[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly&&r.visited[t.y][t.x]==0){\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>      \nusing namespace std;      \nconst int INF = 1 << 30;      \n      \nint W, H;      \nchar mas[20][20];      \nint sy, sx, gy, gx;      \nint cnt;      \nint snow[144];      \nint number[20][20];      \nbool used[20][20];      \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};      \nint ans;      \n      \nint dfs( int x, int y, const int& idx){      \n  if(x < 0 || x >= W || y < 0 || y >= H) return 0;      \n  if(mas[y][x] != 'X') return 0;      \n  if(number[y][x] != -1) return 0;      \n  number[y][x] = idx;      \n  int ret = 1;      \n  for(int i = 0; i < 4; i++){      \n    ret += dfs( x + dx[i], y + dy[i], idx);      \n  }      \n  return ret;      \n}      \nvoid dfs2( int x, int y, int cost){      \n  if(ans <= cost + abs( y - gy) + abs( x - gx)) return;      \n  if(y == gy && x == gx){      \n    ans = min( ans, cost);      \n    return;      \n  }      \n  for(int i = 0; i < 4; i++){      \n    int ny = y + dy[i], nx = x + dx[i];      \n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;      \n    if(mas[ny][nx] == '#' || used[ny][nx]) continue;      \n    if(mas[ny][nx] == 'X'){      \n      if(snow[number[ny][nx]] > 0) snow[number[ny][nx]]--;      \n      else continue;      \n    }      \n    used[ny][nx] = true;      \n    dfs2( nx, ny, cost + 1);      \n    used[ny][nx] = false;      \n    if(mas[ny][nx] == 'X') snow[number[ny][nx]]++;      \n  }      \n  return;      \n}      \n      \nint main(){      \n  while(cin >> W >> H, W){      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        cin >> mas[i][j];      \n        if(mas[i][j] == 'S' || mas[i][j] == 'G'){      \n          if(mas[i][j] == 'S') sy = i, sx = j;      \n          else gy = i, gx = j;      \n          mas[i][j] = '.';      \n        }      \n      }      \n    }      \n    cnt = 0;      \n    memset( number, -1, sizeof number);      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        if(mas[i][j] == 'X' && number[i][j] == -1){      \n          snow[cnt] = dfs( j, i, cnt) / 2;      \n          cnt++;      \n        }      \n      }      \n    }      \n    memset (used, false, sizeof used);      \n    ans = INF;      \n    used[sy][sx] = true;      \n    dfs2(sx,sy,0);      \n    cout << ans << endl;      \n  }      \n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  int prev;\n  Pox(vector<int> array=vector<int>(),int cost=inf,int prev=inf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  printf(\"%d\\n\",pox.cost);\n\t  //cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\n\nint W,H;\nint data[12][12];\nint h[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n\n};\n\ntypedef pair<int,State>PP;\ntypedef pair<int,P>P2;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n/*\nvoid dfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n*/\n\nbool dfs(PP pp,int lim){\n\n   int cnt = pp.first;\n\n\n   State state = pp.second;\n   P p = state.p;\n\n   if(cnt + h[p.first][p.second] - 2 > lim)return false;\n   \n   if(p == g){\n      cout << cnt << endl;\n      return true;\n   }\n   \n   for(int i = 0 ; i < 4 ; i++){\n      P np = P(p.first + dy[i],p.second + dx[i]);\n      if(!check(np))continue;\n      \n      int here = data[np.first][np.second];\n      if(here == wall)continue;\n      if(state.vis[np.first][np.second] < cnt)continue;\n\n      state.p = np;\n\n      int tmp =  state.vis[np.first][np.second];\n      \n      if(here >= 0){\n\n         if(state.v[here] <= mv[here]/2)continue;\n         if(mv[here] == 1)continue;\n         \n         state.v[here]--;\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.v[here]++;\n         state.vis[np.first][np.second] = tmp;\n      }\n      else{\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.vis[np.first][np.second] = tmp;\n      }\n      state.p = p;\n   }\n   return false;\n}\n\n\n\nvoid bfs(){\n   \n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         h[i][j] = INF;\n      }\n   }\n\n   queue<P2>que;\n   que.push(P2(0,g));\n\n   h[g.first][g.second] = 0;\n\n   while(que.size()){\n      P2 p2 = que.front(); que.pop();\n      int cnt = p2.first;\n      P p = p2.second;\n\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] == wall)continue;\n         if(h[np.first][np.second] != INF)continue;\n         h[np.first][np.second] = cnt+1;\n         que.push(P2(cnt+1,np));\n      }\n   }\n}\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n   //bfs();\n   \n   //State state;\n   //state.set(mv,s);\n\n   bfs();\n   \n/*\n   cout << H << ' ' << W << endl;\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         cout << h[i][j];\n      }\n      cout << endl;\n   }\n*/      \n   for(int i = 1 ; ; i++){\n      State state;\n      state.set(mv,s);\n      if(dfs(PP(0,state),i))break;\n   }\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      //cout << \"W = \" << W << \" H = \" << H << endl;//\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    if(step == 0) return NIL;\n    int count = 0;                                                              // 枝刈り４\n    for(const auto& d: NEXT) if(visited[y + d[Y]][x + d[X]]) ++count;           //\n    if(count >= 2) return NIL;                                                  //\n    int result = NIL;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n\n\n\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n    bool operator<(const State& right) const{\n        return d == right.d ? ice > right.ice : d > right.d;\n    }\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        int sy, sx, gy, gx;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        priority_queue<State> que;\n        que.push((State){0,sy,sx,vec(lump_ice_num, 0)});\n        set<string> visited;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            string state_str = state2str(p);\n            if(visited.count(state_str)) continue;\n            visited.insert(state_str);\n            //cout << state_str << endl;\n            if(p.y==gy&&p.x==gx){\n                cout << p.d << endl;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                vec nice = p.ice;\n                if(ny<0||H<=ny||nx<0||W<=nx)continue;\n                if(ifield[ny][nx]==-2)continue;\n                if(ifield[ny][nx]>=0){\n                    int ice_i = ifield[ny][nx];\n                    if(ice_num[ice_i]/2 < nice[ice_i]+1) continue;\n                    nice[ice_i]++;\n                }\n                State np = (State){p.d+1,ny,nx,nice};\n                string nstr = state2str(np);\n                if(visited.count(nstr)==0){\n                    que.push(np);\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,ck[13][13],m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\nvoid chek(int x1,int y1) {\n\tint k;\n\tck[y1][x1]=1;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (ck[y1+dy[k]][x1+dx[k]]==0) chek(x1+dx[k],y1+dy[k]); \n\t\t   \t\t}\n    }\n\nint ans(int x1,int y1,int d) {\n\tint j,k,x2,y2;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tif (d % 3==0) { \n\t\tfor (j=0;j<y;j++) for (k=0;k<x;k++) { ck[j][k]=f[j][k]; if (da[j][k]=='#') ck[j][k]=1;}\n\t\t chek(x1,y1);\n\t\tif (ck[gx][gy]==0 ) return 0;\n\t    }\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = 0;\n    unsigned long long digit = 1;\n    for(int i = 0; i < v.size(); ++i) {result += v[i] * digit; digit *= base;}\n    result += step * digit;\n    result *= 225;\n    result += y + x * 15;\n    return result;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x;\n    vector<int> v;\n    y = n % 15; n /= 15;\n    x = n % 15; n /= 15;\n    for(int i = 0; i < durability.size(); ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 1;\n        if(durability.size()) base = max(base, *max_element(durability.begin(), durability.end()) + 1);\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <string>\n#include <array>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nint ORD, N;\nULL h(const vector<int> &v, int y, int x) {\n    ULL res = 0;\n    for(int i : v) {\n        res *= ORD;\n        res += i;\n    }\n    res *= 12;\n    res += y;\n    res *= 12;\n    res += x;\n    return res;\n}\n\nvoid d(ULL val, vector<int> &v, int &y, int &x) {\n    v.resize(N, 0);\n    x = val % 12;\n    val /= 12;\n    y = val % 12;\n    val /= 12;\n    for(int i = v.size()-1; i >= 0; --i) {\n        v[i] = val % ORD;\n        val /= ORD;\n    }\n}\n\nconst int DY[] = {0, -1, 0, 1};\nconst int DX[] = {1, 0, -1, 0};\n\ninline bool in_range(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nint X, Y;\nint bfs(vector<string> &v, int y, int x, array<array<int,12>,12> &field, int label) {\n    int cnt = 0;\n    queue<pair<int,int>> q;\n    q.push(make_pair(y, x));\n    while(!q.empty()) {\n        int cy = q.front().first;\n        int cx = q.front().second;\n        q.pop();\n        v[cy][cx] = '$';\n        field[cy][cx] = label;\n        ++cnt;\n        for(int i = 0; i < 4; ++i) {\n            const int ny = cy + DY[i];\n            const int nx = cx + DX[i];\n            if(in_range(0, ny, Y) && in_range(0, nx, X) && v[ny][nx] == 'X') {\n                q.push(make_pair(ny, nx));\n            }\n        }\n    }\n    return cnt;\n}\n\nbool solve() {\n    cin >> X >> Y;\n    if(!X && !Y) return false;\n\n    vector<string> v(Y);\n    for(string &s : v) {\n        cin >> s;\n    }\n\n    array<array<int,12>,12> field;\n    pair<int,int> start, goal;\n    vector<int> ice;\n    ice.push_back(0);\n    for(int y = 0; y < Y; ++y) {\n        for(int x = 0; x < X; ++x) {\n            if(v[y][x] == 'X') {\n                int cnt = bfs(v, y, x, field, -(int)ice.size());\n                if(cnt == 1) {\n                    field[y][x] = 0;\n                } else {\n                    ice.push_back(cnt/2);\n                }\n            } else if(v[y][x] == '#') {\n                field[y][x] = 0;\n            } else if(v[y][x] != '$') {\n                field[y][x] = 1;\n                if(v[y][x] == 'S') {\n                    start = make_pair(y, x);\n                } else if(v[y][x] == 'G') {\n                    goal = make_pair(y, x);\n                }\n            }\n        }\n    }\n\n    N = ice.size();\n    ORD = *max_element(ice.begin(), ice.end())+1;\n    vector<int> state(N, 0);\n    vector<ULL> q[2];\n    unordered_set<ULL> memo;\n    q[0].push_back(h(state, start.first, start.second));\n    memo.insert(q[0].back());\n    int turn = 0;\n    while(q[0].size() > 0) {\n        q[1].clear();\n        for(const auto &s : q[0]) {\n            int x, y;\n            d(s, state, y, x);\n            //cout << turn << \": \" << x << ' ' << y << ' ' << \"s \" << state[1] << endl;\n            if(y == goal.first && x == goal.second) {\n                goto end;\n            }\n            for(int i = 0; i < 4; ++i) {\n                const int ny = y + DY[i];\n                const int nx = x + DX[i];\n                if(in_range(0, ny, Y) && in_range(0, nx, X)) {\n                    if(field[ny][nx] < 0) {\n                        const int idx = -field[ny][nx];\n                        if(state[idx] >= ice[idx]) continue;\n                        state[idx]++;\n                        const ULL nh = h(state, ny, nx);\n                        if(memo.count(nh) == 0) {\n                            memo.insert(nh);\n                            q[1].push_back(nh);\n                        }\n                        state[idx]--;\n                    } else if(field[ny][nx] == 1) {\n                        const ULL nh = h(state, ny, nx);\n                        if(memo.count(nh) == 0) {\n                            memo.insert(nh);\n                            q[1].push_back(nh);\n                        }\n                    }\n                }\n            }\n        }\n        ++turn;\n        q[0].swap(q[1]);\n    }\nend:\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {1, -1, 0, 0};\nint dx[] = {0, 0, 1, -1};\n\nvector<string> s;\nint n;                    // 氷の塊の数\nvector<vector<int> > ice; // 各氷の番号\nvector<int> iceNum;       // 各塊の氷の数\nint gy, gx;\nint ret;\n\nvoid solve(int y, int x, int step, vector<vector<bool> >& used, vector<int>& usedIce)\n{\n    if(y == gy && x == gx){\n        ret = step;\n        return;\n    }\n\n    // 明らかに解を更新できなければ終了\n    if(step + abs(y - gy) + abs(x - gx) >= ret)\n        return;\n\n    // ループが発生した場合、より良い解があることが分かるため終了\n    int tmp = 0;\n    for(int i=0; i<4; ++i){\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        if(used[y2][x2])\n            ++ tmp;\n    }\n    if(tmp > 1)\n        return;\n\n    // 氷が割れるかを調べる\n    if(ice[y][x] != -1){\n        if(usedIce[ice[y][x]] + 1 > iceNum[ice[y][x]] / 2)\n            return;\n        ++ usedIce[ice[y][x]];\n    }\n    used[y][x] = true;\n\n    for(int i=0; i<4; ++i){\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        if(used[y2][x2] || s[y2][x2] == '#')\n            continue;\n        solve(y2, x2, step+1, used, usedIce);\n    }\n\n    if(ice[y][x] != -1)\n        -- usedIce[ice[y][x]];\n    used[y][x]= false;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> w >> h;\n        if(h == 0)\n            return 0;\n\n        s.assign(h+2, string(w+2, '#'));\n        int sy, sx;\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> s[i][j];\n                if(s[i][j] == 'S'){\n                    sy = i;\n                    sx = j;\n                }else if(s[i][j] == 'G'){\n                    gy = i;\n                    gx = j;\n                }\n            }\n        }\n\n        n = 0;\n        ice.assign(h+2, vector<int>(w+2, -1));\n        iceNum.clear();\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                if(s[i][j] != 'X' || ice[i][j] != -1)\n                    continue;\n\n                queue<pair<int, int> > q;\n                q.push(make_pair(i, j));\n                ice[i][j] = n;\n                iceNum.push_back(1);\n                while(!q.empty()){\n                    int y0 = q.front().first;\n                    int x0 = q.front().second;\n                    q.pop();\n\n                    for(int k=0; k<4; ++k){\n                        int y = y0 + dy[k];\n                        int x = x0 + dx[k];\n                        if(s[y][x] == 'X' && ice[y][x] == -1){\n                            q.push(make_pair(y, x));\n                            ice[y][x] = n;\n                            ++ iceNum[n];\n                        }\n                    }\n                }\n                ++ n;\n            }\n        }\n\n        ret = INT_MAX;\n        vector<vector<bool> > used(h+2, vector<bool>(w+2, false));\n        used[sy][sx] = true;\n        vector<int> usedIce(n, 0);\n        solve(sy, sx, 0, used, usedIce);\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint h,w;\nchar grid[12][13];\nint ice[12][12],vis[12][12],lim[12*12];\nint gi,gj;\nint res;\n\ninline void dfs(int i,int j,int step)\n{\n\tif(grid[i][j]=='X' && lim[ice[i][j]]==0) return;\n\tif(grid[i][j]=='G') res=min(res,step);\n\tif(step+abs(gi-i)+abs(gj-j)>=res) return;\n\t\n\tvis[i][j]=true;\n\tif(grid[i][j]=='X') lim[ice[i][j]]--;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#' || vis[ni][nj]) continue;\n\t\tdfs(ni,nj,step+1);\n\t}\n\tif(grid[i][j]=='X') lim[ice[i][j]]++;\n\tvis[i][j]=false;\n}\n\nint main()\n{\n\tfor(;cin>>w>>h,w|h;){\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tmemset(ice,-1,sizeof(ice));\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X'){\n\t\t\tif(!f.count(uf.Find(i*w+j)))\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\tice[i][j]=f[uf.Find(i*w+j)];\n\t\t}\n\t\tvi cnt(f.size());\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tcnt[ice[i][j]]++;\n\t\trep(i,cnt.size()) lim[i]=cnt[i]/2;\n\t\t\n\t\tres=INFTY;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='G')\n\t\t\tgi=i,gj=j;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S')\n\t\t\tdfs(i,j,0);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,ck[13][13],m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\n\nint ans(int x1,int y1,int d,int w) {\n\tint k,x2,y2;\n\tif (ck[y1][x1]<=d) return 0;\n\tif (w==0) if (ck[y1][x1]>d) ck[y1][x1]=d;\n\tif (d>=an) return 1;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1,w+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1,w);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) {f[i][j]=0; ck[i][j]=142;}\n\tan=142; ans(sx,sy,0,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\ntypedef pair<int ,int> P;\nint X,Y, sx, sy, gx, gy;\nstring map[20];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}; \n\nvoid ice_lim_cnt(int ice_map[][20], int isx, int isy) {\n  if(ice_map[isy][isx] == 400) {\n    int ice_cnt = 0;\n    queue<P> past;\n    queue<P> que;\n    que.push(P(isx, isy));\n    while(que.size()) {\n      P p = que.front();\n      //      if(p.first == igx && p.second == igy) return;\n      que.pop();\n      for(int i = 0; i < 4; i++) {\n\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\tif(0 <= nx && nx < X && 0 <= ny && ny < Y && map[ny][nx] == 'X' && ice_map[ny][nx] != 0) {\n\t  past.push(P(nx, ny));\n\t  que.push(P(nx,ny));\n\t  ice_cnt++;\n\t  ice_map[ny][nx] = 0;\n\t  //\t  cout << ice_cnt << endl; \n\t  //\t  memo[ny][nx] = memo[p.second][p.first] + 1;\n\t}\n      }\n    }\n    while(past.size()){\n      P p = past.front();\n      past.pop();\n      ice_map[p.second][p.first] = ice_cnt;\n    }\n  }\n}\n\nint bfs(){\n  int ice_map[20][20] ={};\n  int ice_cnt[20][20] ={};\n  int past[20][20] = {};\n\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j< X; j++) {\n      ice_map[i][j] = 400;\n    }\n\n  queue<P> que;\n  int memo[20][20] = {};\n  que.push(P(sx, sy));\n  \n  while(que.size()) {\n    \n    P p = que.front();\n    //    cout <<\"first\" << p.first << \"second\" <<p.second << endl;\n\n    if(p.first == gx && p.second == gy) return memo[p.second][p.first];\n    que.pop();\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(0 <= nx && nx < X && 0 <= ny && ny < Y && map[ny][nx] != '#' && past[ny][nx] == 0) {\n\tif(map[ny][nx] == 'X') {\n\t  ice_lim_cnt(ice_map, nx, ny);\n\t  ice_cnt[ny][nx] = ice_cnt[p.second][p.first] + 1;\n\t  if(ice_cnt[ny][nx] > ice_map[ny][nx] / 2 % 10) continue;\n\t  /*cout << \"ice\" << endl;\n\t    for(int j = 0; j < Y; j++) {\n\t    for(int i = 0; i < X; i++)\n\t    //\t      cout << ice_map[j][i];\n\t    //\t    cout << endl;\n\t    }\n\t    cout << ice_cnt[ny][nx] << ice_cnt[p.second][p.first] <<endl;\n\t    \n\t    cout << \"ice_cnt\" << endl;\n\t    for(int j = 0; j < Y; j++) {\n\t    for(int i = 0; i < X; i++)\n\t    cout << ice_cnt[j][i];\n\t    cout <<endl;\n\t    }*/\n\t}\n\t\n\tpast[ny][nx]++;\n\tmemo[ny][nx] = memo[p.second][p.first] + 1;\n\tque.push(P(nx,ny));\n\t/*\n\t  cout << '1' << endl;\n\t  for(int j = 0; j < Y; j++) {\n\t  for(int i = 0; i < X; i++)\n\t  cout << past[j][i];\n\t  cout << endl;\n\t  \n\t  }*/\n      }\n    }\n  }\n}\n\nint main() {\n  while(cin >> X >> Y, X != 0 || Y != 0) {\n    for(int i = 0; i < Y; i++) {\n      cin >> map[i];\n      for(int j = 0; j < X; j++) \n\tif (map[i][j] == 'S') sx = j, sy = i;\n\telse if(map[i][j] == 'G') gx = j, gy = i;\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\n\nint W,H;\nint data[12][12];\nint h[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n\n};\n\ntypedef pair<int,State>PP;\ntypedef pair<int,P>P2;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n/*\nvoid dfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n*/\n\nbool dfs(PP pp,int lim){\n\n   int cnt = pp.first;\n\n\n   State state = pp.second;\n   P p = state.p;\n\n   if(cnt + h[p.first][p.second] > lim)return false;\n   \n   if(p == g){\n      cout << cnt << endl;\n      return true;\n   }\n   \n   for(int i = 0 ; i < 4 ; i++){\n      P np = P(p.first + dy[i],p.second + dx[i]);\n      if(!check(np))continue;\n      \n      int here = data[np.first][np.second];\n      if(here == wall)continue;\n      if(state.vis[np.first][np.second] < cnt)continue;\n\n      state.p = np;\n\n      int tmp =  state.vis[np.first][np.second];\n      \n      if(here >= 0){\n\n         if(state.v[here] <= mv[here]/2)continue;\n         if(mv[here] == 1)continue;\n         \n         state.v[here]--;\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.v[here]++;\n         state.vis[np.first][np.second] = tmp;\n      }\n      else{\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.vis[np.first][np.second] = tmp;\n      }\n      state.p = p;\n   }\n   return false;\n}\n\n\n\nvoid bfs(){\n   \n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         h[i][j] = INF;\n      }\n   }\n\n   queue<P2>que;\n   que.push(P2(0,g));\n\n   h[g.first][g.second] = 0;\n\n   while(que.size()){\n      P2 p2 = que.front(); que.pop();\n      int cnt = p2.first;\n      P p = p2.second;\n\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] == wall)continue;\n         if(h[np.first][np.second] != INF)continue;\n         h[np.first][np.second] = cnt+1;\n         que.push(P2(cnt+1,np));\n      }\n   }\n}\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n   //bfs();\n   \n   //State state;\n   //state.set(mv,s);\n\n   bfs();\n   \n/*\n   cout << H << ' ' << W << endl;\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         cout << h[i][j];\n      }\n      cout << endl;\n   }\n*/      \n   for(int i = 1 ; ; i++){\n      State state;\n      state.set(mv,s);\n      if(dfs(PP(0,state),i))break;\n   }\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      //cout << \"W = \" << W << \" H = \" << H << endl;//\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 62 == 0))Q.pop();\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    if (step == depth) return false;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0 && !G[sy][sx]) {\n                (*ices[sy][sx])--;\n                G[sy][sx] = true;\n                if (iddfs(sx, sy, step+1)) return true;\n                G[sy][sx] = false;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int empty = 100000;\n        int wall = 0;\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ices[y][x] = &empty;\n                break;\n            case '#':\n                ices[y][x] = &wall;\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((bool *)G, 12*12, false);\n\n        depth = abs(start_x - goal_y) + abs(start_y - goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth++;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n\n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X'){\n\tnum[n] = 0;\n\tgroup(i,j,n);\n\tnum[n]/=2;\n\tn++;\n      }\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    if (step == depth) return false;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0 && !G[sy][sx]) {\n                (*ices[sy][sx])--;\n                G[sy][sx] = true;\n                if (iddfs(sx, sy, step+1)) return true;\n                G[sy][sx] = false;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int empty = 100000;\n        int wall = 0;\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ices[y][x] = &empty;\n                break;\n            case '#':\n                ices[y][x] = &wall;\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((bool *)G, 12*12, false);\n\n        depth = abs(start_x - goal_y) + abs(start_y + goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth++;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>      \nusing namespace std;      \nconst int INF = 1 << 30;      \n      \nint W, H;      \nchar mas[20][20];      \nint sy, sx, gy, gx;      \nint cnt;      \nint snow[144];      \nint number[20][20];      \nbool used[20][20];      \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};      \nint ans;      \n      \nint dfs( int x, int y, const int& idx){      \n  if(x < 0 || x >= W || y < 0 || y >= H) return 0;      \n  if(mas[y][x] != 'X') return 0;      \n  if(number[y][x] != -1) return 0;      \n  number[y][x] = idx;      \n  int ret = 1;      \n  for(int i = 0; i < 4; i++){      \n    ret += dfs( x + dx[i], y + dy[i], idx);      \n  }      \n  return ret;      \n}      \nvoid dfs2( int x, int y, int cost,int prevx, int prevy){      \n  if(ans <= cost + abs( y - gy) + abs( x - gx)) return;      \n  if(y == gy && x == gx){      \n    ans = min( ans, cost);      \n    return;      \n  }      \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n    if(used[ny][nx] && ny != prevy && nx != prevx) return;\n  }\n\n  \n\n  for(int i = 0; i < 4; i++){      \n    int ny = y + dy[i], nx = x + dx[i];      \n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;      \n    if(mas[ny][nx] == '#' || used[ny][nx]) continue;      \n    if(mas[ny][nx] == 'X'){      \n      if(snow[number[ny][nx]] > 0) snow[number[ny][nx]]--;      \n      else continue;      \n    }      \n    used[ny][nx] = true;      \n    dfs2( nx, ny, cost + 1, x, y);      \n    used[ny][nx] = false;      \n    if(mas[ny][nx] == 'X') snow[number[ny][nx]]++;      \n  }      \n  return;      \n}      \n      \nint main(){      \n  while(cin >> W >> H, W){      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        cin >> mas[i][j];      \n        if(mas[i][j] == 'S' || mas[i][j] == 'G'){      \n          if(mas[i][j] == 'S') sy = i, sx = j;      \n          else gy = i, gx = j;      \n          mas[i][j] = '.';      \n        }      \n      }      \n    }      \n    cnt = 0;      \n    memset( number, -1, sizeof number);      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        if(mas[i][j] == 'X' && number[i][j] == -1){      \n          snow[cnt] = dfs( j, i, cnt) / 2;      \n          cnt++;      \n        }      \n      }      \n    }      \n    memset (used, false, sizeof used);      \n    ans = INF;      \n    used[sy][sx] = true;      \n    dfs2(sx,sy,0,sx,sy);      \n    cout << ans << endl;      \n  }      \n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\ttypedef pair<char,char> pcc;\n\t\ttypedef vector<unsigned char> vuc;\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvuc c;\n\t\t\tState(int i,int j,int d,const vuc& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\t\n\t\tdump(sizeof(State));\n\t\tqueue<State> q;\n\t\tq.emplace(s.first,s.second,0,vuc(f.size()));\n\t\tset<pair<pcc,vuc>> memo;\n\t\twhile(!q.empty()){\n\t\t\tState cur=q.front(); q.pop();\n\t\t\t\n\t\t\titer(memo) it=memo.find(mp(mp(cur.i,cur.j),cur.c)); \n\t\t\tif(it!=memo.end()) continue;\n\t\t\tmemo.insert(mp(mp(cur.i,cur.j),cur.c));\n\t\t\t\n\t\t\tif(pii(cur.i,cur.j)==g){\n\t\t\t\tcout<<cur.d<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tvuc nc=cur.c;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tnc[p]++;\n\t\t\t\t\tif(2*nc[p]>cnt[p])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.emplace(ni,nj,cur.d+1,nc);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[12][13],gy,gx;\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // 氷を踏んだ回数\nvoid dfs(int i,int j,int now){\n\tif(ans<now+abs(i-gy)+abs(j-gx) || ans==now) return; // Manhattan 距離で A*\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tif(B[i][j]=='X'){\n\t\tif(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\t\tstep[ice[i][j]]++;\n\t}\n\n\tvis[i][j]=true;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]){\n\t\t\t// これまでに通った道から (y,x) にショートカットして来れる場合は枝刈り\n\t\t\tbool ok=true;\n\t\t\trep(l,4) if((k-l+4)%4!=2) {\n\t\t\t\tint yy=y+dy[l],xx=x+dx[l];\n\t\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && vis[yy][xx]) ok=false;\n\t\t\t}\n\t\t\tif(ok) dfs(y,x,now+1);\n\t\t}\n\t}\n\tvis[i][j]=false;\n\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t}\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {1,0,-1,0};\nconst int dj[] = {0,1,0,-1};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<char> v;\n  S(int py,int px,vector<char> pv):y(py),x(px),v(pv){\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<char>(nid));\n    set<vector<char> > mem[12][12];\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(!mem[e.y][e.x].insert(e.v).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n      v[i].clear();\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n\n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X'){\n\tnum[n] = 0;\n\tgroup(i,j,n);\n\tnum[n]/=2;\n\tn++;\n      }\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif ((x1==gx && y1==gy) || d>=an) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t if (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4 ;j++) z+=c[y2+dy[j]][x2+dx[j]];   \n\t\t\t\t\tif (z<2) {\n\t\t\t\t\tfor (j=0;j<4;j++) {if (da[y2+dy[j]][x2+dx[j]]!='#' && m[y2+dy[j]][x2+dx[j]]<0 && c[y2+dy[j]][x2+dx[j]]==0)\n                       if (c[y2+dy[j]*2][x2+dx[j]*2]==1) z=2;}\n                    if (z<2) {    \t\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=0;j<=x+1;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\nint gx,gy;\n\nint ans = 0;\nint ccc = 0;\nvoid dfs(int x,int y,int C,int px,int py){\n  if( c[y][x] == '#' || c[y][x] == '*') return;\n  if( C + abs(x-gx) + abs(y-gy) >= ans ) return;\n  if( c[y][x] == 'G'){\n    ans = C;\n    return;\n  }\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( px == tx && ty == py ) continue;\n    if( c[ty][tx] == '*' ) return;\n  }\n  char cur = c[y][x];\n  c[y][x] = '*';\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( c[ty][tx] == 'X' ){\n      int b = belong[ty][tx];\n      if( ok[b] > 0 ){\n\tok[b]--;\n\tdfs(tx,ty,C+1,x,y);\n\tok[b]++;\n      }\n    }else{\n      dfs(tx,ty,C+1,x,y);\n    }\n  }\n  c[y][x] = cur;\n  return;\n}\nvoid grouping(int x,int y,int k){\n  if( c[y][x] != 'X') return;\n  if( belong[y][x] != -1 ) return;\n  belong[y][x] = k;\n  ccc++;\n  for(int i = 0 ; i < 4 ; i++)\n    grouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  int W,H;\n  while(cin >> W >> H && W){\n    rep(i,14)rep(j,14) belong[i][j] = -1;\n    rep(i,14)rep(j,14) \n      c[i][j] = '#';\n    int sx , sy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> c[i+1][j+1];\n\tif(c[i+1][j+1] == 'S'){\n\t  c[i+1][j+1] = '.';\n\t  sx = j+1 , sy = i+1;\n\t}else if(c[i+1][j+1] == 'G' ){\n\t  gx = j+1 , gy = i+1;\n\t}\n      }\n    }\n    int k = 0;\n    for(int i = 1 ; i <= H ; i++){\n      for(int j = 1 ; j <= W ; j++){\n\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t  ccc = 0;\n\t  grouping(j,i,k);\n\t    ok[k] = ccc / 2;\n\t    k++;\n\t}\n      }\n    }\n    ans = 1e7;\n    dfs(sx,sy,0,-1,-1);\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint distance(int y, int x) {return abs(gy - y) + abs(gx - x);}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    if(step == 0) return NIL;\n    if(distance(y, x) > step) return NIL;\n    int result = NIL;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nbool visited[12][12];\nint visited_ice[12*12];\nint ans;\nint sy, sx, gy, gx;\nvoid dfs2(int y, int x, int py, int px, int d){\n    //printf(\"%d %d\\n\",y,x);\n    if(y==gy&&x==gx){\n        ans = min(d, ans);\n        return;\n    }\n    if(d + abs(gy-y) + abs(gx-x) >= ans) return;\n    /*for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(ny==py&&nx==px)continue;\n        if(visited[ny][nx]) return;\n    }*/\n    visited[y][x] = true;\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        //printf(\"y=%d x=%d ny=%d nx=%d\\n\", y, x, ny, nx);\n        if(visited[ny][nx])continue;\n        if(ifield[ny][nx]==-2)continue;\n        if(ifield[ny][nx]>=0){\n            int ice_i = ifield[ny][nx];\n            if(ice_num[ice_i]/2 < visited_ice[ice_i]+1) continue;\n            visited_ice[ice_i]++;\n            dfs2(ny, nx, y, x, d+1);\n            visited_ice[ice_i]--;\n        }else{\n            dfs2(ny, nx, y, x, d+1);\n        }\n    }\n    visited[y][x] = false;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        ans = INF;\n        memset(visited, 0, sizeof(visited));\n        memset(visited_ice, 0, sizeof(visited_ice));\n        dfs2(sy, sx, -1, -1, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\tcin>>lx>>ly;\n\t\tif(lx==0&&ly==0){\n\t\t\tbreak;\n\t\t}\n\t\tnc=1;\n\t\tmemset(maps,0,sizeof(maps));\n\t\tmemset(ig,0,sizeof(ig));\n\t\tmin=144;\n\tfor(i=0;i<ly;i++){\n\t\tcin>>map[i];\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(map[i][j]=='S'){\n\t\t\t\tr.x=j;\n\t\t\t\tr.y=i;\n\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\tr.cnt=0;\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\tv.x=j;\n\t\t\t\tv.y=i;\n\t\t\t\tq.push(v);\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tv=q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tu=v;\n\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(maps[i][j]>0){\n\t\t\t\tig[maps[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!s.empty()){\n\t\tr=s.top();\n\t\ts.pop();\n\t\tif(r.visited[r.y][r.x]==1){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tr.visited[r.y][r.x]=1;\n\t\t}\n\t\tif(r.cnt>=min){\n\t\t\tcontinue;\n\t\t}\n\t\tif(map[r.y][r.x]=='G'&&r.cnt<min){\n\t\t\tmin=r.cnt;\n\t\t\tcontinue;\n\t\t}\n\t\tif(maps[r.y][r.x]>0){\n\t\t\ta=maps[r.y][r.x];\n\t\t\tr.ic[a]++;\n\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tt=r;\n\t\t\tt.x+=mx[i];\n\t\t\tt.y+=my[i];\n\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\tt.cnt++;\n\t\t\t\ts.push(t);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nint H,W;\nint sy,sx,gy,gx;\nchar field[101][101];\nint ice;\nint iceNumber[101][101];\n// iceごとのタイル数\nint tileNum[101];\nbool used[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nint predic[101][101];\n\n// 状態に必要なもの\n// ここまでのコスト\n// どのiceを何度踏んだか(vectorでもつ)\ntypedef pair<pii,vector<int> > Info;\ntypedef pair<int,pair<pii,vector<int> > > Sit;\n\n// 氷を踏む回数を無視したときのgoalからの最短距離\nvoid bfs(){\n  queue<pii> q;\n  memset(predic,-1,sizeof(predic));\n  q.push(pii(gy,gx));\n  predic[gy][gx]=0;\n  while(q.size()){\n    pii p=q.front();q.pop();\n    int cy=p.first;\n    int cx=p.second;\n    int ccost=predic[cy][cx];\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&predic[ny][nx]==-1\n\t &&field[ny][nx]!='#'){\n\tint ncost=ccost+1;\n\tpredic[ny][nx]=ncost;\n\tq.push(pii(ny,nx));\n      }\n    }\n  }\n}\n\nint astar(){\n  priority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n  map<Info,int> d;\n  vector<int> sv(ice,0);\n  d[(make_pair(pii(sy,sx),sv))]=predic[sy][sx];\n  pq.push(Sit(predic[sy][sx],make_pair(pii(sy,sx),sv)));\n  int res=10000000;\n  while(pq.size()){\n    Sit p=pq.top();pq.pop();\n    int cy=p.second.first.first;\n    int cx=p.second.first.second;\n    int ccost=p.first;\n    vector<int> ctile=p.second.second;\n    if(d.count(p.second)>0&&ccost>d[p.second])continue;\n    int realCost=ccost-predic[cy][cx];\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n\tvector<int> ntile=ctile;\n\tint ncost=(realCost+1)+predic[ny][nx];\n\tInfo ninfo=p.second;\n\tninfo.first.first=ny;\n\tninfo.first.second=nx;\n\tif(field[ny][nx]=='X'){\n\t  int a=iceNumber[ny][nx];\n\t  ninfo.second[a]++;\n\t  if(ninfo.second[a]>tileNum[a]/2)continue;\n\t}\n\tif(d.count(ninfo)==0||d[ninfo]>ncost){\n\t  d[ninfo]=ncost;\n\t  pq.push(make_pair(ncost,ninfo));\n\t  if(gy==ny&&gx==nx)res=min(res,ncost);\n\t}\n      }\n    }\n  }\n  return res;\n}\n\nint labelling(int cy,int cx,int k){\n  int cnt=1;\n  used[cy][cx]=true;\n  iceNumber[cy][cx]=k;\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&!used[ny][nx]&&field[ny][nx]=='X')\n      cnt+=labelling(ny,nx,k);\n  }\n  return cnt;\n}\n\nint main(){\n  while(cin>>W>>H&&(H|W)){\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>field[i][j];\n\tif(field[i][j]=='S'){\n\t  sy=i;sx=j;\n\t  field[i][j]='.';\n\t}\n\telse if(field[i][j]=='G'){\n\t  gy=i;gx=j;\n\t  field[i][j]='.';\n\t}\n      }\n    }\n    ice=0;\n    memset(used,0,sizeof(used));\n    memset(iceNumber,-1,sizeof(iceNumber));\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tif(!used[i][j]&&field[i][j]=='X'){\n\t  tileNum[ice]=labelling(i,j,ice);\n\t  ice++;\n\t}\n    bfs();\n    int res=astar();\n    cout<<res<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nuc ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)\n    {\n      ice[j+i*w] = inf;\n      ice_cnt[j+i*w] = cinf;\n    }\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      \n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      \n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    if (step == depth) return false;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0) {\n                (*ices[sy][sx])--;\n                if (iddfs(sx, sy, step+1)) return true;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ice[y][x] = 1;\n                ices[y][x] = &ice[y][x];\n                break;\n            case '#':\n                ices[y][x] = &ice[y][x];\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ice[y][x] = 1;\n                ices[y][x] = &ice[y][x];\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ice[y][x] = 1;\n                ices[y][x] = &ice[y][x];\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((bool *)G, 12*12, false);\n        depth = abs(start_x - goal_x) + abs(start_y - goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth++;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define INF 1 << 15\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy,ex,ey;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tint mapc[13][13];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tmemset(mapc,-1,sizeof(mapc));\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\t\tmapc[i][j]=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\t\n\t\t\t\tif(mapc[t.y][t.x]>r.cnt+1||mapc[t.y][t.x]==-1){\n\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(mapc[t.y][t.x]=<r.cnt){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tex=t.x;\n\t\t\t\t\tey=t.y;\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(r.visited[t.y][t.x]==0){\n\t\t\t\t\t\n\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<mapc[ey][ex]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (10000)\n\nusing namespace std;\n\ntypedef unsigned short us;\n\nstruct Pox\n{\n  vector<us> array;\n  int cost;\n  us prev;\n  Pox(vector<us> array=vector<us>(),int cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<us> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<us> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<us> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\nvector<int> rn[24];\n\nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n\tif( c[y][x] == '#' || c[y][x] == '*') return 0;\n\tif( C >= ans ) return 0;\n\tif( c[y][x] == 'G'){\n\t\tans = C;\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( px == tx && ty == py ) continue;\n\t\tif( c[ty][tx] == '*' ) return 0;\n\t}\n\tchar cur = c[y][x];\n\tc[y][x] = '*';\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[rn[(x*7+y*13+C*17)%24][i]];\n\t\tint ty = y + dy[rn[(x*7+y*13+C*17)%24][i]]\t;\n\t\tif( c[ty][tx] == 'X' ){\n\t\t\tint b = belong[ty][tx];\n\t\t\tif( ok[b] > 0 ){\n\t\t\t\tok[b]--;\n\t\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t\t\tok[b]++;\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t}\n\t}\n\tc[y][x] = cur;\n\treturn 0;\n}\nint grouping(int x,int y,int k){\n\tif( c[y][x] != 'X') return 0;\n\tif( belong[y][x] != -1 ) return 0;\n\tbelong[y][x] = k;\n\tccc++;\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tgrouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint W,H;\n\tint rng[] = {0,1,2,3} , ww = 0;\n\trep(i,24) rn[i].resize(4);\n\tdo{\n\t\tfor(int i = 0 ; i < 4 ; i++)\n\t\t\trn[ww][i] = rng[i];\n\t\tww++;\n\t}while(next_permutation(rng,rng+4));\n\tsrand(time(NULL));\n\twhile(cin >> W >> H && W){\n\t\trandom_shuffle(rn,rn+24);\n\t\trep(i,14)rep(j,14) belong[i][j] = -1;\n\t\trep(i,14)rep(j,14) \n\t\t\tc[i][j] = '#';\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif(c[i+1][j+1] == 'S'){\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t\tsx = j+1 , sy = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t\t\t\t\tccc = 0;\n\t\t\t\t\tgrouping(j,i,k);\n\t\t\t\t\tok[k] = ccc / 2;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e7;\n\t\tdfs(sx,sy,0,-1,-1);\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\nint gx,gy;\n\nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n\tif( c[y][x] == '#' || c[y][x] == '*') return 0;\n\tif( C + abs(x-gx) + abs(y-gy) >= ans ) return 0;\n\tif( c[y][x] == 'G'){\n\t\tans = C;\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( px == tx && ty == py ) continue;\n\t\tif( c[ty][tx] == '*' ) return 0;\n\t}\n\tchar cur = c[y][x];\n\tc[y][x] = '*';\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( c[ty][tx] == 'X' ){\n\t\t\tint b = belong[ty][tx];\n\t\t\tif( ok[b] > 0 ){\n\t\t\t\tok[b]--;\n\t\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t\t\tok[b]++;\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t}\n\t}\n\tc[y][x] = cur;\n\treturn 0;\n}\nint grouping(int x,int y,int k){\n\tif( c[y][x] != 'X') return 0;\n\tif( belong[y][x] != -1 ) return 0;\n\tbelong[y][x] = k;\n\tccc++;\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tgrouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint W,H;\n\twhile(cin >> W >> H && W){\n\t\trep(i,14)rep(j,14) belong[i][j] = -1;\n\t\trep(i,14)rep(j,14) \n\t\t\tc[i][j] = '#';\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif(c[i+1][j+1] == 'S'){\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t\tsx = j+1 , sy = i+1;\n\t\t\t\t}else if(c[i+1][j+1] == 'G' ){\n\t\t\t\t\tgx = j+1 , gy = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t\t\t\t\tccc = 0;\n\t\t\t\t\tgrouping(j,i,k);\n\t\t\t\t\tok[k] = ccc / 2;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e7;\n\t\tdfs(sx,sy,0,-1,-1);\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\n#include <bitset>\n#include <set>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nset<long long> visited[12][12];\nvector<int> icesq;\n\nstruct data {\n\tint x, y;\n\tint t;\n\tlong long v;\n\tdata(int x_, int y_, int t_, long long v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tq.push(data(S.se, S.fi, 0, 0));\n\t\tvector<long long> radix;\n\t\tradix.resize(icesq.size() + 1);\n\t\tradix[0] = 1;\n\t\tfor(int i = 1; i < radix.size(); i++) {\n\t\t\tradix[i] = radix[i-1] * (icesq[i-1] + 1);\n\t\t}\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\tfor(int j = 0; j < 12; j++) {\n\t\t\t\tvisited[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvisited[S.fi][S.se].insert(0LL);\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(visited[ny-1][nx-1].find(cur.v) == visited[ny-1][nx-1].end()) {\n\t\t\t\t\t\tvisited[ny-1][nx-1].insert(cur.v);\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X') {\n\t\t\t\t\tlong long flgcnts;\n\t\t\t\t\tflgcnts = (cur.v % radix[ice[ny][nx]+1]) / radix[ice[ny][nx]];\n\t\t\t\t\tif(flgcnts < icesq[ice[ny][nx]]) {\n\t\t\t\t\t\tlong long tmp = cur.v + radix[ice[ny][nx]];\n\t\t\t\t\t\tif(visited[ny-1][nx-1].find(tmp) == visited[ny-1][nx-1].end()) {\n\t\t\t\t\t\t\tvisited[ny-1][nx-1].insert(tmp);\n\t\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\n\nint ans(int x1,int y1,int d) {\n\tint k,x2,y2;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(fromG[ni][nj], make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[12][13],gy,gx;\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // ツ氷ツづーツ督・ツづアツつセツ嘉アツ青?\nvoid dfs(int i,int j,int now){\n\tif(ans<=now+abs(i-gy)+abs(j-gx)) return; // Manhattan ツ仰猟猟」ツづ?A*\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tif(B[i][j]=='X'){\n\t\tif(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\t\tstep[ice[i][j]]++;\n\t}\n\n\tvis[i][j]=true;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]){\n\t\t\t// ツつアツづェツづ慊づ?づ可津環づ?つスツ督ケツつゥツづァ (y,x) ツづ可シツδ?ーツトツカツッツトツつオツづ?猟按づェツづゥツ湘ェツ債?づ債枝ツ環?づィ\n\t\t\tbool ok=true;\n\t\t\trep(l,4) if((k-l+4)%4!=2) {\n\t\t\t\tint yy=y+dy[l],xx=x+dx[l];\n\t\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && vis[yy][xx]) ok=false;\n\t\t\t}\n\t\t\tif(ok) dfs(y,x,now+1);\n\t\t}\n\t}\n\tvis[i][j]=false;\n\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t}\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nuc ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)\n    {\n      ice[j+i*w] = inf;\n      ice_cnt[j+i*w] = cinf;\n    }\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  uc cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      \n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      \n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++))mincost.clear();\n\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n      if(cnt >= 100 && cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 6)\n\t{\n\t  Pox store[5];\n\t  store[0] = pox;\n\t  rep(i,4)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,5)Q.push(store[i]);\n\t}\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<sstream>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nstring encode(int y, int x, const vector<int>& v, int step) {\n    stringstream ss;\n    ss << y << \" \" << x;\n    for(const auto& i: v) {ss << \" \" << i;}\n    ss << \" \" << step;\n    return ss.str();\n}\n\nVertex decode(string s) {\n    stringstream ss(s);\n    int y, x, step;\n    vector<int> v(durability.size());\n    ss >> y >> x;\n    for(auto& i: v) ss >> i;\n    ss >> step;\n    return Vertex(y, x, v, step);\n}\n\nint bfs() {\n    set<string> visited;\n    queue<string> q;\n    q.push(encode(sy, sx, durability, 0));\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        string memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 0;\n        if(durability.size()) base = max(base, *max_element(durability.begin(), durability.end()) + 1);\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nint W,H,SX,SY,GX,GY,ice_N;\nint field[14][14],ice[14][14],icelife[1000];\nbool flag[14][14];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid dfs(int x, int y);\nbool iddfs(int x, int y, int c);\nint main(){\n  while(cin >>W>>H,W||H){\n    for(int i=0; i<14; i++){for(int j=0; j<14; j++){field[i][j] = 1;flag[i][j] = true;}}\n    memset(ice,0,sizeof(ice));\n    memset(icelife,0,sizeof(icelife));\n    ice_N = 1;\n    string s;\n    int ans;\n    for(int i=1; i<=H; i++){\n      cin >>s;\n      for(int j=1; j<=W; j++){\n\tif(s[j-1] == '.'){field[j][i] = 0;}\n\tif(s[j-1] == '#'){field[j][i] = 1;}\n\tif(s[j-1] == 'X'){field[j][i] = 2;}\n\tif(s[j-1] == 'S'){field[j][i] = 0;SX = j;SY = i;}\n\tif(s[j-1] == 'G'){field[j][i] = 0;GX = j;GY = i;}\n      }\n    }\n    for(int i=1; i<=W; i++){\n      for(int j=1; j<=H; j++){\n\tif(field[i][j] == 2 && ice[i][j] == 0){\n\t  dfs(i,j);\n\t  icelife[ice_N]/=2;\n\t  ice_N++;\n\t}\n      }\n    }\n    for(ans = abs(SX-GX)+abs(SY-GY);;ans++){\n      if(iddfs(SX,SY,ans)){cout <<ans<<endl;break;}\n    }\n  }\n  return 0;\n}\nvoid dfs(int x, int y){\n  ice[x][y] = ice_N;\n  icelife[ice_N]++;\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(field[p][q] == 2 && ice[p][q] == 0){dfs(p,q);}\n  }\n}\nbool iddfs(int x, int y, int c){\n  bool f = false;\n  if(x == GX && y == GY){return true;}\n  if(c<abs(x-GX)+abs(y-GY)){return false;}\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    bool next = false;\n    for(int j=0; j<4; j++){\n      int pp = p+dx[j],qq = q+dy[j];\n      if(pp!=x||qq!=y){if(!flag[pp][qq]){next = true;}}\n    }\n    if(next){continue;}\n    if(flag[p][q]){\n      if(field[p][q] == 0){\n\tflag[p][q] = false;\n\tif(iddfs(p,q,c-1)){f = true;}\n\tflag[p][q] = true;\n      }\n      if(field[p][q] == 2){\n\tif(icelife[ice[p][q]]>0){\n\t  flag[p][q] = false;\n\t  icelife[ice[p][q]]--;\n\t  if(iddfs(p,q,c-1)){f = true;}\n\t  icelife[ice[p][q]]++;\n\t  flag[p][q] = true;\n\t}\n      }\n    }\n  }\n  return f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring g[20];\nvector<int> cnt;\nint num[200],n;\nint ice[20][20];\nint sy,sx;\nbool vis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x){\n  if(g[y][x] == 'G')return 0;\n  if(memo.find(cnt)!=memo.end())return memo[cnt];\n  vis[y][x] = true;\n\n  int res = 200;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx) + 1);\n      cnt[curg]--; cnt[n] = y; cnt[n+1] = x;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx) + 1);\n      cnt[n] = y; cnt[n+1] = x;\n    }\n  }\n  vis[y][x] = false;\n\n  if(memo.size()<=100000)memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n    }\n    /*\n    rep(i,h){rep(j,w)cout << ice[i][j] << \" \";cout << endl;}\n    rep(i,n)cout << num[i] << \" \";cout << endl;\n    */\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    cout << dfs(sy,sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\nvector<int> rn[24];\n\nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n\tif( c[y][x] == '#' || c[y][x] == '*') return 0;\n\tif( C >= ans ) return 0;\n\tif( c[y][x] == 'G'){\n\t\tans = C;\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( px == tx && ty == py ) continue;\n\t\tif( c[ty][tx] == '*' ) return 0;\n\t}\n\tchar cur = c[y][x];\n\tc[y][x] = '*';\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[rn[(x*7+y*13+C*17)%24][i]];\n\t\tint ty = y + dy[rn[(x*7+y*13+C*17)%24][i]]\t;\n\t\tif( c[ty][tx] == 'X' ){\n\t\t\tint b = belong[ty][tx];\n\t\t\tif( ok[b] > 0 ){\n\t\t\t\tok[b]--;\n\t\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t\t\tok[b]++;\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t}\n\t}\n\tc[y][x] = cur;\n\treturn 0;\n}\nint grouping(int x,int y,int k){\n\tif( c[y][x] != 'X') return 0;\n\tif( belong[y][x] != -1 ) return 0;\n\tbelong[y][x] = k;\n\tccc++;\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tgrouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint W,H;\n\tint rng[] = {0,1,2,3} , ww = 0;\n\trep(i,24) rn[i].resize(4);\n\tdo{\n\t\tfor(int i = 0 ; i < 4 ; i++)\n\t\t\trn[ww][i] = rng[i];\n\t\tww++;\n\t}while(next_permutation(rng,rng+4));\n\tsrand(time(NULL));\n\twhile(cin >> W >> H && W){\n\t\trandom_shuffle(rn,rn+24);\n\t\trep(i,14)rep(j,14) belong[i][j] = -1;\n\t\trep(i,14)rep(j,14) \n\t\t\tc[i][j] = '#';\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif(c[i+1][j+1] == 'S'){\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t\tsx = j+1 , sy = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t\t\t\t\tccc = 0;\n\t\t\t\t\tgrouping(j,i,k);\n\t\t\t\t\tok[k] = ccc / 2;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e7;\n\t\tdfs(sx,sy,0,-1,-1);\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\nint w, h, sx, sy, gx, gy;\nchar c[16][16];\nint f[16][16];\nvector<int> limit;\n\nvoid mark_ice(int _x, int _y)\n{\n\tint size = 0;\n\tint id = limit.size();\n\n\tqueue<pint> q;\n\tq.push(pint(_x, _y));\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second;\n\t\tq.pop();\n\n\t\tf[y][x] = id;\n\t\t++size;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (valid_pos(nx, ny, w, h) && c[ny][nx] == 'X' && f[ny][nx] == -1)\n\t\t\t\tq.push(pint(nx, ny));\n\t\t}\n\t}\n\n\tlimit.push_back((size + 2) / 2);\n}\n\nint res;\nint walk[256];\nbool visit[16][16];\nvoid dfs(int x, int y, int dis)\n{\n\tif (abs(x - gx) + abs(y - gy) + dis >= res)\n\t\treturn;\n\telse if (x == gx && y == gy)\n\t{\n\t\tres = dis;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (valid_pos(nx, ny, w, h) && !visit[ny][nx] && f[ny][nx] != -1)\n\t\t{\n\t\t\tint id = f[ny][nx];\n\t\t\t++walk[id];\n\t\t\tif (walk[id] < limit[id])\n\t\t\t{\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tdfs(nx, ny, dis + 1);\n\t\t\t\tvisit[ny][nx] = false;\n\t\t\t}\n\t\t\t--walk[id];\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> w >> h, w)\n\t{\n\t\tlimit.clear();\n\t\tCL(visit, 0);\n\t\tCL(f, -1);\n\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> c[i];\n\n\t\tlimit.push_back(114514);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (strchr(\"SG.\", c[y][x]))\n\t\t\t\t\tf[y][x] = 0;\n\n\t\t\t\tif (c[y][x] == 'S')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (c[y][x] == 'G')\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t\telse if (c[y][x] == 'X' && f[y][x] == -1)\n\t\t\t\t\tmark_ice(x, y);\n\t\t\t\telse if (c[y][x] == '#')\n\t\t\t\t\tf[y][x] = -1;\n\t\t\t}\n\t\t}\n\n\t\tres = 114514;\n\t\tvisit[sy][sx] = true;\n\t\tdfs(sx, sy, 0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[15][15];\npair<int,int> par[15][15];\nint sz[15][15];\nint now[15][15];\nint v[15][15];\nint tr,tc;\nint H,W;\nvoid dfs0(int a,int b){\n\tpar[a][b]=make_pair(tr,tc);\n\tsz[tr][tc]++;\n\tv[a][b]=1;\n\tif(a&&str[a-1][b]=='X'&&!v[a-1][b])dfs0(a-1,b);\n\tif(b&&str[a][b-1]=='X'&&!v[a][b-1])dfs0(a,b-1);\n\tif(a<H-1&&str[a+1][b]=='X'&&!v[a+1][b])dfs0(a+1,b);\n\tif(b<W-1&&str[a][b+1]=='X'&&!v[a][b+1])dfs0(a,b+1);\n}\nint res;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint used[15][15];\nint gr,gc;\nint ABS(int a){return max(a,-a);}\nint dfs(int a,int b,int c){\n\tif(str[a][b]=='G'){\n\t\treturn 1;\n\t}\n\tif(c==0)return 0;\n\tif(ABS(gr-a)+ABS(gc-b)>c)return 0;\n\tfor(int i=0;i<4;i++){\n\t\tint nr=a+dx[i];\n\t\tint nc=b+dy[i];\n\t\tif(nr<0||nr>=H||nc<0||nc>=W)continue;\n\t\tif(used[nr][nc])continue;\n\t\tif(str[nr][nc]=='#')continue;\n\t\tif(nr&&nc&&used[nr-1][nc-1]&&used[nr-1][nc]&&used[nr][nc-1])continue;\n\t\tif(nr&&nc<W-1&&used[nr-1][nc]&&used[nr-1][nc+1]&&used[nr][nc+1])continue;\n\t\tif(nr<H-1&&nc&&used[nr][nc-1]&&used[nr+1][nc]&&used[nr+1][nc-1])continue;\n\t\tif(nr<H-1&&nc<W-1&&used[nr][nc+1]&&used[nr+1][nc]&&used[nr+1][nc+1])continue;\n\t\tif(str[nr][nc]=='X'){\n\t\t\tint row=par[nr][nc].first;\n\t\t\tint col=par[nr][nc].second;\n\t\t\tif((now[row][col]+1)*2>sz[row][col])continue;\n\t\t\tnow[row][col]++;\n\t\t\tused[nr][nc]=1;\n\t\t\tif(dfs(nr,nc,c-1))return 1;\n\t\t\tused[nr][nc]=0;\n\t\t\tnow[row][col]--;\n\t\t}else{\n\t\t\tused[nr][nc]=1;\n\t\t\tif(dfs(nr,nc,c-1))return 1;\n\t\t\tused[nr][nc]=0;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)v[i][j]=now[i][j]=sz[i][j]=used[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='X'&&!v[i][j]){\n\t\t\t\ttr=i;tc=j;\n\t\t\t\tdfs0(i,j);\n\t\t\t}\n\t\t}\n\t\tres=99999;\n\t//\tint ret;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='G'){gr=i;gc=j;}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='S'){\n\t\t\tfor(int k=0;;k++){\n\t\t\t\t//res=0;\n\t\t\t\tres=dfs(i,j,k);\n\t\t\t\tif(res){\n\t\t\t\t\tprintf(\"%d\\n\",k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \nint ans;\nint W, H;\n \nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n \nint maxIce[128];\n \nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n \nint sx, sy, gx, gy;\nint px, py;\n \nvoid getMin(int ty, int tx, int *ice, int turn)\n{\n     \n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n        return;\n    }\n     \n    if (ty == gy && tx == gx){\n        ans = turn;\n        return;\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return;\n        }\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        px = tx, py = ty;\n        if (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                getMin(my, mx, ice, turn + 1);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                getMin(my, mx, ice, turn + 1);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n}\n \nvoid label(int ty, int tx, int p)\n{\n    g[ty][tx] = p;\n    maxIce[p]++;\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n         \n        if (0 <= mx && mx < W && 0 <= my && my < H &&\n                    map[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n \nint main()\n{\n    int idx;\n     \n    while (1){\n        scanf(\"%d %d\", &W, &H);\n         \n        if (W + H == 0){\n            break;\n        }\n         \n        for (int i = 0; i < H; i++){\n            scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'S'){\n                    map[i][j] = '.';\n                    sx = j, sy = i;\n                }\n                if (map[i][j] == 'G'){\n                    map[i][j] = '.';\n                    gx = j, gy = i;\n                }\n            }\n        }\n         \n        memset(g, -1, sizeof(g));\n        memset(maxIce, 0, sizeof(maxIce));\n         \n        idx = 0;\n        for (int i = 0; i < H; i++){\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'X' && g[i][j] == -1){\n                    label(i, j, idx);\n                    maxIce[idx++] /= 2;\n                }\n            }\n        }\n         \n        int use[128];\n         \n        memset(use, 0, sizeof(use));\n        memset(v, 0, sizeof(v));\n        px = py = -1;\n        v[sy][sx] = true;\n        ans = W * H;\n        getMin(sy, sx, use, 0);\n         \n        printf(\"%d\\n\", ans);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nconst int ROOM = -1;\nconst int WALL = -2;\nconst int ICE = -3;\n\nconst int MI_X = 13;\nconst int MI_Y= 13;\n\nconst int ANGLE_KIND = 4;//4方向\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint maxx,maxy;//フィールドの大きさ\n\nvector<int>icePow;//氷の耐久力を保存（各フィールドの値はこの要素の値\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int _x,int _y):x(_x),y(_y){}\n\tPoint():x(0),y(0){}\n};\n\n\nPoint start;\nPoint gool;\n\nint minField[MI_Y][MI_X];\n\n//iceP iceの位置を保存する\nvoid IceSet(int field[MI_Y][MI_X],Point fP,vector<Point>& iceP)//わたすのは現在のice\n{\n\ticeP.push_back(fP);\n\tfield[fP.y][fP.x] = icePow.size();\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(fP.x+dx[i],fP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == ICE)\n\t\t\tIceSet(field,p,iceP);\n\t}\n\treturn;\n}\n\nvoid Serch(const int field[MI_Y][MI_X],Point sP,int sField[MI_Y][MI_X],int count,vector<int> icePower)\n{\n\tif(count > minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tif(abs(gool.y - sP.y) + abs(gool.x - sP.x) + count >= minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tsField[sP.y][sP.x] = count;\n\t/*cout << endl << endl;\n\tfor(int y=0;y<maxy;++y)\n\t{\n\t\tfor(int x=0;x<maxx;++x)\n\t\t{\n\t\t\tcout << sField[y][x] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tif(field[sP.y][sP.x] >= 0)\n\t\t--icePower[field[sP.y][sP.x]];\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(sP.x+dx[i],sP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == WALL)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] >= 0)\n\t\t\tif(icePower[field[p.y][p.x]] <= 0)//氷がパリーン！\n\t\t\t\tcontinue;\n\t\t\telse if ( sField[p.y][p.x] > count+1)\n\t\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\tif(sField[p.y][p.x] == -1 || sField[p.y][p.x] > count+1)//記録更新！\n\t\t{\n\t\t\tif(p.y == gool.y && p.x == gool.x)\n\t\t\t{\n\t\t\t\tsField[p.y][p.x] = count+1;\n\n\t\t\t\tif(minField[gool.y][gool.x] > sField[gool.y][gool.x] || minField[gool.y][gool.x] == -1)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<maxy;++y)\n\t\t\t\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t\t\t\t\tminField[y][x] = sField[y][x];\n\t\t\t\t}\n\t\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\t\tsField[p.y][p.x] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\t}\n\t\tif(minField[p.y][p.x] < count+1 && minField[p.y][p.x] != -1)\n\t\t{\n\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tsField[sP.y][sP.x] = -1;\n\treturn;\n}\n\nint main(void)\n{\n\tint field[MI_Y][MI_X];\n\n\twhile(cin >> maxx,cin >> maxy,maxx || maxy)//入力\n\t{\n\t\ticePow.clear();\n\t\tfor(int y=0;y<maxy;++y)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tchar input = getchar();\n\t\t\t\tif(input == '.')\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\telse if(input == '#')\n\t\t\t\t\tfield[y][x] = WALL;\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[y][x] = ICE;\n\t\t\t\telse if(input == 'S'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tstart.y = y;\n\t\t\t\t\tstart.x = x;\n\t\t\t\t}\n\t\t\t\telse if(input == 'G'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tgool.y = y;\n\t\t\t\t\tgool.x = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}//入力終わり\n\t\tfor(int y=0;y<maxy;++y)//ICEの値をアレに\n\t\t{\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tvector<Point> v;\n\t\t\t\tif(field[y][x] == ICE)\n\t\t\t\t{\n\t\t\t\t\tIceSet(field,Point(x,y),v);\n\t\t\t\t\ticePow.push_back(v.size()/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ここから深さ優先\n\t\tint serchField[MI_Y][MI_X];\n\t\tfor(int i=0;i<MI_Y;++i)//-1で初期化\n\t\t{\n\t\t\tfor(int j=0;j<MI_X;++j)\n\t\t\t{\n\t\t\t\tserchField[i][j] = -1;\n\t\t\t\tminField[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSerch(field,start,serchField,0,icePow);\n\t\tcout << minField[gool.y][gool.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nconst ull B =1000000007ULL;\nconst ull inv = 13499267949257065399ULL;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n      if(cnt >= 100 && cnt % 4 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint p[200];\nint root(int x){\n\tif(p[x] < 0) return x;\n\treturn p[x] = root(p[x]);\n}\nint h, w, dist[200][200];\nchar in[12][13];\n\nint main(){\n\twhile(cin >> w >> h, h){\n\t\tint sy, sx, gy, gx;\n\t\trep(i, h * w) p[i] = -1;\n\t\trep(i, h * w) rep(j, h * w) dist[i][j] = i == j ? 0 : inf;\n\t\t\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t\tif(in[i][j] == 'X') rep(d, 2){\n\t\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\t\tif(ny >= 0 && nx >= 0 && in[ny][nx] == 'X'){\n\t\t\t\t\t\tint a = root(i * w + j), b = root(ny * w + nx);\n\t\t\t\t\t\tif(a != b){\n\t\t\t\t\t\t\tp[a] += p[b];\n\t\t\t\t\t\t\tp[b] = a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif(in[i][j] == '#') continue;\n\t\t\t\tdist[i * w + j][ny * w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tpriority_queue<pair<pair<int, pi>, vi> > q;  //cost*, cost, pos, ice\n\t\tset<pair<int, vi> > s;\n\t\tint n = 0, to[100], sz[100];\n\t\tmemset(to, -1, sizeof(to));\n\t\t\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tint r = root(i * w + j);\n\t\t\tif(to[r] < 0){\n\t\t\t\tsz[n] = -p[r];\n\t\t\t\tto[r] = n++;\n\t\t\t}\n\t\t}\n\t\tq.push(mp(mp(-dist[sy * w + sx][gy * w + gx],\n\t\t\tmp(0, sy * w + sx)), vi(n)));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tvi v = q.top().second;\n\t\t\tint cost = q.top().first.second.first;\n\t\t\tint y = q.top().first.second.second;\n\t\t\tint x = y % w; y /= w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(y * w + x, v))) continue;\n\t\t\ts.insert(mp(y * w + x, v));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\t\n\t\t\t\tint r = root(ny * w + nx);\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tv[to[r]]++;\n\t\t\t\t\tif(sz[to[r]] < v[to[r]] * 2){\n\t\t\t\t\t\tv[to[r]]--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!s.count(mp(ny * w + nx, v)))\n\t\t\t\tq.push(mp(mp(cost - dist[ny * w + nx][gy * w + gx],\n\t\t\t\t\tmp(cost - 1, ny * w + nx)), v));\n\t\t\t\t\n\t\t\t\tif(in[ny][nx] == 'X') v[to[r]]--;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define INF 1 << 15\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tint mapc[12][12];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tmemset(mapc,-1,sizeof(mapc));\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\t\tmapc[i][j]=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly&&r.visited[t.y][t.x]==0){\n\t\t\t\t\tif(mapc[t.y][t.x]>mapc[r.y][r.x]+1||mapc[t.y][t.x]==-1){\n\t\t\t\t\t\tmapc[t.y][t.x]=mapc[r.y][r.x]+1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (10000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,zx,zy,x,y,g,m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\n\nint ans(int x1,int y1,int d) {\n\tint k,x2,y2;\n\tzx=gx-x1; zy=gy-y1;\n\tif (zx<0) zx=-zx; if (zy<0) zy=-zy;\n\tif (d>=an || d+zx+zy>=an) return 0;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS =1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\nchar field[101][101];\nint koriNum[101][101];\nint H,W;\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint fillField(int cy,int cx,int id){\n\tkoriNum[cy][cx]=id;\n\tint cnt=1;\n\tfor(int i=0;i<4;i++){\n\t\tint ny=cy+dy[i];\n\t\tint nx=cx+dx[i];\n\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]=='X'&&koriNum[ny][nx]==-1)\n\t\t\tcnt+=fillField(ny,nx,id);\n\t}\n\treturn cnt;\n}\nint sy,sx,gy,gx;\nint minCost;\nint compCnt[1001];\nint footCnt[1001];\nbool passed[101][101];\nvoid dfs(int cy,int cx,int step){\n\tif(cy==gy&&cx==gx){\n\t\tminCost=min(minCost,step);\n\t}\n\telse{\n\t\tint mhd=abs(cy-gy)+abs(cx-gx);\n\t\tif(minCost<=mhd+step)return;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&!passed[ny][nx]){\n\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\tdfs(ny,nx,step+1);\n\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t}\n\t\t\t\telse if(field[ny][nx]=='X'){\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]++;\n\t\t\t\t\t// 半分+1以上のマスに到達してしまったら、到達不能\n\t\t\t\t\tif(!((compCnt[koriNum[ny][nx]]/2+1)<=footCnt[koriNum[ny][nx]])){\n\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\tdfs(ny,nx,step+1);\n\t\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t\t}\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\twhile(cin>>W>>H&&(H|W)){\n\t\tminCost=1000000;\n\t\tmemset(passed,0,sizeof(passed));\n\t\tmemset(compCnt,0,sizeof(compCnt));\n\t\tmemset(footCnt,0,sizeof(footCnt));\n\t\tmemset(koriNum,-1,sizeof(koriNum));\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='S'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='G'){\n\t\t\t\t\tgy=i;\n\t\t\t\t\tgx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint id=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(field[i][j]=='X'){\n\t\t\t\t\tif(koriNum[i][j]==-1){\n\t\t\t\t\t\tcompCnt[id]=fillField(i,j,id);\n\t\t\t\t\t\tid++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpassed[sy][sx]=true;\n\t\tdfs(sy,sx,0);\n\t\tcout<<minCost<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = step;\n    result *= base; result += x;\n    result *= base; result += y;\n    result *= base;\n    for(int i = 0; i < v.size(); ++i) {\n        result += v[i];\n        result *= base;\n    }\n    return result + v.size();\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    reverse(v.begin(), v.end());\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = max(20, *max_element(durability.begin(), durability.end()));\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint ice[14][14];\nint num[10000];\nint gx,gy;\n\nint ans = 0;\nint ccc = 0;\nvoid dfs(int x,int y,int C,int px,int py){\n  if( c[y][x] == '#' || c[y][x] == '*') return;\n  if( C + abs(x-gx) + abs(y-gy) >= ans ) return;\n  if( c[y][x] == 'G'){ans = C; return; }\n\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( px == tx && ty == py ) continue;\n    if( c[ty][tx] == '*' ) return;\n  }\n  char cur = c[y][x];\n  c[y][x] = '*';\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( c[ty][tx] == 'X' ){\n      int b = ice[ty][tx];\n      if( num[b] > 0 ){\n\tnum[b]--;\n\tdfs(tx,ty,C+1,x,y);\n\tnum[b]++;\n      }\n    }else{\n      dfs(tx,ty,C+1,x,y);\n    }\n  }\n  c[y][x] = cur;\n  return;\n}\nvoid grouping(int x,int y,int k){\n  ice[y][x] = k;\n  num[k]++;\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( c[ty][tx] == 'X' && ice[ty][tx] < 0 )grouping(tx,ty,k);\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  int W,H;\n  while(cin >> W >> H && W){\n    rep(i,14)rep(j,14) ice[i][j] = -1;\n    rep(i,14)rep(j,14) \n      c[i][j] = '#';\n    int sx , sy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> c[i+1][j+1];\n\tif(c[i+1][j+1] == 'S'){\n\t  c[i+1][j+1] = '.';\n\t  sx = j+1 , sy = i+1;\n\t}else if(c[i+1][j+1] == 'G' ){\n\t  gx = j+1 , gy = i+1;\n\t}\n      }\n    }\n    int k = 0;\n    for(int i = 1 ; i <= H ; i++){\n      for(int j = 1 ; j <= W ; j++){\n\tif( c[i][j] == 'X' && ice[i][j] < 0){\n\t  num[k] = 0;\n\t  grouping(j,i,k);\n\t  num[k] /= 2;\n\t  k++;\n\t}\n      }\n    }\n    ans = 1e7;\n    dfs(sx,sy,0,-1,-1);\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nuc ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)\n    {\n      ice[j+i*w] = inf;\n      ice_cnt[j+i*w] = cinf;\n    }\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  uc cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      \n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      \n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++))mincost.clear();\n\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstatic const int INF=(1<<21);\nint c=0;\nvoid katamari(int,int);\nchar map[14][14];\nqueue<pair<int,int> > q; \nstruct r{\n\tint x;\n\tint y;\n\tint cnt;\n\tint icec[144];\n\tbool used[12][12];\n};\nr s,v;\nqueue<r> f;\nint maps[12][12],icem[144],x,y,k,h;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint main()\n{\n\tint i,j;\n\twhile(1){\n\t\tc=0;\n\t\twhile(!q.empty()){\n\t\t\tq.pop();\n\t\t}\n\t\tmemset(icem,0,sizeof(icem));\n\t\tmemset(map,'#',sizeof(map));\n\t\tcin>>x>>y;\n\t\tif(x==0&&y==0)break;\n\t\tfor(i=0;i<y;i++){\n\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tmaps[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==INF){\n\t\t\t\t\tq.push(make_pair(i,j) );\n\t\t\t\t\tmaps[i][j] = c;\n\t\t\t\t\tkatamari(j,i);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\telse if(map[i][j] == 'S'){\n\t\t\t\t\ts.y = i;\n\t\t\t\t\ts.x = j;\n\t\t\t\t\ts.cnt = 0;\n\t\t\t\t\tfor(k=0;k<144;k++){\n\t\t\t\t\t\ts.icec[k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.used[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(maps[i][j]!=INF){\n\t\t\t\t\ticem[maps[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf.push(s);\n\t\twhile(!f.empty()){\n\t\t\ts = f.front();\n\t\t\tf.pop();\n\t\t\tif(s.used[s.y][s.x]==false){\n\t\t\t\ts.used[s.y][s.x]=true;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF){\n\t\t\t\ts.icec[maps[s.y][s.x]]++;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF&&s.icec[maps[s.y][s.x]]>icem[maps[s.y][s.x]]/2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[s.y][s.x]=='G'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tif(s.x+dx[i]>=0&&s.x+dx[i]<x&&s.y+dy[i]>=0&&s.y+dy[i]<y&&map[s.y+dy[i]][s.x+dx[i]]!='#'&&s.used[s.y+dy[i]][s.x+dx[i]]==false){\n\t\t\t\t\tfor(j=0;j<144;j++){\n\t\t\t\t\t\tv.icec[j]=s.icec[j];\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=0;j<y;j++){\n\t\t\t\t\t\tfor(k=0;k<x;k++){\n\t\t\t\t\t\t\tv.used[j][k]=s.used[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.x=s.x+dx[i];\n\t\t\t\t\tv.y=s.y+dy[i];\n\t\t\t\t\tv.cnt=s.cnt+1;\n\t\t\t\t\tf.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<s.cnt<<endl;\n\t}\n\treturn 0;\n}\nvoid katamari(int x,int y){\n\twhile(!q.empty()){\n\t\tpair<int,int> p = q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(map[p.first + dx[i]][p.second + dy[i]] == 'X'&&maps[p.first + dx[i]][p.second + dy[i]]==INF){\n\t\t\t\tmaps[p.first + dx[i]][p.second + dy[i]] = c;\n\t\t\t\tq.push(make_pair(p.first + dx[i],p.second + dy[i]));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define INF 1 << 15\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy,ex,ey;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tint mapc[13][13];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tmemset(mapc,-1,sizeof(mapc));\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\t\tmapc[i][j]=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\tif(mapc[t.y][t.x]>=r.cnt+1||mapc[t.y][t.x]==-1){\n\t\t\t\t\t\t\tif(map[t.y][t.x]=='G'){\n\t\t\t\t\t\t\t\tex=t.x;\n\t\t\t\t\t\t\t\tey=t.y;\n\t\t\t\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(mapc[t.y][t.x]<=r.cnt){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tcout<<mapc[ey][ex]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \n//#define LOG(...) printf(__VA_ARGS__)\n#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint w,h;\nvector<string> field;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint dfs(int x, int y, int n){\n\tint cnt=1;\n\tfield[y][x]=-n;\n\tREP(i, 4){\n\t\tint sx=x+dx[i];\n\t\tint sy=y+dy[i];\n\t\tif(0<=sx&&sx<w&&0<=sy&&sy<h&&field[sy][sx]=='X')\n\t\t\tcnt+=dfs(sx, sy, n);\n\t}\n\treturn cnt;\n}\n\nstruct P\n{\n\tint x,y,cost;\n\tvi iceList,l;\n};\n \nint main() {\n\twhile(cin >> w >> h, w|h){\n\t\tfield.clear();\n\t\tREP(y, h){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tfield.push_back(line);\n\t\t}\n\n\t\tP s,g;\n\t\tvi l;\n\t\tREP(y, h){REP(x, w){\n\t\t\tswitch(field[y][x]){\n\t\t\t\tcase 'X':\n\t\t\t\t\tl.push_back(dfs(x,y,l.size()+1)/2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ts=(P){x,y,0};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\tg=(P){x,y};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}}\n\n\t\tREP(y, h){REP(x, w){\n\t\t\tLOG(\"%3d \",field[y][x]);\n\t\t}\n\t\tLOG(\"\\n\");\n\t\t}\n\t\ts.iceList=l;\n\n\t\tREP(i, l.size()){\n\t\t\tLOG(\"ice life %d\\n\",l[i]);\n\t\t}\n\n\t\tLOG(\"gool %d %d \\n\",g.x,g.y);\n\n\t\tqueue<P> que;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tLOG(\"---\\n\");\n\t\t\tP p=que.front();que.pop();\n\t\t\tLOG(\"now %d %d %d\\n\",p.x,p.y,p.cost);\n\t\t\tif(p.y==g.y&&p.x==g.x){\n\t\t\t\tcout << p.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 4){\n\t\t\t\tvi l=p.iceList;\n\t\t\t\tvi ll=p.l;\n\t\t\t\tint sx=p.x+dx[i];\n\t\t\t\tint sy=p.y+dy[i];\n\t\t\t\tif(!(0<=sx&&sx<w&&0<=sy&&sy<h))\n\t\t\t\t\tcontinue;\n\t\t\t\tint d=field[sy][sx];\n\t\t\t\tbool t=false;\n\t\t\t\tREP(j, p.l.size()){\n\t\t\t\t\tif(p.l[j]==sy*w+sx){\n\t\t\t\t\t\tt=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t)continue;\n\t\t\t\tll.push_back(sy*w+sx);\n\t\t\t\tif(d<0){\n\t\t\t\t\td=-d-1;\n\t\t\t\t\tLOG(\"ice %d = %d\\n\",d,l[d]);\n\t\t\t\t\tif(l[d]>0){\n\t\t\t\t\t\tl[d]--;\n\t\t\t\t\t\tque.push((P){sx,sy,p.cost+1,l,ll});\n\t\t\t\t\t}\n\t\t\t\t}else if(d=='.'||d=='G')\n\t\t\t\t\tque.push((P){sx,sy,p.cost+1,l,ll});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring g[20];\nvector<int> cnt;\nint num[200],n;\nint ice[20][20];\nint sy,sx;\nbool vis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x){\n  if(g[y][x] == 'G')return 0;\n  if(memo.find(cnt)!=memo.end())return memo[cnt];\n  vis[y][x] = true;\n\n  int res = 200;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx) + 1);\n      cnt[curg]--; cnt[n] = y; cnt[n+1] = x;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx) + 1);\n      cnt[n] = y; cnt[n+1] = x;\n    }\n  }\n  vis[y][x] = false;\n\n  if(memo.size()<=1000000)memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n    }\n    /*\n    rep(i,h){rep(j,w)cout << ice[i][j] << \" \";cout << endl;}\n    rep(i,n)cout << num[i] << \" \";cout << endl;\n    */\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    cout << dfs(sy,sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <cctype>\n#include <set>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1000000007;\nconst double EPS = 1e-10;\n\nchar field[15][15];\nbool visit[15][15];\nint best;\nint cnt[100];\nint sz[100];\nint id[15][15];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvoid dfs(int r, int c, int k){\n  id[r][c] = k;\n  sz[k]++;\n  rep(i, 4){\n    int r2 = r + dy[i];\n    int c2 = c + dx[i];\n    if(id[r2][c2] == -1 && field[r2][c2] == 'X'){\n      dfs(r2, c2, k);\n    }\n  }\n}\n\nvoid iddfs(int r, int c, int gr, int gc, int dep, int limit){\n  //  if(dep + abs(gr - r) + abs(gc - c) > limit) return false;\n  //  cout << r << \" \" << c << endl;\n  //if(r == gr && c == gc) return true;\n  if(dep + abs(gr - r) + abs(gc - c) > best) return;\n  if(r == gr && c == gc){\n    best = dep;\n    return;\n  }\n  visit[r][c] = true;\n  \n  rep(i, 4){\n\n    int r2 = r + dy[i];\n    int c2 = c + dx[i];\n    \n    if(field[r2][c2] == '#' || visit[r2][c2]) continue;\n    if(field[r2][c2] == '.'){\n      //if(iddfs(r2, c2, gr, gc, dep + 1, limit)) return true;\n      iddfs(r2, c2, gr, gc, dep + 1, limit);\n    }\n    if(field[r2][c2] == 'X'){\n      //      cout << cnt[id[r2][c2]] << \" \" << sz[id[r2][c2]] << \"**\" << endl;\n      if(cnt[id[r2][c2]] + 1 > sz[id[r2][c2]] / 2) continue;\n      cnt[id[r2][c2]]++;\n      //if(iddfs(r2, c2, gr, gc, dep + 1, limit)) return true;\n      iddfs(r2, c2, gr, gc, dep + 1, limit);\n      cnt[id[r2][c2]]--;\n    }\n  }\n  visit[r][c] = false;\n  //  return false;\n}\n\n\n\nint main(){\n  int x, y ,sr, sc, gr, gc, c;\n  while(cin >> x >> y){\n    c = 0;\n    if(x == 0 && y == 0) continue;;\n    fill(&field[0][0], &field[0][0] + 15 * 15, '#');\n    \n    memset(sz, 0, sizeof(sz));\n    memset(cnt, 0, sizeof(cnt));\n    memset(id, -1, sizeof(id));\n    memset(visit, false, sizeof(visit));\n    \n    rep(i, y)rep(j, x){\n      cin >> field[i+1][j+1];\n      if(field[i+1][j+1] == 'S') sr = i + 1, sc = j + 1;\n      if(field[i+1][j+1] == 'G') gr = i + 1, gc = j + 1, field[i+1][j+1] = '.';\n    }\n    \n    rep(i, y)rep(j, x){\n      if(id[i+1][j+1] == -1 && field[i+1][j+1] == 'X'){\n\tdfs(i + 1, j + 1, c++);\n      }\n      //      cout << setw(3) << id[i+1][j+1];\n      //      if(j == x - 1) cout << endl;\n    }\n    \n\n    best = INF;\n    iddfs(sr, sc, gr, gc, 0, best);\n    /*\n      int len = 1;\n    while(!iddfs(sr,sc,gr,gc,0,len)){\n      len++;\n      }\n\n    cout << len << endl;\n*/\n    cout << best << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\n\nint W,H;\nint data[12][12];\nint h[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n\n};\n\ntypedef pair<int,State>PP;\ntypedef pair<int,P>P2;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n/*\nvoid dfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n*/\n\nbool dfs(PP pp,int lim){\n\n   int cnt = pp.first;\n\n\n   State state = pp.second;\n   P p = state.p;\n\n   if(cnt + h[p.first][p.second] - 5 > lim)return false;\n   \n   if(p == g){\n      cout << cnt << endl;\n      return true;\n   }\n   \n   for(int i = 0 ; i < 4 ; i++){\n      P np = P(p.first + dy[i],p.second + dx[i]);\n      if(!check(np))continue;\n      \n      int here = data[np.first][np.second];\n      if(here == wall)continue;\n      if(state.vis[np.first][np.second] < cnt)continue;\n\n      state.p = np;\n\n      int tmp =  state.vis[np.first][np.second];\n      \n      if(here >= 0){\n\n         if(state.v[here] <= mv[here]/2)continue;\n         if(mv[here] == 1)continue;\n         \n         state.v[here]--;\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.v[here]++;\n         state.vis[np.first][np.second] = tmp;\n      }\n      else{\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.vis[np.first][np.second] = tmp;\n      }\n      state.p = p;\n   }\n   return false;\n}\n\n\n\nvoid bfs(){\n   \n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         h[i][j] = INF;\n      }\n   }\n\n   queue<P2>que;\n   que.push(P2(0,g));\n\n   h[g.first][g.second] = 0;\n\n   while(que.size()){\n      P2 p2 = que.front(); que.pop();\n      int cnt = p2.first;\n      P p = p2.second;\n\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] == wall)continue;\n         if(h[np.first][np.second] != INF)continue;\n         h[np.first][np.second] = cnt+1;\n         que.push(P2(cnt+1,np));\n      }\n   }\n}\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n   //bfs();\n   \n   //State state;\n   //state.set(mv,s);\n\n   bfs();\n   \n/*\n   cout << H << ' ' << W << endl;\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         cout << h[i][j];\n      }\n      cout << endl;\n   }\n*/      \n   for(int i = 1 ; ; i++){\n      State state;\n      state.set(mv,s);\n      if(dfs(PP(0,state),i))break;\n   }\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      //cout << \"W = \" << W << \" H = \" << H << endl;//\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n#define at(t, i) get<i>(t)\n\nint h, w;\nint sx, sy, gx, gy;\nchar grid[14][14];\nint dist[14][14];\nint group[14][14];\nint size[1024];\nbool visit[14][14];\n\nbool search(int x, int y, int d)\n{\n\tif (visit[x][y]) return false;\n\tif (dist[x][y] > d) return false;\n\tif (group[x][y] != -1 && size[group[x][y]] <= 1) return false;\n\t\n\tif (x == gx && y == gy) return true;\n\t\n\tvisit[x][y] = true;\n\tif (group[x][y] != -1) size[group[x][y]]--;\n\t\n\tfor (int dir = 0; dir < 4; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tif (grid[nx][ny] == '#') continue;\n\t\tif (visit[nx][ny]) continue;\n\t\tif (search(nx, ny, d - 1)) return true;\n\t}\n\t\n\tvisit[x][y] = false;\n\tif (group[x][y] != -1) size[group[x][y]]++;\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tint color = 0;\n\tfor (int i = 1; i <= h; i++){\n\t\tfor (int j = 1; j <= w; j++){\n\t\t\tif (compl group[i][j]) continue;\n\t\t\tif (grid[i][j] != 'X') continue;\n\t\t\tsize[color] = 1;\n\t\t\tgroup[i][j] = color;\n\t\t\t\n\t\t\tqueue<Pr> que;\n\t\t\tfor (que.push(Pr(i, j)); que.size(); que.pop()){\n\t\t\t\tPr p = que.front();\n\t\t\t\tint x = p.first, y = p.second;\n\t\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\t\tint nx = x + dx[dir];\n\t\t\t\t\tint ny = y + dy[dir];\n\t\t\t\t\tif (group[nx][ny] == -1 && grid[nx][ny] == 'X'){\n\t\t\t\t\t\tgroup[nx][ny] = color;\n\t\t\t\t\t\tsize[color]++;\n\t\t\t\t\t\tque.push(Pr(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsize[color] = size[color] / 2 + 1;\n\t\t\tcolor++;\n\t\t}\n\t}\n\t\n\t{\n\t\tqueue<Tp> que;\n\t\tdist[gx][gy] = 0;\n\t\tfor (que.push(Tp(gx, gy, 0)); que.size(); que.pop()){\n\t\t\tTp t = que.front();\n\t\t\tint x = at(t, 0), y = at(t, 1), d = at(t, 2);\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[dir];\n\t\t\t\tif (grid[nx][ny] == '#') continue;\n\t\t\t\tif (dist[nx][ny] < INF) continue;\n\t\t\t\tdist[nx][ny] = d + 1;\n\t\t\t\tque.push(Tp(nx, ny, d + 1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int d = 1; ; d++){\n\t\tif (search(sx, sy, d)) return d;\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), h){\n\t\tfill_n(*grid, 14 * 14, '#');\n\t\tfill_n(*dist, 14 * 14, INF);\n\t\tfill_n(*group, 14 * 14, -1);\n\t\tfill_n(size, 1024, 0);\n\t\tfill_n(*visit, 14 * 14, false);\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'S'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 'G'){\n\t\t\t\t\tgx = i;\n\t\t\t\t\tgy = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nbitset<3000000> visited[12][12];\nvector<int> icesq;\n\nstruct data {\n\tint x, y;\n\tint t, v;\n\tdata(int x_, int y_, int t_, int v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tq.push(data(S.se, S.fi, 0, 0));\n\t\tvector<int> radix;\n\t\tradix.resize(icesq.size() + 1);\n\t\tradix[0] = 1;\n\t\tfor(int i = 1; i < radix.size(); i++) {\n\t\t\tradix[i] = radix[i-1] * (icesq[i-1] + 1);\n\t\t}\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\tfor(int j = 0; j < 12; j++) {\n\t\t\t\tvisited[i][j].reset();\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(!visited[ny-1][nx-1][cur.v]) {\n\t\t\t\t\t\tvisited[ny-1][nx-1][cur.v] = true;\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X') {\n\t\t\t\t\tint flgcnts;\n\t\t\t\t\tflgcnts = (cur.v % radix[ice[ny][nx]+1]) / radix[ice[ny][nx]];\n\t\t\t\t\tif(flgcnts < icesq[ice[ny][nx]]) {\n\t\t\t\t\t\tint tmp = cur.v + radix[ice[ny][nx]];\n\t\t\t\t\t\tif(!visited[ny-1][nx-1][tmp]) {\n\t\t\t\t\t\t\tvisited[ny-1][nx-1][tmp] = true;\n\t\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif ((x1==gx && y1==gy) || d>=an) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4;j++) {  z+=c[y2+dy[j]][x2+dx[j]];   \n\t\t\t\t\tif (da[y2+dy[i]][x2+dx[i]]!='#' && m[y2+dy[i]][x2+dx[i]]<0 && c[y2+dy[i]][x2+dx[i]]==0)\n\t\t\t\t\t    if (c[y2+dy[i]*2][x2+dx[i]*2]==1) z=2;\n\t\t\t\t\t}\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=0;j<=x+1;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\nint next_depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    if (step == depth) {\n        next_depth = min(next_depth, depth + abs(x - goal_x) + abs(y - goal_y));\n        return false;\n    }\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0 && !G[sy][sx]) {\n                (*ices[sy][sx])--;\n                G[sy][sx] = true;\n                if (iddfs(sx, sy, step+1)) return true;\n                G[sy][sx] = false;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int empty = 100000;\n        int wall = 0;\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ices[y][x] = &empty;\n                break;\n            case '#':\n                ices[y][x] = &wall;\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((bool *)G, 12*12, false);\n        depth = abs(start_x - goal_x) + abs(start_y - goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth = next_depth;\n            next_depth = INF;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  //if(ans<=d + dis[y][x])return;\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n]/=2, n++;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n   /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS =1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\nchar field[101][101];\nint koriNum[101][101];\nint H,W;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nint fillField(int cy,int cx,int id){\n\tkoriNum[cy][cx]=id;\n\tint cnt=1;\n\tfor(int i=0;i<4;i++){\n\t\tint ny=cy+dy[i];\n\t\tint nx=cx+dx[i];\n\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]=='X'&&koriNum[ny][nx]==-1)\n\t\t\tcnt+=fillField(ny,nx,id);\n\t}\n\treturn cnt;\n}\nint sy,sx,gy,gx;\nint minCost;\nint compCnt[1001];\nint footCnt[1001];\nbool passed[101][101];\nint dd[20][20][20][20];\nconst int INF=1000000000;\nvoid bfs(int d[20][20],int ssy,int ssx){\n\tfor(int i=0;i<20;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\td[i][j]=INF;\n\td[ssy][ssx]=0;\n\tqueue<pair<int,pii> > q;\n\tq.push(make_pair(0,pii(ssy,ssx)));\n\twhile(q.size()){\n\t\tpair<int,pii> p=q.front();q.pop();\n\t\tint ccost=p.first;\n\t\tint cy=p.second.first;\n\t\tint cx=p.second.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'&&d[ny][nx]==INF){\n\t\t\t\td[ny][nx]=ccost+1;\n\t\t\t\tq.push(make_pair(d[ny][nx],pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int cy,int cx,int step){\n\t//if(cy==9&&cx==2&&step==13){\n\t//\tcout<<endl;\n\t//}\n\tif(cy==gy&&cx==gx){\n\t\tminCost=min(minCost,step);\n\t}\n\telse{\n\t\tint mhd=dd[cy][cx][gy][gx];\n\t\tif(minCost<=mhd+step)return;\n\t\t//mhd=abs(cy-gy)+abs(cx-gx);\n\t\t//if(minCost<=mhd+step)return;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&!passed[ny][nx]){\n\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\tdfs(ny,nx,step+1);\n\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t}\n\t\t\t\telse if(field[ny][nx]=='X'){\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]++;\n\t\t\t\t\t// 半分+1以上のマスに到達してしまったら、到達不能\n\t\t\t\t\tif(!((compCnt[koriNum[ny][nx]]/2+1)<=footCnt[koriNum[ny][nx]])){\n\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\tdfs(ny,nx,step+1);\n\t\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t\t}\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\twhile(cin>>W>>H&&(H|W)){\n\t\tminCost=H*W-1;\n\t\tmemset(passed,0,sizeof(passed));\n\t\tmemset(compCnt,0,sizeof(compCnt));\n\t\tmemset(footCnt,0,sizeof(footCnt));\n\t\tmemset(koriNum,-1,sizeof(koriNum));\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='S'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='G'){\n\t\t\t\t\tgy=i;\n\t\t\t\t\tgx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint id=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(field[i][j]=='X'){\n\t\t\t\t\tif(koriNum[i][j]==-1){\n\t\t\t\t\t\tcompCnt[id]=fillField(i,j,id);\n\t\t\t\t\t\tid++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tbfs(dd[i][j],i,j);\n\t\tpassed[sy][sx]=true;\n\t\tdfs(sy,sx,0);\n\t\tcout<<minCost<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstatic const int INF=(1<<21);\nint c=0;\nvoid katamari(int,int);\nchar map[14][14];\nqueue<pair<int,int> > q; \nstruct r{\n\tint x;\n\tint y;\n\tint cnt;\n\tint icec[144];\n\tbool used[12][12];\n};\nr s,v;\nqueue<r> f;\nint maps[12][12],icem[144],x,y,k,h;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint main()\n{\n\tint i,j;\n\twhile(1){\n\t\tc=0;\n\t\twhile(!q.empty()){\n\t\t\tq.pop();\n\t\t}\n\t\tmemset(icem,0,sizeof(icem));\n\t\tmemset(map,'#',sizeof(map));\n\t\tcin>>x>>y;\n\t\tif(x==0&&y==0)break;\n\t\tfor(i=0;i<y;i++){\n\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tmaps[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==INF){\n\t\t\t\t\tq.push(make_pair(i,j) );\n\t\t\t\t\tmaps[i][j] = c;\n\t\t\t\t\tkatamari(j,i);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\telse if(map[i][j] == 'S'){\n\t\t\t\t\ts.y = i;\n\t\t\t\t\ts.x = j;\n\t\t\t\t\ts.cnt = 0;\n\t\t\t\t\tfor(k=0;k<144;k++){\n\t\t\t\t\t\ts.icec[k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.used[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(maps[i][j]!=INF){\n\t\t\t\t\ticem[maps[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf.push(s);\n\t\twhile(!f.empty()){\n\t\t\ts = f.front();\n\t\t\tf.pop();\n\t\t\tif(s.used[s.y][s.x]==false){\n\t\t\t\ts.used[s.y][s.x]=true;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF){\n\t\t\t\ts.icec[maps[s.y][s.x]]++;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF&&s.icec[maps[s.y][s.x]]>icem[maps[s.y][s.x]]/2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[s.y][s.x]=='G'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tif(s.x+dx[i]>=0&&s.x+dx[i]<x&&s.y+dy[i]>=0&&s.y+dy[i]<y&&map[s.y+dy[i]][s.x+dx[i]]!='#'&&s.used[s.y+dy[i]][s.x+dx[i]]==false){\n\t\t\t\t\tfor(j=0;j<c;j++){\n\t\t\t\t\t\tv.icec[j]=s.icec[j];\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=0;j<y;j++){\n\t\t\t\t\t\tfor(k=0;k<x;k++){\n\t\t\t\t\t\t\tv.used[j][k]=s.used[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.x=s.x+dx[i];\n\t\t\t\t\tv.y=s.y+dy[i];\n\t\t\t\t\tv.cnt=s.cnt+1;\n\t\t\t\t\tf.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<s.cnt<<endl;\n\t}\n\treturn 0;\n}\nvoid katamari(int x,int y){\n\twhile(!q.empty()){\n\t\tpair<int,int> p = q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(map[p.first + dx[i]][p.second + dy[i]] == 'X'&&maps[p.first + dx[i]][p.second + dy[i]]==INF){\n\t\t\t\tmaps[p.first + dx[i]][p.second + dy[i]] = c;\n\t\t\t\tq.push(make_pair(p.first + dx[i],p.second + dy[i]));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nvoid solve(int h, int w){\n    array<int, 4> dx{-1, 1, 0, 0}, dy{0, 0, -1, 1};\n    vector<vector<int>> v(h+2, vector<int>(w+2, -1));\n    int sy, sx, gy, gx;\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) {\n            if(s[j] == 'X') v[i+1][j+1] = 1000;\n            else if(s[j] == '#' || s[j] == 'S') v[i+1][j+1] = -1;\n            else v[i+1][j+1] = 0;\n            if(s[j] == 'S') sy = i+1, sx = j+1;\n            else if(s[j] == 'G') gy = i+1, gx = j+1;\n        }\n    }\n    vector<int> M{0};\n    for (int i = 0, cur = 1; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if(v[i+1][j+1] == 1000){\n                queue<pair<int, int>> Q;\n                Q.emplace(i+1, j+1);\n                M.emplace_back();\n                v[i+1][j+1] = cur;\n                while(!Q.empty()){\n                    M.back()++;\n                    int y, x; tie(y, x) = Q.front(); Q.pop();\n                    for (int k = 0; k < 4; ++k) {\n                        if(v[y+dy[k]][x+dx[k]] == 1000){\n                            v[y+dy[k]][x+dx[k]] = cur;\n                            Q.emplace(y+dy[k], x+dx[k]);\n                        }\n                    }\n                }\n                M.back() /= 2;\n                cur++;\n            }\n        }\n    }\n    for (int ans = abs(sx-gx)+abs(sy-gy); ; ++ans) {\n        auto G = v;\n        vector<int> m(M.size());\n        auto dfs = [&](int y, int x, int dep, auto &&f) -> bool {\n            if(gy == y && gx == x) return true;\n            if(dep+abs(gy-y)+abs(gx-x) > ans) return false;\n            for (int k = 0; k < 4; ++k) {\n                int p = G[y+dy[k]][x+dx[k]];\n                if(p == 0){\n                    G[y+dy[k]][x+dx[k]] = -1;\n                    if(f(y+dy[k], x+dx[k], dep+1, f)) return true;\n                    G[y+dy[k]][x+dx[k]] = 0;\n                }else if(p > 0 && m[p]+1 <= M[p]){\n                    m[p]++;\n                    G[y+dy[k]][x+dx[k]] = -1;\n                    if(f(y+dy[k], x+dx[k], dep+1, f)) return true;\n                    G[y+dy[k]][x+dx[k]] = p;\n                    m[p]--;\n                }\n            }\n            return false;\n        };\n        if(dfs(sy, sx, 0, dfs)){\n            cout << ans << \"\\n\";\n            return;\n        }\n    }\n\n\n}\n\nint main() {\n    int h, w;\n    while(cin >> w >> h, h){\n        solve(h, w);\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      \n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nstruct S{\n    int x, y;\n    int c, h;\n    vector<int> cnt;\n    bool operator < (const S& s) const {\n        if(c + h != s.c + s.h) return c + h > s.c + s.h;\n        return c > s.c;\n    }\n};\n\nint main(){\n    int W, H;\n    while(cin >> W >> H && W){\n        int sx, sy, gx, gy;\n        vector<string> grid(H);\n        REP(y, H) cin >> grid[y];\n        REP(y, H) REP(x, W) if(grid[y][x] == 'S') { grid[y][x] = '.'; sx = x; sy = y; }\n        REP(y, H) REP(x, W) if(grid[y][x] == 'G') { grid[y][x] = '.'; gx = x; gy = y; }\n\n        int ice_count = 0;\n        int ice_id[12][12] = {};\n        vector<int> ice_v;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'X' && ice_id[y][x] == 0){\n            ice_id[y][x] = ++ice_count;\n            ice_v.push_back(1);\n            queue<int> qx, qy;\n            qx.push(x); qy.push(y);\n            while(!qx.empty()){\n                int bx = qx.front(); qx.pop();\n                int by = qy.front(); qy.pop();\n                REP(r, 4) {\n                    int nx = bx + dx[r];\n                    int ny = by + dy[r];\n                    if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] == 'X' && ice_id[ny][nx] == 0){\n                        qx.push(nx);\n                        qy.push(ny);\n                        ice_id[ny][nx] = ice_count;\n                        ice_v[ice_count - 1]++;\n                    }\n                }\n            }\n        }\n\n        int h_value[12][12];\n        memset(h_value, -1, sizeof h_value);\n        queue<int> qx, qy;\n        qx.push(gx); qy.push(gy);\n        h_value[gy][gx] = 0;\n        while(!qx.empty()){\n            int bx = qx.front(); qx.pop();\n            int by = qy.front(); qy.pop();\n            REP(r, 4) {\n                int nx = bx + dx[r];\n                int ny = by + dy[r];\n                if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] != '#' && h_value[ny][nx] == -1){\n                    qx.push(nx);\n                    qy.push(ny);\n                    h_value[ny][nx] = h_value[by][bx] + 1;\n                }\n            }\n        }\n\n        priority_queue<S> que;\n        S init;\n        init.x = sx, init.y = sy;\n        init.cnt.resize(ice_count);\n        init.c = 0; init.h = h_value[sy][sx];\n        set<vector<int>> used[12][12];\n        que.push(init);\n        while(!que.empty()){\n            S s = que.top(); que.pop();\n            if(s.h == 0){\n                cout << s.c << endl;\n                break;\n            }\n            REP(r, 4){\n                S next = s;\n                next.x += dx[r]; next.y += dy[r];\n                if(!(next.x >= 0 && next.x < W && next.y >= 0 && next.y < H && grid[next.y][next.x] != '#')) continue;\n                next.c ++;\n                next.h = h_value[next.y][next.x];\n                int id = ice_id[next.y][next.x] - 1;\n                if(id >= 0) next.cnt[id]++;\n                if(id >= 0 && next.cnt[id] > ice_v[id] / 2) continue;\n                if(used[next.y][next.x].count(next.cnt)) continue;\n                used[next.y][next.x].insert(next.cnt);\n                que.push(next);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\nint w, h, sx, sy, gx, gy;\nchar c[16][16];\nint f[16][16];\nvector<int> limit;\n\nvoid mark_ice(int _x, int _y)\n{\n\tint size = 0;\n\tint id = limit.size();\n\n\tqueue<pint> q;\n\tq.push(pint(_x, _y));\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second;\n\t\tq.pop();\n\n\t\tf[y][x] = id;\n\t\t++size;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (valid_pos(nx, ny, w, h) && c[ny][nx] == 'X' && f[ny][nx] == -1)\n\t\t\t\tq.push(pint(nx, ny));\n\t\t}\n\t}\n\n\tlimit.push_back((size + 2) / 2);\n}\n\nint res;\nint walk[256];\nbool visit[16][16];\nint dir[16][16][4];\nint gdir[16][16];\nvoid dfs(int x, int y, int dis)\n{\n\tif (gdir[y][x] + dis >= res)\n\t\treturn;\n\telse if (x == gx && y == gy)\n\t{\n\t\tres = dis;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint d = dir[y][x][i];\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (valid_pos(nx, ny, w, h) && !visit[ny][nx] && f[ny][nx] != -1)\n\t\t{\n\t\t\tint id = f[ny][nx];\n\t\t\t++walk[id];\n\t\t\tif (walk[id] < limit[id])\n\t\t\t{\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tdfs(nx, ny, dis + 1);\n\t\t\t\tvisit[ny][nx] = false;\n\t\t\t}\n\t\t\t--walk[id];\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> w >> h, w)\n\t{\n\t\tlimit.clear();\n\t\tCL(visit, 0);\n\t\tCL(f, -1);\n\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> c[i];\n\n\t\tlimit.push_back(114514);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (strchr(\"SG.\", c[y][x]))\n\t\t\t\t\tf[y][x] = 0;\n\n\t\t\t\tif (c[y][x] == 'S')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (c[y][x] == 'G')\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t\telse if (c[y][x] == 'X' && f[y][x] == -1)\n\t\t\t\t\tmark_ice(x, y);\n\t\t\t\telse if (c[y][x] == '#')\n\t\t\t\t\tf[y][x] = -1;\n\n\t\t\t\tpint dd[4];\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdd[i] = pint(abs(x + dx[i] - gx) + abs(y + dy[i] - gy), i);\n\t\t\t\tsort(dd, dd + 4);\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdir[y][x][i] = dd[i].second;\n\n\t\t\t\tgdir[y][x] = abs(x - gx) + abs(y - gy);\n\t\t\t}\n\t\t}\n\n\t\tres = 114514;\n\t\tvisit[sy][sx] = true;\n\t\tdfs(sx, sy, 0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      while(!Q.empty() && Q.back().cost+ev[Q.back().array[ice_number]][st[1]] >= max_ans)Q.pop_back();\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvi c;\n\t\t\tState(int i,int j,int d,const vi& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\tpriority_queue<State,vector<State>,greater<State>> pq;\n\t\tpq.emplace(s.first,s.second,0,vi(f.size()));\n\t\tmap<pair<pii,vi>,int> memo;\n\t\twhile(!pq.empty()){\n\t\t\tState cur=pq.top(); pq.pop();\n\t\t\titer(memo) it=memo.find(mp(mp(cur.i,cur.j),cur.c)); \n\t\t\tif(it!=memo.end() && it->second<=cur.d) continue;\n\t\t\tmemo[mp(mp(cur.i,cur.j),cur.c)]=cur.d;\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tcur.c[p]++;\n\t\t\t\t\tif(2*cur.c[p]<=cnt[p])\n\t\t\t\t\t\tpq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t\t\tcur.c[p]--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tpq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t}\n\t\t}\n\t\tint res=INFTY;\n\t\tfor(auto kv:memo)\n\t\t\tif(kv.first.first==g)\n\t\t\t\tres=min(res,kv.second);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      int depth = 0;\n      while(!compute(depth++));\n\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly&&r.visited[t.y][t.x]==0){\n\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0))Q.pop();\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  //if(ans<=d + dis[y][x])return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n]/=2, n++;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n   /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\ttypedef pair<char,char> pcc;\n\t\ttypedef vector<unsigned char> vuc;\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvuc c;\n\t\t\tState(int i,int j,int d,const vuc& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\t\n\t\tqueue<State> q;\n\t\tq.emplace(s.first,s.second,0,vuc(f.size()));\n\t\tset<pair<pcc,vuc>> memo;\n\t\twhile(!q.empty()){\n\t\t\tState cur=q.front(); q.pop();\n\t\t\t\n\t\t\titer(memo) it=memo.find(mp(mp(cur.i,cur.j),cur.c)); \n\t\t\tif(it!=memo.end()) continue;\n\t\t\tmemo.insert(mp(mp(cur.i,cur.j),cur.c));\n\t\t\t\n\t\t\tif(pii(cur.i,cur.j)==g){\n\t\t\t\tcout<<cur.d<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tvuc nc=cur.c;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tnc[p]++;\n\t\t\t\t\tif(2*nc[p]>cnt[p])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.emplace(ni,nj,cur.d+1,nc);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint h,w;\nchar grid[12][13];\nint ice[12][12],vis[12][12],lim[12*12];\nint gi,gj;\nint res;\n\ninline void dfs(int i,int j,int step)\n{\n\tif(grid[i][j]=='X' && lim[ice[i][j]]==0) return;\n\tif(grid[i][j]=='G') res=min(res,step);\n\tif(step+abs(gi-i)+abs(gj-j)>=res) return;\n\t\n\tvis[i][j]=true;\n\tif(grid[i][j]=='X') lim[ice[i][j]]--;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#' || vis[ni][nj]) continue;\n\t\tdfs(ni,nj,step+1);\n\t}\n\tif(grid[i][j]=='X') lim[ice[i][j]]++;\n\tvis[i][j]=false;\n}\n\nint main()\n{\n\tfor(;cin>>w>>h,w|h;){\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tmemset(ice,-1,sizeof(ice));\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X'){\n\t\t\tif(!f.count(uf.Find(i*w+j)))\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\tice[i][j]=f[uf.Find(i*w+j)];\n\t\t}\n\t\tvi cnt(f.size());\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tcnt[ice[i][j]]++;\n\t\trep(i,cnt.size()) lim[i]=cnt[i]/2;\n\t\t\n\t\tres=INFTY;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='G')\n\t\t\tgi=i,gj=j;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S')\n\t\t\tdfs(i,j,0);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}/*\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\tif(maps[i][j]>0){\n\t\t\t\t\tig[maps[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='G'&&r.cnt<min){\n\t\t\t\tmin=r.cnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tt.cnt++;\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nvector<int> cnt;\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(ans<=d + dis[y][x])return;\n  if(g[y][x] == 'G')ans = d;\n\n  int tmp = 0;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++;\n      if(cnt[curg]*2 <= num[curg])dfs(ny,nx,d+1,y,x);\n      cnt[curg]--;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n\n    cnt = vector<int>(n,0);\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 63 == 0))Q.pop();\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\nint w, h, sx, sy, gx, gy;\nchar c[16][16];\nint f[16][16];\nvector<int> limit;\n\nvoid mark_ice(int _x, int _y)\n{\n\tint size = 0;\n\tint id = limit.size();\n\n\tqueue<pint> q;\n\tq.push(pint(_x, _y));\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second;\n\t\tq.pop();\n\n\t\tf[y][x] = id;\n\t\t++size;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (valid_pos(nx, ny, w, h) && c[ny][nx] == 'X' && f[ny][nx] == -1)\n\t\t\t\tq.push(pint(nx, ny));\n\t\t}\n\t}\n\n\tlimit.push_back((size + 2) / 2);\n}\n\nint res;\nint walk[256];\nbool visit[16][16];\nint dir[16][16][4];\nvoid dfs(int x, int y, int dis)\n{\n\tif (abs(x - gx) + abs(y - gy) + dis >= res)\n\t\treturn;\n\telse if (x == gx && y == gy)\n\t{\n\t\tres = dis;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint d = dir[y][x][i];\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (valid_pos(nx, ny, w, h) && !visit[ny][nx] && f[ny][nx] != -1)\n\t\t{\n\t\t\tint id = f[ny][nx];\n\t\t\t++walk[id];\n\t\t\tif (walk[id] < limit[id])\n\t\t\t{\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tdfs(nx, ny, dis + 1);\n\t\t\t\tvisit[ny][nx] = false;\n\t\t\t}\n\t\t\t--walk[id];\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> w >> h, w)\n\t{\n\t\tlimit.clear();\n\t\tCL(visit, 0);\n\t\tCL(f, -1);\n\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> c[i];\n\n\t\tlimit.push_back(114514);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (strchr(\"SG.\", c[y][x]))\n\t\t\t\t\tf[y][x] = 0;\n\n\t\t\t\tif (c[y][x] == 'S')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (c[y][x] == 'G')\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t\telse if (c[y][x] == 'X' && f[y][x] == -1)\n\t\t\t\t\tmark_ice(x, y);\n\t\t\t\telse if (c[y][x] == '#')\n\t\t\t\t\tf[y][x] = -1;\n\n\t\t\t\tpint dd[4];\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdd[i] = pint(abs(x + dx[i] - gx) + abs(y + dy[i] - gy), i);\n\t\t\t\tsort(dd, dd + 4);\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdir[y][x][i] = dd[i].second;\n\t\t\t}\n\t\t}\n\n\t\tres = 114514;\n\t\tvisit[sy][sx] = true;\n\t\tdfs(sx, sy, 0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,z,m[13][13],a[36],c[13][13],mn[36],dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\n\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d>=an) return 0;\n\tif (x1==gx && y1==gy) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0; j<4; j++) { if (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) z+=c[y2+dy[j]][x2+dx[j]];}\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1; \n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\ntypedef pair<int ,int> P;\nint X,Y, sx, sy, gx, gy;\nstring map[13];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}; \n\nint ice_lim_cnt(int ice_map[][13], int isx, int isy) {\n  if(ice_map[isy][isx] == 400) {\n    int ice_cnt = 0;\n    queue<P> past;\n    queue<P> que;\n    que.push(P(isx, isy));\n    while(que.size()) {\n      P p = que.front();\n      //      if(p.first == igx && p.second == igy) return;\n      que.pop();\n      for(int i = 0; i < 4; i++) {\n\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\tif(0 <= nx && nx < X && 0 <= ny && ny < Y && map[ny][nx] == 'X' && ice_map[ny][nx] != 0) {\n\t  past.push(P(nx, ny));\n\t  que.push(P(nx,ny));\n\t  ice_cnt++;\n\t  ice_map[ny][nx] = 0;\n\t  //\t  cout << ice_cnt << endl; \n\t  //\t  memo[ny][nx] = memo[p.second][p.first] + 1;\n\t}\n      }\n    }\n    while(past.size()){\n      P p = past.front();\n      past.pop();\n      ice_map[p.second][p.first] = ice_cnt;\n    }\n  }\n}\n\nint bfs(){\n  int ice_map[13][13] ={};\n  int ice_cnt[13][13] ={};\n  int past[13][13] = {};\n\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j< X; j++) {\n      ice_map[i][j] = 400;\n      //      ice_cnt[i][j] = 0;\n    }\n\n  queue<P> que;\n  int memo[13][13] = {};\n  que.push(P(sx, sy));\n  \n  while(que.size()) {\n    \n    P p = que.front();\n    //    cout <<\"first\" << p.first << \"second\" <<p.second << endl;\n\n    if(p.first == gx && p.second == gy) return memo[p.second][p.first];\n    que.pop();\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(0 <= nx && nx < X && 0 <= ny && ny < Y && map[ny][nx] != '#' && (ice_cnt[p.second][p.first] <= ice_map[p.second][p.first] / 2 % 10) && past[ny][nx] == 0) {\n\tif(map[ny][nx] == 'X') {\n\t  ice_lim_cnt(ice_map, nx, ny);\n\t  ice_cnt[ny][nx] = ice_cnt[p.second][p.first] + 1;\n\t  /*cout << \"ice\" << endl;\n\t    for(int j = 0; j < Y; j++) {\n\t    for(int i = 0; i < X; i++)\n\t    //\t      cout << ice_map[j][i];\n\t    //\t    cout << endl;\n\t    }\n\t    cout << ice_cnt[ny][nx] << ice_cnt[p.second][p.first] <<endl;\n\t    \n\t    cout << \"ice_cnt\" << endl;\n\t    for(int j = 0; j < Y; j++) {\n\t    for(int i = 0; i < X; i++)\n\t    cout << ice_cnt[j][i];\n\t    cout <<endl;\n\t    }*/\n\t}\n\t\n\tpast[ny][nx]++;\n\tmemo[ny][nx] = memo[p.second][p.first] + 1;\n\tque.push(P(nx,ny));\n\t/*\n\t  cout << '1' << endl;\n\t  for(int j = 0; j < Y; j++) {\n\t  for(int i = 0; i < X; i++)\n\t  cout << past[j][i];\n\t  cout << endl;\n\t  \n\t  }*/\n      }\n    }\n  }\n}\nint main() {\n  while(cin >> X >> Y, X != 0 || Y != 0) {\n    for(int i = 0; i < Y; i++) {\n      cin >> map[i];\n      for(int j = 0; j < X; j++) \n\tif (map[i][j] == 'S') sx = j, sy = i;\n\telse if(map[i][j] == 'G') gx = j, gy = i;\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nvector<int> cnt;\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d){\n  if(ans<=d + dis[y][x])return;\n  if(g[y][x] == 'G')ans = d;\n\n  int tmp = 0;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx])tmp++;\n  }\n  if(tmp>1)return;\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++;\n      if(cnt[curg]*2 <= num[curg])dfs(ny,nx,d+1);\n      cnt[curg]--;\n    }else{\n      dfs(ny,nx,d+1);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n\n    //rep(i,h){rep(j,w)cout << dis[i][j] << \" \";cout << endl;}\n\n    cnt = vector<int>(n,0);\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n      if(cnt >= 100 && cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n      if(cnt >= 100 && cnt % 4 == 0)\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint ice[14][14];\nint num[10000];\nint gx,gy;\n\nint ans = 0;\nint ccc = 0;\nvoid dfs(int x,int y,int C,int px,int py){\n  if( c[y][x] == '#' || c[y][x] == '*') return;\n  if( C + abs(x-gx) + abs(y-gy) >= ans ) return;\n  if( c[y][x] == 'G'){ans = C; return; }\n\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( px == tx && ty == py ) continue;\n    if( c[ty][tx] == '*' ) return;\n  }\n  char cur = c[y][x];\n  c[y][x] = '*';\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( c[ty][tx] == 'X' ){\n      int b = ice[ty][tx];\n      if( num[b] > 0 ){\n\tnum[b]--;\n\tdfs(tx,ty,C+1,x,y);\n\tnum[b]++;\n      }\n    }else{\n      dfs(tx,ty,C+1,x,y);\n    }\n  }\n  c[y][x] = cur;\n  return;\n}\nvoid grouping(int x,int y,int k){\n  ice[y][x] = k;\n  num[k]++;\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( c[ty][tx] == 'X' && ice[ty][tx] < 0 )grouping(tx,ty,k);\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  int W,H;\n  while(cin >> W >> H && W){\n    memset(ice,-1,sizeof(ice));\n    rep(i,14)rep(j,14) \n      c[i][j] = '#';\n    int sx , sy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> c[i+1][j+1];\n\tif(c[i+1][j+1] == 'S'){\n\t  c[i+1][j+1] = '.';\n\t  sx = j+1 , sy = i+1;\n\t}else if(c[i+1][j+1] == 'G' ){\n\t  gx = j+1 , gy = i+1;\n\t}\n      }\n    }\n    int k = 0;\n    for(int i = 1 ; i <= H ; i++){\n      for(int j = 1 ; j <= W ; j++){\n\tif( c[i][j] == 'X' && ice[i][j] < 0){\n\t  num[k] = 0;\n\t  grouping(j,i,k);\n\t  num[k] /= 2;\n\t  k++;\n\t}\n      }\n    }\n    ans = 1e7;\n    dfs(sx,sy,0,-1,-1);\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(cost+abs(ti-pi)+abs(tj-pj) >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(abs(ti-ni)+abs(tj-nj), make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          ++N;\n        }\n      }\n    }\n    ans = 1000;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\n//int dx[4] = {1, 0, -1, 0};\n//int dy[4] = {0, 1, 0, -1};\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nstruct S{\n    int x, y;\n    int c, h;\n    vector<int> cnt;\n    bool operator < (const S& s) const {\n        if(c + h != s.c + s.h) return c + h > s.c + s.h;\n        return c > s.c;\n    }\n};\n\nint main(){\n    int W, H;\n    while(cin >> W >> H && W){\n        int sx, sy, gx, gy;\n        vector<string> grid(H);\n        REP(y, H) cin >> grid[y];\n        REP(y, H) REP(x, W) if(grid[y][x] == 'S') { grid[y][x] = '.'; sx = x; sy = y; }\n        REP(y, H) REP(x, W) if(grid[y][x] == 'G') { grid[y][x] = '.'; gx = x; gy = y; }\n\n        int ice_count = 0;\n        int ice_id[12][12] = {};\n        vector<int> ice_v;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'X' && ice_id[y][x] == 0){\n            ice_id[y][x] = ++ice_count;\n            ice_v.push_back(1);\n            queue<int> qx, qy;\n            qx.push(x); qy.push(y);\n            while(!qx.empty()){\n                int bx = qx.front(); qx.pop();\n                int by = qy.front(); qy.pop();\n                REP(r, 4) {\n                    int nx = bx + dx[r];\n                    int ny = by + dy[r];\n                    if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] == 'X' && ice_id[ny][nx] == 0){\n                        qx.push(nx);\n                        qy.push(ny);\n                        ice_id[ny][nx] = ice_count;\n                        ice_v[ice_count - 1]++;\n                    }\n                }\n            }\n        }\n\n        int h_value[12][12];\n        memset(h_value, -1, sizeof h_value);\n        queue<int> qx, qy;\n        qx.push(gx); qy.push(gy);\n        h_value[gy][gx] = 0;\n        while(!qx.empty()){\n            int bx = qx.front(); qx.pop();\n            int by = qy.front(); qy.pop();\n            REP(r, 4) {\n                int nx = bx + dx[r];\n                int ny = by + dy[r];\n                if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] != '#' && h_value[ny][nx] == -1){\n                    qx.push(nx);\n                    qy.push(ny);\n                    h_value[ny][nx] = h_value[by][bx] + 1;\n                }\n            }\n        }\n\n        priority_queue<S> que;\n        S init;\n        init.x = sx, init.y = sy;\n        init.cnt.resize(ice_count);\n        init.c = 0; init.h = h_value[sy][sx];\n        set<vector<int>> used[12][12];\n        que.push(init);\n        while(!que.empty()){\n            S s = que.top(); que.pop();\n            if(s.h == 0){\n                cout << s.c << endl;\n                break;\n            }\n            REP(r, 4){\n                S next = s;\n                next.x += dx[r]; next.y += dy[r];\n                if(!(next.x >= 0 && next.x < W && next.y >= 0 && next.y < H && grid[next.y][next.x] != '#')) continue;\n                next.c ++;\n                next.h = h_value[next.y][next.x];\n                int id = ice_id[next.y][next.x] - 1;\n                if(id >= 0) next.cnt[id]++;\n                if(id >= 0 && next.cnt[id] > ice_v[id] / 2) continue;\n                if(used[next.y][next.x].count(next.cnt)) continue;\n                used[next.y][next.x].insert(next.cnt);\n                que.push(next);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\ntypedef tuple<int, int, vector<int>, int> Vertex;\ntypedef tuple<int, int, int> Memo;\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nmap<Memo, int> memo;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint dfs(int y, int x, int step) {\n    if(memo.count(Memo(y, x, step))) return memo[Memo(y, x, step)];\n    if(y == gy && x == gx) return step;\n    int result = -1;\n    if(step == 0) return result;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            result = max(result, dfs(ny, nx, step - 1));\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n        }\n    }\n    return memo[Memo(y, x, step)] = result;\n}\n\nint solve() {\n    memo.clear();\n    for(int i = 1; i <= 1000000; ++i) {\n        int t = dfs(sy, sx, i);\n        if(t != -1) return i - t;\n    }\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring g[20];\nint cnt[200],num[200],n;\nint ice[20][20];\nint sy,sx;\nbool vis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x){\n  if(g[y][x] == 'G')return 0;\n  vis[y][x] = true;\n\n  int res = 200;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx) + 1);\n      cnt[curg]--;\n    }else{\n      res = min(res,dfs(ny,nx) + 1);\n    }\n  }\n  vis[y][x] = false;\n\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n    }\n    /*\n    rep(i,h){rep(j,w)cout << ice[i][j] << \" \";cout << endl;}\n    rep(i,n)cout << num[i] << \" \";cout << endl;\n    */\n\n    memset(cnt,0,sizeof(cnt));\n    memset(vis,0,sizeof(vis));\n    cout << dfs(sy,sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint W, H;\n\nchar ma[16][16];\nchar g[16][16];\nbool v[16][16];\n\nint maxIce[128];\nint ice[128];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint ans;\nint px, py;\nint sx, sy, gx, gy;\n\nbool getMin(int ty, int tx, int turn)\n{\n\n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n        return (false);\n    }\n\n    if (ty == gy && tx == gx){\n        ans = turn;\n        return (true);\n    }\n\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return (false);\n        }\n    }\n\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        px = tx, py = ty;\n        if (0 <= mx && mx < W && 0 <= my && my < H && ma[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n\n    return (false);\n}\n\nvoid label(int ty, int tx, int p)\n{\n    g[ty][tx] = p;\n    maxIce[p]++;\n\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n\n        if (0 <= mx && mx < W && 0 <= my && my < H &&\n                    ma[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n\nint main()\n{\n    int idx;\n\n    while (1){\n        scanf(\"%d %d\", &W, &H);\n\n        if (W + H == 0){\n            break;\n        }\n\n        for (int i = 0; i < H; i++){\n            scanf(\"%s\", ma[i]);\n            for (int j = 0; j < W; j++){\n                if (ma[i][j] == 'S'){\n                    ma[i][j] = '.';\n                    sx = j, sy = i;\n                }\n                if (ma[i][j] == 'G'){\n                    ma[i][j] = '.';\n                    gx = j, gy = i;\n                }\n            }\n        }\n\n        memset(g, -1, sizeof(g));\n        memset(maxIce, 0, sizeof(maxIce));\n\n        idx = 0;\n        for (int i = 0; i < H; i++){\n            for (int j = 0; j < W; j++){\n                if (ma[i][j] == 'X' && g[i][j] == -1){\n                    label(i, j, idx);\n                    maxIce[idx++] /= 2;\n                }\n            }\n        }\n\n        memset(ice, 0, sizeof(ice));\n        memset(v, 0, sizeof(v));\n        px = py = -1;\n        v[sy][sx] = true;\n\n        ans = 0;\n        while (!getMin(sy, sx, 0)){\n            memset(ice, 0, sizeof(ice));\n            memset(v, 0, sizeof(v));\n            px = py = -1;\n            v[sy][sx] = true;\n            ans++;\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,sy,sx,gy,gx;\nchar g[20][20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n\n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X'){\n\tnum[n] = 0;\n\tgroup(i,j,n);\n\tnum[n]/=2;\n\tn++;\n      }\n      if(g[i][j] == 'S'){sy = i; sx = j; g[i][j] = '.';}\n      if(g[i][j] == 'G'){gy = i; gx = j;}\n    }\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,z,m[13][13],a[36],c[13][13],h[13][13],mn[36],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d+1>=an) return 1;\n\tif (h[y1][x1]==1) { if (d+1<an) an=d+1; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0; j<4; j++) { if (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) z+=c[y2+dy[j]][x2+dx[j]];}\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) c[i][j]=h[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tfor (i=0;i<4;i++) {\n\t\tif (gx+dx[i]>=0 && gx+dx[i]<x && gy+dy[i]>=0 && gy+dy[i]<y)\n\t\t if (da[gy+dy[i]][gx+dx[i]]!='#') h[gy+dy[i]][gx+dx[i]]=1;\n\t }\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\tf[gy][gx]=0;\n\t\tmemset(f,0,sizeof(f));\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[k];\n\t\t\t\tu.y+=my[k];\n\t\t\t\tif(map[u.y][u.x]!='#'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==0){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint m[15][15],s[15][15],c[15][15],b[150]={0};\nint min,gy,gx;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint f(int x,int y,int t){\n  int i,j,r,ny,nx;\n  if(s[y][x]+t>min)return min;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n    if(c[ny][nx])continue;\n    if(d[ny][nx]=='X'){\n      if(b[m[ny][nx]]==0)continue;\n      b[m[ny][nx]]--;\n    }//printf(\"%3d %d %d\\n\",t,nx,ny);\n    if(ny==gy&&nx==gx)return t;\n    c[ny][nx]=1;\n    r=f(nx,ny,t+1);\n    if(min>r)min=r;\n    if(d[ny][nx]=='X')b[m[ny][nx]]++;\n    c[ny][nx]=0;\n  }\n  return min;\n}\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,qx[150],qy[150];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=s[i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    s[qy[t=0]=gy][qx[0]=gx]=1;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(s[ny][nx])continue;\n\ts[qy[r]=ny][qx[r]=nx]=s[y][x]+1;\n\tr++;\n      }\n    }\n    /*for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)printf(\"%3d \",m[i][j]);\n      printf(\"\\n\");\n    }\n    for(i=1;i<rr;i++)printf(\"%3d\",b[i]);\n    printf(\"\\n\");//*/\n    printf(\"%d\\n\",f(x,y,1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint distance(int y, int x) {return abs(gy - y) + abs(gx - x);}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    if(step == 0) return NIL;\n    if(distance(y, x) > step) return NIL;\n    int result = NIL;\n    vector<int> index = {0, 1, 2, 3};\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nuc ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)\n    {\n      ice[j+i*w] = inf;\n      ice_cnt[j+i*w] = cinf;\n    }\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      \n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      \n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring g[20];\nvector<int> cnt;\nint num[200],n;\nint ice[20][20];\nint sy,sx;\nbool vis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x, int d){\n  if(ans<=d)return INF;\n  if(g[y][x] == 'G'){ans = min(ans,d); return 0;}\n  //if(memo.find(cnt)!=memo.end()){ans = min(ans,d + memo[cnt]); return memo[cnt];}\n  \n  vis[y][x] = true;\n\n  int res = INF;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[curg]--; cnt[n] = y; cnt[n+1] = x;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[n] = y; cnt[n+1] = x;\n    }\n  }\n  vis[y][x] = false;\n\n  //if(res<INF)memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n    }\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    ans = INF;\n    dfs(sy,sx,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nchar g[20][20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n\n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X'){\n\tnum[n] = 0;\n\tgroup(i,j,n);\n\tnum[n]/=2;\n\tn++;\n      }\n      if(g[i][j] == 'S'){sy = i; sx = j; g[i][j] = '.';}\n      if(g[i][j] == 'G'){gy = i; gx = j;}\n    }\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nvector<int> cnt;\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x, int d){\n  if(ans<=d + dis[y][x])return INF;\n  if(g[y][x] == 'G'){ans = min(ans,d); return 0;}\n  //if(memo.find(cnt)!=memo.end()){ans = min(ans,d + memo[cnt]); return memo[cnt];}\n  \n  vis[y][x] = true;\n\n  int res = INF;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[curg]--;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx,d+1)+1);\n    }\n  }\n  vis[y][x] = false;\n  cnt[n] = y; cnt[n+1] = x;\n\n  //if(res<INF)memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n\n    //rep(i,h){rep(j,w)cout << dis[i][j] << \" \";cout << endl;}\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    ans = INF;\n    dfs(sy,sx,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(ans<=d + dis[y][x])return;\n  if(g[y][x] == 'G')ans = d;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n++]/=2;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (10000)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  int cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),int cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,z,m[13][13],a[36],c[13][13],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d>=an) return 0;\n\tif (x1==gx && y1==gy) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4;j++) if (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) z+=c[y2+dy[j]][x2+dx[j]];\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=1000; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\nint next_depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    int dist = abs(x - goal_x) + abs(y - goal_y);\n    if (step + dist > depth) {\n        next_depth = min(next_depth, step + dist);\n        return false;\n    }\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0 && !G[sy][sx]) {\n                (*ices[sy][sx])--;\n                G[sy][sx] = true;\n                if (iddfs(sx, sy, step+1)) return true;\n                G[sy][sx] = false;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int empty = 100000;\n        int wall = 0;\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ices[y][x] = &empty;\n                break;\n            case '#':\n                ices[y][x] = &wall;\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((bool *)G, 12*12, false);\n        depth = abs(start_x - goal_x) + abs(start_y - goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth = next_depth;\n            next_depth = INF;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct P {\n    int x, y, cost;\n\n    P(int x, int y, int cost): x(x), y(y), cost(cost) {}\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nconst int MAZE_W = 12;\nconst int MAZE_H = 12;\nconst int ICE_N = 144;\n\nconst int PLAIN = -1;\nconst int WALL = -2;\nconst int MAYBE_ICE = -3;\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\n\nchar maze[MAZE_H][MAZE_W];\nvi ice_life;\n\nconst int MAX_STEP = 144;\nint step;\n\nint dfs_ice_block(int x, int y, int ice_num) {\n    maze[y][x] = ice_num;\n    int size = 1;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H && maze[sy][sx] == MAYBE_ICE) {\n            size += dfs_ice_block(sx, sy, ice_num);\n        }\n    }\n    return size;\n}\n\nint dfs_search(int x, int y, int depth) {\n    char cell = maze[y][x];\n    maze[y][x] = WALL;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            char current_cell = maze[sy][sx];\n            if (current_cell == WALL ||\n                    (current_cell >= 0 && ice_life[current_cell] == 0)) {\n                continue;\n            }\n\n            if (sx == goal_x && sy == goal_y) {\n                step = min(step, depth);\n                continue;\n            }\n            if (current_cell >= 0) { // ice\n                ice_life[current_cell]--;\n                dfs_search(sx, sy, depth+1);\n                ice_life[current_cell]++;\n            } else {\n                dfs_search(sx, sy, depth+1);\n            }\n        }\n    }\n    maze[y][x] = cell;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        fill_n((char *)maze, MAZE_W*MAZE_H, WALL);\n        ice_life.clear();\n        step = MAX_STEP;\n\n        REP(y, H) {\n            REP(x, W) {\n                char cell;\n                cin >> cell;\n                switch (cell) {\n                case '.':\n                    maze[y][x] = PLAIN;\n                    break;\n                case '#':\n                    maze[y][x] = WALL;\n                    break;\n                case 'X':\n                    maze[y][x] = MAYBE_ICE;\n                    break;\n                case 'S':\n                    start_x = x;\n                    start_y = y;\n                    maze[y][x] = PLAIN;\n                    break;\n                case 'G':\n                    goal_x = x;\n                    goal_y = y;\n                    maze[y][x] = PLAIN;\n                    break;\n                }\n            }\n        }\n\n        // input\n        int ice_num = 0;\n        REP(y, H) {\n            REP(x, W) {\n                if (maze[y][x] == MAYBE_ICE) {\n                    int size = dfs_ice_block(x, y, ice_num);\n                    ice_life.push_back(size/2);\n                    ice_num++;\n                }\n            }\n        }\n\n        // search\n        dfs_search(start_x, start_y, 1);\n\n        cout << step << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  //if(ans<=d + dis[y][x])return;\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h, w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n]/=2, n++;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n   /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \nint ans;\nint W, H;\n \nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n \nint maxIce[128];\n \nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n \nint sx, sy, gx, gy;\nint px, py;\n \nvoid getMin(int ty, int tx, int *ice, int turn)\n{\n     \n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n        return;\n    }\n     \n    if (ty == gy && tx == gx){\n        ans = turn;\n        return;\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return;\n        }\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        px = tx, py = ty;\n        if (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                getMin(my, mx, ice, turn + 1);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                getMin(my, mx, ice, turn + 1);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n}\n \nvoid label(int ty, int tx, int p)\n{\n    g[ty][tx] = p;\n    maxIce[p]++;\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n         \n        if (0 <= mx && mx < W && 0 <= my && my < H &&\n                    map[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n \nint main()\n{\n    int idx;\n     \n    while (scanf(\"%d %d\", &W, &H) == 2){\n        getchar();\n         \n        if (W + H == 0){\n            break;\n        }\n         \n        for (int i = 0; i < H; i++){\n            scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'S'){\n                    map[i][j] = '.';\n                    sx = j, sy = i;\n                }\n                if (map[i][j] == 'G'){\n                    map[i][j] = '.';\n                    gx = j, gy = i;\n                }\n            }\n        }\n         \n        memset(g, -1, sizeof(g));\n        memset(maxIce, 0, sizeof(maxIce));\n         \n        idx = 0;\n        for (int i = 0; i < H; i++){\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'X' && g[i][j] == -1){\n                    label(i, j, idx);\n                    maxIce[idx++] /= 2;\n                }\n            }\n        }\n         \n        int use[128];\n         \n        memset(use, 0, sizeof(use));\n        memset(v, 0, sizeof(v));\n        px = py = -1;\n        v[sy][sx] = true;\n        ans = W * H;\n        getMin(sy, sx, use, 0);\n         \n        printf(\"%d\\n\", ans);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nbool visited[12][12];\nint visited_ice[12*12];\nint ans;\nint sy, sx, gy, gx;\nvoid dfs2(int y, int x, int py, int px, int d){\n    //printf(\"%d %d\\n\",y,x);\n    if(d >= ans) return;\n    if(y==gy&&x==gx){\n        ans = min(d, ans);\n        return;\n    }\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(ny==py&&nx==px)continue;\n        if(visited[ny][nx]) return;\n    }\n    visited[y][x] = true;\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        //printf(\"y=%d x=%d ny=%d nx=%d\\n\", y, x, ny, nx);\n        if(visited[ny][nx])continue;\n        if(ifield[ny][nx]==-2)continue;\n        if(ifield[ny][nx]>=0){\n            int ice_i = ifield[ny][nx];\n            if(ice_num[ice_i]/2 < visited_ice[ice_i]+1) continue;\n            visited_ice[ice_i]++;\n            dfs2(ny, nx, y, x, d+1);\n            visited_ice[ice_i]--;\n        }else{\n            dfs2(ny, nx, y, x, d+1);\n        }\n    }\n    visited[y][x] = false;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        ans = INF;\n        memset(visited, 0, sizeof(visited));\n        memset(visited_ice, 0, sizeof(visited_ice));\n        dfs2(sy, sx, -1, -1, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint W, H;\n\nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n\nint maxIce[128];\nint ice[128];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint ans;\nint px, py;\nint sx, sy, gx, gy;\n\nbool getMin(int ty, int tx, int turn)\n{\n\n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n        return (false);\n    }\n\n    if (ty == gy && tx == gx){\n        ans = turn;\n        return (true);\n    }\n\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return (false);\n        }\n    }\n\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        px = tx, py = ty;\n        if (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n\n    return (false);\n}\n\nvoid label(int ty, int tx, int p)\n{\n    g[ty][tx] = p;\n    maxIce[p]++;\n\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n\n        if (0 <= mx && mx < W && 0 <= my && my < H &&\n                    map[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n\nint main()\n{\n    int idx;\n\n    while (1){\n        scanf(\"%d %d\", &W, &H);\n\n        if (W + H == 0){\n            break;\n        }\n\n        for (int i = 0; i < H; i++){\n            scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'S'){\n                    map[i][j] = '.';\n                    sx = j, sy = i;\n                }\n                if (map[i][j] == 'G'){\n                    map[i][j] = '.';\n                    gx = j, gy = i;\n                }\n            }\n        }\n\n        memset(g, -1, sizeof(g));\n        memset(maxIce, 0, sizeof(maxIce));\n\n        idx = 0;\n        for (int i = 0; i < H; i++){\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'X' && g[i][j] == -1){\n                    label(i, j, idx);\n                    maxIce[idx++] /= 2;\n                }\n            }\n        }\n\n        memset(ice, 0, sizeof(ice));\n        memset(v, 0, sizeof(v));\n        px = py = -1;\n        v[sy][sx] = true;\n\n        ans = 0;\n        while (!getMin(sy, sx, 0)){\n            memset(ice, 0, sizeof(ice));\n            memset(v, 0, sizeof(v));\n            px = py = -1;\n            v[sy][sx] = true;\n            ans++;\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\nmax_ans = h * w;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      int depth = 0;\n      while(!compute(depth))\n\t{\n\t  depth++;\n\t  mincost.clear();\n\t}\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define INF 1 << 15\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy,ex,ey;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tint mapc[13][13];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tmemset(mapc,-1,sizeof(mapc));\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\t\tmapc[i][j]=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\t\n\t\t\t\tif(mapc[t.y][t.x]>r.cnt+1||mapc[t.y][t.x]==-1){\n\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(mapc[t.y][t.x]<=r.cnt){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tex=t.x;\n\t\t\t\t\tey=t.y;\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(r.visited[t.y][t.x]==0){\n\t\t\t\t\t\n\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<mapc[ey][ex]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nclass adres{\npublic:\n\tint x,y;\n\n\tbool samei(int i,int j){\n\t\treturn (i == x && j == y);\n\t}\n\tbool samed(adres b){\n\t\treturn (b.x == x && b.y == y);\n\t}\n\tvoid print(){\n\t\tprintf(\"座標(%d,%d)\\n\",x,y);\n\t}\n};\n\nvoid iceren(int,int,int);\nvoid syokika();\nvoid debag();\nvoid input();\nvoid icegroup();\nvoid hukasa(adres,int);\n\n//変数宣言\nadres S,G;\nint i,j,r,x,y;\nint map[14][14];\nint shortmap[14][14];\nint tx[4] = {1,-1,0,0},ty[4] = {0,0,-1,1};\nchar in[13];\nchar kind[4] = {\".#X\"};\nint ikind[3] = {-1,-2,-3};\nint icebreak[12*12];\n\nint main()\n{\n\tscanf(\"%d%d\",&x,&y);\n\n\twhile(x != 0 && y != 0){\n\t\t//初期化\n\t\tsyokika();\n\n\t\t//マップの入力と数値化\n\t\t//-1:侵入可能 -2:侵入不可 -3:氷\n\t\tinput();\n\n\t\t//氷のグループ化と耐久度設定\n\t\ticegroup();\n\n\t\t//深さ優先探索\n\t\thukasa(S,0);\n\n\t\tprintf(\"%d\\n\",shortmap[G.x][G.y]);\n\n\t\t//デバッグ用出力\n\t\t//debag();\n\n\t\tscanf(\"%d%d\",&x,&y);\n\t}\n\n\treturn 0;\n}\n\n//深さ優先探索関数\n//nx:現在地のx座標  ny:現在地のy座標  c:氷の管理番号\nvoid iceren(int nx,int ny,int c)\n{\n\tint i,j;\n\n\ticebreak[c]++;\n\t\n\t//現在地は探索済みなので\n\t//マップを管理番号に変えて重複して探索しないようにする\n\tmap[nx][ny] = c;\n\n\t//4方向を調べる\n\tfor(i = 0; i < 4; i++){\n\t\t//もし氷なら移動\n\t\tif(map[nx + tx[i]][ny + ty[i]] == -3){\n\t\t\ticeren(nx + tx[i],ny + ty[i],c);\n\t\t}\n\t}\n\n\treturn;\n}\nvoid syokika()\n{\n\tint i;\n\t\n\t//マップ\n\tfor(i = 0; i <= x+1; i++){\n\t\tmap[i][0] = -2;\n\t\tmap[i][y+1] = -2;\n\t}\n\tfor(i = 0; i <= y+1; i++){\n\t\tmap[0][i] = -2;\n\t\tmap[x+1][i] = -2;\n\t}\n\tfor(i = 0; i <= y+1; i++){\n\t\tfor(j = 0; j <= x+1; j++){\n\t\t\tshortmap[j][i] = y*x+1;\n\t\t}\n\t}\n\t//氷の耐久度\n\tfor(i = 0; i < y*x; i++){\n\t\ticebreak[i] = 0;\n\t}\n}\nvoid debag()\n{\n\t//マップ\n\tfor(i = 0; i <= y+1; i++){\n\t\tfor(j = 0; j <= x+1; j++){\n\t\t\tprintf(\"%3d\",map[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t//氷耐久度\n\tfor(i = 0; i < 12; i++){\n\t\tprintf(\"氷[%d]:%d\\n\",i,icebreak[i]);\n\t}\n\n\t/*各種関数\n\tnow.kazuyuki[0] = 0;\n\t\tnow.kazuyuki[1] = 0;\n\t\tnow.tkayuki[0] = 0;\n\t\tnow.tkayuki[1] = 1;\n\t\tnex = now;\n\t\tlaston.push(now);\n\t\tfor(i = 0; i < 10; i++){\n\t\t\tnex.kazuyuki[0]++;\n\t\t\tlaston.push(nex);\n\t\t}\n\t\tnow.print();\n\t\tprintf(\"%d\\n\",cheklast(now));\n\t*/\n}\nvoid input()\n{\n\tfor(i = 1; i <= y; i++){\n\t\tscanf(\"%s\",in);\n\t\tfor(j = 1; j <= x; j++){\n\t\t\tif(in[j-1] == 'S'){\n\t\t\t\tS.x = j;\n\t\t\t\tS.y = i;\n\t\t\t\tmap[j][i] = -1;\n\t\t\t}\n\t\t\telse if(in[j-1] == 'G'){\n\t\t\t\tG.x = j;\n\t\t\t\tG.y = i;\n\t\t\t\tmap[j][i] = -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(r = 0; r < 4; r++){\n\t\t\t\t\tif(kind[r] == in[j-1]){\n\t\t\t\t\t\tmap[j][i] = ikind[r];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid icegroup()\n{\n\tint c = 0;\n\tfor(i = 1; i <= y; i++){\n\t\tfor(j = 1; j <= x; j++){\n\t\t\tif(map[j][i] == -3){\n\t\t\t\ticeren(j,i,c);\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < c; i++){\n\t\ticebreak[i] /= 2;\n\t}\n}\nvoid hukasa(adres now,int count)\n{\n\tadres nex;\n\tint i;\n\n\t//printf(\"%d手目 \",count);\n\t//now.print();\n\t//最少コスト表の更新\n\tshortmap[now.x][now.y] = count;\n\t\n\t//現在地が氷なら,耐久度を1つ下げる\n\tif(map[now.x][now.y] >= 0){\n\t\ticebreak[map[now.x][now.y]]--;\n\t}\n\t\n\tcount++;\n\t\n\t//4方向探索\n\tfor(i = 0; i < 4; i++){\n\t\tnex.x = now.x+tx[i];\n\t\tnex.y = now.y+ty[i];\n\t\t//nex.print();\n\t\tif(map[nex.x][nex.y] == -1 && shortmap[nex.x][nex.y] > count){\n\t\t\thukasa(nex,count);\n\t\t}\n\t\tif(map[nex.x][nex.y] >= 0 && icebreak[ map[nex.x][nex.y] ] > 0 && shortmap[nex.x][nex.y] > count){\n\t\t\thukasa(nex,count);\n\t\t}\n\t}\n\n\t//もどるので氷の値も戻す\n\tif(map[now.x][now.y] >= 0){\n\t\ticebreak[map[now.x][now.y]]++;\n\t}\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\nint gx,gy;\n\nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n\tif( c[y][x] == '#' || c[y][x] == '*') return 0;\n\tif( C + abs(x-gx) + abs(y-gy) >= ans ) return 0;\n\tif( c[y][x] == 'G'){\n\t\tans = C;\n\t\treturn 0;\n\t}\n\t/*for(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( px == tx && ty == py ) continue;\n\t\tif( c[ty][tx] == '*' ) return 0;\n\t}*/\n\tchar cur = c[y][x];\n\tc[y][x] = '*';\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( c[ty][tx] == 'X' ){\n\t\t\tint b = belong[ty][tx];\n\t\t\tif( ok[b] > 0 ){\n\t\t\t\tok[b]--;\n\t\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t\t\tok[b]++;\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t}\n\t}\n\tc[y][x] = cur;\n\treturn 0;\n}\nint grouping(int x,int y,int k){\n\tif( c[y][x] != 'X') return 0;\n\tif( belong[y][x] != -1 ) return 0;\n\tbelong[y][x] = k;\n\tccc++;\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tgrouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint W,H;\n\twhile(cin >> W >> H && W){\n\t\trep(i,14)rep(j,14) belong[i][j] = -1;\n\t\trep(i,14)rep(j,14) \n\t\t\tc[i][j] = '#';\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif(c[i+1][j+1] == 'S'){\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t\tsx = j+1 , sy = i+1;\n\t\t\t\t}else if(c[i+1][j+1] == 'G' ){\n\t\t\t\t\tgx = j+1 , gy = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t\t\t\t\tccc = 0;\n\t\t\t\t\tgrouping(j,i,k);\n\t\t\t\t\tok[k] = ccc / 2;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e7;\n\t\tdfs(sx,sy,0,-1,-1);\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  uc cost;\n  uc prev;\n  Pox(vector<uc> array=vector<uc>(),uc cost=cinf,uc prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << (short)pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\ninline void dfs(const vs& grid,const vvi& ice,pii g,int i,int j,int step,vvi& vis,vi& lim,int& res)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(grid[i][j]=='X' && lim[ice[i][j]]==0) return;\n\tif(grid[i][j]=='G') res=min(res,step);\n\tif(step+abs(g.first-i)+abs(g.second-j)>=res) return;\n\t\n\tvis[i][j]=true;\n\tif(grid[i][j]=='X') lim[ice[i][j]]--;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#' || vis[ni][nj]) continue;\n\t\tdfs(grid,ice,g,ni,nj,step+1,vis,lim,res);\n\t}\n\tif(grid[i][j]=='X') lim[ice[i][j]]++;\n\tvis[i][j]=false;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvvi ice(h,vi(w,-1));\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X'){\n\t\t\tif(!f.count(uf.Find(i*w+j)))\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\tice[i][j]=f[uf.Find(i*w+j)];\n\t\t}\n\t\tvi cnt(f.size());\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tcnt[ice[i][j]]++;\n\t\tvi lim(cnt.size());\n\t\trep(i,lim.size()) lim[i]=cnt[i]/2;\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S')\n\t\t\trep(gi,h) rep(gj,w) if(grid[gi][gj]=='G'){\n\t\t\t\tvvi vis(h,vi(w));\n\t\t\t\tdfs(grid,ice,mp(gi,gj),i,j,0,vis,lim,res);\n\t\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<char> v;\n  S(int py,int px,vector<char> pv):y(py),x(px),v(pv){\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<char>(nid));\n    set<vector<char> > mem[12][12];\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(!mem[e.y][e.x].insert(e.v).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int ROOM = -1;\nconst int WALL = -2;\nconst int ICE = -3;\n\nconst int MI_X = 13;\nconst int MI_Y= 13;\n\nconst int ANGLE_KIND = 4;//4方向\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint maxx,maxy;//フィールドの大きさ\n\nvector<int>icePow;//氷の耐久力を保存（各フィールドの値はこの要素の値\n\nint abs(int a)\n{\n\tif(a < 0)\n\t\treturn a*-1;\n\telse\n\t\treturn a;\n}\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int _x,int _y):x(_x),y(_y){}\n\tPoint():x(0),y(0){}\n};\n\n\nPoint start;\nPoint gool;\n\nint minField[MI_Y][MI_X];\n\n//iceP iceの位置を保存する\nvoid IceSet(int field[MI_Y][MI_X],Point fP,vector<Point>& iceP)//わたすのは現在のice\n{\n\ticeP.push_back(fP);\n\tfield[fP.y][fP.x] = icePow.size();\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(fP.x+dx[i],fP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == ICE)\n\t\t\tIceSet(field,p,iceP);\n\t}\n\treturn;\n}\n\nvoid Serch(const int field[MI_Y][MI_X],Point sP,int sField[MI_Y][MI_X],int count,vector<int> icePower)\n{\n\tif(count > minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tif(abs(gool.y - sP.y) + abs(gool.x - sP.x) + count >= minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tsField[sP.y][sP.x] = count;\n\t/*cout << endl << endl;\n\tfor(int y=0;y<maxy;++y)\n\t{\n\t\tfor(int x=0;x<maxx;++x)\n\t\t{\n\t\t\tcout << sField[y][x] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tif(field[sP.y][sP.x] >= 0)\n\t\t--icePower[field[sP.y][sP.x]];\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(sP.x+dx[i],sP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == WALL)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] >= 0)\n\t\t\tif(icePower[field[p.y][p.x]] <= 0)//氷がパリーン！\n\t\t\t\tcontinue;\n\t\t\telse if ( sField[p.y][p.x] > count+1)\n\t\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\tif(sField[p.y][p.x] == -1 || sField[p.y][p.x] > count+1)//記録更新！\n\t\t{\n\t\t\tif(p.y == gool.y && p.x == gool.x)\n\t\t\t{\n\t\t\t\tsField[p.y][p.x] = count+1;\n\n\t\t\t\tif(minField[gool.y][gool.x] > sField[gool.y][gool.x] || minField[gool.y][gool.x] == -1)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<maxy;++y)\n\t\t\t\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t\t\t\t\tminField[y][x] = sField[y][x];\n\t\t\t\t}\n\t\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\t\tsField[p.y][p.x] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\t}\n\t\tif(minField[p.y][p.x] < count+1 && minField[p.y][p.x] != -1)\n\t\t{\n\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tsField[sP.y][sP.x] = -1;\n\treturn;\n}\n\nint main(void)\n{\n\tint field[MI_Y][MI_X];\n\n\twhile(cin >> maxx,cin >> maxy,maxx || maxy)//入力\n\t{\n\t\ticePow.clear();\n\t\tfor(int y=0;y<maxy;++y)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tchar input = getchar();\n\t\t\t\tif(input == '.')\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\telse if(input == '#')\n\t\t\t\t\tfield[y][x] = WALL;\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[y][x] = ICE;\n\t\t\t\telse if(input == 'S'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tstart.y = y;\n\t\t\t\t\tstart.x = x;\n\t\t\t\t}\n\t\t\t\telse if(input == 'G'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tgool.y = y;\n\t\t\t\t\tgool.x = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}//入力終わり\n\t\tfor(int y=0;y<maxy;++y)//ICEの値をアレに\n\t\t{\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tvector<Point> v;\n\t\t\t\tif(field[y][x] == ICE)\n\t\t\t\t{\n\t\t\t\t\tIceSet(field,Point(x,y),v);\n\t\t\t\t\ticePow.push_back(v.size()/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ここから深さ優先\n\t\tint serchField[MI_Y][MI_X];\n\t\tfor(int i=0;i<MI_Y;++i)//-1で初期化\n\t\t{\n\t\t\tfor(int j=0;j<MI_X;++j)\n\t\t\t{\n\t\t\t\tserchField[i][j] = -1;\n\t\t\t\tminField[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSerch(field,start,serchField,0,icePow);\n\t\tcout << minField[gool.y][gool.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nbool visited[12][12];\nint visited_ice[12*12];\nint ans;\nint sy, sx, gy, gx;\nvoid dfs2(int y, int x, int py, int px, int d){\n    //printf(\"%d %d\\n\",y,x);\n    if(d >= ans) return;\n    if(y==gy&&x==gx){\n        ans = min(d, ans);\n        return;\n    }\n    if(d + abs(gy-y) + abs(gx-x) >= ans) return;\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(ny==py&&nx==px)continue;\n        if(visited[ny][nx]) return;\n    }\n    visited[y][x] = true;\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        //printf(\"y=%d x=%d ny=%d nx=%d\\n\", y, x, ny, nx);\n        if(visited[ny][nx])continue;\n        if(ifield[ny][nx]==-2)continue;\n        if(ifield[ny][nx]>=0){\n            int ice_i = ifield[ny][nx];\n            if(ice_num[ice_i]/2 < visited_ice[ice_i]+1) continue;\n            visited_ice[ice_i]++;\n            dfs2(ny, nx, y, x, d+1);\n            visited_ice[ice_i]--;\n        }else{\n            dfs2(ny, nx, y, x, d+1);\n        }\n    }\n    visited[y][x] = false;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        ans = INF;\n        memset(visited, 0, sizeof(visited));\n        memset(visited_ice, 0, sizeof(visited_ice));\n        dfs2(sy, sx, -1, -1, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,ck[13][13],m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\nvoid chek(int x1,int y1) {\n\tint k;\n\tck[y1][x1]=1;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (ck[y1+dy[k]][x1+dx[k]]==0) chek(x1+dx[k],y1+dy[k]); \n\t\t   \t\t}\n    }\n\nint ans(int x1,int y1,int d) {\n\tint j,k,x2,y2;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tif (d % 3==0) { \n\t\tfor (j=0;j<y;j++) for (k=0;k<x;k++) { ck[j][k]=f[j][k]; if (da[j][k]=='#') ck[j][k]=1;}\n\t\t chek(x1,y1);\n\t\tif (ck[gy][gx]==0 ) return 0;\n\t    }\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint distance(int y, int x) {return abs(gy - y) + abs(gx - x);}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    if(step == 0) return NIL;\n    if(distance(y, x) > step) return NIL;        // 枝刈り１\n    int result = NIL;\n    vector<int> index = {0, 1, 2, 3};\n    // 枝刈り２\n    for(int i = 0; i < 3; ++i) for(int j = i + 1; j < 4; ++j)\n        if(distance(y + NEXT[index[j]][Y], x + NEXT[index[j]][X]) < distance(y + NEXT[index[i]][Y], x + NEXT[index[i]][X]))\n            swap(index[i], index[j]);\n    for(int i = 0; i < 4; ++i) {\n        int ny = y + NEXT[index[i]][Y];\n        int nx = x + NEXT[index[i]][X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(ans<=d + dis[y][x])return;\n  //if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n++]/=2;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    assert(n<=200);\n\n    /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int ROOM = -1;\nconst int WALL = -2;\nconst int ICE = -3;\n\nconst int MI_X = 13;\nconst int MI_Y= 13;\n\nconst int ANGLE_KIND = 4;//4方向\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint maxx,maxy;//フィールドの大きさ\n\nvector<int>icePow;//氷の耐久力を保存（各フィールドの値はこの要素の値\n\nint abs(int a)\n{\n\tif(a < 0)\n\t\treturn a*-1;\n\telse\n\t\treturn a;\n}\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int _x,int _y):x(_x),y(_y){}\n\tPoint():x(0),y(0){}\n};\n\n\nPoint start;\nPoint gool;\n\nint minField[MI_Y][MI_X];\n\n//iceP iceの位置を保存する\nvoid IceSet(int field[MI_Y][MI_X],Point fP,vector<Point>& iceP)//わたすのは現在のice\n{\n\ticeP.push_back(fP);\n\tfield[fP.y][fP.x] = icePow.size();\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(fP.x+dx[i],fP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == ICE)\n\t\t\tIceSet(field,p,iceP);\n\t}\n\treturn;\n}\n\nvoid Serch(const int field[MI_Y][MI_X],Point sP,int sField[MI_Y][MI_X],int count,vector<int> icePower)\n{\n\tif(count > minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tif(abs(gool.y - sP.y) + abs(gool.x - sP.x) + count >= minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tsField[sP.y][sP.x] = count;\n\t//cout << endl << endl;\n\t//for(int y=0;y<maxy;++y)\n\t//{\n\t//\tfor(int x=0;x<maxx;++x)\n\t//\t{\n\t//\t\tcout << sField[y][x] << ' ';\n\t//\t}\n\t//\tcout << endl;\n\t//}\n\tif(field[sP.y][sP.x] >= 0)\n\t\t--icePower[field[sP.y][sP.x]];\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(sP.x+dx[i],sP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == WALL)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] >= 0)\n\t\t\tif(icePower[field[p.y][p.x]] <= 0)//氷がパリーン！\n\t\t\t\tcontinue;\n\t\t\telse if ( sField[p.y][p.x] > count+1)\n\t\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\tif(sField[p.y][p.x] == -1 || sField[p.y][p.x] > count+1)//記録更新！\n\t\t{\n\t\t\tif(p.y == gool.y && p.x == gool.x)\n\t\t\t{\n\t\t\t\tsField[p.y][p.x] = count+1;\n\n\t\t\t\tif(minField[gool.y][gool.x] > sField[gool.y][gool.x] || minField[gool.y][gool.x] == -1)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<maxy;++y)\n\t\t\t\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t\t\t\t\tminField[y][x] = sField[y][x];\n\t\t\t\t}\n\t\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\t\tsField[p.y][p.x] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\t}\n\t\tif(minField[p.y][p.x] < count+1 && minField[p.y][p.x] != -1)\n\t\t{\n\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tsField[sP.y][sP.x] = -1;\n\treturn;\n}\n\nint main(void)\n{\n\tint field[MI_Y][MI_X];\n\n\twhile(cin >> maxx,cin >> maxy,maxx || maxy)//入力\n\t{\n\t\ticePow.clear();\n\t\tfor(int y=0;y<maxy;++y)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tchar input = getchar();\n\t\t\t\tif(input == '.')\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\telse if(input == '#')\n\t\t\t\t\tfield[y][x] = WALL;\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[y][x] = ICE;\n\t\t\t\telse if(input == 'S'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tstart.y = y;\n\t\t\t\t\tstart.x = x;\n\t\t\t\t}\n\t\t\t\telse if(input == 'G'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tgool.y = y;\n\t\t\t\t\tgool.x = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}//入力終わり\n\t\tfor(int y=0;y<maxy;++y)//ICEの値をアレに\n\t\t{\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tvector<Point> v;\n\t\t\t\tif(field[y][x] == ICE)\n\t\t\t\t{\n\t\t\t\t\tIceSet(field,Point(x,y),v);\n\t\t\t\t\ticePow.push_back(v.size()/2.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ここから深さ優先\n\t\tint serchField[MI_Y][MI_X];\n\t\tfor(int i=0;i<MI_Y;++i)//-1で初期化\n\t\t{\n\t\t\tfor(int j=0;j<MI_X;++j)\n\t\t\t{\n\t\t\t\tserchField[i][j] = -1;\n\t\t\t\tminField[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSerch(field,start,serchField,0,icePow);\n\t\tcout << minField[gool.y][gool.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(abs(ti-pi)+abs(tj-pj) >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n\n  vis[pi][pj] = true;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          ++N;\n        }\n      }\n    }\n    ans = 1000;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(fromG[ni][nj], make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,m[13][13],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nstruct wd {\n\tint x,y,t;\n\tint c[36];\n\tint d[12];\n };\n\nwd w,w2;\nqueue<wd> qu; \n \nint bfs() {\n\tint k,x2,y2;\n\twhile(true) {\n\t\tw=qu.front(); qu.pop();\n\t\tw.d[w.y]|=1 << w.x;\n\t\tfor (k=0;k<4;k++) {\n\t\t\tw2=w;\n\t\t\tx2=w2.x+dx[k]; y2=w2.y+dy[k]; w2.t++;\n\t\t\tif (x2==gx && y2==gy) return w2.t;\n\t\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\t\tif ((w.d[y2] & (1 << x2)) == 0) {\n\t\t\t\t\tw2.x=x2; w2.y=y2;\n\t\t\t\t\tif (m[y2][x2]==-1) qu.push(w2); else {\n\t\t\t\t\t\tif  (w.c[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {w2.c[m[y2][x2]]++; \tqu.push(w2);}}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}\t \nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\twhile(!qu.empty()) qu.pop();\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) w.d[i]=0; for (i=0;i<36;i++) w.c[i]=0;\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='#') w.d[i]|=1 << j;\n\tw.x=sx; w.y=sy; w.t=0;\n\tqu.push(w);\n\tan=bfs();\n\tcout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\n\nint ans(int x1,int y1,int d) {\n\tint k,x2,y2;\n\tif (d>=an) return 0;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 0;}\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {a[m[y2][x2]]++;  ans(x2,y2,d+1); a[m[y2][x2]]--;}\n\t\t\t  } else ans(x2,y2,d+1); \n\t\t\t  f[y1][x1]=0;\n\t\t   }\n\t\t}\n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=145; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \nint ans;\nint W, H;\n \nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n \nint maxIce[128];\nint ice[128];\n \nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n \nint px, py;\nint sx, sy, gx, gy;\n \nvoid getMin(int ty, int tx, int turn)\n{\n     \n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n        return;\n    }\n     \n    if (ty == gy && tx == gx){\n        ans = turn;\n        return;\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return;\n        }\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        px = tx, py = ty;\n        if (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                getMin(my, mx, turn + 1);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                getMin(my, mx, turn + 1);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n}\n \nvoid label(int ty, int tx, int p)\n{\n    g[ty][tx] = p;\n    maxIce[p]++;\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n         \n        if (0 <= mx && mx < W && 0 <= my && my < H &&\n                    map[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n \nint main()\n{\n    int idx;\n     \n    while (1){\n        scanf(\"%d %d\", &W, &H);\n         \n        if (W + H == 0){\n            break;\n        }\n         \n        for (int i = 0; i < H; i++){\n            scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'S'){\n                    map[i][j] = '.';\n                    sx = j, sy = i;\n                }\n                if (map[i][j] == 'G'){\n                    map[i][j] = '.';\n                    gx = j, gy = i;\n                }\n            }\n        }\n         \n        memset(g, -1, sizeof(g));\n        memset(maxIce, 0, sizeof(maxIce));\n         \n        idx = 0;\n        for (int i = 0; i < H; i++){\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'X' && g[i][j] == -1){\n                    label(i, j, idx);\n                    maxIce[idx++] /= 2;\n                }\n            }\n        }\n         \n        memset(ice, 0, sizeof(ice));\n        memset(v, 0, sizeof(v));\n        px = py = -1;\n        v[sy][sx] = true;\n        ans = W * H;\n        getMin(sy, sx, 0);\n         \n        printf(\"%d\\n\", ans);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS =1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\nchar field[101][101];\nint koriNum[101][101];\nint H,W;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nint fillField(int cy,int cx,int id){\n\tkoriNum[cy][cx]=id;\n\tint cnt=1;\n\tfor(int i=0;i<4;i++){\n\t\tint ny=cy+dy[i];\n\t\tint nx=cx+dx[i];\n\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]=='X'&&koriNum[ny][nx]==-1)\n\t\t\tcnt+=fillField(ny,nx,id);\n\t}\n\treturn cnt;\n}\nint sy,sx,gy,gx;\nint minCost;\nint compCnt[1001];\nint footCnt[1001];\nbool passed[101][101];\nint dd[20][20][20][20];\nconst int INF=1000000000;\nvoid bfs(int d[20][20],int ssy,int ssx){\n\tfor(int i=0;i<20;i++)\n\t\tfor(int j=0;j<20;j++)\n\t\t\td[i][j]=INF;\n\td[ssy][ssx]=0;\n\tqueue<pair<int,pii> > q;\n\tq.push(make_pair(0,pii(ssy,ssx)));\n\twhile(q.size()){\n\t\tpair<int,pii> p=q.front();q.pop();\n\t\tint ccost=p.first;\n\t\tint cy=p.second.first;\n\t\tint cx=p.second.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'&&d[ny][nx]==INF){\n\t\t\t\td[ny][nx]=ccost+1;\n\t\t\t\tq.push(make_pair(d[ny][nx],pii(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int cy,int cx,int step,int lim){\n\tif(cy==gy&&cx==gx)minCost=min(minCost,step);\n\telse{\n\t\tif(step==lim)return;\n\t\tint mhd=dd[cy][cx][gy][gx];\n\t\tif(minCost<=mhd+step)return;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i],nx=cx+dx[i];\n\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&!passed[ny][nx]){\n\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\tdfs(ny,nx,step+1,lim);\n\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t}\n\t\t\t\telse if(field[ny][nx]=='X'){\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]++;\n\t\t\t\t\t// 半分+1以上のマスに到達してしまったら、到達不能\n\t\t\t\t\tif(!((compCnt[koriNum[ny][nx]]/2+1)<=footCnt[koriNum[ny][nx]])){\n\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\tdfs(ny,nx,step+1,lim);\n\t\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t\t}\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\twhile(cin>>W>>H&&(H|W)){\n\t\tminCost=1000;\n\t\tmemset(passed,0,sizeof(passed));\n\t\tmemset(compCnt,0,sizeof(compCnt));\n\t\tmemset(footCnt,0,sizeof(footCnt));\n\t\tmemset(koriNum,-1,sizeof(koriNum));\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='S'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='G'){\n\t\t\t\t\tgy=i;\n\t\t\t\t\tgx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint id=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(field[i][j]=='X'){\n\t\t\t\t\tif(koriNum[i][j]==-1){\n\t\t\t\t\t\tcompCnt[id]=fillField(i,j,id);\n\t\t\t\t\t\tid++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<H;i++)\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\tif(field[i][j]!='#')bfs(dd[i][j],i,j);\n\t\tfor(int i=1;;i++){\n\t\t\tpassed[sy][sx]=true;\n\t\t\tdfs(sy,sx,0,i);\n\t\t\tif(minCost!=1000){\n\t\t\t\tcout<<minCost<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassed[sy][sx]=false;\n\t\t}\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>      \nusing namespace std;      \nconst int INF = 1 << 30;      \n      \nint W, H;      \nchar mas[20][20];      \nint sy, sx, gy, gx;      \nint cnt;      \nint snow[144];      \nint number[20][20];      \nbool used[20][20];      \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};      \nint ans;      \n      \nint dfs( int x, int y, const int& idx){      \n  if(x < 0 || x >= W || y < 0 || y >= H) return 0;      \n  if(mas[y][x] != 'X') return 0;      \n  if(number[y][x] != -1) return 0;      \n  number[y][x] = idx;      \n  int ret = 1;      \n  for(int i = 0; i < 4; i++){      \n    ret += dfs( x + dx[i], y + dy[i], idx);      \n  }      \n  return ret;      \n}      \nvoid dfs2( int x, int y, int cost,int prevx, int prevy){      \n  if(ans <= cost + abs( y - gy) + abs( x - gx)) return;      \n  if(y == gy && x == gx){      \n    ans = min( ans, cost);      \n    return;      \n  }      \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n    if(used[ny][nx] && ny != prevy && nx != prevx) return;\n  }\n\n  \n\n  for(int i = 0; i < 4; i++){      \n    int ny = y + dy[i], nx = x + dx[i];      \n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;      \n    if(mas[ny][nx] == '#' || used[ny][nx]) continue;      \n    if(mas[ny][nx] == 'X'){      \n      if(snow[number[ny][nx]] > 0) snow[number[ny][nx]]--;      \n      else continue;      \n    }      \n    used[ny][nx] = true;      \n    dfs2( nx, ny, cost + 1, x, y);      \n    used[ny][nx] = false;      \n    if(mas[ny][nx] == 'X') snow[number[ny][nx]]++;      \n  }      \n  return;      \n}      \n      \nint main(){      \n  ios_base::sync_with_stdio(false);\n  while(cin >> W >> H, W){      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        cin >> mas[i][j];      \n        if(mas[i][j] == 'S' || mas[i][j] == 'G'){      \n          if(mas[i][j] == 'S') sy = i, sx = j;      \n          else gy = i, gx = j;      \n          mas[i][j] = '.';      \n        }      \n      }      \n    }      \n    cnt = 0;      \n    memset( number, -1, sizeof number);      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        if(mas[i][j] == 'X' && number[i][j] == -1){      \n          snow[cnt] = dfs( j, i, cnt) / 2;      \n          cnt++;      \n        }      \n      }      \n    }      \n    memset (used, false, sizeof used);      \n    ans = INF;      \n    used[sy][sx] = true;      \n    dfs2(sx,sy,0,sx,sy);      \n    cout << ans << endl;      \n  }      \n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint W, H;\n\nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n\nint maxIce[128];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint sx, sy, gx, gy;\n\nvoid getMin(int ty, int tx, int *ice, int turn)\n{\n\t//printf(\"%d %d %d\\n\", ty, tx, turn);\n\tif (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n\t\treturn;\n\t}\n\t\n\tif (ty == gy && tx == gx){\n\t\tans = turn;\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n\t\t\tif (g[my][mx] == -1){\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (maxIce[g[my][mx]] < ice[g[my][mx]] + 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tice[g[my][mx]]++;\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t\tice[g[my][mx]]--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid label(int ty, int tx, int p)\n{\n\tg[ty][tx] = p;\n\tmaxIce[p]++;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H &&\n\t\t\t\t\tmap[my][mx] == 'X' && g[my][mx] == -1){\n\t\t\tlabel(my, mx, p);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint idx;\n\t\n\twhile (scanf(\"%d %d\", &W, &H) == 2){\n\t\tgetchar();\n\t\t\n\t\tif (W + H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", &map[i]);\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'S'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tsx = j, sy = i;\n\t\t\t\t}\n\t\t\t\tif (map[i][j] == 'G'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tgx = j, gy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tprintf(\"%s\\n\", map[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\t//*/\n\t\t\n\t\tmemset(g, -1, sizeof(g));\n\t\tmemset(maxIce, 0, sizeof(maxIce));\n\t\t\n\t\tidx = 0;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'X' && g[i][j] == -1){\n\t\t\t\t\tlabel(i, j, idx);\n\t\t\t\t\tmaxIce[idx++] /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tprintf(\"%2d \", g[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t//*/\n\t\t\n\t\tint use[128];\n\t\t\n\t\tmemset(use, 0, sizeof(use));\n\t\tmemset(v, 0, sizeof(v));\n\t\tans = W * H;\n\t\tgetMin(sy, sx, use, 0);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  //if(ans<=d + dis[y][x])return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n++]/=2;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\nint next_depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n\n    // ??´???????????§??????????????????????????¢???depth???????????§????????´??????????????§????????????\n    int dist = abs(x - goal_x) + abs(y - goal_y);\n    if (step + dist > depth) {\n        next_depth = min(next_depth, step + dist);\n        return false;\n    }\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0 && !G[sy][sx]) {\n                (*ices[sy][sx])--;\n//                G[sy][sx] = true;\n                if (iddfs(sx, sy, step+1)) return true;\n//                G[sy][sx] = false;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ice[y][x] = 1;\n                ices[y][x] = &ice[y][x];\n                break;\n            case '#':\n                ice[y][x] = 0;\n                ices[y][x] = &ice[y][x];\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ice[y][x] = 1;\n                ices[y][x] = &ice[y][x];\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ice[y][x] = 1;\n                ices[y][x] = &ice[y][x];\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((bool *)G, 12*12, false);\n        depth = abs(start_x - goal_x) + abs(start_y - goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth = next_depth;\n            next_depth = INF;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    if(step == 0) return NIL;\n    int result = NIL;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX_H 12\n#define MAX_W 12\n#define INF (1<<28)\nint h, w;\nint F[MAX_H][MAX_W];\n\nbool dfs_used[MAX_H][MAX_W];\nconst int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\nint dfs(int y, int x, int n) {\n    F[y][x] = n;\n    int cnt = 1;\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 <= ny && ny < h && 0 <= nx && nx < w && !dfs_used[ny][nx] && F[ny][nx] == INF) \n            cnt += dfs(ny, nx, n);\n    }\n    return cnt;\n}\n\nint ice_count[MAX_H*MAX_W];\nint ice_lump_count;\nvoid init() {\n    memset(dfs_used, 0, sizeof(dfs_used));\n    memset(ice_count, 0, sizeof(ice_count));\n    int n = 1;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (F[i][j] == INF) {\n                ice_count[n] = dfs(i, j, n);\n                n++;\n            }\n        }\n    }\n    ice_lump_count = n;\n}\n\nint sy, sx, gy, gx;\n\nstruct S {\n    int y, x;\n    int t;\n    vector<int> used_ice;\n    S() {}\n    S(int y, int x, vector<int> used_ice, int t) : y(y), x(x), used_ice(used_ice), t(t) {}\n};\n\nint bfs() {\n    map<vector<int>, bool> bfs_used[MAX_H][MAX_W];\n    queue<S> q;\n    vector<int> initial_used_ice(ice_lump_count+1, 0);\n    q.push(S(sy, sx, initial_used_ice, 0));\n    bfs_used[sy][sx][initial_used_ice] = true;\n    while (!q.empty()) {\n        S p = q.front(); q.pop();\n        int y = p.y, x = p.x;\n        int t = p.t;\n        if (y == gy && x == gx) return t;\n        //printf(\"in bfs, y: %d, x: %d, t: %d\", y, x, t);\n        //printf(\"    used: \");\n        //for (int i = 1; i < ice_lump_count; i++) printf(\"%3d \", p.used_ice[i]);\n        //printf(\"\\n\");\n        for (int i = 0; i < 4; i++) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if (0 <= ny && ny < h && 0 <= nx && nx < w && !bfs_used[ny][nx][p.used_ice] && F[ny][nx] >= 0) {\n                vector<int> used_ice = p.used_ice;\n                if (F[ny][nx] > 0) {\n                    int c = F[ny][nx];\n                    used_ice[c]++;\n                    if (used_ice[c] * 2 > ice_count[c]) \n                        continue;\n                }\n                bfs_used[ny][nx][used_ice] = true;\n                q.push(S(ny, nx, used_ice, t+1));\n            }\n        }\n    }\n    return INF;\n}\n\nvoid debug() {\n    printf(\"Ice lump count: %d\\n\", ice_lump_count);\n    printf(\"Ice count: %d\\n\\t\", ice_lump_count);\n    for (int i = 0; i < ice_lump_count; i++) \n        printf(\"%3d \", ice_count[i]);\n    printf(\"\\n\");\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            printf(\"%4d \", F[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    while (cin >> w >> h, w || h) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char t; cin >> t;\n                switch (t) {\n                    case 'S':\n                        sy = i, sx = j;\n                        F[i][j] = 0;\n                        break;\n                    case 'G':\n                        gy = i, gx = j;\n                        F[i][j] = 0;\n                        break;\n                    case '.': \n                        F[i][j] = 0;\n                        break;\n                    case '#':\n                        F[i][j] = -1;\n                        break;\n                    case 'X':\n                        F[i][j] = INF;\n                        break;\n                }\n            }\n        }\n        init();\n        //debug();\n        cout << bfs() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      /*\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      */\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = v.size() + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {result += v[i] * digit; digit *= base;}\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(ny < 1 || h < ny || nx < 1 || w < nx) continue;\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 14 + 1;\n        if(durability.size()) base = max(base, *max_element(durability.begin(), durability.end()) + 1);\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned char uchar;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nint h, w;\nchar field[16][16];\nint label[16][16];\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nint labeling(int y, int x, int l)\n{\n    int ret = 1;\n    label[y][x] = l;\n    \n    rep(i, 4){\n        int py = y + dy[i];\n        int px = x + dx[i];\n        if(py<0 || h<=py || px<0 || w<=px) continue;\n        if(field[py][px] == 'X' && label[py][px] == 0){\n            ret += labeling(py, px, l);\n        }\n    }\n    \n    return ret;\n}\n\nstruct Data\n{\n    int y, x, cost;\n    vector<uchar> broken;\n    \n    bool operator== (const Data& d) const\n    {\n        return y == d.y && x == d.x && broken == d.broken;\n    }\n};\n\nstruct myhash\n{\n    size_t operator()(const Data& d) const\n    {\n        size_t h = d.y ^ d.x;\n        rep(i, d.broken.size()) h ^= d.broken[i] << i;\n        return h;\n    }\n};\n\nint func()\n{\n    rep(i, h) rep(j, w) label[i][j] = 0;\n    \n    rep(i, h){\n        cin >> field[i];\n    }\n    \n    vector<uchar> area;\n    rep(y, h) rep(x, w){\n        if(field[y][x] == 'X' && label[y][x] == 0){\n            area.push_back(labeling(y, x, area.size() + 1));\n        }\n    }\n    \n    for(uchar& a : area){\n        a /= 2;\n    }\n    \n    queue<Data> Q;\n    unordered_set<Data, myhash> visited;\n    \n    rep(y, h) rep(x, w){\n        if(field[y][x] == 'S'){\n            Q.push({y, x, 0, area});\n            visited.insert(Q.front());\n        }\n    }\n    \n    while(!Q.empty()){\n        Data d = Q.front();\n        Q.pop();\n        \n        rep(i, 4){\n            int py = d.y + dy[i];\n            int px = d.x + dx[i];\n            if(py<0 || h<=py || px<0 || w<=px || field[py][px] == '#') continue;\n            \n            Data next;\n            if(field[py][px] == 'G'){\n                return d.cost + 1;\n            }\n            else if(field[py][px] == 'X'){\n                uchar& b = d.broken[label[py][px]-1];\n                if(b == 0) continue;\n                --b;\n                next = {py, px, d.cost + 1, d.broken};\n                ++b;\n            }\n            else{\n                next = {py, px, d.cost + 1, d.broken};\n            }\n            \n            if(visited.count(next)) continue;\n            \n            Q.push(next);\n            visited.insert(next);\n        }\n    }\n    \n    return 0;\n}\n    \nint main()\n{\n    while(cin >> w >> h, w){\n        printf(\"%d\\n\", func());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<int> v;\n  S(int py,int px,vector<int> pv):y(py),x(px),v(pv){\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<int>(nid));\n    set<vector<int> > mem[12][12];\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(!mem[e.y][e.x].insert(e.v).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n      v[i].clear();\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,z,m[13][13],a[36],c[13][13],h[13][13],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d+1>=an) return 1;\n\tif (h[y1][x1]==1) { if (d+1<an) an=d+1; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0; j<4; j++) { if (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) z+=c[y2+dy[j]][x2+dx[j]];}\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) c[i][j]=h[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tfor (i=0;i<4;i++) {\n\t\tif (gx+dx[i]>=0 && gx+dx[i]<x && gy+dy[i]>=0 && gy+dy[i]<y)\n\t\t if (da[gy+dy[i]][gx+dx[i]]!='#') h[gy+dy[i]][gx+dx[i]]=1;\n\t }\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  int prev;\n  Pox(vector<int> array=vector<int>(),int cost=inf,int prev=inf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nconst ull B =1000000007ULL;\nconst ull inv = 13499267949257065399ULL;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  printf(\"%d\\n\",pox.cost);\n\t  //cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    if(step == 0) return NIL;\n    if(abs(gy - y) + abs(gx - x) > step) return NIL;\n    int result = NIL;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define INF 1 << 15\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy,ex,ey;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tint mapc[13][13];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tmemset(mapc,-1,sizeof(mapc));\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\t\tmapc[i][j]=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\t\n\t\t\t\tif(mapc[t.y][t.x]>r.cnt+1||mapc[t.y][t.x]==-1){\n\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(mapc[t.y][t.x]<r.cnt){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tex=t.x;\n\t\t\t\t\tey=t.y;\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(r.visited[t.y][t.x]==0){\n\t\t\t\t\t\n\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<mapc[ey][ex]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \nint ans;\nint W, H;\n \nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n \nint maxIce[128];\n \nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n \nint sx, sy, gx, gy;\n \nvoid getMin(int ty, int tx, int *ice, int turn, int py, int px)\n{\n     \n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n        return;\n    }\n     \n    if (ty == gy && tx == gx){\n        ans = turn;\n        return;\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return;\n        }\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                getMin(my, mx, ice, turn + 1, ty, tx);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                getMin(my, mx, ice, turn + 1, ty, tx);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n}\n \nvoid label(int ty, int tx, int p)\n{\n    g[ty][tx] = p;\n    maxIce[p]++;\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n         \n        if (0 <= mx && mx < W && 0 <= my && my < H &&\n                    map[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n \nint main()\n{\n    int idx;\n     \n    while (1){\n        scanf(\"%d %d\", &W, &H);\n         \n        if (W + H == 0){\n            break;\n        }\n         \n        for (int i = 0; i < H; i++){\n            scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'S'){\n                    map[i][j] = '.';\n                    sx = j, sy = i;\n                }\n                if (map[i][j] == 'G'){\n                    map[i][j] = '.';\n                    gx = j, gy = i;\n                }\n            }\n        }\n         \n        memset(g, -1, sizeof(g));\n        memset(maxIce, 0, sizeof(maxIce));\n         \n        idx = 0;\n        for (int i = 0; i < H; i++){\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'X' && g[i][j] == -1){\n                    label(i, j, idx);\n                    maxIce[idx++] /= 2;\n                }\n            }\n        }\n         \n        int use[128];\n         \n        memset(use, 0, sizeof(use));\n        memset(v, 0, sizeof(v));\n        v[sy][sx] = true;\n        ans = W * H;\n        getMin(sy, sx, use, 0, -1, -1);\n         \n        printf(\"%d\\n\", ans);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nvoid dfs(const vs& grid,const vvi& ice,pii g,int i,int j,int step,vvi& vis,vi& lim,int& res)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[i][j]) return;\n\tif(grid[i][j]=='X' && lim[ice[i][j]]==0) return;\n\tif(grid[i][j]=='G') res=min(res,step);\n\t//if(step>=res) return;\n\tif(step+abs(g.first-i)+abs(g.second-j)>=res) return;\n\tvis[i][j]=true;\n\tif(grid[i][j]=='X') lim[ice[i][j]]--;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tdfs(grid,ice,g,ni,nj,step+1,vis,lim,res);\n\t}\n\tif(grid[i][j]=='X') lim[ice[i][j]]++;\n\tvis[i][j]=false;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvvi ice(h,vi(w,-1));\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X'){\n\t\t\tif(!f.count(uf.Find(i*w+j)))\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\tice[i][j]=f[uf.Find(i*w+j)];\n\t\t}\n\t\tvi cnt(f.size());\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tcnt[ice[i][j]]++;\n\t\tvi lim(cnt.size());\n\t\trep(i,lim.size()) lim[i]=cnt[i]/2;\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S')\n\t\t\trep(gi,h) rep(gj,w) if(grid[gi][gj]=='G'){\n\t\t\t\tvvi vis(h,vi(w));\n\t\t\t\tdfs(grid,ice,mp(gi,gj),i,j,0,vis,lim,res);\n\t\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(abs(ti-pi)+abs(tj-pj) >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(abs(ti-ni)+abs(tj-nj), make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          ++N;\n        }\n      }\n    }\n    ans = 1000;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint p[200];\nint root(int x){\n\tif(p[x] < 0) return x;\n\treturn p[x] = root(p[x]);\n}\nint h, w, dist[200][200];\nchar in[12][13];\n\nint main(){\n\twhile(cin >> w >> h, h){\n\t\tint sy, sx, gy, gx;\n\t\trep(i, h * w) p[i] = -1;\n\t\trep(i, h * w) rep(j, h * w) dist[i][j] = i == j ? 0 : inf;\n\t\t\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t\tif(in[i][j] == 'X') rep(d, 2){\n\t\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\t\tif(ny >= 0 && nx >= 0 && in[ny][nx] == 'X'){\n\t\t\t\t\t\tint a = root(i * w + j), b = root(ny * w + nx);\n\t\t\t\t\t\tif(a != b){\n\t\t\t\t\t\t\tp[a] += p[b];\n\t\t\t\t\t\t\tp[b] = a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif(in[i][j] == '#') continue;\n\t\t\t\tdist[i * w + j][ny * w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tpriority_queue<pair<pi, pair<int, vi> > > q;  //cost*, cost, pos, ice\n\t\tset<pair<int, vi> > s;\n\t\t\n\t\tint n = 0, to[200], sz[200];\n\t\tmemset(to, -1, sizeof(to));\n\t\t\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tint r = root(i * w + j);\n\t\t\tif(to[r] < 0){\n\t\t\t\tsz[n] = -p[r];\n\t\t\t\tto[r] = n++;\n\t\t\t}\n\t\t}\n\t\tq.push(mp(mp(-dist[sy * w + sx][gy * w + gx], 0), mp(sy * w + sx, vi(n))));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tvi v = q.top().second.second;\n\t\t\tint cost = q.top().first.second;\n\t\t\tint y = q.top().second.first;\n\t\t\tint x = y % w; y /= w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(y * w + x, v))) continue;\n\t\t\ts.insert(mp(y * w + x, v));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tvi nv = v;\n\t\t\t\t\n\t\t\t\tint r = root(ny * w + nx);\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tnv[to[r]]++;\n\t\t\t\t\tif(sz[to[r]] < nv[to[r]] * 2) continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!s.count(mp(ny * w + nx, nv)))\n\t\t\t\tq.push(mp(mp(cost - dist[ny * w + nx][gy * w + gx], cost - 1), \n\t\t\t\t\tmp(ny * w + nx, nv)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint W,H,SX,SY,GX,GY,ice_N;\nint field[14][14],ice[14][14],icelife[1000];\nbool flag[14][14];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid dfs(int x, int y);\nbool iddfs(int x, int y, int c);\nint main(){\n  while(cin >>W>>H,W||H){\n    for(int i=0; i<14; i++){for(int j=0; j<14; j++){field[i][j] = 1;flag[i][j] = true;}}\n    memset(ice,0,sizeof(ice));\n    memset(icelife,0,sizeof(icelife));\n    ice_N = 1;\n    string s;\n    int ans;\n    for(int i=1; i<=H; i++){\n      cin >>s;\n      for(int j=1; j<=W; j++){\n\tif(s[j-1] == '.'){field[j][i] = 0;}\n\tif(s[j-1] == '#'){field[j][i] = 1;}\n\tif(s[j-1] == 'X'){field[j][i] = 2;}\n\tif(s[j-1] == 'S'){field[j][i] = 0;SX = j;SY = i;}\n\tif(s[j-1] == 'G'){field[j][i] = 0;GX = j;GY = i;}\n      }\n    }\n    for(int i=1; i<=W; i++){\n      for(int j=1; j<=H; j++){\n\tif(field[i][j] == 2 && ice[i][j] == 0){\n\t  dfs(i,j);\n\t  icelife[ice_N]/=2;\n\t  ice_N++;\n\t}\n      }\n    }\n    for(ans = 0;;ans++){\n      if(iddfs(SX,SY,ans)){cout <<ans+1<<endl;break;}\n    }\n  }\n  return 0;\n}\nvoid dfs(int x, int y){\n  ice[x][y] = ice_N;\n  icelife[ice_N]++;\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(field[p][q] == 2 && ice[p][q] == 0){dfs(p,q);}\n  }\n}\nbool iddfs(int x, int y, int c){\n  bool f = false;\n  if(x == GX && y == GY){return true;}\n  if(c<0){return false;}\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(flag[p][q]){\n      if(field[p][q] == 0){\n\tflag[p][q] = false;\n\tif(iddfs(p,q,c-1)){f = true;}\n\tflag[p][q] = true;\n      }\n      if(field[p][q] == 2){\n\tif(icelife[ice[p][q]]>0){\n\t  flag[p][q] = false;\n\t  icelife[ice[p][q]]--;\n\t  if(iddfs(p,q,c-1)){f = true;}\n\t  icelife[ice[p][q]]++;\n\t  flag[p][q] = true;\n\t}\n      }\n    }\n  }\n  return f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(ans<=d + dis[y][x])return;\n  //if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n++]/=2;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstatic const int INF=(1<<21);\nint c=0;\nvoid katamari(int,int);\nchar map[14][14];\nqueue<pair<int,int> > q; \nstruct r{\n\tint x;\n\tint y;\n\tint cnt;\n\tint icec[144];\n\tbool used[12][12];\n};\nr s,v;\nqueue<r> f;\nint maps[12][12],icem[144],x,y,k,h;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint main()\n{\n\tint i,j;\n\twhile(1){\n\t\tc=0;\n\t\twhile(!q.empty()){\n\t\t\tq.pop();\n\t\t}\n\t\tfor(i=0;i<144;i++){\n\t\t\ticem[i]=0;\n\t\t}\n\t\tfor(i=0;i<12;i++){\n\t\t\tfor(j=0;j<12;j++){\n\t\t\t\tmap[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tcin>>x>>y;\n\t\tif(x==0&&y==0)break;\n\t\tfor(i=0;i<y;i++){\n\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tmaps[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==INF){\n\t\t\t\t\tq.push(make_pair(i,j) );\n\t\t\t\t\tmaps[i][j] = c;\n\t\t\t\t\tkatamari(j,i);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\telse if(map[i][j] == 'S'){\n\t\t\t\t\ts.y = i;\n\t\t\t\t\ts.x = j;\n\t\t\t\t\ts.cnt = 0;\n\t\t\t\t\tfor(k=0;k<144;k++){\n\t\t\t\t\t\ts.icec[k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.used[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(maps[i][j]!=INF){\n\t\t\t\t\ticem[maps[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf.push(s);\n\t\twhile(!f.empty()){\n\t\t\ts = f.front();\n\t\t\tf.pop();\n\t\t\tif(s.used[s.y][s.x]==false){\n\t\t\t\ts.used[s.y][s.x]=true;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF){\n\t\t\t\ts.icec[maps[s.y][s.x]]++;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF&&s.icec[maps[s.y][s.x]]>icem[maps[s.y][s.x]]/2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[s.y][s.x]=='G'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tif(s.x+dx[i]>=0&&s.x+dx[i]<x&&s.y+dy[i]>=0&&s.y+dy[i]<y&&map[s.y+dy[i]][s.x+dx[i]]!='#'&&s.used[s.y+dy[i]][s.x+dx[i]]==false){\n\t\t\t\t\tfor(j=0;j<144;j++){\n\t\t\t\t\t\tv.icec[j]=s.icec[j];\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=0;j<y;j++){\n\t\t\t\t\t\tfor(k=0;k<x;k++){\n\t\t\t\t\t\t\tv.used[j][k]=s.used[j][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.x=s.x+dx[i];\n\t\t\t\t\tv.y=s.y+dy[i];\n\t\t\t\t\tv.cnt=s.cnt+1;\n\t\t\t\t\tf.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<s.cnt<<endl;\n\t}\n\treturn 0;\n}\nvoid katamari(int x,int y){\n\twhile(!q.empty()){\n\t\tpair<int,int> p = q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(map[p.first + dx[i]][p.second + dy[i]] == 'X'&&maps[p.first + dx[i]][p.second + dy[i]]==INF){\n\t\t\t\tmaps[p.first + dx[i]][p.second + dy[i]] = c;\n\t\t\t\tq.push(make_pair(p.first + dx[i],p.second + dy[i]));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t if (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4 ;j++) z+=c[y2+dy[j]][x2+dx[j]];   \n\t\t\t\t\tif (z<2) {\n\t\t\t\t\tfor (j=0;j<4;j++) if (da[y2+dy[i]][x2+dx[i]]!='#' && m[y2+dy[i]][x2+dx[i]]<0 && c[y2+dy[i]][x2+dx[i]]==0)\n\t\t\t\t\t    if (c[y2+dy[i]*2][x2+dx[i]*2]==1) z=2;\n\t\t\t\t\tif (z<2) {\n\t\t\t\t\tif ((x2==gx && y2==gy) || d+1>=an) { if (d+1<an) an=d+1; return 1;}\t    \n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=0;j<=x+1;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[15][15];\npair<int,int> par[15][15];\nint sz[15][15];\nint now[15][15];\nint v[15][15];\nint tr,tc;\nint H,W;\nvoid dfs0(int a,int b){\n\tpar[a][b]=make_pair(tr,tc);\n\tsz[tr][tc]++;\n\tv[a][b]=1;\n\tif(a&&str[a-1][b]=='X'&&!v[a-1][b])dfs0(a-1,b);\n\tif(b&&str[a][b-1]=='X'&&!v[a][b-1])dfs0(a,b-1);\n\tif(a<H-1&&str[a+1][b]=='X'&&!v[a+1][b])dfs0(a+1,b);\n\tif(b<W-1&&str[a][b+1]=='X'&&!v[a][b+1])dfs0(a,b+1);\n}\nint res;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint used[15][15];\nint dfs(int a,int b,int c){\n\tif(str[a][b]=='G'){\n\t\treturn 1;\n\t}\n\tif(c==0)return 0;\n\tfor(int i=0;i<4;i++){\n\t\tif(a+dx[i]<0||a+dx[i]>=H||b+dy[i]<0||b+dy[i]>=W)continue;\n\t\tif(used[a+dx[i]][b+dy[i]])continue;\n\t\tif(str[a+dx[i]][b+dy[i]]=='#')continue;\n\t\tif(a+dx[i]&&b+dy[i]&&used[a+dx[i]-1][b+dy[i]-1]&&used[a+dx[i]-1][b+dy[i]]&&used[a+dx[i]][b+dy[i]-1])continue;\n\t\tif(a+dx[i]&&b+dy[i]<W-1&&used[a+dx[i]-1][b+dy[i]]&&used[a+dx[i]-1][b+dy[i]+1]&&used[a+dx[i]][b+dy[i]+1])continue;\n\t\tif(a+dx[i]<H-1&&b+dy[i]&&used[a+dx[i]][b+dy[i]-1]&&used[a+dx[i]+1][b+dy[i]]&&used[a+dx[i]+1][b+dy[i]-1])continue;\n\t\tif(a+dx[i]<H-1&&b+dy[i]<W-1&&used[a+dx[i]][b+dy[i]+1]&&used[a+dx[i]+1][b+dy[i]]&&used[a+dx[i]+1][b+dy[i]+1])continue;\n\t\tif(str[a+dx[i]][b+dy[i]]=='X'){\n\t\t\tint row=par[a+dx[i]][b+dy[i]].first;\n\t\t\tint col=par[a+dx[i]][b+dy[i]].second;\n\t\t\tif((now[row][col]+1)*2>sz[row][col])continue;\n\t\t\tnow[row][col]++;\n\t\t\tused[a+dx[i]][b+dy[i]]=1;\n\t\t\tif(dfs(a+dx[i],b+dy[i],c-1))return 1;\n\t\t\tused[a+dx[i]][b+dy[i]]=0;\n\t\t\tnow[row][col]--;\n\t\t}else{\n\t\t\tused[a+dx[i]][b+dy[i]]=1;\n\t\t\tif(dfs(a+dx[i],b+dy[i],c-1))return 1;\n\t\t\tused[a+dx[i]][b+dy[i]]=0;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)v[i][j]=now[i][j]=sz[i][j]=used[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='X'&&!v[i][j]){\n\t\t\t\ttr=i;tc=j;\n\t\t\t\tdfs0(i,j);\n\t\t\t}\n\t\t}\n\t\tres=99999;\n\t//\tint ret;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(str[i][j]=='S'){\n\t\t\tfor(int k=0;;k++){\n\t\t\t\t//res=0;\n\t\t\t\tres=dfs(i,j,k);\n\t\t\t\tif(res){\n\t\t\t\t\tprintf(\"%d\\n\",k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=10000;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[12][12];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\tcin>>lx>>ly;\n\t\tif(lx==0&&ly==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(maps,0,sizeof(maps));\n\t\tmemset(ig,0,sizeof(ig));\n\t\tmin=10000;\n\tfor(i=0;i<ly;i++){\n\t\tcin>>map[i];\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(map[i][j]=='S'){\n\t\t\t\tr.x=j;\n\t\t\t\tr.y=i;\n\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\tr.cnt=0;\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\tv.x=j;\n\t\t\t\tv.y=i;\n\t\t\t\tq.push(v);\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tv=q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tu=v;\n\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(maps[i][j]>0){\n\t\t\t\tig[maps[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!s.empty()){\n\t\tr=s.top();\n\t\ts.pop();\n\t\tif(r.visited[r.y][r.x]==1){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tr.visited[r.y][r.x]=1;\n\t\t}\n\t\tif(map[r.y][r.x]=='G'&&r.cnt<min){\n\t\t\tmin=r.cnt;\n\t\t\tcontinue;\n\t\t}\n\t\tif(maps[r.y][r.x]>0){\n\t\t\ta=maps[r.y][r.x];\n\t\t\tr.ic[a]++;\n\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tt=r;\n\t\t\tt.x+=mx[i];\n\t\t\tt.y+=my[i];\n\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\tt.cnt++;\n\t\t\t\ts.push(t);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\n\nint W,H;\nint data[12][12];\nint h[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n\n};\n\ntypedef pair<int,State>PP;\ntypedef pair<int,P>P2;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n/*\nvoid dfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n*/\n\nbool dfs(PP pp,int lim){\n\n   int cnt = pp.first;\n\n\n   State state = pp.second;\n   P p = state.p;\n\n   if(cnt + h[p.first][p.second] - 1 > lim)return false;\n   \n   if(p == g){\n      cout << cnt << endl;\n      return true;\n   }\n   \n   for(int i = 0 ; i < 4 ; i++){\n      P np = P(p.first + dy[i],p.second + dx[i]);\n      if(!check(np))continue;\n      \n      int here = data[np.first][np.second];\n      if(here == wall)continue;\n      if(state.vis[np.first][np.second] < cnt)continue;\n\n      state.p = np;\n\n      int tmp =  state.vis[np.first][np.second];\n      \n      if(here >= 0){\n\n         if(state.v[here] <= mv[here]/2)continue;\n         if(mv[here] == 1)continue;\n         \n         state.v[here]--;\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.v[here]++;\n         state.vis[np.first][np.second] = tmp;\n      }\n      else{\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.vis[np.first][np.second] = tmp;\n      }\n      state.p = p;\n   }\n   return false;\n}\n\n\n\nvoid bfs(){\n   \n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         h[i][j] = INF;\n      }\n   }\n\n   queue<P2>que;\n   que.push(P2(0,g));\n\n   h[g.first][g.second] = 0;\n\n   while(que.size()){\n      P2 p2 = que.front(); que.pop();\n      int cnt = p2.first;\n      P p = p2.second;\n\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] == wall)continue;\n         if(h[np.first][np.second] != INF)continue;\n         h[np.first][np.second] = cnt+1;\n         que.push(P2(cnt+1,np));\n      }\n   }\n}\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n   //bfs();\n   \n   //State state;\n   //state.set(mv,s);\n\n   bfs();\n   \n/*\n   cout << H << ' ' << W << endl;\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         cout << h[i][j];\n      }\n      cout << endl;\n   }\n*/      \n   for(int i = 1 ; ; i++){\n      State state;\n      state.set(mv,s);\n      if(dfs(PP(0,state),i))break;\n   }\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      //cout << \"W = \" << W << \" H = \" << H << endl;//\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint ice[14][14];\nint num[10000];\nint gx,gy;\n\nint ans = 0;\nint ccc = 0;\nvoid dfs(int x,int y,int C,int px,int py){\n  if( c[y][x] == '#' || c[y][x] == '*') return;\n  if( C + abs(x-gx) + abs(y-gy) >= ans ) return;\n  if( c[y][x] == 'G'){ans = C; return; }\n\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( px == tx && ty == py ) continue;\n    if( c[ty][tx] == '*' ) return;\n  }\n  char cur = c[y][x];\n  c[y][x] = '*';\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if( c[ty][tx] == 'X' ){\n      int b = ice[ty][tx];\n      if( num[b] > 0 ){\n\tnum[b]--;\n\tdfs(tx,ty,C+1,x,y);\n\tnum[b]++;\n      }\n    }else{\n      dfs(tx,ty,C+1,x,y);\n    }\n  }\n  c[y][x] = cur;\n  return;\n}\nvoid grouping(int x,int y,int k){\n  if( c[y][x] != 'X') return;\n  if( ice[y][x] != -1 ) return;\n  ice[y][x] = k;\n  num[k]++;\n  for(int i = 0 ; i < 4 ; i++)\n    grouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  int W,H;\n  while(cin >> W >> H && W){\n    rep(i,14)rep(j,14) ice[i][j] = -1;\n    rep(i,14)rep(j,14) \n      c[i][j] = '#';\n    int sx , sy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> c[i+1][j+1];\n\tif(c[i+1][j+1] == 'S'){\n\t  c[i+1][j+1] = '.';\n\t  sx = j+1 , sy = i+1;\n\t}else if(c[i+1][j+1] == 'G' ){\n\t  gx = j+1 , gy = i+1;\n\t}\n      }\n    }\n    int k = 0;\n    for(int i = 1 ; i <= H ; i++){\n      for(int j = 1 ; j <= W ; j++){\n\tif( c[i][j] == 'X' && ice[i][j] == -1){\n\t  num[k] = 0;\n\t  grouping(j,i,k);\n\t  num[k] /= 2;\n\t  k++;\n\t}\n      }\n    }\n    ans = 1e7;\n    dfs(sx,sy,0,-1,-1);\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 12\n\nstruct Info{\n\tInfo(){\n\t\trow = col = 0;\n\t}\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator==(const struct Info &arg) const{\n\t\treturn row == arg.row && col == arg.col;\n\t}\n\tint row,col;\n};\n\nint W,H;\nint ice_index,index_table[NUM][NUM];\nint diff_row[4] = {1,0,-1,0},diff_col[4] = {0,1,0,-1};\nint num_member[NUM*NUM],ice_count_table[NUM*NUM];\nint ans;\nchar base_map[NUM][NUM+1];\nbool visited[NUM][NUM];\nInfo start,goal;\n\nbool rangeCheck(Info info){\n\tif(info.row >= 0 && info.row <= H-1 && info.col >= 0 && info.col <= W-1){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(Info info,int sum_cost){\n\n\tif(info == goal){\n\t\tans = min(ans,sum_cost);\n\t\treturn;\n\t}\n\n\t//最小値が出ないならreturn\n\tif(sum_cost+abs(info.row-goal.row)+abs(info.col-goal.col) >= ans){\n\t\treturn;\n\t}\n\n\tint adj_row,adj_col;\n\tint adj_row_2,adj_col_2;\n\n\tbool FLG;\n\n\tfor(int i = 0; i < 4; i++){\n\n\t\tadj_row = info.row+diff_row[i];\n\t\tadj_col = info.col+diff_col[i];\n\n\t\tif(rangeCheck(Info(adj_row,adj_col)) == false || base_map[adj_row][adj_col] == '#' ||\n\t\t\t\tvisited[adj_row][adj_col] == true)continue;\n\n\t\t//最小値が出ないならcontinue\n\t\tif(sum_cost+abs(adj_row-goal.row)+abs(adj_col-goal.col) >= ans)continue;\n\n\t\tFLG = true;\n\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tadj_row_2 = adj_row+diff_row[k];\n\t\t\tadj_col_2 = adj_col+diff_col[k];\n\n\t\t\tif(rangeCheck(Info(adj_row_2,adj_col_2)) == false || base_map[adj_row_2][adj_col_2] == '#' ||\n\t\t\t\t\t(adj_row_2 == info.row && adj_col_2 == info.col))continue;\n\n\t\t\tif(visited[adj_row_2][adj_col_2]){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)continue;\n\n\t\tif(base_map[adj_row][adj_col] == '.'){\n\n\t\t\tvisited[adj_row][adj_col] = true;\n\t\t\trecursive(Info(adj_row,adj_col),sum_cost+1);\n\n\t\t\tvisited[adj_row][adj_col] = false;\n\n\t\t}else{ //base_map[adj_row][adj_col] == 'X'\n\n\t\t\tint tmp_index = index_table[adj_row][adj_col];\n\t\t\tif(ice_count_table[tmp_index]+1 > num_member[tmp_index]/2)continue; //氷が割れるのでcontinue\n\n\t\t\tvisited[adj_row][adj_col] = true;\n\t\t\tice_count_table[tmp_index]++;\n\t\t\trecursive(Info(adj_row,adj_col),sum_cost+1);\n\n\t\t\tvisited[adj_row][adj_col] = false;\n\t\t\tice_count_table[tmp_index]--;\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] == 'S'){\n\n\t\t\t\tstart.set(row,col);\n\t\t\t\tbase_map[row][col] = '.';\n\n\t\t\t}else if(base_map[row][col] == 'G'){\n\n\t\t\t\tgoal.set(row,col);\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\t//氷マスを連結させる&枚数を数える\n\tice_index = 0;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tindex_table[row][col] = -1;\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\tint adj_row,adj_col,count;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] != 'X' || index_table[row][col] != -1)continue;\n\n\t\t\tindex_table[row][col] = ice_index;\n\t\t\tQ.push(Info(row,col));\n\n\t\t\tcount = 1;\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\n\t\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(Info(adj_row,adj_col)) == false || base_map[adj_row][adj_col] != 'X' ||\n\t\t\t\t\t\t\tindex_table[adj_row][adj_col] != -1)continue;\n\n\t\t\t\t\tindex_table[adj_row][adj_col] = ice_index;\n\t\t\t\t\tcount++;\n\n\t\t\t\t\tQ.push(Info(adj_row,adj_col));\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\n\t\t\tnum_member[ice_index] = count;\n\t\t\tice_index++;\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tvisited[row][col] = false;\n\t\t}\n\t}\n\tvisited[start.row][start.col] = true;\n\n\tans = H*W;\n\tfor(int i = 0; i < ice_index; i++)ice_count_table[i] = 0;\n\n\trecursive(start,0);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nint G[12][12];\nint depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    if (step == depth) return false;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (G[sy][sx] >= step && *ices[sy][sx] > 0) {\n                G[sy][sx] = step;\n                (*ices[sy][sx])--;\n                if (iddfs(sx, sy, step+1)) return true;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int empty = 100000;\n        int wall = 0;\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ices[y][x] = &empty;\n                break;\n            case '#':\n                ices[y][x] = &wall;\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        depth = abs(start_x - goal_y) + abs(start_y - goal_y);\n        depth--;\n        do {\n            fill_n((int *)G, 12*12, INF);\n            depth++;\n        } while (!iddfs(start_x, start_y, 0));\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  //if(ans<=d + dis[y][x])return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h && w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n]/=2, n++;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n   /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nvoid dfs(const vs& grid,const vvi& ice,int i,int j,int step,vvi& vis,vi& lim,int& res)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[i][j]) return;\n\tif(grid[i][j]=='X' && lim[ice[i][j]]==0) return;\n\tif(grid[i][j]=='G') res=min(res,step);\n\tif(step>=res) return;\n\tvis[i][j]=true;\n\tif(grid[i][j]=='X') lim[ice[i][j]]--;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tdfs(grid,ice,ni,nj,step+1,vis,lim,res);\n\t}\n\tif(grid[i][j]=='X') lim[ice[i][j]]++;\n\tvis[i][j]=false;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvvi ice(h,vi(w,-1));\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X'){\n\t\t\tif(!f.count(uf.Find(i*w+j)))\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\tice[i][j]=f[uf.Find(i*w+j)];\n\t\t}\n\t\tvi cnt(f.size());\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tcnt[ice[i][j]]++;\n\t\tvi lim(cnt.size());\n\t\trep(i,lim.size()) lim[i]=cnt[i]/2;\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S'){\n\t\t\tvvi vis(h,vi(w));\n\t\t\tdfs(grid,ice,i,j,0,vis,lim,res);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = 0;\n    unsigned long long digit = 1;\n    for(int i = 0; i < v.size(); ++i) {result += v[i] * digit; digit *= base;}\n    result += step * digit;\n    result *= 225;\n    result += y + x * 15;\n    return result;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x;\n    vector<int> v;\n    y = n % 15; n /= 15;\n    x = n % 15; n /= 15;\n    for(int i = 0; i < durability.size(); ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 0;\n        if(durability.size()) base = max(base, *max_element(durability.begin(), durability.end()) + 1);\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n \nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n \nint belong[14][14];\nint ok[10000];\nint gx,gy;\n \nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n    if( c[y][x] == '#' || c[y][x] == '*') return 0;\n    if( C + abs(x-gx) + abs(y-gy) >= ans ) return 0;\n    if( c[y][x] == 'G'){\n        ans = C;\n        return 0;\n    }\n    for(int i = 0 ; i < 4 ; i++){\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if( px == tx && ty == py ) continue;\n        if( c[ty][tx] == '*' ) return 0;\n    }\n    char cur = c[y][x];\n    c[y][x] = '*';\n    for(int i = 0 ; i < 4 ; i++){\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if( c[ty][tx] == 'X' ){\n            int b = belong[ty][tx];\n            if( ok[b] > 0 ){\n                ok[b]--;\n                dfs(tx,ty,C+1,x,y);\n                ok[b]++;\n            }\n        }else{\n            dfs(tx,ty,C+1,x,y);\n        }\n    }\n    c[y][x] = cur;\n    return 0;\n}\nint grouping(int x,int y,int k){\n    if( c[y][x] != 'X') return 0;\n    if( belong[y][x] != -1 ) return 0;\n    belong[y][x] = k;\n    ccc++;\n    for(int i = 0 ; i < 4 ; i++)\n        grouping(x+dx[i],y+dy[i],k);\n}\n \nint main(){\n    ios_base::sync_with_stdio(false);\n    int W,H;\n    while(cin >> W >> H && W){\n        rep(i,14)rep(j,14) belong[i][j] = -1;\n        rep(i,14)rep(j,14) \n            c[i][j] = '#';\n        int sx , sy;\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                cin >> c[i+1][j+1];\n                if(c[i+1][j+1] == 'S'){\n                    c[i+1][j+1] = '.';\n                    sx = j+1 , sy = i+1;\n                }else if(c[i+1][j+1] == 'G' ){\n                    gx = j+1 , gy = i+1;\n                }\n            }\n        }\n        int k = 0;\n        for(int i = 1 ; i <= H ; i++){\n            for(int j = 1 ; j <= W ; j++){\n                if( c[i][j] == 'X' && belong[i][j] == -1){\n                    ccc = 0;\n                    grouping(j,i,k);\n                    ok[k] = ccc / 2;\n                    k++;\n                }\n            }\n        }\n        ans = 1e7;\n        dfs(sx,sy,0,-1,-1);\n        cout << ans << endl;\n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\npriority_queue<Pox> Q;\n\nvoid init()\n{\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n\n      if( cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      int depth = 0;\n      while(!compute(depth))\n\t{\n\t  depth++;\n\n\t}\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nstruct S{\n    int x, y;\n    int c, h;\n    vector<int> cnt;\n    bool operator < (const S& s) const {\n        return c + h > s.c + s.h;\n    }\n};\n\nint main(){\n    int W, H;\n    while(cin >> W >> H && W){\n        int sx, sy, gx, gy;\n        vector<string> grid(H);\n        REP(y, H) cin >> grid[y];\n        REP(y, H) REP(x, W) if(grid[y][x] == 'S') { grid[y][x] = '.'; sx = x; sy = y; }\n        REP(y, H) REP(x, W) if(grid[y][x] == 'G') { grid[y][x] = '.'; gx = x; gy = y; }\n\n        int ice_count = 0;\n        int ice_id[12][12] = {};\n        vector<int> ice_v;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'X' && ice_id[y][x] == 0){\n            ice_id[y][x] = ++ice_count;\n            ice_v.push_back(1);\n            queue<int> qx, qy;\n            qx.push(x); qy.push(y);\n            while(!qx.empty()){\n                int bx = qx.front(); qx.pop();\n                int by = qy.front(); qy.pop();\n                REP(r, 4) {\n                    int nx = bx + dx[r];\n                    int ny = by + dy[r];\n                    if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] == 'X' && ice_id[ny][nx] == 0){\n                        qx.push(nx);\n                        qy.push(ny);\n                        ice_id[ny][nx] = ice_count;\n                        ice_v[ice_count - 1]++;\n                    }\n                }\n            }\n        }\n\n        int h_value[12][12];\n        memset(h_value, -1, sizeof h_value);\n        queue<int> qx, qy;\n        qx.push(gx); qy.push(gy);\n        h_value[gy][gx] = 0;\n        while(!qx.empty()){\n            int bx = qx.front(); qx.pop();\n            int by = qy.front(); qy.pop();\n            REP(r, 4) {\n                int nx = bx + dx[r];\n                int ny = by + dy[r];\n                if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] != '#' && h_value[ny][nx] == -1){\n                    qx.push(nx);\n                    qy.push(ny);\n                    h_value[ny][nx] = h_value[by][bx] + 1;\n                }\n            }\n        }\n\n        priority_queue<S> que;\n        S init;\n        init.x = sx, init.y = sy;\n        init.cnt.resize(ice_count);\n        init.c = 0; init.h = h_value[sy][sx];\n        set<vector<int>> used[12][12];\n        que.push(init);\n        bool output = false;\n        while(!que.empty()){\n            S s = que.top(); que.pop();\n            if(s.h == 0){\n                cout << s.c << endl;\n                output = true;\n                break;\n            }\n            REP(r, 4){\n                S next = s;\n                next.x += dx[r]; next.y += dy[r];\n                if(!(next.x >= 0 && next.x < W && next.y >= 0 && next.y < H && grid[next.y][next.x] != '#')) continue;\n                next.c ++;\n                next.h = h_value[next.y][next.x];\n                int id = ice_id[next.y][next.x] - 1;\n                if(id >= 0) next.cnt[id]++;\n                if(id >= 0 && next.cnt[id] > ice_v[id] / 2) continue;\n                if(used[next.y][next.x].count(next.cnt)) continue;\n                used[next.y][next.x].insert(next.cnt);\n                que.push(next);\n            }\n        }\n        assert(output);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<array>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<int> v;\n  S(int py,int px,vector<int> pv):y(py),x(px),v(pv){\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<int>(nid));\n    set<vector<int> > s[12][12];\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(any_of(begin(s[e.y][e.x]),end(s[e.y][e.x]),[&](vector<int> v){\n\t      for(int i=0;i<nid;i++){\n\t\tif(v[i]>e.v[i])return false;\n\t      }\n\t      return true;\n\t    }))continue;\n\ts[e.y][e.x].insert(e.v);\n\t//\tif(!s[e.y][e.x].insert(e.v).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint h,w;\nchar B[12][13],gy,gx;\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // ツ氷ツづーツ督・ツづアツつセツ嘉アツ青?\nvoid dfs(int i,int j,int now){\n\tif(B[i][j]=='X') if(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\n\tif(ans<=now+abs(i-gy)+abs(j-gx)) return; // Manhattan ツ仰猟猟」ツづ?A*\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tvis[i][j]=true;\n\tif(B[i][j]=='X') step[ice[i][j]]++;\n\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]){\n\t\t\t// ツつアツづェツづ慊づ?づ可津環づ?つスツ督ケツつゥツづァ (y,x) ツづ可シツδ?ーツトツカツッツトツつオツづ?猟按づェツづゥツ湘ェツ債?づ債枝ツ環?づィ\n\t\t\tbool ok=true;\n\t\t\trep(l,4){\n\t\t\t\tint yy=y+dy[l],xx=x+dx[l];\n\t\t\t\tif((yy!=i || xx!=j) && 0<=yy && yy<h && 0<=xx && xx<w && vis[yy][xx]) ok=false;\n\t\t\t}\n\t\t\tif(ok) dfs(y,x,now+1);\n\t\t}\n\t}\n\n\tvis[i][j]=false;\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t}\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,z,v,m[13][13],a[36],c[13][13],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d>=an) return 1;\n\tif (x1==gx && y1==gy) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0; j<4; j++) { if (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) z+=c[y2+dy[j]][x2+dx[j]];}\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; v=dfs(x2,y2,d+1); a[m[y2][x2]]--;} else v=dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t\tif (v==1) return 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1; \n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,int > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  random_shuffle(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].first;\n    int nj = v[i].second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d>=an) return 1;\n\tif (x1==gx && y1==gy) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0; j<4; j++) z+=c[y2+dy[j]][x2+dx[j]];\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=1;j<=x;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nint W,H,SX,SY,GX,GY,ice_N;\nint field[14][14],ice[14][14],icelife[1000];\nbool flag[14][14];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid dfs(int x, int y);\nbool iddfs(int x, int y, int c);\nint main(){\n  while(cin >>W>>H,W||H){\n    for(int i=0; i<14; i++){for(int j=0; j<14; j++){field[i][j] = 1;flag[i][j] = true;}}\n    memset(ice,0,sizeof(ice));\n    memset(icelife,0,sizeof(icelife));\n    ice_N = 1;\n    string s;\n    int ans;\n    for(int i=1; i<=H; i++){\n      cin >>s;\n      for(int j=1; j<=W; j++){\n\tif(s[j-1] == '.'){field[j][i] = 0;}\n\tif(s[j-1] == '#'){field[j][i] = 1;}\n\tif(s[j-1] == 'X'){field[j][i] = 2;}\n\tif(s[j-1] == 'S'){field[j][i] = 0;SX = j;SY = i;}\n\tif(s[j-1] == 'G'){field[j][i] = 0;GX = j;GY = i;}\n      }\n    }\n    for(int i=1; i<=W; i++){\n      for(int j=1; j<=H; j++){\n\tif(field[i][j] == 2 && ice[i][j] == 0){\n\t  dfs(i,j);\n\t  icelife[ice_N]/=2;\n\t  ice_N++;\n\t}\n      }\n    }\n    for(ans = abs(SX-GX)+abs(SY-GY);;ans++){\n      if(iddfs(SX,SY,ans)){cout <<ans<<endl;break;}\n    }\n  }\n  return 0;\n}\nvoid dfs(int x, int y){\n  ice[x][y] = ice_N;\n  icelife[ice_N]++;\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(field[p][q] == 2 && ice[p][q] == 0){dfs(p,q);}\n  }\n}\nbool iddfs(int x, int y, int c){\n  bool f = false;\n  if(x == GX && y == GY){return true;}\n  if(c<abs(x-GX)+abs(y-GY)){return false;}\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(flag[p][q]){\n      if(field[p][q] == 0){\n\tflag[p][q] = false;\n\tif(iddfs(p,q,c-1)){f = true;}\n\tflag[p][q] = true;\n      }\n      if(field[p][q] == 2){\n\tif(icelife[ice[p][q]]>0){\n\t  flag[p][q] = false;\n\t  icelife[ice[p][q]]--;\n\t  if(iddfs(p,q,c-1)){f = true;}\n\t  icelife[ice[p][q]]++;\n\t  flag[p][q] = true;\n\t}\n      }\n    }\n  }\n  return f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n#define at(t, i) get<i>(t)\n\nint h, w;\nint sx, sy, gx, gy;\nchar grid[14][14];\nint dist[14][14];\nint group[14][14];\nint size[1024];\nbool visit[14][14];\n\nbool search(int x, int y, int d)\n{\n\tif (visit[x][y]) return false;\n\tif (dist[x][y] > d) return false;\n\tif (group[x][y] != -1 && size[group[x][y]] <= 1) return false;\n\t\n\tif (x == gx && y == gy) return true;\n\t\n\tvisit[x][y] = true;\n\tif (group[x][y] != -1) size[group[x][y]]--;\n\t\n\tfor (int dir = 0; dir < 4; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tif (grid[nx][ny] == '#') continue;\n\t\tif (visit[nx][ny]) continue;\n\t\tif (search(nx, ny, d - 1)) return true;\n\t}\n\t\n\tvisit[x][y] = false;\n\tif (group[x][y] != -1) size[group[x][y]]++;\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tint color = 0;\n\tfor (int i = 1; i <= h; i++){\n\t\tfor (int j = 1; j <= w; j++){\n\t\t\tif (compl group[i][j]) continue;\n\t\t\tif (grid[i][j] != 'X') continue;\n\t\t\tsize[color] = 1;\n\t\t\tgroup[i][j] = color;\n\t\t\t\n\t\t\tqueue<Pr> que;\n\t\t\tfor (que.push(Pr(i, j)); que.size(); que.pop()){\n\t\t\t\tPr p = que.front();\n\t\t\t\tint x = p.first, y = p.second;\n\t\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\t\tint nx = x + dx[dir];\n\t\t\t\t\tint ny = y + dy[dir];\n\t\t\t\t\tif (group[nx][ny] == -1 && grid[nx][ny] == 'X'){\n\t\t\t\t\t\tgroup[nx][ny] = color;\n\t\t\t\t\t\tsize[color]++;\n\t\t\t\t\t\tque.push(Pr(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsize[color] = size[color] / 2 + 1;\n\t\t\tcolor++;\n\t\t}\n\t}\n\t\n\t{\n\t\tqueue<Tp> que;\n\t\tdist[gx][gy] = 0;\n\t\tfor (que.push(Tp(gx, gy, 0)); que.size(); que.pop()){\n\t\t\tTp t = que.front();\n\t\t\tint x = at(t, 0), y = at(t, 1), d = at(t, 2);\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[dir];\n\t\t\t\tif (grid[nx][ny] == '#') continue;\n\t\t\t\tif (dist[nx][ny] < INF) continue;\n\t\t\t\tdist[nx][ny] = d + 1;\n\t\t\t\tque.push(Tp(nx, ny, d + 1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int d = 1; ; d++){\n\t\tif (search(sx, sy, d)) return d;\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), h){\n\t\tfill_n(*grid, 14 * 14, '#');\n\t\tfill_n(*dist, 14 * 14, INF);\n\t\tfill_n(*group, 14 * 14, -1);\n\t\tfill_n(size, 1024, 0);\n\t\tfill_n(*visit, 14 * 14, false);\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'S'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 'G'){\n\t\t\t\t\tgx = i;\n\t\t\t\t\tgy = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint p[200];\nint root(int x){\n\tif(p[x] < 0) return x;\n\treturn p[x] = root(p[x]);\n}\nint h, w, dist[200][200];\nchar in[12][13];\n\nint main(){\n\twhile(cin >> w >> h, h){\n\t\tint sy, sx, gy, gx;\n\t\trep(i, h * w) p[i] = -1;\n\t\trep(i, h * w) rep(j, h * w) dist[i][j] = i == j ? 0 : inf;\n\t\t\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t\tif(in[i][j] == 'X') rep(d, 2){\n\t\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\t\tif(ny >= 0 && nx >= 0 && in[ny][nx] == 'X'){\n\t\t\t\t\t\tint a = root(i * w + j), b = root(ny * w + nx);\n\t\t\t\t\t\tif(a != b){\n\t\t\t\t\t\t\tp[a] += p[b];\n\t\t\t\t\t\t\tp[b] = a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif(in[i][j] == '#') continue;\n\t\t\t\tdist[i * w + j][ny * w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tpriority_queue<pair<pi, pair<int, vi> > > q;  //cost*, cost, pos, ice\n\t\tset<pair<int, vi> > s;\n\t\tint n = 0, to[100], sz[100];\n\t\tmemset(to, -1, sizeof(to));\n\t\t\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tint r = root(i * w + j);\n\t\t\tif(to[r] < 0){\n\t\t\t\tsz[n] = -p[r];\n\t\t\t\tto[r] = n++;\n\t\t\t}\n\t\t}\n\t\tq.push(mp(mp(-dist[sy * w + sx][gy * w + gx], 0), mp(sy * w + sx, vi(n))));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tvi v = q.top().second.second;\n\t\t\tint cost = q.top().first.second;\n\t\t\tint y = q.top().second.first;\n\t\t\tint x = y % w; y /= w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(y * w + x, v))) continue;\n\t\t\ts.insert(mp(y * w + x, v));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tvi nv = v;\n\t\t\t\t\n\t\t\t\tint r = root(ny * w + nx);\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tnv[to[r]]++;\n\t\t\t\t\tif(sz[to[r]] < nv[to[r]] * 2) continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!s.count(mp(ny * w + nx, nv)))\n\t\t\t\tq.push(mp(mp(cost - dist[ny * w + nx][gy * w + gx], cost - 1), \n\t\t\t\t\tmp(ny * w + nx, nv)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,vector<int> > State;\nconst int MAX_W = 12;\nconst int INF = 1e+8;\n\nint w, h;\nvector<string> s;\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// ice[y][x] := 氷の番号を返す. (連結な氷をひとつのまとまりとする)\nint ice[MAX_W][MAX_W];\n\n// 氷の連結成分を調べる.\nvoid dfs(int x, int y, vector<P>& vp){\n\tif( s[y][x] == 'X' ){\n\t\ts[y][x] = 'x';\n\t\tvp.push_back( P(x,y) );\n\t}else{\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\tif( s[my][mx] == 'X' ){\n\t\t\tdfs(mx,my,vp);\n\t\t}\n\t}\n}\n\nint solve(){\n\tint sx, sy, gx, gy;\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tice[y][x] = -1;\n\t\t}\n\t}\n\t// b[id] := 氷の番号 id があと何歩で壊れるかを返す.\n\tvector<int> b;\n\t// スタートとゴールと氷の連結成分を調べる.\n\tint id=0;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == 'S' ){\n\t\t\t\ts[y][x]  = '.';\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t}\n\t\t\tif( s[y][x] == 'G' ){\n\t\t\t\ts[y][x]  = '.';\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t}\n\t\t\tif( s[y][x] == 'X' ){\n\t\t\t\tvector<P> vp;\n\t\t\t\tdfs(x,y,vp);\n\t\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\t\tint ax = vp[i].first;\n\t\t\t\t\tint ay = vp[i].second;\n\t\t\t\t\tice[ay][ax] = id;\n\t\t\t\t}\n\t\t\t\tb.push_back( vp.size()/2 );\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t}\n\tmap<State,int> d;\n\td[State(P(sx,sy),b)] = 0;\n\tqueue<State> q;\n\tq.push( State(P(sx,sy),b) );\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint x = q.front().first.first;\n\t\tint y = q.front().first.second;\n\t\tvector<int> b = q.front().second;\n\t\tint cnt = d[State(P(x,y),b)];\n\t\tq.pop();\n\t\t\n\t\tif( x == gx && y == gy ){\n\t\t\tres = cnt;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tif( s[my][mx] == '.' ){\n\t\t\t\tState next(P(mx,my),b);\n\t\t\t\tif( !d.count(next) ){\n\t\t\t\t\td[next] = cnt+1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( s[my][mx] == 'x' ){\n\t\t\t\tint id = ice[my][mx];\n\t\t\t\tif( id < b.size() && b[id] > 0 ){\n\t\t\t\t\tb[id]--;\n\t\t\t\t\tState next(P(mx,my),b);\n\t\t\t\t\tif( !d.count(next) ){\n\t\t\t\t\t\td[next] = cnt+1;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t\tb[id]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\ts = vector<string>(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> s[y];\n\t\t}\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  int cnt = 0;\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      \n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define INF 100000000\nchar c[12][12];\nint X,Y;\n\nbool check(int sx,int sy){\n  queue<int> vx, vy;\n  vx.push(sx); vy.push(sy);\n\n  char copy[X][Y];\n  for(int i=0;i<X;i++)\n    for(int j=0;j<Y;j++)\n      copy[i][j] = c[i][j];\n  copy[sx][sy] = '#';\n\n  int count_ice = 0;\n  int count_break = 1;\n  while(!vx.empty()&&!vy.empty()){\n    int x = vx.front(); vx.pop();\n    int y = vy.front(); vy.pop();\n    for(int i=-1;i<=1;i++){\n      if((0<=x+i&&x+i<X)&&(copy[x+i][y]=='X'||copy[x+i][y]=='!')){\n        if(copy[x+i][y]=='X') count_ice++;\n        if(copy[x+i][y]=='!') count_break++;\n        copy[x+i][y] = '#';\n        vx.push(x+i); vy.push(y);\n      }\n      if((0<=y+i&&y+i<Y)&&(copy[x][y+i]=='X'||copy[x][y+i]=='!')){\n        if(copy[x][y+i]=='X') count_ice++;\n        if(copy[x][y+i]=='!') count_break++;\n        copy[x][y+i] = '#';\n        vx.push(x); vy.push(y+i);\n      }\n    }\n  }\n  return count_ice >= count_break;\n}\n\nint search(int x,int y,int count){\n  //cout << x << \" \" << y << endl;\n  if(c[x][y]=='G') return count;\n  char save = c[x][y];\n  int ans = INF;\n  if(c[x][y]=='X'){\n    c[x][y] = '!';\n    bool ok = check(x,y);\n    if(!ok){\n      c[x][y] = save;\n      return INF;\n    }\n  }\n  else c[x][y] = '#';\n\n  for(int i=-1;i<=1;i++){\n    if((0<=x+i&&x+i<X)&&c[x+i][y]!='#'&&c[x+i][y]!='!')\n      ans = min(ans,search(x+i,y,count+1));\n    if((0<=y+i&&y+i<Y)&&c[x][y+i]!='#'&&c[x][y+i]!='!')\n      ans = min(ans,search(x,y+i,count+1));\n  }\n  c[x][y] = save;\n  return ans;\n}\n\nint main(){\n  while(cin >> X >> Y){\n    if(X==0&&Y==0) break;\n    int x,y;\n\n    for(int j=0;j<Y;j++){\n      for(int i=0;i<X;i++){\n        cin >> c[i][j];\n        if(c[i][j]=='S'){\n          x = i;\n          y = j;\n        }\n      }\n    }\n    cout << search(x,y,0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\ninline void dfs(const vs& grid,const vvi& ice,pii g,int i,int j,int step,vvi& vis,vi& lim,int& res)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[i][j]) return;\n\tif(grid[i][j]=='X' && lim[ice[i][j]]==0) return;\n\tif(grid[i][j]=='G') res=min(res,step);\n\tif(step+abs(g.first-i)+abs(g.second-j)>=res) return;\n\tvis[i][j]=true;\n\tif(grid[i][j]=='X') lim[ice[i][j]]--;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tdfs(grid,ice,g,ni,nj,step+1,vis,lim,res);\n\t}\n\tif(grid[i][j]=='X') lim[ice[i][j]]++;\n\tvis[i][j]=false;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvvi ice(h,vi(w,-1));\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X'){\n\t\t\tif(!f.count(uf.Find(i*w+j)))\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\tice[i][j]=f[uf.Find(i*w+j)];\n\t\t}\n\t\tvi cnt(f.size());\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tcnt[ice[i][j]]++;\n\t\tvi lim(cnt.size());\n\t\trep(i,lim.size()) lim[i]=cnt[i]/2;\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S')\n\t\t\trep(gi,h) rep(gj,w) if(grid[gi][gj]=='G'){\n\t\t\t\tvvi vis(h,vi(w));\n\t\t\t\tdfs(grid,ice,mp(gi,gj),i,j,0,vis,lim,res);\n\t\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\ttypedef vector<unsigned char> vuc;\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvuc c;\n\t\t\tState(int i,int j,int d,const vuc& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\t\n\t\tqueue<State> q;\n\t\tq.emplace(s.first,s.second,0,vuc(f.size()));\n\t\tmap<pair<pii,vuc>,int> memo;\n\t\tmemo[mp(s,vuc(f.size()))]=0;\n\t\twhile(!q.empty()){\n\t\t\tState cur=q.front(); q.pop();\n\t\t\tif(mp(cur.i,cur.j)==g) break;\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tvuc nc=cur.c;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tnc[p]++;\n\t\t\t\t\tif(2*nc[p]>cnt[p])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\titer(memo) it=memo.find(mp(mp(ni,nj),nc)); \n\t\t\t\tif(it==memo.end() || it->second>cur.d+1){\n\t\t\t\t\tmemo[mp(mp(ni,nj),nc)]=cur.d+1;\n\t\t\t\t\tq.emplace(ni,nj,cur.d+1,nc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\tfor(auto kv:memo)\n\t\t\tif(kv.first.first==g)\n\t\t\t\tres=min(res,kv.second);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define MAX 18\n#define INFTY (1<<20)\n\nconst int dy[4] = {0, -1, 0, 1};\nconst int dx[4] = {1, 0, -1, 0};\n\nchar M[MAX][MAX];\nint C[256], U[256];\nbool V[MAX][MAX];\nint I[MAX][MAX];\nint D[MAX][MAX][MAX][MAX];\n\nint ncomponent;\nint limit;\n\nint H, W, sy, sx, gy, gx;\n\nbool valid(int ny, int nx){\n  return ( ny >= 0 && nx >= 0 && ny < H && nx < W );\n}\nvoid init(){\n  for ( int i = 0; i < 256; i++ ) C[i] = 0;\n}\nvoid init2(){\n  for ( int i = 0; i < 256; i++ ) U[i] = 0;\n  for ( int i = 0; i < H; i++ ){\n    for ( int j = 0; j < W; j++ ){\n      V[i][j] = false;\n    }\n  }\n}\nbool dfs(int py, int px , int depth){\n  if ( py == gy && px == gx ) return true;\n  //if ( depth >= limit ) return false;\n  if ( depth + D[py][px][gy][gx] > limit ) return false;\n\n  int nx, ny;\n  for ( int r = 0; r < 4; r++ ){\n    ny = py + dy[r];\n    nx = px + dx[r];\n    if ( ny < 0 || nx < 0 || ny >= H || nx >= W ) continue;\n    if ( M[ny][nx] == '#' || V[ny][nx] ) continue;\n     \n    if (M[ny][nx] != '.' ){\n      if ( !(U[I[ny][nx]] >= C[I[ny][nx]]/2) ){\n\tV[ny][nx] = true;\n\tU[I[ny][nx]]++;\n\tif ( dfs(ny, nx, depth+1) ) return true;\n\tV[ny][nx] = false;\n\tU[I[ny][nx]]--;\n      }\n    } else {\n      V[ny][nx] = true;\n      if ( dfs(ny, nx, depth+1) ) return true;\n      V[ny][nx] = false;\n    }\n  }\n  return false;\n}\n\nint solve(){\n  for ( limit = 0; limit < H*W; limit++ ){\n    init2();\n    if ( dfs(sy, sx, 0) ){\n      return limit;\n    }\n  }\n  return -1;\n}\n\nvoid parse(int y, int x, int id, int &area){\n  I[y][x] = id;\n  area++;\n  int ny, nx;\n  for ( int r = 0; r < 4; r++ ){\n    ny = y + dy[r];\n    nx = x + dx[r];\n    if ( !valid(ny, nx) ) continue;\n    if ( M[ny][nx] != 'X' ) continue;\n    if ( I[ny][nx] != -1 ) continue;\n    parse(ny, nx, id, area);\n  }\n}\n\nint bfs(int psy, int psx, int pgy, int pgx){\n  queue<pair<int, int>  > Q;\n  int d[MAX][MAX];\n  rep(i, H) rep(j, W) d[i][j] = INFTY;\n  d[psy][psx] = 0;\n  Q.push(make_pair(psy, psx));\n  \n  pair<int, int> u, v;\n  while( !Q.empty() ){\n    u = Q.front(); Q.pop();\n    if ( u.first == pgy && u.second == pgx ) return d[pgy][pgx];\n    int ny, nx;\n    for ( int r = 0; r < 4; r++ ){\n      ny = u.first + dy[r];\n      nx = u.second + dx[r];\n      if ( !valid(ny, nx) ) continue;\n      if ( M[ny][nx] == '#' ) continue;\n      if ( d[ny][nx] != INFTY ) continue;\n      d[ny][nx] = d[u.first][u.second] + 1;\n      Q.push(make_pair(ny, nx));\n    }\n  }\n  return INFTY;\n}\nvoid makeTable(){\n  ncomponent = 0;\n  rep(i, H) rep(j, W) I[i][j] = -1;\n  rep(i, H) rep(j, W){\n    if ( M[i][j] == 'X' && I[i][j] < 0) {\n      int area = 0;\n      parse(i, j, ncomponent, area);\n      C[ncomponent] = area;\n      ncomponent++;\n    }\n  }\n  for ( int a = 0; a < H*W-1; a++){\n    for ( int b = a+1; b < H*W; b++ ){\n      D[a/W][a%W][b/W][b%W] = D[b/W][b%W][a/W][a%W] = bfs(a/W, a%W, b/W, b%W);\n    }\n  }\n}\n\nmain(){\n  while(1){\n    cin >> W >> H;\n    if ( H == 0 && W == 0 ) break;\n    init();\n    for ( int i = 0; i < H; i++ ){\n      for ( int j = 0; j < W; j++ ){\n\tcin >> M[i][j];\n\tif ( M[i][j] == 'S' ) {\n\t  sy = i; sx = j;\n\t  M[i][j] = '.';\n\t} else if ( M[i][j] == 'G' ){\n\t  gy = i; gx = j;\n\t  M[i][j] = '.';\n\t}\n      }\n    }\n    makeTable();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\n\nint W,H;\nint data[12][12];\nint h[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n\n};\n\ntypedef pair<int,State>PP;\ntypedef pair<int,P>P2;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n/*\nvoid dfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n*/\n\nbool dfs(PP pp,int lim){\n\n   int cnt = pp.first;\n\n\n   State state = pp.second;\n   P p = state.p;\n\n   if(cnt + h[p.first][p.second] - 3 > lim)return false;\n   \n   if(p == g){\n      cout << cnt << endl;\n      return true;\n   }\n   \n   for(int i = 0 ; i < 4 ; i++){\n      P np = P(p.first + dy[i],p.second + dx[i]);\n      if(!check(np))continue;\n      \n      int here = data[np.first][np.second];\n      if(here == wall)continue;\n      if(state.vis[np.first][np.second] < cnt)continue;\n\n      state.p = np;\n\n      int tmp =  state.vis[np.first][np.second];\n      \n      if(here >= 0){\n\n         if(state.v[here] <= mv[here]/2)continue;\n         if(mv[here] == 1)continue;\n         \n         state.v[here]--;\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.v[here]++;\n         state.vis[np.first][np.second] = tmp;\n      }\n      else{\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.vis[np.first][np.second] = tmp;\n      }\n      state.p = p;\n   }\n   return false;\n}\n\n\n\nvoid bfs(){\n   \n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         h[i][j] = INF;\n      }\n   }\n\n   queue<P2>que;\n   que.push(P2(0,g));\n\n   h[g.first][g.second] = 0;\n\n   while(que.size()){\n      P2 p2 = que.front(); que.pop();\n      int cnt = p2.first;\n      P p = p2.second;\n\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] == wall)continue;\n         if(h[np.first][np.second] != INF)continue;\n         h[np.first][np.second] = cnt+1;\n         que.push(P2(cnt+1,np));\n      }\n   }\n}\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n   //bfs();\n   \n   //State state;\n   //state.set(mv,s);\n\n   bfs();\n   \n/*\n   cout << H << ' ' << W << endl;\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         cout << h[i][j];\n      }\n      cout << endl;\n   }\n*/      \n   for(int i = 1 ; ; i++){\n      State state;\n      state.set(mv,s);\n      if(dfs(PP(0,state),i))break;\n   }\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      //cout << \"W = \" << W << \" H = \" << H << endl;//\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS =1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\nchar field[101][101];\nint koriNum[101][101];\nint H,W;\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint fillField(int cy,int cx,int id){\n\tkoriNum[cy][cx]=id;\n\tint cnt=1;\n\tfor(int i=0;i<4;i++){\n\t\tint ny=cy+dy[i];\n\t\tint nx=cx+dx[i];\n\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]=='X'&&koriNum[ny][nx]==-1)\n\t\t\tcnt+=fillField(ny,nx,id);\n\t}\n\treturn cnt;\n}\nint sy,sx,gy,gx;\nint minCost;\nint compCnt[1001];\nint footCnt[1001];\nbool passed[101][101];\nvoid dfs(int cy,int cx,int step){\n\tif(cy==gy&&cx==gx){\n\t\tminCost=min(minCost,step);\n\t}\n\telse{\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=cy+dy[i];\n\t\t\tint nx=cx+dx[i];\n\t\t\tif(ny>=0&&nx>=0&&ny<H&&nx<W&&!passed[ny][nx]){\n\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\tdfs(ny,nx,step+1);\n\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t}\n\t\t\t\telse if(field[ny][nx]=='X'){\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]++;\n\t\t\t\t\t// 半分+1以上のマスに到達してしまったら、到達不能\n\t\t\t\t\tif(!((compCnt[koriNum[ny][nx]]/2+1)<=footCnt[koriNum[ny][nx]])){\n\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\tdfs(ny,nx,step+1);\n\t\t\t\t\t\tpassed[ny][nx]=false;\n\t\t\t\t\t}\n\t\t\t\t\tfootCnt[koriNum[ny][nx]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve(){\n\twhile(cin>>W>>H&&(H|W)){\n\t\tminCost=1000000;\n\t\tmemset(passed,0,sizeof(passed));\n\t\tmemset(compCnt,0,sizeof(compCnt));\n\t\tmemset(footCnt,0,sizeof(footCnt));\n\t\tmemset(koriNum,-1,sizeof(koriNum));\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='S'){\n\t\t\t\t\tsy=i;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='G'){\n\t\t\t\t\tgy=i;\n\t\t\t\t\tgx=j;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint id=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(field[i][j]=='X'){\n\t\t\t\t\tif(koriNum[i][j]==-1){\n\t\t\t\t\t\tcompCnt[id]=fillField(i,j,id);\n\t\t\t\t\t\tid++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpassed[sy][sx]=true;\n\t\tdfs(sy,sx,0);\n\t\tcout<<minCost<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int ROOM = -1;\nconst int WALL = -2;\nconst int ICE = -3;\n\nconst int MI_X = 13;\nconst int MI_Y= 13;\n\nconst int ANGLE_KIND = 4;//4方向\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint maxx,maxy;//フィールドの大きさ\n\nvector<int>icePow;//氷の耐久力を保存（各フィールドの値はこの要素の値\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int _x,int _y):x(_x),y(_y){}\n\tPoint():x(0),y(0){}\n};\n\n\nPoint start;\nPoint gool;\n\nint minField[MI_Y][MI_X];\n\n//iceP iceの位置を保存する\nvoid IceSet(int field[MI_Y][MI_X],Point fP,vector<Point>& iceP)//わたすのは現在のice\n{\n\ticeP.push_back(fP);\n\tfield[fP.y][fP.x] = icePow.size();\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(fP.x+dx[i],fP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == ICE)\n\t\t\tIceSet(field,p,iceP);\n\t}\n\treturn;\n}\n\nvoid Serch(const int field[MI_Y][MI_X],Point sP,int sField[MI_Y][MI_X],int count,vector<int> icePower)\n{\n\tif(count > minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tif((gool.y - sP.y) + (gool.x - sP.x) + count >= minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tsField[sP.y][sP.x] = count;\n\t/*cout << endl << endl;\n\tfor(int y=0;y<maxy;++y)\n\t{\n\t\tfor(int x=0;x<maxx;++x)\n\t\t{\n\t\t\tcout << sField[y][x] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tif(field[sP.y][sP.x] >= 0)\n\t\t--icePower[field[sP.y][sP.x]];\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(sP.x+dx[i],sP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == WALL)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] >= 0)\n\t\t\tif(icePower[field[p.y][p.x]] <= 0)//氷がパリーン！\n\t\t\t\tcontinue;\n\t\t\telse if ( sField[p.y][p.x] > count+1)\n\t\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\tif(sField[p.y][p.x] == -1 || sField[p.y][p.x] > count+1)//記録更新！\n\t\t{\n\t\t\tif(p.y == gool.y && p.x == gool.x)\n\t\t\t{\n\t\t\t\tsField[p.y][p.x] = count+1;\n\n\t\t\t\tif(minField[gool.y][gool.x] > sField[gool.y][gool.x] || minField[gool.y][gool.x] == -1)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<maxy;++y)\n\t\t\t\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t\t\t\t\tminField[y][x] = sField[y][x];\n\t\t\t\t}\n\t\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\t\tsField[p.y][p.x] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\t}\n\t\tif(minField[p.y][p.x] < count+1 && minField[p.y][p.x] != -1)\n\t\t{\n\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tsField[sP.y][sP.x] = -1;\n\treturn;\n}\n\nint main(void)\n{\n\tint field[MI_Y][MI_X];\n\n\twhile(cin >> maxx,cin >> maxy,maxx || maxy)//入力\n\t{\n\t\ticePow.clear();\n\t\tfor(int y=0;y<maxy;++y)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tchar input = getchar();\n\t\t\t\tif(input == '.')\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\telse if(input == '#')\n\t\t\t\t\tfield[y][x] = WALL;\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[y][x] = ICE;\n\t\t\t\telse if(input == 'S'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tstart.y = y;\n\t\t\t\t\tstart.x = x;\n\t\t\t\t}\n\t\t\t\telse if(input == 'G'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tgool.y = y;\n\t\t\t\t\tgool.x = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}//入力終わり\n\t\tfor(int y=0;y<maxy;++y)//ICEの値をアレに\n\t\t{\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tvector<Point> v;\n\t\t\t\tif(field[y][x] == ICE)\n\t\t\t\t{\n\t\t\t\t\tIceSet(field,Point(x,y),v);\n\t\t\t\t\ticePow.push_back(v.size()/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ここから深さ優先\n\t\tint serchField[MI_Y][MI_X];\n\t\tfor(int i=0;i<MI_Y;++i)//-1で初期化\n\t\t{\n\t\t\tfor(int j=0;j<MI_X;++j)\n\t\t\t{\n\t\t\t\tserchField[i][j] = -1;\n\t\t\t\tminField[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSerch(field,start,serchField,0,icePow);\n\t\tcout << minField[gool.y][gool.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\n#define WALL (-1)\n#define NONE (-2)\n\ntypedef pair<int,int> pii;\ntypedef pair<int,vector<int> > pivi;\n\nint w, h;\nchar datach[14][14];\nint dat[14][14];\nint dist[14][14];\nint start, goal;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvector<int> ices;\n\nstruct state{\n\tint step;\n\tint y;\n\tint x;\n\tvector<int> cnts;\n\n\tstate(int s, int y, int x, const vector<int> &c)\n\t\t: step(s), y(y), x(x), cnts(c) {}\n\n\tbool operator< (const state &s) const{\n\t\treturn step + dist[y][x] > s.step + dist[s.y][s.x];\n\t}\n};\n\nstruct statecomparer{\n\tbool operator() (const state &s1, const state &s2){\n\t\tif( s1.y != s2.y ) return s1.y < s2.y;\n\t\tif( s1.x != s2.x ) return s1.x < s2.x;\n\t\treturn s1.cnts < s2.cnts;\n\t}\n};\n\n\nvoid calcdist(){\n\tmemset(dist, -1, sizeof(dist));\n\t\n\tint y = goal / 100;\n\tint x = goal % 100;\n\tdist[y][x] = 0;\n\t\n\tint t = 1;\n\tqueue<pii> q;\n\tq.push( pii(y, x) );\n\tq.push( pii(-1, -1) );\n\twhile( q.size() > 1 ){\n\t\tif( q.front().first < 0 ){\n\t\t\t++t;\n\t\t\tq.push( q.front() );\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\ty = q.front().first + dy[i];\n\t\t\t\tx = q.front().second + dx[i];\n\t\t\t\t\n\t\t\t\tif( dist[y][x] < 0 && dat[y][x] != WALL ){\n\t\t\t\t\tdist[y][x] = t;\n\t\t\t\t\tq.push( pii(y, x) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n}\n\nint countsteps(){\n\tpriority_queue<state> pq;\n\tset<state,statecomparer> st;\n\n\tstate prev(0, start / 100, start % 100, ices);\n\tpq.push(prev);\n\tst.insert(prev);\n\n\twhile(true){\n\t\tprev = pq.top();\n\t\tpq.pop();\n\n\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint y = prev.y + dy[i];\n\t\t\tint x = prev.x + dx[i];\n\n\t\t\tif( dat[y][x] == WALL ) continue;\n\t\t\tif( y * 100 + x == goal ){\n\t\t\t\treturn prev.step + 1;\n\t\t\t}\n\n\t\t\tif( dat[y][x] < 0 ){\n\t\t\t\tstate next(prev.step + 1, y, x, prev.cnts);\n\t\t\t\tif( st.insert(next).second ){\n\t\t\t\t\tpq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint k = dat[y][x];\n\t\t\t\tif( (prev.cnts[k] - 1) * 2 >= ices[k] ){\n\t\t\t\t\tstate next(prev.step + 1, y, x, prev.cnts);\n\t\t\t\t\t--next.cnts[k];\n\t\t\t\t\t\n\t\t\t\t\tif( st.insert(next).second ){\n\t\t\t\t\t\tpq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( scanf(\"%d%d\", &w, &h), w != 0 ){\n\t\tices.clear();\n\n\t\tmemset(dat, -1, sizeof(dat));\n\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\" %s\", datach[i] + 1);\n\t\t}\n\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif( datach[i][j] == '.' ){\n\t\t\t\tdat[i][j] = NONE;\n\t\t\t}\n\t\t\telse if( datach[i][j] == 'S' ){\n\t\t\t\tstart = i * 100 + j;\n\t\t\t\tdat[i][j] = NONE;\n\t\t\t}\n\t\t\telse if( datach[i][j] == 'G' ){\n\t\t\t\tgoal = i * 100 + j;\n\t\t\t\tdat[i][j] = NONE;\n\t\t\t}\n\t\t\telse if( datach[i][j] == 'X' ){\n\t\t\t\tdat[i][j] = ices.size();\n\t\t\t\tdatach[i][j] = '_';\n\n\t\t\t\tint cnt = 1;\n\n\t\t\t\tqueue<pii> q;\n\t\t\t\tq.push( pii(i, j) );\n\t\t\t\twhile( !q.empty() ){\n\t\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\t\tint y = q.front().first + dy[k];\n\t\t\t\t\t\tint x = q.front().second + dx[k];\n\t\t\t\t\t\tif( datach[y][x] == 'X' ){\n\t\t\t\t\t\t\tdatach[y][x] = '_';\n\t\t\t\t\t\t\tdat[y][x] = ices.size();\n\t\t\t\t\t\t\tq.push( pii(y, x) );\n\t\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tq.pop();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tices.push_back(cnt);\n\t\t\t}\n\t\t}\n\n\t\tcalcdist();\n\t\tprintf(\"%d\\n\", countsteps());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nvector<int> cnt;\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d){\n  if(ans<=d + dis[y][x])return;\n  if(g[y][x] == 'G')ans = d;\n\n  vis[y][x] = true;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++;\n      if(cnt[curg]*2 <= num[curg])dfs(ny,nx,d+1);\n      cnt[curg]--;\n    }else{\n      dfs(ny,nx,d+1);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n\n    //rep(i,h){rep(j,w)cout << dis[i][j] << \" \";cout << endl;}\n\n    cnt = vector<int>(n,0);\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n \nusing namespace std;\n \n\nint W, H;\n \nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n \nint maxIce[128];\nint ice[128];\n \nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint ans; \nint px, py;\nint sx, sy, gx, gy;\n \nbool getMin(int ty, int tx, int turn)\n{\n     \n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n        return (false);\n    }\n     \n    if (ty == gy && tx == gx){\n        ans = turn;\n        return (true);\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return (false);\n        }\n    }\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        px = tx, py = ty;\n        if (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n    \n    return (false);\n}\n \nvoid label(int ty, int tx, int p)\n{\n    g[ty][tx] = p;\n    maxIce[p]++;\n     \n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n         \n        if (0 <= mx && mx < W && 0 <= my && my < H &&\n                    map[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n \nint main()\n{\n    int idx;\n     \n    while (1){\n        scanf(\"%d %d\", &W, &H);\n         \n        if (W + H == 0){\n            break;\n        }\n         \n        for (int i = 0; i < H; i++){\n            scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'S'){\n                    map[i][j] = '.';\n                    sx = j, sy = i;\n                }\n                if (map[i][j] == 'G'){\n                    map[i][j] = '.';\n                    gx = j, gy = i;\n                }\n            }\n        }\n         \n        memset(g, -1, sizeof(g));\n        memset(maxIce, 0, sizeof(maxIce));\n         \n        idx = 0;\n        for (int i = 0; i < H; i++){\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'X' && g[i][j] == -1){\n                    label(i, j, idx);\n                    maxIce[idx++] /= 2;\n                }\n            }\n        }\n         \n        memset(ice, 0, sizeof(ice));\n        memset(v, 0, sizeof(v));\n        px = py = -1;\n        v[sy][sx] = true;\n        \n        ans = 0;\n        while (!getMin(sy, sx, 0)){\n        \tmemset(ice, 0, sizeof(ice));\n\t        memset(v, 0, sizeof(v));\n\t        px = py = -1;\n\t        v[sy][sx] = true;\n        \tans++;\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nconst vector<int> dx = { 1, 0, -1, 0 };\nconst vector<int> dy = { 0, 1, 0, -1 };\nint H, W, sx, sy, gx, gy, comp_cnt; vector<int> comp_size; vector<vector<int> > dist, used; vector<vector<int> > comp; vector<string> s;\nvoid comp_dfs(int x, int y) {\n\tcomp[x][y] = comp_cnt;\n\t++comp_size[comp_cnt];\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] == 'X' && comp[tx][ty] == -1) {\n\t\t\tcomp_dfs(tx, ty);\n\t\t}\n\t}\n}\nbool reach(int x, int y, int rem) {\n\tif (x == gx && y == gy) return true;\n\tif (dist[x][y] > rem) return false;\n\tused[x][y] = rem;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && (s[tx][ty] != 'X' || comp_size[comp[tx][ty]] >= 2) && used[tx][ty] == -1) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < 4 && ok; ++j) {\n\t\t\t\tint rx = tx + dx[j], ry = ty + dy[j];\n\t\t\t\tif (0 <= rx && rx < H && 0 <= ry && ry < W && used[rx][ry] >= rem + 2) ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tif (s[tx][ty] == 'X') comp_size[comp[tx][ty]] -= 2;\n\t\t\t\tif (reach(tx, ty, rem - 1)) return true;\n\t\t\t\tif (s[tx][ty] == 'X') comp_size[comp[tx][ty]] += 2;\n\t\t\t}\n\t\t}\n\t}\n\tused[x][y] = -1;\n\treturn false;\n}\nint main() {\n\twhile (cin >> W >> H, H != 0) {\n\t\ts = vector<string>(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tcin >> s[i];\n\t\t\tif (s[i].find('S') != string::npos) sx = i, sy = s[i].find('S');\n\t\t\tif (s[i].find('G') != string::npos) gx = i, gy = s[i].find('G');\n\t\t}\n\t\tcomp = vector<vector<int> >(H, vector<int>(W, -1));\n\t\tcomp_size.clear();\n\t\tcomp_cnt = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (s[i][j] == 'X' && comp[i][j] == -1) {\n\t\t\t\t\tcomp_size.push_back(0);\n\t\t\t\t\tcomp_dfs(i, j);\n\t\t\t\t\t++comp_cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist = vector<vector<int> >(H, vector<int>(W, -1));\n\t\tdist[gx][gy] = 0;\n\t\tqueue<pair<int, int> > que; que.push(make_pair(gx, gy));\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, int> u = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint tx = u.first + dx[i], ty = u.second + dy[i];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && dist[tx][ty] == -1) {\n\t\t\t\t\tdist[tx][ty] = dist[u.first][u.second] + 1;\n\t\t\t\t\tque.push(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused = vector<vector<int> >(H, vector<int>(W, -1));\n\t\tint steps = 1;\n\t\twhile (!reach(sx, sy, steps)) ++steps;\n\t\tcout << steps << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}/*\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\tif(maps[i][j]>0){\n\t\t\t\t\tig[maps[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = v.size() + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {\n        result += v[i] * digit;\n        digit *= base;\n    }\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = max(12, *max_element(durability.begin(), durability.end()));\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h,sy,sx,gy,gx;\nchar g[20][20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {1,0,-1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n\n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X'){\n\tnum[n] = 0;\n\tgroup(i,j,n);\n\tnum[n]/=2;\n\tn++;\n      }\n      if(g[i][j] == 'S'){sy = i; sx = j; g[i][j] = '.';}\n      if(g[i][j] == 'G'){gy = i; gx = j;}\n    }\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  int prev;\n  Pox(vector<int> array=vector<int>(),int cost=inf,int prev=inf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nconst ull B =1000000007ULL;\nconst ull inv = 13499267949257065399ULL;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  printf(\"%d\\n\",pox.cost);\n\t  //cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,zx,zy,x,y,g,m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\n\nint ans(int x1,int y1,int d) {\n\tint k,x2,y2;\n\tzx=gx-x1; zy=gy-y1;\n\tif (zx<0) zx=-zx; if (zy<0) zy=-zy;\n\tif (d>=an || d+zx+zy>=an) return 0;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tfor (k=0;k<4;k++) {\n\t\tg=0;\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nconst int inf = (int) 1e9;\n\nint h, w, sy, sx, gy, gx;\nstring in[100];\nset<pair<vi, int> > s;\n\nint p[200], sz[200], size[200], dist[200][200];\nint root(int x){ return x == p[x] ? x : (p[x] = root(p[x])); }\n\nint main(){\n\t\n\twhile(cin >> w >> h, w){\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i, 200) p[i] = i, sz[i] = 1;\n\t\trep(i, 200) rep(j, 200) dist[i][j] = inf;\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint y = i + dy[d], x = j + dx[d];\n\t\t\t\tif(y < 0 || y >= h || x < 0 || x >= w) continue;\n\t\t\t\tif(in[y][x] != '#'){\n\t\t\t\t\tdist[i * w + j][y * w + x] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\trep(d, 4){\n\t\t\t\tint y = i + dy[d], x = j + dx[d];\n\t\t\t\tif(y < 0 || y >= h || x < 0 || x >= w) continue;\n\t\t\t\tif(in[y][x] == 'X'){\n\t\t\t\t\tint a = root(y * w + x), b = root(i * w + j);\n\t\t\t\t\tif(a != b) p[b] = a, sz[a] += sz[b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int, int> of;\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tof[root(i * w + j)] = 0;\n\t\t}\n\t\tint k = 0;\n\t\teach(i, of){\n\t\t\ti->second = k++;\n\t\t\tsize[i->second] = sz[i->first];\n\t\t}\n\t\t\n\t\tvi v(k);\n\t\ts.clear();\n\t\tpriority_queue<pair<pi, pair<vi, int> > > q;\n\t\t\n\t\tq.push(mp(mp(-dist[gy * w + gx][sy * w + sx], 0), mp(v, sy * w + sx)));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint y = q.top().second.second / w, x = q.top().second.second % w;\n\t\t\tint c = q.top().first.second;\n\t\t\tv = q.top().second.first;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(v, y * w + x))) continue;\n\t\t\ts.insert(mp(v, y * w + x));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w || in[ny][nx] == '#') continue;\n\t\t\t\tvi nv = v;\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tint t = of[root(ny * w + nx)];\n\t\t\t\t\tnv[t]++;\n\t\t\t\t\tif(2 * nv[t] > size[t]) continue;\n\t\t\t\t}\n\t\t\t\tq.push(mp(mp(-dist[gy * w + gx][ny * w + nx] + c, c - 1), mp(nv, ny * w + nx)));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint W,H;\nint ice[14][14];\nint num[10000];\nint gx,gy;\n\nint ans = 0;\nvoid dfs(int x,int y,int C,int px,int py){\n  if( c[y][x] == '#' || c[y][x] == '*') return;\n  if( C + abs(x-gx) + abs(y-gy) >= ans ) return;\n  if( c[y][x] == 'G'){ans = C; return; }\n\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n   if(ty < 0 || tx < 0 || ty >= H || tx >= W)continue;\n  \n   if( px == tx && ty == py ) continue;\n    if( c[ty][tx] == '*' ) return;\n  }\n  char cur = c[y][x];\n  c[y][x] = '*';\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n   if(ty < 0 || tx < 0 || ty >= H || tx >= W)continue;\n  \n   if( c[ty][tx] == 'X' ){\n      int b = ice[ty][tx];\n      if( num[b] > 0 ){\n\tnum[b]--;\n\tdfs(tx,ty,C+1,x,y);\n\tnum[b]++;\n      }\n    }else{\n      dfs(tx,ty,C+1,x,y);\n    }\n  }\n  c[y][x] = cur;\n  return;\n}\nvoid grouping(int x,int y,int k){\n  ice[y][x] = k;\n  num[k]++;\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = x + dx[i];\n    int ty = y + dy[i];\n    if(ty < 0 || tx < 0 || ty >= H || tx >= W)continue;\n    if( c[ty][tx] == 'X' && ice[ty][tx] < 0 )grouping(tx,ty,k);\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n\n  while(cin >> W >> H && W){\n    memset(ice,-1,sizeof(ice));\n    rep(i,14)rep(j,14) \n      c[i][j] = '#';\n    int sx , sy;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> c[i][j];\n\tif(c[i][j] == 'S'){\n\t  c[i][j] = '.';\n\t  sx = j , sy = i;\n\t}else if(c[i][j] == 'G' ){\n\t  gx = j , gy = i;\n\t}\n      }\n    }\n    int k = 0;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif( c[i][j] == 'X' && ice[i][j] < 0){\n\t  num[k] = 0;\n\t  grouping(j,i,k);\n\t  num[k] /= 2;\n\t  k++;\n\t}\n      }\n    }\n    ans = 1e7;\n    dfs(sx,sy,0,-1,-1);\n    cout << ans << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[12][12];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\tcin>>lx>>ly;\n\t\tif(lx==0&&ly==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(maps,0,sizeof(maps));\n\t\tmemset(ig,0,sizeof(ig));\n\t\tmin=144;\n\tfor(i=0;i<ly;i++){\n\t\tcin>>map[i];\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(map[i][j]=='S'){\n\t\t\t\tr.x=j;\n\t\t\t\tr.y=i;\n\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\tr.cnt=0;\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\tv.x=j;\n\t\t\t\tv.y=i;\n\t\t\t\tq.push(v);\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tv=q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tu=v;\n\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(maps[i][j]>0){\n\t\t\t\tig[maps[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!s.empty()){\n\t\tr=s.top();\n\t\ts.pop();\n\t\tif(r.visited[r.y][r.x]==1){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tr.visited[r.y][r.x]=1;\n\t\t}\n\t\tif(r.cnt>=min){\n\t\t\tcontinue;\n\t\t}\n\t\tif(map[r.y][r.x]=='G'&&r.cnt<min){\n\t\t\tmin=r.cnt;\n\t\t\tcontinue;\n\t\t}\n\t\tif(maps[r.y][r.x]>0){\n\t\t\ta=maps[r.y][r.x];\n\t\t\tr.ic[a]++;\n\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tt=r;\n\t\t\tt.x+=mx[i];\n\t\t\tt.y+=my[i];\n\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\tt.cnt++;\n\t\t\t\ts.push(t);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    if (step == depth) return false;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0 && !G[sy][sx]) {\n                (*ices[sy][sx])--;\n                G[sy][sx] = true;\n                if (iddfs(sx, sy, step+1)) return true;\n                G[sy][sx] = false;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int empty = 100000;\n        int wall = 0;\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ices[y][x] = &empty;\n                break;\n            case '#':\n                ices[y][x] = &wall;\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((int *)G, 12*12, false);\n        depth = abs(start_x - goal_x) + abs(start_y - goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth++;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int ans = inf;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int ans = inf;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\nvector<int> rn[24];\n\nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n\tif( c[y][x] == '#' || c[y][x] == '*') return 0;\n\tif( C >= ans ) return 0;\n\tif( c[y][x] == 'G'){\n\t\tans = C;\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( px == tx && ty == py ) continue;\n\t\tif( c[ty][tx] == '*' ) return 0;\n\t}\n\tchar cur = c[y][x];\n\tc[y][x] = '*';\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[rn[(x*7+y*13+C*17)%24][i]];\n\t\tint ty = y + dy[rn[(x*7+y*13+C*17)%24][i]]\t;\n\t\tif( c[ty][tx] == 'X' ){\n\t\t\tint b = belong[ty][tx];\n\t\t\tif( ok[b] > 0 ){\n\t\t\t\tok[b]--;\n\t\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t\t\tok[b]++;\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t}\n\t}\n\tc[y][x] = cur;\n\treturn 0;\n}\nint grouping(int x,int y,int k){\n\tif( c[y][x] != 'X') return 0;\n\tif( belong[y][x] != -1 ) return 0;\n\tbelong[y][x] = k;\n\tccc++;\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tgrouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint W,H;\n\tint rng[] = {0,1,2,3} , ww = 0;\n\trep(i,24) rn[i].resize(4);\n\tdo{\n\t\tfor(int i = 0 ; i < 4 ; i++)\n\t\t\trn[ww][i] = rng[i];\n\t\tww++;\n\t}while(next_permutation(rng,rng+4));\n\tsrand(time(NULL));\n\twhile(cin >> W >> H && W){\n\t\trandom_shuffle(rn,rn+24);\n\t\trep(i,14)rep(j,14) belong[i][j] = -1;\n\t\trep(i,14)rep(j,14) \n\t\t\tc[i][j] = '#';\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif(c[i+1][j+1] == 'S'){\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t\tsx = j+1 , sy = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t\t\t\t\tccc = 0;\n\t\t\t\t\tgrouping(j,i,k);\n\t\t\t\t\tok[k] = ccc / 2;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e7;\n\t\tdfs(sx,sy,0,-1,-1);\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,z,u,m[13][13],a[36],c[13][13],b[13][13],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d>=an || d>=b[y1][x1]) return 0;\n\tif (x1==gx && y1==gy) { if (d<an) an=d; return 1;}\n\tif (u==0 && b[y1][x1]>d) b[y1][x1]=d;\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0; j<4; j++) if (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) z+=c[y2+dy[j]][x2+dx[j]];\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { u=1;a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) { c[i][j]=0; b[i][j]=999;}\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1; u=0;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nuc ice_cnt[MAX*MAX];\n//set<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)\n    {\n      ice[j+i*w] = inf;\n      ice_cnt[j+i*w] = cinf;\n    }\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  uc cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      \n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      \n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  //if(mincost.find(next) == mincost.end())\n\t  //{\n\t  //mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t      //}\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      //mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++))\n\t{\n\t  //mincost.clear();\n\t}\n      while(!Q.empty())Q.pop_back();\n      //mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  uc cost;\n  uc prev;\n  Pox(vector<uc> array=vector<uc>(),uc cost=cinf,uc prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << (short)pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\nint memo;           // 枝刈り３\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    memo = min(memo, abs(y - gy) + abs(x - gx));            // 枝刈り３\n    if(step == 0) return NIL;\n    if(abs(y - gy) + abs(x - gx) > step) return NIL;        // 枝刈り１\n    int result = NIL;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        memo = 1000000000;              // 枝刈り３\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n        i += memo - 1;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,ck[13][13],m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\nvoid mkck(int x1,int y1,int u) {\n\tint k;\n\tck[y1][x1]=u;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='.' && ck[y1+dy[k]][x1+dx[k]]==142) mkck(x1+dx[k],y1+dy[k],u+1);\n\t\t}\n   }\n\nint ans(int x1,int y1,int d) {\n\tint k,x2,y2;\n\tif (ck[y1][x1]<d) return 0;\n\tif (d>=an) return 1;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) { f[i][j]=0;ck[i][j]=142;}\n\tmkck(sx,sy,0);\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<int> v;\n  S(int py,int px,vector<int> pv):y(py),x(px),v(pv){\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<int>(nid));\n    set<vector<int> > mem[12][12];\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(!mem[e.y][e.x].insert(e.v).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1 << 15\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1},\n\tdy[] = {-1,0,1,0};\n\nint X,Y;\nint d[12][12],dd[12][12];\nint IceNum, Ice[144];\nP S,G;\n\nqueue<P> que;\n\nbool check(int NX, int NY)\n{\n\tif(NX >= X || NY >= Y || NX < 0 || NY < 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs(P pos, int now)\n{\n\tif(pos == G){\n\t\tdd[pos.second][pos.first] = min(dd[pos.second][pos.first], now);\n\t\treturn;\n\t}\n\tif(now > dd[pos.second][pos.first])\n\t\treturn;\n\n\tdd[pos.second][pos.first] = now;\n\n\tint nx,ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\tif(check(nx,ny) && d[ny][nx] != -1){\n\t\t\tif(d[ny][nx] > 0){\n\t\t\t\tif(Ice[ d[ny][nx] ] > 0){\n\t\t\t\t\tIce[ d[ny][nx] ]--;\n\t\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t\t\t\tIce[ d[ny][nx] ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t}\n\t}\n\n\n\t\t\n}\nint main(void)\n{\n\twhile(cin >> X >> Y, X){\n\t\tfill(&dd[0][0],&dd[0][0]+144, INF);\n\t\tfill(&Ice[0],&Ice[0]+144, 0);\n\t\tIceNum = 0;\n\t\tchar s[13];\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor(int j = 0; s[j] != '\\0'; j++){\n\t\t\t\tif(s[j] == '.')\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\telse if(s[j] == '#')\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\telse if(s[j] == 'X')\n\t\t\t\t\td[i][j] = -2;\n\t\t\t\telse if(s[j] == 'S')\n\t\t\t\t\tS = P(j,i);\n\t\t\t\telse if(s[j] == 'G')\n\t\t\t\t\tG = P(j,i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(d[i][j] == -2){\n\t\t\t\t\tIceNum++;\n\t\t\t\t\t\n\t\t\t\t\tque.push(P(j,i));\n\n\t\t\t\t\twhile(que.size()){\n\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\td[p.second][p.first] = IceNum;\n\t\t\t\t\t\tIce[IceNum]++;\n\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\t\t\t\tif(check(nx,ny) && d[ny][nx] == -2){\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++)\n\t\t\t\tprintf(\"%2d\", d[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < 144; i++)\n\t\t\tIce[i] /= 2;\n\n\t\tdfs(S,0);\n\t\tprintf(\"%d\\n\", dd[G.second][G.first]);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W, H;\nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\nint maxIce[128];\nint ice[128];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint ans;\nint px, py;\nint sx, sy, gx, gy;\n\nbool getMin(int ty, int tx, int turn){\n    if (turn + abs(ty - gy) + abs(tx - gx) >= ans){return (false);}\n    if (ty == gy && tx == gx){\n        ans = turn; return (true);\n    }\n    for (int i = 0; i < 4; i++){int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n            return (false);\n        }\n    }\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i]; px = tx, py = ty;\n        if (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n            if (g[my][mx] == -1){\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n            }\n            else if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n                ice[g[my][mx]]++;\n                v[my][mx] = true;\n                if (getMin(my, mx, turn + 1)) return (true);\n                v[my][mx] = false;\n                ice[g[my][mx]]--;\n            }\n        }\n    }\n    return (false);\n}\n\nvoid label(int ty, int tx, int p){\n    g[ty][tx] = p;\n    maxIce[p]++;\n    for (int i = 0; i < 4; i++){\n        int mx = tx + dx[i], my = ty + dy[i];\n        if (0 <= mx && mx < W && 0 <= my && my < H &&map[my][mx] == 'X' && g[my][mx] == -1){\n            label(my, mx, p);\n        }\n    }\n}\n\nint main(){\n    int idx;\n    while (1){scanf(\"%d %d\", &W, &H);\n        if (W + H == 0){break;}\n        for (int i = 0; i < H; i++){ scanf(\"%s\", map[i]);\n            for (int j = 0; j < W; j++){\n                if (map[i][j] == 'S'){map[i][j] = '.';sx = j, sy = i;}\n                if (map[i][j] == 'G'){map[i][j] = '.';gx = j, gy = i;}\n            }\n        }\n        memset(g, -1, sizeof(g)); memset(maxIce, 0, sizeof(maxIce));\n        idx = 0;\n        for (int i = 0; i < H; i++){ for (int j = 0; j < W; j++){\n                if (map[i][j] == 'X' && g[i][j] == -1){label(i, j, idx);maxIce[idx++] /= 2;}}\n        }\n        memset(ice, 0, sizeof(ice)); memset(v, 0, sizeof(v));\n        px = py = -1; v[sy][sx] = true; ans = 0;\n        while (!getMin(sy, sx, 0)){\n            memset(ice, 0, sizeof(ice));\n            memset(v, 0, sizeof(v));\n            px = py = -1;\n            v[sy][sx] = true;\n            ans++;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef pair<int,int> pii;\nint H,W;\nint sy,sx,gy,gx;\nchar field[101][101];\nint ice;\nint iceNumber[101][101];\n// iceごとのタイル数\nint tileNum[101];\nbool used[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nint predic[101][101];\n\n// 状態に必要なもの\n// ここまでのコスト\n// どのiceを何度踏んだか(vectorでもつ)\ntypedef pair<pii,vector<int> > Info;\ntypedef pair<int,pair<pii,vector<int> > > Sit;\n\n// 氷を踏む回数を無視したときのgoalからの最短距離\nvoid bfs(){\n  queue<pii> q;\n  memset(predic,-1,sizeof(predic));\n  q.push(pii(gy,gx));\n  predic[gy][gx]=0;\n  while(q.size()){\n    pii p=q.front();q.pop();\n    int cy=p.first;\n    int cx=p.second;\n    int ccost=predic[cy][cx];\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&predic[ny][nx]==-1\n\t &&field[ny][nx]!='#'){\n\tint ncost=ccost+1;\n\tpredic[ny][nx]=ncost;\n\tq.push(pii(ny,nx));\n      }\n    }\n  }\n}\n\nint astar(){\n  priority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n  map<Info,int> d;\n  vector<int> sv(ice,0);\n  d[(make_pair(pii(sy,sx),sv))]=predic[sy][sx];\n  pq.push(Sit(predic[sy][sx],make_pair(pii(sy,sx),sv)));\n  int res=10000000;\n  while(pq.size()){\n    Sit p=pq.top();pq.pop();\n    int cy=p.second.first.first;\n    int cx=p.second.first.second;\n    int ccost=p.first;\n    vector<int> ctile=p.second.second;\n    if(d.count(p.second)>0&&ccost>d[p.second])continue;\n    int realCost=ccost-predic[cy][cx];\n    if(cy==gy&&cx==gx)return realCost;\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n\tvector<int> ntile=ctile;\n\tint ncost=(realCost+1)+predic[ny][nx];\n\tInfo ninfo=p.second;\n\tninfo.first.first=ny;\n\tninfo.first.second=nx;\n\tif(field[ny][nx]=='X'){\n\t  int a=iceNumber[ny][nx];\n\t  ninfo.second[a]++;\n\t  if(ninfo.second[a]>tileNum[a]/2)continue;\n\t}\n\tif(d.count(ninfo)==0||d[ninfo]>ncost){\n\t  d[ninfo]=ncost;\n\t  pq.push(make_pair(ncost,ninfo));\n\t  if(gy==ny&&gx==nx)res=min(res,ncost);\n\t}\n      }\n    }\n  }\n  return res;\n}\n\nint labelling(int cy,int cx,int k){\n  int cnt=1;\n  used[cy][cx]=true;\n  iceNumber[cy][cx]=k;\n  for(int i=0;i<4;i++){\n    int ny=cy+dy[i];\n    int nx=cx+dx[i];\n    if(ny>=0&&nx>=0&&ny<H&&nx<W&&!used[ny][nx]&&field[ny][nx]=='X')\n      cnt+=labelling(ny,nx,k);\n  }\n  return cnt;\n}\n\nint main(){\n  while(cin>>W>>H&&(H|W)){\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>field[i][j];\n\tif(field[i][j]=='S'){\n\t  sy=i;sx=j;\n\t  field[i][j]='.';\n\t}\n\telse if(field[i][j]=='G'){\n\t  gy=i;gx=j;\n\t  field[i][j]='.';\n\t}\n      }\n    }\n    ice=0;\n    memset(used,0,sizeof(used));\n    memset(iceNumber,-1,sizeof(iceNumber));\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tif(!used[i][j]&&field[i][j]=='X'){\n\t  tileNum[ice]=labelling(i,j,ice);\n\t  ice++;\n\t}\n    bfs();\n    int res=astar();\n    cout<<res<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nconst int inf = (int) 1e9;\n\nint h, w, sy, sx, gy, gx;\nstring in[100];\nset<pair<vi, int> > s;\n\nint p[200], sz[200], size[200], dist[200][200];\nint root(int x){ return x == p[x] ? x : (p[x] = root(p[x])); }\n\nint main(){\n\t\n\twhile(cin >> w >> h, w){\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i, 200) p[i] = i, sz[i] = 1;\n\t\trep(i, 200) rep(j, 200) dist[i][j] = inf;\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint y = i + dy[d], x = j + dx[d];\n\t\t\t\tif(y < 0 || y >= h || x < 0 || x >= w) continue;\n\t\t\t\tif(in[y][x] != '#'){\n\t\t\t\t\tdist[i * w + j][y * w + x] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\trep(d, 4){\n\t\t\t\tint y = i + dy[d], x = j + dx[d];\n\t\t\t\tif(y < 0 || y >= h || x < 0 || x >= w) continue;\n\t\t\t\tif(in[y][x] == 'X'){\n\t\t\t\t\tint a = root(y * w + x), b = root(i * w + j);\n\t\t\t\t\tif(a != b) p[b] = a, sz[a] += sz[b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int, int> of;\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tof[root(i * w + j)] = 0;\n\t\t}\n\t\tint k = 0;\n\t\teach(i, of){\n\t\t\ti->second = k++;\n\t\t\tsize[i->second] = sz[i->first];\n\t\t}\n\t\t\n\t\tvi v(k);\n\t\ts.clear();\n\t\tpriority_queue<pair<pi, pair<vi, int> > > q;\n\t\t\n\t\tq.push(mp(mp(-dist[gy * w + gx][sy * w + sx], 0), mp(v, sy * w + sx)));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint y = q.top().second.second / w, x = q.top().second.second % w;\n\t\t\tint c = q.top().first.second;\n\t\t\tv = q.top().second.first;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(v, y * w + x))) continue;\n\t\t\ts.insert(mp(v, y * w + x));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w || in[ny][nx] == '#') continue;\n\t\t\t\tvi nv = v;\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tint t = of[root(ny * w + nx)];\n\t\t\t\t\tnv[t]++;\n\t\t\t\t\tif(2 * nv[t] > size[t]) continue;\n\t\t\t\t}\n\t\t\t\tq.push(mp(mp(-dist[gy * w + gx][ny * w + nx] + c, c - 1), mp(nv, ny * w + nx)));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    int count = 0;\n    for(const auto& d: NEXT) if(visited[y + d[Y]][x + d[X]]) ++count;\n    if(count >= 2) return INF;\n    int result = INF;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = min(result, dfs(ny, nx, step + 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = min(result, dfs(ny, nx, step + 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n\n        cout << dfs(sy, sx, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<int> v;\n  S(int py,int px,vector<int> pv):y(py),x(px),v(pv){\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<int>(nid));\n    map<vector<int>,map<int,map<int,bool> > > mem;\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(mem[e.v][e.y][e.x]++)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\n\nint W,H;\nint data[12][12];\nint h[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n};\n\ntypedef pair<int,State>PP;\ntypedef pair<int,P>P2;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n/*\nvoid bfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n*/\n\nbool dfs(PP pp,int lim){\n\n   int cnt = pp.first;\n\n\n   State state = pp.second;\n   P p = state.p;\n\n   if(max(cnt,cnt + h[p.first][p.second]-3)  > lim)return false;\n   \n   if(p == g){\n      cout << cnt << endl;\n      return true;\n   }\n   \n   for(int i = 0 ; i < 4 ; i++){\n      P np = P(p.first + dy[i],p.second + dx[i]);\n      if(!check(np))continue;\n      \n      int here = data[np.first][np.second];\n      if(here == wall)continue;\n      if(state.vis[np.first][np.second] < cnt)continue;\n\n      state.p = np;\n\n      int tmp =  state.vis[np.first][np.second];\n      \n      if(here >= 0){\n\n         if(state.v[here] <= mv[here]/2)continue;\n         if(mv[here] == 1)continue;\n         \n         state.v[here]--;\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.v[here]++;\n         state.vis[np.first][np.second] = tmp;\n      }\n      else{\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.vis[np.first][np.second] = tmp;\n      }\n      state.p = p;\n   }\n   return false;\n}\n\n\n\nvoid bfs(){\n   \n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         h[i][j] = INF;\n      }\n   }\n\n   queue<P2>que;\n   que.push(P2(0,g));\n\n   h[g.first][g.second] = 0;\n\n   while(que.size()){\n      P2 p2 = que.front(); que.pop();\n      int cnt = p2.first;\n      P p = p2.second;\n\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] == wall)continue;\n         if(h[np.first][np.second] != INF)continue;\n         h[np.first][np.second] = cnt+1;\n         que.push(P2(cnt+1,np));\n      }\n   }\n}\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n   //bfs();\n   \n   //State state;\n   //state.set(mv,s);\n\n   bfs();\n   \n\n   cout << H << ' ' << W << endl;\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(h[i][j] == INF)cout << '#';\n         else cout << h[i][j];\n      }\n      cout << endl;\n   }\n\n\n   for(int i = 1 ; ; i++){\n      State state;\n      state.set(mv,s);\n      if(dfs(PP(0,state),i))break;\n   }\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      //cout << \"W = \" << W << \" H = \" << H << endl;//\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint W, H;\n\nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n\nint maxIce[128];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint sx, sy, gx, gy;\nint px, py;\n\nvoid getMin(int ty, int tx, int *ice, int turn)\n{\n\t\n\tif (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n\t\treturn;\n\t}\n\t\n\tif (ty == gy && tx == gx){\n\t\tans = turn;\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H && px != mx && py != my && v[my][mx]){\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\tpx = tx, py = ty;\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n\t\t\tif (g[my][mx] == -1){\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t}\n\t\t\telse if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n\t\t\t\tice[g[my][mx]]++;\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t\tice[g[my][mx]]--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid label(int ty, int tx, int p)\n{\n\tg[ty][tx] = p;\n\tmaxIce[p]++;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H &&\n\t\t\t\t\tmap[my][mx] == 'X' && g[my][mx] == -1){\n\t\t\tlabel(my, mx, p);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint idx;\n\t\n\twhile (scanf(\"%d %d\", &W, &H) == 2){\n\t\tgetchar();\n\t\t\n\t\tif (W + H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", &map[i]);\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'S'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tsx = j, sy = i;\n\t\t\t\t}\n\t\t\t\tif (map[i][j] == 'G'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tgx = j, gy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(g, -1, sizeof(g));\n\t\tmemset(maxIce, 0, sizeof(maxIce));\n\t\t\n\t\tidx = 0;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'X' && g[i][j] == -1){\n\t\t\t\t\tlabel(i, j, idx);\n\t\t\t\t\tmaxIce[idx++] /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint use[128];\n\t\t\n\t\tmemset(use, 0, sizeof(use));\n\t\tmemset(v, 0, sizeof(v));\n\t\tpx = py = -1;\n\t\tv[sy][sx] = true;\n\t\tans = W * H;\n\t\tgetMin(sy, sx, use, 0);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nuc ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)\n    {\n      ice[j+i*w] = inf;\n      ice_cnt[j+i*w] = cinf;\n    }\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  uc cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      \n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      \n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++))\n\t{\n\t  mincost.clear();\n\t}\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      \n      if( cnt % 1204 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      if(cnt > 10 && !Q.empty() && cnt%60 == 0)Q.pop();\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\nint W,H;\nint data[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n\n};\n\ntypedef pair<int,State>PP;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n\nvoid bfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   //data[s.first][s.second] = mark;\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      //      cout << \"x = \" << p.second << \" y = \" << p.first << endl;//\n      //cout << \"cnt = \" << cnt << endl;//\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            //cout << \"state.v[here] = \"<< state.v[here] << endl;//\n            //cout << \"mv[here]/2 = \" << mv[here]/2 << endl;//\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   /*\n   display();\n   for(int i = 0 ; i < mv.size() ; i++){\n      cout << \"i = \" << i << \" mv[i] = \" << mv[i] << endl;//\n   }\n   */\n\n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n\n   bfs();\n   \n   //State state;\n   //state.set(mv,s);\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = v.size() + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {\n        result += v[i] * digit;\n        digit *= base;\n    }\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = max(20, *max_element(durability.begin(), durability.end()));\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <string>\n#include <array>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nint ORD, N;\nULL h(const vector<int> &v, int y, int x) {\n    ULL res = 0;\n    for(int i : v) {\n        res *= ORD;\n        res += i;\n    }\n    res *= 12;\n    res += y;\n    res *= 12;\n    res += x;\n    return res;\n}\n\nvoid d(ULL val, vector<int> &v, int &y, int &x) {\n    v.resize(N, 0);\n    x = val % 12;\n    val /= 12;\n    y = val % 12;\n    val /= 12;\n    for(int i = v.size()-1; i >= 0; --i) {\n        v[i] = val % ORD;\n        val /= ORD;\n    }\n}\n\nconst int DY[] = {0, -1, 0, 1};\nconst int DX[] = {1, 0, -1, 0};\n\ninline bool in_range(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nint X, Y;\nint bfs(vector<string> &v, int y, int x, array<array<int,12>,12> &field, int label) {\n    int cnt = 0;\n    queue<pair<int,int>> q;\n    q.push(make_pair(y, x));\n    while(!q.empty()) {\n        int cy = q.front().first;\n        int cx = q.front().second;\n        q.pop();\n        v[cy][cx] = '$';\n        field[cy][cx] = label;\n        ++cnt;\n        for(int i = 0; i < 4; ++i) {\n            const int ny = cy + DY[i];\n            const int nx = cx + DX[i];\n            if(in_range(0, ny, Y) && in_range(0, nx, X) && v[ny][nx] == 'X') {\n                q.push(make_pair(ny, nx));\n            }\n        }\n    }\n    return cnt;\n}\n\nbool solve() {\n    cin >> X >> Y;\n    if(!X && !Y) return false;\n\n    vector<string> v(Y);\n    for(string &s : v) {\n        cin >> s;\n    }\n\n    array<array<int,12>,12> field;\n    pair<int,int> start, goal;\n    vector<int> ice;\n    ice.push_back(0);\n    for(int y = 0; y < Y; ++y) {\n        for(int x = 0; x < X; ++x) {\n            if(v[y][x] == 'X') {\n                int cnt = bfs(v, y, x, field, -(int)ice.size());\n                if(cnt == 1) {\n                    field[y][x] = 0;\n                } else {\n                    ice.push_back(cnt/2);\n                }\n            } else if(v[y][x] == '#') {\n                field[y][x] = 0;\n            } else if(v[y][x] != '$') {\n                field[y][x] = 1;\n                if(v[y][x] == 'S') {\n                    start = make_pair(y, x);\n                } else if(v[y][x] == 'G') {\n                    goal = make_pair(y, x);\n                }\n            }\n        }\n    }\n\n    N = ice.size();\n    ORD = *max_element(ice.begin(), ice.end())+1;\n    vector<int> state(N, 0);\n    vector<ULL> q[2];\n    unordered_set<ULL> memo;\n    q[0].push_back(h(state, start.first, start.second));\n    memo.insert(q[0].back());\n    int turn = 0;\n    while(q[0].size() > 0) {\n        q[1].clear();\n        for(const auto &s : q[0]) {\n            int x, y;\n            d(s, state, y, x);\n            //cout << turn << \": \" << x << ' ' << y << ' ' << \"s \" << state[1] << endl;\n            if(y == goal.first && x == goal.second) {\n                goto end;\n            }\n            for(int i = 0; i < 4; ++i) {\n                const int ny = y + DY[i];\n                const int nx = x + DX[i];\n                if(in_range(0, ny, Y) && in_range(0, nx, X)) {\n                    if(field[ny][nx] < 0) {\n                        const int idx = -field[ny][nx];\n                        if(state[idx] >= ice[idx]) continue;\n                        state[idx]++;\n                        const ULL nh = h(state, ny, nx);\n                        if(memo.count(nh) == 0) {\n                            memo.insert(nh);\n                            q[1].push_back(nh);\n                        }\n                        state[idx]--;\n                    } else if(field[ny][nx] == 1) {\n                        const ULL nh = h(state, ny, nx);\n                        if(memo.count(nh) == 0) {\n                            memo.insert(nh);\n                            q[1].push_back(nh);\n                        }\n                    }\n                }\n            }\n        }\n        ++turn;\n        q[0].swap(q[1]);\n    }\nend:\n    cout << turn << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(ans<=d + dis[y][x])return;\n  //if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(vis[ny][nx])return;\n  }\n\n  vis[y][x] = true;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  vis[y][x] = false;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n++]/=2;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    memset(vis,0,sizeof(vis));\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n    bool operator<(const State& right) const{\n        return d == right.d ? ice > right.ice : d > right.d;\n    }\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        int sy, sx, gy, gx;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        priority_queue<State> que;\n        que.push((State){0,sy,sx,vec(lump_ice_num, 0)});\n        set<string> visited;\n        while(que.size()){\n            State p = que.top(); que.pop();\n            string state_str = state2str(p);\n            if(visited.count(state_str)) continue;\n            visited.insert(state_str);\n            //cout << state_str << endl;\n            if(p.y==gy&&p.x==gx){\n                cout << p.d << endl;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                vec nice = p.ice;\n                if(ny<0||H<=ny||nx<0||W<=nx)continue;\n                if(ifield[ny][nx]==-2)continue;\n                if(ifield[ny][nx]>=0){\n                    int ice_i = ifield[ny][nx];\n                    if(ice_num[ice_i]/2 < nice[ice_i]+1) continue;\n                    nice[ice_i]++;\n                }\n                State np = (State){p.d+1,ny,nx,nice};\n                string nstr = state2str(np);\n                if(visited.count(nstr)==0){\n                    que.push(np);\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nconst ull B =1000000007ULL;\nconst ull inv = 13499267949257065399ULL;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] > max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] > depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nbitset<1000000> visited[12][12];\nvector<int> icesq;\n\nstruct data {\n\tint x, y;\n\tint t, v;\n\tdata(int x_, int y_, int t_, int v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tq.push(data(S.se, S.fi, 0, 0));\n\t\tvector<int> radix;\n\t\tradix.resize(icesq.size() + 1);\n\t\tradix[0] = 1;\n\t\tfor(int i = 1; i < radix.size(); i++) {\n\t\t\tradix[i] = radix[i-1] * (icesq[i-1] + 1);\n\t\t}\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\tfor(int j = 0; j < 12; j++) {\n\t\t\t\tvisited[i][j].reset();\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(!visited[ny-1][nx-1][cur.v]) {\n\t\t\t\t\t\tvisited[ny-1][nx-1][cur.v] = true;\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X') {\n\t\t\t\t\tint flgcnts;\n\t\t\t\t\tflgcnts = (cur.v % radix[ice[ny][nx]+1]) / radix[ice[ny][nx]];\n\t\t\t\t\tif(flgcnts < icesq[ice[ny][nx]]) {\n\t\t\t\t\t\tint tmp = cur.v + radix[ice[ny][nx]];\n\t\t\t\t\t\tif(!visited[ny-1][nx-1][tmp]) {\n\t\t\t\t\t\t\tvisited[ny-1][nx-1][tmp] = true;\n\t\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nbitset<1000000> visited[12][12];\nvector<int> icesq;\n\nstruct data {\n\tint x, y;\n\tint t, v;\n\tdata(int x_, int y_, int t_, int v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tq.push(data(S.se, S.fi, 0, 0));\n\t\tvector<int> radix;\n\t\tradix.resize(icesq.size() + 1);\n\t\tradix[0] = 1;\n\t\tfor(int i = 1; i < radix.size(); i++) {\n\t\t\tradix[i] = radix[i-1] * (icesq[i-1] + 1);\n\t\t}\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\tfor(int j = 0; j < 12; j++) {\n\t\t\t\tvisited[i][j].reset();\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(!visited[ny-1][nx-1][cur.v]) {\n\t\t\t\t\t\tvisited[ny-1][nx-1][cur.v] = true;\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X') {\n\t\t\t\t\tint flgcnts;\n\t\t\t\t\tflgcnts = (cur.v % radix[ice[ny][nx]+1]) / radix[ice[ny][nx]];\n\t\t\t\t\tif(flgcnts < icesq[ice[ny][nx]]) {\n\t\t\t\t\t\tint tmp = cur.v + radix[ice[ny][nx]];\n\t\t\t\t\t\tif(!visited[ny-1][nx-1][tmp]) {\n\t\t\t\t\t\t\tvisited[ny-1][nx-1][tmp] = true;\n\t\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring g[20];\nvector<int> cnt;\nint num[200],n;\nint ice[20][20];\nint sy,sx;\nbool vis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x){\n  if(g[y][x] == 'G')return 0;\n  if(memo.find(cnt)!=memo.end())return memo[cnt];\n  vis[y][x] = true;\n\n  int res = 200;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx) + 1);\n      cnt[curg]--; cnt[n] = y; cnt[n+1] = x;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx) + 1);\n      cnt[n] = y; cnt[n+1] = x;\n    }\n  }\n  vis[y][x] = false;\n\n  memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n    }\n    /*\n    rep(i,h){rep(j,w)cout << ice[i][j] << \" \";cout << endl;}\n    rep(i,n)cout << num[i] << \" \";cout << endl;\n    */\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    cout << dfs(sy,sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\n#include <bitset>\n#include <set>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nvector<long long> icesq;\n\nstruct data {\n\tint x, y;\n\tint t;\n\tlong long v;\n\tdata(int x_, int y_, int t_, long long v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tq.push(data(S.se, S.fi, 0, 0));\n\t\tvector<long long> radix;\n\t\tradix.resize(icesq.size() + 1);\n\t\tradix[0] = 1;\n\t\tfor(int i = 1; i < radix.size(); i++) {\n\t\t\tradix[i] = radix[i-1] * (icesq[i-1] + 1);\n\t\t}\n\t\tset<long long> visited[12][12];\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\tfor(int j = 0; j < 12; j++) {\n\t\t\t\tvisited[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvisited[S.fi-1][S.se-1].insert(0LL);\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(visited[ny-1][nx-1].find(cur.v) == visited[ny-1][nx-1].end()) {\n\t\t\t\t\t\tvisited[ny-1][nx-1].insert(cur.v);\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X') {\n\t\t\t\t\tlong long flgcnts;\n\t\t\t\t\tflgcnts = (cur.v % radix[ice[ny][nx]+1]) / radix[ice[ny][nx]];\n\t\t\t\t\tif(flgcnts < icesq[ice[ny][nx]]) {\n\t\t\t\t\t\tlong long tmp = cur.v + radix[ice[ny][nx]];\n\t\t\t\t\t\tif(visited[ny-1][nx-1].find(tmp) == visited[ny-1][nx-1].end()) {\n\t\t\t\t\t\t\tvisited[ny-1][nx-1].insert(tmp);\n\t\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstring ba;\nint iceid[12][12];\nint num[144];\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\nint dist[12][12][144];\nint vec[144];\n\nint gy, gx;\nstruct P {\n  string s;\n  int y,x,d;\n  P(const string &s, int y, int x, int d) :\n    s(s),y(y),x(x),d(d) {}\n};\nbool operator<(const P &a, const P &b) {\n  int ad = a.d + abs(a.y-gy) + abs(a.x-gx);\n  int bd = b.d + abs(b.y-gy) + abs(b.x-gx);\n  return ad != bd ? ad > bd : a.s != b.s ? a.s < b.s : a.y != b.y ? a.y < b.y : a.x != b.x ?\n    a.x < b.x : a.d < b.d;\n}\nclass Cmp {\npublic:\n  bool operator()(const P &a, const P &b) const {\n    return a.s != b.s ? a.s < b.s : a.y != b.y ? a.y < b.y : a.x < b.x;\n  }\n};\n\n\nint main() {\n  int w,h;\n  while(cin>>w>>h,w||h) {\n    ba = \"\";\n    int sy,sx;\n    REP(i,h) {\n      string s; cin >> s;\n      ba += s;\n      REP(j,w) {\n        if (ba[i*w+j] == 'S') {\n          sy=i;sx=j;\n          ba[i*w+j] = '.';\n        } else if (ba[i*w+j] == 'G') {\n          gy = i;\n          gx = j;\n        }\n      }\n    }\n    memset(num,0,sizeof(num));\n    memset(iceid,0,sizeof(iceid));\n    int ice = 1;\n    REP(i,h) {\n      REP(j,w) {\n        if (ba[i*w+j] != 'X') continue;\n        if (iceid[i][j] == 0) {\n          iceid[i][j] = ice;\n          queue<pii> Q;\n          Q.push(pii(i,j));\n          while(!Q.empty()) {\n            pii p = Q.front(); Q.pop();\n            num[ice]++;\n            int y = p.first;\n            int x = p.second;\n            REP(k,4) {\n              int yy=y+dy[k];\n              int xx=x+dx[k];\n              if (yy<0||yy>=h||xx<0||xx>=w) continue;\n\n              if (ba[yy*w+xx] == 'X' && iceid[yy][xx] == 0) {\n                iceid[yy][xx] = ice;\n                Q.push(pii(yy,xx));\n              }\n            }\n          }\n          ice++;\n        }\n      }\n    }\n    priority_queue<P> Q;\n    map<P, int, Cmp> dist;\n    Q.push(P(ba,sy,sx,0));\n    dist[P(ba,sy,sx,0)] = 0;\n    int ans = -1;\n    while(!Q.empty()) {\n      P p = Q.top(); Q.pop();\n      if (p.d > dist[p]) continue;\n      \n      int id = iceid[p.y][p.x];\n      if (p.y == gy && p.x == gx) {\n        ans = p.d;\n        break;\n      }\n      REP(i,ice) vec[i] = 0;\n      REP(i,h)REP(j,w) if (p.s[i*w+j]=='*') vec[iceid[i][j]]++;\n\n      // if (p.y == 8 && p.x == 1 && p.d == 11) {\n      //   cout << p.y << \" \" << p.x << \"  \" << p.d << endl;\n      //   REP(i,ice) cout << vec[i] << \" \"; cout << endl;\n      //   REP(i,h) cout << p.s.substr(i*w,w) << endl;\n      // }\n\n      \n      REP(k,4) {\n        int yy=p.y+dy[k];\n        int xx=p.x+dx[k];\n        if (yy<0||yy>=h||xx<0||xx>=w) continue;\n        if (p.s[yy*w+xx] == '#') continue;\n        int id2 = iceid[yy][xx];\n        if (p.s[yy*w+xx] == 'X') {\n          if (2*(vec[id2]+1) <= num[id2]) {\n            p.s[yy*w+xx] = '*';\n            P next(p.s,yy,xx,p.d+1);\n            if (dist.count(next) == 0 || dist[next] > p.d+1) {\n              dist[next] = p.d+1;\n              Q.push(next);\n            }\n            p.s[yy*w+xx] = 'X';\n          }\n        } else {\n          // char c = p.s[yy*w+xx];\n          // if (p.s[yy*w+xx] != '*') p.s[yy*w+xx] = '-';\n\n          P next(p.s,yy,xx,p.d+1);\n          if (dist.count(next) == 0 || dist[next] > p.d+1) {\n\n            dist[next] = p.d+1;\n            Q.push(next);\n          }\n          // p.s[yy*w+xx] = c;\n        }\n      }\n    }\n    assert(ans != -1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvector<short> c;\n\t\t\tState(int i,int j,int d,const vector<short>& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\tqueue<State> q;\n\t\tq.emplace(s.first,s.second,0,vector<short>(f.size()));\n\t\tmap<pair<pii,vector<short>>,int> memo;\n\t\twhile(!q.empty()){\n\t\t\tState cur=q.front(); q.pop();\n\t\t\titer(memo) it=memo.find(mp(mp(cur.i,cur.j),cur.c)); \n\t\t\tif(it!=memo.end() && it->second<=cur.d) continue;\n\t\t\tmemo[mp(mp(cur.i,cur.j),cur.c)]=cur.d;\n\t\t\tif(mp(cur.i,cur.j)==g) break;\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tcur.c[p]++;\n\t\t\t\t\tif(2*cur.c[p]<=cnt[p])\n\t\t\t\t\t\tq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t\t\tcur.c[p]--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t}\n\t\t}\n\t\tint res=INFTY;\n\t\tfor(auto kv:memo)\n\t\t\tif(kv.first.first==g)\n\t\t\t\tres=min(res,kv.second);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = v.size() + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {\n        result += v[i] * digit;\n        digit *= base;\n    }\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = max(20, *max_element(durability.begin(), durability.end())) + 1;\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n \nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n \nint belong[14][14];\nint ok[10000];\nint gx,gy;\n \nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n    if( c[y][x] == '#' || c[y][x] == '*') return 0;\n    if( C + abs(x-gx) + abs(y-gy) >= ans ) return 0;\n    if( c[y][x] == 'G'){\n        ans = C;\n        return 0;\n    }\n    for(int i = 0 ; i < 4 ; i++){\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if( px == tx && ty == py ) continue;\n        if( c[ty][tx] == '*' ) return 0;\n    }\n    char cur = c[y][x];\n    c[y][x] = '*';\n    for(int i = 0 ; i < 4 ; i++){\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if( c[ty][tx] == 'X' ){\n            int b = belong[ty][tx];\n            if( ok[b] > 0 ){\n                ok[b]--;\n                dfs(tx,ty,C+1,x,y);\n                ok[b]++;\n            }\n        }else{\n            dfs(tx,ty,C+1,x,y);\n        }\n    }\n    c[y][x] = cur;\n    return 0;\n}\nint grouping(int x,int y,int k){\n    if( c[y][x] != 'X') return 0;\n    if( belong[y][x] != -1 ) return 0;\n    belong[y][x] = k;\n    ccc++;\n    for(int i = 0 ; i < 4 ; i++)\n        grouping(x+dx[i],y+dy[i],k);\n}\n \nint main(){\n    ios_base::sync_with_stdio(false);\n    int W,H;\n    while(cin >> W >> H && W){\n        rep(i,14)rep(j,14) belong[i][j] = -1;\n        rep(i,14)rep(j,14) \n            c[i][j] = '#';\n        int sx , sy;\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                cin >> c[i+1][j+1];\n                if(c[i+1][j+1] == 'S'){\n                    c[i+1][j+1] = '.';\n                    sx = j+1 , sy = i+1;\n                }else if(c[i+1][j+1] == 'G' ){\n                    gx = j+1 , gy = i+1;\n                }\n            }\n        }\n        int k = 0;\n        for(int i = 1 ; i <= H ; i++){\n            for(int j = 1 ; j <= W ; j++){\n                if( c[i][j] == 'X' && belong[i][j] == -1){\n                    ccc = 0;\n                    grouping(j,i,k);\n                    ok[k] = ccc / 2;\n                    k++;\n                }\n            }\n        }\n        ans = 1e7;\n        dfs(sx,sy,0,-1,-1);\n        cout << ans << endl;\n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <cctype>\n#include <set>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1000000007;\nconst double EPS = 1e-10;\n\nchar field[15][15];\nbool visit[15][15];\nint cnt[100];\nint sz[100];\nint id[15][15];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvoid dfs(int r, int c, int k){\n  id[r][c] = k;\n  sz[k]++;\n  rep(i, 4){\n    int r2 = r + dy[i];\n    int c2 = c + dx[i];\n    if(id[r2][c2] == -1 && field[r2][c2] == 'X'){\n      dfs(r2, c2, k);\n    }\n  }\n}\n\nbool iddfs(int r, int c, int gr, int gc, int dep, int limit){\n  if(dep + abs(gr - r) + abs(gc - c) > limit) return false;\n  //  cout << r << \" \" << c << endl;\n  if(r == gr && c == gc) return true;\n  visit[r][c] = true;\n  \n  rep(i, 4){\n\n    int r2 = r + dy[i];\n    int c2 = c + dx[i];\n    \n    if(field[r2][c2] == '#' || visit[r2][c2]) continue;\n    if(field[r2][c2] == '.'){\n      if(iddfs(r2, c2, gr, gc, dep + 1, limit)) return true;\n    }\n    if(field[r2][c2] == 'X'){\n      //      cout << cnt[id[r2][c2]] << \" \" << sz[id[r2][c2]] << \"**\" << endl;\n      if(cnt[id[r2][c2]] + 1 > sz[id[r2][c2]] / 2) continue;\n      cnt[id[r2][c2]]++;\n      if(iddfs(r2, c2, gr, gc, dep + 1, limit)) return true;\n      cnt[id[r2][c2]]--;\n    }\n  }\n  visit[r][c] = false;\n  return false;\n}\n\n\n\nint main(){\n  int x, y ,sr, sc, gr, gc, c;\n  while(cin >> x >> y){\n    c = 0;\n    if(x == 0 && y == 0) continue;;\n    fill(&field[0][0], &field[0][0] + 15 * 15, '#');\n    \n    memset(sz, 0, sizeof(sz));\n    memset(cnt, 0, sizeof(cnt));\n    memset(id, -1, sizeof(id));\n    memset(visit, false, sizeof(visit));\n    \n    rep(i, y)rep(j, x){\n      cin >> field[i+1][j+1];\n      if(field[i+1][j+1] == 'S') sr = i + 1, sc = j + 1;\n      if(field[i+1][j+1] == 'G') gr = i + 1, gc = j + 1, field[i+1][j+1] = '.';\n    }\n    \n    rep(i, y)rep(j, x){\n      if(id[i+1][j+1] == -1 && field[i+1][j+1] == 'X'){\n\tdfs(i + 1, j + 1, c++);\n      }\n      //      cout << setw(3) << id[i+1][j+1];\n      //      if(j == x - 1) cout << endl;\n    }\n    \n    int len = 1;\n    while(!iddfs(sr,sc,gr,gc,0,len)){\n      len++;\n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(fromG[ni][nj], make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          ++N;\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost >= depth+1)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring g[20];\nvector<int> cnt;\nint num[200],n;\nint ice[20][20];\nint sy,sx;\nbool vis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x, int d){\n  if(ans<=d)return INF;\n  if(g[y][x] == 'G'){ans = min(ans,d); return 0;}\n  if(memo.find(cnt)!=memo.end()){ans = min(ans,d + memo[cnt]); return memo[cnt];}\n  \n  vis[y][x] = true;\n\n  int res = 200;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[curg]--; cnt[n] = y; cnt[n+1] = x;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[n] = y; cnt[n+1] = x;\n    }\n  }\n  vis[y][x] = false;\n\n  if(res<INF && memo.size()<=1000000)memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n    }\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    ans = 200;\n    dfs(sy,sx,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <climits>\n#include <math.h>\nusing namespace std;\n\nconst int ROOM = -1;\nconst int WALL = -2;\nconst int ICE = -3;\n\nconst int MI_X = 13;\nconst int MI_Y= 13;\n\nconst int ANGLE_KIND = 4;//4方向\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint maxx,maxy;//フィールドの大きさ\n\nvector<int>icePow;//氷の耐久力を保存（各フィールドの値はこの要素の値\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int _x,int _y):x(_x),y(_y){}\n\tPoint():x(0),y(0){}\n};\n\n\nPoint start;\nPoint gool;\n\nint minField[MI_Y][MI_X];\n\n//iceP iceの位置を保存する\nvoid IceSet(int field[MI_Y][MI_X],Point fP,vector<Point>& iceP)//わたすのは現在のice\n{\n\ticeP.push_back(fP);\n\tfield[fP.y][fP.x] = icePow.size();\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(fP.x+dx[i],fP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == ICE)\n\t\t\tIceSet(field,p,iceP);\n\t}\n\treturn;\n}\n\nvoid Serch(const int field[MI_Y][MI_X],Point sP,int sField[MI_Y][MI_X],int count,vector<int> icePower)\n{\n\tif(count > minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tif(abs(gool.y - sP.y) + abs(gool.x - sP.x) + count >= minField[gool.y][gool.x] && minField[gool.y][gool.x] != -1)\n\t\treturn;\n\tsField[sP.y][sP.x] = count;\n\t/*cout << endl << endl;\n\tfor(int y=0;y<maxy;++y)\n\t{\n\t\tfor(int x=0;x<maxx;++x)\n\t\t{\n\t\t\tcout << sField[y][x] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tif(field[sP.y][sP.x] >= 0)\n\t\t--icePower[field[sP.y][sP.x]];\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(sP.x+dx[i],sP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == WALL)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] >= 0)\n\t\t\tif(icePower[field[p.y][p.x]] <= 0)//氷がパリーン！\n\t\t\t\tcontinue;\n\t\t\telse if ( sField[p.y][p.x] > count+1)\n\t\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\tif(sField[p.y][p.x] == -1 || sField[p.y][p.x] > count+1)//記録更新！\n\t\t{\n\t\t\tif(p.y == gool.y && p.x == gool.x)\n\t\t\t{\n\t\t\t\tsField[p.y][p.x] = count+1;\n\n\t\t\t\tif(minField[gool.y][gool.x] > sField[gool.y][gool.x] || minField[gool.y][gool.x] == -1)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<maxy;++y)\n\t\t\t\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t\t\t\t\tminField[y][x] = sField[y][x];\n\t\t\t\t}\n\t\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\t\tsField[p.y][p.x] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\t}\n\t\tif(minField[p.y][p.x] < count+1 && minField[p.y][p.x] != -1)\n\t\t{\n\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tsField[sP.y][sP.x] = -1;\n\treturn;\n}\n\nint main(void)\n{\n\tint field[MI_Y][MI_X];\n\n\twhile(cin >> maxx,cin >> maxy,maxx || maxy)//入力\n\t{\n\t\ticePow.clear();\n\t\tfor(int y=0;y<maxy;++y)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tchar input = getchar();\n\t\t\t\tif(input == '.')\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\telse if(input == '#')\n\t\t\t\t\tfield[y][x] = WALL;\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[y][x] = ICE;\n\t\t\t\telse if(input == 'S'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tstart.y = y;\n\t\t\t\t\tstart.x = x;\n\t\t\t\t}\n\t\t\t\telse if(input == 'G'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tgool.y = y;\n\t\t\t\t\tgool.x = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}//入力終わり\n\t\tfor(int y=0;y<maxy;++y)//ICEの値をアレに\n\t\t{\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tvector<Point> v;\n\t\t\t\tif(field[y][x] == ICE)\n\t\t\t\t{\n\t\t\t\t\tIceSet(field,Point(x,y),v);\n\t\t\t\t\ticePow.push_back(v.size()/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ここから深さ優先\n\t\tint serchField[MI_Y][MI_X];\n\t\tfor(int i=0;i<MI_Y;++i)//-1で初期化\n\t\t{\n\t\t\tfor(int j=0;j<MI_X;++j)\n\t\t\t{\n\t\t\t\tserchField[i][j] = -1;\n\t\t\t\tminField[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSerch(field,start,serchField,0,icePow);\n\t\tcout << minField[gool.y][gool.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nclass adres{\npublic:\n\tint x,y;\n\n\tbool samei(int i,int j){\n\t\treturn (i == x && j == y);\n\t}\n\tbool samed(adres b){\n\t\treturn (b.x == x && b.y == y);\n\t}\n\tvoid print(){\n\t\tprintf(\"座標(%d,%d)\\n\",x,y);\n\t}\n};\n\nvoid iceren(int,int,int);\nvoid syokika();\nvoid debag();\nvoid input();\nvoid icegroup();\nvoid hukasa(adres,int);\n\n//変数宣言\nadres S,G;\nint i,j,r,x,y;\nint map[14][14];\nint shortmap[14][14];\nint tx[4] = {1,-1,0,0},ty[4] = {0,0,-1,1};\nchar in[13];\nchar kind[4] = {\".#X\"};\nint ikind[3] = {-1,-2,-3};\nint icebreak[12*12];\n\nint main()\n{\n\tscanf(\"%d%d\",&x,&y);\n\n\twhile(x != 0 && y != 0){\n\t\t//初期化\n\t\tsyokika();\n\n\t\t//マップの入力と数値化\n\t\t//-1:侵入可能 -2:侵入不可 -3:氷\n\t\tinput();\n\n\t\t//氷のグループ化と耐久度設定\n\t\ticegroup();\n\n\t\t//深さ優先探索\n\t\thukasa(S,0);\n\n\t\tprintf(\"%d\\n\",shortmap[G.x][G.y]);\n\n\t\t//デバッグ用出力\n\t\t//debag();\n\n\t\tscanf(\"%d%d\",&x,&y);\n\t}\n\n\treturn 0;\n}\n\n//深さ優先探索関数\n//nx:現在地のx座標  ny:現在地のy座標  c:氷の管理番号\nvoid iceren(int nx,int ny,int c)\n{\n\tint i,j;\n\n\ticebreak[c]++;\n\t\n\t//現在地は探索済みなので\n\t//マップを管理番号に変えて重複して探索しないようにする\n\tmap[nx][ny] = c;\n\n\t//4方向を調べる\n\tfor(i = 0; i < 4; i++){\n\t\t//もし氷なら移動\n\t\tif(map[nx + tx[i]][ny + ty[i]] == -3){\n\t\t\ticeren(nx + tx[i],ny + ty[i],c);\n\t\t}\n\t}\n\n\treturn;\n}\nvoid syokika()\n{\n\tint i;\n\t\n\t//マップ\n\tfor(i = 0; i <= x+1; i++){\n\t\tmap[i][0] = -2;\n\t\tmap[i][y+1] = -2;\n\t}\n\tfor(i = 0; i <= y+1; i++){\n\t\tmap[0][i] = -2;\n\t\tmap[x+1][i] = -2;\n\t}\n\tfor(i = 0; i <= y+1; i++){\n\t\tfor(j = 0; j <= x+1; j++){\n\t\t\tshortmap[j][i] = y*x+1;\n\t\t}\n\t}\n\t//氷の耐久度\n\tfor(i = 0; i < y*x; i++){\n\t\ticebreak[i] = 0;\n\t}\n}\nvoid debag()\n{\n\t//マップ\n\tfor(i = 0; i <= y+1; i++){\n\t\tfor(j = 0; j <= x+1; j++){\n\t\t\tprintf(\"%3d\",map[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t//氷耐久度\n\tfor(i = 0; i < 12; i++){\n\t\tprintf(\"氷[%d]:%d\\n\",i,icebreak[i]);\n\t}\n\n\t/*各種関数\n\tnow.kazuyuki[0] = 0;\n\t\tnow.kazuyuki[1] = 0;\n\t\tnow.tkayuki[0] = 0;\n\t\tnow.tkayuki[1] = 1;\n\t\tnex = now;\n\t\tlaston.push(now);\n\t\tfor(i = 0; i < 10; i++){\n\t\t\tnex.kazuyuki[0]++;\n\t\t\tlaston.push(nex);\n\t\t}\n\t\tnow.print();\n\t\tprintf(\"%d\\n\",cheklast(now));\n\t*/\n}\nvoid input()\n{\n\tfor(i = 1; i <= y; i++){\n\t\tscanf(\"%s\",in);\n\t\tfor(j = 1; j <= x; j++){\n\t\t\tif(in[j-1] == 'S'){\n\t\t\t\tS.x = j;\n\t\t\t\tS.y = i;\n\t\t\t\tmap[j][i] = -1;\n\t\t\t}\n\t\t\telse if(in[j-1] == 'G'){\n\t\t\t\tG.x = j;\n\t\t\t\tG.y = i;\n\t\t\t\tmap[j][i] = -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(r = 0; r < 4; r++){\n\t\t\t\t\tif(kind[r] == in[j-1]){\n\t\t\t\t\t\tmap[j][i] = ikind[r];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid icegroup()\n{\n\tint c = 0;\n\tfor(i = 1; i <= y; i++){\n\t\tfor(j = 1; j <= x; j++){\n\t\t\tif(map[j][i] == -3){\n\t\t\t\ticeren(j,i,c);\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < c; i++){\n\t\ticebreak[i] /= 2;\n\t}\n}\nvoid hukasa(adres now,int count)\n{\n\tadres nex;\n\tint i;\n\n\t//printf(\"%d手目 \",count);\n\t//now.print();\n\t//最少コスト表の更新\n\tshortmap[now.x][now.y] = count;\n\t\n\t//現在地が氷なら,耐久度を1つ下げる\n\tif(map[now.x][now.y] >= 0){\n\t\ticebreak[map[now.x][now.y]]--;\n\t}\n\t\n\tcount++;\n\t\n\t//4方向探索\n\tfor(i = 0; i < 4; i++){\n\t\tnex.x = now.x+tx[i];\n\t\tnex.y = now.y+ty[i];\n\t\t//nex.print();\n\t\tif(map[nex.x][nex.y] == -1 && shortmap[nex.x][nex.y] > count){\n\t\t\thukasa(nex,count);\n\t\t}\n\t\tif(map[nex.x][nex.y] >= 0 && icebreak[ map[nex.x][nex.y] ] > 0 && shortmap[nex.x][nex.y] > count){\n\t\t\thukasa(nex,count);\n\t\t}\n\t}\n\n\t//もどるので氷の値も戻す\n\tif(map[now.x][now.y] >= 0){\n\t\ticebreak[map[now.x][now.y]]++;\n\t}\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n//　薄氷2011-y-10\t//サンプルデータのみｋ\n\n#include <stdio.h>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1 << 15\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1},\n\tdy[] = {-1,0,1,0};\n\nint X,Y;\nint d[12][12],dd[12][12];\nint IceNum, Ice[144];\nP S,G;\n\nqueue<P> que;\n\nbool check(int NX, int NY)\n{\n\tif(NX >= X || NY >= Y || NX < 0 || NY < 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs(P pos, int now)\n{\n\tif(pos == G){\n\t\tdd[pos.second][pos.first] = min(dd[pos.second][pos.first], now);\n\t\treturn;\n\t}\n\tif(now > dd[pos.second][pos.first] && d[pos.second][pos.first] <= 0)\n\t\treturn;\n\n\tdd[pos.second][pos.first] = now;\n\n\tint nx,ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\tif(check(nx,ny) && d[ny][nx] != -1){\n\t\t\tif(d[ny][nx] > 0){\n\t\t\t\tif(Ice[ d[ny][nx] ] > 0){\n\t\t\t\t\tIce[ d[ny][nx] ]--;\n\t\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t\t\t\tIce[ d[ny][nx] ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t}\n\t}\n\n\n\t\t\n}\nint main(void)\n{\n\twhile(cin >> X >> Y, X > 0 && Y > 0){\n\t\tfill(&dd[0][0],&dd[0][0]+144, INF);\n\t\tfill(&Ice[0],&Ice[0]+144, 0);\n\t\tIceNum = 0;\n\t\tchar s[13];\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor(int j = 0; s[j] != '\\0'; j++){\n\t\t\t\tif(s[j] == '.')\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\telse if(s[j] == '#')\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\telse if(s[j] == 'X')\n\t\t\t\t\td[i][j] = -2;\n\t\t\t\telse if(s[j] == 'S')\n\t\t\t\t\tS = P(j,i),d[i][j] = 0;\n\t\t\t\telse if(s[j] == 'G')\n\t\t\t\t\tG = P(j,i),d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(d[i][j] == -2){\n\t\t\t\t\tIceNum++;\n\t\t\t\t\t\n\t\t\t\t\tque.push(P(j,i));\n\n\t\t\t\t\twhile(que.size()){\n\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\td[p.second][p.first] = IceNum;\n\t\t\t\t\t\tIce[IceNum]++;\n\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\t\t\t\tif(check(nx,ny) && d[ny][nx] == -2){\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++)\n\t\t\t\tprintf(\"%2d\", d[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < 144; i++)\n\t\t\tIce[i] /= 2;\n\n\t\tdfs(S,0);\n\t\tprintf(\"%d\\n\", dd[G.second][G.first]);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\ttypedef vector<unsigned char> vuc;\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvuc c;\n\t\t\tState(int i,int j,int d,const vuc& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\tqueue<State> q;\n\t\tq.emplace(s.first,s.second,0,vuc(f.size()));\n\t\tmap<pair<pii,vuc>,int> memo;\n\t\twhile(!q.empty()){\n\t\t\tState cur=q.front(); q.pop();\n\t\t\titer(memo) it=memo.find(mp(mp(cur.i,cur.j),cur.c)); \n\t\t\tif(it!=memo.end() && it->second<=cur.d) continue;\n\t\t\tmemo[mp(mp(cur.i,cur.j),cur.c)]=cur.d;\n\t\t\tif(mp(cur.i,cur.j)==g) break;\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tcur.c[p]++;\n\t\t\t\t\tif(2*cur.c[p]<=cnt[p])\n\t\t\t\t\t\tq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t\t\tcur.c[p]--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t}\n\t\t}\n\t\tint res=INFTY;\n\t\tfor(auto kv:memo)\n\t\t\tif(kv.first.first==g)\n\t\t\t\tres=min(res,kv.second);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nint h, w;\nchar field[16][16];\nint label[16][16];\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nint labeling(int y, int x, int l)\n{\n    int ret = 1;\n    label[y][x] = l;\n    \n    rep(i, 4){\n        int py = y + dy[i];\n        int px = x + dx[i];\n        if(py<0 || h<=py || px<0 || w<=px) continue;\n        if(field[py][px] == 'X' && label[py][px] == 0){\n            ret += labeling(py, px, l);\n        }\n    }\n    \n    return ret;\n}\n\nstruct Data\n{\n    int y, x, cost;\n    vi broken;\n    \n    bool operator== (const Data& d) const\n    {\n        return y == d.y && x == d.x && broken == d.broken;\n    }\n};\n\nstruct myhash\n{\n    size_t operator()(const Data& d) const\n    {\n        size_t h = d.y ^ d.x;\n        rep(i, d.broken.size()) h ^= d.broken[i] << i;\n        return h;\n    }\n};\n\nint func()\n{\n    rep(i, h) rep(j, w) label[i][j] = 0;\n    \n    rep(i, h){\n        cin >> field[i];\n    }\n    \n    vi area;\n    rep(y, h) rep(x, w){\n        if(field[y][x] == 'X' && label[y][x] == 0){\n            area.push_back(labeling(y, x, area.size() + 1));\n        }\n    }\n    \n    for(int& a : area){\n        a /= 2;\n    }\n    \n    queue<Data> Q;\n    unordered_set<Data, myhash> visited;\n    \n    rep(y, h) rep(x, w){\n        if(field[y][x] == 'S'){\n            Q.push({y, x, 0, area});\n            visited.insert(Q.front());\n        }\n    }\n    \n    while(!Q.empty()){\n        Data d = Q.front();\n        Q.pop();\n        \n        rep(i, 4){\n            int py = d.y + dy[i];\n            int px = d.x + dx[i];\n            if(py<0 || h<=py || px<0 || w<=px || field[py][px] == '#') continue;\n            \n            Data next;\n            if(field[py][px] == 'G'){\n                return d.cost + 1;\n            }\n            else if(field[py][px] == 'X'){\n                int& b = d.broken[label[py][px]-1];\n                if(b == 0) continue;\n                --b;\n                next = {py, px, d.cost + 1, d.broken};\n                ++b;\n            }\n            else{\n                next = {py, px, d.cost + 1, d.broken};\n            }\n            \n            if(visited.count(next)) continue;\n            \n            Q.push(next);\n            visited.insert(next);\n        }\n    }\n    \n    return 0;\n}\n    \nint main()\n{\n    while(cin >> w >> h, w){\n        printf(\"%d\\n\", func());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define INF 100000000\nchar c[12][12];\nint X,Y;\n\nbool check(int sx,int sy){\n  queue<int> vx, vy;\n  vx.push(sx); vy.push(sy);\n\n  char copy[X][Y];\n  for(int i=0;i<X;i++)\n    for(int j=0;j<Y;j++)\n      copy[i][j] = c[i][j];\n  copy[sx][sy] = '#';\n\n  int count_ice = 0;\n  int count_break = 1;\n  while(!vx.empty()&&!vy.empty()){\n    int x = vx.front(); vx.pop();\n    int y = vy.front(); vy.pop();\n    for(int i=-1;i<=1;i++){\n      if((0<=x+i&&x+i<X)&&(copy[x+i][y]=='X'||copy[x+i][y]=='!')){\n        if(copy[x+i][y]=='X') count_ice++;\n        if(copy[x+i][y]=='!') count_break++;\n        copy[x+i][y] = '#';\n        vx.push(x+i); vy.push(y);\n      }\n      if((0<=y+i&&y+i<Y)&&(copy[x][y+i]=='X'||copy[x][y+i]=='!')){\n        if(copy[x][y+i]=='X') count_ice++;\n        if(copy[x][y+i]=='!') count_break++;\n        copy[x][y+i] = '#';\n        vx.push(x); vy.push(y+i);\n      }\n    }\n  }\n  return count_ice >= count_break;\n}\n\nint search(int x,int y,int count){\n  //cout << x << \" \" << y << endl;\n  if(c[x][y]=='G') return count;\n  char save = c[x][y];\n  int ans = INF;\n  if(c[x][y]=='X'){\n    c[x][y] = '!';\n    bool ok = check(x,y);\n    if(!ok){\n      c[x][y] = save;\n      return INF;\n    }\n  }\n  else c[x][y] = '#';\n\n  for(int i=-1;i<=1;i++){\n    if((0<=x+i&&x+i<X)&&c[x+i][y]!='#'&&c[x+i][y]!='!')\n      ans = min(ans,search(x+i,y,count+1));\n    if((0<=y+i&&y+i<Y)&&c[x][y+i]!='#'&&c[x][y+i]!='!')\n      ans = min(ans,search(x,y+i,count+1));\n  }\n  c[x][y] = save;\n  return ans;\n}\n\nint main(){\n  while(cin >> X >> Y){\n    if(X==0&&Y==0) break;\n    int x,y;\n\n    for(int j=0;j<Y;j++){\n      for(int i=0;i<X;i++){\n        cin >> c[i][j];\n        if(c[i][j]=='S'){\n          x = i;\n          y = j;\n        }\n      }\n    }\n    cout << search(x,y,0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nvector<int> icesq;\n\nstruct data {\n\tint x, y;\n\tint t;\n\tvector<int> v;\n\tdata(int x_, int y_, int t_, vector<int> v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nstruct visited_tr {\n\tbool flg;\n\tvector<visited_tr> child;\n\tvisited_tr(vector<int> v) {\n\t\tif(v.empty()) {\n\t\t\tflg = false;\n\t\t\treturn;\n\t\t}\n\t\tchild.resize(v[0] + 1);\n\t\tfor(int i = 0; i < child.size(); i++) {\n\t\t\tchild[i] = visited_tr(vector<int>(v.begin()+1, v.end()));\n\t\t}\n\t}\n\tvisited_tr() {};\n\t\n\tbool check(vector<int> v) {\n\t\tif(v.empty())\n\t\t\treturn flg;\n\t\treturn child[v[0]].check(vector<int>(v.begin()+1,v.end()));\n\t}\n\tbool swtrue(vector<int> v) {\n\t\tif(v.empty())\n\t\t\treturn flg = true;\n\t\treturn child[v[0]].swtrue(vector<int>(v.begin()+1,v.end()));\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tvector<int> tmpv;\n\t\ttmpv.resize(icesq.size());\n\t\tfor(int i = 0; i < tmpv.size(); i++)\n\t\t\ttmpv[i] = 0;\n\t\tq.push(data(S.se, S.fi, 0, tmpv));\n\t\tvisited_tr visited[12][12];\n\t\tfor(int i = 0; i < 12; i++)\n\t\t\tfor(int j = 0; j < 12; j++)\n\t\t\t\tvisited[i][j] = visited_tr(icesq);\n\t\tvisited[S.fi-1][S.se-1].swtrue(tmpv);\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n//\t\t\tfor(int i = 0; i < cur.v.size(); i++)\n//\t\t\t\tcout << cur.v[i] << \" \";\n//\t\t\tcout << endl;\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(!visited[ny-1][nx-1].check(cur.v)) {\n\t\t\t\t\t\tvisited[ny-1][nx-1].swtrue(cur.v);\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X' && cur.v[ice[ny][nx]] < icesq[ice[ny][nx]]) {\n\t\t\t\t\tvector<int> tmp = cur.v;\n\t\t\t\t\ttmp[ice[ny][nx]]++;\n\t\t\t\t\tif(!visited[ny-1][nx-1].check(tmp)) {\n\t\t\t\t\t\tvisited[ny-1][nx-1].swtrue(tmp);\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint W, H;\n\nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n\nint maxIce[128];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint sx, sy, gx, gy;\nint px, py;\n\nvoid getMin(int ty, int tx, int *ice, int turn)\n{\n\t\n\tif (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n\t\treturn;\n\t}\n\t\n\tif (ty == gy && tx == gx){\n\t\tans = turn;\n\t\treturn;\n\t}\n\t\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n\t\t\tif (g[my][mx] == -1){\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tpx = tx, py = ty;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t}\n\t\t\telse if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n\t\t\t\tice[g[my][mx]]++;\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t\tpx = tx, py = ty;\n\t\t\t\tice[g[my][mx]]--;\n\t\t\t}\n\t\t}\n\t\tif (mx != px && my != py && v[my][mx]){\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid label(int ty, int tx, int p)\n{\n\tg[ty][tx] = p;\n\tmaxIce[p]++;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H &&\n\t\t\t\t\tmap[my][mx] == 'X' && g[my][mx] == -1){\n\t\t\tlabel(my, mx, p);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint idx;\n\t\n\twhile (scanf(\"%d %d\", &W, &H) == 2){\n\t\tgetchar();\n\t\t\n\t\tif (W + H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", &map[i]);\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'S'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tsx = j, sy = i;\n\t\t\t\t}\n\t\t\t\tif (map[i][j] == 'G'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tgx = j, gy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(g, -1, sizeof(g));\n\t\tmemset(maxIce, 0, sizeof(maxIce));\n\t\t\n\t\tidx = 0;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'X' && g[i][j] == -1){\n\t\t\t\t\tlabel(i, j, idx);\n\t\t\t\t\tmaxIce[idx++] /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint use[128];\n\t\t\n\t\tmemset(use, 0, sizeof(use));\n\t\tmemset(v, 0, sizeof(v));\n\t\tv[sy][sx] = true;\n\t\tans = W * H;\n\t\tgetMin(sy, sx, use, 0);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\n\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nconst int NIL = -1;\nconst int INF = 1000000000;\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\nvector<vector<int>> visited;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint dfs(int y, int x, int step) {\n    if(y == gy && x == gx) return step;\n    if(step == 0) return NIL;\n    if(abs(y - gy) + abs(x - gx) > step) return NIL;        // 枝刈り１\n    int count = 0;                                                              // 枝刈り４\n    for(const auto& d: NEXT) if(visited[y + d[Y]][x + d[X]]) ++count;           //\n    if(count >= 2) return NIL;                                                  //\n    int result = NIL;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] == WALL) continue;\n        if(field[ny][nx] == FLOOR) {\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            result = max(result, dfs(ny, nx, step - 1));\n            visited[ny][nx] = 0;\n        } else {\n            if(durability[field[ny][nx]] <= 0) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = 1;\n            --durability[field[ny][nx]];\n            result = max(result, dfs(ny, nx, step - 1));\n            ++durability[field[ny][nx]];\n            visited[ny][nx] = 0;\n        }\n    }\n    return result;\n}\n\nint solve() {\n    visited = vector<vector<int>>(h + 2, vector<int>(w + 2, 0));\n    for(int i = 1; i <= INF; ++i) {\n        int result = dfs(sy, sx, i);\n        if(result != NIL) return i - result;\n    }\n    return NIL;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define INF 1 << 15\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy,ex,ey;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tint mapc[13][13];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tmemset(mapc,-1,sizeof(mapc));\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\t\tmapc[i][j]=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\t\n\t\t\t\tif(mapc[t.y][t.x]>r.cnt+1||mapc[t.y][t.x]==-1){\n\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(mapc[t.y][t.x]<=r.cnt){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tex=t.x;\n\t\t\t\t\tey=t.y;\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<mapc[ey][ex]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX_W = 12;\nconst int INF = 1e+8;\n\nint w, h;\nvector<string> s;\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// ice[y][x] := 氷の番号を返す. (連結な氷をひとつのまとまりとする)\nint ice[MAX_W][MAX_W];\n// g[y][x] := (x,y) からゴールへの仮の距離\nint g[MAX_W][MAX_W];\n\n// (コスト,スタートからの距離,位置,氷の耐久)\nstruct State{\n\tint cost, cnt, x, y;\n\tvector<int> b;\n\tState(int cost_, int cnt_, int x_, int y_, const vector<int>& b_){\n\t\tcost = cost_; cnt = cnt_; x = x_; y = y_; b = b_;\n\t}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost > b.cost;\n}\n\n// 氷の連結成分を調べる.\nvoid dfs(int x, int y, vector<P>& vp){\n\tif( s[y][x] == 'X' ){\n\t\ts[y][x] = 'x';\n\t\tvp.push_back( P(x,y) );\n\t}else{\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\tif( s[my][mx] == 'X' ){\n\t\t\tdfs(mx,my,vp);\n\t\t}\n\t}\n}\n\n// ゴールからの仮の距離を調べる\nvoid bfs(int gx, int gy){\n\tqueue<P> q;\n\tq.push( P(gx,gy) );\n\tg[gy][gx] = 0;\n\twhile( !q.empty() ){\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tint cnt = g[y][x];\n\t\tq.pop();\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tif( s[my][mx] == '.' || s[my][mx] == 'x' ){\n\t\t\t\tif( g[my][mx] == INF ){\n\t\t\t\t\tg[my][mx] = cnt + 1;\n\t\t\t\t\tq.push( P(mx,my) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\tint sx, sy, gx, gy;\n\tint memo[MAX_W][MAX_W];\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tice[y][x] = -1;\n\t\t\tg[y][x] = INF;\n\t\t\tmemo[y][x] = 0;\n\t\t}\n\t}\n\t// b[id] := 氷の番号 id があと何歩で壊れるかを返す.\n\tvector<int> b;\n\t// スタートとゴールと氷の連結成分を調べる.\n\tint id=0;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == 'S' ){\n\t\t\t\ts[y][x]  = '.';\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t}\n\t\t\tif( s[y][x] == 'G' ){\n\t\t\t\ts[y][x]  = '.';\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t}\n\t\t\tif( s[y][x] == 'X' ){\n\t\t\t\tvector<P> vp;\n\t\t\t\tdfs(x,y,vp);\n\t\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\t\tint ax = vp[i].first;\n\t\t\t\t\tint ay = vp[i].second;\n\t\t\t\t\tice[ay][ax] = id;\n\t\t\t\t}\n\t\t\t\tb.push_back( vp.size()/2 );\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t}\n\t// ゴールからの仮の距離を調べる\n\tbfs(gx,gy);\n\t\n\t// (コスト,スタートからの距離,位置) を優先度つきキューで保持\n\t// コストは スタートからの距離 + ゴールまでの仮の距離\n\tpriority_queue<State> q;\n\tq.push( State(g[sy][sx],0,sx,sy,b) );\n\t\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint cost = q.top().cost;\n\t\tint cnt = q.top().cnt;\n\t\tint x = q.top().x;\n\t\tint y = q.top().y;\n\t\tvector<int> b = q.top().b;\n\t\tq.pop();\n\t\tmemo[y][x]++;\n\t\tif( memo[y][x] > 100 ) continue;\n\t\t\n\t\tif( res < cnt + g[y][x] ) continue;\n\t\tif( x == gx && y == gy ){\n\t\t\tres = min( res , cnt );\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tif( s[my][mx] == '.' ){\n\t\t\t\tq.push( State(cnt+g[my][mx],cnt+1,mx,my,b) );\n\t\t\t}\n\t\t\tif( s[my][mx] == 'x' ){\n\t\t\t\tint id = ice[my][mx];\n\t\t\t\tif( id < b.size() && b[id] > 0 ){\n\t\t\t\t\tb[id]--;\n\t\t\t\t\tq.push( State(cnt+g[my][mx],cnt+1,mx,my,b) );\n\t\t\t\t\tb[id]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\ts = vector<string>(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> s[y];\n\t\t}\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\nint w, h, sx, sy, gx, gy;\nchar c[16][16];\nint f[16][16];\nvector<int> limit;\n\nvoid mark_ice(int _x, int _y)\n{\n\tint size = 0;\n\tint id = limit.size();\n\n\tqueue<pint> q;\n\tq.push(pint(_x, _y));\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second;\n\t\tq.pop();\n\n\t\tf[y][x] = id;\n\t\t++size;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (valid_pos(nx, ny, w, h) && c[ny][nx] == 'X' && f[ny][nx] == -1)\n\t\t\t\tq.push(pint(nx, ny));\n\t\t}\n\t}\n\n\tlimit.push_back((size + 2) / 2);\n}\n\nint res;\nint walk[256];\nbool visit[16][16];\nint dir[16][16][4];\nint gdir[16][16];\nvoid dfs(int x, int y, int dis)\n{\n\tif (gdir[y][x] + dis >= res)\n\t\treturn;\n\telse if (x == gx && y == gy)\n\t{\n\t\tres = dis;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint d = dir[y][x][i];\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (valid_pos(nx, ny, w, h) && !visit[ny][nx] && f[ny][nx] != -1)\n\t\t{\n\t\t\tint id = f[ny][nx];\n\t\t\t++walk[id];\n\t\t\tif (walk[id] < limit[id])\n\t\t\t{\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tdfs(nx, ny, dis + 1);\n\t\t\t\tvisit[ny][nx] = false;\n\t\t\t}\n\t\t\t--walk[id];\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> w >> h, w)\n\t{\n\t\tlimit.clear();\n\t\tCL(visit, 0);\n\t\tCL(f, -1);\n\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> c[i];\n\n\t\tlimit.push_back(114514);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (strchr(\"SG.\", c[y][x]))\n\t\t\t\t\tf[y][x] = 0;\n\n\t\t\t\tif (c[y][x] == 'S')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (c[y][x] == 'G')\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t\telse if (c[y][x] == 'X' && f[y][x] == -1)\n\t\t\t\t\tmark_ice(x, y);\n\t\t\t\telse if (c[y][x] == '#')\n\t\t\t\t\tf[y][x] = -1;\n\n\t\t\t\tpint dd[4];\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdd[i] = pint(abs(x + dx[i] - gx) + abs(y + dy[i] - gy), i);\n\t\t\t\tsort(dd, dd + 4);\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdir[y][x][i] = dd[i].second;\n\t\t\t}\n\t\t}\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tgdir[y][x] = abs(x - gx) + abs(y - gy);\n\n\t\tres = 114514;\n\t\tvisit[sy][sx] = true;\n\t\tdfs(sx, sy, 0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\ntypedef pair<P,vector<int> > State;\nconst int MAX_W = 12;\nconst int INF = 1e+8;\n\nint w, h;\nvector<string> s;\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// ice[y][x] := 氷の番号を返す. (連結な氷をひとつのまとまりとする)\nint ice[MAX_W][MAX_W];\n\n// 氷の連結成分を調べる.\nvoid dfs(int x, int y, vector<P>& vp){\n\tif( s[y][x] == 'X' ){\n\t\ts[y][x] = 'x';\n\t\tvp.push_back( P(x,y) );\n\t}else{\n\t\treturn;\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\tif( s[my][mx] == 'X' ){\n\t\t\tdfs(mx,my,vp);\n\t\t}\n\t}\n}\n\nint solve(){\n\tint sx, sy, gx, gy;\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tice[y][x] = -1;\n\t\t}\n\t}\n\t// b[id] := 氷の番号 id があと何歩で壊れるかを返す.\n\tvector<int> b;\n\t// スタートとゴールと氷の連結成分を調べる.\n\tint id=0;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == 'S' ){\n\t\t\t\ts[y][x]  = '.';\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t}\n\t\t\tif( s[y][x] == 'G' ){\n\t\t\t\ts[y][x]  = '.';\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t}\n\t\t\tif( s[y][x] == 'X' ){\n\t\t\t\tvector<P> vp;\n\t\t\t\tdfs(x,y,vp);\n\t\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\t\tint ax = vp[i].first;\n\t\t\t\t\tint ay = vp[i].second;\n\t\t\t\t\tice[ay][ax] = id;\n\t\t\t\t}\n\t\t\t\tb.push_back( vp.size()/2 );\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t}\n\tmap<State,int> d;\n\td[State(P(sx,sy),b)] = 0;\n\tqueue<State> q;\n\tq.push( State(P(sx,sy),b) );\n\tint res = INF;\n\twhile( !q.empty() ){\n\t\tint x = q.front().first.first;\n\t\tint y = q.front().first.second;\n\t\tvector<int> b = q.front().second;\n\t\tint cnt = d[State(P(x,y),b)];\n\t\tq.pop();\n\t\t\n\t\tif( x == gx && y == gy ){\n\t\t\tres = cnt;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tif( s[my][mx] == '.' ){\n\t\t\t\tState next(P(mx,my),b);\n\t\t\t\tif( !d.count(next) ){\n\t\t\t\t\td[next] = cnt+1;\n\t\t\t\t\tq.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( s[my][mx] == 'x' ){\n\t\t\t\tint id = ice[my][mx];\n\t\t\t\tif( id < b.size() && b[id] > 0 ){\n\t\t\t\t\tb[id]--;\n\t\t\t\t\tState next(P(mx,my),b);\n\t\t\t\t\tif( !d.count(next) ){\n\t\t\t\t\t\td[next] = cnt+1;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t\tb[id]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\ts = vector<string>(h);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> s[y];\n\t\t}\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n\n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X'){\n\tnum[n] = 0;\n\tgroup(i,j,n);\n\tnum[n]/=2;\n\tn++;\n      }\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (10000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  int cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),int cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\n\nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n\tif( c[y][x] == '#' || c[y][x] == '*') return 0;\n\tif( C >= ans ) return 0;\n\tif( c[y][x] == 'G'){\n\t\tans = C;\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( px == tx && ty == py ) continue;\n\t\tif( c[ty][tx] == '*' ) return 0;\n\t}\n\tchar cur = c[y][x];\n\tc[y][x] = '*';\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( c[ty][tx] == 'X' ){\n\t\t\tint b = belong[ty][tx];\n\t\t\tif( ok[b] > 0 ){\n\t\t\t\tok[b]--;\n\t\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t\t\tok[b]++;\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t}\n\t}\n\tc[y][x] = cur;\n\treturn 0;\n}\nint grouping(int x,int y,int k){\n\tif( c[y][x] != 'X') return 0;\n\tif( belong[y][x] != -1 ) return 0;\n\tbelong[y][x] = k;\n\tccc++;\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tgrouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint W,H;\n\twhile(cin >> W >> H && W){\n\t\trep(i,14)rep(j,14) belong[i][j] = -1;\n\t\trep(i,14)rep(j,14) \n\t\t\tc[i][j] = '#';\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif(c[i+1][j+1] == 'S'){\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t\tsx = j+1 , sy = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t\t\t\t\tccc = 0;\n\t\t\t\t\tgrouping(j,i,k);\n\t\t\t\t\tok[k] = ccc / 2;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e7;\n\t\tdfs(sx,sy,0,-1,-1);\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nus max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = (v.size() ? v.size() : 0) + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {\n        result += v[i] * digit;\n        digit *= base;\n    }\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n// cout<<step<<\" \"<<y<<\",\"<<x<<endl;\n// cout<<memo<<endl;\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 20;\n        if(durability.size()) base = max(20, *max_element(durability.begin(), durability.end()));\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,z,m[13][13],a[36],c[13][13],mn[36],dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\n\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (d>=an) return 0;\n\tif (x1==gx && y1==gy) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4;j++) if (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) z+=c[y2+dy[j]][x2+dx[j]];\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=1000; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n      if(cnt >= 100 && cnt % 2 == 0 && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(pre);\n\t}\n\n      if(cnt >= 100 && cnt % 6 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\tf[gy][gx]=0;\n\t\tmemset(f,0,sizeof(f));\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==0){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,int > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  random_shuffle(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].first;\n    int nj = v[i].second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nbool visited[12][12];\nint visited_ice[12*12];\nint ans;\nint sy, sx, gy, gx;\nvoid dfs2(int y, int x, int py, int px, int d){\n    //printf(\"%d %d\\n\",y,x);\n    //if(d >= ans) return;\n    if(y==gy&&x==gx){\n        ans = min(d, ans);\n        return;\n    }\n    if(d + abs(gy-y) + abs(gx-x) >= ans) return;\n    /*for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(ny==py&&nx==px)continue;\n        if(visited[ny][nx]) return;\n    }*/\n    visited[y][x] = true;\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        //printf(\"y=%d x=%d ny=%d nx=%d\\n\", y, x, ny, nx);\n        if(visited[ny][nx])continue;\n        if(ifield[ny][nx]==-2)continue;\n        if(ifield[ny][nx]>=0){\n            int ice_i = ifield[ny][nx];\n            if(ice_num[ice_i]/2 < visited_ice[ice_i]+1) continue;\n            visited_ice[ice_i]++;\n            dfs2(ny, nx, y, x, d+1);\n            visited_ice[ice_i]--;\n        }else{\n            dfs2(ny, nx, y, x, d+1);\n        }\n    }\n    visited[y][x] = false;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        ans = INF;\n        memset(visited, 0, sizeof(visited));\n        memset(visited_ice, 0, sizeof(visited_ice));\n        dfs2(sy, sx, -1, -1, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\ttypedef pair<char,char> pcc;\n\t\ttypedef vector<unsigned char> vuc;\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvuc c;\n\t\t\tState(int i,int j,int d,const vuc& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\t\n\t\tqueue<State> q;\n\t\tq.emplace(s.first,s.second,0,vuc(f.size()));\n\t\tset<pair<pcc,vuc>> memo;\n\t\twhile(!q.empty()){\n\t\t\tState cur=q.front(); q.pop();\n\t\t\t\n\t\t\titer(memo) it=memo.find(mp(mp(cur.i,cur.j),cur.c)); \n\t\t\tif(it!=memo.end()) continue;\n\t\t\tmemo.insert(mp(mp(cur.i,cur.j),cur.c));\n\t\t\t\n\t\t\tif(pii(cur.i,cur.j)==g){\n\t\t\t\tcout<<cur.d<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tvuc nc=cur.c;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tnc[p]++;\n\t\t\t\t\tif(2*nc[p]>cnt[p])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.emplace(ni,nj,cur.d+1,nc);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int ROOM = -1;\nconst int WALL = -2;\nconst int ICE = -3;\n\nconst int MI_X = 12;\nconst int MI_Y= 12;\n\nconst int ANGLE_KIND = 4;//4方向\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint maxx,maxy;//フィールドの大きさ\n\nvector<int>icePow;//氷の耐久力を保存（各フィールドの値はこの要素の値\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int _x,int _y):x(_x),y(_y){}\n\tPoint():x(0),y(0){}\n};\n\n\nPoint start;\nPoint gool;\n\nint minField[MI_Y][MI_X];\n\n//iceP iceの位置を保存する\nvoid IceSet(int field[MI_Y][MI_X],Point fP,vector<Point>& iceP)//わたすのは現在のice\n{\n\ticeP.push_back(fP);\n\tfield[fP.y][fP.x] = icePow.size();\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(fP.x+dx[i],fP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == ICE)\n\t\t\tIceSet(field,p,iceP);\n\t}\n\treturn;\n}\n\nvoid Serch(const int field[MI_Y][MI_X],Point sP,int sField[MI_Y][MI_X],int count,vector<int> icePower)\n{\n\tsField[sP.y][sP.x] = count;\n\t/*cout << endl << endl;\n\tfor(int y=0;y<maxy;++y)\n\t{\n\t\tfor(int x=0;x<maxx;++x)\n\t\t{\n\t\t\tcout << sField[y][x] << ' ';\n\t\t}\n\t\tcout << endl;\n\t}*/\n\tif(field[sP.y][sP.x] >= 0)\n\t\t--icePower[field[sP.y][sP.x]];\n\tfor(int i=0;i<ANGLE_KIND;++i)\n\t{\n\t\tPoint p(sP.x+dx[i],sP.y+dy[i]);\n\t\tif(p.x >= maxx || p.y >= maxy || p.x < 0 || p.y < 0)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] == WALL)\n\t\t\tcontinue;\n\t\tif(field[p.y][p.x] >= 0)\n\t\t\tif(icePower[field[p.y][p.x]] <= 0)//氷がパリーン！\n\t\t\t\tcontinue;\n\t\t\telse if ( sField[p.y][p.x] > count+1)\n\t\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\tif(sField[p.y][p.x] == -1 || sField[p.y][p.x] > count+1)//記録更新！\n\t\t{\n\t\t\tif(p.y == gool.y && p.x == gool.x)\n\t\t\t{\n\t\t\t\tsField[p.y][p.x] = count+1;\n\n\t\t\t\tif(minField[gool.y][gool.x] > sField[gool.y][gool.x] || minField[gool.y][gool.x] == -1)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<maxy;++y)\n\t\t\t\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t\t\t\t\tminField[y][x] = sField[y][x];\n\t\t\t\t}\n\t\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\t\tsField[p.y][p.x] = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSerch(field,p,sField,count+1,icePower);\n\t\t}\n\t\tif(minField[p.y][p.x] < count+1 && minField[p.y][p.x] != -1)\n\t\t{\n\t\t\tsField[sP.y][sP.x] = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tsField[sP.y][sP.x] = -1;\n\treturn;\n}\n\nint main(void)\n{\n\tint field[MI_Y][MI_X];\n\n\twhile(cin >> maxx,cin >> maxy,maxx || maxy)//入力\n\t{\n\t\tfor(int y=0;y<maxy;++y)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tchar input = getchar();\n\t\t\t\tif(input == '.')\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\telse if(input == '#')\n\t\t\t\t\tfield[y][x] = WALL;\n\t\t\t\telse if(input == 'X')\n\t\t\t\t\tfield[y][x] = ICE;\n\t\t\t\telse if(input == 'S'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tstart.y = y;\n\t\t\t\t\tstart.x = x;\n\t\t\t\t}\n\t\t\t\telse if(input == 'G'){\n\t\t\t\t\tfield[y][x] = ROOM;\n\t\t\t\t\tgool.y = y;\n\t\t\t\t\tgool.x = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}//入力終わり\n\t\tfor(int y=0;y<maxy;++y)//ICEの値をアレに\n\t\t{\n\t\t\tfor(int x=0;x<maxx;++x)\n\t\t\t{\n\t\t\t\tvector<Point> v;\n\t\t\t\tif(field[y][x] == ICE)\n\t\t\t\t{\n\t\t\t\t\tIceSet(field,Point(x,y),v);\n\t\t\t\t\ticePow.push_back(v.size()/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ここから深さ優先\n\t\tint serchField[MI_Y][MI_X];\n\t\tfor(int i=0;i<MI_Y;++i)//-1で初期化\n\t\t{\n\t\t\tfor(int j=0;j<MI_X;++j)\n\t\t\t{\n\t\t\t\tserchField[i][j] = -1;\n\t\t\t\tminField[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSerch(field,start,serchField,0,icePow);\n\t\tcout << minField[gool.y][gool.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n//　薄氷2011-y-10\t//サンプルデータのみｋ\n\n#include <stdio.h>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1 << 15\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1},\n\tdy[] = {-1,0,1,0};\n\nint X,Y;\nint d[12][12],dd[12][12],ddd[12][12];\nint IceNum, Ice[144];\nP S,G;\n\nqueue<P> que;\n\nbool check(int NX, int NY)\n{\n\tif(NX >= X || NY >= Y || NX < 0 || NY < 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs(P pos, int now)\n{\n\tif(pos == G){\n\t\tdd[pos.second][pos.first] = min(dd[pos.second][pos.first], now);\n\t\treturn;\n\t}\n\telse if(d[pos.second][pos.first] > 0 && ddd[pos.second][pos.first] > Ice[d[pos.second][pos.first]]);\n\telse if(now > dd[pos.second][pos.first])\n\t\treturn;\n\n\tdd[pos.second][pos.first] = now;\n\n\tint nx,ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\tif(check(nx,ny) && d[ny][nx] != -1){\n\t\t\tif(d[ny][nx] > 0){\n\t\t\t\tif(Ice[ d[ny][nx] ] > 0){\n\t\t\t\t\tIce[ d[ny][nx] ]--;\n\t\t\t\t\tddd[ny][nx] = Ice[ d[ny][nx] ];\n\t\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t\t\t\tIce[ d[ny][nx] ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t}\n\t}\n\n\n\t\t\n}\nint main(void)\n{\n\twhile(cin >> X >> Y, X > 0 && Y > 0){\n\t\tfill(&dd[0][0],&dd[0][0]+144, INF);\n\t\tfill(&Ice[0],&Ice[0]+144, 0);\n\t\tfill(&ddd[0][0],&ddd[0][0]+144,0);\n\t\tIceNum = 0;\n\t\tchar s[13];\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor(int j = 0; s[j] != '\\0'; j++){\n\t\t\t\tif(s[j] == '.')\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\telse if(s[j] == '#')\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\telse if(s[j] == 'X')\n\t\t\t\t\td[i][j] = -2;\n\t\t\t\telse if(s[j] == 'S')\n\t\t\t\t\tS = P(j,i),d[i][j] = 0;\n\t\t\t\telse if(s[j] == 'G')\n\t\t\t\t\tG = P(j,i),d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(d[i][j] == -2){\n\t\t\t\t\tIceNum++;\n\t\t\t\t\t\n\t\t\t\t\tque.push(P(j,i));\n\n\t\t\t\t\twhile(que.size()){\n\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\td[p.second][p.first] = IceNum;\n\t\t\t\t\t\tIce[IceNum]++;\n\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\t\t\t\tif(check(nx,ny) && d[ny][nx] == -2){\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++)\n\t\t\t\tprintf(\"%2d\", d[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < 144; i++)\n\t\t\tIce[i] /= 2;\n\n\t\tdfs(S,0);\n\t\tprintf(\"%d\\n\", dd[G.second][G.first]);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\nint w, h, sx, sy, gx, gy;\nchar c[16][16];\nint f[16][16];\nvector<int> limit;\n\nvoid mark_ice(int _x, int _y)\n{\n\tint size = 0;\n\tint id = limit.size();\n\n\tqueue<pint> q;\n\tq.push(pint(_x, _y));\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second;\n\t\tq.pop();\n\n\t\tf[y][x] = id;\n\t\t++size;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (valid_pos(nx, ny, w, h) && c[ny][nx] == 'X' && f[ny][nx] == -1)\n\t\t\t\tq.push(pint(nx, ny));\n\t\t}\n\t}\n\n\tlimit.push_back((size + 2) / 2);\n}\n\nint res;\nint walk[256];\nbool visit[16][16];\nint dir[16][16][4];\nvoid dfs(int x, int y, int dis)\n{\n\tif (abs(x - gx) + abs(y - gy) + dis >= res)\n\t\treturn;\n\telse if (x == gx && y == gy)\n\t{\n\t\tres = dis;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint d = dir[y][x][i];\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (valid_pos(nx, ny, w, h) && !visit[ny][nx] && f[ny][nx] != -1)\n\t\t{\n\t\t\tint id = f[ny][nx];\n\t\t\t++walk[id];\n\t\t\tif (walk[id] < limit[id])\n\t\t\t{\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tdfs(nx, ny, dis + 1);\n\t\t\t\tvisit[ny][nx] = false;\n\t\t\t}\n\t\t\t--walk[id];\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> w >> h, w)\n\t{\n\t\tlimit.clear();\n\t\tCL(visit, 0);\n\t\tCL(f, -1);\n\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> c[i];\n\n\t\tlimit.push_back(114514);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (strchr(\"SG.\", c[y][x]))\n\t\t\t\t\tf[y][x] = 0;\n\n\t\t\t\tif (c[y][x] == 'S')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (c[y][x] == 'G')\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t\telse if (c[y][x] == 'X' && f[y][x] == -1)\n\t\t\t\t\tmark_ice(x, y);\n\t\t\t\telse if (c[y][x] == '#')\n\t\t\t\t\tf[y][x] = -1;\n\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdir[y][x][i] = i;\n\t\t\t\trandom_shuffle(dir[y][x], dir[y][x] + 4);\n\t\t\t}\n\t\t}\n\n\t\tres = 114514;\n\t\tvisit[sy][sx] = true;\n\t\tdfs(sx, sy, 0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <queue>\nusing namespace std;\n\nint H, W, sx, sy, gx, gy, col[13][13], G[130], cnts, bit[130]; char c[13][13]; long long J[130], JJ[130];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nmap<long long, int>Map[13][13];\n\nvoid init() {\n\tH = 0; W = 0; sx = 0; sy = 0; gx = 0; gy = 0; cnts = 0;\n\tfor (int i = 0; i < 13; i++) {\n\t\tfor (int j = 0; j < 13; j++) { col[i][j] = 0; Map[i][j].clear(); c[i][j] = 0; }\n\t}\n\tfor (int i = 0; i < 130; i++) { G[i] = 0; J[i] = 0; JJ[i] = 0; }\n}\n\nvoid dfs1(int px, int py) {\n\tif (px < 0 || py < 0 || px >= H || py >= W) return;\n\tif (col[px][py] >= 1 || c[px][py] != 'X') return;\n\tcol[px][py] = cnts; G[cnts]++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tdfs1(px + dx[i], py + dy[i]);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tinit();\n\t\tcin >> W >> H; if (H == 0 && W == 0) break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif (c[i][j] == 'S') { sx = i; sy = j; c[i][j] = '.'; }\n\t\t\t\tif (c[i][j] == 'G') { gx = i; gy = j; c[i][j] = '.'; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (c[i][j] != 'X' || col[i][j] >= 1) continue;\n\t\t\t\tcnts++; dfs1(i, j);\n\t\t\t}\n\t\t}\n\t\tJJ[1] = 1;\n\t\tfor (int i = 1; i <= cnts; i++) { J[i] = (G[i] / 2 + 1); if (i >= 2) JJ[i] = JJ[i - 1] * J[i - 1]; }\n\n\t\tqueue<tuple<int, int, long long>> Q;\n\t\tQ.push(make_tuple(sx, sy, 0)); Map[sx][sy][0] = 1;\n\t\t\n\t\tint ans = (1 << 30);\n\n\t\twhile (!Q.empty()) {\n\t\t\tint px = get<0>(Q.front()), py = get<1>(Q.front()); long long V = get<2>(Q.front()); Q.pop();\n\t\t\tint cost = Map[px][py][V];\n\t\t\tif (px == gx && py == gy) {\n\t\t\t\tans = min(ans, cost); break;\n\t\t\t}\n\n\t\t\tlong long VV = V;\n\t\t\tfor (int i = 1; i <= cnts; i++) { bit[i] = VV % J[i]; VV /= J[i]; }\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint vx = px + dx[i], vy = py + dy[i];\n\t\t\t\tif (vx < 0 || vy < 0 || vx >= H || vy >= W || c[vx][vy] == '#') continue;\n\n\t\t\t\tlong long I = V; bool die = false;\n\t\t\t\tif (col[vx][vy] >= 1) {\n\t\t\t\t\tI += JJ[col[vx][vy]];\n\t\t\t\t\tif (bit[col[vx][vy]] + 1 == J[col[vx][vy]]) die = true;\n\t\t\t\t}\n\t\t\t\tif (die == true) continue;\n\t\t\t\t\n\t\t\t\tif (Map[vx][vy][I] == 0) {\n\t\t\t\t\tMap[vx][vy][I] = cost + 1; Q.push(make_tuple(vx, vy, I));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans - 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    if(cost+1+fromG[ni][nj] >= ans) continue;\n    v.push_back(make_pair(fromG[ni][nj]+(G[ni][nj]=='X')*INF, make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      \n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      \n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring g[20];\nvector<int> cnt;\nint num[200],n;\nint ice[20][20];\nint sy,sx;\nbool vis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x, int d){\n  if(ans<=d)return INF;\n  if(g[y][x] == 'G'){ans = min(ans,d); return 0;}\n  if(memo.find(cnt)!=memo.end()){ans = min(ans,d + memo[cnt]); return memo[cnt];}\n  \n  vis[y][x] = true;\n\n  int res = 200;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[curg]--; cnt[n] = y; cnt[n+1] = x;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[n] = y; cnt[n+1] = x;\n    }\n  }\n  vis[y][x] = false;\n\n  if(res<INF)memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n    }\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    ans = 200;\n    dfs(sy,sx,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (10000)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  int cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),int cost=sinf,us prev=sinf):array(array),cost(cost),prev(prev){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\n//set<ull> mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  // while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  //printf(\"h\\n\",pox.cost);\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  //while(scanf(\"h h\",&w,&h),w|h)\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n      while(!Q.empty())Q.pop_back();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\tcin>>lx>>ly;\n\t\tif(lx==0&&ly==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(maps,0,sizeof(maps));\n\t\tmemset(ig,0,sizeof(ig));\n\t\tmin=144;\n\tfor(i=0;i<ly;i++){\n\t\tcin>>map[i];\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(map[i][j]=='S'){\n\t\t\t\tr.x=j;\n\t\t\t\tr.y=i;\n\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\tr.cnt=0;\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\tv.x=j;\n\t\t\t\tv.y=i;\n\t\t\t\tq.push(v);\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tv=q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tu=v;\n\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<ly;i++){\n\t\tfor(j=0;j<lx;j++){\n\t\t\tif(maps[i][j]>0){\n\t\t\t\tig[maps[i][j]]++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!s.empty()){\n\t\tr=s.top();\n\t\ts.pop();\n\t\tif(r.visited[r.y][r.x]==1){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tr.visited[r.y][r.x]=1;\n\t\t}\n\t\tif(r.cnt>=min){\n\t\t\tcontinue;\n\t\t}\n\t\tif(map[r.y][r.x]=='G'&&r.cnt<min){\n\t\t\tmin=r.cnt;\n\t\t\tcontinue;\n\t\t}\n\t\tif(maps[r.y][r.x]>0){\n\t\t\ta=maps[r.y][r.x];\n\t\t\tr.ic[a]++;\n\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tt=r;\n\t\t\tt.x+=mx[i];\n\t\t\tt.y+=my[i];\n\t\t\tif(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\tt.cnt++;\n\t\t\t\ts.push(t);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nstruct S{\n    int x, y;\n    int c, h;\n    vector<int> cnt;\n    bool operator < (const S& s) const {\n        return c + h > s.c + s.h;\n    }\n};\n\nint main(){\n    int W, H;\n    while(cin >> W >> H && W){\n        int sx, sy, gx, gy;\n        vector<string> grid(H);\n        REP(y, H) cin >> grid[y];\n        REP(y, H) REP(x, W) if(grid[y][x] == 'S') { grid[y][x] = '.'; sx = x; sy = y; }\n        REP(y, H) REP(x, W) if(grid[y][x] == 'G') { grid[y][x] = '.'; gx = x; gy = y; }\n\n        int ice_count = 0;\n        int ice_id[12][12] = {};\n        vector<int> ice_v;\n        REP(y, H) REP(x, W) if(grid[y][x] == 'X' && ice_id[y][x] == 0){\n            ice_id[y][x] = ++ice_count;\n            ice_v.push_back(1);\n            queue<int> qx, qy;\n            qx.push(x); qy.push(y);\n            while(!qx.empty()){\n                int bx = qx.front(); qx.pop();\n                int by = qy.front(); qy.pop();\n                REP(r, 4) {\n                    int nx = bx + dx[r];\n                    int ny = by + dy[r];\n                    if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] == 'X' && ice_id[ny][nx] == 0){\n                        qx.push(nx);\n                        qy.push(ny);\n                        ice_id[ny][nx] = ice_count;\n                        ice_v[ice_count - 1]++;\n                    }\n                }\n            }\n        }\n\n        int h_value[12][12];\n        memset(h_value, -1, sizeof h_value);\n        queue<int> qx, qy;\n        qx.push(gx); qy.push(gy);\n        h_value[gy][gx] = 0;\n        while(!qx.empty()){\n            int bx = qx.front(); qx.pop();\n            int by = qy.front(); qy.pop();\n            REP(r, 4) {\n                int nx = bx + dx[r];\n                int ny = by + dy[r];\n                if(nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] != '#' && h_value[ny][nx] == -1){\n                    qx.push(nx);\n                    qy.push(ny);\n                    h_value[ny][nx] = h_value[by][bx] + 1;\n                }\n            }\n        }\n\n        priority_queue<S> que;\n        S init;\n        init.x = sx, init.y = sy;\n        init.cnt.resize(ice_count);\n        init.c = 0; init.h = h_value[sy][sx];\n        set<vector<int>> used[12][12];\n        que.push(init);\n        while(!que.empty()){\n            S s = que.top(); que.pop();\n            if(s.h == 0){\n                cout << s.c << endl;\n                break;\n            }\n            REP(r, 4){\n                S next = s;\n                next.x += dx[r]; next.y += dy[r];\n                if(!(next.x >= 0 && next.x < W && next.y >= 0 && next.y < H && grid[next.y][next.x] != '#')) continue;\n                next.c ++;\n                next.h = h_value[next.y][next.x];\n                int id = ice_id[next.y][next.x] - 1;\n                if(id >= 0) next.cnt[id]++;\n                if(id >= 0 && next.cnt[id] > ice_v[id] / 2) continue;\n                if(used[next.y][next.x].count(next.cnt)) continue;\n                used[next.y][next.x].insert(next.cnt);\n                que.push(next);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[12][13],gy,gx;\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // ツ氷ツづーツ督・ツづアツつセツ嘉アツ青?\nvoid dfs(int i,int j,int now){\n\tif(ans<=now) return;\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tif(B[i][j]=='X'){\n\t\tif(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\t\tstep[ice[i][j]]++;\n\t}\n\n\tvis[i][j]=true;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]){\n\t\t\t// ツつアツづェツづ慊づ?づ可津環づ?つスツ督ケツつゥツづァ (y,x) ツづ可シツδ?ーツトツカツッツトツつオツづ?猟按づェツづゥツ湘ェツ債?づ債枝ツ環?づィ\n\t\t\tbool ok=true;\n\t\t\trep(l,4) if((k-l+4)%4!=2) {\n\t\t\t\tint yy=y+dy[l],xx=x+dx[l];\n\t\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && vis[yy][xx]) ok=false;\n\t\t\t}\n\t\t\tif(ok) dfs(y,x,now+1);\n\t\t}\n\t}\n\tvis[i][j]=false;\n\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t}\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nbitset<10000000> visited[12][12];\nvector<int> icesq;\n\nstruct data {\n\tint x, y;\n\tint t, v;\n\tdata(int x_, int y_, int t_, int v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tq.push(data(S.se, S.fi, 0, 0));\n\t\tvector<int> radix;\n\t\tradix.resize(icesq.size() + 1);\n\t\tradix[0] = 1;\n\t\tfor(int i = 1; i < radix.size(); i++) {\n\t\t\tradix[i] = radix[i-1] * (icesq[i-1] + 1);\n\t\t}\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\tfor(int j = 0; j < 12; j++) {\n\t\t\t\tvisited[i][j].reset();\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(!visited[ny-1][nx-1][cur.v]) {\n\t\t\t\t\t\tvisited[ny-1][nx-1][cur.v] = true;\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X') {\n\t\t\t\t\tint flgcnts;\n\t\t\t\t\tflgcnts = (cur.v % radix[ice[ny][nx]+1]) / radix[ice[ny][nx]];\n\t\t\t\t\tif(flgcnts < icesq[ice[ny][nx]]) {\n\t\t\t\t\t\tint tmp = cur.v + radix[ice[ny][nx]];\n\t\t\t\t\t\tif(!visited[ny-1][nx-1][tmp]) {\n\t\t\t\t\t\t\tvisited[ny-1][nx-1][tmp] = true;\n\t\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<int> v;\n  S(int py,int px,vector<int> pv):y(py),x(px),v(pv){\n  }\n};\n\nint x,y;\nchar g[12][12];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<int>(nid));\n    set<vector<int> > mem[12][12];\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(!mem[e.y][e.x].insert(e.v).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>      \nusing namespace std;      \nconst int INF = 1 << 30;      \n      \nint W, H;      \nchar mas[20][20];      \nint sy, sx, gy, gx;      \nint cnt;      \nint snow[144];      \nint number[20][20];      \nbool used[20][20];      \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};      \nint ans;      \n      \nint dfs( int x, int y, const int& idx){      \n  if(x < 0 || x >= W || y < 0 || y >= H) return 0;      \n  if(mas[y][x] != 'X') return 0;      \n  if(number[y][x] != -1) return 0;      \n  number[y][x] = idx;      \n  int ret = 1;      \n  for(int i = 0; i < 4; i++){      \n    ret += dfs( x + dx[i], y + dy[i], idx);      \n  }      \n  return ret;      \n}      \nvoid dfs2( int x, int y, int cost,int prevx, int prevy){      \n  if(ans <= cost + abs( y - gy) + abs( x - gx)) return;      \n  if(y == gy && x == gx){      \n    ans = min( ans, cost);      \n    return;      \n  }      \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n    if(used[ny][nx] && ny != y && nx != x) return;\n  }\n\n  \n\n  for(int i = 0; i < 4; i++){      \n    int ny = y + dy[i], nx = x + dx[i];      \n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;      \n    if(mas[ny][nx] == '#' || used[ny][nx]) continue;      \n    if(mas[ny][nx] == 'X'){      \n      if(snow[number[ny][nx]] > 0) snow[number[ny][nx]]--;      \n      else continue;      \n    }      \n    used[ny][nx] = true;      \n    dfs2( nx, ny, cost + 1, x, y);      \n    used[ny][nx] = false;      \n    if(mas[ny][nx] == 'X') snow[number[ny][nx]]++;      \n  }      \n  return;      \n}      \n      \nint main(){      \n  while(cin >> W >> H, W){      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        cin >> mas[i][j];      \n        if(mas[i][j] == 'S' || mas[i][j] == 'G'){      \n          if(mas[i][j] == 'S') sy = i, sx = j;      \n          else gy = i, gx = j;      \n          mas[i][j] = '.';      \n        }      \n      }      \n    }      \n    cnt = 0;      \n    memset( number, -1, sizeof number);      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        if(mas[i][j] == 'X' && number[i][j] == -1){      \n          snow[cnt] = dfs( j, i, cnt) / 2;      \n          cnt++;      \n        }      \n      }      \n    }      \n    memset (used, false, sizeof used);      \n    ans = INF;      \n    used[sy][sx] = true;      \n    dfs2(sx,sy,0,sx,sy);      \n    cout << ans << endl;      \n  }      \n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nvoid dfs(const vs& grid,const vvi& ice,int i,int j,int step,vvi& vis,vi& lim,int& res)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]=='#' || vis[i][j]) return;\n\tif(grid[i][j]=='X' && lim[ice[i][j]]==0) return;\n\tif(grid[i][j]=='G') res=min(res,step);\n\t//if(step>=res) return;\n\t{\n\t\trep(gi,h) rep(gj,w) if(grid[gi][gj]=='G')\n\t\t\tif(step+abs(gi-i)+abs(gj-j)>=res)\n\t\t\t\treturn;\n\t}\n\tvis[i][j]=true;\n\tif(grid[i][j]=='X') lim[ice[i][j]]--;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tdfs(grid,ice,ni,nj,step+1,vis,lim,res);\n\t}\n\tif(grid[i][j]=='X') lim[ice[i][j]]++;\n\tvis[i][j]=false;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvvi ice(h,vi(w,-1));\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X'){\n\t\t\tif(!f.count(uf.Find(i*w+j)))\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\tice[i][j]=f[uf.Find(i*w+j)];\n\t\t}\n\t\tvi cnt(f.size());\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tcnt[ice[i][j]]++;\n\t\tvi lim(cnt.size());\n\t\trep(i,lim.size()) lim[i]=cnt[i]/2;\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='S'){\n\t\t\tvvi vis(h,vi(w));\n\t\t\tdfs(grid,ice,i,j,0,vis,lim,res);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \n \nconst int mod = 1000000007;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \n\n\nint w, h, sx, sy, gx, gy;\nchar c[16][16];\nint f[16][16];\nvector<int> limit;\n\nvoid mark_ice(int _x, int _y)\n{\n\tint size = 0;\n\tint id = limit.size();\n\n\tqueue<pint> q;\n\tq.push(pint(_x, _y));\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second;\n\t\tq.pop();\n\n\t\tf[y][x] = id;\n\t\t++size;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (valid_pos(nx, ny, w, h) && c[ny][nx] == 'X' && f[ny][nx] == -1)\n\t\t\t\tq.push(pint(nx, ny));\n\t\t}\n\t}\n\n\tlimit.push_back((size + 2) / 2);\n}\n\nint res;\nint walk[256];\nbool visit[16][16];\nint dir[16][16][4];\nint gdis[16][16];\n\nvoid dfs(int x, int y, int dis)\n{\n\tif (gdis[y][x] + dis >= res)\n\t\treturn;\n\telse if (x == gx && y == gy)\n\t{\n\t\tres = dis;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint d = dir[y][x][i];\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (valid_pos(nx, ny, w, h) && !visit[ny][nx] && f[ny][nx] != -1)\n\t\t{\n\t\t\tint id = f[ny][nx];\n\t\t\t++walk[id];\n\t\t\tif (walk[id] < limit[id])\n\t\t\t{\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tdfs(nx, ny, dis + 1);\n\t\t\t\tvisit[ny][nx] = false;\n\t\t\t}\n\t\t\t--walk[id];\n\t\t}\n\t}\n}\nint dis_ignore_ice(int sx, int sy)\n{\n\tint d[16][16];\n\tCL(d, -1);\n\tqueue<pint> q;\n\td[sy][sx] = 0;\n\tq.push(pint(sx, sy));\n\twhile (!q.empty())\n\t{\n\t\tint x = q.front().first, y = q.front().second;\n\t\tq.pop();\n\n\t\tif (x == gx && y == gy)\n\t\t\treturn d[y][x];\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (valid_pos(nx, ny, w, h) && c[ny][nx] != '#' && d[ny][nx] == -1)\n\t\t\t{\n\t\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\t\tq.push(pint(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 114514;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> w >> h, w)\n\t{\n\t\tlimit.clear();\n\t\tCL(visit, 0);\n\t\tCL(f, -1);\n\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tcin >> c[i];\n\n\t\tlimit.push_back(114514);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tif (strchr(\"SG.\", c[y][x]))\n\t\t\t\t\tf[y][x] = 0;\n\n\t\t\t\tif (c[y][x] == 'S')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (c[y][x] == 'G')\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t\telse if (c[y][x] == 'X' && f[y][x] == -1)\n\t\t\t\t\tmark_ice(x, y);\n\t\t\t\telse if (c[y][x] == '#')\n\t\t\t\t\tf[y][x] = -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < h; ++y)\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t\tgdis[y][x] = dis_ignore_ice(x, y);\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tpint dd[4];\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\t\tdd[i] = pint(valid_pos(nx, ny, w, h) ? gdis[ny][nx] : 114514, i);\n\t\t\t\t}\n\t\t\t\tsort(dd, dd + 4);\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\tdir[y][x][i] = dd[i].second;\n\t\t\t}\n\t\t}\n\n\t\tres = 114514;\n\t\tvisit[sy][sx] = true;\n\t\tdfs(sx, sy, 0);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define INF 1 << 15\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tint mapc[12][12];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\tmemset(mapc,-1,sizeof(mapc));\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\t\tmapc[i][j]=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly&&r.visited[t.y][t.x]==0){\n\t\t\t\t\tif(mapc[t.y][t.x]>r.cnt+1||mapc[t.y][t.x]==-1){\n\t\t\t\t\t\tmapc[t.y][t.x]=r.cnt+1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(mapc[t.y][t.x]<r.cnt){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(map[t.y][t.x]=='X'){\n\t\t\t\t\t\ta=maps[t.y][t.x];\n\t\t\t\t\t\tt.ic[a]++;\n\t\t\t\t\t\tif(t.ic[a]<=(ig[a]/2)){\n\t\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[12][13],gy,gx;\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // ツ氷ツづーツ督・ツづアツつセツ嘉アツ青?\nvoid dfs(int i,int j,int now){\n\tif(B[i][j]=='X') if(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\n\tif(ans<=now+abs(i-gy)+abs(j-gx)) return; // Manhattan ツ仰猟猟」ツづ?A*\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tif(B[i][j]=='X') step[ice[i][j]]++;\n\n\tvis[i][j]=true;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]){\n\t\t\t// ツつアツづェツづ慊づ?づ可津環づ?つスツ督ケツつゥツづァ (y,x) ツづ可シツδ?ーツトツカツッツトツつオツづ?猟按づェツづゥツ湘ェツ債?づ債枝ツ環?づィ\n\t\t\tbool ok=true;\n\t\t\trep(l,4){\n\t\t\t\tint yy=y+dy[l],xx=x+dx[l];\n\t\t\t\tif((yy!=i || xx!=j) && 0<=yy && yy<h && 0<=xx && xx<w && vis[yy][xx]) ok=false;\n\t\t\t}\n\t\t\tif(ok) dfs(y,x,now+1);\n\t\t}\n\t}\n\tvis[i][j]=false;\n\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t}\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[12][13];\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // 氷を踏んだ回数\nvoid dfs(int i,int j,int now){\n\tif(ans<=now) return;\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tif(B[i][j]=='X'){\n\t\tif(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\t\tstep[ice[i][j]]++;\n\t}\n\n\tvis[i][j]=true;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]) dfs(y,x,now+1);\n\t}\n\tvis[i][j]=false;\n\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='S') sx=j, sy=i;\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\n\n#define fi first\n#define se second\n\ntypedef pair<int,int> pii;\n\nconst int dxy[] = {1, 0, -1, 0, 1};\nchar maze[15][15];\nint ice[15][15];\nbit set<3000000> visited[12][12];\nvector<int> icesq;\n\nstruct data {\n\tint x, y;\n\tint t, v;\n\tdata(int x_, int y_, int t_, int v_) {\n\t\tx = x_;\n\t\ty = y_;\n\t\tt = t_;\n\t\tv = v_;\n\t}\n};\n\nint maketag(int i, int j, int n) {\n\tif(maze[i][j] != 'X' || ice[i][j] != -1)\n\t\treturn 0;\n\tice[i][j] = n;\n\tint res = 1;\n\tfor(int k = 0; k < 4; k++)\n\t\tres += maketag(i+dxy[k], j+dxy[k+1], n);\n\treturn res;\n}\n\nint main() {\n\tint x, y;\n\twhile(cin >> x >> y, x || y) {\n\t\tfor(int i = 0; i < 15; i++) {\n\t\t\tfor(int j = 0; j < 15; j++) {\n\t\t\t\tmaze[i][j] = '#';\n\t\t\t\tice[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tscanf(\"%s\", maze[i+1]+1);\n\t\t\tmaze[i+1][1+x] = '#';\n\t\t}\n\t\ticesq.clear();\n\t\tint tg = 0;\n\t\tpii S, G;\n\t\tfor(int i = 0; i < y; i++) {\n\t\t\tfor(int j = 0; j < x; j++) {\n\t\t\t\tint res;\n\t\t\t\tif(maze[i+1][j+1] == 'S') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tS.fi = i+1; S.se = j+1;\n\t\t\t\t}\n\t\t\t\telse if(maze[i+1][j+1] == 'G') {\n\t\t\t\t\tmaze[i+1][j+1] = '.';\n\t\t\t\t\tG.fi = i+1; G.se = j+1;\n\t\t\t\t}\n\n\t\t\t\tres = maketag(i+1,j+1,tg);\n\t\t\t\tif(res != 0) {\n\t\t\t\t\ticesq.push_back(res / 2);\n\t\t\t\t\ttg++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < 14; i++) {\n\t\t\tfor(int j = 0; j < 14; j++) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t} cout << endl;\n\t\t}\n// */\n/*\n\t\tfor(int i = 0; i < icesq.size(); i++) {\n\t\t\tcout << icesq[i] << \" \";\n\t\t} cout << endl;\n// */\n\t\tqueue<data> q;\n\t\tq.push(data(S.se, S.fi, 0, 0));\n\t\tvector<int> radix;\n\t\tradix.resize(icesq.size() + 1);\n\t\tradix[0] = 1;\n\t\tfor(int i = 1; i < radix.size(); i++) {\n\t\t\tradix[i] = radix[i-1] * (icesq[i-1] + 1);\n\t\t}\n\t\tfor(int i = 0; i < 12; i++) {\n\t\t\tfor(int j = 0; j < 12; j++) {\n\t\t\t\tvisited[i][j].reset();\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()) {\n\t\t\tdata cur = q.front();\n\t\t\tq.pop();\n//\t\t\tcout << cur.y << \" \" << cur.x << \" \" << cur.t << \":\";\n\t\t\tif(cur.y == G.fi && cur.x == G.se) {\n\t\t\t\tcout << cur.t << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx, ny;\n\t\t\t\tny = cur.y + dxy[i];\n\t\t\t\tnx = cur.x + dxy[i+1];\n\n\t\t\t\tif(!(0 < nx && nx <= x && 0 < ny && ny <= y)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(maze[ny][nx] == '.') {\n\t\t\t\t\tif(!visited[ny-1][nx-1][cur.v]) {\n\t\t\t\t\t\tvisited[ny-1][nx-1][cur.v] = true;\n\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, cur.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(maze[ny][nx] == 'X') {\n\t\t\t\t\tint flgcnts;\n\t\t\t\t\tflgcnts = (cur.v % radix[ice[ny][nx]+1]) / radix[ice[ny][nx]];\n\t\t\t\t\tif(flgcnts < icesq[ice[ny][nx]]) {\n\t\t\t\t\t\tint tmp = cur.v + radix[ice[ny][nx]];\n\t\t\t\t\t\tif(!visited[ny-1][nx-1][tmp]) {\n\t\t\t\t\t\t\tvisited[ny-1][nx-1][tmp] = true;\n\t\t\t\t\t\t\tq.push(data(nx, ny, cur.t + 1, tmp));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << \"----------\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,int > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(ni,nj));\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  random_shuffle(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].first;\n    int nj = v[i].second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  //if(ans<=d + dis[y][x])return;\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      num[curg]--;\n      if(num[curg]>=0)dfs(ny,nx,d+1,y,x);\n      num[curg]++;\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  std::ios::sync_with_stdio(false);\n  while(cin >> w >> h, w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n), num[n]/=2, n++;\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n   /*\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n    */\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,ck[13][13],m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\nvoid chek(int x1,int y1) {\n\tint k;\n\tck[y1][x1]=1;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (ck[y1+dy[k]][x1+dx[k]]==0) chek(x1+dx[k],y1+dy[k]); \n\t\t   \t\t}\n    }\n\nint ans(int x1,int y1,int d) {\n\tint j,k,x2,y2;\n\tif (d>=an) return 0;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tif (d % 5==0) { \n\t\tfor (j=0;j<y;j++) for (k=0;k<x;k++) { ck[j][k]=f[j][k]; if (da[j][k]=='#') ck[j][k]=1;}\n\t\t chek(x1,y1);\n\t\tif (ck[gy][gx]==0 ) return 0;\n\t    }\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint p[200];\nint root(int x){\n\tif(p[x] < 0) return x;\n\treturn p[x] = root(p[x]);\n}\nint h, w, dist[200][200];\nint n, sz[200], to[200];\nchar in[12][13];\n\nset<pair<int, vi> > s;\n\nint main(){\n\twhile(cin >> w >> h, h){\n\t\tint sy, sx, gy, gx;\n\t\trep(i, h * w) p[i] = -1;\n\t\trep(i, h * w) rep(j, h * w) dist[i][j] = i == j ? 0 : inf;\n\t\t\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t\tif(in[i][j] == 'X') rep(d, 2){\n\t\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\t\tif(ny >= 0 && nx >= 0 && in[ny][nx] == 'X'){\n\t\t\t\t\t\tint a = root(i * w + j), b = root(ny * w + nx);\n\t\t\t\t\t\tif(a != b){\n\t\t\t\t\t\t\tp[a] += p[b];\n\t\t\t\t\t\t\tp[b] = a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i * w + j][ny * w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tpriority_queue<pair<pi, pair<int, vi> > > q;  //cost*, cost, pos, ice\n\t\t\n\t\t\n\t\tn = 0;\n\t\tmemset(to, -1, sizeof(to));\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tint r = root(i * w + j);\n\t\t\tif(to[r] < 0){\n\t\t\t\tsz[n] = -p[r];\n\t\t\t\tto[r] = n++;\n\t\t\t}\n\t\t}\n\t\ts.clear();\n\t\tq.push(mp(mp(-dist[sy * w + sx][gy * w + gx], 0), mp(sy * w + sx, vi(n))));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tvi v = q.top().second.second;\n\t\t\tint cost = q.top().first.second;\n\t\t\tint y = q.top().second.first;\n\t\t\tint x = y % w; y /= w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(y * w + x, v))) continue;\n\t\t\ts.insert(mp(y * w + x, v));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tvi nv = v;\n\t\t\t\t\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tint r = to[root(ny * w + nx)];\n\t\t\t\t\tnv[r]++;\n\t\t\t\t\tif(sz[r] < nv[r] * 2) continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!s.count(mp(ny * w + nx, nv)))\n\t\t\t\tq.push(mp(mp(cost - dist[ny * w + nx][gy * w + gx], cost - 1), \n\t\t\t\t\tmp(ny * w + nx, nv)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,ck[13][13],m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\nvoid chek(int x1,int y1) {\n\tint k;\n\tck[y1][x1]=1;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (ck[y1+dy[k]][x1+dx[k]]==0) chek(x1+dx[k],y1+dy[k]); \n\t\t   \t\t}\n    }\n\nint ans(int x1,int y1,int d) {\n\tint j,k,x2,y2;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tif (d % 10==0) { \n\t\tfor (j=0;j<y;j++) for (k=0;k<x;k++) { ck[j][k]=f[j][k]; if (da[j][k]=='#') ck[j][k]=1;}\n\t\t chek(x1,y1);\n\t\tif (ck[gy][gx]==0 ) return 0;\n\t    }\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) f[i][j]=0;\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint belong[14][14];\nint ok[10000];\nint rn[24][4];\n\nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n\tif( c[y][x] == '#' || c[y][x] == '*') return 0;\n\tif( C >= ans ) return 0;\n\tif( c[y][x] == 'G'){\n\t\tans = C;\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif( px == tx && ty == py ) continue;\n\t\tif( c[ty][tx] == '*' ) return 0;\n\t}\n\tchar cur = c[y][x];\n\tc[y][x] = '*';\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[rn[(x*7+y*13+C*17)%24][i]];\n\t\tint ty = y + dy[rn[(x*7+y*13+C*17)%24][i]]\t;\n\t\tif( c[ty][tx] == 'X' ){\n\t\t\tint b = belong[ty][tx];\n\t\t\tif( ok[b] > 0 ){\n\t\t\t\tok[b]--;\n\t\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t\t\tok[b]++;\n\t\t\t}\n\t\t}else{\n\t\t\tdfs(tx,ty,C+1,x,y);\n\t\t}\n\t}\n\tc[y][x] = cur;\n\treturn 0;\n}\nint grouping(int x,int y,int k){\n\tif( c[y][x] != 'X') return 0;\n\tif( belong[y][x] != -1 ) return 0;\n\tbelong[y][x] = k;\n\tccc++;\n\tfor(int i = 0 ; i < 4 ; i++)\n\t\tgrouping(x+dx[i],y+dy[i],k);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint W,H;\n\tint rng[] = {0,1,2,3} , ww = 0;\n\t\n\tdo{\n\t\tfor(int i = 0 ; i < 4 ; i++)\n\t\t\trn[ww][i] = rng[i];\n\t\tww++;\n\t}while(next_permutation(rng,rng+4));\n\tsrand(time(NULL));\n\twhile(cin >> W >> H && W){\n\t\trandom_shuffle(rn,rn+24);\n\t\trep(i,14)rep(j,14) belong[i][j] = -1;\n\t\trep(i,14)rep(j,14) \n\t\t\tc[i][j] = '#';\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tcin >> c[i+1][j+1];\n\t\t\t\tif(c[i+1][j+1] == 'S'){\n\t\t\t\t\tc[i+1][j+1] = '.';\n\t\t\t\t\tsx = j+1 , sy = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tif( c[i][j] == 'X' && belong[i][j] == -1){\n\t\t\t\t\tccc = 0;\n\t\t\t\t\tgrouping(j,i,k);\n\t\t\t\t\tok[k] = ccc / 2;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 1e7;\n\t\tdfs(sx,sy,0,-1,-1);\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint h,w,a[12][12],icesum;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nclass state{\npublic:\n\tint x,y,cost,ice[12*12];\n\tbool f[12][12];\n};\n\nvoid dfs(int y, int x, int c){\n\ta[y][x] = c;\n\ticesum++;\n\tfor(int i=0;i<4;i++){\n\t\tint ay = y + dy[i];\n\t\tint ax = x + dx[i];\n\t\tif(ay >= 0 && ay < h && ax >= 0 && ax < w && a[ay][ax] == -2) dfs(ay,ax,c);\n\t\t   }\n\t}\n\nint main(){\n\twhile(cin >> w >> h && w && h){\n\t\tint ans,maxice[12*12];\n\t\tqueue<state> Q;\n\t\tstate u,v;\n\t\tint gx,gy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\tu.y = i;\n\t\t\t\t\tu.x = j;\n\t\t\t\t} else if(c == 'G'){\n\t\t\t\t\tgy = i;\n\t\t\t\t\tgx = j;\n\t\t\t\t} else if(c == '#') a[i][j] = -1;\n\t\t\t\telse if(c == 'X') a[i][j] = -2;\n\t\t\t}\n\t\t}\n\n\t\tint c = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j] == -2){\n\t\t\t\t\ticesum = 0;\n\t\t\t\t\tdfs(i,j,++c);\n\t\t\t\t\tmaxice[c] = icesum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfill(u.f[0],u.f[12],false);\n\t\tfill(u.ice,u.ice+12*12,0);\n\t\tu.f[u.y][u.x] = true;\n\t\tu.cost = 0;\n\n\t\tfor(Q.push(u); !Q.empty(); Q.pop()){\n\t\t\tu = Q.front();\n\t\t\tif(gy == u.y && gx == u.x){\n\t\t\t\tans = u.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tu.cost++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tv = u;\n\t\t\t\tv.y += dy[i];\n\t\t\t\tv.x += dx[i];\n\t\t\t\tif(v.y >= 0 && v.y < h && v.x >= 0 && v.x < w && a[v.y][v.x] >= 0 && !v.f[v.y][v.x]){\n\t\t\t\t\tv.f[v.y][v.x] = true;\n\t\t\t\t\tif(a[v.y][v.x] > 0){\n\t\t\t\t\t\tv.ice[a[v.y][v.x]]++;\n\t\t\t\t\t\tif(v.ice[a[v.y][v.x]] > maxice[a[v.y][v.x]] / 2) continue;\n\t\t\t\t\t}\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint W, H;\n\nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n\nint maxIce[128];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint sx, sy, gx, gy;\n\nvoid getMin(int ty, int tx, int *ice, int turn)\n{\n\t//printf(\"%d %d %d\\n\", ty, tx, turn);\n\tif (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n\t\treturn;\n\t}\n\t\n\tif (ty == gy && tx == gx){\n\t\tans = turn;\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n\t\t\tif (g[my][mx] == -1){\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (maxIce[g[my][mx]] < ice[g[my][mx]] + 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tice[g[my][mx]]++;\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t\tice[g[my][mx]]--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid label(int ty, int tx, int p)\n{\n\tg[ty][tx] = p;\n\tmaxIce[p]++;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H &&\n\t\t\t\t\tmap[my][mx] == 'X' && g[my][mx] == -1){\n\t\t\tlabel(my, mx, p);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint idx;\n\t\n\twhile (scanf(\"%d %d\", &W, &H) == 2){\n\t\tgetchar();\n\t\t\n\t\tif (W + H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", &map[i]);\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'S'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tsx = j, sy = i;\n\t\t\t\t}\n\t\t\t\tif (map[i][j] == 'G'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tgx = j, gy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tprintf(\"\\n\");\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tprintf(\"%s\\n\", map[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\t//*/\n\t\t\n\t\tmemset(g, -1, sizeof(g));\n\t\tmemset(maxIce, 0, sizeof(maxIce));\n\t\t\n\t\tidx = 0;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'X' && g[i][j] == -1){\n\t\t\t\t\tlabel(i, j, idx);\n\t\t\t\t\tmaxIce[idx++] /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tprintf(\"%2d \", g[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t//*/\n\t\t\n\t\tint use[128];\n\t\t\n\t\tmemset(use, 0, sizeof(use));\n\t\tmemset(v, 0, sizeof(v));\n\t\tv[sy][sx] = true;\n\t\tans = W * H;\n\t\tgetMin(sy, sx, use, 0);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct S{\n  int y,x;\n  vector<int> v;\n  S(int py,int px,vector<int> pv):y(py),x(px),v(pv){\n  }\n  bool operator<(S s)const{\n    if(x!=s.x){\n      return x<s.x;\n    }else if(y!=s.y){\n      return y<s.y;\n    }else{\n      return v<s.v;\n    }\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    vector<int> ni(nid);\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx,vector<int>(nid));\n    set<S> s;\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(!s.insert(e).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\n//int ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n/*\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n*/\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      cnt++;\n      if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1 << 15\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1},\n\tdy[] = {-1,0,1,0};\n\nint X,Y;\nint d[12][12],dd[12][12];\nint IceNum, Ice[144];\nP S,G;\n\nqueue<P> que;\n\nbool check(int NX, int NY)\n{\n\tif(NX >= X || NY >= Y || NX < 0 || NY < 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs(P pos, int now)\n{\n\tif(pos == G){\n\t\tdd[pos.second][pos.first] = min(dd[pos.second][pos.first], now);\n\t\treturn;\n\t}\n\tif(now > dd[pos.second][pos.first])\n\t\treturn;\n\n\tdd[pos.second][pos.first] = now;\n\n\tint nx,ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\tif(check(nx,ny) && d[ny][nx] != -1){\n\t\t\tif(d[ny][nx] > 0){\n\t\t\t\tif(Ice[ d[ny][nx] ] > 0){\n\t\t\t\t\tIce[ d[ny][nx] ]--;\n\t\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t\t\t\tIce[ d[ny][nx] ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t}\n\t}\n\n\n\t\t\n}\nint main(void)\n{\n\twhile(cin >> X >> Y, X > 0 && Y > 0){\n\t\tfill(&dd[0][0],&dd[0][0]+144, INF);\n\t\tfill(&Ice[0],&Ice[0]+144, 0);\n\t\tIceNum = 0;\n\t\tchar s[13];\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor(int j = 0; s[j] != '\\0'; j++){\n\t\t\t\tif(s[j] == '.')\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\telse if(s[j] == '#')\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\telse if(s[j] == 'X')\n\t\t\t\t\td[i][j] = -2;\n\t\t\t\telse if(s[j] == 'S')\n\t\t\t\t\tS = P(j,i),d[i][j] = 0;\n\t\t\t\telse if(s[j] == 'G')\n\t\t\t\t\tG = P(j,i),d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(d[i][j] == -2){\n\t\t\t\t\tIceNum++;\n\t\t\t\t\t\n\t\t\t\t\tque.push(P(j,i));\n\n\t\t\t\t\twhile(que.size()){\n\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\td[p.second][p.first] = IceNum;\n\t\t\t\t\t\tIce[IceNum]++;\n\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\t\t\t\tif(check(nx,ny) && d[ny][nx] == -2){\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++)\n\t\t\t\tprintf(\"%2d\", d[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < 144; i++)\n\t\t\tIce[i] /= 2;\n\n\t\tdfs(S,0);\n\t\tprintf(\"%d\\n\", dd[G.second][G.first]);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[12][13];\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // 氷を踏んだ回数\nvoid dfs(int i,int j,int now){\n\tif(ans<=now) return;\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tif(B[i][j]=='X'){\n\t\tif(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\t\tstep[ice[i][j]]++;\n\t}\n\n\tvis[i][j]=true;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]){\n\t\t\t// これまでに通った道から (y,x) にショートカットして来れる場合は枝刈り\n\t\t\tbool ok=true;\n\t\t\trep(l,4) if((k-l+4)%4!=2) {\n\t\t\t\tint yy=y+dy[l],xx=x+dx[l];\n\t\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && vis[yy][xx]) ok=false;\n\t\t\t}\n\t\t\tif(ok) dfs(y,x,now+1);\n\t\t}\n\t}\n\tvis[i][j]=false;\n\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='S') sx=j, sy=i;\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint p[200];\nint root(int x){\n\tif(p[x] < 0) return x;\n\treturn p[x] = root(p[x]);\n}\nint h, w, dist[200][200];\nint n, sz[200], to[200];\nchar in[12][13];\n\nint main(){\n\twhile(cin >> w >> h, h){\n\t\tint sy, sx, gy, gx;\n\t\trep(i, h * w) p[i] = -1;\n\t\trep(i, 200) rep(j, 200) dist[i][j] = i == j ? 0 : inf;\n\t\t\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t\tif(in[i][j] == 'X') rep(d, 2){\n\t\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\t\tif(ny >= 0 && nx >= 0 && in[ny][nx] == 'X'){\n\t\t\t\t\t\tint a = root(i * w + j), b = root(ny * w + nx);\n\t\t\t\t\t\tif(a != b){\n\t\t\t\t\t\t\tp[a] += p[b];\n\t\t\t\t\t\t\tp[b] = a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tdist[i * w + j][ny * w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tpriority_queue<pair<pi, pair<int, vi> > > q;  //cost*, cost, pos, ice\n\t\tset<pair<int, vi> > s;\n\t\t\n\t\tn = 0;\n\t\tmemset(to, -1, sizeof(to));\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tint r = root(i * w + j);\n\t\t\tif(to[r] < 0){\n\t\t\t\tsz[n] = -p[r];\n\t\t\t\tto[r] = n++;\n\t\t\t}\n\t\t}\n\t\tq.push(mp(mp(-dist[sy * w + sx][gy * w + gx], 0), mp(sy * w + sx, vi(n))));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tvi v = q.top().second.second;\n\t\t\tint cost = q.top().first.second;\n\t\t\tint y = q.top().second.first;\n\t\t\tint x = y % w; y /= w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(y * w + x, v))) continue;\n\t\t\ts.insert(mp(y * w + x, v));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tvi nv = v;\n\t\t\t\t\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tint r = to[root(ny * w + nx)];\n\t\t\t\t\tnv[r]++;\n\t\t\t\t\tif(sz[r] < nv[r] * 2) continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!s.count(mp(ny * w + nx, nv)))\n\t\t\t\tq.push(mp(mp(cost - dist[ny * w + nx][gy * w + gx], cost - 1), \n\t\t\t\t\tmp(ny * w + nx, nv)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = v.size() + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {\n        result += v[i] * digit;\n        digit *= base;\n    }\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 14;\n        if(durability.size()) base = max(base, *max_element(durability.begin(), durability.end()));\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\ntypedef tuple<int, int, vector<int>, int> Vertex;\ntypedef tuple<int, int, vector<int>> Memo;\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint h, w;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nint bfs() {\n    set<Memo> visited;\n    queue<Vertex> q;\n    q.push(Vertex(sy, sx, durability, 0));\n    while(!q.empty()) {\n        int y = get<Y>(q.front());\n        int x = get<X>(q.front());\n        int step = get<STEP>(q.front());\n        vector<int> ice = get<DURABILITY>(q.front());\n        q.pop();\n        if(y == gy && x == gx) return step;\n        if(visited.count(Memo(y, x, ice))) continue;\n        visited.insert(Memo(y, x, ice));\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(Vertex(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(Vertex(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint ic[144];\n\tint visited[12][12];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tqueue<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()){\n\t\t\tr=s.front();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,g,ck[13][13],m[13][13],f[13][13],mn[72],a[72],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nvoid mkda(int x1,int y1,int u) {\n\tint k;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') mkda(x1+dx[k],y1+dy[k],u);\n\t\t}\n\t}\nvoid mkck(int x1,int y1,int u) {\n\tint k;\n\tck[y1][x1]=u;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y) {\n\t\t   if (m[y1+dy[k]][x1+dx[k]]==-1 && ck[y1+dy[k]][x1+dx[k]]>u+1) mkck(x1+dx[k],y1+dy[k],u+1);}\n\t\t}\n   }\n\nint ans(int x1,int y1,int d) {\n\tint k,x2,y2;\n\tif (ck[y1][x1]<d) return 0;\n\tif (d>=an) return 1;\n\tif (x1==gx && y1==gy) { if (an>d) an=d; return 1;}\n\tg=0;\n\tfor (k=0;k<4;k++) {\n\t\tx2=x1+dx[k]; y2=y1+dy[k];\n\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t   if (f[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t   f[y1][x1]=1;\n\t\t\t  if (m[y2][x2]>-1) { \n\t\t\t\t  if (a[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {\n\t\t\t\t\t  a[m[y2][x2]]++;  g=ans(x2,y2,d+1); a[m[y2][x2]]--;\n\t\t\t\t\t  \t  }\n\t\t\t  } else g=ans(x2,y2,d+1);\n\t\t\t  f[y1][x1]=0;\n\t\t\t }\n\t\t}\n\t\tif (g==1) break; \n\t  }\n\treturn 0;\n}\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<72;i++) mn[i]=a[i]=0;\t\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='X') { e=1; k++; mkda(j,i,k);}}\n\tfor (i=0;i<13;i++) for (j=0;j<13;j++) { f[i][j]=0;ck[i][j]=142;}\n\tmkck(sx,sy,0);\n\tan=142; ans(sx,sy,0);\n    cout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t if (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4 ;j++) z+=c[y2+dy[j]][x2+dx[j]];   \n\t\t\t\t\tif (z<2) {\n\t\t\t\t\tfor (j=0;j<4;j++) if (da[y2+dy[i]][x2+dx[i]]!='#' && m[y2+dy[i]][x2+dx[i]]<0 && c[y2+dy[i]][x2+dx[i]]==0)\n\t\t\t\t\t    if (c[y2+dy[i]*2][x2+dx[i]*2]==1) z=2;\n\t\t\t\t\tif (z<2) {\n\t\t\t\t\tif ((x2==gx && y2==gy) || d+1>=an) { if (d+1<an) an=d+1; return 1;}\t    \n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=0;j<=x+1;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      //cnt++;\n      //if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nchar g[20][20];\nint ice[20][20],num[10000],n;\nint dis[20][20],ans;\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nconst int INF = 1000000;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nvoid dfs(int y, int x, int d, int py, int px){\n  if(g[y][x] == '#' || g[y][x] == 'v')return;\n  if(ans <= d + abs(y-gy) + abs(x-gx) )return;\n  if(g[y][x] == 'G'){ans = d; return;}\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(py == ny && px == nx)continue;\n    if(g[ny][nx] == 'v')return;\n  }\n\n  char cur = g[y][x];\n  g[y][x] = 'v';\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    //if(g[ny][nx] == 'v' || g[ny][nx] == '#')continue;\n    if(g[ny][nx] == 'X'){\n      int curg = ice[ny][nx];\n      if(num[curg]>0){\n\tnum[curg]--;\n\tdfs(ny,nx,d+1,y,x);\n\tnum[curg]++;\n      }\n    }else{\n      dfs(ny,nx,d+1,y,x);\n    }\n  }\n  g[y][x] = cur;\n  return;\n}\n    \nint main(){\n  ios_base::sync_with_stdio(false);\n  while(cin >> w >> h){\n    if(w==0 && h==0)break;\n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n\n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X'){\n\tnum[n] = 0;\n\tgroup(i,j,n);\n\tnum[n]/=2;\n\tn++;\n      }\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    ans = INF;\n    dfs(sy,sx,0,-1,-1);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = v.size() + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {result += v[i] * digit; digit *= base;}\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(ny < 1 || h < ny || nx < 1 || w < nx) continue;\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 12 + 1;\n        if(durability.size()) base = max(base, *max_element(durability.begin(), durability.end()) + 1);\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {1,0,-1,0};\nconst int dj[] = {0,1,0,-1};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,int > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(ni,nj));\n  }\n  //random_shuffle(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].first;\n    int nj = v[i].second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        int sy, sx, gy, gx;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        queue<State> que;\n        que.push((State){0,sy,sx,vec(lump_ice_num, 0)});\n        set<string> visited;\n        while(que.size()){\n            State p = que.front(); que.pop();\n            string state_str = state2str(p);\n            if(visited.count(state_str)) continue;\n            visited.insert(state_str);\n            //cout << state_str << endl;\n            if(p.y==gy&&p.x==gx){\n                cout << p.d << endl;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                int ny = p.y + dy[i], nx = p.x + dx[i];\n                vec nice = p.ice;\n                if(ny<0||H<=ny||nx<0||W<=nx)continue;\n                if(ifield[ny][nx]==-2)continue;\n                if(ifield[ny][nx]>=0){\n                    int ice_i = ifield[ny][nx];\n                    if(ice_num[ice_i]/2 < nice[ice_i]+1) continue;\n                    nice[ice_i]++;\n                }\n                State np = (State){p.d+1,ny,nx,nice};\n                string nstr = state2str(np);\n                if(visited.count(nstr)==0){\n                    que.push(np);\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\nint W,H,SX,SY,GX,GY,ice_N;\nint field[14][14],ice[14][14],icelife[1000];\nbool flag[14][14];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid dfs(int x, int y);\nbool iddfs(int x, int y, int c);\nint main(){\n  while(cin >>W>>H,W||H){\n    for(int i=0; i<14; i++){for(int j=0; j<14; j++){field[i][j] = 1;flag[i][j] = true;}}\n    memset(ice,0,sizeof(ice));\n    memset(icelife,0,sizeof(icelife));\n    ice_N = 1;\n    string s;\n    int ans;\n    for(int i=1; i<=H; i++){\n      cin >>s;\n      for(int j=1; j<=W; j++){\n\tif(s[j-1] == '.'){field[j][i] = 0;}\n\tif(s[j-1] == '#'){field[j][i] = 1;}\n\tif(s[j-1] == 'X'){field[j][i] = 2;}\n\tif(s[j-1] == 'S'){field[j][i] = 0;SX = j;SY = i;}\n\tif(s[j-1] == 'G'){field[j][i] = 0;GX = j;GY = i;}\n      }\n    }\n    for(int i=1; i<=W; i++){\n      for(int j=1; j<=H; j++){\n\tif(field[i][j] == 2 && ice[i][j] == 0){\n\t  dfs(i,j);\n\t  icelife[ice_N]/=2;\n\t  ice_N++;\n\t}\n      }\n    }\n    for(ans = 0;;ans++){\n      if(iddfs(SX,SY,ans)){cout <<ans+1<<endl;break;}\n    }\n  }\n  return 0;\n}\nvoid dfs(int x, int y){\n  ice[x][y] = ice_N;\n  icelife[ice_N]++;\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(field[p][q] == 2 && ice[p][q] == 0){dfs(p,q);}\n  }\n}\nbool iddfs(int x, int y, int c){\n  bool f = false;\n  if(x == GX && y == GY){return true;}\n  if(c<0){return false;}\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(flag[p][q]){\n      if(field[p][q] == 0){\n\tflag[p][q] = false;\n\tif(iddfs(p,q,c-1)){f = true;}\n\tflag[p][q] = true;\n      }\n      if(field[p][q] == 2){\n\tif(icelife[ice[p][q]]>0){\n\t  flag[p][q] = false;\n\t  icelife[ice[p][q]]--;\n\t  if(iddfs(p,q,c-1)){f = true;}\n\t  icelife[ice[p][q]]++;\n\t  flag[p][q] = true;\n\t}\n      }\n    }\n  }\n  return f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX_H 12\n#define MAX_W 12\n#define INF (1<<28)\nint h, w;\nint F[MAX_H][MAX_W];\n\nbool dfs_used[MAX_H][MAX_W];\nconst int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\nint dfs(int y, int x, int n) {\n    F[y][x] = n;\n    int cnt = 1;\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 <= ny && ny < h && 0 <= nx && nx < w && !dfs_used[ny][nx] && F[ny][nx] == INF) \n            cnt += dfs(ny, nx, n);\n    }\n    return cnt;\n}\n\nint ice_count[MAX_H*MAX_W];\nint ice_lump_count;\nint dist_from_goal[MAX_H][MAX_W];\nstruct S {\n    int y, x, t;\n    S(int y, int x, int t) : y(y), x(x), t(t) {}\n};\n\nint sy, sx, gy, gx;\nvoid init() {\n    memset(dfs_used, 0, sizeof(dfs_used));\n    memset(ice_count, 0, sizeof(ice_count));\n    memset(dist_from_goal, -1, sizeof(dist_from_goal));\n    int n = 1;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (F[i][j] == INF) {\n                ice_count[n] = dfs(i, j, n);\n                n++;\n            }\n        }\n    }\n    ice_lump_count = n;\n\n    // 各タイルに対しbfsで氷を考慮しない場合のゴールまでの最短距離を求める.\n    queue<S> q;\n    q.push(S(gy, gx, 0));\n    dist_from_goal[gy][gx] = 0;\n    while (!q.empty()) {\n        S p = q.front(); q.pop();\n        for (int i = 0; i < 4; i++) {\n            int ny = p.y + dy[i], nx = p.x + dx[i];\n            if (0 <= ny && ny < h && 0 <= nx && nx < w &&\n                    dist_from_goal[ny][nx] < 0 && F[ny][nx] >= 0) {\n                dist_from_goal[ny][nx] = p.t+1;\n                q.push(S(ny, nx, p.t+1));\n            }\n        }\n    }\n}\n\nbool dls_used[MAX_H][MAX_W];\nbool __used[MAX_H][MAX_W];\nint count_used_ice(int y, int x) {\n    int cnt = (dls_used[y][x] ? 1 : 0);\n    //if (cnt == 1) cout << \"count_used_ice: \" << y << ',' << x << endl;\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (0 <= ny && ny < h && 0 <= nx && nx < w && !__used[ny][nx] && F[ny][nx] == F[y][x]) {\n            __used[ny][nx] = true;\n            cnt += count_used_ice(ny, nx);\n        }\n    }\n    return cnt;\n}\n\nbool ice_break(int y, int x) {\n    memset(__used, 0, sizeof(__used));\n    __used[y][x] = true;\n    int c = count_used_ice(y, x);\n    //cout << \"icebreak: \" << c << endl;\n    return c * 2 > ice_count[F[y][x]];\n}\n\nbool dls(int y, int x, int depth) {\n    //cout << y << ',' << x << ',' << depth << endl;\n    if (depth == 0) \n        return y == gy && x == gx;\n    if (dist_from_goal[y][x] > depth) \n        return false;\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (0 <= ny && ny < h && 0 <= nx && nx < w\n                && !dls_used[ny][nx] && F[ny][nx] >= 0) {\n            dls_used[ny][nx] = true;\n            if (F[ny][nx] > 0) \n                if (ice_break(ny, nx)) {\n                    dls_used[ny][nx] = false;\n                    continue;\n                }\n            if (dls(ny, nx, depth-1)) {\n                //cout << endl;\n                //for (int k = 0; k < h; k++) {\n                //    for (int l = 0; l < w; l++)\n                //        cout << dls_used[k][l] << ' ';\n                //    cout << endl;\n                //}\n                dls_used[ny][nx] = false;\n                return true;\n            }\n            dls_used[ny][nx] = false;\n        }\n    }\n    return false;\n}\n\nint iddfs() {\n    int depth = 0;\n    int y = sy, x = sx;\n    while (true) {\n        memset(dls_used, 0, sizeof(dls_used));\n        dls_used[y][x] = true;\n        if (dls(y, x, depth)) return depth;\n        depth++;\n    }\n}\n\nvoid debug() {\n    printf(\"Ice lump count: %d\\n\", ice_lump_count);\n    printf(\"Ice count: %d\\n\\t\", ice_lump_count);\n    for (int i = 0; i < ice_lump_count; i++) \n        printf(\"%3d \", ice_count[i]);\n    printf(\"\\n\");\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            printf(\"%4d \", F[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            printf(\"%4d \", dist_from_goal[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    while (cin >> w >> h, w || h) {\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char t; cin >> t;\n                switch (t) {\n                    case 'S':\n                        sy = i, sx = j;\n                        F[i][j] = 0;\n                        break;\n                    case 'G':\n                        gy = i, gx = j;\n                        F[i][j] = 0;\n                        break;\n                    case '.': \n                        F[i][j] = 0;\n                        break;\n                    case '#':\n                        F[i][j] = -1;\n                        break;\n                    case 'X':\n                        F[i][j] = INF;\n                        break;\n                }\n            }\n        }\n        init();\n        //debug();\n        cout << iddfs() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nconst int wall = -1;\nconst int tile = -2;\nconst int ice = -3;\nconst int INF = 1e8;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\nint W,H;\nint data[12][12];\n\nP s,g;\nvector<int>mv;\n\nclass State{\npublic:\n   int vis[12][12];\n   vector<int> v;\n   P p;\n   void set(vector<int> _v,P _p){\n      for(int i = 0 ; i < H ; i++){\n         for(int j = 0 ; j < W ; j++){\n            vis[i][j] = INF;\n         }\n      }\n      v = _v;\n      p = _p;\n   }\n\n};\n\ntypedef pair<int,State>PP;\n\nvoid display(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == wall)cout << '#';\n         else if(data[i][j] == tile)cout << '.';\n         else cout << data[i][j];\n      }\n      cout << endl;\n   }\n}\n\nvoid input(){\n   for(int i = 0 ; i < H ;i++){\n      for(int j = 0 ;j  < W ; j++){\n         char c;\n         cin >> c;\n         if(c == '#')data[i][j] = wall;\n         else if(c == 'X')data[i][j] = ice;\n         else {\n            if(c == 'S')s = P(i,j);\n            else if(c == 'G')g = P(i,j);\n            data[i][j] = tile;\n         }\n      }\n   }\n}\n\nbool check(P p){\n   int y,x;\n   y = p.first;\n   x = p.second;\n   if(!(0 <= x && x < W ))return false;\n   if(!(0 <= y && y < H ))return false;\n   return true;\n}\n\nvoid ice_bfs(P s,int &mark){\n   queue<P>que;\n   int cnt = 1;\n   que.push(s);\n   data[s.first][s.second] = mark;\n   while(que.size()){\n      P p = que.front(); que.pop();\n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         if(data[np.first][np.second] != ice)continue;\n         data[np.first][np.second] = mark;\n         cnt++;\n         que.push(np);\n      }\n   }\n   mv.push_back(cnt);\n   mark++;\n}\n\n/*\nvoid dfs(){\n   queue<PP>que;\n   \n   State state;\n   state.set(mv,s);\n\n   que.push(PP(0,state));\n\n   while(que.size()){\n      PP pp = que.front(); que.pop();\n      \n      int cnt = pp.first;\n      state = pp.second;\n      P p = state.p;\n\n      if(p == g){\n         cout << cnt << endl;\n         return;\n      }\n      \n      for(int i = 0 ; i < 4 ; i++){\n         P np = P(p.first + dy[i],p.second + dx[i]);\n         if(!check(np))continue;\n         \n         int here = data[np.first][np.second];\n         if(here == wall)continue;\n         if(state.vis[np.first][np.second] < cnt)continue;\n\n         state.p = np;\n\n         int tmp =  state.vis[np.first][np.second];\n\n         if(here >= 0){\n\n            if(state.v[here] <= mv[here]/2)continue;\n            if(mv[here] == 1)continue;\n\n            state.v[here]--;\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.v[here]++;\n            state.vis[np.first][np.second] = tmp;\n         }\n         else{\n            state.vis[np.first][np.second] = cnt;\n            que.push(PP(cnt+1,state));\n            state.vis[np.first][np.second] = tmp;\n         }\n\n         state.p = p;\n\n      }\n   }\n}\n*/\n\nbool dfs(PP pp,int lim){\n\n   int cnt = pp.first;\n   if(cnt > lim)return false;\n\n   State state = pp.second;\n   P p = state.p;\n   \n   if(p == g){\n      cout << cnt << endl;\n      return true;\n   }\n   \n   for(int i = 0 ; i < 4 ; i++){\n      P np = P(p.first + dy[i],p.second + dx[i]);\n      if(!check(np))continue;\n      \n      int here = data[np.first][np.second];\n      if(here == wall)continue;\n      if(state.vis[np.first][np.second] < cnt)continue;\n\n      state.p = np;\n\n      int tmp =  state.vis[np.first][np.second];\n      \n      if(here >= 0){\n\n         if(state.v[here] <= mv[here]/2)continue;\n         if(mv[here] == 1)continue;\n         \n         state.v[here]--;\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.v[here]++;\n         state.vis[np.first][np.second] = tmp;\n      }\n      else{\n         state.vis[np.first][np.second] = cnt;\n         if(dfs(PP(cnt+1,state),lim))return true;\n         state.vis[np.first][np.second] = tmp;\n      }\n      state.p = p;\n   }\n   return false;\n}\n\n\n\n\nvoid solve(){\n   input();\n   int mark = 0;\n   mv.clear();\n\n   for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n         if(data[i][j] == ice)ice_bfs(P(i,j),mark);\n      }\n   }\n   \n   //cout << \"s = \" << s.first << ' ' << s.second << endl;\n   //cout << \"g = \" << g.first << ' ' << s.second << endl;//\n   //bfs();\n   \n   //State state;\n   //state.set(mv,s);\n      \n   for(int i = 1 ; ; i++){\n      State state;\n      state.set(mv,s);\n      if(dfs(PP(0,state),i))break;\n   }\n}\n\nint main(){\n   while(1){\n      cin >> W >> H;\n      //cout << \"W = \" << W << \" H = \" << H << endl;//\n      if(!W && !H)break;\n      solve();\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int previ, int prevj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni == previ && nj == prevj) continue;\n    if(vis[ni][nj]) return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(fromG[ni][nj], make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, pi, pj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          if(cnt[N] == 0) {\n            ice[i][j] = -1;\n            G[i][j] = '#';\n          } else {\n            ++N;\n          }\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, -1, -1, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1 << 15\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1},\n\tdy[] = {-1,0,1,0};\n\nint X,Y;\nint d[12][12],dd[12][12];\nint IceNum, Ice[144];\nP S,G;\n\nqueue<P> que;\n\nbool check(int NX, int NY)\n{\n\tif(NX >= X || NY >= Y || NX < 0 || NY < 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs(P pos, int now)\n{\n\tif(pos == G){\n\t\tdd[pos.second][pos.first] = min(dd[pos.second][pos.first], now);\n\t\treturn;\n\t}\n\tif(now > dd[pos.second][pos.first])\n\t\treturn;\n\n\tdd[pos.second][pos.first] = now;\n\n\tint nx,ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\tif(check(nx,ny) && d[ny][nx] != -1){\n\t\t\tif(d[ny][nx] > 0){\n\t\t\t\tif(Ice[ d[ny][nx] ] > 0){\n\t\t\t\t\tIce[ d[ny][nx] ]--;\n\t\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t\t\t\tIce[ d[ny][nx] ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t}\n\t}\n\n\n\t\t\n}\nint main(void)\n{\n\twhile(cin >> X >> Y, X > 0 && Y > 0){\n\t\tfill(&dd[0][0],&dd[0][0]+144, INF);\n\t\tfill(&Ice[0],&Ice[0]+144, 0);\n\t\tIceNum = 0;\n\t\tchar s[13];\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor(int j = 0; s[j] != '\\0'; j++){\n\t\t\t\tif(s[j] == '.')\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\telse if(s[j] == '#')\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\telse if(s[j] == 'X')\n\t\t\t\t\td[i][j] = -2;\n\t\t\t\telse if(s[j] == 'S')\n\t\t\t\t\tS = P(j,i),d[i][j] = 0;\n\t\t\t\telse if(s[j] == 'G')\n\t\t\t\t\tG = P(j,i),d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(d[i][j] == -2){\n\t\t\t\t\tIceNum++;\n\t\t\t\t\t\n\t\t\t\t\tque.push(P(j,i));\n\n\t\t\t\t\twhile(que.size()){\n\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\td[p.second][p.first] = IceNum;\n\t\t\t\t\t\tIce[IceNum]++;\n\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\t\t\t\tif(check(nx,ny) && d[ny][nx] == -2){\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++)\n\t\t\t\tprintf(\"%2d\", d[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < 144; i++)\n\t\t\tIce[i] /= 2;\n\n\t\tdfs(S,0);\n\t\tprintf(\"%d\\n\", dd[G.second][G.first]);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n#define sinf (30000)\n#define cinf (254)\n\nusing namespace std;\n\ntypedef unsigned short us;\ntypedef unsigned char uc;\n\nstruct Pox\n{\n  vector<uc> array;\n  us cost;\n  us prev;\n  Pox(vector<uc> array=vector<uc>(),us cost=cinf,us prev=cinf):array(array),cost(cost),prev(prev){}\n};\n\nuc dx[] = {1,0,-1,0};\nuc dy[] = {0,-1,0,1};\nuc max_ans;\nuc ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nus st[2],h,w,ice_number;\nint ice[MAX*MAX];\nuc ice_cnt[MAX*MAX];\nset<vector<uc> > mincost;\ndeque<Pox> Q;\n\n\n\nvoid init()\n{\n  max_ans = 0;\n  ice_number = 0;\n  rep(i,h)rep(j,w)\n    {\n      ice[j+i*w] = inf;\n      ice_cnt[j+i*w] = cinf;\n    }\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<us> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  uc cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      uc nx = cur % w + dx[i];\n\t      uc ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(uc cur,uc id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      uc nx = cur % w + dx[i];\n      uc ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(us depth)\n{\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      \n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)\n\t{\n\t  continue;\n\t}\n      \n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n      \n\n      rep(i,4)\n\t{\n\t  if(pox.prev != -1 && pox.prev == (i+2)%4)continue;\n\t  uc nx = pox.array[ice_number] % w + dx[i];\n\t  uc ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<uc> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1,i));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1,i));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(cin >> w >> h,w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n\n      vector<uc> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0,-1));\n      mincost.insert(initial_array);\n      us depth = 0;\n      while(!compute(depth++))\n\t{\n\t  mincost.clear();\n\t}\n      while(!Q.empty())Q.pop_back();\n      mincost.clear();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n \nchar c[14][14];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n \nint belong[14][14];\nint ok[10000];\nint gx,gy;\n \nint ans = 0;\nint ccc = 0;\nint dfs(int x,int y,int C,int px,int py){\n    if( c[y][x] == '#' || c[y][x] == '*') return 0;\n    if( C + abs(x-gx) + abs(y-gy) >= ans ) return 0;\n    if( c[y][x] == 'G'){\n        ans = C;\n        return 0;\n    }\n    for(int i = 0 ; i < 4 ; i++){\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if( px == tx && ty == py ) continue;\n        if( c[ty][tx] == '*' ) return 0;\n    }\n    char cur = c[y][x];\n    c[y][x] = '*';\n    for(int i = 0 ; i < 4 ; i++){\n        int tx = x + dx[i];\n        int ty = y + dy[i];\n        if( c[ty][tx] == 'X' ){\n            int b = belong[ty][tx];\n            if( ok[b] > 0 ){\n                ok[b]--;\n                dfs(tx,ty,C+1,x,y);\n                ok[b]++;\n            }\n        }else{\n            dfs(tx,ty,C+1,x,y);\n        }\n    }\n    c[y][x] = cur;\n    return 0;\n}\nint grouping(int x,int y,int k){\n    if( c[y][x] != 'X') return 0;\n    if( belong[y][x] != -1 ) return 0;\n    belong[y][x] = k;\n    ccc++;\n    for(int i = 0 ; i < 4 ; i++)\n        grouping(x+dx[i],y+dy[i],k);\n}\n \nint main(){\n    ios_base::sync_with_stdio(false);\n    int W,H;\n    while(cin >> W >> H && W){\n        rep(i,14)rep(j,14) belong[i][j] = -1;\n        rep(i,14)rep(j,14) \n            c[i][j] = '#';\n        int sx , sy;\n        for(int i = 0 ; i < H ; i++){\n            for(int j = 0 ; j < W ; j++){\n                cin >> c[i+1][j+1];\n                if(c[i+1][j+1] == 'S'){\n                    c[i+1][j+1] = '.';\n                    sx = j+1 , sy = i+1;\n                }else if(c[i+1][j+1] == 'G' ){\n                    gx = j+1 , gy = i+1;\n                }\n            }\n        }\n        int k = 0;\n        for(int i = 1 ; i <= H ; i++){\n            for(int j = 1 ; j <= W ; j++){\n                if( c[i][j] == 'X' && belong[i][j] == -1){\n                    ccc = 0;\n                    grouping(j,i,k);\n                    ok[k] = ccc / 2;\n                    k++;\n                }\n            }\n        }\n        ans = 1e7;\n        dfs(sx,sy,0,-1,-1);\n        cout << ans << endl;\n         \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum {FLOOR = -3, WALL, ICE};\nenum {Y, X, DURABILITY, STEP};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\ntypedef tuple<int, int, vector<int>, int> Vertex;\n\nint h, w;\nint base;\nvector<vector<int>> field;\nvector<int> durability;\nint sy, sx, gy, gx;\n\nint flood_fill(int y, int x, int id) {\n    int result = 1;\n    field[y][x] = id;\n    for(const auto& d: NEXT) {\n        int ny = y + d[Y];\n        int nx = x + d[X];\n        if(field[ny][nx] != ICE) continue;\n        result += flood_fill(ny, nx, id);\n    }\n    return result;\n}\n\nunsigned long long encode(int y, int x, const vector<int>& v, int step) {\n    unsigned long long result = v.size() + y * base + x * base * base;\n    unsigned long long digit = base * base * base;\n    for(int i = 0; i < v.size(); ++i) {\n        result += v[i] * digit;\n        digit *= base;\n    }\n    return result + step * digit;\n}\n\nVertex decode(unsigned long long n) {\n    int y, x, size;\n    vector<int> v;\n    size = n % base; n /= base;\n    y = n % base; n /= base;\n    x = n % base; n /= base;\n    for(int i = 0; i < size; ++i) {v.push_back(n % base); n /= base;}\n    return Vertex(y, x, v, n);\n}\n\nint bfs() {\n    set<unsigned long long> visited;\n    queue<unsigned long long> q;\n    q.push(encode(sy, sx, durability, 0));\n\n    while(!q.empty()) {\n        Vertex v = decode(q.front());\n        q.pop();\n        int y = get<Y>(v);\n        int x = get<X>(v);\n        int step = get<STEP>(v);\n        vector<int> ice = get<DURABILITY>(v);\n\n        if(y == gy && x == gx) return step;\n        unsigned long long memo = encode(y, x, ice, 0);\n        if(visited.count(memo)) continue;\n        visited.insert(memo);\n\n        for(const auto& d: NEXT) {\n            int ny = y + d[Y];\n            int nx = x + d[X];\n            if(field[ny][nx] == WALL) continue;\n            if(field[ny][nx] == FLOOR) {\n                q.push(encode(ny, nx, ice, step + 1));\n            } else {\n                if(ice[field[ny][nx]] <= 0) continue;\n                --ice[field[ny][nx]];\n                q.push(encode(ny, nx, ice, step + 1));\n                ++ice[field[ny][nx]];\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while(cin >> w >> h, w | h) {\n        field = vector<vector<int>>(h + 2, vector<int>(w + 2, WALL));\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) {\n            char c;\n            cin >> c;\n            if(c == '#') field[i][j] = WALL;\n            else if(c == 'X') field[i][j] = ICE;\n            else {\n                field[i][j] = FLOOR;\n                if(c == 'S') {sy = i; sx = j;}\n                if(c == 'G') {gy = i; gx = j;}\n            }\n        }\n\n        durability.clear();\n        for(int i = 1; i <= h; ++i) for(int j = 1; j <= w; ++j) if(field[i][j] == ICE) durability.push_back(flood_fill(i, j, durability.size()) / 2);\n\n        base = 12;\n        if(durability.size()) base = max(base, *max_element(durability.begin(), durability.end()));\n\n        cout << bfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>      \nusing namespace std;      \nconst int INF = 1 << 30;      \n      \nint W, H;      \nchar mas[20][20];      \nint sy, sx, gy, gx;      \nint cnt;      \nint snow[144];      \nint number[20][20];      \nbool used[20][20];      \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};      \nint ans;      \n      \nint dfs( int x, int y, const int& idx){      \n  if(x < 0 || x >= W || y < 0 || y >= H) return 0;      \n  if(mas[y][x] != 'X') return 0;      \n  if(number[y][x] != -1) return 0;      \n  number[y][x] = idx;      \n  int ret = 1;      \n  for(int i = 0; i < 4; i++){      \n    ret += dfs( x + dx[i], y + dy[i], idx);      \n  }      \n  return ret;      \n}      \nvoid dfs2( int x, int y, int cost,int prevx, int prevy){      \n  if(ans <= cost + abs( y - gy) + abs( x - gx)) return;      \n  if(y == gy && x == gx){      \n    ans = cost;    \n    return;      \n  }      \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n    if(used[ny][nx] && ny != prevy && nx != prevx) return;\n  }\n\n  \n\n  for(int i = 0; i < 4; i++){      \n    int ny = y + dy[i], nx = x + dx[i];      \n    if(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;      \n    if(mas[ny][nx] == '#' || used[ny][nx]) continue;      \n    if(mas[ny][nx] == 'X'){      \n      if(snow[number[ny][nx]] > 0) snow[number[ny][nx]]--;      \n      else continue;      \n    }      \n    used[ny][nx] = true;      \n    dfs2( nx, ny, cost + 1, x, y);      \n    used[ny][nx] = false;      \n    if(mas[ny][nx] == 'X') snow[number[ny][nx]]++;      \n  }      \n  return;      \n}      \n      \nint main(){      \n  ios_base::sync_with_stdio(false);\n  while(cin >> W >> H, W){      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        cin >> mas[i][j];      \n        if(mas[i][j] == 'S' || mas[i][j] == 'G'){      \n          if(mas[i][j] == 'S') sy = i, sx = j;      \n          else gy = i, gx = j;      \n          mas[i][j] = '.';      \n        }      \n      }      \n    }      \n    cnt = 0;      \n    memset( number, -1, sizeof number);      \n    for(int i = 0; i < H; i++){      \n      for(int j = 0; j < W; j++){      \n        if(mas[i][j] == 'X' && number[i][j] == -1){      \n          snow[cnt] = dfs( j, i, cnt) / 2;      \n          cnt++;      \n        }      \n      }      \n    }      \n    ans = INF;      \n    used[sy][sx] = true;      \n    dfs2(sx,sy,0,-1,-1);\n    used[sy][sx] = false;\n    cout << ans << endl;      \n  }      \n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w,h,sy,sx,gy,gx;\nstring g[20];\nvector<int> cnt;\nint ice[20][20],num[200],n;\nbool vis[20][20];\nint dis[20][20];\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nmap<vector<int>,int> memo;\nint ans;\nconst int INF = 200;\n\nvoid group(int y, int x, int c){\n  num[c]++;\n  ice[y][x] = c;\n\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(ice[ny][nx]<0 && g[ny][nx] == 'X')group(ny,nx,c);\n  }\n}\n\nint dfs(int y, int x, int d){\n  if(ans<=d + dis[y][x])return INF;\n  if(g[y][x] == 'G'){ans = min(ans,d); return 0;}\n  if(memo.find(cnt)!=memo.end()){ans = min(ans,d + memo[cnt]); return memo[cnt];}\n  \n  vis[y][x] = true;\n\n  int res = INF;\n  rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(vis[ny][nx] || g[ny][nx] == '#')continue;\n    if(ice[ny][nx]>=0){\n      int curg = ice[ny][nx];\n      cnt[curg]++; cnt[n] = ny; cnt[n+1] = nx;\n      if(cnt[curg]*2 <= num[curg])res = min(res,dfs(ny,nx,d+1)+1);\n      cnt[curg]--;\n    }else{\n      cnt[n] = ny; cnt[n+1] = nx;\n      res = min(res,dfs(ny,nx,d+1)+1);\n    }\n  }\n  vis[y][x] = false;\n  cnt[n] = y; cnt[n+1] = x;\n\n  if(res<INF)memo[cnt] = res;\n  return res;\n}\n    \nint main(){\n  while(cin >> w >> h,w){\n    rep(i,h)cin >> g[i];\n    \n    n = 0;\n    memset(ice,-1,sizeof(ice));\n    memset(num,0,sizeof(num));\n    \n    rep(i,h)rep(j,w){\n      if(ice[i][j]<0 && g[i][j] == 'X')group(i,j,n++);\n      if(g[i][j] == 'S')sy = i, sx = j;\n      if(g[i][j] == 'G')gy = i, gx = j;\n    }\n\n    memset(dis,-1,sizeof(dis));\n    dis[gy][gx] = 0;\n    queue<P> q;\n    q.push(P(gy,gx));\n \n    while(q.size()){\n      P p = q.front(); q.pop();\n      int y = p.first, x = p.second;\n      rep(i,4){\n\tint ny = y + dy[i], nx = x + dx[i];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\tif(dis[ny][nx]<0){\n\t  dis[ny][nx] = dis[y][x] + 1;\n\t  q.push(P(ny,nx));\n\t}\n      }\n    }\n\n    //rep(i,h){rep(j,w)cout << dis[i][j] << \" \";cout << endl;}\n\n    cnt = vector<int>(n+2,0); cnt[n] = sy; cnt[n+1] = sx;\n    memset(vis,0,sizeof(vis));\n    memo.clear();\n    ans = INF;\n    dfs(sy,sx,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,m[13][13],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nstruct wd {\n\tint x,y,t,h;\n\tint c[36];\n\tint d[12];\n };\n\nwd w,w2;\nqueue<wd> qu; \n \nint bfs() {\n\tint k,x2,y2;\n\twhile(true) {\n\t\tw=qu.front(); qu.pop();\n\t\tw.d[w.y]|=1 << w.x;\n\t\tif (w.h==0) da[w.y][w.x]='#';\n\t\tfor (k=0;k<4;k++) {\n\t\t\tw2=w;\n\t\t\tx2=w2.x+dx[k]; y2=w2.y+dy[k]; w2.t++;\n\t\t\tif (x2==gx && y2==gy) return w2.t;\n\t\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\t\tif ((w2.d[y2] & (1 << x2)) == 0 && da[y2][x2]!='#') {\n\t\t\t\t\tw2.x=x2; w2.y=y2;\n\t\t\t\t\tif (m[y2][x2]==-1) qu.push(w2); else {\n\t\t\t\t\t\tif  (w.c[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {w2.c[m[y2][x2]]++; w2.h=1; qu.push(w2);}}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}\t \nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\twhile(!qu.empty()) qu.pop();\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) w.d[i]=0; for (i=0;i<36;i++) w.c[i]=0;\n\tfor (i=0;i<y;i++) for (j=0;j<x;j++) if (da[i][j]=='#') w.d[i]|=1 << j;\n\tw.x=sx; w.y=sy; w.t=0; w.h=0;\n\tqu.push(w);\n\tan=bfs();\n\tcout << an << endl;\n     }  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif ((x1==gx && y1==gy) || d>=an) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4;j++) {z+=c[y2+dy[j]][x2+dx[j]];   \n\t\t\t\t\tif (da[y2+dy[i]][x2+dx[i]]!='#' && m[y2+dy[i]][x2+dx[i]]<0 && c[y2+dy[i]][x2+dx[i]]==0)\n\t\t\t\t\t    if (c[y2+dy[i]*2][x2+dx[i]*2]==1) z=2;}\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=0;j<=x+1;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1 << 15\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1},\n\tdy[] = {-1,0,1,0};\n\nint X,Y;\nint d[12][12],dd[12][12];\nint IceNum, Ice[144];\nP S,G;\n\nqueue<P> que;\n\nbool check(int NX, int NY)\n{\n\tif(NX >= X || NY >= Y || NX < 0 || NY < 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs(P pos, int now)\n{\n\tif(pos == G){\n\t\tdd[pos.second][pos.first] = min(dd[pos.second][pos.first], now);\n\t\treturn;\n\t}\n\tif(now > dd[pos.second][pos.first])\n\t\treturn;\n\n\tdd[pos.second][pos.first] = now;\n\n\tint nx,ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\tif(check(nx,ny) && d[ny][nx] != -1){\n\t\t\tif(d[ny][nx] > 0){\n\t\t\t\tif(Ice[ d[ny][nx] ] > 0){\n\t\t\t\t\tIce[ d[ny][nx] ]--;\n\t\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t\t\t\tIce[ d[ny][nx] ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t}\n\t}\n\n\n\t\t\n}\nint main(void)\n{\n\twhile(cin >> X >> Y, X){\n\t\tfill(&dd[0][0],&dd[0][0]+144, INF);\n\t\tfill(&Ice[0],&Ice[0]+144, 0);\n\t\tIceNum = 0;\n\t\tchar s[13];\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor(int j = 0; s[j] != '\\0'; j++){\n\t\t\t\tif(s[j] == '.')\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\telse if(s[j] == '#')\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\telse if(s[j] == 'X')\n\t\t\t\t\td[i][j] = -2;\n\t\t\t\telse if(s[j] == 'S')\n\t\t\t\t\tS = P(j,i),d[i][j] = 0;\n\t\t\t\telse if(s[j] == 'G')\n\t\t\t\t\tG = P(j,i),d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(d[i][j] == -2){\n\t\t\t\t\tIceNum++;\n\t\t\t\t\t\n\t\t\t\t\tque.push(P(j,i));\n\n\t\t\t\t\twhile(que.size()){\n\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\td[p.second][p.first] = IceNum;\n\t\t\t\t\t\tIce[IceNum]++;\n\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\t\t\t\tif(check(nx,ny) && d[ny][nx] == -2){\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++)\n\t\t\t\tprintf(\"%2d\", d[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(int i = 0; i < 144; i++)\n\t\t\tIce[i] /= 2;\n\n\t\tdfs(S,0);\n\t\tprintf(\"      %d\\n\", dd[G.second][G.first]);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstatic const int INF=(1<<21);\nint c=0;\nvoid katamari(int,int);\nchar map[14][14];\nqueue<pair<int,int> > q; \nstruct r{\n\tint x;\n\tint y;\n\tint cnt;\n\tint icec[144];\n\tbool used[12][12];\n};\nr s,v;\nqueue<r> f;\nint maps[12][12],icem[144],x,y,k,h;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint main()\n{\n\tint i,j;\n\twhile(1){\n\t\tc=0;\n\t\twhile(!q.empty()){\n\t\t\tq.pop();\n\t\t}\n\t\tmemset(icem,0,sizeof(icem));\n\t\tmemset(map,'#',sizeof(map));\n\t\tcin>>x>>y;\n\t\tif(x==0&&y==0)break;\n\t\tfor(i=0;i<y;i++){\n\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tmaps[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==INF){\n\t\t\t\t\tq.push(make_pair(i,j) );\n\t\t\t\t\tmaps[i][j] = c;\n\t\t\t\t\tkatamari(j,i);\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\telse if(map[i][j] == 'S'){\n\t\t\t\t\ts.y = i;\n\t\t\t\t\ts.x = j;\n\t\t\t\t\ts.cnt = 0;\n\t\t\t\t\tfor(k=0;k<144;k++){\n\t\t\t\t\t\ts.icec[k]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.used[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<y;i++){\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tif(maps[i][j]!=INF){\n\t\t\t\t\ticem[maps[i][j]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf.push(s);\n\t\twhile(!f.empty()){\n\t\t\ts = f.front();\n\t\t\tf.pop();\n\t\t\tif(s.used[s.y][s.x]==false){\n\t\t\t\ts.used[s.y][s.x]=true;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF){\n\t\t\t\ts.icec[maps[s.y][s.x]]++;\n\t\t\t}\n\t\t\tif(maps[s.y][s.x]!=INF&&s.icec[maps[s.y][s.x]]>icem[maps[s.y][s.x]]/2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[s.y][s.x]=='G'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(j=0;j<c;j++){\n\t\t\t\tv.icec[j]=s.icec[j];\n\t\t\t}\n\t\t\tfor(j=0;j<y;j++){\n\t\t\t\tfor(k=0;k<x;k++){\n\t\t\t\t\tv.used[j][k]=s.used[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tif(s.x+dx[i]>=0&&s.x+dx[i]<x&&s.y+dy[i]>=0&&s.y+dy[i]<y&&map[s.y+dy[i]][s.x+dx[i]]!='#'&&s.used[s.y+dy[i]][s.x+dx[i]]==false){\n\t\t\t\t\t\n\t\t\t\t\tv.x=s.x+dx[i];\n\t\t\t\t\tv.y=s.y+dy[i];\n\t\t\t\t\tv.cnt=s.cnt+1;\n\t\t\t\t\tf.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<s.cnt<<endl;\n\t}\n\treturn 0;\n}\nvoid katamari(int x,int y){\n\twhile(!q.empty()){\n\t\tpair<int,int> p = q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(map[p.first + dx[i]][p.second + dy[i]] == 'X'&&maps[p.first + dx[i]][p.second + dy[i]]==INF){\n\t\t\t\tmaps[p.first + dx[i]][p.second + dy[i]] = c;\n\t\t\t\tq.push(make_pair(p.first + dx[i],p.second + dy[i]));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144,gx,gy;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tint f[12][12];\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='G'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.x=gx;\n\t\tv.y=gy;\n\t\t\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[gy][gx]=0;\n\t\tq.push(v);\n\t\twhile(!q.empty()){\n\t\t\tv=q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(map[u.y][u.x]!='#'&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly&&f[u.y][u.x]==-1){\n\t\t\t\t\tq.push(u);\n\t\t\t\t\tf[u.y][u.x]=f[v.y][v.x]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt+f[r.y][r.x]>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nint h,w,a[12][12],icesum;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nclass state{\npublic:\n\tint x,y,cost,ice[12*12];\n\tbool f[12][12];\n};\n\nvoid dfs(int y, int x, int c){\n\ta[y][x] = c;\n\ticesum++;\n\tfor(int i=0;i<4;i++){\n\t\tint ay = y + dy[i];\n\t\tint ax = x + dx[i];\n\t\tif(ay >= 0 && ay < h && ax >= 0 && ax < w && a[ay][ax] == -2) dfs(ay,ax,c);\n\t\t   }\n\t}\n\nint main(){\n\twhile(cin >> w >> h && w && h){\n\t\tint ans,maxice[12*12];\n\t\tqueue<state> Q;\n\t\tstate u,v;\n\t\tint gx,gy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tif(c == 'S'){\n\t\t\t\t\tu.y = i;\n\t\t\t\t\tu.x = j;\n\t\t\t\t} else if(c == 'G'){\n\t\t\t\t\tgy = i;\n\t\t\t\t\tgx = j;\n\t\t\t\t} else if(c == '#') a[i][j] = -1;\n\t\t\t\telse if(c == 'X') a[i][j] = -2;\n\t\t\t}\n\t\t}\n\n\t\tint c = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j] == -2){\n\t\t\t\t\ticesum = 0;\n\t\t\t\t\tdfs(i,j,++c);\n\t\t\t\t\tmaxice[c] = icesum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfill(u.f[0],u.f[12],false);\n\t\tfill(u.ice,u.ice+12*12,0);\n\t\tu.f[u.y][u.x] = true;\n\t\tu.cost = 0;\n\n\t\tfor(Q.push(u); !Q.empty(); Q.pop()){\n\t\t\tu = Q.front();\n\t\t\tif(gy == u.y && gx == u.x){\n\t\t\t\tans = u.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tu.cost++;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tv = u;\n\t\t\t\tv.y += dy[i];\n\t\t\t\tv.x += dx[i];\n\t\t\t\tif(v.y >= 0 && v.y < h && v.x >= 0 && v.x < w && a[v.y][v.x] >= 0 && !v.f[v.y][v.x]){\n\t\t\t\t\tv.f[v.y][v.x] = true;\n\t\t\t\t\tif(a[v.y][v.x] > 0){\n\t\t\t\t\t\tv.ice[a[v.y][v.x]]++;\n\t\t\t\t\t\tif(v.ice[a[v.y][v.x]] > maxice[a[v.y][v.x]] / 2) continue;\n\t\t\t\t\t}\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint p[200];\nint root(int x){\n\tif(p[x] < 0) return x;\n\treturn p[x] = root(p[x]);\n}\nint h, w, dist[200][200];\nint n, sz[200], to[200];\nchar in[12][13];\n\nset<pair<int, vi> > s;\n\nint main(){\n\twhile(cin >> w >> h, h){\n\t\tint sy, sx, gy, gx;\n\t\trep(i, h * w) p[i] = -1;\n\t\trep(i, h * w) rep(j, h * w) dist[i][j] = i == j ? 0 : inf;\n\t\t\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w){\n\t\t\t\tif(in[i][j] == 'S') sy = i, sx = j;\n\t\t\t\tif(in[i][j] == 'G') gy = i, gx = j;\n\t\t\t\tif(in[i][j] == 'X') rep(d, 2){\n\t\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\t\tif(ny >= 0 && nx >= 0 && in[ny][nx] == 'X'){\n\t\t\t\t\t\tint a = root(i * w + j), b = root(ny * w + nx);\n\t\t\t\t\t\tif(a != b){\n\t\t\t\t\t\t\tp[a] += p[b];\n\t\t\t\t\t\t\tp[b] = a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, h) rep(j, w) if(in[i][j] != '#'){\n\t\t\trep(d, 4){\n\t\t\t\tint ny = i + dy[d], nx = j + dx[d];\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\t\tif(in[i][j] == '#') continue;\n\t\t\t\tdist[i * w + j][ny * w + nx] = 1;\n\t\t\t}\n\t\t}\n\t\trep(k, 200) rep(i, 200) rep(j, 200)\n\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\n\t\tpriority_queue<pair<pi, pair<int, vi> > > q;  //cost*, cost, pos, ice\n\t\t\n\t\t\n\t\tn = 0;\n\t\tmemset(to, -1, sizeof(to));\n\t\trep(i, h) rep(j, w) if(in[i][j] == 'X'){\n\t\t\tint r = root(i * w + j);\n\t\t\tif(to[r] < 0){\n\t\t\t\tsz[n] = -p[r];\n\t\t\t\tto[r] = n++;\n\t\t\t}\n\t\t}\n\t\ts.clear();\n\t\tq.push(mp(mp(-dist[sy * w + sx][gy * w + gx], 0), mp(sy * w + sx, vi(n))));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tvi v = q.top().second.second;\n\t\t\tint cost = q.top().first.second;\n\t\t\tint y = q.top().second.first;\n\t\t\tint x = y % w; y /= w;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(s.count(mp(y * w + x, v))) continue;\n\t\t\ts.insert(mp(y * w + x, v));\n\t\t\t\n\t\t\tif(in[y][x] == 'G'){\n\t\t\t\tcout << -cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\trep(d, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\t\t\tif(in[ny][nx] == '#') continue;\n\t\t\t\tvi nv = v;\n\t\t\t\t\n\t\t\t\tif(in[ny][nx] == 'X'){\n\t\t\t\t\tint r = to[root(ny * w + nx)];\n\t\t\t\t\tnv[r]++;\n\t\t\t\t\tif(sz[r] < nv[r] * 2) continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!s.count(mp(ny * w + nx, nv)))\n\t\t\t\tq.push(mp(mp(cost - dist[ny * w + nx][gy * w + gx], cost - 1), \n\t\t\t\t\tmp(ny * w + nx, nv)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i]/2;\n      max_ans--;\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\nint h, w;\nchar field[16][16];\nint label[16][16];\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nint labeling(int y, int x, int l)\n{\n    int ret = 1;\n    label[y][x] = l;\n    \n    rep(i, 4){\n        int py = y + dy[i];\n        int px = x + dx[i];\n        if(py<0 || h<=py || px<0 || w<=px) continue;\n        if(field[py][px] == 'X' && label[py][px] == 0){\n            ret += labeling(py, px, l);\n        }\n    }\n    \n    return ret;\n}\n\nstruct Data\n{\n    int y, x, cost;\n    vi broken;\n    \n    bool operator== (const Data& d) const\n    {\n        return y == d.y && x == d.x && broken == d.broken;\n    }\n};\n\ntemplate<>\nstruct hash<Data>\n{\n    size_t operator()(const Data& d) const\n    {\n        size_t h = d.y ^ d.x;\n        rep(i, d.broken.size()) h ^= d.broken[i] << i;\n        return h;\n    }\n};\n\nint func()\n{\n    rep(i, h) rep(j, w) label[i][j] = 0;\n    \n    rep(i, h){\n        cin >> field[i];\n    }\n    \n    vi area;\n    rep(y, h) rep(x, w){\n        if(field[y][x] == 'X' && label[y][x] == 0){\n            area.push_back(labeling(y, x, area.size() + 1));\n        }\n    }\n    \n    for(int& a : area){\n        a /= 2;\n    }\n    \n    queue<Data> Q;\n    unordered_set<Data> visited;\n    \n    rep(y, h) rep(x, w){\n        if(field[y][x] == 'S'){\n            Q.push({y, x, 0, area});\n            visited.insert(Q.front());\n        }\n    }\n    \n    while(!Q.empty()){\n        Data d = Q.front();\n        Q.pop();\n        \n        rep(i, 4){\n            int py = d.y + dy[i];\n            int px = d.x + dx[i];\n            if(py<0 || h<=py || px<0 || w<=px || field[py][px] == '#') continue;\n            \n            Data next;\n            if(field[py][px] == 'G'){\n                return d.cost + 1;\n            }\n            else if(field[py][px] == 'X'){\n                int& b = d.broken[label[py][px]-1];\n                if(b == 0) continue;\n                --b;\n                next = {py, px, d.cost + 1, d.broken};\n                ++b;\n            }\n            else{\n                next = {py, px, d.cost + 1, d.broken};\n            }\n            \n            if(visited.count(next)) continue;\n            \n            Q.push(next);\n            visited.insert(next);\n        }\n    }\n    \n    return 0;\n}\n    \nint main()\n{\n    while(cin >> w >> h, w){\n        printf(\"%d\\n\", func());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\nusing namespace std;\nint W,H,SX,SY,GX,GY,ice_N;\nint field[14][14],ice[14][14],icelife[1000];\nbool flag[14][14];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid dfs(int x, int y);\nbool iddfs(int x, int y, int c);\nint main(){\n  while(cin >>W>>H,W||H){\n    for(int i=0; i<14; i++){for(int j=0; j<14; j++){field[i][j] = 1;flag[i][j] = true;}}\n    memset(ice,0,sizeof(ice));\n    memset(icelife,0,sizeof(icelife));\n    ice_N = 1;\n    string s;\n    int ans;\n    for(int i=1; i<=H; i++){\n      cin >>s;\n      for(int j=1; j<=W; j++){\n\tif(s[j-1] == '.'){field[j][i] = 0;}\n\tif(s[j-1] == '#'){field[j][i] = 1;}\n\tif(s[j-1] == 'X'){field[j][i] = 2;}\n\tif(s[j-1] == 'S'){field[j][i] = 0;SX = j;SY = i;}\n\tif(s[j-1] == 'G'){field[j][i] = 0;GX = j;GY = i;}\n      }\n    }\n    for(int i=1; i<=W; i++){\n      for(int j=1; j<=H; j++){\n\tif(field[i][j] == 2 && ice[i][j] == 0){\n\t  dfs(i,j);\n\t  icelife[ice_N]/=2;\n\t  ice_N++;\n\t}\n      }\n    }\n    for(ans = abs(SX-GX)+abs(SY-GY);;ans++){\n      if(iddfs(SX,SY,ans)){cout <<ans<<endl;break;}\n    }\n  }\n  return 0;\n}\nvoid dfs(int x, int y){\n  ice[x][y] = ice_N;\n  icelife[ice_N]++;\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(field[p][q] == 2 && ice[p][q] == 0){dfs(p,q);}\n  }\n}\nbool iddfs(int x, int y, int c){\n  bool f = false;\n  if(x == GX && y == GY){return true;}\n  if(c<abs(x-GX)+abs(y-GY)){return false;}\n  for(int i=0; i<4; i++){\n    int p = x+dx[i],q = y+dy[i];\n    if(flag[p][q]){\n      if(field[p][q] == 0){\n\tflag[p][q] = false;\n\tif(iddfs(p,q,c-1)){f = true;}\n\tflag[p][q] = true;\n      }\n      if(field[p][q] == 2){\n\tif(icelife[ice[p][q]]>0){\n\t  flag[p][q] = false;\n\t  icelife[ice[p][q]]--;\n\t  if(iddfs(p,q,c-1)){f = true;}\n\t  icelife[ice[p][q]]++;\n\t  flag[p][q] = true;\n\t}\n      }\n    }\n  }\n  return f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<array>\n#include<set>\n\nusing namespace std;\n\ntypedef array<int,72> A;\n\nstruct S{\n  int y,x;\n  A v;\n  S(int py,int px):y(py),x(px),v{}{\n  }\n  S(int py,int px,A pv):y(py),x(px){\n    copy(begin(pv),end(pv),begin(v));\n  }\n};\n\nint x,y;\nchar g[12][13];\nint id[12][12];\n\nbool inside(int py,int px){\n  return 0<=py&&py<y&&0<=px&&px<x;\n}\n\nvoid ff(int y,int x,int n){\n  if(!inside(y,x)||g[y][x]!='X'||id[y][x]>=0)return;\n  id[y][x]=n;\n  for(int i=0;i<4;i++){\n    static int d[]={0,1,0,-1,0};\n    ff(y+d[i],x+d[i+1],n);\n  }\n}\n\nint main(){\n  while(cin>>x>>y,x){\n    int sy,sx,gy,gx;\n    for(int i=0;i<y;i++){\n      cin>>g[i];\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='S'){\n\t  sy=i;\n\t  sx=j;\n\t}else if(g[i][j]=='G'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }\n    }\n    fill(id[0],id[12],-1);\n    int nid=0;\n    for(int i=0;i<y;i++){\n      for(int j=0;j<x;j++){\n\tif(g[i][j]=='X'&&id[i][j]<0){\n\t  ff(i,j,nid++);\n\t}\n      }\n    }\n    A ni={};\n    for(int i=0;i<nid;i++){\n      ni[i]=count(id[0],id[12],i);\n    }\n    vector<S> v[146];\n    v[0].emplace_back(sy,sx);\n    set<A> s[12][12];\n    for(int i=0;;i++){\n      for(auto e:v[i]){\n\tif(e.y==gy&&e.x==gx){\n\t  cout<<i<<endl;\n\t  goto next;\n\t}\n\tif(!s[e.y][e.x].insert(e.v).second)continue;\n\tfor(int j=0;j<4;j++){\n\t  static int d[]={0,1,0,-1,0};\n\t  int ny=e.y+d[j];\n\t  int nx=e.x+d[j+1];\n\t  if(inside(ny,nx)&&g[ny][nx]!='#'){\n\t    auto nv=e.v;\n\t    if(g[ny][nx]=='X'){\n\t      int cid=id[ny][nx];\n\t      nv[cid]++;\n\t      if(nv[cid]>ni[cid]/2)continue;\n\t    }\n\t    v[i+1].emplace_back(ny,nx,nv);\n\t  }\n\t}\n      }\n    }\n  next:\n    ;\n  }\n}\n\n\n\t      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\n//queue<Pox> Q;\ndeque<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop_back();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  if(cur == st[1])break;\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop_front();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      \n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop_front();\n\t  continue;\n\t  //Q.push(pre);\n\t}\n      \n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push_back(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      if(Q.front().cost > pox.cost+1)\n\t\tQ.push_front(Pox(next,pox.cost+1));\n\t      else\n\t\tQ.push_back(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n      vector<int> initial_array(ice_number+1,0);\n      initial_array[ice_number] = st[0];\n      Q.push_back(Pox(initial_array,0));\n      mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif ((x1==gx && y1==gy) || d>=an) { if (d<an) an=d; return 1;}\n\tfor (i=0;i<4;i++) if (da[y1+dy[i]][x1+dx[i]]!='#' && m[y1+dy[i]][x1+dx[i]]<0 && c[y1+dy[i]][x1+dx[i]]==0) if (c[y1+dy[i]*2][x1+dx[i]*2]==1) return 1;\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t\tif (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0; j<4; j++) z+=c[y2+dy[j]][x2+dx[j]];\n\t\t\t\tif (z<2) {\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=1;j<=x;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nconst int INF = 1<<28;\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\nint fromG[MAXH][MAXW];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid bfs(int si, int sj) {\n  queue<pair<int,int> > que;\n  fill(fromG[0], fromG[MAXH], INF);\n  que.push(make_pair(si,sj));\n  fromG[si][sj] = 0;\n  while(que.size()) {\n    int pi = que.front().first;\n    int pj = que.front().second;\n    que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int ni = pi + di[k];\n      int nj = pj + dj[k];\n      if(ni < 0 || ni >= H) continue;\n      if(nj < 0 || nj >= W) continue;\n      if(G[ni][nj] == '#') continue;\n      if(fromG[ni][nj] != INF) continue;\n      que.push(make_pair(ni,nj));\n      fromG[ni][nj] = fromG[pi][pj] + 1;\n    }\n  }\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(cost+fromG[pi][pj] >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n\n  vis[pi][pj] = true;\n  vector<pair<int,pair<int,int> > > v;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    v.push_back(make_pair(fromG[pi][pj], make_pair(ni,nj)));\n  }\n  sort(v.begin(), v.end());\n  for(int i = 0; i < v.size(); ++i) {\n    int ni = v[i].second.first;\n    int nj = v[i].second.second;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          ++N;\n        }\n      }\n    }\n    bfs(ti, tj);\n    ans = INF;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tpii s,g;\n\t\tUnionFind uf(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='S')\n\t\t\t\ts=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='G')\n\t\t\t\tg=mp(i,j),grid[i][j]='.';\n\t\t\tif(grid[i][j]=='X'){\n\t\t\t\tif(i+1<h && grid[i+1][j]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,(i+1)*w+j);\n\t\t\t\tif(j+1<w && grid[i][j+1]=='X')\n\t\t\t\t\tuf.Unite(i*w+j,i*w+(j+1));\n\t\t\t}\n\t\t}\n\t\tmap<int,int> f;\n\t\tvi cnt;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='X')\n\t\t\tif(!f.count(uf.Find(i*w+j))){\n\t\t\t\tf.insert(mp(uf.Find(i*w+j),f.size()));\n\t\t\t\tcnt.push_back(uf.Size(i*w+j));\n\t\t\t}\n\t\t\n\t\tstruct State{\n\t\t\tint i,j,d;\n\t\t\tvi c;\n\t\t\tState(int i,int j,int d,const vi& c):i(i),j(j),d(d),c(c){}\n\t\t\tbool operator<(const State& s)const{return d<s.d;}\n\t\t\tbool operator>(const State& s)const{return d>s.d;}\n\t\t};\n\t\tqueue<State> q;\n\t\tq.emplace(s.first,s.second,0,vi(f.size()));\n\t\tmap<pair<pii,vi>,int> memo;\n\t\twhile(!q.empty()){\n\t\t\tState cur=q.front(); q.pop();\n\t\t\titer(memo) it=memo.find(mp(mp(cur.i,cur.j),cur.c)); \n\t\t\tif(it!=memo.end() && it->second<=cur.d) continue;\n\t\t\tmemo[mp(mp(cur.i,cur.j),cur.c)]=cur.d;\n\t\t\tif(mp(cur.i,cur.j)==g) break;\n\t\t\t\n\t\t\trep(k,4){\n\t\t\t\tint ni=cur.i+\"\\xff\\x1\\0\\0\"[k],nj=cur.j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj || grid[ni][nj]=='#') continue;\n\t\t\t\tif(grid[ni][nj]=='X'){\n\t\t\t\t\tint p=f[uf.Find(ni*w+nj)];\n\t\t\t\t\tcur.c[p]++;\n\t\t\t\t\tif(2*cur.c[p]<=cnt[p])\n\t\t\t\t\t\tq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t\t\tcur.c[p]--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tq.emplace(ni,nj,cur.d+1,cur.c);\n\t\t\t}\n\t\t}\n\t\tint res=INFTY;\n\t\tfor(auto kv:memo)\n\t\t\tif(kv.first.first==g)\n\t\t\t\tres=min(res,kv.second);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n\n\n\nvoid init()\n{\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nvoid compute()\n{\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  priority_queue<Pox> Q;\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n\n  int ans = inf;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return;\n\t}\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  assert(false);\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      //make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int,int> P;\nstruct edge{int to,cost;};\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nchar field[12][12];\nint ifield[12][12];\nint W,H;\n\nstruct State{\n    int d,y,x;\n    vec ice;\n};\n\nstring state2str(State& s){\n    string ret = \"\";\n    ret.push_back(s.d+'0');\n    ret.push_back(s.y+'0');\n    ret.push_back(s.x+'0');\n    for(int i=0;i<s.ice.size();i++){\n        ret.push_back(s.ice[i]+'0');\n    }\n    return ret;\n}\n\nint lump_ice_num;\nint ice_num[12*12];\nint dfs(int y, int x){\n    int ret = 1;\n    ifield[y][x] = lump_ice_num;\n    field[y][x] = '.';\n    for(int i=0;i<4;i++){\n        int ny = y+dy[i], nx = x+dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(field[ny][nx]=='X'){\n            ret += dfs(ny, nx);\n        }\n    }\n    return ret;\n}\n\nbool visited[12][12];\nint visited_ice[12*12];\nint ans;\nint sy, sx, gy, gx;\nvoid dfs2(int y, int x, int py, int px, int d){\n    //printf(\"%d %d\\n\",y,x);\n    if(y==gy&&x==gx){\n        ans = min(d, ans);\n        return;\n    }\n    if(d + abs(gy-y) + abs(gx-x) >= ans) return;\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        if(ny==py&&nx==px)continue;\n        if(visited[ny][nx]) return;\n    }\n    visited[y][x] = true;\n    for(int i=0;i<4;i++){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny<0||H<=ny||nx<0||W<=nx)continue;\n        //printf(\"y=%d x=%d ny=%d nx=%d\\n\", y, x, ny, nx);\n        if(visited[ny][nx])continue;\n        if(ifield[ny][nx]==-2)continue;\n        if(ifield[ny][nx]>=0){\n            int ice_i = ifield[ny][nx];\n            if(ice_num[ice_i]/2 < visited_ice[ice_i]+1) continue;\n            visited_ice[ice_i]++;\n            dfs2(ny, nx, y, x, d+1);\n            visited_ice[ice_i]--;\n        }else{\n            dfs2(ny, nx, y, x, d+1);\n        }\n    }\n    visited[y][x] = false;\n}\n\nint main(){\n    while(cin >> W >> H, W){\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                cin >> field[i][j];\n                if(field[i][j]=='.'){\n                    ifield[i][j] = -1;\n                }else if(field[i][j]=='#'){\n                    ifield[i][j] = -2;\n                }else if(field[i][j]=='S'){\n                    ifield[i][j] = -1;\n                    sy = i; sx = j;\n                }else if(field[i][j]=='G'){\n                    ifield[i][j] = -1;\n                    gy = i; gx = j;\n                }\n            }\n        }\n\n        lump_ice_num = 0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(field[i][j]=='X'){\n                    ice_num[lump_ice_num] = dfs(i,j);\n                    lump_ice_num++;\n                }\n            }\n        }\n\n        ans = INF;\n        memset(visited, 0, sizeof(visited));\n        memset(visited_ice, 0, sizeof(visited_ice));\n        dfs2(sy, sx, -1, -1, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct d{\n\tint x;\n\tint y;\n\tint visited[12][12];\n\tint ic[144];\n\tint cnt;\n};\nstruct b{\n\tint x;\n\tint y;\n};\nint main(){\n\tint lx,ly,i,j,nc=1,k,a,min=144;\n\tint maps[12][12]={0};\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tint ig[144]={0};\n\tchar map[13][13];\n\tqueue<b> q;\n\tb v,u;\n\tstack<d> s;\n\td r,t;\n\twhile(1){\n\t\tcin>>lx>>ly;\n\t\t\tif(lx==0&&ly==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnc=1;\n\t\t\tmemset(maps,0,sizeof(maps));\n\t\t\tmemset(ig,0,sizeof(ig));\n\t\t\tmin=144;\n\t\tfor(i=0;i<ly;i++){\n\t\t\tcin>>map[i];\n\t\t}\n\t\tfor(i=0;i<ly;i++){\n\t\t\tfor(j=0;j<lx;j++){\n\t\t\t\t\tif(map[i][j]=='S'){\n\t\t\t\t\tr.x=j;\n\t\t\t\t\t\tr.y=i;\n\t\t\t\t\tmemset(r.visited,0,sizeof(r.visited));\n\t\t\t\t\tmemset(r.ic,0,sizeof(r.ic));\n\t\t\t\t\tr.cnt=0;\n\t\t\t\t\ts.push(r);\n\t\t\t\t}\n\t\t\t\tif(map[i][j]=='X'&&maps[i][j]==0){\n\t\t\t\t\tv.x=j;\n\t\t\t\t\tv.y=i;\n\t\t\t\t\tq.push(v);\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tv=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tmaps[v.y][v.x]=nc;\n\t\t\t\t\t\tig[nc]++;\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tu=v;\n\t\t\t\t\t\t\tu.x+=mx[k];\n\t\t\t\t\t\t\tu.y+=my[k];\n\t\t\t\t\t\t\tif(map[u.y][u.x]=='X'&&maps[u.y][u.x]==0&&u.x>=0&&u.x<lx&&u.y>=0&&u.y<ly){\n\t\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ig[nc]==1){\n\t\t\t\t\t\tmap[v.y][v.x]='#';\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!s.empty()){\n\t\t\tr=s.top();\n\t\t\ts.pop();\n\t\t\tif(r.visited[r.y][r.x]==1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr.visited[r.y][r.x]=1;\n\t\t\t}\n\t\t\tif(r.cnt>=min){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[r.y][r.x]=='X'){\n\t\t\t\ta=maps[r.y][r.x];\n\t\t\t\tr.ic[a]++;\n\t\t\t\tif(r.ic[a]>(ig[a]/2)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tt=r;\n\t\t\t\tt.x+=mx[i];\n\t\t\t\tt.y+=my[i];\n\t\t\t\tt.cnt++;\n\t\t\t\tif(map[t.y][t.x]=='G'&&t.cnt<min&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\tmin=t.cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[t.y][t.x]!='#'&&t.x>=0&&t.x<lx&&t.y>=0&&t.y<ly){\n\t\t\t\t\ts.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<min<<endl;\n\t}\n\treturn 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAXH = 13;\nconst int MAXW = 13;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint W, H;\nchar G[MAXH][MAXW];\nint si, sj, ti, tj;\nint N;\nint ice[MAXH][MAXW];\nint ans;\nbool vis[MAXH][MAXW];\nint cnt[1000];\n\nint dfs(int pi, int pj, int n) {\n  int res = 1;\n  ice[pi][pj] = n;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(G[ni][nj] != 'X') continue;\n    if(ice[ni][nj] != -1) continue;\n    res += dfs(ni, nj, n);\n  }\n  return res;\n}\n\nvoid dfs2(int pi, int pj, int cost) {\n  if(cost+abs(ti-pi)+abs(tj-pj) >= ans) return;\n  if(pi == ti && pj == tj) {\n    ans = min(ans, cost);\n    return;\n  }\n  vis[pi][pj] = true;\n  for(int k = 0; k < 4; ++k) {\n    int ni = pi + di[k];\n    int nj = pj + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    if(vis[ni][nj]) continue;\n    if(G[ni][nj] == '#') continue;\n    if(G[ni][nj] == 'X' && cnt[ice[ni][nj]] == 0) continue;\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] -= 1;\n    dfs2(ni, nj, cost+1);\n    if(G[ni][nj] == 'X') cnt[ice[ni][nj]] += 1;\n  }\n  vis[pi][pj] = false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == 'S') {\n          si = i;\n          sj = j;\n          G[i][j] = '.';\n        }\n        if(G[i][j] == 'G') {\n          ti = i;\n          tj = j;\n          G[i][j] = '.';\n        }\n      }\n    }\n    fill(ice[0], ice[MAXH], -1);\n    N = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(G[i][j] == 'X' && ice[i][j] == -1) {\n          cnt[N] = dfs(i, j, N)/2;\n          ++N;\n        }\n      }\n    }\n    ans = 1000;\n    fill(vis[0], vis[MAXH], 0);\n    dfs2(si, sj, 0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint ans;\nint W, H;\n\nchar map[16][16];\nchar g[16][16];\nbool v[16][16];\n\nint maxIce[128];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint sx, sy, gx, gy;\nint px, py;\n\nvoid getMin(int ty, int tx, int *ice, int turn)\n{\n\t\n\tif (turn + abs(ty - gy) + abs(tx - gx) >= ans){\n\t\treturn;\n\t}\n\t\n\tif (ty == gy && tx == gx){\n\t\tans = turn;\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (px == mx && py == my) continue;\n\t\tif (v[my][mx] == 1) return;\n\t}\n\t\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\tpx = tx, py = ty;\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H && map[my][mx] != '#' && !v[my][mx]){\n\t\t\tif (g[my][mx] == -1){\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t}\n\t\t\telse if (maxIce[g[my][mx]] >= ice[g[my][mx]] + 1){\n\t\t\t\tice[g[my][mx]]++;\n\t\t\t\tv[my][mx] = true;\n\t\t\t\tgetMin(my, mx, ice, turn + 1);\n\t\t\t\tv[my][mx] = false;\n\t\t\t\tice[g[my][mx]]--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid label(int ty, int tx, int p)\n{\n\tg[ty][tx] = p;\n\tmaxIce[p]++;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tint mx = tx + dx[i], my = ty + dy[i];\n\t\t\n\t\tif (0 <= mx && mx < W && 0 <= my && my < H &&\n\t\t\t\t\tmap[my][mx] == 'X' && g[my][mx] == -1){\n\t\t\tlabel(my, mx, p);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint idx;\n\t\n\twhile (scanf(\"%d %d\", &W, &H) == 2){\n\t\tgetchar();\n\t\t\n\t\tif (W + H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", &map[i]);\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'S'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tsx = j, sy = i;\n\t\t\t\t}\n\t\t\t\tif (map[i][j] == 'G'){\n\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\tgx = j, gy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(g, -1, sizeof(g));\n\t\tmemset(maxIce, 0, sizeof(maxIce));\n\t\t\n\t\tidx = 0;\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (map[i][j] == 'X' && g[i][j] == -1){\n\t\t\t\t\tlabel(i, j, idx);\n\t\t\t\t\tmaxIce[idx++] /= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint use[128];\n\t\t\n\t\tmemset(use, 0, sizeof(use));\n\t\tmemset(v, 0, sizeof(v));\n\t\tpx = py = -1;\n\t\tv[sy][sx] = true;\n\t\tans = W * H;\n\t\tgetMin(sy, sx, use, 0);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[12][13],gy,gx;\n\nbool vis[12][12];\n\nint ice[12][12],ice_sz[144];\nvoid predfs(int i,int j,int id){\n\tvis[i][j]=true;\n\tice[i][j]=id;\n\tice_sz[id]++;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]=='X' && !vis[y][x]) predfs(y,x,id);\n\t}\n}\n\nint ans;\nint step[144]; // 氷を踏んだ回数\nvoid dfs(int i,int j,int now){\n\tif(ans<now+abs(i-gy)+abs(j-gx)) return; // Manhattan 距離で A*\n\tif(B[i][j]=='G'){\n\t\tans=now;\n\t\treturn;\n\t}\n\n\tif(B[i][j]=='X'){\n\t\tif(ice_sz[ice[i][j]]/2<step[ice[i][j]]+1) return;\n\t\tstep[ice[i][j]]++;\n\t}\n\n\tvis[i][j]=true;\n\trep(k,4){\n\t\tint y=i+dy[k],x=j+dx[k];\n\t\tif(0<=y && y<h && 0<=x && x<w && B[y][x]!='#' && !vis[y][x]){\n\t\t\t// これまでに通った道から (y,x) にショートカットして来れる場合は枝刈り\n\t\t\tbool ok=true;\n\t\t\trep(l,4) if((k-l+4)%4!=2) {\n\t\t\t\tint yy=y+dy[l],xx=x+dx[l];\n\t\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && vis[yy][xx]) ok=false;\n\t\t\t}\n\t\t\tif(ok) dfs(y,x,now+1);\n\t\t}\n\t}\n\tvis[i][j]=false;\n\n\tif(B[i][j]=='X') step[ice[i][j]]--;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tint ice_id=0;\n\t\trep(i,h) rep(j,w) if(B[i][j]=='X' && !vis[i][j]) {\n\t\t\tice_sz[ice_id]=0;\n\t\t\tpredfs(i,j,ice_id++);\n\t\t}\n\n\t\tint sx,sy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='S') sx=j, sy=i;\n\t\t\tif(B[i][j]=='G') gx=j, gy=i;\n\t\t}\n\n\t\trep(i,h) rep(j,w) vis[i][j]=false;\n\t\tans=h*w;\n\t\tdfs(sy,sx,0);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<sstream>\n#include<queue>\n#include<cassert>\n#include<deque>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 12\n\nusing namespace std;\n\nstruct Pox\n{\n  vector<int> array;\n  int cost;\n  Pox(vector<int> array=vector<int>(),int cost=inf):array(array),cost(cost){}\n  bool operator < (const Pox &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint max_ans;\n//int dx[] = {0,1,0,-1};\n//int dy[] = {1,0,-1,0};\nint ev[MAX*MAX][MAX*MAX];//評価値 ev[a][b] := aからbまでの最短コスト\nchar g[MAX][MAX];\nint st[2],h,w,ice_number,T;\nint ice[MAX*MAX];\nint ice_cnt[MAX*MAX];\nset<vector<int> > mincost;\n//priority_queue<Pox> Q;\nqueue<Pox> Q;\n\nvoid init()\n{\n  max_ans = 0;\n  while(!Q.empty())Q.pop();\n  ice_number = 0;\n  rep(i,h)rep(j,w)ice[j+i*w] = ice_cnt[j+i*w] = inf;\n  //rep(i,h*w)rep(j,h*w)ev[i][j] = inf;\n  mincost.clear();\n}\n\nvoid getInput()\n{\n  rep(i,h)\n    {\n      getchar();\n      rep(j,w)\n\t{\n\t  scanf(\"%c\",&g[i][j]);\n\t  if(g[i][j] == 'S')\n\t    {\n\t      st[0] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == 'G')\n\t    {\n\t      st[1] = j + i * w;\n\t      g[i][j] = '.';\n\t    }\n\t  if(g[i][j] == '.')max_ans++;\n\t}\n    }\n}\n\nvoid make_ev()\n{\n  rep(sp,h*w)\n    {\n      ev[sp][sp] = 0;\n      deque<int> deq;\n      deq.push_back(sp);\n\n      while(!deq.empty())\n\t{\n\t  int cur = deq.front(); deq.pop_front();\n\t  rep(i,4)\n\t    {\n\t      int nx = cur % w + dx[i];\n\t      int ny = cur / w + dy[i];\n\t      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t      if(g[ny][nx] == '#')continue;\n\t      if(ev[sp][nx+ny*w] > ev[sp][cur]+1)\n\t\t{\n\t\t  ev[sp][nx+ny*w] = ev[sp][cur]+1;\n\t\t  deq.push_back(nx+ny*w);\n\t\t}\n\t    }\n\t}\n    }\n}\n\nvoid draw(int cur,int id,int &cnt)\n{\n  if(ice[cur] != inf)return;\n  ice[cur] = id;\n  cnt++;\n  rep(i,4)\n    {\n      int nx = cur % w + dx[i];\n      int ny = cur / w + dy[i];\n      if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n      if(g[ny][nx] != 'X')continue;\n      draw(nx+ny*w,id,cnt);\n    }\n}\n\nbool compute(int depth)\n{\n\n  int cnt = 0;\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.front(); Q.pop();\n      cnt++;\n      if(pox.cost + ev[pox.array[ice_number]][st[1]] >= max_ans)continue;\n      //if(cnt > 10 && !Q.empty() && (cnt%60 == 0 || cnt %120 == 0 || cnt % 73 == 0))Q.pop();\n      // int cost = pox.cost + ev[pox.array[ice_number]][st[1]];\n      //if(cost >= ev[st[0]][st[1]]*5)continue;\n      /*\n      if( (cnt % 666 == 0|| cnt % 700 == 0) && !Q.empty())\n\t{\n\t  Pox pre = pox;\n\t  pox = Q.front(); Q.pop();\n\t  //Q.push(pre);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 3 == 0 && Q.size() >= 2)\n\t{\n\t  Pox store = pox;\n\t  Pox store2 = Q.top(); Q.pop();\n\t  pox = Q.top(); Q.pop();\n\t  Q.push(store);\n\t  Q.push(store2);\n\t}\n      */\n      /*\n      if(cnt >= 100 && cnt % 7 == 0 && Q.size() >= 5)\n\t{\n\t  Pox store[3];\n\t  store[0] = pox;\n\t  rep(i,2)\n\t    {\n\t      store[i+1] = Q.top(); Q.pop();\n\t    }\n\t  pox = Q.top(); Q.pop();\n\t  rep(i,3)Q.push(store[i]);\n\t}\n      */\n      /*\n      cout << \"pox:array:\\n\";\n      rep(i,pox.array.size())\n\tcout << \"array[\" << i << \"] = \" << pox.array[i] << endl;\n      cout << \"pox:cost:\" << pox.cost << endl << endl;\n      */\n      if(st[1] == pox.array[ice_number])\n\t{\n\t  cout << pox.cost << endl;\n\t  return true;\n\t}\n\n      if(pox.cost >= depth)\n\t{\n\t  Q.push(pox);\n\t  return false;\n\t}\n\n\n      rep(i,4)\n\t{\n\t  int nx = pox.array[ice_number] % w + dx[i];\n\t  int ny = pox.array[ice_number] / w + dy[i];\n\t  if(!(0 <= nx && nx < w && 0 <= ny && ny < h))continue;\n\t  if(g[ny][nx] == '#')continue;\n\n\t  vector<int> next = pox.array;\t\n\t  next[ice_number] = nx+ny*w;  \n\t  if(g[ny][nx] == 'X')\n\t    {\n\t      if(ice_cnt[ice[nx+ny*w]] < 2*(pox.array[ice[nx+ny*w]] + 1))continue;\n\t      next[ice[nx+ny*w]]++;\n\t    }\n\n\t  if(mincost.find(next) == mincost.end())\n\t    {\n\t      mincost.insert(next);\n\t      Q.push(Pox(next,pox.cost+1));\n\t    }\n\t}\n    }\n  return false;\n}\n\nint main()\n{\n  while(scanf(\"%d %d\",&w,&h),w|h)\n    {\n      init();\n      getInput();\n      make_ev();\n\n      rep(y,h)rep(x,w)\n\tif(g[y][x] == 'X' && ice[x+y*w] == inf)\n\t    {\n\t      int cnt = 0;\n\t      draw(x+y*w,ice_number,cnt);\n\t      ice_cnt[ice_number] = cnt;\n\t      ice_number++;      \n\t    }\n\n      rep(i,ice_number)max_ans += ice_cnt[i];\n\n  vector<int> initial_array(ice_number+1,0);\n  initial_array[ice_number] = st[0];\n  Q.push(Pox(initial_array,0));\n  mincost.insert(initial_array);\n      int depth = 0;\n      while(!compute(depth++));\t\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nchar da[13][13];\nint an,sx,sy,gx,gy,x,y,m[13][13],f[13][13],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nstruct wd {\n\tint x,y,t;\n\tint c[36];\n\tint d[12];\n };\n\nwd w,w2;\nqueue<wd> qu; \n \nint bfs() {\n\tint c,k,j,x2,y2;\n\twhile(true) {\n\t\tw=qu.front(); qu.pop();\n\t\tw.d[w.y]|=1 << w.x;\n\t\tfor (k=0;k<4;k++) {\n\t\t\tw2=w;\n\t\t\tx2=w2.x+dx[k]; y2=w2.y+dy[k]; w2.t++;\n\t\t\tif (x2==gx && y2==gy) return w2.t;\n\t\t\tif (x2>=0 && x2<x && y2>=0 && y2<y) {\n\t\t\t\tif ((w2.d[y2] & (1 << x2)) == 0 && da[y2][x2]!='#') {\n\t\t\t\t\tc=0;\n\t\t\t\t\tfor (j=0;j<4;j++) {\n\t\t\t\t\t\tif (x2+dx[j]>=0 && x2+dx[j]<x && y2+dy[j]>=0 && y2+dy[j]<y) {\n\t\t\t\t\t\t    if ((w2.d[y2+dy[j]] & (1 << (x2+dx[j]))) > 0) c++;}\n\t\t\t\t\t\t}\n\t\t\t\t\tif (c<2) {\t\t\t\t\t\t\n\t\t\t\t\tw2.x=x2; w2.y=y2;\n\t\t\t\t\tif (m[y2][x2]==-1) qu.push(w2); else {\n\t\t\t\t\t\tif  (w.c[m[y2][x2]]+1<=mn[m[y2][x2]]/2) {w2.c[m[y2][x2]]++; qu.push(w2);}}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\treturn 0;\n}\t \nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\tif (x1+dx[k]>=0 && x1+dx[k]<x && y1+dy[k]>=0 && y1+dy[k]<y)\n\t\t   if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint main() {\n\tint i,j,k,e;\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\twhile(!qu.empty()) qu.pop();\n\tfor (i=0;i<y;i++) { cin >> da[i];\n\t     for (j=0;j<x;j++) { m[i][j]=-1;\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<y;i++) w.d[i]=0; for (i=0;i<36;i++) w.c[i]=0;\n\tw.x=sx; w.y=sy; w.t=0;\n\tqu.push(w);\n\tan=bfs();\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <cctype>\n#include <set>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1000000007;\nconst double EPS = 1e-10;\n\nchar field[15][15];\nbool visit[15][15];\nint cnt[100];\nint sz[100];\nint id[15][15];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nint nextlimit;\n\n\nvoid dfs(int r, int c, int k){\n  id[r][c] = k;\n  sz[k]++;\n  rep(i, 4){\n    int r2 = r + dy[i];\n    int c2 = c + dx[i];\n    if(id[r2][c2] == -1 && field[r2][c2] == 'X'){\n      dfs(r2, c2, k);\n    }\n  }\n}\n\nbool iddfs(int r, int c, int gr, int gc, int dep, int limit){\n  if(dep + abs(gr - r) + abs(gc - c) > limit){\n    nextlimit = min(dep + abs(gr - r) + abs(gc - c), nextlimit);\n    return false;\n  }\n  if(r == gr && c == gc) return true;\n  visit[r][c] = true;\n  \n  rep(i, 4){\n\n    int r2 = r + dy[i];\n    int c2 = c + dx[i];\n    \n    if(field[r2][c2] == '#' || visit[r2][c2]) continue;\n    if(field[r2][c2] == '.'){\n      if(iddfs(r2, c2, gr, gc, dep + 1, limit)) return true;\n    }\n    if(field[r2][c2] == 'X'){\n      if(cnt[id[r2][c2]] + 1 > sz[id[r2][c2]] / 2) continue;\n      cnt[id[r2][c2]]++;\n      if(iddfs(r2, c2, gr, gc, dep + 1, limit)) return true;\n      cnt[id[r2][c2]]--;\n    }\n  }\n  visit[r][c] = false;\n  return false;\n}\n\n\n\nint main(){\n  int x, y ,sr, sc, gr, gc, c;\n  while(cin >> x >> y){\n    c = 0;\n    if(x == 0 && y == 0) continue;;\n    fill(&field[0][0], &field[0][0] + 15 * 15, '#');\n    \n    memset(sz, 0, sizeof(sz));\n    memset(cnt, 0, sizeof(cnt));\n    memset(id, -1, sizeof(id));\n    memset(visit, false, sizeof(visit));\n    \n    rep(i, y)rep(j, x){\n      cin >> field[i+1][j+1];\n      if(field[i+1][j+1] == 'S') sr = i + 1, sc = j + 1;\n      if(field[i+1][j+1] == 'G') gr = i + 1, gc = j + 1, field[i+1][j+1] = '.';\n    }\n    \n    rep(i, y)rep(j, x){\n      if(id[i+1][j+1] == -1 && field[i+1][j+1] == 'X'){\n\tdfs(i + 1, j + 1, c++);\n      }\n      //cout << setw(3) << id[i+1][j+1];\n      //      if(j == x - 1) cout << endl;\n    }\n    \n    int len = 1;\n    nextlimit = INF;\n    while(!iddfs(sr,sc,gr,gc,0,len)){\n      len = nextlimit;\n      nextlimit = INF;      \n    }\n    cout << len << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar da[14][14];\nint an,sx,sy,gx,gy,x,y,z,m[14][14],a[36],c[14][14],mn[36],dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\nint mkda(int x1,int y1,int u,int g) {\n\tint k,f;\n\tda[y1][x1]='.'; m[y1][x1]=u; mn[u]++; f=0;\n\tfor (k=0;k<4;k++) {\n\t\t if (da[y1+dy[k]][x1+dx[k]]=='X') { f=1; mkda(x1+dx[k],y1+dy[k],u,g+1);}\n\t\t}\n\tif (f==0 && g==0) { da[y1][x1]='#'; mn[u]=0; return 1;}\n\treturn 0;\t\n\t}\n\nint dfs(int x1,int y1,int d) {\n\tint i,j,x2,y2;\n\tif (da[y1][x1]=='g' || d+1>=an) { if (d+1<an) an=d+1; return 1;}\n\tfor (i=0;i<4;i++) {\n\t\tx2=x1+dx[i]; y2=y1+dy[i];\n\t\t if (c[y2][x2]==0 && da[y2][x2]!='#') {\n\t\t\t\tz=0;\n\t\t\t\tif (m[y2][x2]>=0) if (a[m[y2][x2]]+1>mn[m[y2][x2]]/2) continue;\n\t\t\t\tfor (j=0;j<4 ;j++) z+=c[y2+dy[j]][x2+dx[j]];   \n\t\t\t\t\tif (z<2) {\n\t\t\t\t\tfor (j=0;j<4;j++) {if (da[y2+dy[j]][x2+dx[j]]!='#' && m[y2+dy[j]][x2+dx[j]]<0 && c[y2+dy[j]][x2+dx[j]]==0)\n                       if (c[y2+dy[j]*2][x2+dx[j]*2]==1) z=2;}\n                    if (z<2) {    \t\n\t\t\t\t\tc[y2][x2]=1;\n\t\t\t\t\tif (m[y2][x2]>=0) { a[m[y2][x2]]++; dfs(x2,y2,d+1); a[m[y2][x2]]--;} else dfs(x2,y2,d+1);\n\t\t\t\t\tc[y2][x2]=0;\n\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t}\n\t\t}\n\t\treturn 0;\n} \nint main() {\n\tint i,j,k,e;\n\tchar ch[14];\n\twhile(cin >> x >> y && x>0) {\n\tfor (i=0;i<36;i++) mn[i]=0;\t\n\tfor (i=1;i<=y;i++) { cin >> ch;\n\t     da[i][0]=da[i][x+1]='#'; for (j=0;j<x;j++) da[i][1+j]=ch[j]; \n\t     for (j=0;j<=x+1;j++) { m[i][j]=-1; da[0][j]=da[y+1][j]='#';\n\t      if (da[i][j]=='S') {sx=j; sy=i;}\n\t      if (da[i][j]=='G') {gx=j; gy=i;}\n\t       }\n\t   }\n\te=1; k=-1;\n\twhile(e>0) {e=0; for (i=1;i<=y;i++) for (j=1;j<=x;j++) {\n\t\tif (da[i][j]=='X') { e=1; k++; k-=mkda(j,i,k,0);}}}\n\tfor (i=0;i<=y+1;i++) for (j=0;j<=x+1;j++) c[i][j]=0;\n\tfor (i=0;i<36;i++) a[i]=0;\t\n\tan=999; c[sy][sx]=1;\n\tfor (i=0;i<4;i++) if (da[gy+dy[i]][gx+dx[i]]!='#') da[gy+dy[i]][gx+dx[i]]='g';\n\tdfs(sx,sy,0);\n\tcout << an << endl;\n\t}  \t \t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint W, H;\nint start_x, start_y, goal_x, goal_y;\nint *ices[12][12];\nchar maze[12][12];\nbool G[12][12];\nint depth;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nvoid dfs_count(int *ice, int x, int y) {\n    (*ice)++;\n    ices[y][x] = ice;\n    maze[y][x] = '?'; // used\n\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (maze[sy][sx] == 'X') {\n                dfs_count(ice, sx, sy);\n            }\n        }\n    }\n}\n\nbool iddfs(int x, int y, int step) {\n    if (x == goal_x && y == goal_y) return true;\n    if (step == depth) return false;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (*ices[sy][sx] > 0 && !G[sy][sx]) {\n                (*ices[sy][sx])--;\n                G[sy][sx] = true;\n                if (iddfs(sx, sy, step+1)) return true;\n                G[sy][sx] = false;\n                (*ices[sy][sx])++;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        REP(y, H) REP(x, W) cin >> maze[y][x];\n\n        int empty = 100000;\n        int wall = 0;\n\n        int ice[12][12] = {};\n\n        REP(y, H) REP(x, W) {\n            switch (maze[y][x]) {\n            case '.':\n                ices[y][x] = &empty;\n                break;\n            case '#':\n                ices[y][x] = &wall;\n                break;\n            case 'S':\n                start_x = x;\n                start_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'G':\n                goal_x = x;\n                goal_y = y;\n                ices[y][x] = &empty;\n                break;\n            case 'X': {\n                dfs_count(&ice[y][x], x, y);\n                ice[y][x] /= 2;\n                ices[y][x] = &ice[y][x];\n                break;\n            }\n            }\n            maze[y][x] = '?'; // used\n        }\n\n        fill_n((bool *)G, 12*12, false);\n        depth = abs(start_x - goal_x) + abs(start_y - goal_y);\n        while (!iddfs(start_x, start_y, 0)) {\n            depth++;\n        }\n        cout << depth << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1 << 15\n\ntypedef pair<int, int> P;\n\nint dx[] = {0,1,0,-1},\n\tdy[] = {-1,0,1,0};\n\nint X,Y;\nint d[12][12],dd[12][12];\nint IceNum, Ice[144];\nP S,G;\n\nqueue<P> que;\n\nbool check(int NX, int NY)\n{\n\tif(NX >= X || NY >= Y || NX < 0 || NY < 0)\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs(P pos, int now)\n{\n\tif(pos == G){\n\t\tdd[pos.second][pos.first] = min(dd[pos.second][pos.first], now);\n\t\treturn;\n\t}\n\tif(now > dd[pos.second][pos.first])\n\t\treturn;\n\n\tdd[pos.second][pos.first] = now;\n\n\tint nx,ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\tif(check(nx,ny) && d[ny][nx] != -1){\n\t\t\tif(d[ny][nx] > 0){\n\t\t\t\tif(Ice[ d[ny][nx] ] > 0){\n\t\t\t\t\tIce[ d[ny][nx] ]--;\n\t\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t\t\t\tIce[ d[ny][nx] ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdfs(P(nx,ny), now+1);\n\t\t}\n\t}\n\n\n\t\t\n}\nint main(void)\n{\n\twhile(cin >> X >> Y, X > 0 && Y > 0){\n\t\tfill(&dd[0][0],&dd[0][0]+144, INF);\n\t\tfill(&Ice[0],&Ice[0]+144, 0);\n\t\tIceNum = 0;\n\t\tchar s[13];\n\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor(int j = 0; s[j] != '\\0'; j++){\n\t\t\t\tif(s[j] == '.')\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\telse if(s[j] == '#')\n\t\t\t\t\td[i][j] = -1;\n\t\t\t\telse if(s[j] == 'X')\n\t\t\t\t\td[i][j] = -2;\n\t\t\t\telse if(s[j] == 'S')\n\t\t\t\t\tS = P(j,i),d[i][j] = 0;\n\t\t\t\telse if(s[j] == 'G')\n\t\t\t\t\tG = P(j,i),d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Y; i++){\n\t\t\tfor(int j = 0; j < X; j++){\n\t\t\t\tif(d[i][j] == -2){\n\t\t\t\t\tIceNum++;\n\t\t\t\t\t\n\t\t\t\t\tque.push(P(j,i));\n\n\t\t\t\t\twhile(que.size()){\n\n\t\t\t\t\t\tP p = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\td[p.second][p.first] = IceNum;\n\t\t\t\t\t\tIce[IceNum]++;\n\t\t\t\t\t\tint nx,ny;\n\t\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\t\t\t\tif(check(nx,ny) && d[ny][nx] == -2){\n\t\t\t\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 144; i++)\n\t\t\tIce[i] /= 2;\n\n\t\tdfs(S,0);\n\t\tprintf(\"%d\\n\", dd[G.second][G.first]);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15];\nint gy,gx,w,h,rr;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nshort int f(int x,int y,short int c[15][15],short int b[15000]){\n  int i,j,k,t=0,r,ny,nx,min=1000;\n  short int cc[15][15],cb[15000],qx[15000],qy[15000];\n  qx[0]=x;//printf(\"\\n\");\n  qy[0]=y;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++)cc[i][j]=c[i][j];\n  }\n  for(i=1;i<rr;i++)cb[i]=b[i];//printf(\"a\\n\");\n  for(r=1;r-t;t++){\n    for(i=0;i<4;i++){\n      nx=qx[t]+X[i];\n      ny=qy[t]+Y[i];\n      if(d[ny][nx]=='#'||d[ny][nx]==0)continue;//printf(\"a\\n\");\n      if(cc[ny][nx])continue;\n      cc[qy[r]=ny][qx[r]=nx]=cc[qy[t]][qx[t]]+1;\n      //printf(\"%d %d %d\\n\",ny,nx,cc[ny][nx]);\n      if(d[ny][nx]=='X'){\n\tif(cb[m[ny][nx]]==0)continue;\n\tcb[m[ny][nx]]--;\n\tk=f(nx,ny,cc,cb);\n\tif(min>k)min=k;\n\t//if(k)return min;\n\tcb[m[ny][nx]]++;\n\tcontinue;\n      }//printf(\"%3d %d %d\\n\",t,nx,ny);\n      if(ny==gy&&nx==gx)return cc[ny][nx];\n      r++;\n    }\n  }//printf(\"b\\n\");\n  return min;\n}\nint main(){\n  int i,j,k,ny,nx,r,t,co,x,y,qx[15000],qy[15000];\n  short int c[15][15],b[15000]={0};\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=m[i][j]=0;\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    c[y][x]=1;\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    printf(\"%d\\n\",f(x,y,c,b)-1);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15],c[1000][15][15],b[1000][150]={0};\nint min,gy,gx;\nint qx[150000],qy[150000],s[150000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t}\n\tr++;//printf(\"\\n\");\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint b[150]={0};\nint min,gy,gx;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nint f(int x,int y,char d[15][15],int c[15][15],int m[15][15],int t){\n  int i,j,r,ny,nx;\n  if(t>min)return t;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n    if(c[ny][nx])continue;\n    if(d[ny][nx]=='X'){\n      if(b[m[ny][nx]]==0)continue;\n      b[m[ny][nx]]--;\n    }//printf(\"%3d %d %d\\n\",t,nx,ny);\n    if(ny==gy&&nx==gx)return t;\n    c[ny][nx]=1;\n    r=f(nx,ny,d,c,m,t+1);\n    if(min>r)min=r;\n    if(d[ny][nx]=='X')b[m[ny][nx]]++;\n    c[ny][nx]=0;\n  }\n  return min;\n}\n  \nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,qx[150],qy[150];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    char d[15][15]={0};\n    int c[15][15]={0};\n    int m[15][15]={0};\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    /*for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)printf(\"%3d \",m[i][j]);\n      printf(\"\\n\");\n    }\n    for(i=1;i<rr;i++)printf(\"%3d\",b[i]);\n    printf(\"\\n\");//*/\n    printf(\"%d\\n\",f(x,y,d,c,m,1));\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15];\nint gy,gx,w,h,rr;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nshort int f(int x,int y,short int c[15][15],short int b[150]){\n  int i,j,k,t=0,r,ny,nx,min=1000;\n  short int cc[15][15],cb[150],qx[150],qy[150];\n  qx[0]=x;//printf(\"\\n\");\n  qy[0]=y;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++)cc[i][j]=c[i][j];\n  }\n  for(i=1;i<rr;i++)cb[i]=b[i];//printf(\"a\\n\");\n  for(r=1;r-t;t++){\n    for(i=0;i<4;i++){\n      nx=qx[t]+X[i];\n      ny=qy[t]+Y[i];\n      if(d[ny][nx]=='#'||d[ny][nx]==0)continue;//printf(\"a\\n\");\n      if(cc[ny][nx])continue;\n      cc[qy[r]=ny][qx[r]=nx]=cc[qy[t]][qx[t]]+1;\n      //printf(\"%d %d %d\\n\",ny,nx,cc[ny][nx]);\n      if(d[ny][nx]=='X'){\n\tif(cb[m[ny][nx]]==0)continue;\n\tcb[m[ny][nx]]--;\n\tk=f(nx,ny,cc,cb);\n\tif(min>k)min=k;\n\t//if(k)return min;\n\tcb[m[ny][nx]]++;\n\tcontinue;\n      }//printf(\"%3d %d %d\\n\",t,nx,ny);\n      if(ny==gy&&nx==gx)return cc[ny][nx];\n      r++;\n    }\n  }//printf(\"b\\n\");\n  return min;\n}\nint main(){\n  int i,j,k,ny,nx,r,t,co,x,y,qx[150],qy[150];\n  short int c[15][15],b[150]={0};\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=m[i][j]=0;\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    c[y][x]=1;\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    printf(\"%d\\n\",f(x,y,c,b)-1);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15];\nint gy,gx,w,h,rr;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nshort int f(int x,int y,short int c[15][15],short int b[150]){\n  int i,j,k,t=0,r,ny,nx,min=1000;\n  short int cc[15][15],cb[15000],qx[15000],qy[15000];\n  qx[0]=x;//printf(\"\\n\");\n  qy[0]=y;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++)cc[i][j]=c[i][j];\n  }\n  for(i=1;i<rr;i++)cb[i]=b[i];//printf(\"a\\n\");\n  for(r=1;r-t;t++){\n    for(i=0;i<4;i++){\n      nx=qx[t]+X[i];\n      ny=qy[t]+Y[i];\n      if(d[ny][nx]=='#'||d[ny][nx]==0)continue;//printf(\"a\\n\");\n      if(cc[ny][nx])continue;\n      cc[qy[r]=ny][qx[r]=nx]=cc[qy[t]][qx[t]]+1;\n      //printf(\"%d %d %d\\n\",ny,nx,cc[ny][nx]);\n      if(d[ny][nx]=='X'){\n\tif(cb[m[ny][nx]]==0)continue;\n\tcb[m[ny][nx]]--;\n\tk=f(nx,ny,cc,cb);\n\tif(min>k)min=k;\n\t//if(k)return min;\n\tcb[m[ny][nx]]++;\n\tcontinue;\n      }//printf(\"%3d %d %d\\n\",t,nx,ny);\n      if(ny==gy&&nx==gx)return cc[ny][nx];\n      r++;\n    }\n  }//printf(\"b\\n\");\n  return min;\n}\nint main(){\n  int i,j,k,ny,nx,r,t,co,x,y,qx[150],qy[150];\n  short int c[15][15],b[150]={0};\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=m[i][j]=0;\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    c[y][x]=1;\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    printf(\"%d\\n\",f(x,y,c,b)-1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned short int m[15][15],s[10000000],c[100000][15][15],b[100000][150]={0};\nint min,gy,gx;\nchar qx[10000000],qy[10000000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t}\n\tr++;//printf(\"\\n\");\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "// AOJ 0247: Ice Maze\n// 2018.3.20 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef unsigned char uchar;\n\n// [library]\n\n/* priority queue library for C */\n#define QMAX 1000\ntypedef struct { char r, c; uchar t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n/* UNION-FIND */\nint id[150], size[150];\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q)\n{\n    int i = root(p), j = root(q); if (i == j) return;\n    if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\n/* hash */\n#define HASHSIZ 50021\ntypedef struct { char r, c; int id; uchar t, ice[50]; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\nint insert(char r, char c, uchar t, uchar *ice, int n)\n{\n\tHASH *hp;\n\tuchar *p = ice;\tint k = n;\n\tunsigned long long id = 0;\n\twhile (n--) id = (id << 3) + (*p++);\n\tid = 1 + (id % HASHSIZ), hp = hash + id;\n\twhile (hp->id) {\n\t\tif (hp->r == r && hp->c == c && hp->t == t && !memcmp(ice, hp->ice, k)) return 1;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->r = r, hp->c = c, hp->id = (int)id, hp->t = t, memcpy(hp->ice, ice, k);\n\treturn 0;\n}\n// [\\library]\n\n#define MAX 1000\ntypedef struct { char r, c, pr, pc; uchar t, ice[50]; } Q;\nQ     q[MAX+2]; int top;\nchar  map[12][13];\nuchar dist[12][12];\nint   mv[4][2] = {{0,-1},{1,0},{0,1},{-1,0}};\nuchar memo[12][12], blkid[12][12], maxice[12][12], blk[144]; int sz;\n\nvoid dijkstra(int w, int h, int sr, int sc)\n{\n\tint i, r, c, nr, nc, t;\n\n\tmemset(dist, 0xa0, sizeof(dist));\n\tqsize = 0;\n\tdist[sr][sc] = 0, enq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\tif (dist[r][c] < t) continue;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w || map[nr][nc] == '#') continue;\n\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t}\n\t}\n}\n\nint main()\n{\n    int w, h, i, r, c, f, ans;\n\tint sr, sc, gr, gc, nr, nc;\n    Q   s, ns;\n\n    while (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tinit(w*h);\n\t\ti = 0; for (r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tmemo[r][c] = i++;\n\t\t\t\tif      (map[r][c] == 'S') map[r][c] = '.', sr = r, sc = c;\n\t\t\t\telse if (map[r][c] == 'G') map[r][c] = '.', gr = r, gc = c;\n\t\t\t}\n\t\t}\n\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tif (map[r][c] != 'X') continue;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w ||\n\t\t\t\t\tmap[nr][nc] != 'X') continue;\n\t\t\t\tunite(memo[r][c], memo[nr][nc]);\n\t\t\t}\n\t\t}\n\t\tmemset(blkid, 0, sizeof(blk)), memset(maxice, 0, sizeof(maxice));\n\t\tmemset(blk, 0xff, sizeof(blk));\n\t\tf = 0, sz = 0;\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tif (map[r][c] != 'X') continue;\n\t\t\ti = root(memo[r][c]);\n\t\t\tif (size[i] == 1) { map[r][c] = '#'; continue; }\n\t\t\tif (blk[i] == 0xff) blk[i] = sz++;\n\t\t\tblkid[r][c] = blk[i];\n\t\t\tmaxice[r][c] = size[i] >> 1, f = 1;\n\t\t}\n\n        dijkstra(w, h, gr, gc);\n\t\tif (!f) { printf(\"%d\\n\", dist[sr][sc]); continue; }\n\n\t\tfor (ans = dist[sr][sc]; ; ans++) {\n\t\t\tmemset(hash, 0, sizeof(hash));\n\t\t\tmemset(&s, 0, sizeof(Q));\n\t\t\ts.r = s.pr = sr, s.c = s.pc = sc, s.t = 0;\n\t\t\tinsert(s.r, s.c, 0, ns.ice, sz);\n\t\t\tq[0] = s, top = 1;\n\t\t\twhile (top) {\n\t\t\t\ts = q[--top];\n\n\t\t\t\tif (s.r == gr && s.c == gc) goto done;\n\t\t\t\tif (s.t + dist[s.r][s.c] > ans) continue;\n\n//\t\t\t\tif (insert(s.r, s.c, s.t, s.ice, sz)) continue;\n\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tnr = s.r + mv[i][0], nc = s.c + mv[i][1];\n\t\t\t\t\tif (nr == s.pr && nc == s.pc) continue;\n\t\t\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w\n\t\t\t\t\t\t|| map[nr][nc] == '#') continue;\n\t\t\t\t\tif (map[nr][nc] == 'X' && s.ice[blkid[nr][nc]] >= maxice[nr][nc]) continue;\n\t\t\t\t\tns = s, ns.r = nr, ns.pr = r, ns.c = nc, ns.pc = c, ns.t = s.t+1;\n\t\t\t\t\tif (map[nr][nc] == 'X') ns.ice[blkid[nr][nc]]++;\n\t\t\t\t\tif (!insert(ns.r, ns.c, ns.t, ns.ice, sz)) q[top++] = ns;\n\t\t\t\t}\n\t\t\t}\n\t\t}\ndone:\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15],s[15][15],c[15][15],b[150]={0};\nint min,gy,gx;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint f(int x,int y,int t){\n  int i,j,r,ny,nx;\n  if(t==min)return t;\n  if(s[y][x]+t>min)return min;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n    if(c[ny][nx])continue;\n    if(d[ny][nx]=='X'){\n      if(b[m[ny][nx]]==0)continue;\n      b[m[ny][nx]]--;\n    }//printf(\"%3d %d %d\\n\",t,nx,ny);\n    if(ny==gy&&nx==gx)return t;\n    c[ny][nx]=1;\n    r=f(nx,ny,t+1);\n    if(min>r)min=r;\n    if(d[ny][nx]=='X')b[m[ny][nx]]++;\n    c[ny][nx]=0;\n  }\n  return min;\n}\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,qx[150],qy[150];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=s[i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    s[qy[t=0]=gy][qx[0]=gx]=1;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(s[ny][nx])continue;\n\ts[qy[r]=ny][qx[r]=nx]=s[y][x]+1;\n\tr++;\n      }\n    }\n    /*for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)printf(\"%3d \",m[i][j]);\n      printf(\"\\n\");\n    }\n    for(i=1;i<rr;i++)printf(\"%3d\",b[i]);\n    printf(\"\\n\");//*/\n    printf(\"%d\\n\",f(x,y,1));\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15],c[15][15],b[150]={0};\nint min,gy,gx;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint f(int x,int y,int t){\n  int i,j,r,ny,nx;\n  if(t==0)return 0;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n    if(c[ny][nx])continue;\n    if(d[ny][nx]=='X'){\n      if(b[m[ny][nx]]==0)continue;\n      b[m[ny][nx]]--;\n    }\n    if(ny==gy&&nx==gx)return 1;\n    c[ny][nx]=1;\n    if(f(nx,ny,t-1))return 1;\n    if(d[ny][nx]=='X')b[m[ny][nx]]++;\n    c[ny][nx]=0;\n  }\n  return 0;\n}\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,qx[150],qy[150];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    for(i=1;f(x,y,i)==0;i++);\n    printf(\"%d\\n\",i);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned short int m[15][15],s[50000],c[50000][15][15],b[50000][150]={0};\nint min,gy,gx;\nchar qx[50000],qy[50000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t  rr%=50000;\n\t}\n\tr++;//printf(\"\\n\");\n\tr%=50000;\n\tt%=50000;\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "// AOJ 0247: Ice Maze\n// 2018.3.20 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef unsigned char uchar;\n\n// [library]\n\n/* priority queue library for C */\n#define QMAX 1000\ntypedef struct { char r, c; uchar t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n/* UNION-FIND */\nint id[150], size[150];\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q)\n{\n    int i = root(p), j = root(q); if (i == j) return;\n    if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\n/* hash */\n#define HASHSIZ 50021\ntypedef struct { int id; uchar ice[50]; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\nint insert(int id, uchar *ice, int n)\n{\n\tHASH *hp;\n\tuchar *p = ice;\tint k = n;\n\tunsigned long long x = 0;\n\n\twhile (n--) x = (x << 3) + (*p++);\n\thp = hash + x % HASHSIZ;\n\tid++;\n\n\twhile (hp->id) {\n\t\tif (hp->id == id && !memcmp(ice, hp->ice, k)) return 1;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->id = id, memcpy(hp->ice, ice, k);\n\treturn 0;\n}\n// [\\library]\n\n#define MAX 1000\ntypedef struct { char r, c, pr, pc; uchar t, ice[50]; } Q;\nQ     q[MAX+2]; int top;\nchar  map[12][13];\nuchar dist[12][12];\nint   mv[4][2] = {{0,-1},{1,0},{0,1},{-1,0}};\nuchar memo[12][12], blkid[12][12], maxice[12][12], blk[144]; int sz;\n\nvoid dijkstra(int w, int h, int sr, int sc)\n{\n\tint i, r, c, nr, nc, t;\n\n\tmemset(dist, 0xa0, sizeof(dist));\n\tqsize = 0;\n\tdist[sr][sc] = 0, enq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\tif (dist[r][c] < t) continue;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w || map[nr][nc] == '#') continue;\n\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t}\n\t}\n}\n\nint main()\n{\n    int w, h, i, r, c, t, f, ans;\n\tint sr, sc, gr, gc, nr, nc;\n    Q   s, ns;\n\n    while (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tinit(w*h);\n\t\ti = 0; for (r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tmemo[r][c] = i++;\n\t\t\t\tif      (map[r][c] == 'S') map[r][c] = '.', sr = r, sc = c;\n\t\t\t\telse if (map[r][c] == 'G') map[r][c] = '.', gr = r, gc = c;\n\t\t\t}\n\t\t}\n\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tif (map[r][c] != 'X') continue;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w ||\n\t\t\t\t\tmap[nr][nc] != 'X') continue;\n\t\t\t\tunite(memo[r][c], memo[nr][nc]);\n\t\t\t}\n\t\t}\n\t\tmemset(blkid, 0, sizeof(blk)), memset(maxice, 0, sizeof(maxice));\n\t\tmemset(blk, 0xff, sizeof(blk));\n\t\tf = 0, sz = 0;\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tif (map[r][c] != 'X') continue;\n\t\t\ti = root(memo[r][c]);\n\t\t\tif (size[i] == 1) { map[r][c] = '#'; continue; }\n\t\t\tif (blk[i] == 0xff) blk[i] = sz++;\n\t\t\tblkid[r][c] = blk[i];\n\t\t\tmaxice[r][c] = size[i] >> 1, f = 1;\n\t\t}\n\n        dijkstra(w, h, gr, gc);\n\t\tif (!f) { printf(\"%d\\n\", dist[sr][sc]); continue; }\n\n\t\tfor (ans = dist[sr][sc]; ; ans++) {\n\t\t\tmemset(hash, 0, sizeof(hash));\n\t\t\tmemset(&s, 0, sizeof(Q));\n\t\t\ts.r = s.pr = sr, s.c = s.pc = sc, s.t = 0;\n//\t\t\tinsert(s.r, s.c, 0, ns.ice, sz);\n\t\t\tq[0] = s, top = 1;\n\t\t\twhile (top) {\n\t\t\t\ts = q[--top], r = s.r, c = s.c, t = s.t;\n\n\t\t\t\tif (r == gr && c == gc) goto done;\n\t\t\t\tif (t + dist[r][c] > ans) continue;\n\t\t\t\tif (insert((((r<<4)|c)<<6)|t, s.ice, sz)) continue;\n\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\t\t\tif (nr == s.pr && nc == s.pc) continue;\n\t\t\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w\n\t\t\t\t\t\t|| map[nr][nc] == '#') continue;\n\t\t\t\t\tif (map[nr][nc] == 'X' && s.ice[blkid[nr][nc]] >= maxice[nr][nc]) continue;\n\t\t\t\t\tns = s, ns.r = nr, ns.pr = r, ns.c = nc, ns.pc = c, ns.t = t+1;\n\t\t\t\t\tif (map[nr][nc] == 'X') ns.ice[blkid[nr][nc]]++;\n//\t\t\t\t\tif (!insert(ns.r, ns.c, ns.t, ns.ice, sz))\n\t\t\t\t\tq[top++] = ns;\n\t\t\t\t}\n\t\t\t}\n\t\t}\ndone:\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nshort int m[15][15],s[15000000],c[10000][15][15],b[10000][150]={0};\nint min,gy,gx;\nchar qx[15000000],qy[15000000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t}\n\tr++;//printf(\"\\n\");\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15],s[15][15],c[15][15],b[150]={0};\nint min,gy,gx;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint f(int x,int y,int t){\n  int i,j,r,ny,nx;\n  if(t==0)return 0;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n    if(c[ny][nx])continue;\n    if(d[ny][nx]=='X'){\n      if(b[m[ny][nx]]==0)continue;\n      b[m[ny][nx]]--;\n    }\n    if(ny==gy&&nx==gx)return 1;\n    c[ny][nx]=1;\n    if(f(nx,ny,t-1))return 1;\n    if(d[ny][nx]=='X')b[m[ny][nx]]++;\n    c[ny][nx]=0;\n  }\n  return 0;\n}\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,qx[150],qy[150];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=s[i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    s[qy[t=0]=gy][qx[0]=gx]=1;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(s[ny][nx])continue;\n\ts[qy[r]=ny][qx[r]=nx]=s[y][x]+1;\n\tr++;\n      }\n    }\n    for(i=s[y][x];f(x,y,i)==0;i++);\n    printf(\"%d\\n\",i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0247: Ice Maze\n// 2018.3.20 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef unsigned char uchar;\n\n// [library]\n\n/* priority queue library for C */\n#define QMAX 1000\ntypedef struct { char r, c; uchar t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n/* UNION-FIND */\nint id[150], size[150];\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q)\n{\n    int i = root(p), j = root(q); if (i == j) return;\n    if (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\n/* hash */\n#define HASHSIZ 50021\ntypedef struct { char r, c; int id; uchar t, ice[50]; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\nint insert(char r, char c, uchar t, uchar *ice, int n)\n{\n\tHASH *hp;\n\tuchar *p = ice;\tint k = n;\n\tunsigned long long id = 0;\n\twhile (n--) id = (id << 3) + (*p++);\n\tid = 1 + (id % HASHSIZ), hp = hash + id;\n\twhile (hp->id) {\n\t\tif (hp->r == r && hp->c == c && hp->t == t && !memcmp(ice, hp->ice, k)) return 1;\n\t\tif (++hp == hashend) hp = hash;\n\t}\n\thp->r = r, hp->c = c, hp->id = (int)id, hp->t = t, memcpy(hp->ice, ice, k);\n\treturn 0;\n}\n// [\\library]\n\n#define MAX 1000\ntypedef struct { char r, c, pr, pc; uchar t, ice[50]; } Q;\nQ     q[MAX+2]; int top;\nchar  map[12][13];\nuchar dist[12][12];\nint   mv[4][2] = {{0,-1},{1,0},{0,1},{-1,0}};\nuchar memo[12][12], blkid[12][12], maxice[12][12], blk[144]; int sz;\n\nvoid dijkstra(int w, int h, int sr, int sc)\n{\n\tint i, r, c, nr, nc, t;\n\n\tmemset(dist, 0xa0, sizeof(dist));\n\tqsize = 0;\n\tdist[sr][sc] = 0, enq(sr, sc, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, t = que[0].t, deq();\n\t\tif (dist[r][c] < t) continue;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w || map[nr][nc] == '#') continue;\n\t\t\tif (dist[nr][nc] > t+1) dist[nr][nc] = t+1, enq(nr, nc, t+1);\n\t\t}\n\t}\n}\n\nint main()\n{\n    int w, h, i, r, c, f, ans;\n\tint sr, sc, gr, gc, nr, nc;\n    Q   s, ns;\n\n    while (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tinit(w*h);\n\t\ti = 0; for (r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tmemo[r][c] = i++;\n\t\t\t\tif      (map[r][c] == 'S') map[r][c] = '.', sr = r, sc = c;\n\t\t\t\telse if (map[r][c] == 'G') map[r][c] = '.', gr = r, gc = c;\n\t\t\t}\n\t\t}\n\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tif (map[r][c] != 'X') continue;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w ||\n\t\t\t\t\tmap[nr][nc] != 'X') continue;\n\t\t\t\tunite(memo[r][c], memo[nr][nc]);\n\t\t\t}\n\t\t}\n\t\tmemset(blkid, 0, sizeof(blk)), memset(maxice, 0, sizeof(maxice));\n\t\tmemset(blk, 0xff, sizeof(blk));\n\t\tf = 0, sz = 0;\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tif (map[r][c] != 'X') continue;\n\t\t\ti = root(memo[r][c]);\n\t\t\tif (size[i] == 1) { map[r][c] = '#'; continue; }\n\t\t\tif (blk[i] == 0xff) blk[i] = sz++;\n\t\t\tblkid[r][c] = blk[i];\n\t\t\tmaxice[r][c] = size[i] >> 1, f = 1;\n\t\t}\n\n        dijkstra(w, h, gr, gc);\n\t\tif (!f) { printf(\"%d\\n\", dist[sr][sc]); continue; }\n\n\t\tfor (ans = dist[sr][sc]; ans < 144; ans++) {\n\t\t\tmemset(hash, 0, sizeof(hash));\n\t\t\tmemset(&s, 0, sizeof(Q));\n\t\t\ts.r = s.pr = sr, s.c = s.pc = sc, s.t = 0;\n\t\t\tq[0] = s, top = 1;\n\n\t\t\twhile (top) {\n\t\t\t\ts = q[--top];\n\n\t\t\t\tif (s.r == gr && s.c == gc) goto done;\n\t\t\t\tif (s.t + dist[s.r][s.c] > ans) continue;\n\n\t\t\t\tif (insert(s.r, s.c, s.t, s.ice, sz)) continue;\n\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tnr = s.r + mv[i][0], nc = s.c + mv[i][1];\n\t\t\t\t\tif (nr == s.pr && nc == s.pc) continue;\n\t\t\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w\n\t\t\t\t\t\t|| map[nr][nc] == '#') continue;\n\t\t\t\t\tif (map[nr][nc] == 'X' && s.ice[blkid[nr][nc]] >= maxice[nr][nc]) continue;\n\t\t\t\t\tns = s, ns.r = nr, ns.pr = r, ns.c = nc, ns.pc = c, ns.t = s.t+1;\n\t\t\t\t\tif (map[nr][nc] == 'X') ns.ice[blkid[nr][nc]]++;\n\t\t\t\t\tq[top++] = ns;\n\t\t\t\t}\n\t\t\t}\n\t\t}\ndone:\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15],c[10000][15][15],b[10000][150]={0};\nint min,gy,gx;\nint qx[1500000],qy[1500000],s[1500000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t}\n\tr++;//printf(\"\\n\");\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15],s[15][15],c[15][15],b[150]={0};\nint min,gy,gx;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint f(int x,int y,int t){\n  int i,j,r,ny,nx;\n  if(t==min)return t;\n  if(s[y][x]+t>min)return min;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n    if(c[ny][nx])continue;\n    if(d[ny][nx]=='X'){\n      if(b[m[ny][nx]]==0)continue;\n      b[m[ny][nx]]--;\n    }//printf(\"%3d %d %d\\n\",t,nx,ny);\n    if(ny==gy&&nx==gx)return t;\n    c[ny][nx]=1;\n    r=f(nx,ny,t+1);\n    if(min>r)min=r;\n    if(d[ny][nx]=='X')b[m[ny][nx]]++;\n    c[ny][nx]=0;\n  }\n  return min;\n}\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,qx[150],qy[150];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=s[i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    s[qy[t=0]=gy][qx[0]=gx]=1;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(s[ny][nx])continue;\n\ts[qy[r]=ny][qx[r]=nx]=s[y][x]+1;\n\tr++;\n      }\n    }\n    /*for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)printf(\"%3d \",m[i][j]);\n      printf(\"\\n\");\n    }\n    for(i=1;i<rr;i++)printf(\"%3d\",b[i]);\n    printf(\"\\n\");//*/\n    printf(\"%d\\n\",f(x,y,1));\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned short int m[15][15],s[20000],c[20000][15][15],b[20000][150]={0};\nint min,gy,gx;\nchar qx[20000],qy[20000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t  rr%=20000;\n\t}\n\tr++;//printf(\"\\n\");\n\tr%=20000;\n\tt%=20000;\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned short int m[15][15],s[35000000],c[100000][15][15],b[100000][150]={0};\nint min,gy,gx;\nchar qx[35000000],qy[35000000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t}\n\tr++;//printf(\"\\n\");\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nunsigned short int m[15][15],s[25000000],c[100000][15][15],b[100000][150]={0};\nint min,gy,gx;\nchar qx[25000000],qy[25000000];\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,ic;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[0][i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=ic=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=ic;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=ic;\n\t      r++;\n\t    }\n\t  }\n\t  b[0][ic++]=++co/2;\n\t}\n      }\n    }\n    qx[t=0]=x;\n    qy[  0]=y;\n    s [  0]=0;\n    for(r=rr=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(c[s[t]][ny][nx])continue;\n\tc[s[r]=s[t]][qy[r]=ny][qx[r]=nx]=c[s[t]][qy[t]][qx[t]]+1;\n\tif(gy==ny&&gx==nx)goto END;\n\t//printf(\"%d %d %d %d:\",s[t],ny,nx,c[s[t]][ny][nx]);\n\tif(d[ny][nx]=='X'){\n\t  if(b[s[t]][m[ny][nx]]==0)continue;\n\t  b[s[t]][m[ny][nx]]--;\n\t  for(j=1;j<=h;j++){\n\t    for(k=1;k<=w;k++)c[rr][j][k]=c[s[t]][j][k];\n\t  }\n\t  for(j=1;j<ic;j++)b[rr][j]=b[s[t]][j];\n\t  b[s[t]][m[ny][nx]]++;\n\t  //for(j=1;j<ic;j++)printf(\"%d \",b[rr][j]);\n\t  s[r]=rr++;\n\t}\n\tr++;//printf(\"\\n\");\n      }\n    }//printf(\"a\\n\");\n  END:\n    printf(\"%d\\n\",c[s[t]][gy][gx]);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15];\nint gy,gx,w,h,rr,min;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nshort int f(int x,int y,short int c[15][15],short int b[150]){\n  int i,j,k,t=0,r,ny,nx;\n  short int cc[15][15],cb[150],qx[150],qy[150];\n  qx[0]=x;//printf(\"\\n\");\n  qy[0]=y;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++)cc[i][j]=c[i][j];\n  }\n  for(i=1;i<rr;i++)cb[i]=b[i];//printf(\"a\\n\");\n  for(r=1;r-t;t++){\n    for(i=0;i<4;i++){\n      nx=qx[t]+X[i];\n      ny=qy[t]+Y[i];\n      if(d[ny][nx]=='#'||d[ny][nx]==0)continue;//printf(\"a\\n\");\n      if(cc[ny][nx])continue;\n      cc[qy[r]=ny][qx[r]=nx]=cc[qy[t]][qx[t]]+1;\n      //printf(\"%d %d %d\\n\",ny,nx,cc[ny][nx]);\n      if(d[ny][nx]=='X'){\n\tif(cb[m[ny][nx]]==0)continue;\n\tcb[m[ny][nx]]--;\n\tk=f(nx,ny,cc,cb);\n\tif(min>k)min=k;\n\t//if(k)return min;\n\tcb[m[ny][nx]]++;\n\tcontinue;\n      }//printf(\"%3d %d %d\\n\",t,nx,ny);\n      if(ny==gy&&nx==gx)return cc[ny][nx];\n      r++;\n    }\n  }//printf(\"b\\n\");\n  return min;\n}\nint main(){\n  int i,j,k,ny,nx,r,t,co,x,y,qx[150],qy[150];\n  short int c[15][15],b[150]={0};\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=m[i][j]=0;\n    }\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    min=1000;\n    c[y][x]=1;\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    printf(\"%d\\n\",f(x,y,c,b)-1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[15][15],s[15][15],c[15][15],b[150]={0};\nint min,gy,gx;\nint X[]={0,1,0,-1};\nint Y[]={1,0,-1,0};\nchar d[15][15];\nint f(int x,int y,int t){\n  int i,j,r,ny,nx;\n  if(t==0)return 0;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n    if(c[ny][nx])continue;\n    if(d[ny][nx]=='X'){\n      if(b[m[ny][nx]]==0)continue;\n      b[m[ny][nx]]--;\n    }//printf(\"%3d %d %d\\n\",t,nx,ny);\n    if(ny==gy&&nx==gx)return 1;\n    c[ny][nx]=1;\n    if(f(nx,ny,t-1))return 1;\n    if(d[ny][nx]=='X')b[m[ny][nx]]++;\n    c[ny][nx]=0;\n  }\n  return 0;\n}\nint main(){\n  int w,h,i,j,k,ny,nx,r,t,rr,co,x,y,qx[150],qy[150];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)d[i][j]=c[i][j]=s[i][j]=m[i][j]=0;\n    }\n    min=1000;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='S')d[ y=i][ x=j]='#';\n\tif(d[i][j]=='G')d[gy=i][gx=j]='.';\n      }\n    }\n    for(i=rr=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(m[i][j]==0&&d[i][j]=='X'){\n\t  m[qy[co=0]=i][qx[t=0]=j]=rr;\n\t  for(r=1;r-t;t++){\n\t    for(k=0;k<4;k++){\n\t      nx=qx[t]+X[k];\n\t      ny=qy[t]+Y[k];\n\t      if(d[ny][nx]-'X'||m[ny][nx])continue;\n\t      co++;\n\t      m[qy[r]=ny][qx[r]=nx]=rr;\n\t      r++;\n\t    }\n\t  }\n\t  b[rr++]=++co/2;\n\t}\n      }\n    }\n    s[qy[t=0]=gy][qx[0]=gx]=1;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=qx[t]+X[i];\n\tny=qy[t]+Y[i];\n\tif(d[ny][nx]=='#'||d[ny][nx]==0)continue;\n\tif(s[ny][nx])continue;\n\ts[qy[r]=ny][qx[r]=nx]=s[y][x]+1;\n\tr++;\n      }\n    }\n    /*for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++)printf(\"%3d \",m[i][j]);\n      printf(\"\\n\");\n    }\n    for(i=1;i<rr;i++)printf(\"%3d\",b[i]);\n    printf(\"\\n\");//*/\n    for(i=1;f(x,y,i)==0;i++);\n    printf(\"%d\\n\",i);\n  }\n  return 0;\n}\n\t      "
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] ice, hit;\n\tint[][] id, dist;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tboolean f(int i, int j, int depth, int pi, int pj){\n\t\tif(res < depth+dist[i][j])return false;\n\t\tif(gi==i && gj==j){\n//\t\t\tres = Math.min(res, depth);\n\t\t\treturn true;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(ni!=pi&&nj!=pj&&v[ni][nj])return false;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(!v[ni][nj]&&m[ni][nj]!='#'){\n\t\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tif(f(ni, nj, depth+1, i, j))return true;\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tdist = new int[14][14];\n\t\tm = new char[14][14];\n\t\tv = new boolean[14][14];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tfor(int i=0;i<h+2;i++)for(int j=0;j<w+2;j++){\n\t\t\t\tdist[i][j] = INF;\n\t\t\t\tv[i][j] = false;\n\t\t\t\tm[i][j] = '#';\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tm[i][j] = c[j-1];\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h+2][w+2];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tdist[gi][gj] = 0;\n\t\t\tQueue<int[]> que = new LinkedList<int[]>();\n\t\t\tque.add(new int[]{gi, gj});\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V[] = que.poll();\n\t\t\t\tint pi = V[0], pj = V[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(m[ni][nj]!='#'&&dist[ni][nj]==INF){\n\t\t\t\t\t\tdist[ni][nj] = dist[pi][pj]+1;\n\t\t\t\t\t\tque.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv[si][sj] = true;\n\t\t\twhile(!f(si, sj, 0, -1, -1)){\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tfor(int i=0;i<h+2;i++)for(int j=0;j<w+2;j++)v[i][j]=false;\n\t\t\t\tv[si][sj] = true;\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n\t\tif(gi==i&&gj==j){\n\t\t\tres = Math.min(res, depth);\n\t\t\treturn;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tint w,h;\n\tchar [][] data;\n\t\n\tclass State {\n\t\tint x, y, step;\n\t\tint [] enter;\n\t\tpublic State(int x, int y, int step, int [] enter) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.enter = enter;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0 ; i < h; i++){\n\t\t\t\tdata[i]= sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sx = -1, sy = -1;\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == 'S'){\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][j]== 'X'){\n\t\t\t\t\t\tint res = dfs(i,j, list.size());\n\t\t\t\t\t\tif(res == 1){\n\t\t\t\t\t\t\tdata[i][j] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlist.add(res / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] initenter = new int[list.size()];\n\t\t\tfor(int i = 0; i < initenter.length; i++){\n\t\t\t\tinitenter[i] = list.get(i);\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\topen.add(new State(sx, sy, 0, initenter));\n\t\t\tHashSet<String> close = new HashSet<String>();\n\t\t\tclose.add((sy * w + sx)+ \" \"+ getState(initenter));\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(data[now.y][now.x]== 'G' ){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\t\tif(data[yy][xx] == '#') continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tint [] nextenter = (int[]) now.enter.clone();\n\t\t\t\t\tif(data[yy][xx]== 'G' ){\n\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\tflg =true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[yy][xx] != '.'){\n\t\t\t\t\t\tint ind = data[yy][xx] - '0';\n\t\t\t\t\t\tif(nextenter[ind] <= 0) continue;\n\t\t\t\t\t\tnextenter[ind]--;\n\t\t\t\t\t}\n\t\t\t\t\tString nextstate = (yy * w + xx) + \" \" + getState(nextenter);\n\t\t\t\t\tif(close.contains(nextstate))continue;\n\t\t\t\t\topen.add(new State(xx, yy, now.step + 1, nextenter));\n\t\t\t\t\tclose.add(nextstate);\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate String getState(int [] list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int value: list){\n\t\t\tsb.append(\" \" + value);\n\t\t}\n\t\treturn sb.length() == 0 ? \"\" : sb.substring(1);\n\t}\n\n\tprivate int dfs(int y, int x, int ind) {\n\t\tint sum = 1;\n\t\tdata[y][x] = (char) ('0' + ind);\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\tif(data[yy][xx] == 'X'){\n\t\t\t\tsum += dfs(yy,xx,ind);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int[][] map;\n\tpublic static int[] ices;\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(y)]=find(x);\n\t\t}\n\t}\n\t\n\tpublic static int ans = 1000;\n\tpublic static boolean[][] is_visited = new boolean[12][12];\n\t\n\tpublic static int dps(int x, int y, int gx, int gy, int px, int py, int time, int[] using_ice){\n\t\tif(is_visited[y][x]){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(time + Math.abs(x - gx) + Math.abs(y - gy) >= ans){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tans = time;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t//check\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(px == nx && py == ny){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tis_visited[y][x] = true;\n\t\t//moving\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tif(ices[map[ny][nx]] / 2 < using_ice[map[ny][nx]] + 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tusing_ice[map[ny][nx]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(nx, ny, gx, gy, x, y, time + 1, using_ice);\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tusing_ice[map[ny][nx]]--;\n\t\t\t}\n\t\t}\n\t\tis_visited[y][x] = false;\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tint gx = -1, gy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(in[j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'X'){\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t}else if(in[j] == '#'){\n\t\t\t\t\t\tmap[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint number = 1;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t}else if(x == 0){\n\t\t\t\t\t\tif(map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y-1][x];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(y == 0){\n\t\t\t\t\t\tif(map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y][x-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left = map[y][x-1] <= 0 ? Integer.MAX_VALUE : map[y][x-1];\n\t\t\t\t\t\tfinal int up = map[y-1][x] <= 0 ? Integer.MAX_VALUE : map[y-1][x];\n\t\t\t\t\t\tfinal int min = Math.min(left, up);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(min == Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(145);\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y][x-1]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y][x-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y][x-1], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y-1][x]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y-1][x]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y-1][x], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = uf.find(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSet<Integer> hash = new HashSet<Integer>();\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thash.add(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(hash);\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tices = new int[hash.size()];\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x] = Collections.binarySearch(list, map[y][x]);\n\t\t\t\t\tices[map[y][x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(y == sy && x == sx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_S\");\n\t\t\t\t\t}else if(y == gy && x == gx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_G\");\n\t\t\t\t\t}else if(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", map[y][x] == 0 ? \"  \" : \"XX\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.printf(\"%02d\", map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(Arrays.toString(ices));\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t*/\n\t\t\t\n\t\t\tans = 1000;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tis_visited[y][x] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(sx, sy, gx, gy, -1, -1,  0, new int[hash.size()]);\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit, goal;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n\t\tif(goal[i*w+j]!=INF){\n\t\t\tres = Math.min(res, depth+goal[i*w+j]);\n\t\t\treturn;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tgoal = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(goal, INF);\n\t\t\tgoal[gi*w+gj] = 0;\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='.'&&goal[ni*w+nj]==INF){\n\t\t\t\t\t\tgoal[ni*w+nj] = goal[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int[][] map;\n\tpublic static int[] ices;\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(y)]=find(x);\n\t\t}\n\t}\n\t\n\tpublic static int ans = 1000;\n\tpublic static boolean[][] is_visited = new boolean[12][12];\n\t\n\tpublic static int dps(int x, int y, int gx, int gy, int px, int py, int time){\n\t\tif(is_visited[y][x]){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(time + Math.abs(x - gx) + Math.abs(y - gy) >= ans){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tans = time;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t//check\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(px == nx && py == ny){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tis_visited[y][x] = true;\n\t\t//moving\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tif(ices[map[ny][nx]] > 0){\n\t\t\t\t\tices[map[ny][nx]]--;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(nx, ny, gx, gy, x, y, time + 1);\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tices[map[ny][nx]]++;\n\t\t\t}\n\t\t}\n\t\tis_visited[y][x] = false;\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tint gx = -1, gy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(in[j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'X'){\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t}else if(in[j] == '#'){\n\t\t\t\t\t\tmap[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint number = 1;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t}else if(x == 0){\n\t\t\t\t\t\tif(map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y-1][x];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(y == 0){\n\t\t\t\t\t\tif(map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y][x-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left = map[y][x-1] <= 0 ? Integer.MAX_VALUE : map[y][x-1];\n\t\t\t\t\t\tfinal int up = map[y-1][x] <= 0 ? Integer.MAX_VALUE : map[y-1][x];\n\t\t\t\t\t\tfinal int min = Math.min(left, up);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(min == Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(145);\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y][x-1]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y][x-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y][x-1], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y-1][x]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y-1][x]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y-1][x], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = uf.find(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSet<Integer> hash = new HashSet<Integer>();\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thash.add(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(hash);\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tices = new int[hash.size()];\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x] = Collections.binarySearch(list, map[y][x]);\n\t\t\t\t\tices[map[y][x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < ices.length; i++){\n\t\t\t\tices[i] /= 2;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(y == sy && x == sx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_S\");\n\t\t\t\t\t}else if(y == gy && x == gx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_G\");\n\t\t\t\t\t}else if(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", map[y][x] == 0 ? \"  \" : \"XX\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.printf(\"%02d\", map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(Arrays.toString(ices));\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t*/\n\t\t\t\n\t\t\tans = 1000;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tis_visited[y][x] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(sx, sy, gx, gy, -1, -1,  0);\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int[][] map;\n\tpublic static int[] ices;\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(y)]=find(x);\n\t\t}\n\t}\n\t\n\tpublic static int ans = 1000;\n\tpublic static boolean[][] is_visited = new boolean[12][12];\n\t\n\tpublic static int dps(int x, int y, int gx, int gy, int px, int py, int time, int[] using_ice){\n\t\tif(is_visited[y][x]){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(time + Math.abs(x - gx) + Math.abs(y - gy) >= ans){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tans = time;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t//check\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(px == nx && py == ny){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tis_visited[y][x] = true;\n\t\t//moving\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tif(ices[map[ny][nx]] / 2 < using_ice[map[ny][nx]] + 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tusing_ice[map[ny][nx]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(nx, ny, gx, gy, x, y, time + 1, using_ice);\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tusing_ice[map[ny][nx]]--;\n\t\t\t}\n\t\t}\n\t\tis_visited[y][x] = false;\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tint gx = -1, gy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(in[j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'X'){\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t}else if(in[j] == '#'){\n\t\t\t\t\t\tmap[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint number = 1;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t}else if(x == 0){\n\t\t\t\t\t\tif(map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y-1][x];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(y == 0){\n\t\t\t\t\t\tif(map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y][x-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left = map[y][x-1] <= 0 ? Integer.MAX_VALUE : map[y][x-1];\n\t\t\t\t\t\tfinal int up = map[y-1][x] <= 0 ? Integer.MAX_VALUE : map[y-1][x];\n\t\t\t\t\t\tfinal int min = Math.min(left, up);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(min == Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(145);\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y][x-1]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y][x-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y][x-1], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y-1][x]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y-1][x]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y-1][x], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = uf.find(map[y][x]);\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y][x-1] = uf.find(map[y][x-1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y-1][x] = uf.find(map[y-1][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSet<Integer> hash = new HashSet<Integer>();\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thash.add(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(hash);\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tices = new int[hash.size()];\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x] = Collections.binarySearch(list, map[y][x]);\n\t\t\t\t\tices[map[y][x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(y == sy && x == sx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_S\");\n\t\t\t\t\t}else if(y == gy && x == gx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_G\");\n\t\t\t\t\t}else if(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", map[y][x] == 0 ? \"  \" : \"XX\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.printf(\"%02d\", map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(Arrays.toString(ices));\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t*/\n\t\t\tans = 1000;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tis_visited[y][x] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(sx, sy, gx, gy, -1, -1,  0, new int[hash.size()]);\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tint R, C;\n\tchar[][] table;\n\tint[][] id;\n\tint[] size;\n\tint[] by;\n\n\tint startR;\n\tint startC;\n\tint goalR;\n\tint goalC;\n\n\tvoid solve() {\n\t\tC = sc.nextInt();\n\t\tR = sc.nextInt();\n\t\tif (R == 0) return;\n\t\ttable = new char[R][];\n\t\tfor (int i = 0; i < R; i++) table[i] = sc.next().toCharArray();\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tif (table[i][j] == 'S') {\n\t\t\t\t\ttable[i][j] = '.';\n\t\t\t\t\tstartR = i;\n\t\t\t\t\tstartC = j;\n\t\t\t\t}\n\t\t\t\tif (table[i][j] == 'G') {\n\t\t\t\t\ttable[i][j] = '.';\n\t\t\t\t\tgoalR = i;\n\t\t\t\t\tgoalC = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tid = new int[R][C];\n\t\tsize = new int[144];\n\t\t{\n\t\t\tint k = 1;\n\t\t\tfor (int i = 0; i < R; i++) {\n\t\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\t\tif (table[i][j] == 'X' && id[i][j] == 0) {\n\t\t\t\t\t\tsize[k] = calcSize(i, j, k);\n\t\t\t\t\t\tif (size[k] == 1) {\n\t\t\t\t\t\t\ttable[i][j] = '#';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsize = Arrays.copyOfRange(size, 0, k);\n\t\t\tby = new int[k];\n\n\t\t}\n\n\t\tfound = false;\n\t\tfor (int limit = 1; limit < 144 ;limit++) {\n\t\t\tlong s = System.currentTimeMillis();\n\t\t\tdfs(startR, startC, limit);\n\t\t\tlong e = System.currentTimeMillis();\n\t\t\tif (found) {\n\t\t\t\tout.println(limit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tout.println(-1);\n\t\t}\n\n\t}\n\n\tint[] dr = {0, 1, 0, -1};\n\tint[] dc = {-1, 0, 1, 0};\n\tboolean found;\n\tvoid dfs(int r, int c, int limit) {\n\t\tif (r == goalR && c == goalC) {\n\t\t\tfound = true;\n\t\t\treturn;\n\t\t}\n\t\tif (limit == 0) return;\n\t\tif (limit < Math.abs(r - goalR) + Math.abs(c - goalC)) return;\n\t\tif (found) return;\n\t\tchar save = table[r][c];\n\t\ttable[r][c] = '#';\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nr = r + dr[i];\n\t\t\tint nc = c + dc[i];\n\t\t\tif (isin(nr, nc) && table[nr][nc] != '#') {\n\t\t\t\tint x = id[nr][nc];\n\t\t\t\tif (x != 0) {\n\t\t\t\t\tby[x] += 2;\n\t\t\t\t\tif (by[x] <= size[x]) dfs(nr, nc, limit - 1);\n\t\t\t\t\tby[x] -= 2;\n\t\t\t\t} else {\n\t\t\t\t\tdfs(nr, nc, limit - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttable[r][c] = save;\n\t}\n\n\tboolean isin(int r, int c) {\n\t\treturn 0 <= r && r < R && 0 <= c && c < C;\n\t}\n\n\tint calcSize(int r, int c, int k) {\n\t\tint res = 0;\n\t\tif (isin(r,c) && table[r][c] == 'X' && id[r][c] == 0) {\n\t\t\tid[r][c] = k;\n\t\t\t++res;\n\t\t\tres += calcSize(r + 1, c, k);\n\t\t\tres += calcSize(r - 1, c, k);\n\t\t\tres += calcSize(r, c + 1, k);\n\t\t\tres += calcSize(r, c - 1, k);\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tice = new int[h * w];\n\t\t\thit = new int[h * w];\n\t\t\tdist = new int[h][w];\n\t\t\tm = new char[h][w];\n\t\t\tv = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tm[i][j] = c[j];\n\t\t\t\t\tif (m[i][j] == 'S') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\tsj = j;\n\t\t\t\t\t} else if (m[i][j] == 'G') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tgi = i;\n\t\t\t\t\t\tgj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (m[i][j] != 'X' || id[i][j] > 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmark(i, j, ID);\n\t\t\t\t\tif (ice[ID] == 1)\n\t\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t\tID++;\n\t\t\t\t}\n\t\t\tdist[gi][gj] = 0;\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { gi, gj });\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint[] V = deque.poll();\n\t\t\t\tint pi = V[0];\n\t\t\t\tint pj = V[1];\n\t\t\t\tfor (int[] mo : d) {\n\t\t\t\t\tint ni = pi + mo[0];\n\t\t\t\t\tint nj = pj + mo[1];\n\t\t\t\t\tif (!isOK(ni, nj))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (m[ni][nj] != '#' && dist[ni][nj] == -1) {\n\t\t\t\t\t\tdist[ni][nj] = dist[pi][pj] + 1;\n\t\t\t\t\t\tdeque.offer(new int[] { ni, nj });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tv[si][sj] = true;\n\t\t\twhile (!f(si, sj, 0)) {\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tv = new boolean[h][w];\n\t\t\t\tv[si][sj] = true;\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate boolean f(int i, int j, int depth) {\n\t\tif (res < depth + dist[i][j])\n\t\t\treturn false;\n\t\tif (gi == i && gj == j)\n\t\t\treturn true;\n\t\tfor (int r = 0;r<4;r++) {\n\t\t\tint ni = i + d[r][0];\n\t\t\tint nj = j + d[r][1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (!v[ni][nj] && m[ni][nj] != '#') {\n\t\t\t\tif (ice[id[ni][nj]] /2 > hit[id[ni][nj]] ) {\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tif (f(ni, nj, depth + 1))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void mark(int i, int j, int x) {\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor (int[] mo : d) {\n\t\t\tint ni = i + mo[0];\n\t\t\tint nj = j + mo[1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (m[ni][nj] == 'X' && id[ni][nj] == 0)\n\t\t\t\tmark(ni, nj, x);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int i, int j) {\n\t\tif (0 <= i && i < h && 0 <= j && j < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h, si, sj, gi, gj, INF = 1 << 29, res;\n\tint[][] d = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tint[] ice, hit;\n\tint[][] id, dist;\n\tchar[][] m;\n\tboolean[][] v;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n\t\tif(gi==i && gj==j){\n\t\t\tres = Math.min(res, depth); return;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tint c = 0;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&v[ni][nj])c++;\n\t\t}\n\t\tif(2 <= c)return;\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] goal;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid g(int i, int j){\n\t\tgoal[i][j] = true;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='.'&&!goal[ni][nj])g(ni, nj);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n//\t\tif(gi==i&&gj==j){\n//\t\t\tres = Math.min(res, depth);\n//\t\t\treturn;\n//\t\t}\n\t\tif(goal[i][j]){\n\t\t\tres = Math.min(res, depth+dist[i*w+j]);\n\t\t\treturn;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoal = new boolean[h][w];\n\t\t\tg(gi, gj);\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final int MAX_INT = (1 << 30);\n  static final int[][] DXYS = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\n\n  static final int BRD_PATH = -1;\n  static final int BRD_MONT = -2;\n  static final int BRD_ISLD = -3;\n\n  // inner classes\n\n  static class Stat {\n    int pos;\n    int[] ices;\n\n    Stat(int pos, int[] ices) {\n      this.pos = pos;\n      this.ices = ices;\n    }\n  }\n\n  static class Dist {\n    ArrayList<HashMap<String, Integer>> dists;\n\n    Dist(int size) {\n      dists = new ArrayList<HashMap<String, Integer>>(size);\n      for (int i = 0; i < size; i++)\n        dists.add(new HashMap<String, Integer>());\n    }\n\n    int get(int pos, String key) {\n      Integer d = dists.get(pos).get(key);\n      return (d == null) ? MAX_INT : d;\n    }\n\n    void put(int pos, String key, int val) {\n      dists.get(pos).put(key, val);\n    }\n\n    Collection<Integer> values(int pos) {\n      return dists.get(pos).values();\n    }\n  }\n\n  // subroutines\n\n  static String joinInt(int[] inta) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < inta.length; i++) {\n      if (i > 0) sb.append(',');\n      sb.append(inta[i]);\n    }\n    return sb.toString();\n  }\n\n  static void print_board(int[] brds, int w, int h, int start, int goal) {\n    for (int pos = 0; pos < w * h; pos++) {\n      if (pos == start)\n        System.out.print(\"  S\");\n      else if (pos == goal)\n        System.out.print(\"  G\");\n      else\n        System.out.printf(\"%3d\", brds[pos]);\n      if ((pos + 1) % w == 0) System.out.println();\n    }\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int w = sc.nextInt();\n      int h = sc.nextInt();\n      int wh = w * h;\n      if (w == 0 && h == 0) break;\n\n      int start = -1, goal = -1;\n      int[] brds = new int[wh];\n\n      for (int y = 0; y < h; y++) {\n        String hl = sc.next().trim();\n\n        for (int x = 0; x < w; x++) {\n          int pos = y * w + x;\n\n          switch (hl.charAt(x)) {\n          case '.':\n            brds[pos] = BRD_PATH;\n            break;\n          case '#':\n            brds[pos] = BRD_MONT;\n            break;\n          case 'X':\n            brds[pos] = BRD_ISLD;\n            break;\n          case 'S':\n            start = pos;\n            brds[pos] = BRD_PATH;\n            break;\n          case 'G':\n            goal = pos;\n            brds[pos] = BRD_PATH;\n            break;\n          }\n        }\n      }\n\n      int nice = 0;\n      ArrayList<Integer> iclist = new ArrayList<Integer>();\n\n      for (int y = 0; y < h; y++) {\n        for (int x = 0; x < w; x++) {\n          int pos = y * w + x;\n\n          if (brds[pos] == BRD_ISLD) {\n            iclist.add(1);\n            brds[pos] = nice;\n\n            Stack<Integer> q = new Stack<Integer>();\n            q.push(pos);\n\n            while (! q.isEmpty()) {\n              int pos0 = q.pop();\n              int x0 = pos0 % w;\n              int y0 = pos0 / w;\n\n              for (int[] dxy: DXYS) {\n                int x1 = x0 + dxy[0];\n                int y1 = y0 + dxy[1];\n                int pos1 = y1 * w + x1;\n\n                if (x1 >= 0 && x1 < w && y1 >= 0 && y1 < h &&\n                    brds[pos1] == BRD_ISLD) {\n                  iclist.set(nice, iclist.get(nice) + 1);\n                  brds[pos1] = nice;\n                  q.push(pos1);\n                }\n              }\n            }\n\n            nice += 1;\n          }\n        }\n      }\n\n      int[] ices = new int[nice];\n      for (int i = 0; i < nice; i++)\n        ices[i] = iclist.get(i) / 2;\n\n      //print_board(brds, w, h, start, goal);\n      //for(int ic: ices) System.out.print(\" \" + ic);\n      //System.out.println();\n\n      Dist dists = new Dist(wh);\n      dists.put(start, joinInt(ices), 0);\n\n      ArrayList<Stat> q = new ArrayList<Stat>();\n      q.add(new Stat(start, ices.clone()));\n\n      while (! q.isEmpty()) {\n        Stat st = q.remove(0);\n        String stKey = joinInt(st.ices);\n        int stDist = dists.get(st.pos, stKey);\n        //System.out.printf(\"q(%d,%d)\\n\", st.pos % w, st.pos / w);\n\n        if (st.pos == goal) continue;\n\n        int x = st.pos % w;\n        int y = st.pos / w;\n\n        for (int[] dxy: DXYS) {\n          int x0 = x + dxy[0];\n          int y0 = y + dxy[1];\n\n          if (x0 >= 0 && x0 < w && y0 >= 0 && y0 < h) {\n            int pos0 = y0 * w + x0;\n            int ic = brds[pos0];\n\n            if (ic == BRD_MONT) continue;\n\n            int[] ics0 = st.ices.clone();\n\n            if (ic >= 0) {\n              if (ics0[ic] <= 0) continue;\n              ics0[ic]--;\n            }\n\n            int d0 = stDist + 1;\n            String key0 = joinInt(ics0);\n\n            if (dists.get(pos0, key0) >= MAX_INT) {\n              dists.put(pos0, key0, d0);\n              q.add(new Stat(pos0, ics0));\n            }\n          }\n        }\n      }\n\n      int min_dist = MAX_INT;\n\n      for (int d: dists.values(goal))\n        if (min_dist > d) min_dist = d;\n\n      System.out.println(min_dist);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tice = new int[h * w];\n\t\t\thit = new int[h * w];\n\t\t\tdist = new int[h][w];\n\t\t\tm = new char[h][w];\n\t\t\tv = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tm[i][j] = c[j];\n\t\t\t\t\tif (m[i][j] == 'S') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\tsj = j;\n\t\t\t\t\t} else if (m[i][j] == 'G') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tgi = i;\n\t\t\t\t\t\tgj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (m[i][j] != 'X' || id[i][j] > 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmark(i, j, ID);\n\t\t\t\t\tif (ice[ID] == 1)\n\t\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t\tID++;\n\t\t\t\t}\n\t\t\tdist[gi][gj] = 0;\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { gi, gj });\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint[] V = deque.poll();\n\t\t\t\tint pi = V[0];\n\t\t\t\tint pj = V[1];\n\t\t\t\tfor (int[] mo : d) {\n\t\t\t\t\tint ni = pi + mo[0];\n\t\t\t\t\tint nj = pj + mo[1];\n\t\t\t\t\tif (!isOK(ni, nj))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (m[ni][nj] != '#' && dist[ni][nj] == -1) {\n\t\t\t\t\t\tdist[ni][nj] = dist[pi][pj] + 1;\n\t\t\t\t\t\tdeque.offer(new int[] { ni, nj });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tv[si][sj] = true;\n\t\t\twhile (!f(si, sj, 0)) {\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\t\tv[i][j] = false;\n\t\t\t\tv[si][sj] = true;\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate boolean f(int i, int j, int depth) {\n\t\tif (res < depth + dist[i][j])\n\t\t\treturn false;\n\t\tif (gi == i && gj == j)\n\t\t\treturn true;\n\t\tfor (int[] mo : d) {\n\t\t\tint ni = i + mo[0];\n\t\t\tint nj = j + mo[1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (!v[ni][nj] && m[ni][nj] != '#') {\n\t\t\t\tif (ice[id[ni][nj]] /2 > hit[id[ni][nj]] ) {\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tif (f(ni, nj, depth + 1))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void mark(int i, int j, int x) {\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor (int[] mo : d) {\n\t\t\tint ni = i + mo[0];\n\t\t\tint nj = j + mo[1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (m[ni][nj] == 'X' && id[ni][nj] == 0)\n\t\t\t\tmark(ni, nj, x);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int i, int j) {\n\t\tif (0 <= i && i < h && 0 <= j && j < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h, si, sj, gi, gj, INF = 1 << 29, res;\n\tint[][] d = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tint[] ice, hit;\n\tint[][] id, dist;\n\tchar[][] m;\n\tboolean[][] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tice = new int[h * w];\n\t\t\thit = new int[h * w];\n\t\t\tdist = new int[h][w];\n\t\t\tm = new char[h][w];\n\t\t\tv = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tm[i][j] = c[j];\n\t\t\t\t\tif (m[i][j] == 'S') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\tsj = j;\n\t\t\t\t\t} else if (m[i][j] == 'G') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tgi = i;\n\t\t\t\t\t\tgj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (m[i][j] != 'X' || id[i][j] > 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmark(i, j, ID);\n\t\t\t\t\tif (ice[ID] == 1)\n\t\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t\tID++;\n\t\t\t\t}\n\t\t\tdist[gi][gj] = 0;\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { gi, gj });\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint[] V = deque.poll();\n\t\t\t\tint pi = V[0];\n\t\t\t\tint pj = V[1];\n\t\t\t\tfor (int[] mo : d) {\n\t\t\t\t\tint ni = pi + mo[0];\n\t\t\t\t\tint nj = pj + mo[1];\n\t\t\t\t\tif (!isOK(ni, nj))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (m[ni][nj] != '#' && dist[ni][nj] == -1) {\n\t\t\t\t\t\tdist[ni][nj] = dist[pi][pj] + 1;\n\t\t\t\t\t\tdeque.offer(new int[] { ni, nj });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tv[si][sj] = true;\n\t\t\twhile (!f(si, sj, 0, -1, -1)) {\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\t\tv[i][j] = false;\n\t\t\t\tv[si][sj] = true;\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate boolean f(int i, int j, int depth, int pi, int pj) {\n\t\tif (res < depth + dist[i][j])\n\t\t\treturn false;\n\t\tif (gi == i && gj == j)\n\t\t\treturn true;\n\t\tfor (int[] mo : d) {\n\t\t\tint ni = i + mo[0];\n\t\t\tint nj = j + mo[1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (ni != pi && nj != pj && v[ni][nj])\n\t\t\t\treturn false;\n\t\t}\n\t\tfor (int[] mo : d) {\n\t\t\tint ni = i + mo[0];\n\t\t\tint nj = j + mo[1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (!v[ni][nj] && m[ni][nj] != '#') {\n\t\t\t\tif (ice[id[ni][nj]] /2 > hit[id[ni][nj]] ) {\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tif (f(ni, nj, depth + 1, i, j))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void mark(int i, int j, int x) {\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor (int[] mo : d) {\n\t\t\tint ni = i + mo[0];\n\t\t\tint nj = j + mo[1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (m[ni][nj] == 'X' && id[ni][nj] == 0)\n\t\t\t\tmark(ni, nj, x);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int i, int j) {\n\t\tif (0 <= i && i < h && 0 <= j && j < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h, si, sj, gi, gj, INF = 1 << 29, res;\n\tint[][] d = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tint[] ice, hit;\n\tint[][] id, dist;\n\tchar[][] m;\n\tboolean[][] v;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tboolean f(int i, int j, int depth, int limit){\n\t\tif(limit<depth+dist[i*w+j])return false;\n\t\tif(gi==i&&gj==j){\n\t\t\treturn true;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tif(f(ni, nj, depth+1, limit))return true;\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID++);\n\t\t\t}\n\t\t\tint L = 1, R = h*w;\n\t\t\twhile(R-L>1){\n\t\t\t\tint M = (L+R)/2;\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tv = new boolean[h][w];\n\t\t\t\tv[si][sj] = true;\n\t\t\t\tif(f(si, sj, 0, M))R=M;\n\t\t\t\telse L=M;\n\t\t\t}\n\t\t\tSystem.out.println(R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tdist = new int[h][w];\n\t\t\tmap = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] cs = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tchar c = cs[j];\n\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t\tif (c == 'S') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t} else if (c == 'G') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ID = 1;\n\t\t\tice = new int[h * w];\n\t\t\tid = new int[h][w];\n\t\t\tice[0] = INF;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (id[i][j] == 0 && map[i][j] == 'X') {\n\t\t\t\t\t\tmark(i, j, ID);\n\t\t\t\t\t\tif (ice[ID] == 1)\n\t\t\t\t\t\t\tmap[i][j] = '#';\n\t\t\t\t\t\tID++;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.offer(new Point(gy, gx));\n\t\t\tdist[gy][gx] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = p.y + m[0];\n\t\t\t\t\tint nx = p.x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != '#' && dist[ny][nx] == -1) {\n\t\t\t\t\t\tdist[ny][nx] = dist[p.y][p.x] + 1;\n\t\t\t\t\t\tdeque.offer(new Point(ny, nx));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = dist[sy][sx];\n\t\t\thit = new int[h * w];\n\t\t\tb = new boolean[h][w];\n\t\t\tb[sy][sx] = true;\n\t\t\twhile (!f(sy, sx, 0)) {\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tb = new boolean[h][w];\n\t\t\t\tb[sy][sx] = true;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean f(int y, int x, int depth) {\n\t\tif (ans < depth + dist[y][x])\n\t\t\treturn false;\n\t\tif (y == gy && x == gx)\n\t\t\treturn true;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (b[ny][nx] || map[ny][nx] == '#')\n\t\t\t\tcontinue;\n\t\t\tif (ice[id[ny][nx]] / 2 > hit[id[ny][nx]]) {\n\t\t\t\thit[id[ny][nx]]++;\n\t\t\t\tb[ny][nx] = true;\n\t\t\t\tif (f(ny, nx, depth + 1))\n\t\t\t\t\treturn true;\n\t\t\t\thit[id[ny][nx]]--;\n\t\t\t\tb[ny][nx] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void mark(int i, int j, int ID) {\n\t\tice[ID]++;\n\t\tid[i][j] = ID;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = i + m[0];\n\t\t\tint nx = j + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] == 'X' && id[ny][nx] == 0)\n\t\t\t\tmark(ny, nx, ID);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w, sx, sy, gx, gy, INF = 1 << 24, ans;\n\tchar[][] map;\n\tint[][] dist, id;\n\tint[] ice, hit;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tboolean[][] b;\n\n\tclass Point {\n\t\tint y, x;\n\n\t\tpublic Point(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n\t\tif(gi==i && gj==j){\n\t\t\tres = Math.min(res, depth); return;\n\t\t}\n\t\tint c = 0;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&v[ni][nj])c++;\n\t\t}\n\t\tif(2 <= c)return;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&!v[ni][nj]&&m[ni][nj]!='#'){\n\t\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int[][] map;\n\tpublic static int[] ices;\n\t\n\tpublic static int[][][] memo = new int[12][12][145];\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(y)]=find(x);\n\t\t}\n\t}\n\t\n\tpublic static int dps(int x, int y, int gx, int gy, int time, int[] using_ice){\n\t\tif(time < 0){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}else if(memo[y][x][time] >= 0){\n\t\t\treturn memo[y][x][time];\n\t\t}else if(x == gx && y == gy){\n\t\t\tmemo[y][x][time] = 0;\n\t\t\treturn memo[y][x][time];\n\t\t}\n\t\t\n\t\tint ret = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tif(ices[map[ny][nx]] / 2 <= using_ice[map[ny][nx]]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tusing_ice[map[ny][nx]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tret = Math.min(ret, dps(nx, ny, gx, gy, time - 1, using_ice));\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tusing_ice[map[ny][nx]]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo[y][x][time] = ret == Integer.MAX_VALUE ? ret : ret + 1;\n\t\treturn memo[y][x][time];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tint gx = -1, gy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(in[j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'X'){\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t}else if(in[j] == '#'){\n\t\t\t\t\t\tmap[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint number = 1;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t}else if(x == 0){\n\t\t\t\t\t\tif(map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y-1][x];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(y == 0){\n\t\t\t\t\t\tif(map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y][x-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left = map[y][x-1] <= 0 ? Integer.MAX_VALUE : map[y][x-1];\n\t\t\t\t\t\tfinal int up = map[y-1][x] <= 0 ? Integer.MAX_VALUE : map[y-1][x];\n\t\t\t\t\t\tfinal int min = Math.min(left, up);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(min == Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(73);\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y][x-1]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y][x-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y][x-1], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y-1][x]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y-1][x]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y-1][x], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = uf.find(map[y][x]);\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y][x-1] = uf.find(map[y][x-1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y-1][x] = uf.find(map[y-1][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSet<Integer> hash = new HashSet<Integer>();\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thash.add(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(hash);\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tices = new int[hash.size()];\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x] = Collections.binarySearch(list, map[y][x]);\n\t\t\t\t\tices[map[y][x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tfor(int t = 0; t <= 144; t++){\n\t\t\t\t\t\tmemo[y][x][t] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int time = 0; time <= 144; time++){\n\t\t\t\tint ret = dps(sx, sy, gx, gy, time, new int[hash.size()]);\n\t\t\t\tif(ret != Integer.MAX_VALUE){\n\t\t\t\t\tSystem.out.println(ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tPoint s = new Point();\n\t\t\tPoint g = new Point();\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = scanner.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = str.charAt(j);\n\t\t\t\t\tif (now == 'S') {\n\t\t\t\t\t\ts.y = i;\n\t\t\t\t\t\ts.x = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == 'G') {\n\t\t\t\t\t\tg.y = i;\n\t\t\t\t\t\tg.x = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '#')\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\telse if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = -2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] != -2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint a = slove(i, j, map, -2);\n\t\t\t\t\tfor (int k = 0; k < h; k++)\n\t\t\t\t\t\tfor (int l = 0; l < w; l++)\n\t\t\t\t\t\t\tif (map[k][l] == -3)\n\t\t\t\t\t\t\t\tmap[k][l] = a;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\t\tint[][] tmpMap = map.clone();\n\t\t\tint md = Math.abs(s.y - g.y) + Math.abs(s.x - g.x);\n\t\t\tpq.offer(new Point(s.y, s.x, 0, md, tmpMap));\n\t\t\tint ans = 0;\n\t\t\tboolean[][] b  =new boolean[h][w];\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tPoint point = pq.poll();\n\t\t\t\tif(b[point.y][point.x])\n\t\t\t\t\tcontinue;\n\t\t\t\tb[point.y][point.x] = true;\n\t\t\t\tif (point.y == g.y && point.x == g.x) {\n\t\t\t\t\tans = point.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\tint ny = point.y + mo[0];\n\t\t\t\t\tint nx = point.x + mo[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (point.map[ny][nx] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint[][] tmp = new int[h][w];\n\t\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\t\ttmp[i] = Arrays.copyOf(point.map[i], w);\n\t\t\t\t\tif (tmp[ny][nx] != -1) {\n\t\t\t\t\t\tslove(ny, nx, tmp, tmp[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t\tint nmd = Math.abs(ny - g.y) + Math.abs(nx - g.x);\n\t\t\t\t\tpq.offer(new Point(ny, nx, point.step + 1, nmd + point.step\n\t\t\t\t\t\t\t+ 1, tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate int slove(int y, int x, int[][] map, int k) {\n\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\tint count = 1;\n\t\tdeque.push(new Point(y, x));\n\t\tloop: while (!deque.isEmpty()) {\n\t\t\tPoint point = deque.peek();\n\t\t\tmap[point.y][point.x] = k - 1;\n\t\t\tfor (int[] m : move) {\n\t\t\t\tint ny = point.y + m[0];\n\t\t\t\tint nx = point.x + m[1];\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (map[ny][nx] != k)\n\t\t\t\t\tcontinue;\n\t\t\t\tdeque.push(new Point(ny, nx));\n\t\t\t\tcount++;\n\t\t\t\tcontinue loop;\n\t\t\t}\n\t\t\tdeque.poll();\n\t\t}\n\t\treturn count / 2;\n\t}\n\n\tboolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point implements Comparable<Point> {\n\t\tint y, x;\n\t\tint step, md;\n\t\tint[][] map;\n\n\t\tpublic Point(int y, int x, int step, int md, int[][] map) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.md = md;\n\t\t\tthis.map = map;\n\t\t}\n\n\t\tPoint() {\n\t\t}\n\n\t\tpublic Point(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tfor (int[] m : map)\n\t\t\t\tbuilder.append(Arrays.toString(m)).append('\\n');\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \", md=\"\n\t\t\t\t\t+ md + \", map=\\n\" + builder + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif(this.md==o.md)\n\t\t\t\treturn o.step-this.step;\n\t\t\treturn this.md - o.md;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tPoint s = new Point();\n\t\t\tPoint g = new Point();\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = scanner.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tchar now = str.charAt(j);\n\t\t\t\t\tif (now == 'S') {\n\t\t\t\t\t\ts.y = i;\n\t\t\t\t\t\ts.x = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == 'G') {\n\t\t\t\t\t\tg.y = i;\n\t\t\t\t\t\tg.x = j;\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else if (now == '#')\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\telse if (now == '.')\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = -2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] != -2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint a = slove(i, j, map, -2);\n\t\t\t\t\tfor (int k = 0; k < h; k++)\n\t\t\t\t\t\tfor (int l = 0; l < w; l++)\n\t\t\t\t\t\t\tif (map[k][l] == -3)\n\t\t\t\t\t\t\t\tmap[k][l] = a;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\t\tint[][] tmpMap = map.clone();\n\t\t\tint md = Math.abs(s.y - g.y) + Math.abs(s.x - g.x);\n\t\t\tboolean[][] b = new boolean[h][w];\n\t\t\tb[s.y][s.x] = true;\n\t\t\tpq.offer(new Point(s.y, s.x, 0, md, tmpMap, b));\n\t\t\tint ans = 0;\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tPoint point = pq.poll();\n\t\t\t\tif (point.y == g.y && point.x == g.x) {\n\t\t\t\t\tans = point.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int[] mo : move) {\n\t\t\t\t\tint ny = point.y + mo[0];\n\t\t\t\t\tint nx = point.x + mo[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (point.map[ny][nx] == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (point.b[ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint[][] tmp = new int[h][w];\n\t\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\t\ttmp[i] = Arrays.copyOf(point.map[i], w);\n\t\t\t\t\tif (tmp[ny][nx] != -1) {\n\t\t\t\t\t\tslove(ny, nx, tmp, tmp[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t\tboolean[][] tb = new boolean[h][w];\n\t\t\t\t\tfor(int i = 0;i<h;i++)\n\t\t\t\t\t\ttb[i] = Arrays.copyOf(point.b[i], w);\n\t\t\t\t\ttb[ny][nx] = true;\n\t\t\t\t\tint nmd = Math.abs(ny - g.y) + Math.abs(nx - g.x);\n\t\t\t\t\tpq.offer(new Point(ny, nx, point.step + 1, nmd + point.step\n\t\t\t\t\t\t\t+ 1, tmp, tb));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate int slove(int y, int x, int[][] map, int k) {\n\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\tint count = 1;\n\t\tdeque.push(new Point(y, x));\n\t\tloop: while (!deque.isEmpty()) {\n\t\t\tPoint point = deque.peek();\n\t\t\tmap[point.y][point.x] = k - 1;\n\t\t\tfor (int[] m : move) {\n\t\t\t\tint ny = point.y + m[0];\n\t\t\t\tint nx = point.x + m[1];\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (map[ny][nx] != k)\n\t\t\t\t\tcontinue;\n\t\t\t\tdeque.push(new Point(ny, nx));\n\t\t\t\tcount++;\n\t\t\t\tcontinue loop;\n\t\t\t}\n\t\t\tdeque.poll();\n\t\t}\n\t\treturn count / 2;\n\t}\n\n\tboolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point implements Comparable<Point> {\n\t\tint y, x;\n\t\tint step, md;\n\t\tint[][] map;\n\t\tboolean[][] b;\n\n\t\tpublic Point(int y, int x, int step, int md, int[][] map, boolean[][] b) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.md = md;\n\t\t\tthis.map = map;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\tPoint() {\n\t\t}\n\n\t\tpublic Point(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tfor (int[] m : map)\n\t\t\t\tbuilder.append(Arrays.toString(m)).append('\\n');\n\t\t\tfor (boolean[] bb : b)\n\t\t\t\tbuilder.append(Arrays.toString(bb)).append('\\n');\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \", md=\"\n\t\t\t\t\t+ md + \", map=\\n\" + builder + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif(this.md==o.md)\n\t\t\t\treturn o.step-this.step;\n\t\t\treturn this.md - o.md;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] goal;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid g(int i, int j){\n\t\tgoal[i][j] = true;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='.'&&!goal[ni][nj])g(ni, nj);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n\t\tif(gi==i&&gj==j){\n\t\t\tres = Math.min(res, depth);\n\t\t\treturn;\n\t\t}\n\t\tif(goal[i][j]){\n\t\t\tres = Math.min(res, depth+dist[i*w+j]);\n\t\t\treturn;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoal = new boolean[h][w];\n\t\t\tg(gi, gj);\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int[][] map;\n\tpublic static int[] ices;\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(y)]=find(x);\n\t\t}\n\t}\n\t\n\tpublic static int ans = 1000;\n\tpublic static boolean[][] is_visited = new boolean[12][12];\n\t\n\tpublic static int dps(int x, int y, int gx, int gy, int px, int py, int time, int lim){\n\t\tif(is_visited[y][x]){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(time >= lim){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(time + Math.abs(x - gx) + Math.abs(y - gy) >= lim){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tans = time;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t//check\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(px == nx && py == ny){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tis_visited[y][x] = true;\n\t\t//moving\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tif(ices[map[ny][nx]] > 0){\n\t\t\t\t\tices[map[ny][nx]]--;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(nx, ny, gx, gy, x, y, time + 1, lim);\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tices[map[ny][nx]]++;\n\t\t\t}\n\t\t}\n\t\tis_visited[y][x] = false;\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tint gx = -1, gy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(in[j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'X'){\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t}else if(in[j] == '#'){\n\t\t\t\t\t\tmap[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint number = 1;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t}else if(x == 0){\n\t\t\t\t\t\tif(map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y-1][x];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(y == 0){\n\t\t\t\t\t\tif(map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y][x-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left = map[y][x-1] <= 0 ? Integer.MAX_VALUE : map[y][x-1];\n\t\t\t\t\t\tfinal int up = map[y-1][x] <= 0 ? Integer.MAX_VALUE : map[y-1][x];\n\t\t\t\t\t\tfinal int min = Math.min(left, up);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(min == Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(145);\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y][x-1]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y][x-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y][x-1], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y-1][x]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y-1][x]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y-1][x], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = uf.find(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSet<Integer> hash = new HashSet<Integer>();\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thash.add(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(hash);\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tices = new int[hash.size()];\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x] = Collections.binarySearch(list, map[y][x]);\n\t\t\t\t\tices[map[y][x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < ices.length; i++){\n\t\t\t\tices[i] /= 2;\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(y == sy && x == sx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_S\");\n\t\t\t\t\t}else if(y == gy && x == gx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_G\");\n\t\t\t\t\t}else if(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", map[y][x] == 0 ? \"  \" : \"XX\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.printf(\"%02d\", map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(Arrays.toString(ices));\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t*/\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i <= 144; i++){\n\t\t\t\tans = 1000;\n\t\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\t\tis_visited[y][x] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdps(sx, sy, gx, gy, -1, -1, 0, i);\n\t\t\t\t\n\t\t\t\tif(ans != 1000){\n\t\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tint w,h;\n\tchar [][] data;\n\t\n\tclass State {\n\t\tint x, y, step;\n\t\tint [] enter;\n\t\tpublic State(int x, int y, int step, int [] enter) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.enter = enter;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0 ; i < h; i++){\n\t\t\t\tdata[i]= sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sx = -1, sy = -1;\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tchar c = '0';\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == 'S'){\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][j]== 'X'){\n\t\t\t\t\t\tint res = dfs(i,j, c);\n\t\t\t\t\t\tif(res == 1){\n\t\t\t\t\t\t\tdata[i][j] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlist.add(res / 2);\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tif(c == 'G' || c == 'S'){\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] initenter = new int[list.size()];\n\t\t\tfor(int i = 0; i < initenter.length; i++){\n\t\t\t\tinitenter[i] = list.get(i);\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\topen.add(new State(sx, sy, 0, initenter));\n\t\t\tHashSet<String> close = new HashSet<String>();\n\t\t\tclose.add((sy * w + sx)+ \" \"+ getState(initenter));\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(data[now.y][now.x]== 'G' ){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\t\tif(data[yy][xx] == '#') continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tint [] nextenter = (int[]) now.enter.clone();\n\t\t\t\t\tif(data[yy][xx]== 'G' ){\n\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\tflg =true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[yy][xx] != '.'){\n\t\t\t\t\t\tint ind = data[yy][xx] - '0';\n\t\t\t\t\t\tif(ind >= ('U' - '0')){\n\t\t\t\t\t\t\tind--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ind >= ('G' - '0')){\n\t\t\t\t\t\t\tind--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nextenter[ind] <= 0) continue;\n\t\t\t\t\t\tnextenter[ind]--;\n\t\t\t\t\t}\n\t\t\t\t\tString nextstate = (yy * w + xx) + \" \" + getState(nextenter);\n\t\t\t\t\tif(close.contains(nextstate))continue;\n\t\t\t\t\topen.add(new State(xx, yy, now.step + 1, nextenter));\n\t\t\t\t\tclose.add(nextstate);\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate String getState(int [] list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int value: list){\n\t\t\tsb.append(\" \" + value);\n\t\t}\n\t\treturn sb.length() == 0 ? \"\" : sb.substring(1);\n\t}\n\n\tprivate int dfs(int y, int x, char c) {\n\t\tint sum = 1;\n\t\tdata[y][x] = c;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\tif(data[yy][xx] == 'X'){\n\t\t\t\tsum += dfs(yy,xx,c);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tice = new int[h * w];\n\t\t\thit = new int[h * w];\n\t\t\tdist = new int[h][w];\n\t\t\tm = new char[h][w];\n\t\t\tv = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tm[i][j] = c[j];\n\t\t\t\t\tif (m[i][j] == 'S') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\tsj = j;\n\t\t\t\t\t} else if (m[i][j] == 'G') {\n\t\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\t\tgi = i;\n\t\t\t\t\t\tgj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (m[i][j] != 'X' || id[i][j] > 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmark(i, j, ID);\n\t\t\t\t\tif (ice[ID] == 1)\n\t\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t\tID++;\n\t\t\t\t}\n\t\t\tdist[gi][gj] = 0;\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { gi, gj });\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint[] V = deque.poll();\n\t\t\t\tint pi = V[0];\n\t\t\t\tint pj = V[1];\n\t\t\t\tfor (int[] mo : d) {\n\t\t\t\t\tint ni = pi + mo[0];\n\t\t\t\t\tint nj = pj + mo[1];\n\t\t\t\t\tif (!isOK(ni, nj))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (m[ni][nj] != '#' && dist[ni][nj] == -1) {\n\t\t\t\t\t\tdist[ni][nj] = dist[pi][pj] + 1;\n\t\t\t\t\t\tdeque.offer(new int[] { ni, nj });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tv[si][sj] = true;\n\t\t\twhile (!f(si, sj, 0,-100)) {\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\t\tv[i][j] = false;\n\t\t\t\tv[si][sj] = true;\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate boolean f(int i, int j, int depth,int pre) {\n\t\tif (res < depth + dist[i][j])\n\t\t\treturn false;\n\t\tif (gi == i && gj == j)\n\t\t\treturn true;\n\t\tfor (int r = 0;r<4;r++) {\n\t\t\tint ni = i + d[r][0];\n\t\t\tint nj = j + d[r][1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif(Math.max(r, pre)-Math.min(r,pre)==2)\n\t\t\t\tcontinue;\n\t\t\tif (!v[ni][nj] && m[ni][nj] != '#') {\n\t\t\t\tif (ice[id[ni][nj]] /2 > hit[id[ni][nj]] ) {\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tif (f(ni, nj, depth + 1,r))\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void mark(int i, int j, int x) {\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor (int[] mo : d) {\n\t\t\tint ni = i + mo[0];\n\t\t\tint nj = j + mo[1];\n\t\t\tif (!isOK(ni, nj))\n\t\t\t\tcontinue;\n\t\t\tif (m[ni][nj] == 'X' && id[ni][nj] == 0)\n\t\t\t\tmark(ni, nj, x);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int i, int j) {\n\t\tif (0 <= i && i < h && 0 <= j && j < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint w, h, si, sj, gi, gj, INF = 1 << 29, res;\n\tint[][] d = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tint[] ice, hit;\n\tint[][] id, dist;\n\tchar[][] m;\n\tboolean[][] v;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tdist = new int[h][w];\n\t\t\tmap = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] cs = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tchar c = cs[j];\n\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t\tif (c == 'S') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t} else if (c == 'G') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ID = 1;\n\t\t\tice = new int[h * w];\n\t\t\tid = new int[h][w];\n\t\t\tice[0] = INF;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (id[i][j] == 0 && map[i][j] == 'X') {\n\t\t\t\t\t\tmark(i, j, ID);\n\t\t\t\t\t\tif (ice[ID] == 1)\n\t\t\t\t\t\t\tmap[i][j] = '#';\n\t\t\t\t\t\tID++;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.offer(new Point(gy, gx));\n\t\t\tdist[gy][gx] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = p.y + m[0];\n\t\t\t\t\tint nx = p.x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != '#' && dist[ny][nx] == -1) {\n\t\t\t\t\t\tdist[ny][nx] = dist[p.y][p.x] + 1;\n\t\t\t\t\t\tdeque.offer(new Point(ny, nx));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = dist[sy][sx];\n\t\t\thit = new int[h * w];\n\t\t\twhile (true) {\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tb = new boolean[h][w];\n\t\t\t\tb[sy][sx] = true;\n\t\t\t\tif(f(sy, sx, 0))\n\t\t\t\t\tbreak;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tprivate boolean f(int y, int x, int depth) {\n\t\tif (ans < depth + dist[y][x])\n\t\t\treturn false;\n\t\tif (y == gy && x == gx)\n\t\t\treturn true;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (b[ny][nx] || map[ny][nx] == '#')\n\t\t\t\tcontinue;\n\t\t\tif (ice[id[ny][nx]] / 2 > hit[id[ny][nx]]) {\n\t\t\t\thit[id[ny][nx]]++;\n\t\t\t\tb[ny][nx] = true;\n\t\t\t\tif (f(ny, nx, depth + 1))\n\t\t\t\t\treturn true;\n\t\t\t\thit[id[ny][nx]]--;\n\t\t\t\tb[ny][nx] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void mark(int i, int j, int ID) {\n\t\tice[ID]++;\n\t\tid[i][j] = ID;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = i + m[0];\n\t\t\tint nx = j + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] == 'X' && id[ny][nx] == 0)\n\t\t\t\tmark(ny, nx, ID);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w, sx, sy, gx, gy, INF = 1 << 24, ans;\n\tchar[][] map;\n\tint[][] dist, id;\n\tint[] ice, hit;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tboolean[][] b;\n\n\tclass Point {\n\t\tint y, x;\n\n\t\tpublic Point(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] f;\n\tstatic int[][] step;\n\tstatic int w,h,xs,ys,xg,yg;\n\tstatic Ice[] ice;\n\tstatic int iceCount;\n\tstatic int[] v1={1,0,-1,0};\n\tstatic int[] v2={0,-1,0,1};\n\tstatic int a;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=0;\n\t\t\tf=new int[h][w];\n\t\t\tstep=new int[h][w];\n\t\t\tice=new Ice[h*w/2];\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tstep[i][j]=h*w*2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tString s = cin.next();\n\t\t\t\tfor(int j = 0;j<s.length();j++){\n\t\t\t\t\tif(s.charAt(j)=='.'){\n\t\t\t\t\t\tf[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.charAt(j)=='#'){\n\t\t\t\t\t\tf[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.charAt(j)=='X'){\n\t\t\t\t\t\tf[i][j]=-3;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.charAt(j)=='S'){\n\t\t\t\t\t\txs=i;\n\t\t\t\t\t\tys=j;\n\t\t\t\t\t\tf[i][j]=-1;\n\t\t\t\t\t\tstep[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\txg=i;\n\t\t\t\t\t\tyg=j;\n\t\t\t\t\t\tf[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\ticeCount=0;\n\t\t\tfor(int i = 0;i<h;i++){\n\t\t\t\tfor(int j = 0;j<w;j++){\n\t\t\t\t\tif(f[i][j]==-3){\n\t\t\t\t\t\ta=0;\n\t\t\t\t\t\tbfsIce(i,j);\n\t\t\t\t\t\tice[iceCount++]=new Ice(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbfs(xs,ys);\n\t\t\tSystem.out.println(step[xg][yg]);\n\t\t}\n\t}\n\tstatic void bfs(int x,int y){\n\t\t//System.out.println(x+\" \" +y + \" \" + step[x][y]);\n\t\tfor(int i =0;i<4;i++){\n\t\t\t\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(f[xx][yy]!=-2){\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tice[f[xx][yy]].step++;\n\t\t\t\t\tif(ice[f[xx][yy]].isBroken()){\n\t\t\t\t\t\t//System.out.println(\"break \"+f[xx][yy]+\" \" + xx+\" \" + yy);\n\t\t\t\t\t\tice[f[xx][yy]].step--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(step[x][y]+1 <= step[xx][yy]){\n\t\t\t\t\tstep[xx][yy]=step[x][y]+1;\n\t\t\t\t\tbfs(xx,yy);\n\t\t\t\t}\n\t\t\t\tif(f[xx][yy]>=0){\n\t\t\t\t\tice[f[xx][yy]].step--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic void bfsIce(int x,int y){\n\t\tf[x][y]=iceCount;\n\t\ta++;\n\t\tfor(int i = 0;i<4;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(f[xx][yy]==-3){\n\t\t\t\tbfsIce(xx,yy);\n\t\t\t}\n\t\t}\n\t}\n}\nclass Ice{\n\tint size;\n\tint step;\n\tboolean isBroken(){\n\t\treturn size/2+1 <= step;\n\t}\n\tIce(int a){\n\t\tsize=a;\n\t\tstep=0;\n\t}\n}\nclass Field{\n\tint type;\n\tint size;\n\tint step;\n\tField(int a){\n\t\tsize=a;\n\t\tstep=0;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tdist = new int[h][w];\n\t\t\tmap = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] cs = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tdist[i][j] = -1;\n\t\t\t\t\tchar c = cs[j];\n\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t\tif (c == 'S') {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t} else if (c == 'G') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ID = 1;\n\t\t\tice = new int[h * w];\n\t\t\tid = new int[h][w];\n\t\t\tice[0] = INF;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (id[i][j] == 0 && map[i][j] == 'X') {\n\t\t\t\t\t\tmark(i, j, ID);\n\t\t\t\t\t\tif (ice[ID] == 1)\n\t\t\t\t\t\t\tmap[i][j] = '#';\n\t\t\t\t\t\tID++;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.offer(new Point(gy, gx));\n\t\t\tdist[gy][gx] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = p.y + m[0];\n\t\t\t\t\tint nx = p.x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] != '#' && dist[ny][nx] == -1) {\n\t\t\t\t\t\tdist[ny][nx] = dist[p.y][p.x] + 1;\n\t\t\t\t\t\tdeque.offer(new Point(ny, nx));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = dist[sy][sx];\n\t\t\thit = new int[h * w];\n\t\t\tb = new boolean[h][w];\n\t\t\tb[sy][sx] = true;\n\t\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\t\tpq.offer(new Point(sy, sx, 0, dist[sy][sx], hit, b));\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tPoint p = pq.poll();\n\t\t\t\tif (p.y == gy && p.x == gx) {\n\t\t\t\t\tSystem.out.println(p.step);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = p.y + m[0];\n\t\t\t\t\tint nx = p.x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (p.b[ny][nx])\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (ice[id[ny][nx]] / 2 > p.hit[id[ny][nx]]) {\n\t\t\t\t\t\tPoint cp = p.clone();\n\t\t\t\t\t\tcp.b[ny][nx] = true;\n\t\t\t\t\t\tcp.hit[id[ny][nx]]++;\n\t\t\t\t\t\tcp.step++;\n\t\t\t\t\t\tcp.md = cp.step + dist[ny][nx];\n\t\t\t\t\t\tcp.y = ny;\n\t\t\t\t\t\tcp.x = nx;\n\t\t\t\t\t\tpq.offer(cp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprivate boolean f(int y, int x, int depth) {\n\t\tif (ans < depth + dist[y][x])\n\t\t\treturn false;\n\t\tif (y == gy && x == gx)\n\t\t\treturn true;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (b[ny][nx] || map[ny][nx] == '#')\n\t\t\t\tcontinue;\n\t\t\tif (ice[id[ny][nx]] / 2 > hit[id[ny][nx]]) {\n\t\t\t\thit[id[ny][nx]]++;\n\t\t\t\tb[ny][nx] = true;\n\t\t\t\tif (f(ny, nx, depth + 1))\n\t\t\t\t\treturn true;\n\t\t\t\thit[id[ny][nx]]--;\n\t\t\t\tb[ny][nx] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void mark(int i, int j, int ID) {\n\t\tice[ID]++;\n\t\tid[i][j] = ID;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = i + m[0];\n\t\t\tint nx = j + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] == 'X' && id[ny][nx] == 0)\n\t\t\t\tmark(ny, nx, ID);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < h && 0 <= x && x < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint h, w, sx, sy, gx, gy, INF = 1 << 24, ans;\n\tchar[][] map;\n\tint[][] dist, id;\n\tint[] ice, hit;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tboolean[][] b;\n\n\tclass Point implements Cloneable, Comparable<Point> {\n\t\tint y, x, step, md;\n\t\tint[] hit;\n\t\tboolean[][] b;\n\n\t\tpublic Point(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic Point(int y, int x, int step, int md, int[] hit, boolean[][] b) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t\tthis.md = md;\n\t\t\tthis.hit = hit;\n\t\t\tthis.b = b;\n\t\t}\n\n\t\t@Override\n\t\tprotected Point clone() {\n\t\t\t// TODO ?????????????????????????????????????????????\n\t\t\ttry {\n\t\t\t\tPoint clonePoint = (Point) super.clone();\n\t\t\t\tclonePoint.hit = this.hit.clone();\n\t\t\t\tboolean[][] nb = new boolean[h][w];\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tnb[i] = Arrays.copyOf(this.b[i], w);\n\t\t\t\tclonePoint.b = nb;\n\t\t\t\treturn clonePoint;\n\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\tthrow new InternalError();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tfor (boolean[] bb : b)\n\t\t\t\tbuilder.append(Arrays.toString(bb)).append('\\n');\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \", md=\"\n\t\t\t\t\t+ md + \", hit=\" + Arrays.toString(hit) + \", b=\\n\" + builder\n\t\t\t\t\t+ \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.md == o.md)\n\t\t\t\treturn o.step - this.step;\n\t\t\treturn this.md - o.md;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tint w,h;\n\tchar [][] data;\n\t\n\tclass State {\n\t\tint x, y, step;\n\t\tint [] enter;\n\t\tpublic State(int x, int y, int step, int [] enter) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.enter = enter;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0 ; i < h; i++){\n\t\t\t\tdata[i]= sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sx = -1, sy = -1;\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == 'S'){\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][j]== 'X'){\n\t\t\t\t\t\tint res = dfs(i,j, list.size());\n\t\t\t\t\t\tif(res == 1){\n\t\t\t\t\t\t\tdata[i][j] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlist.add(res / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] initenter = new int[list.size()];\n\t\t\tfor(int i = 0; i < initenter.length; i++){\n\t\t\t\tinitenter[i] = list.get(i);\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\topen.add(new State(sx, sy, 0, initenter));\n\t\t\tHashSet<String> close = new HashSet<String>();\n\t\t\tclose.add((sy * w + sx)+ getState(initenter));\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(data[now.y][now.x]== 'G' ){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\t\tif(data[yy][xx] == '#') continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tint [] nextenter = (int[]) now.enter.clone();\n\t\t\t\t\tif(data[yy][xx]== 'G' ){\n\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\tflg =true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[yy][xx] != '.'){\n\t\t\t\t\t\tint ind = data[yy][xx] - '0';\n\t\t\t\t\t\tif(nextenter[ind] == 0) continue;\n\t\t\t\t\t\tnextenter[ind]--;\n\t\t\t\t\t}\n\t\t\t\t\tString nextstate = (yy * w + xx)+ getState(nextenter);\n\t\t\t\t\tif(close.contains(nextstate))continue;\n\t\t\t\t\topen.add(new State(xx, yy, now.step + 1, nextenter));\n\t\t\t\t\tclose.add(nextstate);\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate String getState(int [] list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int value: list){\n\t\t\tsb.append(\" \" + value);\n\t\t}\n\t\treturn sb.length() == 0 ? \"\" : sb.substring(1);\n\t}\n\n\tprivate int dfs(int y, int x, int ind) {\n\t\tint sum = 1;\n\t\tdata[y][x] = (char) ('0' + ind);\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\tif(data[yy][xx] == 'X'){\n\t\t\t\tsum += dfs(yy,xx,ind);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] ice, hit;\n\tint[][] id, dist;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i][j])return;\n\t\tif(res<=depth+Math.abs(gi-i)+Math.abs(gj-j))return;\n\t\tif(gi==i && gj==j){\n\t\t\tres = Math.min(res, depth); return;\n\t\t}\n\t\tint c = 0;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(v[ni][nj])c++;\n\t\t}\n\t\tif(2 <= c)return;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(!v[ni][nj]&&m[ni][nj]!='#'){\n\t\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tdist = new int[14][14];\n\t\tm = new char[14][14];\n\t\tv = new boolean[14][14];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tfor(int i=0;i<h+2;i++)for(int j=0;j<w+2;j++){\n\t\t\t\tdist[i][j] = INF;\n\t\t\t\tv[i][j] = false;\n\t\t\t\tm[i][j] = '#';\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tm[i][j] = c[j-1];\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h+2][w+2];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tdist[gi][gj] = 0;\n\t\t\tQueue<int[]> que = new LinkedList<int[]>();\n\t\t\tque.add(new int[]{gi, gj});\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V[] = que.poll();\n\t\t\t\tint pi = V[0], pj = V[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(m[ni][nj]!='#'&&dist[ni][nj]==INF){\n\t\t\t\t\t\tdist[ni][nj] = dist[pi][pj]+1;\n\t\t\t\t\t\tque.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int[][] map;\n\tpublic static int[] ices;\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(y)]=find(x);\n\t\t}\n\t}\n\t\n\tpublic static int ans = 1000;\n\tpublic static boolean[][] is_visited = new boolean[12][12];\n\t\n\tpublic static int dps(int x, int y, int gx, int gy, int px, int py, int time, int[] using_ice){\n\t\tif(is_visited[y][x]){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(time + Math.abs(x - gx) + Math.abs(y - gy) >= ans){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(x == gx && y == gy){\n\t\t\tans = time;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t//check\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(px == nx && py == ny){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tis_visited[y][x] = true;\n\t\t//moving\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}else if(is_visited[ny][nx]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tif(ices[map[ny][nx]] / 2 < using_ice[map[ny][nx]] + 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tusing_ice[map[ny][nx]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(nx, ny, gx, gy, x, y, time + 1, using_ice);\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tusing_ice[map[ny][nx]]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tint gx = -1, gy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(in[j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'X'){\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t}else if(in[j] == '#'){\n\t\t\t\t\t\tmap[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint number = 1;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t}else if(x == 0){\n\t\t\t\t\t\tif(map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y-1][x];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(y == 0){\n\t\t\t\t\t\tif(map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y][x-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left = map[y][x-1] <= 0 ? Integer.MAX_VALUE : map[y][x-1];\n\t\t\t\t\t\tfinal int up = map[y-1][x] <= 0 ? Integer.MAX_VALUE : map[y-1][x];\n\t\t\t\t\t\tfinal int min = Math.min(left, up);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(min == Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(145);\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y][x-1]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y][x-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y][x-1], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y-1][x]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y-1][x]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y-1][x], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = uf.find(map[y][x]);\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y][x-1] = uf.find(map[y][x-1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y-1][x] = uf.find(map[y-1][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSet<Integer> hash = new HashSet<Integer>();\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thash.add(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(hash);\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tices = new int[hash.size()];\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x] = Collections.binarySearch(list, map[y][x]);\n\t\t\t\t\tices[map[y][x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(y == sy && x == sx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_S\");\n\t\t\t\t\t}else if(y == gy && x == gx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_G\");\n\t\t\t\t\t}else if(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", map[y][x] == 0 ? \"  \" : \"XX\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.printf(\"%02d\", map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(Arrays.toString(ices));\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t*/\n\t\t\tans = 1000;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tis_visited[y][x] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdps(sx, sy, gx, gy, -1, -1,  0, new int[hash.size()]);\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit, goal;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n\t\tif(goal[i*w+j]!=INF){\n\t\t\tres = Math.min(res, depth+goal[i*w+j]);\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tgoal = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(goal, INF);\n\t\t\tgoal[gi*w+gj] = 0;\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='.'&&goal[ni*w+nj]==INF){\n\t\t\t\t\t\tgoal[ni*w+nj] = goal[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i*w+j])return;\n\t\tif(gi==i&&gj==j){\n\t\t\tres = Math.min(res, depth); return;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID++);\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tint w,h;\n\tchar [][] data;\n\t\n\tclass State {\n\t\tint x, y, step;\n\t\tint [] enter;\n\t\tpublic State(int x, int y, int step, int [] enter) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.enter = enter;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0 ; i < h; i++){\n\t\t\t\tdata[i]= sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sx = -1, sy = -1;\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == 'S'){\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][j]== 'X'){\n\t\t\t\t\t\tchar c = (char) (list.size() + '0');\n\t\t\t\t\t\tif(c >= 'S'){\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res = dfs(i,j, c);\n\t\t\t\t\t\tif(res == 1){\n\t\t\t\t\t\t\tdata[i][j] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlist.add(res / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] initenter = new int[list.size()];\n\t\t\tfor(int i = 0; i < initenter.length; i++){\n\t\t\t\tinitenter[i] = list.get(i);\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\topen.add(new State(sx, sy, 0, initenter));\n\t\t\tHashSet<String> close = new HashSet<String>();\n\t\t\tclose.add((sy * w + sx)+ \" \"+ getState(initenter));\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(data[now.y][now.x]== 'G' ){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\t\tif(data[yy][xx] == '#') continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tint [] nextenter = (int[]) now.enter.clone();\n\t\t\t\t\tif(data[yy][xx]== 'G' ){\n\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\tflg =true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[yy][xx] != '.'){\n\t\t\t\t\t\tint ind = data[yy][xx] - '0';\n\t\t\t\t\t\tif(nextenter[ind] <= 0) continue;\n\t\t\t\t\t\tnextenter[ind]--;\n\t\t\t\t\t}\n\t\t\t\t\tString nextstate = (yy * w + xx) + \" \" + getState(nextenter);\n\t\t\t\t\tif(close.contains(nextstate))continue;\n\t\t\t\t\topen.add(new State(xx, yy, now.step + 1, nextenter));\n\t\t\t\t\tclose.add(nextstate);\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate String getState(int [] list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int value: list){\n\t\t\tsb.append(\" \" + value);\n\t\t}\n\t\treturn sb.length() == 0 ? \"\" : sb.substring(1);\n\t}\n\n\tprivate int dfs(int y, int x, char c) {\n\t\tint sum = 1;\n\t\tdata[y][x] = c;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\tif(data[yy][xx] == 'X'){\n\t\t\t\tsum += dfs(yy,xx,c);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\tint w,h, gx, gy;\n\tchar [][] data;\n\t\n\tclass State implements Comparable<State>{\n\t\tint x, y, step, restdist;\n\t\tint [] enter;\n\t\tpublic State(int x, int y, int step, int [] enter, int restdist) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.step = step;\n\t\t\tthis.enter = enter;\n\t\t\tthis.restdist = restdist;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn (this.step + this.restdist) - (o.step + o.restdist);\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tfor(int i = 0 ; i < h; i++){\n\t\t\t\tdata[i]= sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sx = -1, sy = -1;\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tchar c = '0';\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == 'S'){\n\t\t\t\t\t\tdata[i][j] = '.';\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[i][j]== 'X'){\n\t\t\t\t\t\tint res = dfs(i,j, c);\n\t\t\t\t\t\tif(res == 1){\n\t\t\t\t\t\t\tdata[i][j] = '#';\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tlist.add(res / 2);\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\tif(c == 'G' || c == 'S'){\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [] initenter = new int[list.size()];\n\t\t\tfor(int i = 0; i < initenter.length; i++){\n\t\t\t\tinitenter[i] = list.get(i);\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(sx, sy, 0, initenter, calcM(sx,sy)));\n\t\t\tHashSet<String> close = new HashSet<String>();\n\t\t\tclose.add((sy * w + sx)+ \" \"+ getState(initenter));\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x + vx[i];\n\t\t\t\t\tint yy = now.y + vy[i];\n\t\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\t\tif(data[yy][xx] == '#') continue;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tint [] nextenter = (int[]) now.enter.clone();\n\t\t\t\t\tif(data[yy][xx]== 'G' ){\n\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\tflg =true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(data[yy][xx] != '.'){\n\t\t\t\t\t\tint ind = data[yy][xx] - '0';\n\t\t\t\t\t\tif(ind >= ('U' - '0')){\n\t\t\t\t\t\t\tind--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ind >= ('G' - '0')){\n\t\t\t\t\t\t\tind--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nextenter[ind] <= 0) continue;\n\t\t\t\t\t\tnextenter[ind]--;\n\t\t\t\t\t}\n\t\t\t\t\tString nextstate = (yy * w + xx) + \" \" + getState(nextenter);\n\t\t\t\t\tif(close.contains(nextstate))continue;\n\t\t\t\t\topen.add(new State(xx, yy, now.step + 1, nextenter, calcM(xx, yy)));\n\t\t\t\t\tclose.add(nextstate);\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int calcM(int sx, int sy) {\n\t\tint res = Math.abs(sx - gx) + Math.abs(sy - sy);\n\t\treturn res;\n\t}\n\n\tprivate String getState(int [] list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int value: list){\n\t\t\tsb.append(\" \" + value);\n\t\t}\n\t\treturn sb.length() == 0 ? \"\" : sb.substring(1);\n\t}\n\n\tprivate int dfs(int y, int x, char c) {\n\t\tint sum = 1;\n\t\tdata[y][x] = c;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = x + vx[i];\n\t\t\tint yy = y + vy[i];\n\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\tif(data[yy][xx] == 'X'){\n\t\t\t\tsum += dfs(yy,xx,c);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static int H;\n\tpublic static int W;\n\tpublic static int[][] map;\n\tpublic static int[] ices;\n\t\n\tpublic static int[][][] memo = new int[12][12][145];\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(y)]=find(x);\n\t\t}\n\t}\n\t\n\tpublic static int dps(int x, int y, int gx, int gy, int time, int[] using_ice){\n\t\tif(time < 0){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}else if(memo[y][x][time] >= 0){\n\t\t\treturn memo[y][x][time];\n\t\t}else if(x == gx && y == gy){\n\t\t\tmemo[y][x][time] = 0;\n\t\t\treturn memo[y][x][time];\n\t\t}\n\t\t\n\t\tint ret = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int[] move : move_dir){\n\t\t\tfinal int nx = x + move[0];\n\t\t\tfinal int ny = y + move[1];\n\t\t\t\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n\t\t\t\tcontinue;\n\t\t\t}else if(map[ny][nx] == Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tif(ices[map[ny][nx]] / 2 < using_ice[map[ny][nx]] + 1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tusing_ice[map[ny][nx]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tret = Math.min(ret, dps(nx, ny, gx, gy, time - 1, using_ice));\n\t\t\t\n\t\t\tif(map[ny][nx] > 0){\n\t\t\t\tusing_ice[map[ny][nx]]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo[y][x][time] = ret == Integer.MAX_VALUE ? ret : ret + 1;\n\t\treturn memo[y][x][time];\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmap = new int[H][W];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tint gx = -1, gy = -1;\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tif(in[j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'G'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}else if(in[j] == 'X'){\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t}else if(in[j] == '#'){\n\t\t\t\t\t\tmap[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint number = 1;\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x == 0 && y == 0){\n\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t}else if(x == 0){\n\t\t\t\t\t\tif(map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y-1][x];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(y == 0){\n\t\t\t\t\t\tif(map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = map[y][x-1];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfinal int left = map[y][x-1] <= 0 ? Integer.MAX_VALUE : map[y][x-1];\n\t\t\t\t\t\tfinal int up = map[y-1][x] <= 0 ? Integer.MAX_VALUE : map[y-1][x];\n\t\t\t\t\t\tfinal int min = Math.min(left, up);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(min == Integer.MAX_VALUE){\n\t\t\t\t\t\t\tmap[y][x] = number++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmap[y][x] = min;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tUnionFind uf = new UnionFind(73);\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y][x-1]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y][x-1]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y][x-1], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tif(map[y][x] < map[y-1][x]){\n\t\t\t\t\t\t\tuf.unite(map[y][x], map[y-1][x]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuf.unite(map[y-1][x], map[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmap[y][x] = uf.find(map[y][x]);\n\t\t\t\t\tif(x != 0 && map[y][x-1] > 0 && map[y][x-1] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y][x-1] = uf.find(map[y][x-1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(y != 0 && map[y-1][x] > 0 && map[y-1][x] != Integer.MAX_VALUE){\n\t\t\t\t\t\tmap[y-1][x] = uf.find(map[y-1][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSet<Integer> hash = new HashSet<Integer>();\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\thash.add(map[y][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(0);\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>(hash);\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tices = new int[hash.size()];\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmap[y][x] = Collections.binarySearch(list, map[y][x]);\n\t\t\t\t\tices[map[y][x]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tfor(int t = 0; t <= 144; t++){\n\t\t\t\t\t\tmemo[y][x][t] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int y = 0; y < H; y++){\n\t\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\t\tif(y == sy && x == sx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_S\");\n\t\t\t\t\t}else if(y == gy && x == gx){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", \"_G\");\n\t\t\t\t\t}else if(map[y][x] <= 0 || map[y][x] == Integer.MAX_VALUE){\n\t\t\t\t\t\tSystem.out.printf(\"%s\", map[y][x] == 0 ? \"  \" : \"XX\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.printf(\"%02d\", map[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println(Arrays.toString(ices));\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\t*/\n\t\t\tfor(int time = 0; time <= 144; time++){\n\t\t\t\tint ret = dps(sx, sy, gx, gy, time, new int[hash.size()]);\n\t\t\t\tif(ret != Integer.MAX_VALUE){\n\t\t\t\t\tSystem.out.println(ret);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] dist, ice, hit;\n\tint[][] id;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tComparator<Integer> com = new Comparator<Integer>() {\n\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\treturn dist[o1]-dist[o2];\n\t\t}\n\t};\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tboolean f(int i, int j, int depth, int limit){\n\t\tif(limit<depth+dist[i*w+j])return false;\n\t\tif(gi==i&&gj==j){\n\t\t\treturn true;\n\t\t}\n\t\tList<Integer> l = new ArrayList<Integer>(3);\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&!v[ni][nj])l.add(ni*w+nj);\n\t\t}\n\t\tCollections.sort(l, com);\n\t\tfor(int V:l){\n\t\t\tint ni = V/w, nj = V%w;\n\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\tv[ni][nj] = true;\n\t\t\t\tif(f(ni, nj, depth+1, limit))return true;\n\t\t\t\tv[ni][nj] = false;\n\t\t\t\thit[id[ni][nj]]--;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tdist = new int[144];\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[gi*w+gj] = 0;\n\t\t\tQueue<Integer> que = new LinkedList<Integer>();\n\t\t\tque.add(gi*w+gj);\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V = que.poll();\n\t\t\t\tint pi = V/w, pj = V%w;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'&&dist[ni*w+nj]==INF){\n\t\t\t\t\t\tdist[ni*w+nj] = dist[V]+1;\n\t\t\t\t\t\tque.add(ni*w+nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h][w];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID++);\n\t\t\t}\n\t\t\tint L = 1, R = h*w;\n\t\t\twhile(R-L>1){\n\t\t\t\tint M = (L+R)/2;\n\t\t\t\tArrays.fill(hit, 0);\n\t\t\t\tv = new boolean[h][w];\n\t\t\t\tv[si][sj] = true;\n\t\t\t\tif(f(si, sj, 0, M))R=M;\n\t\t\t\telse L=M;\n\t\t\t}\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tSystem.out.println(f(si, sj, 0, L)?L:R);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Ice Maze\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, INF = 1<<29, res;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] ice, hit;\n\tint[][] id, dist;\n\tchar[][] m;\n\tboolean[][] v;\n\t\n\tvoid mark(int i, int j, int x){\n\t\tid[i][j] = x;\n\t\tice[x]++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(m[ni][nj]=='X'&&id[ni][nj]==0)mark(ni, nj, x);\n\t\t}\n\t}\n\t\n\tvoid f(int i, int j, int depth){\n\t\tif(res<=depth+dist[i][j])return;\n\t\tif(gi==i && gj==j){\n\t\t\tres = Math.min(res, depth); return;\n\t\t}\n\t\tint c = 0;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(v[ni][nj])c++;\n\t\t}\n\t\tif(2 <= c)return;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+d[k][0], nj = j+d[k][1];\n\t\t\tif(!v[ni][nj]&&m[ni][nj]!='#'){\n\t\t\t\tif(ice[id[ni][nj]]>>1 >= hit[id[ni][nj]]+1){\n\t\t\t\t\thit[id[ni][nj]]++;\n\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\tf(ni, nj, depth+1);\n\t\t\t\t\tv[ni][nj] = false;\n\t\t\t\t\thit[id[ni][nj]]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tice = new int[144];\n\t\thit = new int[144];\n\t\tdist = new int[14][14];\n\t\tm = new char[14][14];\n\t\tv = new boolean[14][14];\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tfor(int i=0;i<h+2;i++)for(int j=0;j<w+2;j++){\n\t\t\t\tdist[i][j] = INF;\n\t\t\t\tv[i][j] = false;\n\t\t\t\tm[i][j] = '#';\n\t\t\t}\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tm[i][j] = c[j-1];\n\t\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\t\tm[i][j] = '.'; si = i; sj = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\t\tm[i][j] = '.'; gi = i; gj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(ice, 0);\n\t\t\tice[0] = INF;\n\t\t\tid = new int[h+2][w+2];\n\t\t\tint ID = 1;\n\t\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++){\n\t\t\t\tif(m[i][j]!='X'||id[i][j]>0)continue;\n\t\t\t\tmark(i, j, ID);\n\t\t\t\tif(ice[ID]==1){\n\t\t\t\t\tm[i][j] = '#';\n\t\t\t\t}\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tdist[gi][gj] = 0;\n\t\t\tQueue<int[]> que = new LinkedList<int[]>();\n\t\t\tque.add(new int[]{gi, gj});\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint V[] = que.poll();\n\t\t\t\tint pi = V[0], pj = V[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(m[ni][nj]!='#'&&dist[ni][nj]==INF){\n\t\t\t\t\t\tdist[ni][nj] = dist[pi][pj]+1;\n\t\t\t\t\t\tque.add(new int[]{ni, nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = INF;\n\t\t\tArrays.fill(hit, 0);\n\t\t\tv[si][sj] = true;\n\t\t\tf(si, sj, 0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static Dictionary<int, int> iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Count + 1];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!iceCnts.ContainsKey(cnt)) iceCnts.Add(cnt, 0);\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            if (CalcEValue(i, j, cost) <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static private int CalcEValue(int i, int j, int cost)\n        {\n            return cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static Dictionary<int, int> iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < map.Length; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            visited = new bool[xy[1], xy[0]];\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Count + 1];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!iceCnts.ContainsKey(cnt)) iceCnts.Add(cnt, 0);\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            if (CalcEValue(i, j, cost) <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static private int CalcEValue(int i, int j, int cost)\n        {\n            return cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, 1, 0, -1 };\n        static readonly int[] dj = new int[] { 1, 0, -1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n            int num = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        SetIceDFS(i, j, num);\n                        num++;\n                    }\n                }\n            }\n        }\n\n        private static void SetIceDFS(int i, int j, int num)\n        {\n            map[i, j] = num;\n            iceCnts[num]++;\n            for (int k = 0; k < di.Length; k++)\n            {\n                int nI = i + di[k];\n                int nJ = j + dj[k];\n                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                SetIceDFS(nI, nJ, num);\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            int eValue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            if (eValue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n            int num = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        SetIceDFS(i, j, num);\n                        num++;\n                    }\n                }\n            }\n        }\n\n        private static void SetIceDFS(int i, int j, int num)\n        {\n            map[i, j] = num;\n            iceCnts[num]++;\n            for (int k = 0; k < di.Length; k++)\n            {\n                int nI = i + di[k];\n                int nJ = j + dj[k];\n                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                SetIceDFS(nI, nJ, num);\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            int eValue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            if (eValue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n\n            int cnt = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            if (CalcEValue(i, j, cost) <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static private int CalcEValue(int i, int j, int cost)\n        {\n            return cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static Dictionary<int, int> iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < map.Length; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            visited = new bool[xy[1], xy[0]];\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Count + 1];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!iceCnts.ContainsKey(cnt)) iceCnts.Add(cnt, 0);\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            if (CalcEValue(i, j, cost) <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static private int CalcEValue(int i, int j, int cost)\n        {\n            return cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, 1, 0, -1 };\n        static readonly int[] dj = new int[] { 1, 0, -1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n            int num = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        SetIceDFS(i, j, num);\n                        num++;\n                    }\n                }\n            }\n        }\n\n        private static void SetIceDFS(int i, int j, int num)\n        {\n            map[i, j] = num;\n            iceCnts[num]++;\n            for (int k = 0; k < di.Length; k++)\n            {\n                int nI = i + di[k];\n                int nJ = j + dj[k];\n                if (!(0 <= nI && nI < h && 0 <= nJ && nJ < w) || map[nI, nJ] != (int)Field.Ice) continue;\n                SetIceDFS(nI, nJ, num);\n            }\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            int eValue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            if (eValue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!(0 <= nI && nI < h && 0 <= nJ && nJ < w) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        //enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = -2;\n                            break;\n                        case 'X':\n                            map[i, j] = -1;\n                            break;\n                        default:\n                            map[i, j] = -3;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n            int num = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == -1)\n                    {\n                        SetIceDFS(i, j, num);\n                        num++;\n                    }\n                }\n            }\n        }\n\n        private static void SetIceDFS(int i, int j, int num)\n        {\n            map[i, j] = num;\n            iceCnts[num]++;\n            for (int k = 0; k < di.Length; k++)\n            {\n                int nI = i + di[k];\n                int nJ = j + dj[k];\n                if (!IsInArea(nI, nJ) || map[nI, nJ] != -1) continue;\n                SetIceDFS(nI, nJ, num);\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            int eValue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            if (eValue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == -2 || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != -3)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        class State : IComparable<State>\n        {\n            public int I { get; set; }\n            public int J { get; set; }\n            public int Cost { get; set; }\n            public int Evalue { get; set; }\n            public Dictionary<int, int> PassedIce { get; set; }\n            public State(int i, int j, int cost, Dictionary<int, int> passedIce)\n            {\n                I = i;\n                J = j;\n                Cost = cost;\n                Evalue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n                PassedIce = passedIce;\n            }\n            public int CompareTo(State other)\n            {\n                return other.Evalue - Evalue;\n            }\n        }\n\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static Dictionary<int, int> IceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n                visited = new bool[map.GetLength(0), map.GetLength(1)];\n                for (int i = 0; i < map.Length; i++)\n                {                 \n                    if (CalcMinCost(i, new State(sI, sJ, 0, new Dictionary<int, int>())))\n                    {\n                        Console.WriteLine(i);\n                        break;\n                    }\n                }               \n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n        }\n\n        private static void SetIce()\n        {\n            IceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!IceCnts.ContainsKey(cnt)) IceCnts.Add(cnt, 0);\n                            IceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        private static bool CalcMinCost(int u, State cur)\n        {\n            if (cur.I == gI && cur.J == gJ) return true;\n            visited[cur.I, cur.J] = true;\n            if (cur.Evalue <= u)\n            {\n\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = cur.I + di[k];\n                    int nJ = cur.J + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    Dictionary<int, int> nPassedIce = new Dictionary<int, int>(cur.PassedIce);\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if (!nPassedIce.ContainsKey(iceIdx)) nPassedIce.Add(iceIdx, 0);\n                        nPassedIce[iceIdx]++;\n                        if (nPassedIce[iceIdx] * 2 > IceCnts[iceIdx]) continue;\n                    }\n\n                    visited[nI, nJ] = true;\n                    if(CalcMinCost(u, new State(nI, nJ, cur.Cost + 1, nPassedIce))) return true;\n                    visited[nI, nJ] = false;\n                }\n            }\n            visited[cur.I, cur.J] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n\n            int cnt = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            if (CalcEValue(i, j, cost) <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static private int CalcEValue(int i, int j, int cost)\n        {\n            return cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        //enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n            int num = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        SetIceDFS(i, j, num);\n                        num++;\n                    }\n                }\n            }\n        }\n\n        private static void SetIceDFS(int i, int j, int num)\n        {\n            map[i, j] = num;\n            iceCnts[num]++;\n            for (int k = 0; k < di.Length; k++)\n            {\n                int nI = i + di[k];\n                int nJ = j + dj[k];\n                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                SetIceDFS(nI, nJ, num);\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            int eValue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            if (eValue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        class State : IComparable<State>\n        {\n            public int I { get; set; }\n            public int J { get; set; }\n            public int Cost { get; set; }\n            public int Evalue { get; set; }\n            public State(int i, int j, int cost)\n            {\n                I = i;\n                J = j;\n                Cost = cost;\n                Evalue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            }\n            public int CompareTo(State other)\n            {\n                return other.Evalue - Evalue;\n            }\n        }\n\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static Dictionary<int, int> iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int i = 0; i < map.Length; i++)\n                {\n                    if (CalcMinCost(i, new State(sI, sJ, 0)))\n                    {\n                        Console.WriteLine(i);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            visited = new bool[xy[1], xy[0]];\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Count + 1];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!iceCnts.ContainsKey(cnt)) iceCnts.Add(cnt, 0);\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        private static bool CalcMinCost(int u, State cur)\n        {\n            if (cur.I == gI && cur.J == gJ)\n            {\n                return true;\n            }\n\n            visited[cur.I, cur.J] = true;\n            if (cur.Evalue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = cur.I + di[k];\n                    int nJ = cur.J + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, new State(nI, nJ, cur.Cost + 1))) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, new State(nI, nJ, cur.Cost + 1))) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[cur.I, cur.J] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static Dictionary<int, int> iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < map.Length; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Count + 1];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!iceCnts.ContainsKey(cnt)) iceCnts.Add(cnt, 0);\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            if (CalcEValue(i, j, cost) <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static private int CalcEValue(int i, int j, int cost)\n        {\n            return cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n\n            int cnt = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            int eValue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            if (eValue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        class State : IComparable<State>\n        {\n            public int I { get; set; }\n            public int J { get; set; }\n            public int Cost { get; set; }\n            public int Evalue { get; set; }\n            public HashSet<int> Pass { get; set; }\n            public Dictionary<int, int> PassedIce { get; set; }\n            public State(int i, int j, int cost, Dictionary<int, int> passedIce, HashSet<int> pass)\n            {\n                I = i;\n                J = j;\n                Cost = cost;\n                Evalue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n                PassedIce = passedIce;\n                Pass = pass;\n                Pass.Add(GetCellID(i, j));\n            }\n            public int CompareTo(State other)\n            {\n                return other.Evalue - Evalue;\n            }\n        }\n\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static Dictionary<int, int> IceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                int res = 0;\n                for (int i = 0; i < map.GetLength(0) * map.GetLength(1); i++)\n                {\n                    res = CalcMinCost(i);\n                    if (res > 0) break;\n                }\n                Console.WriteLine(res);\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n        }\n\n        private static void SetIce()\n        {\n            IceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!IceCnts.ContainsKey(cnt)) IceCnts.Add(cnt, 0);\n                            IceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        private static int CalcMinCost(int i)\n        {\n            Stack<State> s = new Stack<State>();\n            s.Push(new State(sI, sJ, 0, new Dictionary<int, int>(), new HashSet<int>()));\n\n            while (s.Count > 0)\n            {\n                State cur = s.Pop();\n                if (cur.I == gI && cur.J == gJ) return cur.Cost;\n                if (cur.Evalue > i) continue;\n\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = cur.I + di[k];\n                    int nJ = cur.J + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || cur.Pass.Contains(GetCellID(nI, nJ))) continue;\n\n                    Dictionary<int, int> nPassedIce = new Dictionary<int, int>(cur.PassedIce);\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if (!nPassedIce.ContainsKey(iceIdx)) nPassedIce.Add(iceIdx, 0);\n                        nPassedIce[iceIdx]++;\n                        if (nPassedIce[iceIdx] * 2 > IceCnts[iceIdx]) continue;\n                    }\n                    s.Push(new State(nI, nJ, cur.Cost + 1, nPassedIce, new HashSet<int>(cur.Pass)));\n                }\n            }\n            return 0;\n        }\n\n        private static int GetCellID(int i, int j)\n        {\n            return i * map.GetLength(1) + j;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = 0, Mountain = -1, Ice = 99 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static Dictionary<int, int> iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n\n                for (int u = CalcEValue(sI, sJ, 0); u < map.Length; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            map = new int[xy[1], xy[0]];\n            visited = new bool[xy[1], xy[0]];\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Count + 1];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new Dictionary<int, int>();\n\n            int cnt = 1;\n            for (int i = 0; i < map.GetLength(0); i++)\n            {\n                for (int j = 0; j < map.GetLength(1); j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                        q.Enqueue(new Tuple<int, int>(i, j));\n                        while (q.Count() > 0)\n                        {\n                            var cur = q.Dequeue();\n                            if (map[cur.Item1, cur.Item2] != (int)Field.Ice) continue;\n\n                            map[cur.Item1, cur.Item2] = cnt;\n                            if (!iceCnts.ContainsKey(cnt)) iceCnts.Add(cnt, 0);\n                            iceCnts[cnt]++;\n\n                            for (int k = 0; k < di.Length; k++)\n                            {\n                                int nI = cur.Item1 + di[k];\n                                int nJ = cur.Item2 + dj[k];\n                                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                                q.Enqueue(new Tuple<int, int>(nI, nJ));\n                            }\n                        }\n                        cnt++;\n                    }\n                }\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < map.GetLength(0) && 0 <= j && j < map.GetLength(1);\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            if (CalcEValue(i, j, cost) <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static private int CalcEValue(int i, int j, int cost)\n        {\n            return cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0247\n{\n    class Program\n    {\n        enum Field { Plain = -3, Mountain = -2, Ice = -1 }\n        static readonly int[] di = new int[] { 0, -1, 0, 1 };\n        static readonly int[] dj = new int[] { -1, 0, 1, 0 };\n\n        static int h, w;\n        static int sI, sJ, gI, gJ;\n        static int[,] map;\n        static bool[,] visited;\n        static int[] passedIce;\n        static int[] iceCnts;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] xy = RArInt();\n                if (xy.Sum() == 0) break;\n                Init(xy);\n                for (int u = 0; u < h * w; u++)\n                {\n                    if (CalcMinCost(u, sI, sJ, 0))\n                    {\n                        Console.WriteLine(u);\n                        break;\n                    }\n                }\n            }\n        }\n\n        private static void Init(int[] xy)\n        {\n            w = xy[0]; h = xy[1];\n            map = new int[h, w];\n            visited = new bool[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                string ms = RSt();\n                for (int j = 0; j < w; j++)\n                {\n                    switch (ms[j])\n                    {\n                        case '#':\n                            map[i, j] = (int)Field.Mountain;\n                            break;\n                        case 'X':\n                            map[i, j] = (int)Field.Ice;\n                            break;\n                        default:\n                            map[i, j] = (int)Field.Plain;\n                            if (ms[j] == 'S') { sI = i; sJ = j; }\n                            else if (ms[j] == 'G') { gI = i; gJ = j; }\n                            break;\n                    }\n                }\n            }\n            SetIce();\n            passedIce = new int[iceCnts.Length];\n        }\n\n        private static void SetIce()\n        {\n            iceCnts = new int[100];\n            int num = 0;\n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    if (map[i, j] == (int)Field.Ice)\n                    {\n                        SetIceDFS(i, j, num);\n                        num++;\n                    }\n                }\n            }\n        }\n\n        private static void SetIceDFS(int i, int j, int num)\n        {\n            map[i, j] = num;\n            iceCnts[num]++;\n            for (int k = 0; k < di.Length; k++)\n            {\n                int nI = i + di[k];\n                int nJ = j + dj[k];\n                if (!IsInArea(nI, nJ) || map[nI, nJ] != (int)Field.Ice) continue;\n                SetIceDFS(nI, nJ, num);\n            }\n        }\n\n        private static bool IsInArea(int i, int j)\n        {\n            return 0 <= i && i < h && 0 <= j && j < w;\n        }\n\n        private static bool CalcMinCost(int u, int i, int j, int cost)\n        {\n            if (i == gI && j == gJ)\n            {\n                return true;\n            }\n\n            visited[i, j] = true;\n            int eValue = cost + Math.Abs(i - gI) + Math.Abs(j - gJ);\n            if (eValue <= u)\n            {\n                for (int k = 0; k < di.Length; k++)\n                {\n                    int nI = i + di[k];\n                    int nJ = j + dj[k];\n                    if (!IsInArea(nI, nJ) || map[nI, nJ] == (int)Field.Mountain || visited[nI, nJ]) continue;\n\n                    if (map[nI, nJ] != (int)Field.Plain)\n                    {\n                        int iceIdx = map[nI, nJ];\n                        if ((passedIce[iceIdx] + 1) * 2 <= iceCnts[iceIdx])\n                        {\n                            passedIce[iceIdx]++;\n                            visited[nI, nJ] = true;\n                            if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                            visited[nI, nJ] = false;\n                            passedIce[iceIdx]--;\n                        }\n                    }\n                    else\n                    {\n                        visited[nI, nJ] = true;\n                        if (CalcMinCost(u, nI, nJ, cost + 1)) return true;\n                        visited[nI, nJ] = false;\n                    }\n                }\n            }\n            visited[i, j] = false;\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### main\n\nwhile true\n  $w, $h = gets.strip.split(' ').map{|s| s.to_i}\n  $wh = $w * $h\n  break if $w == 0 && $h == 0\n\n  start = nil\n  goal = nil\n  brds = []\n\n  for y in (0...$h)\n    hl = gets.strip\n    for x in (0...$w)\n      pos = y * $w + x\n      case hl[x]\n      when '.'\n        brds[pos] = -1\n      when '#'\n        brds[pos] = nil\n      when 'X'\n        brds[pos] = 'X'\n      when 'S'\n        start = pos\n        brds[pos] = -1\n      when 'G'\n        goal = pos\n        brds[pos] = -1\n      end\n    end\n  end\n\n  nice = 0\n  ices = []\n\n  for y in (0...$h)\n    for x in (0...$w)\n      pos = y * $w + x\n      if brds[pos] == 'X'\n        ices[nice] = 1\n        brds[pos] = nice\n        q = [pos]\n\n        while ! q.empty?\n          pos0 = q.shift\n          x0 = pos0 % $w\n          y0 = pos0 / $w\n\n          for dxy in DXYS\n            x1 = x0 + dxy[0]\n            y1 = y0 + dxy[1]\n            pos1 = y1 * $w + x1\n            if x1 >= 0 && x1 < $w && y1 >= 0 && y1 < $h && brds[pos1] == 'X'\n              ices[nice] += 1\n              brds[pos1] = nice\n              q << pos1\n            end\n          end\n        end\n\n        nice += 1\n      end\n    end\n  end\n\n  ices.map!{|k| k / 2 }\n\n  #p brds\n  #p ices\n\n  dists = $wh.times.map{Hash.new(MAX_INT)}\n  dists[start][ices] = 0\n  q = [[start, ices]]\n\n  while ! q.empty?\n    #p q\n\n    nd = q.min{|a, b| dists[a[0]][a[1]] <=> dists[b[0]][b[1]]}\n    q.delete nd\n\n    pos, ics = nd\n    break if pos == goal\n\n    x = pos % $w\n    y = pos / $w\n\n    for dxy in DXYS\n      x0 = x + dxy[0]\n      y0 = y + dxy[1]\n\n      if x0 >= 0 && x0 < $w && y0 >= 0 && y0 < $h\n        pos0 = y0 * $w + x0\n        ic = brds[pos0]\n        next if ic.nil?\n\n        if ic >= 0\n          next if ics[ic] <= 0\n          ics0 = ics.clone\n          ics0[ic] -= 1\n        else\n          ics0 = ics\n        end\n\n        d0 = dists[pos][ics] + 1\n        if dists[pos0][ics0] > d0\n          dists[pos0][ics0] = d0\n          q << [pos0, ics0]\n        end\n      end\n    end\n  end\n  #p dists\n\n  puts dists[goal].values.min\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### main\n\nwhile true\n  $w, $h = gets.strip.split(' ').map{|s| s.to_i}\n  break if $w == 0 && $h == 0\n\n  start = nil\n  goal = nil\n\n  brds = $h.times.map{[]}\n\n  for y in (0...$h)\n    hl = gets.strip\n    for x in (0...$w)\n      case hl[x]\n      when '.'\n        brds[y][x] = -1\n      when '#'\n        brds[y][x] = nil\n      when 'X'\n        brds[y][x] = 'X'\n      when 'S'\n        start = [x, y]\n        brds[y][x] = -1\n      when 'G'\n        goal = [x, y]\n        brds[y][x] = -1\n      end\n    end\n  end\n\n  nice = 0\n  ices = []\n\n  for y in (0...$h)\n    for x in (0...$w)\n      if brds[y][x] == 'X'\n        ices[nice] = 1\n        brds[y][x] = nice\n        q = [[x, y]]\n\n        while ! q.empty?\n          x0, y0 = q.shift\n\n          for dxy in DXYS\n            x1 = x0 + dxy[0]\n            y1 = y0 + dxy[1]\n            if x1 >= 0 && x1 < $w && y1 >= 0 && y1 < $h && brds[y1][x1] == 'X'\n              ices[nice] += 1\n              brds[y1][x1] = nice\n              q << [x1, y1]\n            end\n          end\n        end\n\n        nice += 1\n      end\n    end\n  end\n\n  ices.map!{|k| k / 2 }\n\n  #p brds\n  #p ices\n\n  dists = $h.times.map{$w.times.map{Hash.new(MAX_INT)}}\n  dists[start[1]][start[0]][ices] = 0\n  q = [start + [ices]]\n\n  while ! q.empty?\n    #p q\n\n    xy = q.min{|a, b| dists[a[1]][a[0]][a[2]] <=> dists[b[1]][b[0]][b[2]]}\n    q.delete xy\n\n    break if xy == goal\n\n    x, y, ics = xy\n\n    for dxy in DXYS\n      x0 = x + dxy[0]\n      y0 = y + dxy[1]\n\n      if x0 >= 0 && x0 < $w && y0 >= 0 && y0 < $h\n        ic = brds[y0][x0]\n        next if ic.nil?\n\n        if ic >= 0\n          next if ics[ic] <= 0\n          ics0 = ics.clone\n          ics0[ic] -= 1\n        else\n          ics0 = ics\n        end\n\n        d0 = dists[y][x][ics] + 1\n        if dists[y0][x0][ics0] > d0\n          dists[y0][x0][ics0] = d0\n          q << [x0, y0, ics0]\n        end\n      end\n    end\n  end\n  #p dists\n\n  gx, gy = goal\n  puts dists[gy][gx].values.min\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e){\n\tm[e[1]][e[0]] = 1;\n\tint cnt = 1;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tcnt += XSize(neo.a2P);\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint d(P a, P b){\n\timport std.math;\n\tint sum;\n\tint[] a_ = a.P2a;\n\ta_[]-=b.P2a[];\n\tforeach(i; a_){\n\t\tsum += cast(int)(sqrt(cast(double)(i*i)));\n\t}\n\treturn sum;\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){return cnt;}\n\tif(minist <= cnt + d(e, g)){\n\t\treturn int.max;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tint res = int.max;\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin_ = min(min_, res);\n\t\t\t\tminist = min(minist, min_);\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\t\n\treturn min_;\n}\n\nbool dfs(P e, int cnt, int n){\n\tif(cnt==n){\n\t\treturn e==g;\n\t}\n\tif(cnt+d(e, g) > n){\n\t\treturn false;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn false;\n\t}\n\tforeach(i; ofs){\n\t\tbool res = false;\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res)return true;\n\t}\n\t\n\treturn false;\n}\n\nint iddfs(){\n\tint n = d(s, g);\n\tdone[s[1]][s[0]] = true;\n\twhile(!dfs(s, 0, n)){++n;}\n\treturn n;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = l['X'];\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = (XSize(P(j, i))/2)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tdfs(s, 0).writeln;\n\t\tiddfs().writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e, int cnt){\n\tm[e[1]][e[0]] = 1;\n\tint max_ = cnt;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tmax_ = max(max_, XSize(neo.a2P, cnt+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn max_;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint d(P a, P b){\n\timport std.math;\n\tint sum;\n\tint[] a_ = a.P2a;\n\ta_[]-=b.P2a[];\n\tforeach(i; a_){\n\t\tsum += cast(int)(sqrt(cast(double)(i*i)));\n\t}\n\treturn sum;\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){return cnt;}\n\tif(minist <= cnt + d(e, g)){\n\t\treturn int.max;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tint res = int.max;\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin_ = min(min_, res);\n\t\t\t\tminist = min(minist, min_);\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\t\n\treturn min_;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = 1;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = cast(int)(cast(double)(XSize(P(j, i), 1))/2.)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(s, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e){\n\tm[e[1]][e[0]] = 1;\n\tint cnt = 1;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tcnt += XSize(neo.a2P);\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint d(P a, P b){\n\timport std.math;\n\tint sum;\n\tint[] a_ = a.P2a;\n\ta_[]-=b.P2a[];\n\tforeach(i; a_){\n\t\tsum += cast(int)(sqrt(cast(double)(i*i)));\n\t}\n\treturn sum;\n}\n\nint[P[2]] bfs(P s){\n\tint[][] foot;\n\tforeach(i; y.iota){ foot ~= repeat(-1).take(x).array; }\n\t\n\tfoot[s[1]][s[0]] = 0;\n\tP[] q = [s];\n\twhile(q.length>0){\n\t\tP e = q.front;  q.popFront;\n\t\tforeach(i; ofs){\n\t\t\tauto neo_ = e.P2a;\n\t\t\tneo_[]+=i.P2a[];\n\t\t\tauto neo = neo_.a2P;\n\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] == 0 && foot[neo[1]][neo[0]]==-1){\n\t\t\t\t\tfoot[neo[1]][neo[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\tq ~= neo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdebug(1){\n\t\tforeach(i; y.iota){\n\t\t\tfoot[i].dbg;\n\t\t}\n\t\tforeach(i; y.iota){\n\t\t\tdone[i].dbg;\n\t\t}\n\t}\n\t\n\tint[P[2]] req;\n\tforeach(i; y.iota){\n\t\tforeach(j; x.iota){\n\t\t\tif(foot[i][j] >= 0){\n\t\t\t\tforeach(ite; ofs){\n\t\t\t\t\tint[2] v = [j, i];\n\t\t\t\t\tv[]+=ite.P2a[];\n\t\t\t\t\tauto neo = v.a2P;\n\t\t\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] > 0){\n\t\t\t\t\t\t\t/+\n\t\t\t\t\t\t\tif((neo in req)==null){\n\t\t\t\t\t\t\t\treq[neo] = foot[i][j] + 1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\treq[neo] = min(req[neo], foot[i][j]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t+/\n\t\t\t\t\t\t\treq[ [neo, P(j, i)] ] = foot[i][j] + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(P(j, i)==g){\n//\t\t\t\t\tassert((P(j, i) in req)==null);\n\t\t\t\t\treq[ [P(j, i), P(j, i)] ] = foot[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn req;\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){\n\t\treturn cnt;\n\t}\n\tif(minist <= cnt+d(e, g)){\n\t\treturn int.max;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tint[P[2]] req = bfs(e);\n\tforeach(P[2] ps, int n; req){\n\t\tP p = ps.front;\n\t\tP pp = ps.back;\n\t\tdebug(1){\n\t\t\tdbg(p.P2a, pp.P2a, n);\n\t\t}\n\t\tif(!done[p[1]][p[0]]){\n\t\t\tdone[pp[1]][pp[0]] = true;\n\t\t\tint res = int.max;\n\t\t\tif(m[p[1]][p[0]]==0){\n\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t}else if(m[p[1]][p[0]] > 1){\n\t\t\t\tif(f[m[p[1]][p[0]]] > 1){\n\t\t\t\t\t--f[m[p[1]][p[0]]];\n\t\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t\t\t++f[m[p[1]][p[0]]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin_ = min(min_, res);\n\t\t\tminist = min(minist, min_);\n\n\t\t\tdone[pp[1]][pp[0]] = false;\n\t\t}else{\n\t\t\tdebug(1){\n\t\t\t\tdbg = \"done\";\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\treturn min_;\n}\n\nbool dfs(P e, int cnt, int n){\n\tif(cnt==n){\n\t\treturn e==g;\n\t}\n\tif(cnt+d(e, g) > n){\n\t\treturn false;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn false;\n\t}\n\tforeach(i; ofs){\n\t\tbool res = false;\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res)return true;\n\t}\n\t\n\treturn false;\n}\n\nint iddfs(){\n\tint n = d(s, g);\n\tdone[s[1]][s[0]] = true;\n\twhile(!dfs(s, 0, n)){++n;}\n\treturn n;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = l['X'];\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = (XSize(P(j, i))/2)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(s, 0).writeln;\n//\t\tiddfs().writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e){\n\tm[e[1]][e[0]] = 1;\n\tint cnt = 1;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tcnt += XSize(neo.a2P);\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint d(P a, P b){\n\timport std.math;\n\tint sum;\n\tint[] a_ = a.P2a;\n\ta_[]-=b.P2a[];\n\tforeach(i; a_){\n\t\tsum += cast(int)(sqrt(cast(double)(i*i)));\n\t}\n\treturn sum;\n}\n\nint[P] bfs(P s){\n\tint[][] foot;\n\tforeach(i; y.iota){ foot ~= repeat(-1).take(x).array; }\n\t\n\tfoot[s[1]][s[0]] = 0;\n\tP[] q = [s];\n\twhile(q.length>0){\n\t\tP e = q.front;  q.popFront;\n\t\tforeach(i; ofs){\n\t\t\tauto neo_ = e.P2a;\n\t\t\tneo_[]+=i.P2a[];\n\t\t\tauto neo = neo_.a2P;\n\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] == 0 && foot[neo[1]][neo[0]]==-1){\n\t\t\t\t\tfoot[neo[1]][neo[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\tq ~= neo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint[P] req;\n\tforeach(i; y.iota){\n\t\tforeach(j; x.iota){\n\t\t\tif(foot[i][j] >= 0){\n\t\t\t\tforeach(ite; ofs){\n\t\t\t\t\tint[2] v = [j, i];\n\t\t\t\t\tv[]+=ite.P2a[];\n\t\t\t\t\tauto neo = v.a2P;\n\t\t\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] > 0){\n\t\t\t\t\t\t\tif((neo in req)==null){\n\t\t\t\t\t\t\t\treq[neo] = foot[i][j] + 1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\treq[neo] = min(req[neo], foot[i][j]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(P(j, i)==g){\n\t\t\t\t\tassert((P(j, i) in req)==null);\n\t\t\t\t\treq[P(j, i)] = foot[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn req;\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){\n\t\treturn cnt;\n\t}\n\tif(minist <= cnt+d(e, g)){\n\t\treturn int.max;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tint[P] req = bfs(e);\n\tforeach(P p, int n; req){\n\t\tif(!done[p[1]][p[0]]){\n\t\t\tint res = int.max;\n\t\t\tif(m[p[1]][p[0]]==0){\n\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t}else if(m[p[1]][p[0]] > 1){\n\t\t\t\tif(f[m[p[1]][p[0]]] > 1){\n\t\t\t\t\t--f[m[p[1]][p[0]]];\n\t\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t\t\t++f[m[p[1]][p[0]]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin_ = min(min_, res);\n\t\t\tminist = min(minist, min_);\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\treturn min_;\n}\n\nbool dfs(P e, int cnt, int n){\n\tif(cnt==n){\n\t\treturn e==g;\n\t}\n\tif(cnt+d(e, g) > n){\n\t\treturn false;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn false;\n\t}\n\tforeach(i; ofs){\n\t\tbool res = false;\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res)return true;\n\t}\n\t\n\treturn false;\n}\n\nint iddfs(){\n\tint n = d(s, g);\n\tdone[s[1]][s[0]] = true;\n\twhile(!dfs(s, 0, n)){++n;}\n\treturn n;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = l['X'];\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = (XSize(P(j, i))/2)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(s, 0).writeln;\n//\t\tiddfs().writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e, int cnt){\n\tm[e[1]][e[0]] = 1;\n\tint max_ = cnt;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tmax_ = max(max_, XSize(neo.a2P, cnt+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn max_;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){return cnt;}\n\tif(minist < cnt){\n\t\treturn cnt;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tint res = int.max;\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin_ = min(min_, res);\n\t\t\t\tminist = min(minist, min_);\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\t\n\treturn min_;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = 1;\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = cast(int)(cast(double)(XSize(P(j, i), 1))/2.)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(s, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\nP[] shuffle_ofs(){\n\timport std.random;\n\tint[] s = (cast(int)(ofs.length)).iota.array;\n\tP[] p;\n\twhile(s.length>0){\n\t\tint i = uniform(0, s.length);\n\t\tp ~= ofs[s[i]];\n\t\tint[] s_;\n\t\tforeach(ite; s){\n\t\t\tif(ite!=s[i]){\n\t\t\t\ts_ ~= ite;\n\t\t\t}\n\t\t}\n\t\ts = s_;\n\t}\n\t\n\treturn p;\n}\n\nP s;\nP g;\n\nint XSize(P e){\n\tm[e[1]][e[0]] = 1;\n\tint cnt = 1;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tcnt += XSize(neo.a2P);\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint d(P a, P b){\n\timport std.math;\n\tint sum;\n\tint[] a_ = a.P2a;\n\ta_[]-=b.P2a[];\n\tforeach(i; a_){\n\t\tsum += cast(int)(sqrt(cast(double)(i*i)));\n\t}\n\treturn sum;\n}\n\nint[P] bfs(P s){\n\tint[][] foot;\n\tforeach(i; y.iota){ foot ~= repeat(-1).take(x).array; }\n\t\n\tfoot[s[1]][s[0]] = 0;\n\tP[] q = [s];\n\twhile(q.length>0){\n\t\tP e = q.front;  q.popFront;\n\t\tforeach(i; ofs){\n\t\t\tauto neo_ = e.P2a;\n\t\t\tneo_[]+=i.P2a[];\n\t\t\tauto neo = neo_.a2P;\n\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] == 0 && foot[neo[1]][neo[0]]==-1){\n\t\t\t\t\tfoot[neo[1]][neo[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\tq ~= neo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint[P] req;\n\tforeach(i; y.iota){\n\t\tforeach(j; x.iota){\n\t\t\tif(foot[i][j] >= 0){\n\t\t\t\tforeach(ite; ofs){\n\t\t\t\t\tint[2] v = [j, i];\n\t\t\t\t\tv[]+=ite.P2a[];\n\t\t\t\t\tauto neo = v.a2P;\n\t\t\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] > 0){\n\t\t\t\t\t\t\tif((neo in req)==null){\n\t\t\t\t\t\t\t\treq[neo] = foot[i][j] + 1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\treq[neo] = min(req[neo], foot[i][j]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(P(j, i)==g){\n\t\t\t\t\tassert((P(j, i) in req)==null);\n\t\t\t\t\treq[P(j, i)] = foot[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn req;\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){\n\t\treturn cnt;\n\t}\n\tif(minist <= cnt+d(e, g)){\n\t\treturn int.max;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tint[P] req = bfs(e);\n\tforeach(P p, int n; req){\n\t\tif(!done[p[1]][p[0]]){\n\t\t\tint res = int.max;\n\t\t\tif(m[p[1]][p[0]]==0){\n\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t}else if(m[p[1]][p[0]] > 1){\n\t\t\t\tif(f[m[p[1]][p[0]]] > 1){\n\t\t\t\t\t--f[m[p[1]][p[0]]];\n\t\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t\t\t++f[m[p[1]][p[0]]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin_ = min(min_, res);\n\t\t\tminist = min(minist, min_);\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\treturn min_;\n}\n\nbool dfs(P e, int cnt, int n){\n\tif(cnt==n){\n\t\treturn e==g;\n\t}\n\tif(cnt+d(e, g) > n){\n\t\treturn false;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn false;\n\t}\n\tforeach(i; shuffle_ofs){\n\t\tbool res = false;\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res)return true;\n\t}\n\t\n\treturn false;\n}\n\nint iddfs(){\n\tint n = d(s, g);\n\tdone[s[1]][s[0]] = true;\n\twhile(!dfs(s, 0, n)){++n;}\n\treturn n;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = l['X'];\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = (XSize(P(j, i))/2)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(s, 0).writeln;\n//\t\tiddfs().writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nint[][] f;\nbool[][] done;\nint x;\nint y;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e, int cnt){\n\tm[e[1]][e[0]] = 1;\n\tint max_ = cnt;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tmax_ = max(max_, XSize(neo.a2P, cnt+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn max_;\n}\n\nvoid fill(P e, int num){\n\tm[e[1]][e[0]] = num;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=num){\n\t\t\t\tfill(neo.a2P, num);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){return cnt;}\n\tif(minist < cnt){\n\t\treturn cnt;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tint res = int.max;\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tfill(neo.a2P, m[neo[1]][neo[0]]-1);\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t\tfill(neo.a2P, m[neo[1]][neo[0]]+1);\n\t\t\t\t}\n\t\t\t\tmin_ = min(min_, res);\n\t\t\t\tminist = min(minist, min_);\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\t\n\treturn min_;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tf = f.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\tfill(P(j, i), cast(int)(cast(double)(XSize(P(j, i), 1))/2.)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(s, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e){\n\tm[e[1]][e[0]] = 1;\n\tint cnt = 1;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tcnt += XSize(neo.a2P);\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint d(P a, P b){\n\timport std.math;\n\tint sum;\n\tint[] a_ = a.P2a;\n\ta_[]-=b.P2a[];\n\tforeach(i; a_){\n\t\tsum += cast(int)(sqrt(cast(double)(i*i)));\n\t}\n\treturn sum;\n}\n\nint[P[2]] bfs(P s){\n\tint[][] foot;\n\tforeach(i; y.iota){ foot ~= repeat(-1).take(x).array; }\n\t\n\tfoot[s[1]][s[0]] = 0;\n\tP[] q = [s];\n\twhile(q.length>0){\n\t\tP e = q.front;  q.popFront;\n\t\tforeach(i; ofs){\n\t\t\tauto neo_ = e.P2a;\n\t\t\tneo_[]+=i.P2a[];\n\t\t\tauto neo = neo_.a2P;\n\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] == 0 && foot[neo[1]][neo[0]]==-1){\n\t\t\t\t\tfoot[neo[1]][neo[0]] = foot[e[1]][e[0]] + 1;\n\t\t\t\t\tq ~= neo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdebug(1){\n\t\tforeach(i; y.iota){\n\t\t\tfoot[i].dbg;\n\t\t}\n\t\tforeach(i; y.iota){\n\t\t\tdone[i].dbg;\n\t\t}\n\t}\n\t\n\tint[P[2]] req;\n\tforeach(i; y.iota){\n\t\tforeach(j; x.iota){\n\t\t\tif(foot[i][j] >= 0){\n\t\t\t\tforeach(ite; ofs){\n\t\t\t\t\tint[2] v = [j, i];\n\t\t\t\t\tv[]+=ite.P2a[];\n\t\t\t\t\tauto neo = v.a2P;\n\t\t\t\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\t\t\t\tif(!done[neo[1]][neo[0]] && m[neo[1]][neo[0]] > 0){\n\t\t\t\t\t\t\t/+\n\t\t\t\t\t\t\tif((neo in req)==null){\n\t\t\t\t\t\t\t\treq[neo] = foot[i][j] + 1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\treq[neo] = min(req[neo], foot[i][j]+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t+/\n\t\t\t\t\t\t\treq[ [neo, P(j, i)] ] = foot[i][j] + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(P(j, i)==g){\n//\t\t\t\t\tassert((P(j, i) in req)==null);\n\t\t\t\t\treq[ [P(j, i), P(j, i)] ] = foot[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn req;\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){\n\t\treturn cnt;\n\t}\n\tif(minist <= cnt+d(e, g)){\n\t\treturn int.max;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tint[P[2]] req = bfs(e);\n\tforeach(P[2] ps, int n; req){\n\t\tP p = ps.front;\n\t\tP pp = ps.back;\n\t\tdebug(1){\n\t\t\tdbg(p.P2a, pp.P2a, n);\n\t\t}\n\t\tif(!done[p[1]][p[0]]){\n\t\t\tdone[pp[1]][pp[0]] = true;\n\t\t\tint res = int.max;\n\t\t\tif(m[p[1]][p[0]]==0){\n\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t}else if(m[p[1]][p[0]] > 1){\n\t\t\t\tif(f[m[p[1]][p[0]]] > 1){\n\t\t\t\t\t--f[m[p[1]][p[0]]];\n\t\t\t\t\tres = dfs(p, cnt+n);\n\t\t\t\t\t++f[m[p[1]][p[0]]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin_ = min(min_, res);\n\t\t\tminist = min(minist, min_);\n\n\t\t\tdone[pp[1]][pp[0]] = false;\n\t\t}else{\n\t\t\tdebug(1){\n\t\t\t\tdbg = \"done\";\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\treturn min_;\n}\n\nbool dfs(P e, int cnt, int n){\n\tif(cnt==n){\n\t\treturn e==g;\n\t}\n\tif(cnt+d(e, g) > n){\n\t\treturn false;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn false;\n\t}\n\t/+\n\tforeach(i; ofs){\n\t\tbool res = false;\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = true;\n\t\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\t\tdone[neo[1]][neo[0]] = false;\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res)return true;\n\t}\n\t+/\n\tint[P[2]] req = bfs(e);\n\tforeach(P[2] ps, int num; req){\n\t\tP p = ps.front;\n\t\tP pp = ps.back;\n\t\tdebug(1){\n\t\t\tdbg(p.P2a, pp.P2a, n);\n\t\t}\n\t\tif(!done[p[1]][p[0]]){\n\t\t\tdone[pp[1]][pp[0]] = true;\n\t\t\tif(m[p[1]][p[0]]==0){\n\t\t\t\tdone[p[1]][p[0]] = true;\n\t\t\t\tif(dfs(p, cnt+num, n)){ return true; }\n\t\t\t\tdone[p[1]][p[0]] = false;\n\t\t\t}else if(m[p[1]][p[0]] > 1){\n\t\t\t\tif(f[m[p[1]][p[0]]] > 1){\n\t\t\t\t\t--f[m[p[1]][p[0]]];\n\t\t\t\t\tdone[p[1]][p[0]] = true;\n\t\t\t\t\tif(dfs(p, cnt+num, n)){ return true; }\n\t\t\t\t\tdone[p[1]][p[0]] = false;\n\t\t\t\t\t++f[m[p[1]][p[0]]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone[pp[1]][pp[0]] = false;\n\t\t}else{\n\t\t\tdebug(1){\n\t\t\t\tdbg = \"done\";\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\treturn false;\n}\n\nint iddfs(){\n\tint n = d(s, g);\n\tdone[s[1]][s[0]] = true;\n\twhile(!dfs(s, 0, n)){++n;}\n\treturn n;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = l['X'];\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = (XSize(P(j, i))/2)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tdfs(s, 0).writeln;\n\t\tiddfs().writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nint[][] f;\nbool[][] done;\nint x;\nint y;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e, int cnt){\n\tm[e[1]][e[0]] = 1;\n\tint max_ = cnt;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tmax_ = max(max_, XSize(neo.a2P, cnt+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn max_;\n}\n\nvoid fill(P e, int num){\n\tm[e[1]][e[0]] = num;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=num){\n\t\t\t\tfill(neo.a2P, num);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){return cnt;}\n\tif(minist < cnt){\n\t\treturn cnt;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tint res = int.max;\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tfill(neo.a2P, m[neo[1]][neo[0]]-1);\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t\tfill(neo.a2P, m[neo[1]][neo[0]]+1);\n\t\t\t\t}\n\t\t\t\tmin_ = min(min_, res);\n\t\t\t\tminist = min(minist, min_);\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\t\n\treturn min_;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tf = f.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\tfill(P(j, i), cast(int)(cast(double)(XSize(P(j, i), 1))/2.)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(s, 0).writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : write, writeln, writefln, stdin;\nimport std.array;\nimport std.range;\nimport std.typecons;\nimport std.algorithm : max, min;\n\nalias Tuple!(int, int) P;\n\nint[][] m;\nbool[][] done;\nint x;\nint y;\n\nint[int] f;\n\nconst P[] ofs = [P(-1, 0), P(1, 0), P(0, 1), P(0, -1)];\n\nP s;\nP g;\n\nint XSize(P e, int cnt){\n\tm[e[1]][e[0]] = 1;\n\tint max_ = cnt;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]==2){\n\t\t\t\tmax_ = max(max_, XSize(neo.a2P, cnt+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn max_;\n}\n\nvoid fill(P e, int key){\n\tm[e[1]][e[0]] = key;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(m[neo[1]][neo[0]]>0 && m[neo[1]][neo[0]]!=key){\n\t\t\t\tfill(neo.a2P, key);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint d(P a, P b){\n\timport std.math;\n\tint sum;\n\tint[] a_ = a.P2a;\n\ta_[]-=b.P2a[];\n\tforeach(i; a_){\n\t\tsum += cast(int)(sqrt(cast(double)(i*i)));\n\t}\n\treturn sum;\n}\n\nint minist;\nint dfs(P e, int cnt){\n\tif(e==g){return cnt;}\n\tif(minist <= cnt + d(e, g)){\n\t\treturn int.max;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn int.max;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tint min_ = int.max;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tint res = int.max;\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tres = dfs(neo.a2P, cnt+1);\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin_ = min(min_, res);\n\t\t\t\tminist = min(minist, min_);\n\t\t\t}\n\t\t}\n\t}\n\tdone[e[1]][e[0]] = false;\n\t\n\treturn min_;\n}\n\nbool dfs(P e, int cnt, int n){\n\tif(cnt==n){\n\t\treturn e==g;\n\t}\n\tif(cnt+d(e, g) > n){\n\t\treturn false;\n\t}\n\tint sum = 0;\n\tforeach(i; ofs){\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(done[neo[1]][neo[0]]) ++sum;\n\t\t}\n\t}\n\tif(sum > 1){\n\t\treturn false;\n\t}\n\tdone[e[1]][e[0]] = true;\n\tforeach(i; ofs){\n\t\tbool res = false;\n\t\tauto neo = e.P2a;\n\t\tneo[]+=i.P2a[];\n\t\tif(0<=neo[0] && neo[0]<x && 0<=neo[1] && neo[1]<y){\n\t\t\tif(!done[neo[1]][neo[0]]){\n\t\t\t\tif(m[neo[1]][neo[0]]==0){\n\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t}else if(m[neo[1]][neo[0]] > 1){\n\t\t\t\t\tif(f[m[neo[1]][neo[0]]] > 1){\n\t\t\t\t\t\t--f[m[neo[1]][neo[0]]];\n\t\t\t\t\t\tres |= dfs(neo.a2P, cnt+1, n);\n\t\t\t\t\t\t++f[m[neo[1]][neo[0]]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(res)return true;\n\t}\n\tdone[e[1]][e[0]] = false;\n\t\n\treturn false;\n}\n\nint iddfs(){\n\tint n = d(s, g);\n\twhile(!dfs(s, 0, n)){++n; }\n\treturn n;\n}\n\nint[2] P2a(P a){\n\treturn [a[0], a[1]];\n}\nP a2P(int[2] a){\n\treturn P(a[0], a[1]);\n}\n\nvoid main(){\n\tint[char] l = [\n\t\t'.':0,\n\t\t'#':-1,\n\t\t'X':2,\n\t];\n\n\n\twhile(true){\n\t\tm = m.init;\n\t\tdone = done.init;\n\t\tminist = int.max;\n\t\tf = f.init;\n\t\tx.next;\n\t\ty.next;\n\t\tif((x|y)==0x00){ break; }\n\t\t\n\t\tforeach(i; y.iota){\n\t\t\tstring str = next!string();\n\t\t\tint[] d;\n\t\t\tforeach(j, c; str){\n\t\t\t\tif((c in l)!=null){\n\t\t\t\t\td ~= l[c];\n\t\t\t\t}else{\n\t\t\t\t\td ~= l['.'];\n\t\t\t\t\tif(c=='S'){\n\t\t\t\t\t\ts = P(cast(int)j, i);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tg = P(cast(int)j, i);\n\t\t\t\t\t\tassert(c=='G');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm ~= d;\n\t\t\t\n\t\t\tdone ~= repeat(false).take(x).array;\n\t\t}\n\t\t\n\t\t\n\t\tint key = l['X'];\n\t\tforeach(i; y.iota){\n\t\t\tforeach(j; x.iota){\n\t\t\t\tif(m[i][j] == l['X']){\n\t\t\t\t\t++key;\n\t\t\t\t\tf[key] = (XSize(P(j, i), 1)/2)+1;\n\t\t\t\t\tfill(P(j, i), key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tdfs(s, 0).writeln;\n\t\tiddfs().writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nimport collections as co\n\nclass Vec(co.namedtuple('Vec','x y')):\n    __slots__ = ()\n    def __add__(self,v):\n        return Vec(self.x+v.x, self.y+v.y)\n\nwhile True:\n    X,Y = map(int, input().split())\n    if X==0: break\n    field = dict()\n    neighbors = dict()\n    ices = set()\n    for y in range(Y):\n        line = input()\n        for x in range(X):\n            if line[x] != '#': field[Vec(x,y)] = line[x]\n            if line[x] == 'S': startv = Vec(x,y)\n            if line[x] == 'G': goalv = Vec(x,y)\n            if line[x] == 'X': ices.add(Vec(x,y))\n\n    pairs = [(1,0),(0,1),(-1,0),(0,-1)]\n    direcs = [Vec(*pair) for pair in pairs]\n\n    for k,v in field.items():\n        for direc in direcs:\n            neighbors[k] = {k+direc for direc in direcs if k+direc in field}\n\n    def dfsIce(v0,visited=None):\n        if visited==None:\n            visited = set()\n        visited.add(v0)\n        for v in ices & (neighbors[v0] - visited):\n            dfsIce(v,visited)\n        return visited\n\n    iceAreas = [] # list of sets\n    for v in ices:\n        flatten = set(it.chain(*iceAreas))\n        if v not in flatten:\n            iceAreas.append(dfsIce(v))\n    # print(iceAreas)\n    # print()\n\n    areaOf = dict()\n    for v in ices:\n        for area in iceAreas:\n            if v in area:\n                areaOf[v] = area\n                break\n\n    def testIce(path):\n        v = path[-1]\n        afterArea = areaOf[v]-set(path)\n        return False if len(afterArea) < len(areaOf[v]) / 2 else True\n\n    def bfsPaths(startv, goalv):\n        pathQueue = [[startv]]\n        while pathQueue:\n            path = pathQueue.pop(0)\n            v0 = path[-1]\n            for v in neighbors[v0] - set(path):\n                if v == goalv:\n                    return path+[v]\n                elif field[v]!='X' or testIce(path+[v]):\n                    pathQueue.append(path+[v])\n\n    sp = bfsPaths(startv, goalv)\n    print(len(sp)-1)\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nimport collections as co\n\nclass Vec(co.namedtuple('Vec','x y')):\n    __slots__ = ()\n    def __add__(self,v):\n        return Vec(self.x+v.x, self.y+v.y)\n\nwhile True:\n    X,Y = map(int, input().split())\n    if X==0: break\n    field = dict()\n    neighbors = dict()\n    ices = set()\n    for y in range(Y):\n        line = input()\n        for x in range(X):\n            if line[x] != '#': field[Vec(x,y)] = line[x]\n            if line[x] == 'S': startv = Vec(x,y)\n            if line[x] == 'G': goalv = Vec(x,y)\n            if line[x] == 'X': ices.add(Vec(x,y))\n\n    pairs = [(1,0),(0,1),(-1,0),(0,-1)]\n    direcs = [Vec(*pair) for pair in pairs]\n    def getNeighbors(v):\n        return {v+direc for direc in direcs if v+direc in field}\n\n    # remove single ice from field and ices\n    for ice in ices.copy():\n        if getNeighbors(ice).isdisjoint(ices):\n            field.pop(ice)\n            ices.remove(ice)\n\n    # init neighbors\n    for v in field.keys():\n        neighbors[v] = getNeighbors(v)\n\n    def dfsIce(v0,visited=None):\n        if visited==None:\n            visited = set()\n        visited.add(v0)\n        for v in ices & (neighbors[v0] - visited):\n            dfsIce(v,visited)\n        return visited\n\n    # init iceAreas\n    iceAreas = [] # list of sets\n    for v in ices:\n        flatten = set(it.chain(*iceAreas))\n        if v not in flatten:\n            iceAreas.append(dfsIce(v))\n    # print(iceAreas)\n    # print()\n\n    # init areaOf\n    areaOf = dict()\n    for ice in ices:\n        for area in iceAreas:\n            if ice in area:\n                areaOf[ice] = area\n                break\n\n    def testIce(path):\n        ice = path[-1]\n        afterArea = areaOf[ice]-set(path)\n        return False if len(afterArea) < len(areaOf[ice]) / 2 else True\n\n    def bfsPaths(startv, goalv):\n        pathQueue = [[startv]]\n        while pathQueue:\n            path = pathQueue.pop(0)\n            v0 = path[-1]\n            for v in neighbors[v0] - set(path):\n                if v == goalv:\n                    return path+[v]\n                elif field[v]!='X' or testIce(path+[v]):\n                    pathQueue.append(path+[v])\n\n    sp = bfsPaths(startv, goalv)\n    print(len(sp)-1)\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nimport collections as co\n\nclass Vec(co.namedtuple('Vec','x y')):\n    def __add__(self,v):\n        return Vec(self.x+v.x, self.y+v.y)\n\nwhile True:\n    X,Y = map(int, input().split())\n    if X==0: break\n    field = dict()\n    ices = set()\n    for y in range(Y):\n        line = input()\n        for x in range(X):\n            if line[x] != '#': field[Vec(x,y)] = line[x]\n            if line[x] == 'S': startv = Vec(x,y)\n            if line[x] == 'G': goalv = Vec(x,y)\n            if line[x] == 'X': ices.add(Vec(x,y))\n    pairs = [(1,0),(0,1),(-1,0),(0,-1)]\n    direcs = [Vec(*pair) for pair in pairs]\n\n    def neighbors(v):\n        return {v+direc for direc in direcs if v+direc in field}\n\n    def dfsIce(v0,visited=None):\n        if visited==None:\n            visited = set()\n        visited.add(v0)\n        for v in ices & (neighbors(v0) - visited):\n            dfsIce(v,visited)\n        return visited\n\n    iceAreas = [] # list of sets\n    for v in ices:\n        flatten = set(it.chain(*iceAreas))\n        if v not in flatten:\n            iceAreas.append(dfsIce(v))\n    # print(iceAreas)\n\n    def testIce(path):\n        for area in iceAreas:\n            afterArea = area-set(path)\n            if len(afterArea) < len(area) / 2:\n                return False\n        return True\n\n    def bfsPaths(startv, goalv):\n        pathQueue = [[startv]]\n        while pathQueue:\n            path = pathQueue.pop(0)\n            v0 = path[-1]\n            for v in neighbors(v0) - set(path):\n                if v == goalv:\n                    return path+[v]\n                elif field[v]!='X' or testIce(path+[v]):\n                    pathQueue.append(path+[v])\n\n    sp = bfsPaths(startv, goalv)\n    print(len(sp)-1)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nwhile True:\n    x, y = map(int, input().split())\n    if x == 0:break\n    mp = [list(\"#\" * (x + 2))] + [list(\"#\" + input() + \"#\") for _ in range(y)] + [list(\"#\" * (x + 2))]\n    ice_cnt = 0\n    ice_dic = []\n    vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n    \n    \n    def ice_search(x, y, ice_cnt):\n        for dx, dy in vec:\n            if mp[y + dy][x + dx] == \"X\":\n                mp[y + dy][x + dx] = ice_cnt\n                ice_dic[ice_cnt] += 1\n                ice_search(x + dx, y + dy, ice_cnt)\n\n\n    for i in range(1, y + 1):\n        for j in range(1, x + 1):\n            if mp[i][j] == \"S\":\n                sx, sy = j, i\n                mp[i][j] = \".\"\n            if mp[i][j] == \"G\":\n                gx, gy = j, i\n                mp[i][j] = \".\"\n            if mp[i][j] == \"X\":\n                mp[i][j] = ice_cnt\n                ice_dic.append(1)\n                ice_search(j, i, ice_cnt)\n                ice_cnt += 1\n\n    que = deque()\n    que.append((0, sx, sy, [v // 2 for v in ice_dic], 0))\n    dic = {}\n    dic[(sx, sy, 0)] = 0\n    hash_lst = [150 ** i for i in range(len(ice_dic))]\n    while que:\n        score, px, py, counters, hs = que.popleft()\n        if (px, py) == (gx, gy):\n            print(score)\n            break\n        for dx, dy in vec:\n            nx, ny = px + dx, py + dy\n            if mp[ny][nx] == \"#\":continue\n            elif mp[ny][nx] == \".\":\n                if (nx, ny, hs) in dic:continue\n                dic[(nx, ny, hs)] = True\n                que.append((score + 1, nx, ny, counters[:], hs))\n            else:\n                num = mp[ny][nx]\n                if counters[num] <= 0:continue\n                new_counters = counters[:]\n                new_counters[num] -= 1\n                new_hs = hs + hash_lst[num]\n                if (nx, ny, new_hs) in dic:continue\n                dic[(nx, ny, new_hs)] = True\n                que.append((score + 1, nx, ny, new_counters, new_hs))\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools as it\nimport collections as co\n\nclass Vec(co.namedtuple('Vec','x y')):\n    __slots__ = ()\n    def __add__(self,v):\n        return Vec(self.x+v.x, self.y+v.y)\n\nwhile True:\n    X,Y = map(int, input().split())\n    if X==0: break\n    field = dict()\n    ices = set()\n    for y in range(Y):\n        line = input()\n        for x in range(X):\n            if line[x] != '#': field[Vec(x,y)] = line[x]\n            if line[x] == 'S': startv = Vec(x,y)\n            if line[x] == 'G': goalv = Vec(x,y)\n            if line[x] == 'X': ices.add(Vec(x,y))\n    pairs = [(1,0),(0,1),(-1,0),(0,-1)]\n    direcs = [Vec(*pair) for pair in pairs]\n\n    def neighbors(v):\n        return {v+direc for direc in direcs if v+direc in field}\n\n    def dfsIce(v0,visited=None):\n        if visited==None:\n            visited = set()\n        visited.add(v0)\n        for v in ices & (neighbors(v0) - visited):\n            dfsIce(v,visited)\n        return visited\n\n    iceAreas = [] # list of sets\n    for v in ices:\n        flatten = set(it.chain(*iceAreas))\n        if v not in flatten:\n            iceAreas.append(dfsIce(v))\n\n    areaOf = dict()\n    for v in ices:\n        for area in iceAreas:\n            if v in area:\n                areaOf[v] = area\n                break\n\n    def testIce(path):\n        v = path[-1]\n        afterArea = areaOf[v]-set(path)\n        return False if len(afterArea) < len(areaOf[v]) / 2 else True\n\n    def bfsPaths(startv, goalv):\n        pathQueue = [[startv]]\n        while pathQueue:\n            path = pathQueue.pop(0)\n            v0 = path[-1]\n            for v in neighbors(v0) - set(path):\n                if v == goalv:\n                    return path+[v]\n                elif field[v]!='X' or testIce(path+[v]):\n                    pathQueue.append(path+[v])\n                # else:\n                #     pathQueue.append(path+[v])\n\n    sp = bfsPaths(startv, goalv)\n    print(len(sp)-1)\n\n\n"
  }
]