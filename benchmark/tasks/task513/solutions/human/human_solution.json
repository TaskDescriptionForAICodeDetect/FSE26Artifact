[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int64;\ntypedef pair< int64, int64 > Pi;\nconst int64 INF = 1LL << 58;\n \nint N, L, A[100000], B[100000], C[100000];\nvector< Pi > drinks;\npriority_queue< Pi > que, que2;\nint64 v[100000];\n \nint solve()\n{\n  int my_height = 0;\n  int enemy_height = 0;\n  int deletable = 0;\n \n  for(int i = 0; i < N; i++) {\n    while(!que.empty() && v[que.top().second] < i) que.pop();\n    if(!que.empty() && my_height + que.top().first >= L) return (i + 1);\n    my_height += drinks[i].first;\n    que2.emplace(B[drinks[i].second], drinks[i].second);\n    while(my_height - drinks[deletable].first <= enemy_height) ++deletable;\n    while(!que2.empty() && v[que2.top().second] < deletable) que2.pop();\n    if(!que2.empty() && my_height + que2.top().first >= L) return (i + 1);\n    v[drinks[i].second] = i;\n    enemy_height += C[i];\n    if(enemy_height >= my_height) return (-1);\n  }\n  return (-1);\n}\n \nint main()\n{\n  cin >> N >> L;\n  for(int i = 0; i < N; i++) {\n    cin >> A[i] >> B[i];\n    que.emplace(A[i], i);\n    drinks.emplace_back(A[i] - B[i], i);\n    v[i] = INF;\n  }\n  sort(begin(drinks), end(drinks));\n  reverse(begin(drinks), end(drinks));\n  for(int i = 0; i < N; i++) {\n    cin >> C[i];\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct drink{\n  LL a;\n  LL b;\n  bool operator<(const struct drink& right) const{\n    return (a-b==right.a-right.b?a>right.a:a-b<right.a-right.b);\n  }\n};\n\nint main(){\n  LL n,l;\n  cin >> n >> l;\n  vector<struct drink> d(n);\n  LL total=0;\n  for(int i=0;i<n;i++){\n    cin >> d[i].a >> d[i].b;\n  }\n  sort(d.begin(),d.end());\n  vector<LL> mx(n);\n  mx[0]=-1000000000;\n  for(int i=1;i<n;i++){\n    mx[i]=max(mx[i-1],d[i-1].a);\n  }\n  // for(int i=0;i<n;i++){\n  //   cout << d[i].a << \" \" << d[i].b << endl;\n  // }\n  vector<LL> c(n);\n  for(int i=0;i<n;i++){\n    cin >> c[i];\n  }\n  LL ruiD=0,ruiC=0;\n  for(int i=0;i<n-1;i++){\n    ruiD+=d[n-1-i].a-d[n-1-i].b;\n    ruiC+=c[i];\n    if(ruiD<=ruiC){\n      cout << -1 << endl;\n      return 0;\n    }\n    if(ruiD+mx[n-1-i]>=l){\n      cout << i+2 << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define EACH(i, a) for(auto&& i:a)\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,a,b) for(ll i = (b)-1; i >= (a); --i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define ALL(v) (v).begin(),(v).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\n\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\n\nstruct Drink {\n    ll A, B;\n};\nistream& operator>>(istream& is, Drink& d) {\n    return cin >> d.A >> d.B;\n}\nbool operator<(const Drink& d1, const Drink& d2) {\n    return d1.A - d1.B < d2.A - d2.B;\n}\nbool operator>(const Drink& d1, const Drink& d2) {\n    return d2 < d1;\n}\n\n// template<class T>\n// T lower_bound(T l, T r, ll times, const function<bool(T)>& check) {\n//     while (times--) {\n//         T m = (l + r) / 2;\n//         if ( check(m) ) {\n//             r = m;\n//         }\n//         else {\n//             l = m;\n//         }\n//     }\n//     return r;\n// }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, L; cin >> n >> L;\n    vector<Drink> D(n); cin >> D;\n    vector<ll> C(n); cin >> C;\n    sort(ALL(D), greater<Drink>());\n    // ll pos = lower_bound<ll>(0, n, 50, [&](ll m) {\n    //     return true;\n    // });\n    vector<ll> M(n+1, 0);\n    RREP(i, n) M[i] = max(M[i+1], D[i].A);\n    if ( M[0] >= L ) {\n        cout << 1 << endl;\n        return 0;\n    }\n    // d??\\??§??§?????????\n    auto check = [&](ll d) {\n        // pos?????????????????§???d-1??\\?????????????????????\n        auto check = [&](ll pos) {\n            ll j = 0;\n            ll sum1 = 0, sum2 = 0;\n            REP(i, d) {\n                if (i == pos) continue;\n                sum1 += D[i].A - D[i].B;\n                sum2 += C[j++];\n                if (sum1 <= sum2) return 0;\n                if ((pos != d || i != d-1) && sum1+M[i+1] >= L) return 2;\n            }\n            return 1;\n        };\n        if ( check(d) == 2 ) return true;\n        if ( !check(d) ) return false;\n        ll l = 0, r = d;\n        REP(t, 50) {\n            ll m = (l + r) / 2;\n            if ( check(m) ) {\n                r = m;\n            }\n            else {\n                l = m;\n            }\n        }\n        ll pos = r;\n        ll sum = 0;\n        REP(i, d) if (D[i].A - D[i].B >= 0) {\n            sum += D[i].A - D[i].B;\n        }\n        vector<ll> S(d+2, 0);\n        REP(i, d-1) S[i+1] = S[i]+D[i].A-D[i].B;\n        S[d+1] = linf;\n        FOR(i, pos, d) {\n            if ( D[i].A - D[i].B >= 0 ) {\n                if (sum + D[i].B >= L) return true;\n            }\n            else {\n                if (sum + D[i].A >= L) return true;\n            }\n        }\n        sum -= D[d-1].A - D[d-1].B;\n        FOR(i, d-1, n) {\n            ll lb = lower_bound(ALL(S), L-D[i].A)-S.begin();\n            if (lb < d) return true;\n        }\n        return false;\n    };\n    // cout << check(5) << endl;\n    // return 0;\n    ll l = 0, r = n;\n    REP(i, n) {\n        if (D[i].A - D[i].B < 0) {\n            r = i;\n            break;\n        }\n    }\n    if ( !check(r) ) {\n        cout << -1 << endl;\n        return 0;\n    }\n    REP(t, 50) {\n        ll m = (l + r) / 2;\n        if ( check(m) ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    cout << r << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n// #define show(x) cerr << #x << \" = \" << x << endl\n#define show(x)\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return (Total != d.Total) ? Total > d.Total : A < d.A;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total << endl;\n    return os;\n}\n\nint main()\n{\n    ll N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (ll i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (ll i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    //    cerr << accum << endl;\n\n    vector<ll> C(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (ll i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (ll i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (ll i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    //    cerr << data << endl;\n    // show(sum1);\n    // show(sum2);\n    //    show(accum);\n    // show(data);\n    constexpr ll INF = 1LL << 60;\n    ll minimum = INF;\n\n\n    for (ll i = 0; i < N; i++) {\n        show(i);\n        ll goal = L - data[i].A;\n        const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            show(\"hogeohoegoeodwqd\");\n            show(goal);\n            show(lower);\n            const ll mini = seg1.query(1, lower + 1);\n            show(mini);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            show(\"feffwuefwiuefwuef\");\n            // if (lower >= N) {\n            //     continue;\n            // }\n            goal = L - data[i].B;\n            const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N + 1) {\n                //          cerr << accum[N] - goal << endl;\n                continue;\n            }\n            show(lower);\n            if (i == 0) {\n                show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower + 1);\n                }\n            } else {\n                show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i + 1);\n                show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower+1);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst ll A = 3e5 + 10;\nll a[A];\nclass P{\npublic:\n    ll id,val;\n    P(ll _id = 0,ll _val = 0){\n        id = _id;\n        val = _val;\n    }\n    bool operator<(const P& rhs)const{\n        if(val == rhs.val) return a[id] > a[rhs.id];\n        return val < rhs.val;\n    }\n};\npriority_queue<P> que_A,que_Dis;\nbool vis[A];\nll n,C[A];\nll L;\n\nll calc(){\n    ll now = 0,Di = 0;\n    memset(vis,0,sizeof(vis));\n    for(ll i=1 ;i<=n ;i++){\n        while(vis[que_A.top().id]) que_A.pop();\n        if(now + que_A.top().val >= L) return i;\n\n        now += que_Dis.top().val;\n        vis[que_Dis.top().id] = 1;\n        que_Dis.pop();\n        Di += C[i];\n        if(Di >= now) return -1;\n    }\n    return -1;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&n,&L);\n    for(ll i=1 ;i<=n ;i++){\n        ll x,y;\n        scanf(\"%lld%lld\",&x,&y);\n        a[i] = x;\n        que_A.push(P(i,x));\n        que_Dis.push(P(i,x-y));\n    }\n    for(ll i=1 ;i<=n ;i++) scanf(\"%lld\",&C[i]);\n    ll ans = calc();\n    if(ans == -1) puts(\"-1\");\n    else          printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nint n, L ,need;\nint l, r, mid;\nstruct Bottle {\n    int up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nint main()\n{\n     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n     int n,L;\n     cin>>n>>L;\n     rep(i,1,n+1)cin>>a[i].up>>a[i].down,a[i].val = a[i].up - a[i].down;\n     rep(i,1,n+1)cin>>b[i],c[i]=c[i-1]+b[i];         //c[i]保存b的前缀和\n     sort(a+1,a+n+1);\n     rep(i,1,n+1)sum[i]=sum[i-1]+a[i].val;               //sum[i]保存a的前缀和\n    int day = 1;for(int i = 1; a[i].val > 0 && i <= n; i++, day++);    //找到可能的答案范围\n     int ans=999999999;        //保存答案\n     rep(k,1,n+1)\n     {\n         l=1,r=day;\n         need=L-a[k].up;\n         while(l<r)\n         {\n             int mid=(l+r)>>1;\n             if(mid==1)l=mid+1;\n             else if((mid-1)>=k&&sum[mid]-a[k].val<=c[mid-1])r=mid;\n             else if((mid-1)<k&&sum[mid-1]<=c[mid-1])r=mid;\n              else l=mid+1;\n         }      //求出k作为最后一瓶饮料使用时最少需要多少天被追上，复杂度为logr\n         l=1;   //因为之前求出的r是刚好被追上的那天，所以最多r天早上逃脱，晚上就会被抓\n         if((r-1)>=k&&sum[r]-a[k].val<=c[r-1])r--;//判断第r天是否被追上\n         if((r-1)<k&&sum[r-1]<=c[r-1])r--;      //判断第r天是否被追上\n        while(l<r)\n        {\n            int mid=(l+r)>>1;\n            if((mid-1)>=k&&sum[mid]-a[k].val>=need)r=mid;\n             else if(mid<k&&sum[mid-1]>=need)r=mid;\n              else l=mid+1;\n        }     //求出最少所用天数复杂度为logr\n        if(((l-1)>=k&&sum[l]-a[k].val>=need)||((l-1)<k&&sum[l-1]>=need))ans=min(l,ans);\n     }\n     if(ans==999999999)cout<<-1<<endl;\n     else cout<<ans<<endl;\n     return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first > 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define LL long long\n#define FOR(i,s,t) for (int i = (int)s; i < (int)t; ++i)\nusing namespace std;\nconst int maxn = 100010;\n\nint n, li[maxn];\nLL L, sum[maxn], c[maxn];\n\nstruct Num{\n    LL a, b;\n    bool operator < (const Num& rhs) const{\n        return a-b > rhs.a-rhs.b;\n    }\n}s[maxn];\n\nvoid Init() {\n    LL ca = 0;\n    int idx = 1;\n    FOR(i, 2, n+1) {\n        ca = ca+s[i].a-s[i].b-c[idx];\n        if(ca <= 0) break;\n        ++ idx;\n    }\n    li[1] = idx;\n    FOR(i, 2, n+1) {\n        if(i-1 > idx) {li[i] = idx; continue;}\n        if(idx == n) {li[i] = n; continue;}\n        ca += s[i-1].a-s[i-1].b+s[i].b-s[i].a;\n        while(ca > 0 && idx < n) {\n            ++ idx;\n            ca += s[idx+1].a-s[idx+1].b-c[idx];\n        }\n        li[i] = idx;\n    }\n}\n\nint ff = n+1;\n\nbool judge(int x) {\n    -- x;\n    FOR(i, 1, n+1) {\n        LL lim = L-s[i].a;\n        if(li[i] <= x) continue;\n        if(i > x && sum[x] >= lim)  return true;\n        if(i <= x && sum[x+1]-s[i].a+s[i].b >= lim) return true;\n    }\n    return false;\n}\n\nint main() {\n    while(~scanf(\"%d%lld\", &n, &L)) {\n        LL mx = -1;\n        FOR(i, 1, n+1)\n            scanf(\"%lld%lld\", &s[i].a, &s[i].b),\n            mx = max(mx, s[i].a);\n        s[n+1].a = s[n+1].b = 0;\n        FOR(i, 1 ,n+1) scanf(\"%lld\", c+i);\n        if(mx >= L) {printf(\"1\\n\"); continue;}\n        sort(s+1, s+n+1);\n        ff = n;\n        FOR(i, 1, n+1) if(s[i].a <= s[i].b) {ff = i; break;}\n        sum[0] = 0;\n        FOR(i, 1, n+1) sum[i] = sum[i-1]+s[i].a-s[i].b;\n        Init();\n        int l = 1, r = ff;\n        if(l > r) {printf(\"-1\\n\"); continue;}\n        while(l < r) {\n            int mid = (l+r) >> 1;\n            if(judge(mid))  r = mid;\n            else    l = mid+1;\n        }\n        if(judge(l))    printf(\"%d\\n\", l);\n        else    printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM -2000000000\n#define SIZE 100000\n\nstruct Info{\n\tInfo(ll arg_A,ll arg_B){\n\t\tA = arg_A;\n\t\tB = arg_B;\n\t}\n\tbool operator<(const struct Info& arg) const{ //A-Bの降順\n\t\treturn A-B > arg.A-arg.B;\n\t}\n\tll A,B;\n};\n\nint N;\nll* table;\nll* min_diff;\nll enemy[SIZE],self[SIZE],max_A[SIZE];\nvector<Info> info;\n\n//簡易化のため、要素数を2のべき乗にする関数\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int loc,ll value){\n\tloc += N-1;\n\n\ttable[loc] = value;\n\n\tif(N == 1)return;\n\n\tint parent = (loc-1)/2;\n\n\twhile(true){\n\t\ttable[parent] = max(table[2*parent+1],table[2*parent+2]); //親は左右の子の大きい方の値を持つ\n\n\t\tif(parent == 0)break;\n\t\telse{\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\nvoid min_update(int loc,ll value){\n\tloc += N-1;\n\n\tmin_diff[loc] = value;\n\n\tif(N == 1)return;\n\n\tint parent = (loc-1)/2;\n\n\twhile(true){\n\t\tmin_diff[parent] = min(min_diff[2*parent+1],min_diff[2*parent+2]); //親は左右の子の小さい方の値を持つ\n\n\t\tif(parent == 0)break;\n\t\telse{\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\n\nll query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t//今回のノードが検索区間をカバーしていなければ、結果に関係ない値を返す\n\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\t//今回のノードの区間が、検索区間の部分区間である場合、今回のノードの値を返す\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn table[node_id];\n\t}\n\n\t//今回のノードの区間に、一部検索区間と重なっている区間がある場合→再帰的に子どもに尋ねる\n\tll left_max= query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tll right_max = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn max(left_max,right_max);\n}\n\nll min_query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t//今回のノードが検索区間をカバーしていなければ、結果に関係ない値を返す\n\tif(search_right < node_left || search_left > node_right)return BIG_NUM;\n\n\t//今回のノードの区間が、検索区間の部分区間である場合、今回のノードの値を返す\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn min_diff[node_id];\n\t}\n\n\t//今回のノードの区間に、一部検索区間と重なっている区間がある場合→再帰的に子どもに尋ねる\n\tll left_min= min_query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tll right_min = min_query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn min(left_min,right_min);\n}\n\nint main(){\n\n\tint first_N;\n\tll L;\n\n\tscanf(\"%d %lld\",&first_N,&L);\n\n\tll A,B;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld %lld\",&A,&B);\n\t\tinfo.push_back(Info(A,B));\n\t}\n\n\t//敵の高さを計算\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&enemy[i]);\n\t\tif(i != 0){\n\t\t\tenemy[i] += enemy[i-1]; //累積和を計算\n\t\t}\n\t}\n\n\tsort(info.begin(),info.end());\n\n\t//自分の高さを計算\n\tfor(int i = 0; i < first_N; i++){\n\t\tself[i] = info[i].A-info[i].B;\n\t\tif(i != 0){\n\t\t\tself[i] += self[i-1];\n\t\t}\n\t}\n\t//ある日を含め、ある日より右にある、最大のAを求める\n\tmax_A[first_N-1] = info[first_N-1].A;\n\tfor(int i = first_N-2; i >= 0; i--){\n\t\tmax_A[i] = max(max_A[i+1],info[i].A);\n\t}\n\n\t//Bをセグメント木に登録する\n\tN = 1;\n\tinit(first_N);\n\n\ttable = new ll[2*N-1];\n\n\t//0～N-2が上位構造のアドレス、N-1～2*N-2が最小要素のアドレス\n\tfor(int i = 0; i <= 2*N-2; i++)table[i] = NUM;  //まずは範囲外値で初期化\n\t//Bを登録\n\tfor(int i = 0; i < first_N; i++){\n\t\tupdate(i,info[i].B);\n\t}\n\n\t//差をセグメント木に登録する\n\tmin_diff = new ll[2*N-1];\n\n\tfor(int i = 0; i <= 2*N-2; i++)min_diff[i] = BIG_NUM;\n\t//差を登録\n\tfor(int i = 0; i < first_N; i++){\n\t\tif(i != 0){\n\t\t\tmin_update(i,self[i]-enemy[i-1]);\n\t\t}else{\n\t\t\tmin_update(i,self[i]);\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\n\tll tmp_H;\n\t/*★A-Bの降順に値を採用、脱出日は最大のAを使用する場合★*/\n\n\t//初日で脱出可\n\tif(max_A[0] >= L){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 1; i < first_N; i++){\n\n\t\tif(self[i-1] <= enemy[i-1]){ //敵に追いつかれたので終了\n\t\t\tbreak;\n\t\t}\n\t\ttmp_H = self[i-1]+max_A[i];\n\n\t\tif(tmp_H >= L){\n\t\t\tans = i+1; //解答は1オリジンのため\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbool FLG;\n\n\t/*★脱出日までの、どこか一日を、最終日に持ってくる場合★*/\n\tint left = 0,right,m;\n\tint min_index;\n\tll max_B,tmp_diff;\n\n\tfor(int i = 1; i < first_N; i++){\n\n\t\tif(self[i-1] <= enemy[i-1]){ //敵に追いつかれたので終了\n\t\t\tbreak;\n\t\t}\n\t\t//0～i日目の間で、i日目に順番を回しても、敵に追いつかれないドリンクの範囲を二分探索で求める\n\t\tright = i,m = (left+right)/2; //★始点は随時右にずれていくので、初期化せずに値を引き継ぐ\n\n\t\tmin_index = BIG_NUM;\n\n\t\twhile(left <= right){\n\n\t\t\tFLG = true;\n\t\t\t//ドリンクmを飲むのをi日目にすることで、敵に追いつかれるか調べる\n\n\t\t\ttmp_diff = min_query(m+1,i,0,0,N-1);\n\n\t\t\tif(tmp_diff <= info[m].A-info[m].B){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(FLG){\n\n\t\t\t\tmin_index = m;\n\t\t\t\tright = m-1;\n\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tif(min_index == BIG_NUM)continue;\n\n\t\tmax_B = query(min_index,i,0,0,N-1); //★i日に回しても良いドリンクの中での、Bの最大値を取得★\n\n\t\ttmp_H = self[i]+max_B; //★★加算していたマイナスが消える分(マイナスのマイナス)、プラスになる\n\n\t\tif(tmp_H >= L){\n\t\t\tans = min(ans,i+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n// #define show(x) cerr << #x << \" = \" << x << endl\n#define show(x)\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return (Total != d.Total) ? Total > d.Total : A < d.A;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total << endl;\n    return os;\n}\n\nint main()\n{\n    ll N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (ll i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (ll i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    //    cerr << accum << endl;\n\n    vector<ll> C(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (ll i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (ll i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (ll i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    //    cerr << data << endl;\n    // show(sum1);\n    // show(sum2);\n    //    show(accum);\n    // show(data);\n    constexpr ll INF = 1LL << 60;\n    ll minimum = INF;\n\n\n    for (ll i = 0; i < N; i++) {\n        show(i);\n        ll goal = L - data[i].A;\n        const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            show(\"hogeohoegoeodwqd\");\n            show(goal);\n            show(lower);\n            const ll mini = seg1.query(1, lower + 1);\n            show(mini);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            show(\"feffwuefwiuefwuef\");\n            // if (lower >= N) {\n            //     continue;\n            // }\n            goal = L - data[i].B;\n            const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N + 1) {\n                //          cerr << accum[N] - goal << endl;\n                continue;\n            }\n            show(lower);\n            if (i == 0) {\n                show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower + 1);\n                }\n            } else {\n                show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i + 1);\n                show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n,lim=n;\n  bool dbg=0;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(cur<=tmp) lim=min(lim,i);\n    if(dbg) cout<<i<<\" \"<<cur<<\" \"<<tmp<<endl;\n  }\n  if(dbg) for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  if(dbg) for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    {\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(pos>=lim) continue;\n      if(dbg) cout<<i<<\";\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\";\"<<x<<\" \"<<pos<<\" \"<<endl;\n      if(rev[i]<=pos) continue;\n      ans=min(ans,pos+2);\n    }\n  }\n  for(int i=0;i<n;i++){\n    {\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      //cout<<pos<<endl;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<=y) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      if(pos<rev[i]) continue;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=1000000007 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\tint n,i;cin>>n;\n\tllint L;cin>>L;\n\tvector<pair<llint,llint>>dri(n);//通常の登り,ピーク登り\n\tvector<llint>c(n+1);//相手\n\tfor(i=0;i<n;i++){llint AA,BB;cin>>AA>>BB;dri[i]=mp(AA-BB,AA);}\n\tfor(i=0;i<n;i++){cin>>c[i+1];c[i+1]+=c[i];}\n\tSO(dri);REV(dri);\n\tvector<llint>wa(n+1);\n\tfor(i=0;i<n;i++){wa[i+1]=wa[i]+max(0LL,dri[i].fir);}\n\tvector<llint>yorui(n+1);\n\tyorui[0]=big;yorui[1]=big;\n\tfor(i=2;i<=n;i++){yorui[i]=wa[i]-c[i-1];mineq(yorui[i],yorui[i-1]);}\n\tllint usedD=-big;\n\tint outm=1,ans=mod;\n\twhile(outm<n&&wa[outm]>c[outm]){outm++;}\n\t//cerr<<\"outm=\"<<outm<<endl;\n\t//for(i=0;i<n;i++){cerr<<yorui[i]<<\" \";}cerr<<endl;\n\tfor(i=n-1;i>=0;i--){\n\t\t\n\t\tif(!maxeq(usedD,dri[i].sec)){continue;}\n\t\t//最終日使用ドリンク\n\t\tllint Lg=L-dri[i].sec;\n\t\t//cerr<<\"Lg=\"<<Lg<<endl;\n\t\tif(wa[i]>=Lg){//それまでに普通に足りている\n\t\t\tint bas=LBI(wa,Lg);\n\t\t\t//cerr<<\"i=\"<<i<<\"bass=\"<<bas<<endl;\n\t\t\tif(bas<outm){mineq(ans,bas+1);}\n\t\t}else{\n\t\t\tif(outm<=i){continue;}\n\t\t\tint bas=LBI(wa,Lg+max(0LL,dri[i].fir));\n\t\t\tif(bas==n+1){continue;}\n\t\t\t//cerr<<\"i=\"<<i<<\"bas=\"<<bas<<endl;\n\t\t\tif(yorui[bas]>dri[i].fir){mineq(ans,bas);}\n\t\t}\n\t}\n\tif(ans==mod){ans=-1;}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n/*\n7 10\n4 7\n1 6\n-3 4\n-4 10\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\ntypedef long long i64;\ntypedef std::pair<int, int> Info;\n\nconst int N = 100000 + 10;\nconst i64 INF = 0x3f3f3f3f3f3f3fLL;\n\nint n, m, c[N];\n\nInfo info[N];\ni64 x[N], y[N], u[N], v[N];\n\ni64 table[20][N];\n\ni64 rmq(int l, int r) {\n  int k = 31 - __builtin_clz(r - l + 1);\n  return std::min(table[k][l], table[k][r - (1 << k) + 1]);\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    info[i] = Info(a - b, a);\n  }\n  std::sort(info + 1, info + n + 1);\n  std::reverse(info + 1, info + n + 1);\n  int ans = n + 1;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &c[i]);\n  for (int i = 1; i <= n; ++i) x[i] = x[i - 1] + std::max(info[i].first, 0), y[i] = y[i - 1] + c[i];\n  for (int i = 1; i <= n; ++i) u[i] = x[i] - y[i], v[i] = x[i] - y[i - 1];\n  u[0] = INF;\n  for (int i = 1; i <= n; ++i) u[i] = std::min(u[i - 1], u[i]);\n  memset(table, 0x3f, sizeof table);\n  for (int i = 1; i <= n; ++i) table[0][i] = v[i];\n  for (int i = 1; i < 20; ++i)\n    for (int j = 1; j + (1 << i) - 1 <= n; ++j)\n      table[i][j] = std::min(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);\n  for (int i = 1; i <= n; ++i) {\n    int t = info[i].second;\n    if (x[i - 1] + t >= m) {\n      int p = std::lower_bound(x, x + i, m - t) - x;\n      if (u[p] > 0) ans = std::min(ans, p + 1);\n    } else {\n      int d = std::max(info[i].first, 0);\n      int p = std::lower_bound(x + i + 1, x + n + 1, m - t + d) - x;\n      if (p > n) continue;\n      if (u[i - 1] > 0 && *std::min_element(v + i + 1, v + p + 1) - d > 0) ans = std::min(ans, p);\n    }\n  }\n  printf(\"%d\\n\", ans <= n ? ans : -1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n        SUPTO\n        UNIVERSITY OF DHAKA\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define D(x) cerr<<#x \" = \"<<(x)<<endl\n#define pb push_back\n#define ff first\n#define ss second\n#define mem(a) memset(a,0,sizeof(a))\n#define _set(a) memset(a,-1,sizeof(a))\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define eps 1e-9\n#define MAX 100005\n#define MAXL 20\n#define MAXE 100000\n//const int mod = 1000000007;\n//const int inf = 1<<30;\n//int dx[] = {0,0,1,-1};\n//int dy[] = {1,-1,0,0};\n//int dx[] = {-1,-1,-1,0,0,1,1,1};\n//int dy[] = {-1,0,1,-1,1,-1,0,1};\n\npll ar[MAX];\nll c[MAX], mx[MAX];\nbool cmp(pll a, pll b)\n{\n    if(a.ff- a.ss == b.ff-b.ss)\n    {\n        return a.ff- a.ss+b.ff > b.ff-b.ss+a.ff;\n    }\n    return a.ff- a.ss > b.ff-b.ss;\n}\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"codes.out\", \"w\", stdout);\n    int n, i, day;\n    ll L;\n    scanf(\"%d %lld\", &n, &L);\n    for(i = 0; i < n; i++)\n    {\n        scanf(\"%lld %lld\", &ar[i].ff, &ar[i].ss);\n    }\n    for(i = 0; i < n; i++) scanf(\"%lld\", &c[i]);\n    sort(ar, ar+n, cmp);\n    for(i = n-1; i >= 0; i--) mx[i] = max(mx[i+1], ar[i].ff);\n    ll work = 0, other = 0;\n    bool found = false;\n    for(day = 0; day < n; day++)\n    {\n        //D(ar[day].ff);\n        if(work + mx[day] >= L)\n        {\n            found = true;\n            break;\n        }\n        work += ar[day].ff;\n        if(work >= L)\n        {\n            found = true;\n            break;\n        }\n        work = max(0LL, work-ar[day].ss);\n        other += c[day];\n        //D(work);\n        //D(other);\n        if(other >= work) break;\n    }\n    if(found) printf(\"%d\\n\", day+1);\n    else printf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define EACH(i, a) for(auto&& i:a)\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,a,b) for(ll i = (b)-1; i >= (a); --i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define ALL(v) (v).begin(),(v).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\n\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\n\nstruct Drink {\n    ll A, B;\n};\nistream& operator>>(istream& is, Drink& d) {\n    return cin >> d.A >> d.B;\n}\nbool operator<(const Drink& d1, const Drink& d2) {\n    return d1.A - d1.B < d2.A - d2.B;\n}\nbool operator>(const Drink& d1, const Drink& d2) {\n    return d2 < d1;\n}\n\n// template<class T>\n// T lower_bound(T l, T r, ll times, const function<bool(T)>& check) {\n//     while (times--) {\n//         T m = (l + r) / 2;\n//         if ( check(m) ) {\n//             r = m;\n//         }\n//         else {\n//             l = m;\n//         }\n//     }\n//     return r;\n// }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, L; cin >> n >> L;\n    vector<Drink> D(n); cin >> D;\n    vector<ll> C(n); cin >> C;\n    sort(ALL(D), greater<Drink>());\n    // ll pos = lower_bound<ll>(0, n, 50, [&](ll m) {\n    //     return true;\n    // });\n    vector<ll> M(n+1, 0);\n    RREP(i, n) M[i] = max(M[i+1], D[i].A);\n    if ( M[0] >= L ) {\n        cout << 1 << endl;\n        return 0;\n    }\n    auto check = [&](ll id) {\n        ll sum1 = 0, sum2 = 0;\n        ll j = 0;\n        REP(i, n) {\n            if (i == id) continue;\n            sum1 += D[i].A - D[i].B;\n            sum2 += C[j++];\n            if (sum1 <= sum2) return false;\n            if (sum1+M[i+1] >= L) return true;\n            if (sum1+D[id].A >= L) return true;\n        }\n        return false;\n    };\n    ll l = 0, r = n;\n    REP (t, 50) {\n        ll m = (l + r) / 2;\n        if ( check(m) ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    ll pos = r;\n    if (pos == n) {\n        cout << -1 << endl;\n        return 0;\n    }\n    vector<ll> v;\n    REP(i, pos) v.pb(D[i].A - D[i].B);\n    vector<ll> S(v.size()+1, 0);\n    REP(i, v.size()) {\n        S[i+1] = S[i] + v[i];\n    }\n    ll ans = linf;\n    if (S[v.size()] >= L) ans = v.size();\n    FOR(i, pos, n) {\n        ll a = (ll)(lower_bound(ALL(S), L-D[i].A) - S.begin())+1;\n        ans = min(ans, a);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*****************************************************************\n *                   BISMILLAHIR RAHMANIR RAHIM                  *\n *                           JU_Circavex                         *\n *****************************************************************/\n\n#include<bits/stdc++.h>\n\n//#include<algorithm>\n//#include<cstdio>\n//#include<sstream>\n//#include<cstdlib>\n//#include<cctype>\n//#include<cmath>\n//#include<set>\n//#include<queue>\n//#include<stack>\n//#include<list>\n//#include<iostream>\n//#include<fstream>\n//#include<numeric>\n//#include<string>\n//#include<vector>\n//#include<cstring>\n//#include<map>\n//#include<iterator>\n//#include<deque>\n//#include<climits>\n//#include<complex>\n\n#define S scanf\n#define P printf\n#define DI(X) int (X);             scanf(\"%d\", &X)\n#define DII(X, Y) int X, Y;        scanf(\"%d%d\", &X, &Y)\n#define DIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define DILL(X) LL (X); scanf(\"%lld\", &X)\n\n#define LL long long int\n#define ULL unsigned long long int\n#define D double\n\n#define all(a) a.begin(),a.end()\n#define X  first\n#define Y  second\n#define MP make_pair\n#define NL P(\"\\n\")\n\n#define PB(x)      push_back(x)\n#define PS(x)      push(x)\n#define sz()       size()\n#define UB         upper_bound\n#define LB         lower_bound\n#define countbit(x) __builtin_popcount(x)\n\n#define MEM(a,val) memset(a,val,sizeof(a));\n#define SET(a)     memset(a,-1,sizeof a)\n#define CLR(a)     memset(a,0,sizeof a)\n\nusing namespace std;\n\n\n#define ll long long int\n#define ull unsigned long long int\n#define inf (1<<30)\n#define linf (1LL<<60)\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define sc4(a,b,c,d) scanf(\"%d%d%d%d\",&a,&b,&c,&d)\n#define f(i,n) for(i=0;i<n;i++)\n#define fl(c,i,n) for(i=c;i<n;i++)\n#define mem(a) memset(a,0,sizeof(a))\n#define memn(a) memset(a,-1,sizeof(a))\n#define aov(a) a.begin(),a.end()\n#define pb push_back\n#define PI (2.0*acos(0.0)) //#define PI acos(-1.0)\n#define pll pair< ll , ll >\n#define pii pair< int , int >\n#define mpr make_pair\n#define xx first\n#define yy second\n#define nl puts(\"\")\n//#define endl '\\n'\n#define dbg(x) cerr<<#x<<\" : \"<<x<<endl\n#define mpp make_pair\n#define SZ(x) (int)(x.size())\n#define fr(i,a,n) for(int i=a;i<=n;i++)\n\n//template <typename T> T BigMod (T b,T p,T m){if (p == 0) return 1;if (p%2 == 0){T s = BigMod(b,p/2,m);return ((s%m)*(s%m))%m;}return ((b%m)*(BigMod(b,p-1,m)%m))%m;}\n//template <typename T> T ModInv (T b,T m){return BigMod(b,m-2,m);}\n//template <typename T> T POW(T B,T P){ if(P==0) return 1; if(P&1) return B*POW(B,P-1);  else return SQR(POW(B,P/2));}\n//template <typename T> LL isLeft(T a,T b,T c) { return (a.x-b.x)*(b.y-c.y)-(b.x-c.x)*(a.y-b.y); }\ntemplate <class T> inline T bigmod(T p,T e,T M){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;}return (T)ret;}\n//template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}   // M is prime}\ntemplate <class T> inline T bpow(T p,T e){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p);p = (p * p);}return (T)ret;}\n//\n//int    Set(int N,int pos){ return N=N | (1<<pos);}\n//int  Reset(int N,int pos){return N= N & ~(1<<pos);}\n//bool Check(int N,int pos){return (bool)(N & (1<<pos));}\n\n#define VI  vector< int >\n#define VII vector< VI >\n#define VLL vector< LL >\n#define PII pair< int , int >\n#define PLL pair< LL , LL >\n#define VPI vector< PII >\n\n\n/// Hashing Bases & MOD\n///           0123456789\n#define Base1 10000019ULL\n#define Base2 10000079ULL\n#define Base3 10000103ULL\n#define MOD1  1000000007ULL\n#define MOD2  1000000009ULL\n#define MOD3  1000000021ULL\n#define LOGX  17\n#define FCIN  ios_base::sync_with_stdio(0); cin.tie(0)\n\n///int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};  //Not Leap Year\n///int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n///int dx[]={-1,+1,0,1,0,-1}; // Hexagonal Direction   **\n///int dy[]={-1,+1,1,0,-1,0}; //                       *#*\n///                                                     **\nint dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 Direction\nint ts, kk = 1;\n\n\n///         0123456789\n#define MX  10000001.0\n#define MD  1000000001.0\n#define MOD 1000000007\n#define eps 1e-9\n#define M   200005\n#define MM  1010\n#define MD  1000000007LL\n\n#define lft ((i<<1)+1)\n#define rgt (lft+1)\n#define mid ((s+e)>>1)\n\nll n,m;\npll a[M];\nll c[M];\nll mx[M];\nll sm[M];\n\nll tr[M*4];\n\nvoid updt(int i,int s,int e,int p,ll v)\n{\n    if(s==e)\n    {\n        tr[i]=v;\n        return ;\n    }\n    if(p<=mid)updt(lft,s,mid,p,v);\n    else updt(rgt,mid+1,e,p,v);\n\n    tr[i]=min(tr[lft],tr[rgt]);\n}\n\nll qry(int i,int s,int e,int st,int ed)\n{\n    if(st<=s&&e<=ed)return tr[i];\n    if(ed<=mid)return qry(lft,s,mid,st,ed);\n    else if(mid<st)return qry(rgt,mid+1,e,st,ed);\n    return min(qry(lft,s,mid,st,ed),\n            qry(rgt,mid+1,e,st,ed));\n}\n\n\nint clc(int x)\n{\n    int lo,hi,md,q=-1;\n    lo=x+1;\n    hi=n-1;\n    while(lo<=hi)\n    {\n        md=(lo+hi)>>1;\n//        cerr<<x<<\" => \"<<md<<\" \"<<qry(0,0,n-1,x,md)<<endl;\n        if( qry(0,0,n-1,x+1,md)<=a[x].xx )hi=md-1;\n        else\n        {\n            ll q1,q2;\n\n            if( c[md]-a[x].xx+max(mx[md],a[x].yy)>=m )\n            {\n                q=md;\n                hi=md-1;\n            }\n            else\n                lo=md+1;\n        }\n    }\n    if(q==-1)return n+n;\n    return q;\n}\n\nint main()\n{\n    int t,i,j,k;\n\n    S(\"%lld%lld\",&n,&m);\n    f(i,n)\n    {\n        S(\"%lld%lld\",&a[i].yy,&a[i].xx);\n        a[i].xx=-(a[i].yy-a[i].xx);\n    }\n    f(i,n)\n    {\n        S(\"%lld\",&c[i]);\n        if(i)c[i]+=c[i-1];\n    }\n\n\n    sort(a,a+n);\n\n    mx[n]=-MD;\n    a[n].xx=-MD;\n    for(i=n-1;i>-1;i--)\n    {\n        mx[i]=max(a[i].yy,mx[i+1]);\n        a[i].xx=-a[i].xx;\n    }\n\n    ll cr=0;\n    for(i=0;i<n;i++)\n    {\n        cr+=a[i].xx;\n        sm[i]=cr;\n//        cerr<<i<<\" - \"<<sm[i]<<\" : \"<<c[i]<<\" = \"<<mx[i]<<endl;\n    }\n\n    int rs=n+n;\n    for(i=n-1;i>-1;i--)\n    {\n        if( sm[i]-a[i].xx+mx[i]>=m )\n            rs=min(rs,i+1);\n//        cerr<<i<<\" ----------------- \"<<sm[i]-c[i]<<endl;\n        rs=min(rs,clc(i));\n        updt(0,0,n-1,i,sm[i]-c[i]);\n    }\n\n    if(rs==n+n)rs=-1;\n\n    printf(\"%d\\n\",rs);\n\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst int INF = 0x3f3f3f3f;\nint c[N], ls[N], sum[N];\nint n, l, fr;\n\nstruct Node{\n  int a, b;\n}node[N];\nbool cmp(const Node& lh, const Node& rh){\n  if(lh.a-lh.b == rh.a-rh.b)  return lh.b > rh.b;\n  return lh.a-lh.b > rh.a-rh.b;\n}\nvoid pre(){\n  sort(node+1, node+n+1, cmp);\n  fr = n;\n  for(int i = 1; i <= n; i++) if(node[i].a <= node[i].b) {fr = i; break;}\n  for(int i = 1; i <= n; i++) sum[i] += sum[i-1]+node[i].a-node[i].b;\n  ll ca = 0;\n  int idx = 1;\n  for(int i = 2; i <= n; i++){\n    ca += node[i].a-node[i].b-c[idx];\n    if(ca <= 0) break;\n    idx++;\n  }\n  ls[1] = idx;\n  for(int i = 2; i <= n; i++){\n    if(idx == n) {ls[i]=n; continue;}\n    if(i >= idx){ls[i]=n; continue;}\n    ca += node[i-1].a-node[i-1].b-node[i].a+node[i].b;\n    while(ca > 0 && idx < n){\n      idx++;\n      ca += node[idx+1].a-node[idx+1].b-c[idx];\n    }\n    ls[i] = idx;\n  }\n}\nbool check(int x){\n  x--;\n  for(int i = 1; i <= n; i++){\n    ll lim = l - node[i].a;\n    if(ls[i] <= x) continue;\n    if(i > x && sum[x] >= lim) return true;\n    if(i <= x && sum[x+1]-node[i].a+node[i].b >= lim) return true;\n  }\n  return false;\n}\nint main()\n{\n  ll s, sa; s = 0;\n  scanf(\"%d%d\", &n, &l);\n  for(int i = 1; i <= n; i++) scanf(\"%d%d\", &node[i].a, &node[i].b);\n  for(int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  pre();\n  int ans = INF;\n  int left = 1, right = fr, mid;\n  while(left <= right){\n    mid = (left+right)/2;\n    if(check(mid)) right=mid-1;\n    else left=mid+1;\n  }\n  printf(\"%d\\n\", left==fr+1?-1:left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nlong long N, LL, A[100009], B[100009], C[100009], id[100009]; vector<pair<long long, long long>>X;\nlong long P1[100009], P2[100009], Q1[100009], Q2[100009];\n\nlong long sum(long long pos, long long XX) {\n\tif (pos < XX) return P1[pos];\n\treturn P2[pos] - X[XX - 1].first;\n}\nlong long query(long long pos, long long XX) {\n\tif (pos < XX) return Q1[pos];\n\treturn min(Q1[XX - 1], Q2[pos] - X[XX - 1].first);\n}\n\nint main() {\n\tcin >> N >> LL;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i]; id[i] = (1 << 30);\n\t\tif (A[i] - B[i] >= 1) X.push_back(make_pair(A[i] - B[i], i));\n\t}\n\tfor (int i = 1; i <= N; i++) { cin >> C[i]; C[i] += C[i - 1]; }\n\n\tsort(X.begin(), X.end(), greater<pair<long long, long long>>());\n\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tid[X[i].second] = i + 1; P1[i + 1] = X[i].first; P2[i] = X[i].first;\n\t\tP1[i + 1] += P1[i]; if (i >= 1) P2[i] += P2[i - 1];\n\t\tQ1[i + 1] = P1[i + 1]; Q2[i] = P2[i];\n\t}\n\tfor (int i = 1; i <= N; i++) { Q1[i] -= C[i]; Q2[i] -= C[i]; }\n\tQ1[0] = (1LL << 32); Q2[0] = (1LL << 32);\n\tfor (int i = 1; i <= N; i++) { Q1[i] = min(Q1[i], Q1[i - 1]); Q2[i] = min(Q2[i], Q2[i - 1]); }\n\n\tlong long ans = (1 << 30);\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tlong long L = 0, R = X.size(), M, maxn = (1 << 30); if (id[i] == (1 << 30)) R++; R = min(R, N);\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tlong long ti = sum(M, id[i]);\n\t\t\tif (ti >= LL - A[i]) { R = M; maxn = min(maxn, M); }\n\t\t\telse { L = M; }\n\t\t}\n\t\tlong long L2 = 0, R2 = X.size(), M2, maxn2 = -1; if (id[i] == (1 << 30)) R2++; R2 = min(R2, N);\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tM2 = (L2 + R2) / 2;\n\t\t\tlong long rmq = query(M2, id[i]);\n\t\t\tif (rmq > 0) { maxn2 = max(maxn2, M2); L2 = M2; }\n\t\t\telse { R2 = M2; }\n\t\t}\n\t\tif (maxn2 < maxn) continue;\n\t\tans = min(ans, maxn + 1);\n\t}\n\tif (ans == (1 << 30)) ans = -1;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {};\nint m; ll dat[199999];\nvoid init(int m_) {\n\tm = 1;\n\twhile (m < m_)m *= 2;\n\trep(i, 2 * m - 1)dat[i] = INF;\n}\nvoid update(int k,ll a) {\n\tk += m - 1; dat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n;\n\tll l; cin >> n >> l; m = n - 1;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tinit(m);\n    rep(i, n - 1) {\n\t\tupdate(i,sum[i + 1] - csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tll mi = query(i, loc, 0, 0, m);\n\t\t\tif (mi-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define EACH(i, a) for(auto&& i:a)\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,a,b) for(ll i = (b)-1; i >= (a); --i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define ALL(v) (v).begin(),(v).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\n\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\n\nstruct Drink {\n    ll A, B;\n};\nistream& operator>>(istream& is, Drink& d) {\n    return cin >> d.A >> d.B;\n}\nbool operator<(const Drink& d1, const Drink& d2) {\n    return d1.A - d1.B < d2.A - d2.B;\n}\nbool operator>(const Drink& d1, const Drink& d2) {\n    return d2 < d1;\n}\n\n// template<class T>\n// T lower_bound(T l, T r, ll times, const function<bool(T)>& check) {\n//     while (times--) {\n//         T m = (l + r) / 2;\n//         if ( check(m) ) {\n//             r = m;\n//         }\n//         else {\n//             l = m;\n//         }\n//     }\n//     return r;\n// }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, L; cin >> n >> L;\n    vector<Drink> D(n); cin >> D;\n    vector<ll> C(n); cin >> C;\n    sort(ALL(D), greater<Drink>());\n    // ll pos = lower_bound<ll>(0, n, 50, [&](ll m) {\n    //     return true;\n    // });\n    vector<ll> M(n+1, 0);\n    RREP(i, n) M[i] = max(M[i+1], D[i].A);\n    if ( M[0] >= L ) {\n        cout << 1 << endl;\n        return 0;\n    }\n    // d??\\??§??§?????????\n    auto check = [&](ll d) {\n        // pos?????????????????§???d-1??\\?????????????????????\n        auto check = [&](ll pos) {\n            ll j = 0;\n            ll sum1 = 0, sum2 = 0;\n            REP(i, d) {\n                if (i == pos) continue;\n                sum1 += D[i].A - D[i].B;\n                sum2 += C[j++];\n                if (sum1 <= sum2) return false;\n                if (sum1+M[i+1] >= L) return true;\n            }\n            return true;\n        };\n        if ( !check(d) ) return false;\n        ll l = 0, r = d;\n        REP(t, 50) {\n            ll m = (l + r) / 2;\n            if ( check(m) ) {\n                r = m;\n            }\n            else {\n                l = m;\n            }\n        }\n        ll pos = r;\n        ll sum = 0;\n        REP(i, d) if (D[i].A - D[i].B > 0) {\n            sum += D[i].A - D[i].B;\n        }\n        vector<ll> S(d+2, 0);\n        REP(i, d-1) S[i+1] = S[i]+D[i].A-D[i].B;\n        S[d+1] = linf;\n        FOR(i, pos, d) {\n            if (sum + D[i].B >= L) return true;\n        }\n        sum -= D[d-1].A - D[d-1].B;\n        FOR(i, d-1, n) {\n            ll lb = lower_bound(ALL(S), L-D[i].A)-S.begin();\n            if (lb < d) return true;\n        }\n        return false;\n    };\n    // cout << check(5) << endl;\n    // return 0;\n    ll l = 0, r = n;\n    REP(i, n) {\n        if (D[i].A - D[i].B < 0) {\n            r = i;\n            break;\n        }\n    }\n    REP (t, 50) {\n        ll m = (l + r) / 2;\n        if ( check(m) ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    if ( !check(n) ) {\n        cout << -1 << endl;\n    }\n    else {\n        cout << r << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst int INF = 0x3f3f3f3f;\nint c[N], ls[N];\nll sum[N];\nint n, l, fr;\n\nstruct Node{\n  int a, b;\n}node[N];\nbool cmp(const Node& lh, const Node& rh){\n  if(lh.a-lh.b == rh.a-rh.b)  return lh.b > rh.b;\n  return lh.a-lh.b > rh.a-rh.b;\n}\nvoid pre(){\n  sort(node+1, node+n+1, cmp);\n  fr = n;\n  for(int i = 1; i <= n; i++) if(node[i].a <= node[i].b) {fr = i; break;}\n  for(int i = 1; i <= n; i++) sum[i] += sum[i-1]+node[i].a-node[i].b;\n  ll ca = 0;\n  int idx = 1;\n  for(int i = 2; i <= n; i++){\n    ca += node[i].a-node[i].b-c[idx];\n    if(ca <= 0) break;\n    idx++;\n  }\n  ls[1] = idx;\n  for(int i = 2; i <= n; i++){\n    if(idx == n) {ls[i]=n; continue;}\n    if(i >= idx){ls[i]=n; continue;}\n    ca += node[i-1].a-node[i-1].b-node[i].a+node[i].b;\n    while(ca > 0 && idx < n){\n      idx++;\n      ca += node[idx+1].a-node[idx+1].b-c[idx];\n    }\n    ls[i] = idx;\n  }\n}\nbool check(int x){\n  x--;\n  for(int i = 1; i <= n; i++){\n    ll lim = l - node[i].a;\n    if(ls[i] <= x) continue;\n    if(i > x && sum[x] >= lim) return true;\n    if(i <= x && sum[x+1]-node[i].a+node[i].b >= lim) return true;\n  }\n  return false;\n}\nint main()\n{\n  ll s, mx; s = 0, mx = -1;\n  scanf(\"%d%d\", &n, &l);\n  for(int i = 1; i <= n; i++) {scanf(\"%d%d\", &node[i].a, &node[i].b); mx = max(mx, (ll)node[i].a);}\n  for(int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  if(mx >= l){printf(\"1\\n\"); return 0;}\n  pre();\n  int left = 1, right = fr, mid;\n  while(left <= right){\n    mid = (left+right)/2;\n    if(check(mid)) right=mid-1;\n    else left=mid+1;\n  }\n  printf(\"%d\\n\", check(left)?left:-1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define rez(v, n) (v).clear(), (v).resize(n)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\ntemplate<class T> struct Min {\n  T nil;\n  Min(){}\n  Min(T nil):nil(nil){}\n  T operator()(T a, T b) {\n    return a < b ? a : b;\n  }\n};\ntemplate<class T> struct Max {\n  T nil;\n  Max(){}\n  Max(T nil):nil(nil){}\n  T operator()(T a, T b) {\n    return a > b ? a : b;\n  }\n};\n\ntemplate<class T, class F>\nstruct SegmentTree {\n  vector<T> data;\n  F func;\n  int sz;\n  SegmentTree(int n, F f) {\n    func = f;\n    sz = 1; while(sz < n) sz <<= 1;\n    data.resize(2*sz+1, func.nil);\n  }\n  void update(int k, T x) {\n    k += sz-1;\n    data[k] = x;\n    while(k > 0) {\n      k = (k-1)/2;\n      data[k] = func(data[2*k+1], data[2*k+2]);\n    }\n  }\n  T query(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return func.nil;\n    if(a <= l && r <= b) return data[k];\n    return func(query(a, b, 2*k+1, l, (l+r)/2),\n\t       query(a, b, 2*k+2, (l+r)/2, r));\n  }\n  T query(int a, int b) {\n    return query(a, b, 0, 0, sz);\n  }\n};\n\nint N, L;\nvint A, B, C, D;\nvint sumC, sumD;\nvint idx;\n\nbool cmp(int i, int j) {\n  return D[i] > D[j];\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> L;\n  rez(A, N), rez(B, N), rez(C, N), rez(D, N);\n  rep(i, N) {\n    cin >> A[i] >> B[i];\n    D[i] = A[i]-B[i];\n  }\n  rep(i, N) {\n    cin >> C[i];\n  }\n\n  rez(idx, N);\n  rep(i, N) idx[i] = i;\n  sort(all(idx), cmp);\n  rez(sumC, N+1), rez(sumD, N+1);\n  rep(i, N) {\n    sumD[i+1] = sumD[i] + D[idx[i]];\n    sumC[i+1] = sumC[i] + C[i];\n  }\n\n  SegmentTree< int, Max<int> > segA(N, Max<int>(-inf)), segB(N, Max<int>(-inf));\n  rep(i, N) {\n    int k = idx[i];\n    segA.update(i, A[k]);\n    segB.update(i, B[k]);\n  }\n\n  SegmentTree< int, Min<int> > segX(N, Min<int>(inf));\n  rep(i, N) {\n    segX.update(i, sumD[i+1]-sumC[i+1]);\n  }\n\n  int ans = inf;\n  rep(i, N) {\n    int a = segA.query(i, N);\n    if(sumD[i]+a >= L) {\n      //cout<<sumD[i]+a<<\" \"<<L<<endl;\n      chmin(ans, i);\n      break;\n    }\n\n    //cout<<\"BIN_SEARCH\"<<endl;\n    int lb = -1, ub = i;\n    while(lb+1 < ub) {\n      int mb = (lb+ub)/2;\n      //cout<<idx[mb]<<\" \"<<idx[i]<<endl;\n      //cout<<segX.query(mb, i) << \" \"<< D[idx[mb]]-D[idx[i]]<<endl;\n      if(segX.query(mb, i) > D[idx[mb]]-D[idx[i]]) ub = mb;\n      else lb = mb;\n    }\n    int b = segB.query(ub, i);\n    if(b != -inf) {\n      //cout<<\"OK\"<<endl;\n      //cout << ub << \" \" << b << endl;\n      //cout<<sumD[i+1]<<\" \" << b << endl;\n      if(sumD[i+1]+b >= L) {\n\tchmin(ans, i);\n\tbreak;\n      }\n    }\n    if(sumD[i+1] <= sumC[i+1]) break;\n  }\n\n  cout << (ans == inf ? -1 : ans+1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*****************************************************************\n *                   BISMILLAHIR RAHMANIR RAHIM                  *\n *                           JU_Circavex                         *\n *****************************************************************/\n\n#include<bits/stdc++.h>\n\n//#include<algorithm>\n//#include<cstdio>\n//#include<sstream>\n//#include<cstdlib>\n//#include<cctype>\n//#include<cmath>\n//#include<set>\n//#include<queue>\n//#include<stack>\n//#include<list>\n//#include<iostream>\n//#include<fstream>\n//#include<numeric>\n//#include<string>\n//#include<vector>\n//#include<cstring>\n//#include<map>\n//#include<iterator>\n//#include<deque>\n//#include<climits>\n//#include<complex>\n\n#define S scanf\n#define P printf\n#define DI(X) int (X);             scanf(\"%d\", &X)\n#define DII(X, Y) int X, Y;        scanf(\"%d%d\", &X, &Y)\n#define DIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define DILL(X) LL (X); scanf(\"%lld\", &X)\n\n#define LL long long int\n#define ULL unsigned long long int\n#define D double\n\n#define all(a) a.begin(),a.end()\n#define X  first\n#define Y  second\n#define MP make_pair\n#define NL P(\"\\n\")\n\n#define PB(x)      push_back(x)\n#define PS(x)      push(x)\n#define sz()       size()\n#define UB         upper_bound\n#define LB         lower_bound\n#define countbit(x) __builtin_popcount(x)\n\n#define MEM(a,val) memset(a,val,sizeof(a));\n#define SET(a)     memset(a,-1,sizeof a)\n#define CLR(a)     memset(a,0,sizeof a)\n\nusing namespace std;\n\n\n#define ll long long int\n#define ull unsigned long long int\n#define inf (1<<30)\n#define linf (1LL<<60)\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define sc4(a,b,c,d) scanf(\"%d%d%d%d\",&a,&b,&c,&d)\n#define f(i,n) for(i=0;i<n;i++)\n#define fl(c,i,n) for(i=c;i<n;i++)\n#define mem(a) memset(a,0,sizeof(a))\n#define memn(a) memset(a,-1,sizeof(a))\n#define aov(a) a.begin(),a.end()\n#define pb push_back\n#define PI (2.0*acos(0.0)) //#define PI acos(-1.0)\n#define pll pair< ll , ll >\n#define pii pair< int , int >\n#define mpr make_pair\n#define xx first\n#define yy second\n#define nl puts(\"\")\n//#define endl '\\n'\n#define dbg(x) cerr<<#x<<\" : \"<<x<<endl\n#define mpp make_pair\n#define SZ(x) (int)(x.size())\n#define fr(i,a,n) for(int i=a;i<=n;i++)\n\n//template <typename T> T BigMod (T b,T p,T m){if (p == 0) return 1;if (p%2 == 0){T s = BigMod(b,p/2,m);return ((s%m)*(s%m))%m;}return ((b%m)*(BigMod(b,p-1,m)%m))%m;}\n//template <typename T> T ModInv (T b,T m){return BigMod(b,m-2,m);}\n//template <typename T> T POW(T B,T P){ if(P==0) return 1; if(P&1) return B*POW(B,P-1);  else return SQR(POW(B,P/2));}\n//template <typename T> LL isLeft(T a,T b,T c) { return (a.x-b.x)*(b.y-c.y)-(b.x-c.x)*(a.y-b.y); }\ntemplate <class T> inline T bigmod(T p,T e,T M){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;}return (T)ret;}\n//template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}   // M is prime}\ntemplate <class T> inline T bpow(T p,T e){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p);p = (p * p);}return (T)ret;}\n//\n//int    Set(int N,int pos){ return N=N | (1<<pos);}\n//int  Reset(int N,int pos){return N= N & ~(1<<pos);}\n//bool Check(int N,int pos){return (bool)(N & (1<<pos));}\n\n#define VI  vector< int >\n#define VII vector< VI >\n#define VLL vector< LL >\n#define PII pair< int , int >\n#define PLL pair< LL , LL >\n#define VPI vector< PII >\n\n\n/// Hashing Bases & MOD\n///           0123456789\n#define Base1 10000019ULL\n#define Base2 10000079ULL\n#define Base3 10000103ULL\n#define MOD1  1000000007ULL\n#define MOD2  1000000009ULL\n#define MOD3  1000000021ULL\n#define LOGX  17\n#define FCIN  ios_base::sync_with_stdio(0); cin.tie(0)\n\n///int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};  //Not Leap Year\n///int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n///int dx[]={-1,+1,0,1,0,-1}; // Hexagonal Direction   **\n///int dy[]={-1,+1,1,0,-1,0}; //                       *#*\n///                                                     **\nint dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 Direction\nint ts, kk = 1;\n\n\n///         0123456789\n#define MX  10000001.0\n#define MD  1000000001.0\n#define MOD 1000000007\n#define eps 1e-9\n#define M   100005\n#define MM  1010\n#define MD  1000000007LL\n\n#define lft ((i<<1)+1)\n#define rgt (lft+1)\n#define mid ((s+e)>>1)\n\nll n,m;\npll a[M];\nll c[M];\nll mx[M];\nll sm[M];\n\nll tr[M*4];\n\nvoid updt(int i,int s,int e,int p,ll v)\n{\n    if(s==e)\n    {\n        tr[i]=v;\n        return ;\n    }\n    if(p<=mid)updt(lft,s,mid,p,v);\n    else updt(rgt,mid+1,e,p,v);\n\n    tr[i]=min(tr[lft],tr[rgt]);\n}\n\nll qry(int i,int s,int e,int st,int ed)\n{\n    if(st<=s&&e<=ed)return tr[i];\n    if(ed<=mid)return qry(lft,s,mid,st,ed);\n    else if(mid<st)return qry(rgt,mid+1,e,st,ed);\n    return min(qry(lft,s,mid,st,ed),\n            qry(rgt,mid+1,e,st,ed));\n}\n\n\nint clc(int x)\n{\n    int lo,hi,md,q=-1;\n    lo=x+1;\n    hi=n-1;\n    while(lo<=hi)\n    {\n        md=(lo+hi)>>1;\n//        cerr<<x<<\" => \"<<md<<\" \"<<qry(0,0,n-1,x,md)<<endl;\n        if( qry(0,0,n-1,x+1,md)<=a[x].xx )hi=md-1;\n        else\n        {\n            if( c[md]-a[x].xx+max(mx[md],a[x].yy)>=m )\n            {\n                q=md;\n                hi=md-1;\n            }\n            else\n                lo=md+1;\n        }\n    }\n    if(q==-1)return INT_MAX;\n    return q;\n}\n\nint main()\n{\n    int t,i,j,k;\n\n    S(\"%lld%lld\",&n,&m);\n    f(i,n)\n    {\n        S(\"%lld%lld\",&a[i].yy,&a[i].xx);\n        a[i].xx=-(a[i].yy-a[i].xx);\n    }\n    f(i,n)\n    {\n        S(\"%lld\",&c[i]);\n        if(i)c[i]+=c[i-1];\n    }\n\n\n    sort(a,a+n);\n\n    mx[n]=-MD;\n    a[n].xx=-MD;\n    for(i=n-1;i>-1;i--)\n    {\n        mx[i]=max(a[i].yy,mx[i+1]);\n        a[i].xx=-a[i].xx;\n    }\n\n    ll cr=0;\n    for(i=0;i<n;i++)\n    {\n        cr+=a[i].xx;\n        sm[i]=cr;\n        if(sm[i]<=c[i])break;\n//        cerr<<i<<\" - \"<<sm[i]<<\" : \"<<c[i]<<\" = \"<<mx[i]<<endl;\n    }\n    n=i;\n\n    int rs=INT_MAX;\n    for(i=n-1;i>-1;i--)\n    {\n        if( sm[i]-a[i].xx+mx[i]>=m )\n            rs=min(rs,i+1);\n//        cerr<<i<<\" ----------------- \"<<sm[i]-c[i]<<endl;\n        rs=min(rs,clc(i));\n        updt(0,0,n-1,i,sm[i]-c[i]);\n    }\n\n    if(rs==INT_MAX)rs=-1;\n\n    printf(\"%d\\n\",rs);\n\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first > 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005;\nstruct rec {\n\tint a,b,d;\n};\nint s[N],c[N],n,h;\nrec a[N];\npriority_queue<pair<int,int> > dui1,dui2;\nbool cmp(const rec &a, const rec &b){\n\treturn a.d > b.d;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&h);\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%d%d\",&a[i].a,&a[i].b);\n\t\ta[i].d = a[i].a - a[i].b;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\",&c[i]);\n\ts[0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\ts[i] = s[i - 1] + c[i];\n\tsort(a + 1,a + n + 1,cmp);\n//\tfor (int i = 1; i <= n; i++)\n//\t\tprintf(\"%d\\n\",a[i].d);\n//\tprintf(\"!!!!\\n\");\n\tint len = 1;\n\tint p = 1;\n\tint s = 0;\n\tint ss = a[1].d;\n\tdui1.push(make_pair(a[1].b,1));\n\tfor (int i = 2; i <= n; i++)\n\t\tdui2.push(make_pair(a[i].a,i));\n//\tprintf(\"!!!!\\n\");\n\twhile (len <= n){\n\t\tif (s > 0 || len == 1){\n//\t\t\tprintf(\"!%d %d %d\\n\",len,p,s);\n\t\t\twhile (! dui1.empty())\n\t\t\t\tif (dui1.top().second < p)\n\t\t\t\t\tdui1.pop();\n\t\t\t\telse break;\n\t\t\tif ((! dui1.empty()))\n\t\t\t\tif (dui1.top().first + ss >= h)\n\t\t\t\t\tbreak;\n//\t\t\tprintf(\"!%d\\n\",len);\n\t\t\twhile (! dui2.empty())\n\t\t\t\tif (dui2.top().second <= len)\n\t\t\t\t\tdui2.pop();\n\t\t\t\telse break;\n\t\t\tif ((! dui2.empty()))\n\t\t\t\tif (dui2.top().first - a[len].d + ss >= h)\n\t\t\t\t\tbreak;\n\t\t}\n//\t\tprintf(\"!%d\\n\",len);\n\t\tlen++;\n\t\tdui1.push(make_pair(a[len].b,len));\n//\t\tprintf(\"!! %d\\n\",s);\n\t\ts += a[len].d - c[len - 1];\n//\t\tprintf(\"!! %d %d %d %d\\n\",s,a[len].d,len,c[len - 1]);\n\t\tss += a[len].d;\n\t\twhile (s <= 0 && p < len){\n\t\t\ts += a[p].d - a[p + 1].d;\n\t\t\tp++;\n\t\t}\n\t}\n//\tprintf(\"!!!!\\n\");\n\tif (len <= n) printf(\"%d\\n\",len);\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n \nint INF=1001001001001001001ll;\nstruct segtree{\n    static const int SEG=1<<17;\n    vint dat;\n    segtree():dat(SEG*2,INF){}\n    void update(int k,int x){\n        k+=SEG-1;\n        dat[k]=x;\n        while(k){\n            k=(k-1)/2;\n            dat[k]=min(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    int query(int a,int b,int k=0,int l=0,int r=SEG){\n        if(r<=a||b<=l)return INF;\n        if(a<=l&&r<=b)return dat[k];\n        return min(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n    }\n};\n \nint N,L;\nint A[100000],B[100000];\nint C[100000];\n \nint premin[111111];\nint sufmax[111111];\n \nint SA[111111];\nint SC[111111];\nsigned main(){\n    scanf(\"%lld%lld\",&N,&L);\n    rep(i,N)scanf(\"%lld%lld\",&A[i],&B[i]);\n    rep(i,N)scanf(\"%lld\",&C[i]);\n    rep(i,N)SC[i+1]=SC[i]+C[i];\n    vpint vec;\n    rep(i,N)vec.pb(pint(B[i]-A[i],B[i]));\n    sort(all(vec));\n    rep(i,N){\n        A[i]=-vec[i].fi+vec[i].se;\n        B[i]=vec[i].se;\n    }\n    rep(i,N)SA[i+1]=SA[i]+A[i]-B[i];\n \n    sufmax[N]=-1001001001;\n    for(int i=N-1;i>=0;i--){\n        sufmax[i]=max(sufmax[i+1],A[i]);\n    }\n    premin[0]=1001001001;\n    for(int i=1;i<=N;i++){\n        premin[i]=min(premin[i-1],SA[i]-SC[i]);\n    }\n \n \n    int ans=INF;\n    for(int i=0;i<N;i++){\n        if(premin[i]<=0)break;\n        if(SA[i]+sufmax[i]>=L)chmin(ans,i+1);\n    }\n \n \n    deque<pint>Bs;\n    deque<pint>As;\n    for(int i=1;i<=N;i++){\n        if(A[i-1]-B[i-1]<=0)break;\n        while(Bs.size()&&Bs.back().fi<=B[i-1])Bs.pop_back();\n        Bs.pb(pint(B[i-1],i-1));\n        while(Bs.size()>1&&Bs[1].fi+SA[i]>=L)Bs.pop_front();\n \n        int t=Bs.front().se;\n        if(B[t]+SA[i]<L)continue;\n        if(premin[t]<=0)continue;\n \n        while(As.size()&&As.back().fi>=SA[i]-SC[i-1])As.pop_back();\n        As.pb(pint(SA[i]-SC[i-1],i-2));\n        while(As.size()&&As.front().se<t)As.pop_front();\n        if(As.size()&&As.front().fi-(A[t]-B[t])<=0)continue;\n        chmin(ans,i);\n    }\n \n    if(ans!=INF)cout<<ans<<endl;\n    else cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1e5+5;\nconst int imax=1e6;\nconst int inf=99999999;\nint en,n,a[maxn],c[maxn],tree[imax],sum[maxn];\n\nstruct node\n{\n\tint x,id;\n//\tnode(int x,int id):x(x),id(id){}\n}p[maxn];\n\nbool operator < (node a,node b){ return a.x==b.x?a.id<b.id:a.x<b.x; }\n\nvoid build(int l,int r,int rt)\n{\n\tif(l==r)\n\t{\n\t\ttree[rt]=sum[l]-c[l-1];\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,rt*2);\n\tbuild(mid+1,r,rt*2+1);\n\ttree[rt]=min(tree[rt*2],tree[rt*2+1]); \n}\n\n/*int qu(int L,int R,int l,int r,int rt)\n{\n\tif(r<L||l>R)\treturn inf;\n\tif(l>=L&&r<=R)\treturn tree[rt];\n\tint mid=(l+r)>>1;\n\tint a1=inf,a2=inf;\n\ta1=qu(L,R,l,mid,rt*2);\n\ta2=qu(L,R,mid,r,rt*2+1);\n\treturn min(a1,a2);\n}*/\n\nint qu(int L,int R,int l,int r,int rt)\n{\n    if(L>R) return inf;\n    if(L<=l&&r<=R) return tree[rt];\n    int mid=(l+r)/2;\n    int a1=inf,a2=inf;\n    if(L<=mid) a1=qu(L,R,l,mid,rt*2);\n    if(R>mid) a2=qu(L,R,mid+1,r,rt*2+1);\n    return min(a1,a2);\n}\n\nbool check(int i,int mid)\n{\n\tif(i>mid)\treturn sum[mid]+a[p[i].id]>=en;\n\treturn sum[mid]+a[p[i].id]-p[i].x>=en;\n}\n\nint main()\n{\n\tint ans=inf;\n\tc[0]=0;\n\tsum[0]=0;\n\tscanf(\"%d%d\",&n,&en);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint tmp;\n\t\tscanf(\"%d%d\",a+i,&tmp);\n\t\tp[i].x=a[i]-tmp;\n\t\tp[i].id=i;\n\t\tsum[i]=sum[i-1]+p[i].x;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",c+i);\n\t\tc[i]+=c[i-1];\n\t}\n\tsort(p+1,p+1+n);\n\tbuild(1,n,1);\n\tint gg=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(p[i].x<0)\n\t\t{\n\t\t\tgg=i;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\tgg++;\n//\tprintf(\"gg==%d\\n\",gg);\n\tint num=1;\n\twhile(sum[num]>c[num])\n\t{\n\t\tif(num>n)\tbreak;\n\t\tnum++;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint l=0,r=gg;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(check(i,mid))\tr=mid;\n\t\t\tl=mid+1;\n\t\t}\n\t//\tprintf(\"he\\n\");\n\t\tif(r>n)\tcontinue;\n\t\tif(r<i)\n\t\t{\n\t\t\tif(r<num)\tans=min(ans,r+1);\n\t\t}\n\t\telse\n\t\tif(qu(i,r,1,n,1)>p[i].x)\tans=min(ans,r);\n\t//\tprintf(\"douwo\\n\");\n\t}\n\tif(ans==inf)\tprintf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define P pair<ll,ll>\n#define inf 0x3f3f3f3f\nconst int maxn=200005;\nll pre1[maxn],pre2[maxn],a[maxn],b[maxn],d[maxn];\nP c[maxn];\nint bin(int x,ll targ,ll end)\n{\n\tint l=0,r=end+1;\n\twhile(r-l>1)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tll sum=0;\n\t\tif(x<=mid)\n\t\tsum=pre1[mid]+b[c[x].second];\n\t\telse\n\t\tsum=pre1[mid]+a[c[x].second];\n\t\tif(sum>=targ)\n\t\tr=mid;\n\t\telse\n\t\tl=mid;\n\t}\n\treturn r;\n}\nbool cmp(P x,P y)\n{\n\treturn x.first>y.first;\n}\nint main()\n{\n\tll n,l;\n\tll ans=inf;\n\tscanf(\"%lld%lld\",&n,&l);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tc[i]=P(a[i]-b[i],i);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&d[i]);\n\tsort(c+1,c+1+n,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpre1[i]=pre1[i-1]+c[i].first;\n\t\tpre2[i]=pre2[i-1]+d[i];\n\t}\n\tint sum1=0,sum2=0;\n\tint pos=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(pos<=n&&sum1+c[pos+1].first>sum2+d[pos])\n\t\t{\n\t\t\tpos++;\n\t\t\tsum1+=c[pos+1].first;\n\t\t\tsum2+=d[pos];\n\t\t}\n\t\tif(a[c[i].second]>=l)\n\t\tans=1;\n\t\tll tmp=bin(i,l,pos);\n\t\tif(tmp<pos+1)\n\t\tans=min(ans,tmp+(tmp<i));\n\t\tif(pos>i)\n\t\tsum1+=c[i].first;\n\t\tif(pos>i+1)\n\t\tsum1-=c[i+1].first;\n\t}\n\tif(ans==inf)\n\tprintf(\"-1\");\n\telse\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {};\nint m; ll dat[399999];\nvoid init(int m_) {\n\tm = 1;\n\twhile (m < m_)m *= 2;\n\trep(i, 2 * m - 1)dat[i] = INF;\n}\nvoid updat(int k,ll a) {\n\tk += m - 1; dat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n;\n\tll l; cin >> n >> l; m = n - 1;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tint chk;\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tif (x[i].first <= 0)chk = i;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tinit(m);\n    rep(i, n - 1) {\n\t\tupdat(i,sum[i + 1] - csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + chk, l - ny) - sum;\n\t\tif (loc == chk)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + chk, l - ny + nx) - sum;\n\t\t\tif (loc == chk)continue;\n\t\t\tll mi = query(i, loc, 0, 0, m);\n\t\t\tif (mi-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1LL<<60\ntypedef long long ll;\ntypedef pair<ll,int> P;\nvector<ll> dif;\nvector<P> dif2;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<17;\n\tll dp[1<<18];\n\tint cnt[1<<18];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(cnt,0,sizeof(cnt));\n\t}\n\n\tvoid update(int k,P p){\n\t\tk+=N-1;\n\t\tcnt[k]+=p.first;\n\t\tdp[k]+=p.second;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[k]=dp[k*2+1]+dp[k*2+2];\n\t\t\tcnt[k]=cnt[k*2+1]+cnt[k*2+2];\n\t\t}\n\t}\n\n\tint find(ll v){\n\t\tif(dp[0]<v)return -1;\n\t\tint k=0,l=0,r=N;\n\t\tll sum=0;\n\t\tint cc=0;\n\t\twhile(r-l>1){\n\t\t\tif(dp[k*2+2]>=v){\n\t\t\t\tl=(l+r)/2;\n\t\t\t\tk=k*2+2;\n\t\t\t}else{\n\t\t\t\tv-=dp[k*2+2];\n\t\t\t\tcc+=cnt[k*2+2];\n\t\t\t\tr=(l+r)/2;\n\t\t\t\tk=k*2+1;\n\t\t\t}\n\t\t}\n\t\treturn cc+1;\n\t}\n};\n\nclass segtree2{\npublic:\n\tstatic const int N=1<<17;\n\tll dp[1<<18];\n\tsegtree2(){\n\t\tfor(int i=0;i<N*2;i++){\n\t\t\tdp[i]=INF;\n\t\t}\n\t}\n\n\tvoid update(int k,ll p){\n\t\tk+=N-1;\n\t\tdp[k]=p;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t\t}\n\t}\n\tll query(int a,int b,int k=0,int l=0,int r=N){\n\t\tif(r<=a || b<=l)return INF;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tll vl=query(a,b,k*2+1,l,mid);\n\t\tll vr=query(a,b,k*2+2,mid,r);\n\t\treturn min(vl,vr);\n\t}\n};\n\n\nsegtree seg;\nsegtree2 segsum;\nsegtree2 segsum2;\n\nint n;\nll l;\nll a[100005],b[100005];\nll c[100005];\n\nint main(void){\n\tscanf(\"%d%lld\",&n,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tif(a[i]-b[i]>0)dif.push_back(a[i]-b[i]);\n\t\tif(a[i]-b[i]>0)dif2.push_back(P(a[i]-b[i],i));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld\",&c[i]);\n\t}\n\tsort(dif.begin(),dif.end());\n\tsort(dif2.begin(),dif2.end());\n\tll sum=0;\n\tfor(int i=0;i<dif.size();i++){\n\t\tsum+=dif[dif.size()-1-i]-c[i];\n\t\t//printf(\"sum %lld\\n\",sum);\n\t\tsegsum.update(i,sum);\n\t\tif(i+1<dif.size()){\n\t\t\tsegsum2.update(i,sum+dif[dif.size()-2-i]);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(a[i]-b[i]>0){\n\t\t\tint v=lower_bound(dif2.begin(),dif2.end(),P(a[i]-b[i],i))-dif2.begin();\n\t\t\tseg.update(v,P(1,a[i]-b[i]));\n\t\t}\n\t}\n\tint ans=n+1;\n\tfor(int i=0;i<n;i++){\n\t\tll rest=l-a[i];\n\t\tif(rest<=0){\n\t\t\tans=1;\n\t\t}else{\n\t\t\tint v=lower_bound(dif2.begin(),dif2.end(),P(a[i]-b[i],i))-dif2.begin();\n\t\t\tif(a[i]-b[i]>0)seg.update(v,P(-1,-a[i]+b[i]));\n\t\t\tint co=seg.find(rest);\n\t\t\tif(a[i]-b[i]>0)seg.update(v,P(1,a[i]-b[i]));\n\t\t\tif(co==-1)continue;\n\t\t\tv=lower_bound(dif.begin(),dif.end(),a[i]-b[i])-dif.begin();\n\t\t\tv=dif.size()-1-v;\n\t\t\tif((a[i]-b[i]<=0 && segsum.query(0,co)>0) || (a[i]-b[i]>0 && segsum.query(0,min(v,co))>0 && segsum2.query(v,co)>a[i]-b[i])){\n\t\t\t\t//printf(\"%d %d %lld %lld %lld\\n\",i,co,rest,segsum.query(0,min(v,co)),segsum2.query(v,co));\n\t\t\t\tans=min(ans,co+1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans==(n+1)?-1:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2e5+5;\ntypedef long long ll;\n\nint n;\nll L,c[N],slen[N],dis[N];\npair<ll,ll>a[N];\n\nint cmp(pair<ll,ll> x,pair<ll,ll> y)\n{\n    return x.first-x.second>y.first-y.second;\n}\n\nstruct rmq\n{\n    ll mn[N][20],mx[N][20];\n    void init(ll *a)\n    {\n        for(int i=1;i<=n;i++) mn[i][0]=mx[i][0]=a[i];\n        int t=log(n)/log(2);\n        for(int j=1;j<=t;j++)\n            for(int i=1;i<=n-(1<<j)+1;i++)\n            {\n                mn[i][j]=min(mn[i][j-1],mn[i+(1<<(j-1))][j-1]);\n                mx[i][j]=max(mx[i][j-1],mx[i+(1<<(j-1))][j-1]);\n            }\n    }\n    ll get_mn(int l,int r)\n    {\n        int t=log(r-l+1)/log(2);\n        return min(mn[l][t],mn[r-(1<<t)+1][t]);\n    }\n    ll get_mx(int l,int r)\n    {\n        int t=log(r-l+1)/log(2);\n        return max(mx[l][t],mx[r-(1<<t)+1][t]);\n    }\n}rmqlen,rmqdis;\n\nint main()\n{\n    //freopen(\"F.in\",\"r\",stdin);\n    scanf(\"%d %d\",&n,&L);\n    for(int i=1;i<=n;i++)\n        scanf(\"%lld %lld\",&a[i].first,&a[i].second);\n    sort(a+1,a+1+n,cmp);\n    c[0]=0;\n    for(int i=1;i<=n;i++)\n        scanf(\"%lld\",&c[i]);\n    slen[0]=dis[0]=0;\n    for(int i=1;i<=n;i++) slen[i]=slen[i-1]+a[i].first-a[i].second;\n    for(int i=1;i<=n;i++) dis[i]=dis[i-1]+a[i].first-a[i].second-c[i-1];\n    rmqlen.init(slen);\n    rmqdis.init(dis);\n    ll sum=0,len=0;\n    int fin=0,ans=n+1;\n    for(int i=1;i<=n;i++)\n    {\n        if(i>1&&rmqlen.get_mx(1,i-1)+a[i].first>=L)\n        {\n            int l=0,r=i-1;\n            while(l+1<r)\n            {\n                int mid=l+r>>1;\n                if(rmqlen.get_mx(1,mid)+a[i].first>=L) r=mid;\n                else l=mid;\n            }\n            if(fin==0||fin>=r) ans=min(ans,r+1);\n            continue;\n        }\n        if(fin) continue;\n        if(i<n&&rmqlen.get_mx(i+1,n)+a[i].second>=L)\n        {\n            int l=i,r=n;\n            while(l+1<r)\n            {\n                int mid=l+r>>1;\n                if(rmqlen.get_mx(i+1,mid)+a[i].second>=L) r=mid;\n                else l=mid;\n            }\n            if(rmqdis.get_mn(i+1,r)-dis[i]+sum>0) ans=min(ans,r);\n        }\n        if(sum+a[i].first-a[i].second-c[i]<=0)\n        {\n            fin=i-1;\n            continue;\n        }\n        sum+=a[i].first-a[i].second-c[i];\n        len+=a[i].first-a[i].second;\n    }\n    if(ans==n+1) ans=-1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1e5+5;\nconst int imax=1e6;\nconst int inf=99999999;\nint en,n,a[maxn],c[maxn],tree[imax],sum[maxn];\n\nstruct node\n{\n\tint x,id;\n//\tnode(int x,int id):x(x),id(id){}\n}p[maxn];\n\nbool operator < (node a,node b){ return a.x==b.x?a.id<b.id:a.x<b.x; }\n\nvoid build(int l,int r,int rt)\n{\n\tif(l==r)\n\t{\n\t\ttree[rt]=sum[l]-c[l-1];\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,rt*2);\n\tbuild(mid+1,r,rt*2+1);\n\ttree[rt]=min(tree[rt*2],tree[rt*2+1]); \n}\n\n/*int qu(int L,int R,int l,int r,int rt)\n{\n\tif(r<L||l>R)\treturn inf;\n\tif(l>=L&&r<=R)\treturn tree[rt];\n\tint mid=(l+r)>>1;\n\tint a1=inf,a2=inf;\n\ta1=qu(L,R,l,mid,rt*2);\n\ta2=qu(L,R,mid,r,rt*2+1);\n\treturn min(a1,a2);\n}*/\n\nint qu(int L,int R,int l,int r,int rt)\n{\n    if(L>R) return inf;\n    if(L<=l&&r<=R) return tree[rt];\n    int mid=(l+r)/2;\n    int a1=inf,a2=inf;\n    if(L<=mid) a1=qu(L,R,l,mid,rt*2);\n    if(R>mid) a2=qu(L,R,mid+1,r,rt*2+1);\n    return min(a1,a2);\n}\n\nbool check(int i,int mid)\n{\n\tif(i>mid)\treturn sum[mid]+a[p[i].id]>=en;\n\treturn sum[mid]+a[p[i].id]-p[i].x>=en;\n}\n\nint main()\n{\n\tint ans=inf;\n\tc[0]=0;\n\tsum[0]=0;\n\tscanf(\"%d%d\",&n,&en);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint tmp;\n\t\tscanf(\"%d%d\",a+i,&tmp);\n\t\tp[i].x=a[i]-tmp;\n\t\tp[i].id=i;\n\t\tsum[i]=sum[i-1]+p[i].x;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d\",c+i);\n\t\tc[i]+=c[i-1];\n\t}\n\tsort(p+1,p+1+n);\n\tbuild(1,n,1);\n\tint gg=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(p[i].x<0)\n\t\t{\n\t\t\tgg=i;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\tgg++;\n//\tprintf(\"gg==%d\\n\",gg);\n\tint num=1;\n\twhile(sum[num]>c[num])\n\t{\n\t\tif(num>n)\tbreak;\n\t\tnum++;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint l=0,r=n+1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(check(i,mid))\tr=mid;\n\t\t\tl=mid+1;\n\t\t}\n\t//\tprintf(\"he\\n\");\n\t\tif(r>n)\tcontinue;\n\t\tif(r<=i)\n\t\t{\n\t\t\tif(r<num)\tans=min(ans,r+1);\n\t\t}\n\t\telse\n\t\tif(qu(i+1,r,1,n,1)>p[i].x)\tans=min(ans,r);\n\t//\tprintf(\"douwo\\n\");\n\t}\n\tif(ans==inf)\tprintf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {}; ll dif2[100000] = {};\nint main() {\n\tint n; ll l; cin >> n >> l;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tif (n >= 2) {\n\t\tdif2[0] = sum[1] - csum[0];\n\t}\n\tRep(i,1, n - 1) {\n\t\tdif2[i] = min(dif2[i - 1], sum[i+1]-csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tif (dif2[loc-1]-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first >= 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nint n, L;\nint l, r, mid;\nstruct Bottle {\n    int up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nbool check(int x) {\n    x--;\n    rep(k, 1, n + 1) {\n        if(c[k] <= x)\n            continue;\n        ll p = L - a[k].up, go = 0;\n        if(k <= x && sum[x + 1] - a[k].val >= p)\n            return 1;\n        if(k > x && sum[x] >= p)\n            return 1;\n    }\n    return 0;\n}\ninline char gc() {\n    static char buf[1<<20], *head = buf, *tail = buf;\n    return (head == tail && (tail = (head = buf) + fread(buf, 1, 1 << 20, stdin), head == tail)? -1: *head++);\n}\ntemplate <typename T> inline bool read(T &x) {\n    static bool f;\n    static char c;\n    for (c = gc(), f = false; !isdigit(c); c =gc()) {\n        if (c == EOF)\n            return false;\n        else if (c == 45)\n            f = true;\n    }\n    for (x = 0; isdigit(c); c = gc())\n        x = x * 10 + c - 48;\n    if (f)\n        x = -x;\n    return true;\n}\nint main() {\n    read(n);read(L);\n    rep(i, 1, n + 1)read(a[i].up),read(a[i].down),a[i].val = a[i].up - a[i].down;\n    rep(i, 1, n + 1)read(b[i]);\n    sort(a + 1, a + n + 1);\n    rep(i, 1, n + 1)sum[i] = sum[i - 1] + a[i].val;\n    ll cnt = 1, dis = 0;\n    rep(i, 2, n + 1) {\n        dis += (a[i].val - b[cnt]);\n        if(dis <= 0)\n            break;\n        cnt++;\n    }\n    c[1] = cnt;\n    int k = 2;\n    for(; k <= n; k++) {\n        if(cnt < k - 1 || cnt == n)\n            break;\n        dis += (a[k - 1].val - a[k].val);\n        while(dis > 0 && cnt < n)\n            cnt++, dis += (a[cnt + 1].val - b[cnt]);\n        c[k] = cnt;\n    }\n    for(; k <= n; k++)\n        c[k] = cnt;\n    int day = 1;\n    for(int i = 1; a[i].val > 0 && i <= n; i++, day++);\n    l = 1, r = day;\n    while(l < r) {\n        mid = (l + r) / 2;\n        if(check(mid))\n            r = mid;\n        else\n            l = mid + 1;\n    }\n    if(check(l))\n        cout << l << endl;\n    else\n        cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define rez(v, n) (v).clear(), (v).resize(n)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\ntemplate<class T> struct Min {\n  T nil;\n  Min(){}\n  Min(T nil):nil(nil){}\n  T operator()(T a, T b) {\n    return a < b ? a : b;\n  }\n};\ntemplate<class T> struct Max {\n  T nil;\n  Max(){}\n  Max(T nil):nil(nil){}\n  T operator()(T a, T b) {\n    return a > b ? a : b;\n  }\n};\n\ntemplate<class T, class F>\nstruct SegmentTree {\n  vector<T> data;\n  F func;\n  int sz;\n  SegmentTree(int n, F f) {\n    func = f;\n    sz = 1; while(sz < n) sz <<= 1;\n    data.resize(2*sz+1, func.nil);\n  }\n  void update(int k, T x) {\n    k += sz-1;\n    data[k] = x;\n    while(k > 0) {\n      k = (k-1)/2;\n      data[k] = func(data[2*k+1], data[2*k+2]);\n    }\n  }\n  T query(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return func.nil;\n    if(a <= l && r <= b) return data[k];\n    return func(query(a, b, 2*k+1, l, (l+r)/2),\n\t       query(a, b, 2*k+2, (l+r)/2, r));\n  }\n  T query(int a, int b) {\n    return query(a, b, 0, 0, sz);\n  }\n};\n\nint N, L;\nvint A, B, C, D;\nvint sumC, sumD;\nvint idx;\n\nbool cmp(int i, int j) {\n  return D[i] > D[j];\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> L;\n  rez(A, N), rez(B, N), rez(C, N), rez(D, N);\n  rep(i, N) {\n    cin >> A[i] >> B[i];\n    D[i] = A[i]-B[i];\n  }\n  rep(i, N) {\n    cin >> C[i];\n  }\n\n  rez(idx, N);\n  rep(i, N) idx[i] = i;\n  sort(all(idx), cmp);\n  rez(sumC, N+1), rez(sumD, N+1);\n  rep(i, N) {\n    sumD[i+1] = sumD[i] + D[idx[i]];\n    sumC[i+1] = sumC[i] + C[i];\n  }\n\n  SegmentTree< int, Max<int> > segA(N, Max<int>(-inf)), segB(N, Max<int>(-inf));\n  rep(i, N) {\n    int k = idx[i];\n    segA.update(i, A[k]);\n    segB.update(i, B[k]);\n  }\n\n  SegmentTree< int, Min<int> > segX(N, Min<int>(inf));\n  rep(i, N) {\n    segX.update(i, sumD[i+1]-sumC[i+1]);\n  }\n\n  int ans = inf;\n  rep(i, N) {\n    int a = segA.query(i, N);\n    if(sumD[i]+a >= L) {\n      //cout<<sumD[i]+a<<\" \"<<L<<endl;\n      chmin(ans, i);\n      break;\n    }\n\n    //cout<<\"BIN_SEARCH\"<<endl;\n    int lb = -1, ub = i;\n    while(lb+1 < ub) {\n      int mb = (lb+ub)/2;\n      //cout<<idx[mb]<<\" \"<<idx[i]<<endl;\n      //cout<<segX.query(mb, i) << \" \"<< D[idx[mb]]-D[idx[i]]<<endl;\n      if(segX.query(mb, i) > D[idx[mb]]-D[idx[i]]) ub = mb;\n      else lb = mb;\n    }\n    int b = segB.query(ub, i);\n    if(b == -inf) continue;\n    //cout<<\"OK\"<<endl;\n    //cout << ub << \" \" << b << endl;\n    //cout<<sumD[i+1]<<\" \" << b << endl;\n    if(sumD[i+1]+b >= L) {\n      chmin(ans, i);\n      break;\n    }\n    if(sumD[i+1] <= sumC[i+1]) break;\n  }\n\n  cout << (ans == inf ? -1 : ans+1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nll n, L ,need;\nll l, r, mid;\nstruct Bottle {\n    ll up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nint main()\n{\n     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n     cin>>n>>L;\n     rep(i,1,n+1)cin>>a[i].up>>a[i].down,a[i].val = a[i].up - a[i].down;\n     rep(i,1,n+1)cin>>b[i],c[i]=c[i-1]+b[i];         //c[i]保存b的前缀和\n     sort(a+1,a+n+1);\n     rep(i,1,n+1)sum[i]=sum[i-1]+a[i].val;               //sum[i]保存a的前缀和\n    ll day = 1;for(int i=1;a[i].val>0&&i<=n;i++,day++);    //找到可能的答案范围\n     ll ans=999999999;        //保存答案\n     rep(k,1,n+1)\n     {\n         l=1,r=day;\n         need=L-a[k].up;\n         while(l<r)\n         {\n             ll mid=(l+r)>>1;\n             if(mid==1)l=mid+1;\n             else if((mid-1)>=k&&sum[mid]-a[k].val<=c[mid-1])r=mid;\n             else if((mid-1)<k&&sum[mid-1]<=c[mid-1])r=mid;\n              else l=mid+1;\n         }      //求出k作为最后一瓶饮料使用时最少需要多少天被追上，复杂度为logr\n         l=1;\n         while(((r-1)>=k&&sum[r]-a[k].val<=c[r-1])||((r-1)<k&&sum[r-1]<=c[r-1]))\n         r--;     //判断第r天前是否被追上\n         int date=r;\n        while(l<r)\n        {\n            ll mid=(l+r)>>1;\n            if((mid-1)>=k&&sum[mid]-a[k].val>=need)r=mid;\n             else if(mid<k&&sum[mid-1]>=need)r=mid;\n              else l=mid+1;\n        }     //求出最少所用天数复杂度为logr\n        for(;l<=date;l++)\n        if(((l-1)>=k&&sum[l]-a[k].val>=need)||((l-1)<k&&sum[l-1]>=need)){ans=min(l,ans);break;}\n     }\n     if(ans==999999999)cout<<-1<<endl;\n     else cout<<ans<<endl;\n     return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {};\nint m; ll dat[399999];\nvoid init(int m_) {\n\tm = 1;\n\twhile (m < m_)m *= 2;\n\trep(i, 2 * m - 1)dat[i] = INF;\n}\nvoid updat(int k,ll a) {\n\tk += m - 1; dat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n;\n\tll l; cin >> n >> l; m = n - 1;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tint chk = n;\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tif (x[i].first <= 0)chk = i;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tinit(m);\n    rep(i, n - 1) {\n\t\tupdat(i,sum[i + 1] - csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + chk, l - ny) - sum;\n\t\tif (loc == chk)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + chk, l - ny + nx) - sum;\n\t\t\tif (loc == chk)continue;\n\t\t\tll mi = query(i, loc, 0, 0, m);\n\t\t\tif (mi-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N,L;\nvector<P> a;\nll D[100010],C[100010];\nll l[100010];\nll mx;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N>>L;\n  rep(i,N){\n    ll A,B;\n    cin>>A>>B;\n    a.push_back(P(A,B));\n  }\n  sort(all(a),[](const P& b,const P& c){ return b.fi-b.se > c.fi-c.se; });\n  rep(i,N)D[i+1]=max(0LL,a[i].fi-a[i].se);\n  rep(i,N)cin>>C[i+1];\n  rep(i,N){\n    C[i+1]+=C[i];\n    D[i+1]+=D[i];\n  }\n\n  repl(i,1,N){\n    ll lb=-1,ub=i+1;\n    while(ub-lb>1){\n      ll X=(lb+ub)/2;\n      ll sum=D[i+1]-(D[X+1]-D[X]);\n      if(sum>C[i])ub=X;\n      else lb=X;\n    }\n    l[i]=ub;\n    if(ub==i+1){\n      l[i]=INF;\n    }\n  }\n  l[0]=0;\n  rep(i,N)maxch(l[i+1],l[i]);\n\n  ll res=INF;\n  rep(i,N){\n    ll rest=L-a[i].fi;\n    if(rest<=0){\n      cout<<1<<endl;\n      return 0;\n    }\n    if(D[i]>=rest){\n      ll lb=-1,ub=i;\n      while(ub-lb>1){\n        ll X=(lb+ub)/2;\n        if(D[X]>=rest)ub=X;\n        else lb=X;\n      }\n      if(i<l[ub])continue;\n      minch(res,ub+1);\n    }else{\n      ll lb=i+1,ub=N;\n      while(ub-lb>1){\n        ll X=(lb+ub)/2;\n        if(D[i]+(D[X]-D[i+1])>=rest)ub=X;\n        else lb=X;\n      }\n      if(i<l[ub]||(D[i]+(D[ub]-D[i+1]))<rest)continue;\n      minch(res,ub);\n    }\n  }\n\n  if(res==INF)cout<<-1<<endl;\n  else cout<<res<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct drink{\n  LL a;\n  LL b;\n  bool operator<(const struct drink& right) const{\n    return (a-b==right.a-right.b?a<right.a:a-b<right.a-right.b);\n  }\n};\n\nint main(){\n  LL n,l;\n  cin >> n >> l;\n  vector<struct drink> d(n);\n  LL total=0;\n  for(int i=0;i<n;i++){\n    cin >> d[i].a >> d[i].b;\n  }\n  sort(d.begin(),d.end());\n  vector<LL> mx(n);\n  mx[0]=-1000000000;\n  for(int i=1;i<n;i++){\n    mx[i]=max(mx[i-1],d[i-1].a);\n  }\n  vector<LL> c(n);\n  for(int i=0;i<n;i++){\n    cin >> c[i];\n  }\n  LL ruiD=0,ruiC=0;\n  for(int i=0;i<n-1;i++){\n    ruiD+=d[n-1-i].a-d[n-1-i].b;\n    ruiC+=c[i];\n    if(ruiD+mx[n-1-i]>=l){\n      cout << i+2 << endl;\n      return 0;\n    }\n    if(ruiD<=ruiC){\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n) {\n\t\tif (a[i].first > 0)max = i + 1;\n\t\telse break;\n\t}\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second <= l) {\n\t\t\tint p = lower_bound(b.begin() + i, b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p + 1) > 0 && p != max)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst ll A = 3e5 + 10;\nll a[A];\nclass P{\npublic:\n    ll id,val;\n    P(ll _id = 0,ll _val = 0){\n        id = _id;\n        val = _val;\n    }\n    bool operator<(const P& rhs)const{\n        if(val == rhs.val) return a[id] > a[rhs.id];\n        return val < rhs.val;\n    }\n};\npriority_queue<P> que_A,que_Dis;\nbool vis[A];\nll n,C[A];\nll L;\n\nll calc(){\n    ll now = 0,Di = 0;\n    memset(vis,0,sizeof(vis));\n    for(ll i=1 ;i<=n ;i++){\n        while(vis[que_A.top().id]) que_A.pop();\n        if(now + que_A.top().val >= L) return i;\n\n        now += que_Dis.top().val;\n        vis[que_Dis.top().id] = 1;\n        que_Dis.pop();\n        Di += C[i];\n        if(Di > now) return -1;\n    }\n    return -1;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&n,&L);\n    for(ll i=1 ;i<=n ;i++){\n        ll x,y;\n        scanf(\"%lld%lld\",&x,&y);\n        a[i] = x;\n        que_A.push(P(i,x));\n        que_Dis.push(P(i,x-y));\n    }\n    for(ll i=1 ;i<=n ;i++) scanf(\"%lld\",&C[i]);\n    printf(\"%lld\\n\",calc());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tvi d(n);\n\trep(i, n)d[i] = st2[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first > 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max) {\n\t\t\tint p = lower_bound(d.begin() + i, b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && p != max)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return Total > d.Total;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total;\n    return os;\n}\n\nint main()\n{\n    int N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (int i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (int i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (int i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    vector<ll> C(N);\n    for (int i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (int i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (int i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (int i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (int i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (int i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (int i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    // show(sum1);\n    // show(sum2);\n    // show(accum);\n    // show(data);\n    constexpr int INF = 1 << 30;\n    int minimum = INF;\n\n    for (int i = 0; i < N; i++) {\n        // show(i);\n        ll goal = L - data[i].A;\n        const int lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            // show(\"hogeohoegoeodwqd\");\n            // show(goal);\n            // show(lower);\n            const ll mini = seg1.query(1, lower);\n            if (mini <= 0) {\n                continue;\n            } else {\n                // if (lower + 1 == 3308) {\n                //     show(\"buebuebue\");\n                // }\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            //            show(\"feffwuefwiuefwuef\");\n            if (lower >= N) {\n                continue;\n            }\n            goal = L - data[i].B;\n            //            show(goal);\n            const int lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N) {\n                continue;\n            }\n            //            show(lower);\n            if (i == 0) {\n                // show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                // show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    // if (lower == 3308) {\n                    //     show(\"pachicpawdw\");\n                    // }\n                    minimum = min(minimum, lower);\n                }\n            } else {\n                // show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i);\n                // show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    // if (lower + 1 == 3308) {\n                    //     show(\"adewjdiejdwjd\");\n                    // }\n                    minimum = min(minimum, lower + 1);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    // if (lower + 1 == 3308) {\n                    //     show(\"fuewfuehfuwhfiwfhwfu\");\n                    // }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvll c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvll b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<ll> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n) {\n\t\tif (a[i].first > 0)max = i + 1;\n\t\telse break;\n\t}\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second <= l) {\n\t\t\tint p = lower_bound(b.begin() + i, b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p + 1) > 0 && p != max)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {}; ll dif2[100000] = {};\nint main() {\n\tint n; ll l; cin >> n >> l;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tif (n >= 2) {\n\t\tdif2[0] = csum[0] + sum[1];\n\t}\n\tRep(i,1, n - 1) {\n\t\tdif2[i] = min(dif2[i - 1], csum[i] + sum[i + 1]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tif (dif2[loc]-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <bitset>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nint n, L;\nint l, r, mid;\nstruct Bottle {\n    int up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nbool check(int x) {\n    x--;\n    rep(k, 1, n + 1) {\n        if(c[k] <= x)\n            continue;\n        ll p = L - a[k].up, go = 0;\n        if(k <= x && sum[x + 1] - a[k].val >= p)\n            return 1;\n        if(k > x && sum[x] >= p)\n            return 1;\n    }\n    return 0;\n}\ninline char gc() {\n    static char buf[1<<20], *head = buf, *tail = buf;\n    return (head == tail && (tail = (head = buf) + fread(buf, 1, 1 << 20, stdin), head == tail)? -1: *head++);\n}\ntemplate <typename T> inline bool read(T &x) {\n    static bool f;\n    static char c;\n    for (c = gc(), f = false; !isdigit(c); c =gc()) {\n        if (c == EOF)\n            return false;\n        else if (c == 45)\n            f = true;\n    }\n    for (x = 0; isdigit(c); c = gc())\n        x = x * 10 + c - 48;\n    if (f)\n        x = -x;\n    return true;\n}\nint main() {\n    read(n);read(L);\n    rep(i, 1, n + 1)read(a[i].up),read(a[i].down),a[i].val = a[i].up - a[i].down;\n    rep(i, 1, n + 1)read(b[i]);\n    sort(a + 1, a + n + 1);\n    rep(i, 1, n + 1)sum[i] = sum[i - 1] + a[i].val;\n    ll cnt = 1, dis = 0;\n    rep(i, 2, n + 1) {\n        dis += (a[i].val - b[cnt]);\n        if(dis <= 0)\n            break;\n        cnt++;\n    }\n    c[1] = cnt;\n    int k = 2;\n    for(; k <= n; k++) {\n        if(cnt < k - 1 || cnt == n)\n            break;\n        dis += (a[k - 1].val - a[k].val);\n        while(dis > 0 && cnt < n)\n            cnt++, dis += (a[cnt + 1].val - b[cnt]);\n        c[k] = cnt;\n    }\n    for(; k <= n; k++)\n        c[k] = cnt;\n    int day = 1;\n    for(int i = 1; a[i].val > 0 && i <= n; i++, day++);\n    l = 1, r = day;\n    while(l < r) {\n        mid = (l + r) / 2;\n        if(check(mid))\n            r = mid;\n        else\n            l = mid + 1;\n    }\n    if(check(l))\n        cout << l << endl;\n    else\n        cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>pii;\nconst int N = 1e5+5;\nstruct Man{\n   int a,b;\n   bool operator<(const Man &rhs)const{\n      return a-b>rhs.a-rhs.b;\n   }\n}s[N];\nint n,c[N],l,ma[N],b[N];\npriority_queue<pii>q;\nset<pii>se;\nint solve(){\n  ll up=0,down=0;\n  for(int i=1;i<=n;++i){\n     if(up+ma[i]>=l)return i;\n     up+=s[i].a-s[i].b;\n     ll tmp = up-down;\n     while(!q.empty()&&q.top().first>=tmp){\n         int x = q.top().second;\n         q.pop();\n         se.erase(make_pair(s[x].b,x));\n     }\n     if(!se.empty()&&up+(*--se.end()).first>=l)return i;\n     down+=c[i];\n     if(up<=down)break;\n     se.insert(make_pair(s[i].b,i));\n     q.push(make_pair(s[i].a-s[i].b,i));\n  }\n  return -1;\n}\nint main() {\n   scanf(\"%d%d\",&n,&l);\n   for(int i=1;i<=n;++i){\n      scanf(\"%d%d\",&s[i].a,&s[i].b);\n   }\n   for(int i=1;i<=n;++i)scanf(\"%d\",&c[i]);\n   sort(s+1,s+1+n);\n   for(int i=n;i>=1;--i)ma[i]=max(ma[i+1],s[i].a);\n   printf(\"%d\\n\",solve());\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nint n,L;\nint l,r,mid;\nstruct Bottle\n{\n    int up,down,val;\n    bool operator < (const Bottle a)const\n    {\n        return val>a.val;\n    }\n}a[100005];\nll b[100005],c[100005],sum[100005];\nbool check(int x)\n{\n    x--;\n    rep(k,1,n+1)\n     {\n         if(c[k]<=x)continue;\n        ll p=L-a[k].up,go=0;\n        if(k<=x&&sum[x+1]-a[k].val>=p)return 1;\n        if(k>x&&sum[x]>=p)return 1;\n    }\n    return 0;\n}\nint main()\n{\n     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n     int mx=0;\n     cin>>n>>L;\n     rep(i,1,n+1)cin>>a[i].up>>a[i].down,a[i].val=a[i].up-a[i].down,mx=max(a[i].val,mx);\n     if(mx>=L){cout<<1<<endl;return 0;}\n     rep(i,1,n+1)cin>>b[i];\n     sort(a+1,a+n+1);\n     rep(i,1,n+1)sum[i]=sum[i-1]+a[i].val;\n     ll cnt=1,dis=0;\n     rep(i,2,n+1)\n     {\n         dis+=(a[i].val-b[cnt]);\n         if(dis<=0)break;cnt++;\n     }\n     c[1]=cnt;\n     int k=2;\n     for(;k<=n;k++)\n     {\n         if(cnt<k-1||cnt==n)break;\n         dis+=(a[k-1].val-a[k].val);\n         while(dis>0&&cnt<n)cnt++,dis+=(a[cnt+1].val-b[cnt]);c[k]=cnt;\n     }\n     for(;k<=n;k++)c[k]=cnt;\n     int day=n;rep(i, 1, n+1)if(a[i].val<=0){day=i;break;}//for(int i=1;a[i].val>0&&i<=n;i++,day++);\n     l=1,r=day;\n     if(l>r){cout<<-1<<endl;return 0;}\n     while(l<r)\n     {\n         mid=(l+r)/2;\n         if(check(mid))r=mid;\n         else l=mid+1;\n     }\n     if(check(l))cout<<l<<endl;\n     else cout<<-1<<endl;\n     return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1e6+5;\nconst int imax=1e6;\nconst int inf=999999999;\nint en,n,a[maxn],b[maxn];\ntypedef long long ll;\nll tree[maxn],sum[maxn],c[maxn];\n\n/*struct node\n{\n\tint x,id;\n//\tnode(int x,int id):x(x),id(id){}\n}p[maxn];*/\n\nstruct node\n{\n    int x,id;\n    node(){}\n    bool operator < (const node &a) const\n    {\n        if(a.x==x) return id<a.id;\n        return x>a.x;\n    }\n}p[maxn];\n\nbool cmp(node a,node b)\n{\n\treturn a.x==b.x?a.id<b.id:a.x>b.x;\n}\n\n\nvoid build(int l,int r,int rt)\n{\n\tif(l==r)\n\t{\n\t\ttree[rt]=sum[l]-c[l-1];\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,rt*2);\n\tbuild(mid+1,r,rt*2+1);\n\ttree[rt]=min(tree[rt*2],tree[rt*2+1]); \n}\n\nll qu(int L,int R,int l,int r,int rt)\n{\n\tif(L>R)\treturn inf;\n\tif(r<L||l>R)\treturn inf;\n\tif(l>=L&&r<=R)\treturn tree[rt];\n\tint mid=(l+r)>>1;\n\tint a1=inf,a2=inf;\n\ta1=qu(L,R,l,mid,rt*2);\n\ta2=qu(L,R,mid+1,r,rt*2+1);\n\treturn min(a1,a2);\n}\n\nbool check(int i,int mid)\n{\n    if(i>mid) return sum[mid]+a[p[i].id]>=en;\n    return sum[mid]-p[i].x+a[p[i].id]>=en;\n}\n\n\nint main()\n{\n\tint ans=inf;\n\tc[0]=0;\n\tsum[0]=0;\n\tscanf(\"%d%d\",&n,&en);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tp[i].x=a[i]-b[i];\n\t\tp[i].id=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",c+i);\n\t\tc[i]+=c[i-1];\n\t}\n\tsort(p+1,p+1+n,cmp);\n\tfor(int i=1;i<=n;++i)\tsum[i]=sum[i-1]+p[i].x;\n\tbuild(1,n,1);\n\tint gg=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(p[i].x<0)\n\t\t{\n\t\t\tgg=i;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\tgg++;\n\tint num=1;\n\twhile(sum[num]>c[num])\n\t{\n\t\tif(num>n)\tbreak;\n\t\tnum++;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint l=0,r=n+1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(check(i,mid))\tr=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(r>n)\tcontinue;\n\t\tif(r<i)\n\t\t{\n\t\t\tif(r<num)\tans=min(ans,r+1);\n\t\t}\n\t\telse\n\t\tif(qu(i+1,r,1,n,1)>p[i].x)\tans=min(ans,r);\n\t}\n\tif(ans==inf)\tprintf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(i = 0; i<n; i++)\n#define repl(i,n) for(i = 1; i<=n; i++)\n\n#define sz(x)   (int)x.size()\n#define pb      push_back\n#define all(x)  x.begin(), x.end()\n#define uu      first\n#define vv  second\n#define mem(x,y) memset(x,y,sizeof(x))\n#define sdi(x) scanf(\"%d\",&x)\n#define sdii(x,y) scanf(\"%d %d\",&x,&y)\n#define sdiii(x,y,z)  scanf(\"%d %d %d\",&x,&y,&z)\n#define sdl(x) scanf(\"%lld\",&x)\n#define sdll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define sdlll(x,y,z)  scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define sds(x) scanf(\"%s\",s);\n#define pfi(x) printf(\"%d\\n\",x)\n#define pfii(x,y) printf(\"%d %d\\n\",x,y)\n#define pfiii(x,y,z) printf(\"%d %d %d\\n\",x,y,z)\n#define pfl(x) printf(\"%lld\\n\",x)\n#define pfll(x,y) printf(\"%lld %lld\\n\",x,y)\n#define pflll(x,y,z) printf(\"%lld %lld %lld\\n\",x,y,z)\n\n#define eps 1e-9\n//#define OK  cerr<< \"OK\" << '\\n'\n//#define DB(x) cerr << #x \" = \" << x << '\\n'\n\n#define FRE(i,a,b) for(i = a; i<=b; i++)\n#define FRL(i,a,b) for(i = a; i<b; i++)\n#define un(x) x.erase(unique(all(x)),x.end())\n#define sf(x) scanf(\"%d\",&x)\n#define sff(x,y) scanf(\"%d %d\",&x,&y)\n#define sfff(x,y,z)  scanf(\"%d %d %d\",&x,&y,&z)\n#define sl(x) scanf(\"%lld\",&x)\n#define sll(x,y) scanf(\"%lld %lld\",&x,&y)\n#define slll(x,y,z)  scanf(\"%lld %lld %lld\",&x,&y,&z)\n#define D(x)        cerr << #x \" = \" << x << '\\n'\n#define DBG         cerr << \"Hi\" << '\\n'\n#define PI          acose(-1.00)\n#define xx          first\n#define yy          second\n\ntypedef double db;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\ninline int setBit(int N, int pos) { return N=N|(1<<pos);}\ninline int resetBit(int N, int pos) {return N=N &~(1<<pos);}\ninline bool checkBit(int N, int pos) {return (bool) (N & (1<<pos));}\n\n\n//int fx[] = {+0, +0, +1, -1, +1, -1, +1};\n//int fy[] = {-1, +1, +0, +0, +1, -1, -1};\n\n\nconst int MAX = 100005;\nint n, ub;\nLL c[MAX], cumDelta[MAX], cumC[MAX], tree[MAX*4], l;\nstruct data {\n    int a, b;\n    inline bool operator < (const data &p) const {\n        return ((a-b) > (p.a-p.b));\n    }\n} arr[MAX];\n\nvoid init(int node, int beg, int endd) {\n    if(beg == endd) {\n        tree[node] = cumDelta[beg] - cumC[beg];\n        return;\n    }\n\n    int left = node << 1;\n    int right = left + 1;\n    int mid = (beg+endd) >> 1;\n\n    init(left, beg, mid);\n    init(right, mid+1, endd);\n\n    tree[node] = min(tree[left], tree[right]);\n}\n\nvoid update(int node, int beg, int endd, int x, LL val) {\n    if(beg == endd) {\n        tree[node] += val;\n        return;\n    }\n\n    int left = node << 1;\n    int right = left + 1;\n    int mid = (beg+endd) >> 1;\n\n    if(x <= mid) update(left, beg, mid, x, val);\n    else update(right, mid+1, endd, x, val);\n\n    tree[node] = min(tree[left], tree[right]);\n}\n\nLL query(int node, int beg, int endd, int x, int y) {\n    if(x > y) return LLONG_MAX;\n    if(beg == x && endd == y) return tree[node];\n\n    int left = node << 1;\n    int right = left + 1;\n    int mid = (beg+endd) >> 1;\n\n    LL l = query(left, beg, mid, x, min(y, mid));\n    LL r = query(right, mid+1, endd, max(x, mid+1), y);\n\n    return min(l, r);\n}\n\ninline int bs(int idx) {\n    int low=1, high=ub, mid, ret=n+5;\n    while(low <= high) {\n        mid = (low+high) >> 1;\n        LL x = cumDelta[mid];\n        if(mid >= idx) x -= (arr[idx].a - arr[idx].b);\n        if(x >= l - arr[idx].a) {\n            ret = min(ret, mid);\n            high = mid-1;\n        }\n        else low = mid+1;\n    }\n    return ret;\n}\n\ninline int check(int idx) {\n    update(1, 1, n, idx, -cumDelta[idx]);\n    if(idx < n) update(1, 1, n, idx, cumDelta[idx+1]);\n    int here = bs(idx);\n    if(here > n) return here;\n    if(query(1, 1, n, 1, here) > 0) {\n        if(idx > here) here++;\n        return here;\n    }\n    else return n+5;\n}\n\nint solve() {\n    int ret = n+5, i;\n    for(i=n; i>=1; i--) {\n        int x = check(i);\n        ret = min(ret, x);\n    }\n    if(ret > n) return -1;\n    else return ret;\n}\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    int i;\n\n    sdi(n);\n    sdl(l);\n    repl(i, n) sdll(arr[i].a, arr[i].b);\n    repl(i, n) sdl(c[i]);\n\n    sort(arr+1, arr+1+n);\n    ub = n;\n    repl(i, n) {\n        if(arr[i].a >= arr[i].b) ub = i;\n    }\n    repl(i, n) {\n        cumDelta[i] = cumDelta[i-1];\n        cumDelta[i] += (arr[i].a - arr[i].b);\n    }\n    repl(i, n) {\n        cumC[i] = cumC[i-1];\n        cumC[i] += c[i];\n    }\n\n//    repl(i, n) pfll(arr[i].a, arr[i].b); puts(\"----------\");\n//    repl(i, n) pfl(c[i]);\n\n    init(1, 1, n);\n    pfi(solve());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {};\nint m; ll dat[199999];\nvoid init(int m_) {\n\tm = 1;\n\twhile (m < m_)m *= 2;\n\trep(i, 2 * m - 1)dat[i] = INF;\n}\nvoid update(int k,ll a) {\n\tk += m - 1; dat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n;\n\tll l; cin >> n >> l; m = n - 1;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tinit(m);\n    rep(i, n - 1) {\n\t\tupdate(i,sum[i + 1] - csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tll mi = query(i, loc, 0, 0, m);\n\t\t\tif (mi-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n//#define show(x) cerr << #x << \" = \" << x << endl\n#define show(x)\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return (Total != d.Total) ? Total > d.Total : A < d.A;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total << endl;\n    return os;\n}\n\nint main()\n{\n    ll N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (ll i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (ll i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    //    cerr << accum << endl;\n\n    vector<ll> C(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (ll i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (ll i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (ll i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    //    cerr << data << endl;\n    // show(sum1);\n    // show(sum2);\n    //    show(accum);\n    // show(data);\n    constexpr ll INF = 1LL << 60;\n    ll minimum = INF;\n\n\n    for (ll i = 0; i < N; i++) {\n        show(i);\n        ll goal = L - data[i].A;\n        const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            show(\"hogeohoegoeodwqd\");\n            show(goal);\n            show(lower);\n            const ll mini = seg1.query(1, lower);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            show(\"feffwuefwiuefwuef\");\n            // if (lower >= N) {\n            //     continue;\n            // }\n            goal = L - data[i].B;\n            const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N + 1) {\n                //          cerr << accum[N] - goal << endl;\n                continue;\n            }\n            show(lower);\n            if (i == 0) {\n                show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower);\n                }\n            } else {\n                show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i);\n                show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> pii;\nvoid chkmin(int &a, int b) { a = a < b ? a : b; }\nvoid chkmin(LL &a, LL b) { a = a < b ? a : b; }\nconst int maxn = 100100;\nint n;\nLL c[maxn], s[maxn], mn1[maxn], mn2[maxn];\npii p[maxn];\nbool cmp(pii &a, pii &b) { return a.first - a.second > b.first - b.second; }\nint main()\n{\n\tconst LL oo = 0x3f3f3f3f3f3f3f3fLL;\n\tLL L;\n\tscanf(\"%d%lld\", &n, &L);\n\tfor (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &p[i].first, &p[i].second);\n\tsort(p, p + n, cmp);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lld\", c + i);\n\t\tif (i) c[i] += c[i - 1];\n\t\ts[i] = p[i].first - p[i].second;\n\t\tif (i) s[i] += s[i - 1];\n\t\tmn1[i] = s[i] - c[i];\n\t\tif (i) chkmin(mn1[i], mn1[i - 1]);\n\t\tif (i == 0) mn2[i] = oo;\n\t\telse mn2[i] = s[i] - c[i - 1];\n\t\tif (i) chkmin(mn2[i], mn2[i - 1]);\n\t}\n\tLL ans = oo;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint id1 = upper_bound(mn1, mn1 + i, 1, greater<int>()) - mn1 - 1;\n\t\tif (id1 == -1) {\n\t\t\tif (p[i].first >= L) chkmin(ans, 1);\n\t\t}\n\t\telse {\n\t\t\tif (s[id1] + p[i].first >= L) chkmin(ans, id1 + 1);\n\t\t}\n\t\tint id2 = upper_bound(mn2 + i + 1, mn2 + n, p[i].first - p[i].second, greater<int>()) - mn2 - 1;\n\t\tif (id2 == i) {\n\t\t\tif (p[i].first >= L) chkmin(ans, 1);\n\t\t}\n\t\telse {\n\t\t\tif (s[id2] + p[i].second >= L) chkmin(ans, id2);\n\t\t}\n\t}\n\tif (ans == oo) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {};\nint m; ll dat[399999];\nvoid init(int m_) {\n\tm = 1;\n\twhile (m < m_)m *= 2;\n\trep(i, 2 * m - 1)dat[i] = INF;\n}\nvoid updat(int k,ll a) {\n\tk += m - 1; dat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n;\n\tll l; cin >> n >> l; m = n - 1;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tinit(m);\n    rep(i, n - 1) {\n\t\tupdat(i,sum[i + 1] - csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tll mi = query(i, loc, 0, 0, m);\n\t\t\tif (mi-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\nusing ll = long long;\nusing pii = pair<ll, int>;\n\nll a[N], b[N], c[N];\npriority_queue<pii> pq;\n\nint vis[N];\nint lst[N], id = 1;\n\nstruct cmp {\n\tbool operator()(int x, int y) {\n\t\treturn a[x] == a[y] ? b[x] > b[y] : a[x] > a[y];\n\t}\n};\n\nint main() {\n\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tios_base::sync_with_stdio(0);\n\tint n, L; cin >> n >> L;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tpq.push(make_pair(a[i] - b[i], i));\n\t\tlst[i] = i;\n\t}\n\tsort (lst + 1, lst + n + 1, cmp());\n\t\n\tfor (int i = 1; i <= n; i++) cin >> c[i], c[i] = c[i-1] + c[i];\n\tint ans = 0, now = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpii pt, nt;\n\t\tif (now + a[lst[id]] >= L) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t\tpt = pq.top(), pq.pop();\n\t\tif (pt.first + now <= c[i]) break;\n\t\tif (pt.second != lst[id]) {\n\t\t\tnow += pt.first;\n\t\t\tvis[pt.second] = 1;\n\t\t} else {\n\t\t\tif (pq.size() > 1) {\n\t\t\t\tnt = pq.top(), pq.pop();\n\t\t\t\tif (now + nt.first <= c[i]) {\n\t\t\t\t\tpq.push(nt);\n\t\t\t\t\tnow += pt.first;\n\t\t\t\t\tvis[pt.second] = 1;\n\t\t\t\t\tfor (; id <= n; id++) {\n\t\t\t\t\t\tif (vis[lst[id]] == 1) continue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpq.push(pt);\n\t\t\t\t\tnow += nt.first;\n\t\t\t\t\tvis[nt.second] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnow += pt.first;\n\t\t\t\tvis[pt.second] = 1;\n\t\t\t\tfor (; id <= n; id++) {\n\t\t\t\t\tif (vis[lst[id]] == 1) continue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ans) cout << ans << endl;\n\telse puts(\"-1\");\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first >= 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM -2000000000\n#define SIZE 100000\n\nstruct Info{\n\tInfo(ll arg_A,ll arg_B){\n\t\tA = arg_A;\n\t\tB = arg_B;\n\t}\n\tbool operator<(const struct Info& arg) const{ //A-Bの降順\n\t\treturn A-B > arg.A-arg.B;\n\t}\n\tll A,B;\n};\n\nint N;\nll* table;\nll enemy[SIZE],self[SIZE],max_A[SIZE];\nvector<Info> info;\n\n//簡易化のため、要素数を2のべき乗にする関数\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int loc,ll value){\n\tloc += N-1;\n\n\ttable[loc] = value;\n\n\tif(N == 1)return;\n\n\tint parent = (loc-1)/2;\n\n\twhile(true){\n\t\ttable[parent] = max(table[2*parent+1],table[2*parent+2]); //親は左右の子の大きい方の値を持つ\n\n\t\tif(parent == 0)break;\n\t\telse{\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\n\n//任意の区間の最大値を求める関数\nll query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t//今回のノードが検索区間をカバーしていなければ、結果に関係ない値を返す\n\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\t//今回のノードの区間が、検索区間の部分区間である場合、今回のノードの値を返す\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn table[node_id];\n\t}\n\n\t//今回のノードの区間に、一部検索区間と重なっている区間がある場合→再帰的に子どもに尋ねる\n\tll left_max= query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tll right_max = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn max(left_max,right_max);\n}\n\nint main(){\n\n\tint first_N;\n\tll L;\n\n\tscanf(\"%d %lld\",&first_N,&L);\n\n\tll A,B;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld %lld\",&A,&B);\n\t\tinfo.push_back(Info(A,B));\n\t}\n\n\t//敵の高さを計算\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&enemy[i]);\n\t\tif(i != 0){\n\t\t\tenemy[i] += enemy[i-1]; //累積和を計算\n\t\t}\n\t}\n\n\tsort(info.begin(),info.end());\n\n\t//自分の高さを計算\n\tfor(int i = 0; i < first_N; i++){\n\t\tself[i] = info[i].A-info[i].B;\n\t\tif(i != 0){\n\t\t\tself[i] += self[i-1];\n\t\t}\n\t}\n\t//ある日を含め、ある日より右にある、最大のAを求める\n\tmax_A[first_N-1] = info[first_N-1].A;\n\tfor(int i = first_N-2; i >= 0; i--){\n\t\tmax_A[i] = max(max_A[i+1],info[i].A);\n\t}\n\n\t//Bをセグメント木に登録する\n\tN = 1;\n\tinit(first_N);\n\n\ttable = new ll[2*N-1];\n\n\t//0～N-2が上位構造のアドレス、N-1～2*N-2が最小要素のアドレス\n\tfor(int i = 0; i <= 2*N-2; i++)table[i] = NUM;  //まずは範囲外値で初期化\n\t//Bを登録\n\tfor(int i = 0; i < first_N; i++){\n\t\tupdate(i,info[i].B);\n\t}\n\n\tint ans = BIG_NUM;\n\tint limit;\n\n\tll tmp_H;\n\t/*★A-Bの降順に値を採用、脱出日は最大のAを使用する場合★*/\n\n\t//初日で脱出可\n\tif(max_A[0] >= L){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 1; i < first_N; i++){\n\n\t\tif(self[i-1] <= enemy[i-1]){ //敵に追いつかれたので終了\n\t\t\tlimit = i;\n\t\t\tbreak;\n\t\t}\n\t\ttmp_H = self[i-1]+max_A[i];\n\n\t\tif(tmp_H >= L){\n\t\t\tans = i+1; //解答は1オリジンのため\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbool FLG;\n\n\t/*★脱出日までの、どこか一日を、最終日に持ってくる場合★*/\n\tint left = 0,right,m;\n\tint min_index;\n\tll max_B;\n\n\tfor(int i = 1; i < first_N; i++){\n\n\t\tif(self[i-1] <= enemy[i-1]){ //敵に追いつかれたので終了\n\t\t\tbreak;\n\t\t}\n\t\t//0～i日目の間で、i日目に順番を回しても、敵に追いつかれないドリンクの範囲を二分探索で求める\n\t\tright = i,m = (left+right)/2; //★始点は随時右にずれていくので、初期化せずに値を引き継ぐ\n\n\t\tmin_index = BIG_NUM;\n\n\t\twhile(left <= right){\n\n\t\t\tFLG = true;\n\t\t\t//ドリンクmを飲むのをi日目にすることで、敵に追いつかれるか調べる\n\t\t\tfor(int k = m+1; k <= i; k++){\n\t\t\t\tif(self[k]-enemy[k-1] <= info[m].A-info[m].B){ //自分が抜けた翌日以降の敵との差が、自分の加算分以下ならout(追いつかれる)\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\n\t\t\t\tmin_index = m;\n\t\t\t\tright = m-1;\n\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tif(min_index == BIG_NUM)continue;\n\n\t\tmax_B = query(min_index,i,0,0,N-1); //★i日に回しても良いドリンクの中での、Bの最大値を取得★\n\n\t\ttmp_H = self[i]+max_B; //★★加算していたマイナスが消える分(マイナスのマイナス)、プラスになる\n\n\t\tif(tmp_H >= L){\n\t\t\tans = min(ans,i+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110000;\nint a[N], b[N], c[N];\nusing pii = pair<int, int>;\npriority_queue<pii> pq;\n\nint vis[N];\nint lst[N], id = 1;\n\nstruct cmp {\n\tbool operator()(int x, int y) {\n\t\treturn a[x] == a[y] ? b[x] > b[y] : a[x] > a[y];\n\t}\n};\n\nint main() {\n\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tios_base::sync_with_stdio(0);\n\tint n, L; cin >> n >> L;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tpq.push(make_pair(a[i] - b[i], i));\n\t\tlst[i] = i;\n\t}\n\tsort (lst + 1, lst + n + 1, cmp());\n\t\n\tfor (int i = 1; i <= n; i++) cin >> c[i], c[i] = c[i-1] + c[i];\n\tint ans = 0, now = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpii pt, nt;\n\t\tif (now + a[lst[id]] >= L) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t\tpt = pq.top(), pq.pop();\n\t\tif (pt.first + now <= c[i]) break;\n\t\tif (pt.second != lst[id]) {\n\t\t\tnow += pt.first;\n\t\t\tvis[pt.second] = 1;\n\t\t} else {\n\t\t\tif (pq.size() > 1) {\n\t\t\t\tnt = pq.top(), pq.pop();\n\t\t\t\tif (now + nt.first <= c[i]) {\n\t\t\t\t\tpq.push(nt);\n\t\t\t\t\tnow += pt.first;\n\t\t\t\t\tvis[pt.second] = 1;\n\t\t\t\t\tfor (; id <= n; id++) {\n\t\t\t\t\t\tif (vis[lst[id]] == 1) continue;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpq.push(pt);\n\t\t\t\t\tnow += nt.first;\n\t\t\t\t\tvis[nt.second] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnow += pt.first;\n\t\t\t\tvis[pt.second] = 1;\n\t\t\t\tfor (; id <= n; id++) {\n\t\t\t\t\tif (vis[lst[id]] == 1) continue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ans) cout << ans << endl;\n\telse puts(\"-1\");\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cctype>\n#include <set>\n#include \"iostream\"\nusing namespace std;\n#define FOP freopen(\"input.txt\",\"r\",stdin)\n#define Met(x,y) memset(x,y,sizeof x)\ntypedef long long ll;\nconst ll MAXN =100100;\nconst ll INF = 0x3f3f3f3f3f;\n#define L index*2\n#define R index*2+1\n#define MAXN 105100\nstruct node\n{\n\tint l,r,v,mark;\n};\nnode tree[MAXN*4];\nint arr[MAXN],dpo[MAXN],dpn[MAXN];\nint afford[MAXN],sum[MAXN],sumc[MAXN];\nvoid build(int index,int l,int r)\n{\n\ttree[index].l=l,tree[index].r=r;\n    if(l==r)\n    {\n        tree[index].v=afford[l];\n    }\n\tif(l!=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tbuild(L,l,mid);\n\t\tbuild(R,mid+1,r);\n        tree[index].v=min(tree[L].v,tree[R].v);\n\t}\n}\nint query(int index,int l,int r)\n{\n\tif(l==tree[index].l && r==tree[index].r)\n\t{\n\t\treturn tree[index].v;\n\t}else{\n\t\t// if(tree[index].mark)\n\t\t// \tpushdown(index);\n\t\tint mid=(tree[index].l+tree[index].r)/2;\n\t\tif(mid<l){\n\t\t\treturn query(R,l,r);\n\t\t}else if(mid>=r){\n\t\t\treturn query(L,l,r);\n\t\t}else return min(query(L,l,mid),query(R,mid+1,r));\n\t}\n}\nstruct drink\n{\n    ll inc,dec;\n}d[MAXN];\nbool cmp(drink a,drink b)\n{\n    return (a.inc-a.dec)>(b.inc-b.dec);\n}\nint c[MAXN];\nint main(int argc, char const *argv[]) {\n    // FOP;\n\t// freopen(\"input.txt\",\"r\",stdin);\n\t// freopen(\"OUT1.txt\",\"w\",stdout);\n    ll n,l;\n    while(scanf(\"%lld %lld\",&n,&l)!=EOF)\n    {\n        bool one=0;\n        for(ll i=0;i<n;++i) {\n            scanf(\"%lld %lld\",&d[i].inc,&d[i].dec);\n            if(d[i].inc>=l) one=1;\n        }\n        for(ll i=0;i<n;++i) scanf(\"%lld\",&c[i]);\n        if(one)\n        {\n            printf(\"1\\n\" );\n            continue;\n        }\n        sort(d,d+n,cmp);\n        ll days=INF;\n        bool flag=0;\n        sum[0]=d[0].inc-d[0].dec;\n        sumc[0]=c[0];\n        afford[0]=sum[0]-sumc[0];\n        if(sum[0]<=sumc[0]) flag=1;\n        ll pos=n-1;\n        bool reach=0;\n        ll inque=n-1;\n        for(ll i=1;i<n;++i)\n        {\n            sum[i]=sum[i-1]+d[i].inc-d[i].dec;\n            if(d[i].inc-d[i].dec<0)\n            {\n                pos=i-1;\n                inque=i-1;\n                break;\n            }\n            sumc[i]=sumc[i-1]+c[i];\n            afford[i]=sum[i]-sumc[i];\n            if(sum[i]<=sumc[i] && sum[i-1]+d[i].inc<n)\n            {\n                flag=1;\n                break;\n            }\n            if(sum[i]>=l){\n                reach=1;\n                 pos=i;\n                 inque=i;\n                 break;\n            }\n        }\n        if(flag==1 )\n        {\n            printf(\"-1\\n\" );\n            continue;\n        }\n        build(1,0,n-1);\n        bool totch=0;\n        for(ll i=0;i<=inque;++i)\n        {\n            {\n                ll te=INF;\n                for(ll j=pos;sum[j]+d[i].dec>=l && j >i;--j)\n                {\n                    te=j;\n                    if(d[i].inc-d[i].dec-(d[i+1].inc-d[i+1].dec)<query(1,i,te-1))\n                        pos=min(pos,te),totch=1;\n                }\n                //if(d[i].inc-d[i].dec-(d[i+1].inc-d[i+1].dec)<query(1,i,te-1))\n                //    pos=min(pos,te);\n                te=INF;\n                for(ll j=i-1;sum[j]+d[i].inc>=l && j>=0;--j)\n                {\n                    totch=1;\n                    te=j+1;\n                }\n                pos=min(pos,te);\n            }\n        }\n        for(ll i=inque+1;i<n;++i)\n        {\n            ll te=INF;\n            for(ll j=inque;sum[j]+d[i].inc>=l && j>=0;--j)\n            {\n                totch=1;\n                te=j+1;\n            }\n            pos=min(pos,te);\n        }\n        if(reach || totch) printf(\"%lld\\n\",pos+1);\n        else printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nstruct Node\n{\n    LL a,b;\n    LL cha;\n} s[100005];\nLL vis[100005];\nLL c[100005];\nbool cmp(Node a,Node b)\n{\n    if(a.cha==b.cha)\n    {\n        return a.a<b.a;\n    }\n    return a.cha>b.cha;\n}\n\nint main()\n{\n    int n,l;\n    while(~scanf(\"%d%d\",&n,&l))\n    {\n        LL j=0;\n        memset(vis,0,sizeof(vis));\n        priority_queue<LL,vector<LL>,less<LL> >q1;\n        priority_queue<LL,vector<LL>,less<LL> >q2;\n        for(LL i=0; i<n; i++)\n        {\n            scanf(\"%lld%lld\",&s[i].a,&s[i].b);\n            s[i].cha=s[i].a-s[i].b;\n            q1.push(s[i].a);\n        }\n         for(LL i=0; i<n; i++)\n         {\n             scanf(\"%lld\",&c[i]);\n         }\n        sort(s,s+n,cmp);\n        LL mx;\n        LL sum=0;\n        LL ans=0;\n        LL flag=0;\n        LL ss=0;\n        for(LL i=0;i<n;i++)\n        {\n            ss+=c[i];\n             mx=q1.top();\n            if(sum+mx>=l)\n            {\n                sum+=mx;\n                ans++;\n                break;\n            }\n            sum+=s[i].cha;\n            ans++;\n            q2.push(s[i].a);\n//            prLLf(\"%d +++ %d   %d\\n\",sum,ss,mx);\n            if(sum<=ss)\n            {\n                flag=1;\n                break;\n            }\n            while(!q1.empty()&&!q2.empty()&&q1.top()==q2.top())\n            {\n                q1.pop();\n                q2.pop();\n            }\n        }\n        if(sum<l)\n        {\n            flag=1;\n        }\n        if(flag)\n        {\n            printf(\"-1\\n\");\n        }\n        else\n        {\n            printf(\"%lld\\n\",ans);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst int INF = 0x3f3f3f3f;\nint c[N], ls[N];\nll sum[N];\nint n, l, fr;\n\nstruct Node{\n  int a, b;\n}node[N];\nbool cmp(const Node& lh, const Node& rh){\n  if(lh.a-lh.b == rh.a-rh.b)  return lh.b > rh.b;\n  return lh.a-lh.b > rh.a-rh.b;\n}\nvoid pre(){\n  sort(node+1, node+n+1, cmp);\n  fr = n;\n  for(int i = 1; i <= n; i++) if(node[i].a <= node[i].b) {fr = i; break;}\n  for(int i = 1; i <= n; i++) sum[i] += sum[i-1]+node[i].a-node[i].b;\n  ll ca = 0;\n  int idx = 1;\n  for(int i = 2; i <= n; i++){\n    ca += node[i].a-node[i].b-c[idx];\n    if(ca <= 0) break;\n    idx++;\n  }\n  ls[1] = idx;\n  for(int i = 2; i <= n; i++){\n    if(idx == n) {ls[i]=n; continue;}\n    if(i >= idx){ls[i]=n; continue;}\n    ca += node[i-1].a-node[i-1].b-node[i].a+node[i].b;\n    while(ca > 0 && idx < n){\n      idx++;\n      ca += node[idx+1].a-node[idx+1].b-c[idx];\n    }\n    ls[i] = idx;\n  }\n}\nbool check(int x){\n  x--;\n  for(int i = 1; i <= n; i++){\n    ll lim = l - node[i].a;\n    if(ls[i] <= x) continue;\n    if(i > x && sum[x] >= lim) return true;\n    if(i <= x && sum[x+1]-node[i].a+node[i].b >= lim) return true;\n  }\n  return false;\n}\nint main()\n{\n  ll s, mx; s = 0, mx = -1;\n  scanf(\"%d%d\", &n, &l);\n  for(int i = 1; i <= n; i++) {scanf(\"%d%d\", &node[i].a, &node[i].b); mx = max(mx, (ll)node[i].a);}\n  node[n+1].a = node[n+1].b = 0;\n  for(int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  if(mx >= l){printf(\"1\\n\"); return 0;}\n  pre();\n  int left = 1, right = fr, mid;\n  while(left <= right){\n    mid = (left+right)/2;\n    if(check(mid)) right=mid-1;\n    else left=mid+1;\n  }\n  printf(\"%d\\n\", left==fr+1?-1:left);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {}; ll dif2[100000] = {};\nint main() {\n\tint n; ll l; cin >> n >> l;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tif (n >= 2) {\n\t\tdif2[0] = csum[0] + sum[1];\n\t}\n\tRep(i,1, n - 1) {\n\t\tdif2[i] = min(dif2[i - 1], csum[i] + sum[i + 1]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tif (dif2[loc]-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\nconstexpr ll inf = 1e18;\n\ntemplate<typename Monoid>\nclass segment_tree {\n    using T = typename Monoid::type;\n\npublic:\n    segment_tree(std::vector<T> const& init)\n        : sz(init.size()), n(expand(init.size()))\n    {\n        dat.assign(n*2, Monoid::id());\n        std::copy(begin(init), end(init), begin(dat) + n);\n        for(int i = n - 1; i >= 0; --i) {\n            dat[i] = Monoid::op(dat[i * 2], dat[i * 2 + 1]);\n        }\n    }\n\n    segment_tree(int const n_, T const& init = Monoid::id())\n        : segment_tree(std::vector<T>(n_, init))\n    {}\n\n    void update(int p, T val) {\n        assert(0 <= p && p < sz);\n        dat[p += n] = val;\n        while(p /= 2) {\n            dat[p] = Monoid::op(dat[p * 2], dat[p * 2 + 1]);\n        }\n    }\n\n    // [l, r)\n    T query(int l, int r) const {\n        assert(0 <= l && l <= r && r <= sz);\n        l += n, r += n;\n        T res1 = Monoid::id(), res2 = Monoid::id();\n        while(l != r) {\n            if(l & 1) res1 = Monoid::op(res1, dat[l++]);\n            if(r & 1) res2 = Monoid::op(dat[--r], res2);\n            l /= 2, r /= 2;\n        }\n        return Monoid::op(res1, res2);\n    }\n\nprivate:\n    int expand(int n_) const {\n        assert(n_ >= 1);\n        return n_ == 1 ? n_ : expand((n_ + 1) / 2) * 2;\n    }\n\nprivate:\n    const int sz, n;\n    std::vector<T> dat;\n};\n\nstruct RSMQ {\n    struct type {\n        ll sum, mini, maxi;\n        type() : sum(0), mini(inf), maxi(-inf) {}\n        type(ll s, ll mi, ll ma) : sum(s), mini(mi), maxi(ma) {}\n    };\n    static type id() {\n        return type{0, inf, -inf};\n    }\n    static type op(type const& l, type const& r) {\n        if(l.mini == inf) return r;\n        if(r.mini == inf) return l;\n        return type(l.sum + r.sum,\n                    min(l.mini, l.sum + r.mini),\n                    max(l.maxi, l.sum + r.maxi));\n    }\n};\n\nint main() {\n    ll n, l; cin >> n >> l;\n    vector<pll> drink(n);\n    vector<ll> c(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> drink[i].first >> drink[i].second;\n    }\n    for(int i = 0; i < n; ++i) {\n        cin >> c[i];\n    }\n    sort(begin(drink), end(drink), [] (const pll& p1, const pll& p2) {\n        return p1.first - p1.second > p2.first - p2.second;\n    });\n\n    // a[i] - b[i], a[i] - b[i] - c[i], a[i] - b[i] - c[i - 1]\n    vector<RSMQ::type> dat1(n), dat2(n), dat3(n);\n    for(int i = 0; i < n; ++i) {\n        const ll a = drink[i].first, b = drink[i].second;\n        dat1[i] = RSMQ::type{a - b, a - b, a - b};\n        dat2[i] = RSMQ::type{a - b - c[i], a - b - c[i], a - b - c[i]};\n        if(i != 0) {\n            dat3[i] = RSMQ::type{a - b - c[i - 1], a - b - c[i - 1], a - b - c[i - 1]};\n        }\n    }\n    segment_tree<RSMQ> seg1(dat1), seg2(dat2), seg3(dat3);\n\n    int ans = n + 1;\n    for(int i = 0; i < n; ++i) { // last use\n        const ll r = l - drink[i].first;\n        if(r <= 0) {\n            ans = 1;\n            break;\n        }\n        if(seg1.query(0, i).maxi < r) {\n            if(seg2.query(0, i).mini < 0) continue;\n            int lb = i + 1, ub = n;\n            const ll s = seg1.query(0, i).sum;\n            while(ub - lb > 1) {\n                const int mid = (ub + lb) >> 1;\n                (seg1.query(i + 1, mid).maxi < r - s ? lb : ub) = mid;\n            }\n            if(seg1.query(i + 1, ub).maxi < r - s) continue;\n            if(seg2.query(0, i).sum + seg3.query(i + 1, ub).mini <= 0) continue;\n            ans = min(ans, ub);\n        } else {\n            int lb = 0, ub = i;\n            while(ub - lb > 1) {\n                const int mid = (lb + ub) >> 1;\n                (seg1.query(0, mid).maxi < r ? lb : ub) = mid;\n            }\n            if(seg2.query(0, ub).mini <= 0) continue;\n            ans = min(ans, ub + 1);\n        }\n    }\n\n    cout << (ans == n + 1 ? -1 : ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nint n, L;\nint l, r, mid;\nstruct Bottle {\n    int up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nbool check(int x) {\n    x--;\n    rep(k, 1, n + 1) {\n        if(c[k] <= x)\n            continue;\n        ll p = L - a[k].up, go = 0;\n        if(k <= x && sum[x + 1] - a[k].val >= p)\n            return 1;\n        if(k > x && sum[x] >= p)\n            return 1;\n    }\n    return 0;\n}\ninline char gc() {\n    static char buf[1<<20], *head = buf, *tail = buf;\n    return (head == tail && (tail = (head = buf) + fread(buf, 1, 1 << 20, stdin), head == tail)? -1: *head++);\n}\ntemplate <typename T> inline bool read(T &x) {\n    static bool f;\n    static char c;\n    for (c = gc(), f = false; !isdigit(c); c =gc()) {\n        if (c == EOF)\n            return false;\n        else if (c == 45)\n            f = true;\n    }\n    for (x = 0; isdigit(c); c = gc())\n        x = x * 10 + c - 48;\n    if (f)\n        x = -x;\n    return true;\n}\nint main() {\n    read(n);read(L);\n    rep(i, 1, n + 1)read(a[i].up),read(a[i].down),a[i].val = a[i].up - a[i].down;\n    rep(i, 1, n + 1)read(b[i]);\n    sort(a + 1, a + n + 1);\n    rep(i, 1, n + 1)sum[i] = sum[i - 1] + a[i].val;\n    ll cnt = 1, dis = 0;\n    rep(i, 2, n + 1) {\n        dis += (a[i].val - b[cnt]);\n        if(dis <= 0)\n            break;\n        cnt++;\n    }\n    c[1] = cnt;\n    int k = 2;\n    for(; k <= n; k++) {\n        if(cnt < k - 1 || cnt == n)\n            break;\n        dis += (a[k - 1].val - a[k].val);\n        while(dis > 0 && cnt < n)\n            cnt++, dis += (a[cnt + 1].val - b[cnt]);\n        c[k] = cnt;\n    }\n    for(; k <= n; k++)\n        c[k] = cnt;\n    int day = 1;\n    for(int i = 1; a[i].val > 0 && i <= n; i++, day++);\n    l = 1, r = day;\n    while(l < r) {\n        mid = (l + r) / 2;\n        if(check(mid))\n            r = mid;\n        else\n            l = mid + 1;\n    }\n    if(check(l))\n        cout << l << endl;\n    else\n        cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\nconst int INF = 0x3f3f3f3f;\nint c[N], ls[N], sum[N];\nint n, l, fr;\n\nstruct Node{\n  int a, b;\n}node[N];\nbool cmp(const Node& lh, const Node& rh){\n  if(lh.a-lh.b == rh.a-rh.b)  return lh.b > rh.b;\n  return lh.a-lh.b > rh.a-rh.b;\n}\nvoid pre(){\n  sort(node+1, node+n+1, cmp);\n  fr = n;\n  for(int i = 1; i <= n; i++) if(node[i].a <= node[i].b) {fr = i; break;}\n  for(int i = 1; i <= n; i++) sum[i] += sum[i-1]+node[i].a-node[i].b;\n  ll ca = 0;\n  int idx = 1;\n  for(int i = 2; i <= n; i++){\n    ca += node[i].a-node[i].b-c[idx];\n    if(ca <= 0) break;\n    idx++;\n  }\n  ls[1] = idx;\n  for(int i = 2; i <= n; i++){\n    if(idx == n) {ls[i]=n; continue;}\n    if(i >= idx){ls[i]=n; continue;}\n    ca += node[i-1].a-node[i-1].b-node[i].a+node[i].b;\n    while(ca > 0 && idx < n){\n      idx++;\n      ca += node[idx+1].a-node[idx+1].b-c[idx];\n    }\n    ls[i] = idx;\n  }\n}\nbool check(int x){\n  x--;\n  for(int i = 1; i <= n; i++){\n    ll lim = l - node[i].a;\n    if(ls[i] <= x) continue;\n    if(i > x && sum[x] >= lim) return true;\n    if(i <= x && sum[x+1]-node[i].a+node[i].b >= lim) return true;\n  }\n  return false;\n}\nint main()\n{\n  ll s, mx; s = 0, mx = -1;\n  scanf(\"%d%d\", &n, &l);\n  for(int i = 1; i <= n; i++) {scanf(\"%d%d\", &node[i].a, &node[i].b); mx = max(mx, (ll)node[i].a);}\n  for(int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n  if(mx >= l){printf(\"1\\n\"); return 0;}\n  pre();\n  int left = 1, right = fr, mid;\n  while(left < right){\n    mid = (left+right)/2;\n    if(check(mid)) right=mid;\n    else left=mid+1;\n  }\n  printf(\"%d\\n\", check(l)?l:-1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {};\nint m; ll dat[199999];\nvoid init(int m_) {\n\tm = 1;\n\twhile (m < m_)m *= 2;\n\trep(i, 2 * m - 1)dat[i] = INF;\n}\nvoid update(int k,ll a) {\n\tk += m - 1; dat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n;\n\tll l; cin >> n >> l; m = n - 1;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tinit(m);\n    rep(i, n - 1) {\n\t\tupdate(i,sum[i + 1] - csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tll mi = query(i, loc, 0, 0, m);\n\t\t\tif (mi-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 1e5 + 5, INF = 0x3f3f3f3f;\n\nstruct P\n{\n\tll dif; int id;\n\tP(ll dif = 0, int id = -1) :dif(dif), id(id) {}\n\tP operator + (const P &a) const { return P(dif + a.dif, id); }\n\tbool operator < (const P &a) const { return dif > a.dif; }\n};\n\nP p[N];\nint n, ans, loc[N];\nll L, a[N], b[N], c[N], d[N];\n\nll ok(int mid, int i)\n{\n\tif (i <= mid) return p[mid].dif - a[p[i].id] + b[p[i].id];\n\treturn p[mid].dif;\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%lld\", &n, &L))\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\t\tp[i] = P(a[i] - b[i], i);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &c[i]);\n\t\t\tif (i) c[i] += c[i - 1];\n\t\t}\n\t\tsort(p, p + n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tloc[p[i].id] = i;\n\t\tint fu = n - 1;\n\t\tfor (; fu >= 0 && p[fu].dif <= 0; fu--);\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tp[i] = p[i] + p[i - 1];\n\t\tans = INF;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tll len = L - a[i];\n\t\t\tint l = -1, r = fu;\n\t\t\tif (len <= 0) { ans = min(ans, 1); continue; }\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif (ok(mid, loc[i]) < len) l = mid;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\tint now = r - (r >= loc[i]), v = ok(r, loc[i]);\n\t\t\tif (v >= len&& v > c[now])\n\t\t\t\tans = min(ans, now + 2);\n\t\t}\n\t\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nll n, L ,need;\nll l, r, mid;\nstruct Bottle {\n    ll up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nint main()\n{\n     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n     cin>>n>>L;\n     rep(i,1,n+1)cin>>a[i].up>>a[i].down,a[i].val = a[i].up - a[i].down;\n     rep(i,1,n+1)cin>>b[i],c[i]=c[i-1]+b[i];         //c[i]保存b的前缀和\n     sort(a+1,a+n+1);\n     rep(i,1,n+1)sum[i]=sum[i-1]+a[i].val;               //sum[i]保存a的前缀和\n    ll day = 1;for(int i=1;a[i].val>0&&i<=n;i++,day++);    //找到可能的答案范围\n     ll ans=999999999;        //保存答案\n     rep(k,1,n+1)\n     {\n         l=1,r=day;\n         need=L-a[k].up;\n         while(l<r)\n         {\n             ll mid=(l+r)>>1;\n             if(mid==1)l=mid+1;\n             else if((mid-1)>=k&&sum[mid]-a[k].val<=c[mid-1])r=mid;\n             else if((mid-1)<k&&sum[mid-1]<=c[mid-1])r=mid;\n              else l=mid+1;\n         }      //求出k作为最后一瓶饮料使用时最少需要多少天被追上，复杂度为logr\n         l=1;\n         while(((r-1)>=k&&sum[r]-a[k].val<=c[r-1])||((r-1)<k&&sum[r-1]<=c[r-1]))\n         r--;     //判断第r天前是否被追上\n         ll vis=0;\n        while(l<r)\n        {\n            ll mid=(l+r)>>1;\n            if((mid-1)>=k&&sum[mid]-a[k].val>=need){r=mid;vis=mid;}\n             else if((mid-1)<k&&sum[mid-1]>=need){r=mid;vis=mid;}\n              else l=mid+1;\n        }     //求出最少所用天数复杂度为logr\n        if(((l-1)>=k&&sum[l]-a[k].val>=need)||((l-1)<k&&sum[l-1]>=need))\n        ans=min(l,ans);\n        else if(vis)\n        ans=min(vis,ans);\n     }\n     if(ans==999999999)cout<<-1<<endl;\n     else cout<<ans<<endl;\n     return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<string>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<sstream>\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\ntypedef pair<LL, int> pli;\ninline void fre1()\n{\n    freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\in.txt\", \"r\", stdin);/*freopen(\"output.txt\",\"w\",stdout);*/\n    freopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\out.txt\", \"w\", stdout);\n}\ninline void fre2()\n{\n    fclose(stdin);/*fclose(stdout);*/\n}\ninline LL read()\n{\n    LL a = 0, f = 1; char c = getchar();\n    while(!isdigit(c)){ if(c == '-') f = -1; c = getchar(); }\n    while(isdigit(c)) (a *= 10) += c - '0', c = getchar() ;\n    return a * f;\n}\n#define lowbit(x) (x&-x)//取x二?制数最小的1\n#define MS(x, y) memset(x, y, sizeof(x))\n#define MC(x, y) memcpy(x, y, sizeof(x))\n#define lrt rt<<1\n#define rrt rt<<1|1\n#define lson l, mid, lrt\n#define rson mid+1, r, rrt\n#define rep(i, a, b) for(LL i = (a); i <= (b); ++i)\n#define dwn(i, b, a) for(LL i = (b); i >= (a); --i)\nconst LL mod = 1e9 + 7;\nconst int maxn = 5e5 + 10;\nconst double PI = acos(-1), eps = 1e-10;\nconst int FFT_MAXN = 1 << 20;//FFT_MAXN就是大于(n + m)的最小的2^k(做fft?度必??2^k)\nint n, L;\nstruct node\n{\n    int A, B;\n    bool operator < (const node&rhs)const\n    {\n        return  A - B > rhs.A - rhs.B;\n    }\n}p[maxn];\nint C[maxn], li[maxn];\nLL sum[maxn];\n//li[i]表示最后一天白天喝的?料是第i?，追兵最少用多少天才能追上?个人\nvoid init()\n{\n    LL now = 0;\n    int cnt = 1;\n    for(int i = 2; i <= n; ++i)\n    {\n        now += p[i].A - p[i].B - C[cnt];\n        if(now <= 0)break;\n        cnt++;\n    }\n    li[1] = cnt;\n    for(int i = 2; i <= n; ++i)\n    {\n        if(cnt == n || i - 1 > cnt){li[i] = cnt; continue;}\n        now += p[i - 1].A - p[i - 1].B - (p[i].A - p[i].B);\n        while(cnt < n && now > 0)\n        {\n            cnt++;\n            now += p[cnt + 1].A - p[cnt + 1].B - C[cnt];\n        }\n        li[i] = cnt;\n    }\n    //for(int i = 1; i <= n; ++i)printf(\"%d\\n\", li[i]);\n}\nint judge(int x)\n{\n    for(int i = 1; i <= n; ++i)\n    {\n        int tmp = L - p[i].A;\n        if(li[i] <= x - 1)continue;\n        if(i >= x && sum[x - 1] >= tmp)return 1;\n        if(i < x && sum[x] - p[i].A + p[i].B >= tmp)return 1;\n    }\n    return 0;\n}\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &L))\n    {\n        for(int i = 1; i <= n; ++i)scanf(\"%d%d\", &p[i].A, &p[i].B);\n        p[n + 1] = node{0, 0};\n        for(int i = 1; i <= n; ++i)scanf(\"%d\", &C[i]);\n        sort(p + 1, p + 1 + n);\n        for(int i = 1; i <= n; ++i)sum[i] = sum[i - 1] + p[i].A - p[i].B;\n        init();\n        int l = 1, r = n, ans = -1;\n        //for(int i = 1; i <= n; ++i)if(p[i].A <= p[i].B){r = i;break;}\n        while(l <= r)\n        {\n            int mid = (l + r) / 2;\n            if(judge(mid)) ans = mid, r = mid - 1;\n            else l = mid + 1;\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n;\n  bool dbg=0;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(dbg) cout<<i<<\" \"<<cur<<\" \"<<tmp<<endl;\n  }\n  if(dbg) for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  if(dbg) for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    if(z<=rev[i]){\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<pos<<\" \"<<endl;\n      ans=min(ans,pos+2);\n    }else{\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<=y) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n);\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first >= 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N = 100000;\n\nstruct node\n{\n\tint a, b, id;\n\tbool operator < (const node &rhs) const\n\t{\n\t\treturn a - b != rhs.a - rhs.b ?\n\t\t\ta - b > rhs.a - rhs.b :\n\t\t\t\ta < rhs.a;\n\t}\n} ab[N+1], cp[N+1];\n\nbool cmp(const node &x, const node &y)\n{\n\treturn x.a > y.a;\n}\n\nint c[N+1];\nbool vis[N+1];\n\nint main()\n{\n\tint n, l;\n\tscanf(\"%d%d\", &n, &l);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &ab[i].a, &ab[i].b);\n\t\tab[i].id = i;\n\t\tcp[i] = ab[i];\n\t}\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", c+i);\n\n\tsort(ab + 1, ab + n + 1);\n\tsort(cp + 1, cp + n + 1, cmp);\n\n\tmemset(vis, false, sizeof vis);\n\tlong long h = 0, enemy = 0;\n\tint day = 1;\n\tfor(int i = 1, j = 1; day <= n; ++day)\n\t{\n\t\twhile(i <= n && vis[cp[i].id])\n\t\t\t++i;\n\t\tif(i <= n && h + cp[i].a >= l)\n\t\t{\n\t\t\th += cp[i].a;\n\t\t\tvis[cp[i].id] = true;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile(j <= n && vis[ab[j].id])\n\t\t\t++j;\n\t\tif(j > n)\n\t\t\tbreak;\n\t\th += ab[j].a - ab[j].b;\n\t\tvis[ab[j].id] = true;\n\t\tenemy += c[day];\n\t\tif(h <= enemy)\n\t\t\tbreak;\n\t}\n\tprintf(\"%d\\n\", h >= l ? day : -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100500\n#define int long long\nusing namespace std;\nstruct Data{int a, b;}d[N];\nbool cmp(Data x, Data y){\n\treturn x.a - x.b > y.a - y.b;\n}\nint n, m, c[N], f[N], s[N], g[N], h[N], Ans, mnp, mn[N << 2], nn;\nint Min(int a, int b){return g[a] <= g[b] ? a : b;}\nvoid build(int rt, int l, int r){\n\tif(l == r){\n\t\tmn[rt] = l;\n\t\t//printf(\"g[%d] = %d\\n\", r, g[l]);\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(rt << 1, l, mid);\n\tbuild(rt << 1 | 1, mid + 1, r);\n\tmn[rt] = Min(mn[rt << 1], mn[rt << 1 | 1]);\n\t//printf(\"%d  %d  %d  %d\\n\", rt, l, r, mn[rt]);\n}\nint qry(int rt, int l, int r, int y){\n\tif(l == r) return g[l] <= y ? l : (n + 1);\n\tint mid = (l + r) >> 1;\n\tif(g[mn[rt << 1]] <= y) return qry(rt << 1, l, mid, y);\n\tif(g[mn[rt << 1 | 1]] <= y) return qry(rt << 1 | 1, mid + 1, r, y);\n\treturn n + 1;\n}\nint query(int rt, int l, int r, int x, int y){\n\t//printf(\"%d  %d  %d  %d  %d\\n\", rt, l, r, x, y);\n\tif(x <= l) return qry(rt, l, r, y);\n\tint mid = (l + r) >> 1, p1 = n + 1, p2;\n\tif(x <= mid) p1 = query(rt << 1, l, mid, x, y);\n\tp2 = query(rt << 1 | 1, mid + 1, r, x, y);\n\t//printf(\"%d  %d  %d  %d  %d  %d  %d  %d\\n\", rt, l, r, x, y, p1, p2, Min(p1, p2));\n\treturn min(p1, p2);\n}\nint getsum(int x, int y){\n\tif(y < x) return h[y];\n\treturn h[y] - (d[x].a - d[x].b) + (d[y + 1].a - d[y + 1].b);\n}\nint find(int x, int y){\n\tint l = 0, r = nn, mid;\n\twhile(l <= r){\n\t\tmid = (l + r) >> 1;\n\t\tif(getsum(x, mid) >= y) r = mid - 1;\n\t\telse l = mid + 1;\n\t}\n        if(r == nn) r = n;\n\treturn r + 1;\n}\nvoid work(int x){\n\t//printf(\"x ====== %d\\n\", x);\n\tint pos = query(1, 1, n, x, d[x].a - d[x].b);\n\tpos = min(pos, mnp);\n\tint fin = find(x, m - d[x].a);\n\t//printf(\"fin == %d  pos == %d\\n\", fin, pos);\n\tif(pos <= fin) return ;\n\tAns = min(Ans, fin + 1);\n}\nsigned main(){\n\tscanf(\"%lld%lld\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld%lld\", &d[i].a, &d[i].b);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\tsort(d + 1, d + n + 1, cmp);\n\tnn = n;\n\twhile(d[nn].a - d[nn].b <= 0) nn--;\n\tfor(int i = 1; i <= n; i++){\n\t\tf[i] = d[i].a - d[i].b - c[i];\n\t\ts[i] = s[i - 1] + f[i];\n\t\tg[i] = s[i] + (d[i + 1].a - d[i + 1].b);\n\t\th[i] = d[i].a - d[i].b + h[i - 1];\n\t}\n\tg[n + 1] = INT_MAX;\n\tbuild(1, 1, n);\n\tmnp = n + 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(s[i] <= 0) {mnp = i; break;}\n\tAns = LLONG_MAX;\n\t/*work(1);\n\treturn 0;*/\n\tfor(int i = 1; i <= n; i++)\n\t\twork(i);\n\tif(Ans == LLONG_MAX) puts(\"-1\");\n\telse printf(\"%lld\\n\", Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename T& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :obj(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT b0, b1;\n\trangeadd(int n) :b0(n), b1(n);\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\ntemplate<class T>\nclass lazysegtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tT ret(e);\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse {\n\t\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t\treturn ret.update(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t\t}\n\t}\n\ttemplate<class... Param>\n\tT update(int a, int b, int k, int l, int r,const Param&... param) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].update(param);\n\t\t\treturn obj[k];\n\t\t}\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\tobj[k].update(update(a, b, k * 2 + 1, l, (l + r) / 2, param), update(a, b, k * 2 + 2, (l + r) / 2, r, param));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\ttemplate<class... Param>\n\tT update(int a, int b, Param&&... param) {\n\t\tupdate(a, b, 0, 0, offset + 1, param);\n\t}\n\t/*\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l)\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}*/\n\tlazysegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\t/*lazysegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::refrence operator[](int n) {\n\t\treturn obj[n + offset];\n\t}*/\n};//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first >= 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first > 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p - 1) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, LL> P;\nconst int N = 1e5 + 5;\n\nLL n, m;\nLL c[N], day[N];\nP drinks[N];\n\nbool check(int mid) {\n  LL sum = 0, tmp = drinks[mid].first - drinks[mid].second;\n  for (int i = 1; i < mid; ++i) sum += drinks[i].first - drinks[i].second;\n  for (int i = 1; i <= n; ++i) {\n    if (day[i] < mid) continue;\n    if (i < mid) {\n      if (sum + tmp + drinks[i].second >= m) return true;\n    }\n    else {\n      if (sum + drinks[i].first >= m) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  LL mx = -1;\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld%lld\", &drinks[i].first, &drinks[i].second);\n    mx = max(mx, drinks[i].first);\n  }\n  for (int i = 1; i <= n; ++i) scanf(\"%lld\", c + i);\n  if (mx >= m) {\n    puts(\"1\");\n    continue;\n  }\n  sort(drinks + 1, drinks + 1 + n, [](const P& a, const P& b) {\n       return a.first - a.second > b.first - b.second;\n       });\n  int p = 1;\n  LL sum = 0;\n  for (int i = 2; i <= n; ++i) {\n    sum += drinks[i].first - drinks[i].second - c[p];\n    if (sum <= 0) break;\n    p++;\n  }\n  day[1] = p;\n  for (int i = 2; i <= n; ++i) {\n    if (p < i - 1) {\n      day[i] = p;\n      continue;\n    }\n    if (p == n) {\n      day[i] = n;\n      continue;\n    }\n    sum += drinks[i-1].first - drinks[i-1].second - (drinks[i].first - drinks[i].second);\n    while (p < n && sum > 0) {\n      ++p;\n      sum += drinks[p+1].first - drinks[p+1].second - c[p];\n    }\n    day[i] = p;\n  }\n  int l = 1, r = n, mid, ans = -1;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    if (check(mid)) r = (ans = mid) - 1;\n    else l = mid + 1;\n  }\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {}; ll dif2[100000] = {};\nint main() {\n\tint n; ll l; cin >> n >> l;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tif (n >= 2) {\n\t\tdif2[0] = csum[0] + sum[1];\n\t}\n\tRep(i,1, n - 1) {\n\t\tdif2[i] = min(dif2[i - 1], sum[i]-csum[i] + x[i + 1].first);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tif (dif2[loc-1]-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct point\n{\n    long long u,d,c;\n} p[100000+10];\nlong long mx [100009];\nlong long num[100009];\nlong long cc[100009];\nlong long mx1 [100009][2];\nbool cmp(point x,point y)\n{\n    if (x.c!=y.c)\n    {\n        return x.c>y.c;\n    }\n    else return x.u<y.u;\n}\nint main ()\n{\n    long long n,l;\n    while (~scanf(\"%lld%lld\",&n,&l))\n    {\n        for (long long i =0; i<n; i++)\n        {\n            scanf(\"%lld%lld\",&p[i].u,&p[i].d);\n            p[i].c=p[i].u-p[i].d;\n        }\n        sort(p,p+n,cmp);\n        long long s=0;\n        for (long long i =0; i<n; i++)\n        {\n            long long www;\n            scanf(\"%lld\",&www);\n            if (i==0)cc[i]=www;\n            else cc[i]=cc[i-1]+www;\n        }\n        long long fg=p[0].d;\n        long long mk=p[0].u;\n        for (long long i =0; i<n; i++)\n        {\n            if (i==0) num[i]=p[i].c;\n            else  num[i]=p[i].c+num[i-1];\n            if (fg>p[i].d)\n           {\n               fg=p[i].d;\n               mk=p[i].u;\n           }\n           mx1[i][0]=fg;\n           mx1[i][1]=mk;\n        }\n        fg=p[n-1].u;\n        for (long long i =n-1; i>=0; i--)\n        {\n            fg=max(fg,p[i].u);\n            mx[i]=fg;\n        }\n        long long  ans=mx[0];\n        long long res;\n        if (ans>=l)\n            res=1;\n        else\n            for (long long i =1; i<n; i++)\n            {\n                if (num[i]-mx1[i][1]+mx1[i][0]>cc[i-1])\n                {\n                    ans=max(ans,mx1[i][0]+num[i]);\n                }\n                 if (ans>=l)\n                {\n                    res=i+1;\n                    break;\n                }\n                if (num[i-1]<=cc[i-1])\n                {\n                    ans=-1;\n                    break;\n                }\n                ans=num[i-1]+mx[i];\n\n                if (ans>=l)\n                {\n                    res=i+1;\n                    break;\n                }\n            }\n        if (ans<l)printf (\"-1\\n\");\n        else printf (\"%lld\\n\",res);\n    }\n}\n/*\n3 9\n6 3\n5 2\n3 1\n2\n2\n2\n5 20\n3 2\n4 2\n6 3\n8 4\n10 5\n4\n2\n3\n4\n5\n5 20\n6 5\n7 3\n10 3\n10 14\n4 7\n2\n5\n3\n9\n2\n4 12\n8 4\n6 4\n2 1\n2 1\n1\n1\n4\n4\n\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <iostream>\n#include <vector>\n#include <numeric>\n#include <limits>\n#include <string>\n#include <stdio.h>\n#include <algorithm>\n#include <stack>\nusing namespace std;\nconst int maxn = 100000 + 10;\ntypedef long long int LLI;\n\nstruct Node {\n\tLLI x,y,iter;\n\tbool flag;\n}op[maxn],op1[maxn];\n\nLLI c[maxn];\nLLI id[maxn];\n\nbool cmp2(Node a, Node b){\n\tif((a.x - a.y) != (b.x - b.y)) return (a.x - a.y) > (b.x - b.y);\n\treturn a.x < b.x;\n}\n\nbool cmp1(Node a, Node b){\n\treturn a.x > b.x;\n}\n\nint main() {\n//    freopen(\"in.txt\",\"r\",stdin);\n\tLLI n,L;\n\tscanf(\"%lld%lld\", &n,&L);\n\tfor (LLI i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld\", &op[i].x, &op[i].y);\n\t\top[i].flag = true;\n\t\top[i].iter = i;\n\t\top1[i] = op[i];\n\t}\n\tfor (LLI i = 1; i <= n; i++)\tscanf(\"%lld\", &c[i]);\n\tsort(op + 1, op + 1 + n, cmp1);\n\tsort(op1 + 1, op1 + 1 + n, cmp2);\n\tfor (LLI i = 1; i <= n; i++){\n\t\tid[op[i].iter] = i;\n\t}\n\n\tLLI l1 = 1, l2 = 1,len = -L,zlen = -L,ans = -1;\n\tfor (LLI i = 1; i <= n; i++){\n\t\twhile (op[l1].flag == false && l1 <= n)\tl1++;\n\t\twhile (op1[l2].flag == false && l2 <= n)\tl2++;\n\t\tif (len + op[l1].x >= 0)\t{\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tlen = len + (op1[l2].x - op1[l2].y);\n\t\t\top1[l2].flag = false;\n\t\t\top[id[op1[l2].iter]].flag = false;\n\t\t\tzlen += c[i];\n\t\t\tif (zlen >= len)\tbreak;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct BIT{\n\tint size;\n\tvector<llint> bit;\n\tBIT(){size = 0;}\n\tBIT(int s){\n\t\tsize = s;\n\t\tbit.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) bit[i] = 0;\n\t}\n\tllint query(int i){\n\t\tllint ret = 0;\n\t\twhile(i > 0){\n\t\t\tret += bit[i];\n\t\t\ti -= i&(-i);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid add(int i, llint x){\n\t\twhile(i <= size){\n\t\t\tbit[i] += x;\n\t\t\ti += i&(-i);\n\t\t}\n\t}\n};\n\nstruct SegTree{\n\tint size;\n\tvector<llint> seg;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++) seg[i] = inf;\n\t}\n\t\n\tvoid update(int i, llint val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\n\tllint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tllint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tllint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tllint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nllint n, l;\nllint a[100005], b[100005];\nllint c[100005], sumc[100005];\n\nvector<P> vec;\nBIT bit(100005);\nSegTree seg(17);\nllint pnum;\n\nllint get(llint x)\n{\n\tllint ub = pnum+1, lb = -1, mid;\n\twhile(ub-lb>1){\n\t\tmid = (ub+lb)/2;\n\t\tif(bit.query(mid) >= x) ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nint main(void)\n{\n\tcin >> n >> l;\n\tfor(int i = 1; i <= n; i++) cin >> a[i] >> b[i];\n\tfor(int i = 1; i <= n; i++) cin >> c[i];\n\tfor(int i = 1; i <= n; i++) sumc[i] = sumc[i-1] + c[i];\n\t\n\tfor(int i = 1; i <= n; i++) vec.push_back(make_pair(a[i]-b[i], i));\n\tsort(vec.rbegin(), vec.rend());\n\t\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tif(vec[i].first < 0) break;\n\t\tbit.add(i+1, vec[i].first);\n\t\tpnum++;\n\t}\n\tllint tpos = n+1;\n\tfor(int i = 1; i <= pnum; i++){\n\t\tif(bit.query(i) - sumc[i] <= 0){\n\t\t\ttpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tseg.init();\n\tfor(int i = 1; i <= pnum; i++) seg.update(i, bit.query(i) - sumc[i-1]);\n\t\n\tllint ans = inf;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tllint id = vec[i].second;\n\t\tif(i < pnum){\n\t\t\tbit.add(i+1, -vec[i].first);\n\t\t\tllint p = get(l - a[id]);\n\t\t\tbit.add(i+1, vec[i].first);\n\t\t\tif(p > pnum || p >= tpos) continue;\n\t\t\tif(p < i+2) ans = min(ans, p+1);\n\t\t\telse if(seg.query(i+2, p) > vec[i].first) ans = min(ans, p);\n\t\t}\n\t\telse{\n\t\t\tllint p = get(l - a[id]);\n\t\t\tif(p > pnum) continue;\n\t\t\tif(p < tpos) ans = min(ans, p+1);\n\t\t}\n\t}\n\tif(ans >= inf) cout << -1 << endl;\n\telse cout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define P pair<ll,ll>\n#define inf 0x3f3f3f3f\nconst int maxn=200005;\nll pre1[maxn],pre2[maxn],a[maxn],b[maxn],d[maxn];\nP c[maxn];\nll bin(ll x,ll targ,ll end)\n{\n\tll l=0,r=end+1;\n\twhile(r-l>1)\n\t{\n\t\tll mid=(l+r)/2;\n\t\tll sum=0;\n\t\tif(x<=mid)\n\t\tsum=pre1[mid]+b[c[x].second];\n\t\telse\n\t\tsum=pre1[mid]+a[c[x].second];\n\t\tif(sum>=targ)\n\t\tr=mid;\n\t\telse\n\t\tl=mid;\n\t}\n\treturn r;\n}\nbool cmp(P x,P y)\n{\n\treturn x.first>y.first;\n}\nint main()\n{\n\tll n,l;\n\tll ans=inf;\n\tscanf(\"%lld%lld\",&n,&l);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tc[i]=P(a[i]-b[i],i);\n\t}\n\tfor(ll i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&d[i]);\n\tsort(c+1,c+1+n,cmp);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tpre1[i]=pre1[i-1]+c[i].first;\n\t\tpre2[i]=pre2[i-1]+d[i];\n\t}\n\tll sum1=0,sum2=0;\n\tll pos=1;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\twhile(pos<=n&&sum1+c[pos+1].first>sum2+d[pos])\n\t\t{\n\t\t\tpos++;\n\t\t\tsum1+=c[pos+1].first;\n\t\t\tsum2+=d[pos];\n\t\t}\n\t\tif(a[c[i].second]>=l)\n\t\tans=1;\n\t\tll tmp=bin(i,l,pos);\n\t\tif(tmp<pos+1)\n\t\tans=min(ans,tmp+(tmp<i));\n\t\tif(pos>i)\n\t\tsum1+=c[i].first;\n\t\tif(pos>i+1)\n\t\tsum1-=c[i+1].first;\n\t}\n\tif(ans==inf)\n\tprintf(\"-1\\n\");\n\telse\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\n#define MAX 100005\ntypedef pair<ll,ll> P;\ntypedef pair<ll, P > PP;\n \nconst ll INF = 10000000000000000LL;\n \nstruct segtree {\n  vector<ll> data;\n  vector<ll> delay;\n \n  int n;\n  void init(int _n){\n    n = 1;\n    while( n < _n ) n*=2;\n    data.resize( 2 * n );\n    delay.resize( 2 * n );\n  }\n \n  void delaycalc( int k ){\n    data[k] = data[k] + delay[k];\n    if( k + 1 < n )\n      for(int i=1;i<=2;i++)\n        delay[ 2 * k + i ] += delay[k];\n    delay[k] = 0;\n  }\n \n  void add( int a, int b, ll x, int k, int l, int r ){\n    delaycalc( k );\n    if( r<=a  || b<=l ) return;\n \n    else if( a <= l && r <= b ) {\n      delay[k] = x;\n      delaycalc( k );\n    } else {\n      add( a, b, x, 2 * k + 1, l, (l+r)/2 );\n      add( a, b, x, 2 * k + 2, (l+r)/2, r );\n      data[k] = min( data[ 2 * k + 1 ], data[ 2 * k + 2 ] );\n    }\n  }\n \n  ll query( int a,int b,int k,int l, int r ){\n    delaycalc( k );\n    if( r<=a  || b<=l ) return INF;\n    else if( a <= l && r <= b ) {\n      return data[k] + delay[k];\n    } else {\n      ll vl = query( a, b, 2 * k + 1, l, (l + r)/2 );\n      ll vr = query( a, b, 2 * k + 2, (l + r)/2, r );\n      return min( vl, vr );\n    }      \n  }\n \n  //[a, b)\n  void add( int a, int b, ll x ,bool flg=false){\n    if(flg)x*=-1LL;\n    add( a, b, x, 0, 0, n );\n  }\n  //[a, b )\n  ll query( int a, int b ,bool flg=false){\n    ll res=query( a, b, 0, 0, n );\n    if(flg)res*=-1LL;\n    return res;\n  }\n  \n};\n \n \nsegtree S,T;\nll N,L;\nll a[MAX],b[MAX];\nll c[MAX];\n \nint search(ll x){\n  int L=0,R=N,M;\n  while(L<R){\n    M=(L+R)/2;\n    if(S.query(0,M,true) <x )L=M+1;\n    else R=M;\n  }\n  return L;\n}\n \nint main(){\n  cin>>N>>L;\n  S.init(N+10);\n  T.init(N+10);\n \n  vector<PP> v;\n  for(int i=0;i<N;i++){\n    cin>>a[i]>>b[i];\n    if(a[i]>=L){\n      cout<<1<<endl;\n      return 0;\n    }\n    v.push_back(PP(a[i]-b[i],P(a[i],b[i])));\n  }\n  sort(v.begin(),v.end());\n  reverse(v.begin(),v.end());\n  for(int i=0;i<N;i++){\n    a[i]=v[i].second.first;\n    b[i]=v[i].second.second;\n  }\n  for(int i=0;i<N;i++){\n    ll num;\n    cin>>num;\n    c[i]=num;\n    T.add(i,N,-num);\n    T.add(i,N,a[i]-b[i]);\n    S.add(i,N,a[i]-b[i],true);\n  }\n  \n  ll ans=INF;\n  for(int i=N-1;i>=0;i--){\n    S.add(i,N,b[i]-a[i],true);\n    T.add(i,N,b[i]-a[i]);\n    if(i<N-1){\n      T.add(i,N,c[i]);\n      T.add(i+1,N,-c[i]);\n    }\n    /*    \n    for(int j=0;j<N;j++){\n      cout<<S.query(j,j+1,true)<<' '<<T.query(j,j+1)<<endl;\n    }\n    cout<<endl<<endl;\n    */\n    int id=search( L-a[i] );\n \n \n    int si=0;\n    if(i==0)si=1;\n    if( T.query(si,id) > 0  && S.query(0,id,true) >= L-a[i] ){\n      if(i<id)id--;\n      ans=min(ans,(ll)id+1);\n    }\n \n    S.add(i,N,a[i]-b[i],true);\n    T.add(i,N,a[i]-b[i]);\n  }\n  if(ans==INF)ans=-1;\n  cout<<ans<<endl;  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first >= 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nint n, L;\nint l, r, mid;\nstruct Bottle {\n    int up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nbool check(int x) {\n    x--;\n    rep(k, 1, n + 1) {\n        if(c[k] <= x)\n            continue;\n        ll p = L - a[k].up, go = 0;\n        if(k <= x && sum[x + 1] - a[k].val >= p)\n            return 1;\n        if(k > x && sum[x] >= p)\n            return 1;\n    }\n    return 0;\n}\ninline char gc() {\n    static char buf[1<<20], *head = buf, *tail = buf;\n    return (head == tail && (tail = (head = buf) + fread(buf, 1, 1 << 20, stdin), head == tail)? -1: *head++);\n}\ntemplate <typename T> inline bool read(T &x) {\n    static bool f;\n    static char c;\n    for (c = gc(), f = false; !isdigit(c); c =gc()) {\n        if (c == EOF)\n            return false;\n        else if (c == 45)\n            f = true;\n    }\n    for (x = 0; isdigit(c); c = gc())\n        x = x * 10 + c - 48;\n    if (f)\n        x = -x;\n    return true;\n}\nint main() {\n    read(n);read(L);\n    rep(i, 1, n + 1)read(a[i].up),read(a[i].down),a[i].val = a[i].up - a[i].down;\n    rep(i, 1, n + 1)read(b[i]);\n    sort(a + 1, a + n + 1);\n    rep(i, 1, n + 1)sum[i] = sum[i - 1] + a[i].val;\n    ll cnt = 1, dis = 0;\n    rep(i, 2, n + 1) {\n        dis += (a[i].val - b[cnt]);\n        if(dis <= 0)\n            break;\n        cnt++;\n    }\n    c[1] = cnt;\n    int k = 2;\n    for(; k <= n; k++) {\n        if(cnt < k - 1 || cnt == n)\n            break;\n        dis += (a[k - 1].val - a[k].val);\n        while(dis > 0 && cnt < n)\n            cnt++, dis += (a[cnt + 1].val - b[cnt]);\n        c[k] = cnt;\n    }\n    for(; k <= n; k++)\n        c[k] = cnt;\n    int day = 1;\n    for(int i = 1; a[i].val > 0 && i <= n; i++, day++);\n    l = 1, r = day;\n    while(l < r) {\n        mid = (l + r) / 2;\n        if(check(mid))\n            r = mid;\n        else\n            l = mid + 1;\n    }\n    if(check(l))\n        cout << l << endl;\n    else\n        cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> pii;\nvoid chkmin(int &a, int b) { a = a < b ? a : b; }\nvoid chkmin(LL &a, LL b) { a = a < b ? a : b; }\nconst int maxn = 100100;\nconst LL oo = 0x3f3f3f3f3f3f3f3fLL;\n#define lowbit(x) ((x) & (-(x)))\nLL bit_data[maxn];\nvoid add(int p, LL v)\n{\n\tfor (++p; p < maxn; p += lowbit(p)) chkmin(bit_data[p], v);\n}\nLL sum(int p)\n{\n\tLL ret = oo;\n\tfor (++p; p; p -= lowbit(p)) chkmin(ret, bit_data[p]);\n\treturn ret;\n}\nint n, id[maxn];\nLL c[maxn], s[maxn], mn1[maxn], mn2[maxn];\npii p[maxn];\nbool cmp(pii &a, pii &b) { return a.first - a.second > b.first - b.second; }\nint myfind(int lo, int hi, LL v)\n{\n\tint ans = lo - 1;\n\twhile (lo <= hi) {\n\t\tint md = (lo + hi) / 2;\n\t\tif (sum(md) > v) lo = md + 1, ans = md;\n\t\telse hi = md - 1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tLL L;\n\tscanf(\"%d%lld\", &n, &L);\n\tfor (int i = 0; i < n; ++i) scanf(\"%lld%lld\", &p[i].first, &p[i].second), id[i] = i;\n\tsort(p, p + n, cmp);\n\tmemset(bit_data, 0x3f, sizeof(bit_data));\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lld\", c + i);\n\t\tif (i) c[i] += c[i - 1];\n\t\ts[i] = p[i].first - p[i].second;\n\t\tif (i) s[i] += s[i - 1];\n\t\tmn1[i] = s[i] - c[i];\n\t\tif (i) chkmin(mn1[i], mn1[i - 1]);\n\t\tif (i == 0) mn2[i] = oo;\n\t\telse mn2[i] = s[i] - c[i - 1];\n\t\tif (i) chkmin(mn2[i], mn2[i - 1]);\n\t}\n\tLL ans = oo;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tint id1 = upper_bound(mn1, mn1 + i, 1, greater<int>()) - mn1 - 1;\n\t\tif (id1 == -1) {\n\t\t\tif (p[i].first >= L) chkmin(ans, 1);\n\t\t}\n\t\telse {\n\t\t\tif (s[id1] + p[i].first >= L) chkmin(ans, id1 + 1);\n\t\t}\n\t\tif (id1 == i - 1) {\n\t\t\tint id2 = myfind(i + 1, n - 1, p[i].first - p[i].second);\n\t\t\tif (s[id2] + p[i].second >= L) chkmin(ans, id2);\n\t\t}\n\t\tadd(i, mn2[i]);\n\t}\n\tif (ans == oo) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {}; ll dif2[100000] = {};\nint main() {\n\tint n; ll l; cin >> n >> l;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tif (n >= 2) {\n\t\tdif2[0] = csum[0] + sum[1];\n\t}\n\tRep(i,1, n - 1) {\n\t\tdif2[i] = min(dif2[i - 1], csum[i] + sum[i + 1]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tif (dif2[loc-1]-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define EACH(i, a) for(auto&& i:a)\n#define FOR(i,a,b) for(ll i = (a); i < (b); ++i)\n#define RFOR(i,a,b) for(ll i = (b)-1; i >= (a); --i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define ALL(v) (v).begin(),(v).end()\n\nconst ll linf = 1e18;\nconst ll inf = 1e9;\n\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\n\nstruct Drink {\n    ll A, B;\n};\nistream& operator>>(istream& is, Drink& d) {\n    return cin >> d.A >> d.B;\n}\nbool operator<(const Drink& d1, const Drink& d2) {\n    return d1.A - d1.B < d2.A - d2.B;\n}\nbool operator>(const Drink& d1, const Drink& d2) {\n    return d2 < d1;\n}\n\n// template<class T>\n// T lower_bound(T l, T r, ll times, const function<bool(T)>& check) {\n//     while (times--) {\n//         T m = (l + r) / 2;\n//         if ( check(m) ) {\n//             r = m;\n//         }\n//         else {\n//             l = m;\n//         }\n//     }\n//     return r;\n// }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, L; cin >> n >> L;\n    vector<Drink> D(n); cin >> D;\n    vector<ll> C(n); cin >> C;\n    sort(ALL(D), greater<Drink>());\n    // ll pos = lower_bound<ll>(0, n, 50, [&](ll m) {\n    //     return true;\n    // });\n    vector<ll> M(n+1, 0);\n    RREP(i, n) M[i] = max(M[i+1], D[i].A);\n    if ( M[0] >= L ) {\n        cout << 1 << endl;\n        return 0;\n    }\n    // d??\\??§??§?????????\n    auto check = [&](ll d) {\n        // pos?????????????????§???d-1??\\?????????????????????\n        auto check = [&](ll pos) {\n            ll j = 0;\n            ll sum1 = 0, sum2 = 0;\n            REP(i, d) {\n                if (i == pos) continue;\n                sum1 += D[i].A - D[i].B;\n                sum2 += C[j++];\n                if (sum1 <= sum2) return false;\n                if (sum1+M[i+1] >= L) return true;\n            }\n            return true;\n        };\n        if ( !check(d) ) return false;\n        ll l = 0, r = d;\n        REP(t, 50) {\n            ll m = (l + r) / 2;\n            if ( check(m) ) {\n                r = m;\n            }\n            else {\n                l = m;\n            }\n        }\n        ll pos = r;\n        ll sum = 0;\n        REP(i, d) if (D[i].A - D[i].B > 0) {\n            sum += D[i].A - D[i].B;\n        }\n        vector<ll> S(d+2, 0);\n        REP(i, d-1) S[i+1] = S[i]+D[i].A-D[i].B;\n        S[d+1] = linf;\n        FOR(i, pos, d) {\n            if ( D[i].A - D[i].B >= 0 ) {\n                if (sum + D[i].B >= L) return true;\n            }\n            else {\n                if (sum + D[i].A >= L) return true;\n            }\n        }\n        sum -= D[d-1].A - D[d-1].B;\n        FOR(i, d-1, n) {\n            ll lb = lower_bound(ALL(S), L-D[i].A)-S.begin();\n            if (lb < d) return true;\n        }\n        return false;\n    };\n    // cout << check(5) << endl;\n    // return 0;\n    ll l = 0, r = n;\n    REP(i, n) {\n        if (D[i].A - D[i].B < 0) {\n            r = i;\n            break;\n        }\n    }\n    if ( !check(r) ) {\n        cout << -1 << endl;\n        return 0;\n    }\n    REP(t, 50) {\n        ll m = (l + r) / 2;\n        if ( check(m) ) {\n            r = m;\n        }\n        else {\n            l = m;\n        }\n    }\n    cout << r << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nll dif1[100000] = {};\nint m; ll dat[199999];\nvoid init(int m_) {\n\tm = 1;\n\twhile (m < m_)m *= 2;\n\trep(i, 2 * m - 1)dat[i] = INF;\n}\nvoid updat(int k,ll a) {\n\tk += m - 1; dat[k] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\nll query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l)return INF;\n\tif (a <= l && r <= b)return dat[k];\n\telse {\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\nint main() {\n\tint n;\n\tll l; cin >> n >> l; m = n - 1;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tdif1[0] = sum[0] - csum[0];\n\tRep(i,1, n) {\n\t\tdif1[i] = min(dif1[i - 1], sum[i] - csum[i]);\n\t}\n\tinit(m);\n    rep(i, n - 1) {\n\t\tupdat(i,sum[i + 1] - csum[i]);\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (dif1[loc]>0)out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tll mi = query(i, loc, 0, 0, m);\n\t\t\tif (mi-nx>0)out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n// #define show(x) cerr << #x << \" = \" << x << endl\n#define show(x)\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return (Total != d.Total) ? Total > d.Total : A < d.A;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total << endl;\n    return os;\n}\n\nint main()\n{\n    ll N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (ll i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (ll i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    //    cerr << accum << endl;\n\n    vector<ll> C(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (ll i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (ll i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (ll i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    //    cerr << data << endl;\n    // show(sum1);\n    // show(sum2);\n    //    show(accum);\n    // show(data);\n    constexpr ll INF = 1LL << 60;\n    ll minimum = INF;\n\n\n    for (ll i = 0; i < N; i++) {\n        show(i);\n        ll goal = L - data[i].A;\n        const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower <= i) {\n            show(\"hogeohoegoeodwqd\");\n            show(goal);\n            show(lower);\n            const ll mini = seg1.query(1, lower + 1);\n            show(mini);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            show(\"feffwuefwiuefwuef\");\n            // if (lower >= N) {\n            //     continue;\n            // }\n            goal = L - data[i].B;\n            const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N + 1) {\n                //          cerr << accum[N] - goal << endl;\n                continue;\n            }\n            show(lower);\n            if (i == 0) {\n                show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower);\n                }\n            } else {\n                show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i + 1);\n                show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <fstream>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <bitset>\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,x,n) for(int i=n-1;i>=x;i--)\nusing namespace std;\n#define ll long long\n//head\nint n, L;\nint l, r, mid;\nstruct Bottle {\n    int up, down, val;\n    bool operator < (const Bottle a)const {\n        return val > a.val;\n    }\n} a[100005];\nll b[100005], c[100005], sum[100005];\nbool check(int x) {\n    x--;\n    rep(k, 1, n + 1) {\n        if(c[k] <= x)\n            continue;\n        ll p = L - a[k].up, go = 0;\n        if(k <= x && sum[x + 1] - a[k].val >= p)\n            return 1;\n        if(k > x && sum[x] >= p)\n            return 1;\n    }\n    return 0;\n}\ninline char gc() {\n    static char buf[1<<20], *head = buf, *tail = buf;\n    return (head == tail && (tail = (head = buf) + fread(buf, 1, 1 << 20, stdin), head == tail)? -1: *head++);\n}\ntemplate <typename T> inline bool read(T &x) {\n    static bool f;\n    static char c;\n    for (c = gc(), f = false; !isdigit(c); c =gc()) {\n        if (c == EOF)\n            return false;\n        else if (c == 45)\n            f = true;\n    }\n    for (x = 0; isdigit(c); c = gc())\n        x = x * 10 + c - 48;\n    if (f)\n        x = -x;\n    return true;\n}\nint main() {\n    read(n);read(L);\n    rep(i, 1, n + 1)read(a[i].up),read(a[i].down),a[i].val = a[i].up - a[i].down;\n    rep(i, 1, n + 1)read(b[i]);\n    sort(a + 1, a + n + 1);\n    rep(i, 1, n + 1)sum[i] = sum[i - 1] + a[i].val;\n    ll cnt = 1, dis = 0;\n    rep(i, 2, n + 1) {\n        dis += (a[i].val - b[cnt]);\n        if(dis <= 0)\n            break;\n        cnt++;\n    }\n    c[1] = cnt;\n    int k = 2;\n    for(; k <= n; k++) {\n        if(cnt < k - 1 || cnt == n)\n            break;\n        dis += (a[k - 1].val - a[k].val);\n        while(dis > 0 && cnt < n)\n            cnt++, dis += (a[cnt + 1].val - b[cnt]);\n        c[k] = cnt;\n    }\n    for(; k <= n; k++)\n        c[k] = cnt;\n    int day = 1;\n    for(int i = 1; a[i].val > 0 && i <= n; i++, day++);\n    l = 1, r = day;\n    while(l < r) {\n        mid = (l + r) / 2;\n        if(check(mid))\n            r = mid;\n        else\n            l = mid + 1;\n    }\n    if(check(l))\n        cout << l << endl;\n    else\n        cout << -1 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first > 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i <= max) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && p != max)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n;\n  bool dbg=0;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(dbg) cout<<i<<\" \"<<cur<<\" \"<<tmp<<endl;\n    if(cur<=tmp){\n      z=i;\n      break;\n    }\n  }\n  if(dbg) for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  if(dbg) for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    if(z<=rev[i]){\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<pos<<\" \"<<endl;\n      ans=min(ans,pos+2);\n    }else{\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<=y) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nLP x[100000]; ll csum[100000]; ll c[100000]; ll sum[100000];\nint safe1[100000] = {}; int safe2[100000] = {};\nint main() {\n\tint n; ll l; cin >> n >> l;\n\trep(i, n) {\n\t\tll a, b; cin >> a >> b;\n\t\tx[i] = { a - b,a };\n\t}\n\trep(i, n) {\n\t\tcin >> c[i];\n\t}\n\tsort(x, x + n,greater<LP>());\n\tsum[0] = x[0].first;\n\tcsum[0] = c[0];\n\tRep(i, 1, n) {\n\t\tsum[i] = sum[i - 1] + x[i].first;\n\t\tcsum[i] = csum[i - 1] + c[i];\n\t}\n\tif (sum[0] > csum[0])safe1[0] = 1;\n\tRep(i, 1, n) {\n\t\tif (sum[i] > csum[i])safe1[i] = 1;\n\t\tif (sum[i]-sum[0] > csum[i - 1])safe2[i] = 1;\n\t}\n\tRep(i,1, n) {\n\t\tsafe1[i] *= safe1[i - 1];\n\t\tif (i > 1) {\n\t\t\tsafe2[i] *= safe2[i - 1];\n\t\t}\n\t}\n\tint out = (int)MOD;\n\trep(i, n) {\n\t\tll nx = x[i].first; ll ny = x[i].second;\n\t\tint loc = lower_bound(sum, sum + n, l - ny) - sum;\n\t\tif (loc == n)continue;\n\t\tif (loc < i) {\n\t\t\tif (safe1[loc])out = min(out, 2 + loc);\n\t\t}\n\t\telse {\n\t\t\tloc = lower_bound(sum, sum + n, l - ny + nx) - sum;\n\t\t\tif (loc == n)continue;\n\t\t\tif (safe2[loc])out = min(out, loc + 1);\n\t\t}\n\t}\n\tif (out == (int)MOD) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, LL> P;\nconst int N = 1e5 + 5;\n\nint n, m;\nint c[N], day[N];\nP drinks[N];\n\nbool check(int mid) {\n  LL sum = 0, tmp = drinks[mid].first - drinks[mid].second;\n  for (int i = 1; i < mid; ++i) sum += drinks[i].first - drinks[i].second;\n  for (int i = 1; i <= n; ++i) {\n    if (day[i] < mid) continue;\n    if (1 <= i && i < mid) {\n      if (sum + tmp + drinks[i].second >= m) return true;\n    }\n    else {\n      if (sum + drinks[i].first >= m) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%lld%lld\", &drinks[i].first, &drinks[i].second);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", c + i);\n  sort(drinks + 1, drinks + 1 + n, [](const P& a, const P& b) {\n       return a.first - a.second > b.first - b.second;\n       });\n  int p = 1;\n  LL sum = 0;\n  for (int i = 2; i <= n; ++i) {\n    sum += drinks[i].first - drinks[i].second - c[p];\n    if (sum <= 0) break;\n    p++;\n  }\n  day[1] = p;\n  for (int i = 2; i <= n; ++i) {\n    if (p < i - 1) {\n      day[i] = p;\n      continue;\n    }\n    if (p == n) {\n      day[i] = n;\n      continue;\n    }\n    sum += drinks[i-1].first - drinks[i-1].second - (drinks[i].first - drinks[i].second);\n    while (p < n && sum > 0) {\n      ++p;\n      sum += drinks[p+1].first - drinks[p+1].second - c[p];\n    }\n    day[i] = p;\n  }\n  int l = 1, r = n, mid, ans = -1;\n  while (l <= r) {\n    mid = (l + r) >> 1;\n    if (check(mid)) r = (ans = mid) - 1;\n    else l = mid + 1;\n  }\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* SimpleSegTree(0-index) */\n\ntemplate <typename Type = int>\nstruct SimpleSegTree{\n  int segn2;\n  Type initVal;\n  vector<Type> data;\n  function<Type(Type, Type)> merge;\n\n  SimpleSegTree(int n, Type initVal, function<Type(Type, Type)> merge):\n    initVal(initVal), merge(merge)\n  {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, initVal);\n  }\n\n  SimpleSegTree(int n): //RangeMinimunQuery\n    SimpleSegTree(n, LLINF, [](Type a, Type b){ return min(a, b); }) {}\n\n  SimpleSegTree(int n, Type initVal): //RangeMinimunQuery\n    SimpleSegTree(n, initVal, [](Type a, Type b){ return min(a, b); }) {}\n\n  //get value [a,b)\n  Type query(int a, int b, int l = 0, int r = -1, int k = 0){\n    if(r == -1) r = segn2;\n    if(a <= l && r <= b) return data[k];\n    if(r <= a || b <= l) return initVal;\n    return merge(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2,r,k*2+2));\n  }\n\n  //set kth number x\n  void set(int k, Type x){\n    k += segn2-1;\n    data[k] = x;\n    while(k > 0){\n      k = (k-1)/2;\n      data[k] = merge(data[k*2+1], data[k*2+2]);\n    }\n  }\n};\n\n\n\nll A[SIZE], B[SIZE], C[SIZE];\npair<ll,int> d[SIZE];\nint pos[SIZE];\nbool ok[SIZE];\n\nint main(){\n  int N, L;\n\n  scanf(\"%d%d\", &N, &L);\n\n  bool once = false;\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%lld%lld\", A+i, B+i);\n    d[i] = {A[i] - B[i], i};\n    once |= A[i] >= L;\n  }\n\n  if (once) {\n    puts(\"1\");\n    return 0;\n  }\n\n  sort(d, d+N, greater<pair<ll,int>>());\n\n  for (int i=0; i<N-1; i++) {\n    d[i+1].first = max(0LL, d[i+1].first) + d[i].first;\n    pos[d[i].second] = i;\n  }\n  pos[d[N-1].second] = N-1;\n\n\n  for (int i=0; i<N; i++)\n    scanf(\"%lld\", C+i);\n\n  for (int i=0; i<N-1; i++)\n    C[i+1] += C[i];\n\n  for (int i=0; i<N; i++) {\n    ok[i] = C[i] < d[i].first;\n    if (i > 0) ok[i] &= ok[i-1];\n    debug(d[i].first);\n    debug(ok[i]);\n  }\n\n  SimpleSegTree<ll> seg(N);\n\n  for (int i=0; i<N-1; i++) {\n    seg.set(i, d[i+1].first - C[i]);\n  }\n\n\n  int ans = INF;\n\n  for (int i=0; i<N; i++) {\n    int p = pos[i];\n\n    int q1 = lower_bound(d, d+p, make_pair(L-A[i], 0)) - d;\n    int q2 = lower_bound(d+p+1, d+N, make_pair(L+(A[i]-B[i])-A[i], 0)) - d;\n\n    debug(p); debug(q1); debug(q2);\n\n    if (q1 < p) {\n      if (ok[q1]) ans = min(ans, q1+2);\n    }\n\n    if (q2 < N) {\n      if ((p < 0 || ok[p-1]) && seg.query(p, q2) > (A[i] - B[i]))\n        ans = min(ans, q2+1);\n    }\n  }\n\n  if (ans == INF) ans = -1;\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int M=100020;\nconst int N=100010;\nstruct node{\n     int x;\n}na[N];\nint f[N],n,m,k,l;\nLL a[N],b[N],c[N],qianzhui[N],cqianzhui[N];\ninline bool operator < (const node &lhs,const node &rhs){\n     return a[lhs.x]-b[lhs.x]>a[rhs.x]-b[rhs.x];\n}\nint main(){\n     int cases;\n     cases=1;\n     for(int iii=1;iii<=cases;++iii){\n          scanf(\"%d%lld\",&n,&l);\n          for(int i=1;i<=n;++i)scanf(\"%lld%lld\",&a[i],&b[i]);\n          for(int i=1;i<=n;++i)scanf(\"%lld\",&c[i]);\n          for(int i=1;i<=n;++i)na[i].x=i;\n          sort(na+1,na+n+1);\n          qianzhui[0]=0;\n          int border=n+1;\n          for(int i=1;i<=n;++i){\n               qianzhui[i]=qianzhui[i-1]+a[na[i].x]-b[na[i].x];\n               if(border==n+1&&qianzhui[i]<qianzhui[i-1])border=i;\n          }\n          cqianzhui[0]=0;\n          for(int i=1;i<=n;++i)cqianzhui[i]=cqianzhui[i-1]+c[i];\n\n\n          int ans=n+1;\n          for(int ii=1;ii<=n;++ii){\n               int i=min(ii,border);\n               if(qianzhui[i-1]+a[na[ii].x]>=l){\n                    int leftp=0,rightp=i-1;\n                    while(leftp<rightp){\n                         int mid=((leftp+rightp)>>1);\n                         if(qianzhui[mid]+a[na[ii].x]>=l)rightp=mid;\n                         else leftp=mid+1;\n                    }\n                    if(qianzhui[leftp]+a[na[ii].x]<l)continue;\n                    if(qianzhui[leftp]<=cqianzhui[leftp])continue;\n                    ans=min(ans,leftp+1);\n               }\n               else{\n                    if(ii==n)continue;\n                    if(ii>=border)continue;\n                    int leftp=ii+1,rightp=border-1;\n                    while(leftp<rightp){\n                         int mid=((leftp+rightp)>>1);\n                         if(qianzhui[mid]+b[na[ii].x]>=l)rightp=mid;\n                         else leftp=mid+1;\n                    }\n                    if(qianzhui[leftp]+b[na[ii].x]<l)continue;\n                    if(qianzhui[leftp]-(a[na[ii].x]-b[na[ii].x])<=cqianzhui[leftp-1])continue;\n                    ans=min(ans,leftp);\n               }\n          }\n          if(ans<=n)\n          printf(\"%d\\n\",ans);\n          else printf(\"-1\\n\");\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n\nusing namespace std;\n\n#define maxn 100005\n#define ll long long\n\nconst int inf=0x3f3f3f3f;\n\nstruct node{\n    ll id;\n    ll a;\n    ll b;\n    bool operator <(const node& x) const {\n    return a-b==x.a-x.b?a<x.a:a-b>x.a-x.b;\n    }\n};\n\nnode s1[maxn],s2[maxn];\nll c[maxn];\nbool vis[maxn];\nll l,n;\n\nbool cmp(node a,node b){\n    return a.a>b.a;\n}\n\nbool ok(int d){\n    ll sum=0;\n    memset(vis,false,sizeof(vis));\n    for(int i=0;i<d-1;i++){\n        sum+=s1[i].a-s1[i].b;\n        vis[s1[i].id]=true;\n        if(sum<=c[i]) return false;\n        if(sum>=l) return true;\n    }\n    int i;\n    for(i=0;i<n;i++){\n        if(vis[s2[i].id]) continue;\n        else break;\n    }\n    if(sum+s2[i].a>=l) return true;\n    return false;\n}\n\nint main(){\n    scanf(\"%lld%lld\",&n,&l);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld%lld\",&s1[i].a,&s1[i].b);\n        s1[i].id=i;\n    }\n    for(int i=0;i<n;i++){\n        s2[i]=s1[i];\n    }\n    sort(s1,s1+n);\n    sort(s2,s2+n,cmp);\n    for(int i=0;i<n;i++)\n        scanf(\"%lld\",c+i);\n    for(int i=1;i<n;i++){\n        c[i]+=c[i-1];\n    }\n    int l=1;\n    int r=n;\n    while(l<r){\n        int m=(l+r)>>1;\n        if(ok(m)) r=m;\n        else l=m+1;\n //       cout<<m<<' '<<ok(m)<<endl;\n    }\n    int ans=l;\n    if(ok(l)==false) ans=-1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n// #define show(x) cerr << #x << \" = \" << x << endl\n#define show(x)\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return (Total != d.Total) ? Total > d.Total : A < d.A;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total << endl;\n    return os;\n}\n\nint main()\n{\n    ll N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (ll i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (ll i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    //    cerr << accum << endl;\n\n    vector<ll> C(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (ll i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (ll i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (ll i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    //    cerr << data << endl;\n    // show(sum1);\n    // show(sum2);\n    //    show(accum);\n    // show(data);\n    constexpr ll INF = 1LL << 60;\n    ll minimum = INF;\n\n\n    for (ll i = 0; i < N; i++) {\n        show(i);\n        ll goal = L - data[i].A;\n        const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            show(\"hogeohoegoeodwqd\");\n            show(goal);\n            show(lower);\n            const ll mini = seg1.query(1, lower + 1);\n            show(mini);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            show(\"feffwuefwiuefwuef\");\n            // if (lower >= N) {\n            //     continue;\n            // }\n            goal = L - data[i].B;\n            const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N + 1) {\n                //          cerr << accum[N] - goal << endl;\n                continue;\n            }\n            show(lower);\n            if (i == 0) {\n                show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower);\n                }\n            } else {\n                show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i + 1);\n                show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n//#define show(x) cerr << #x << \" = \" << x << endl\n#define show(x)\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return (Total != d.Total) ? Total > d.Total : A < d.A;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total << endl;\n    return os;\n}\n\nint main()\n{\n    ll N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (ll i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (ll i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    //    cerr << accum << endl;\n\n    vector<ll> C(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (ll i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (ll i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (ll i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    //    cerr << data << endl;\n    // show(sum1);\n    // show(sum2);\n    //    show(accum);\n    // show(data);\n    constexpr ll INF = 1LL << 60;\n    ll minimum = INF;\n\n\n    for (ll i = 0; i < N; i++) {\n        show(i);\n        ll goal = L - data[i].A;\n        const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            show(\"hogeohoegoeodwqd\");\n            show(goal);\n            show(lower);\n            const ll mini = seg1.query(1, lower);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            show(\"feffwuefwiuefwuef\");\n            // if (lower >= N) {\n            //     continue;\n            // }\n            goal = L - data[i].B;\n            const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N + 1) {\n                //          cerr << accum[N] - goal << endl;\n                continue;\n            }\n            show(lower);\n            if (i == 0) {\n                show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower);\n                }\n            } else {\n                show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i);\n                show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower + 1);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n;\n  bool dbg=0;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(dbg) cout<<i<<\" \"<<cur<<\" \"<<tmp<<endl;\n  }\n  if(dbg) for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  if(dbg) for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    {\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(dbg) cout<<i<<\";\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\";\"<<x<<\" \"<<pos<<\" \"<<endl;\n      if(rev[i]<=pos) continue;\n      ans=min(ans,pos+2);\n    }\n  }\n  for(int i=0;i<n;i++){\n    {\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      //cout<<pos<<endl;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<=y) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      if(pos<rev[i]) continue;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1e6+5;\nconst int imax=1e6;\nconst int inf=999999999;\nint en,n,a[maxn],b[maxn];\ntypedef long long ll;\nll tree[maxn],sum[maxn],c[maxn];\n\n/*struct node\n{\n\tint x,id;\n//\tnode(int x,int id):x(x),id(id){}\n}p[maxn];*/\n\nstruct node\n{\n    int x,id;\n    node(){}\n    bool operator < (const node &a) const\n    {\n        if(a.x==x) return id<a.id;\n        return x>a.x;\n    }\n}p[maxn];\n\n//bool operator < (node a,node b){ return a.x==b.x?a.id<b.id:a.x<b.x; }\n\n/*bool cmp(node a,node b)\n{\n\treturn a.x==b.x?a.id<b.id:a.x>b.x;\n}*/\n\nvoid build(int l,int r,int rt)\n{\n    if(l==r)\n    {\n        tree[rt]=sum[l]-c[l-1];\n        return ;\n    }\n    int mid=(l+r)/2;\n    build(l,mid,rt*2);\n    build(mid+1,r,rt*2+1);\n    tree[rt]=min(tree[rt*2],tree[rt*2+1]);\n}\n\n/*void build(int l,int r,int rt)\n{\n\tif(l==r)\n\t{\n\t\ttree[rt]=sum[l]-c[l-1];\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,rt*2);\n\tbuild(mid+1,r,rt*2+1);\n\ttree[rt]=min(tree[rt*2],tree[rt*2+1]); \n}*/\n\nint qu(int L,int R,int l,int r,int rt)\n{\n\tif(r<L||l>R)\treturn inf;\n\tif(l>=L&&r<=R)\treturn tree[rt];\n\tint mid=(l+r)>>1;\n\tint a1=inf,a2=inf;\n\ta1=qu(L,R,l,mid,rt*2);\n\ta2=qu(L,R,mid,r,rt*2+1);\n\treturn min(a1,a2);\n}\n\n/*ll qu(int L,int R,int l,int r,int rt)\n{\n    if(L>R) return inf;\n    if(L<=l&&r<=R) return tree[rt];\n    int mid=(l+r)/2;\n    int a1=inf,a2=inf;\n    if(L<=mid) a1=qu(L,R,l,mid,rt*2);\n    if(R>mid) a2=qu(L,R,mid+1,r,rt*2+1);\n    return min(a1,a2);\n}*/\n\nbool check(int i,int mid)\n{\n    if(i>mid) return sum[mid]+a[p[i].id]>=en;\n    return sum[mid]-p[i].x+a[p[i].id]>=en;\n}\n\n\nint main()\n{\n\tint ans=inf;\n\tc[0]=0;\n\tsum[0]=0;\n\tscanf(\"%d%d\",&n,&en);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tp[i].x=a[i]-b[i];\n\t\tp[i].id=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",c+i);\n\t\tc[i]+=c[i-1];\n\t}\n\tsort(p+1,p+1+n);\n\tfor(int i=1;i<=n;++i)\tsum[i]=sum[i-1]+p[i].x;\n\tbuild(1,n,1);\n\tint gg=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(p[i].x<0)\n\t\t{\n\t\t\tgg=i;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\tgg++;\n\tint num=1;\n\twhile(sum[num]>c[num])\n\t{\n\t\tif(num>n)\tbreak;\n\t\tnum++;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint l=0,r=n+1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(check(i,mid))\tr=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t//\tprintf(\"he\\n\");\n\t\tif(r>n)\tcontinue;\n\t\tif(r<=i)\n\t\t{\n\t\t\tif(r<num)\tans=min(ans,r+1);\n\t\t}\n\t\telse\n\t\tif(qu(i+1,r,1,n,1)>p[i].x)\tans=min(ans,r);\n\t//\tprintf(\"douwo\\n\");\n\t}\n\tif(ans==inf)\tprintf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n// #define show(x) cerr << #x << \" = \" << x << endl\n#define show(x)\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return (Total != d.Total) ? Total > d.Total : A < d.A;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total << endl;\n    return os;\n}\n\nint main()\n{\n    ll N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (ll i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (ll i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    //    cerr << accum << endl;\n\n    vector<ll> C(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (ll i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (ll i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (ll i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (ll i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    //    cerr << data << endl;\n    // show(sum1);\n    // show(sum2);\n    //    show(accum);\n    // show(data);\n    constexpr ll INF = 1LL << 60;\n    ll minimum = INF;\n\n\n    for (ll i = 0; i < N; i++) {\n        show(i);\n        ll goal = L - data[i].A;\n        const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            show(\"hogeohoegoeodwqd\");\n            show(goal);\n            show(lower);\n            const ll mini = seg1.query(1, lower + 1);\n            show(mini);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            show(\"feffwuefwiuefwuef\");\n            // if (lower >= N) {\n            //     continue;\n            // }\n            goal = L - data[i].B;\n            const ll lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N + 1) {\n                //          cerr << accum[N] - goal << endl;\n                continue;\n            }\n            show(lower);\n            if (i == 0) {\n                show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower+1);\n                }\n            } else {\n                show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i + 1);\n                show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// 区間add, 区間min\nstruct LazySegTree{\n    int n; vector<ll> mx,mn,lazy;\n    //初期化\n    LazySegTree(int _n){\n        n=1;\n        while(n<_n) n*=2;\n        mx=vector<ll>(2*n-1,0);\n        mn=vector<ll>(2*n-1,0);\n        lazy=vector<ll>(2*n-1,0);\n    }\n\n    void setLazy(int k, ll v){\n        lazy[k] += v;\n        mx[k] += v;\n        mn[k] += v;\n    }\n\n    void push(int k, int l, int r){\n        if(lazy[k]!=0){\n            setLazy(2*k+1,lazy[k]);\n            setLazy(2*k+2,lazy[k]);\n        }\n        lazy[k]=0;\n    }\n\n    void fix(int k, int l, int r){\n        mx[k] = max(mx[2*k+1], mx[2*k+2]);\n        mn[k] = min(mn[2*k+1], mn[2*k+2]);\n    }\n\n    //内部的に投げられるクエリ\n    void _add(int a, int b, ll x, int k, int l, int r){\n        if(r<=a || b<=l) return;\n        if(a<=l && r<=b){\n            setLazy(k,x);\n            return;\n        }\n\n        push(k,l,r);\n        _add(a,b,x,2*k+1,l,(l+r)/2);\n        _add(a,b,x,2*k+2,(l+r)/2,r);\n\n        fix(k,l,r);\n    }\n    //[a,b)に+x\n    void add(int a, int b, ll x){\n        return _add(a,b,x,0,0,n);\n    }\n\n    //内部的に投げられるクエリ\n    ll _MIN(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l) return LLONG_MAX/3;\n        if(a<=l && r<=b) return mn[k];\n\n        push(k,l,r);\n        ll vl=_MIN(a,b,2*k+1,l,(l+r)/2);\n        ll vr=_MIN(a,b,2*k+2,(l+r)/2,r);\n        return min(vl,vr);\n    }\n    //[a,b)の最小値\n    ll MIN(int a, int b){\n        return _MIN(a,b,0,0,n);\n    }\n\n        //内部的に投げられるクエリ\n    ll _MAX(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l) return -LLONG_MAX/3;\n        if(a<=l && r<=b) return mx[k];\n\n        push(k,l,r);\n        ll vl=_MAX(a,b,2*k+1,l,(l+r)/2);\n        ll vr=_MAX(a,b,2*k+2,(l+r)/2,r);\n        return max(vl,vr);\n    }\n    //[a,b)の最小値\n    ll MAX(int a, int b){\n        return _MAX(a,b,0,0,n);\n    }\n};\n\nconst int INF = 1234567;\nusing P = pair<ll,int>;\n\nint main(){\n    int n;\n    ll L;\n    scanf(\" %d %lld\", &n, &L);\n\n    vector<ll> a(n),b(n);\n    rep(i,n) scanf(\" %lld %lld\", &a[i], &b[i]);\n\n    vector<ll> c(n);\n    rep(i,n) scanf(\" %lld\", &c[i]);\n\n    rep(i,n-1) c[i+1] += c[i];\n\n    vector<P> drink(n);\n    vector<ll> v(n);\n    rep(i,n) drink[i] = {a[i]-b[i], i};\n    sort(all(drink), greater<P>());\n\n    rep(i,n) v[i] = drink[i].fi;\n    rep(i,n-1) v[i+1] += v[i];\n\n    LazySegTree vst(n),st1(n),st2(n);\n    rep(i,n){\n        vst.add(i,i+1,v[i]);\n        st1.add(i,i+1,v[i]);\n        st2.add(i,i+1,v[i]);\n    }\n    rep(i,n) st1.add(i,i+1,-c[i]);\n    rep(i,n-1) st2.add(i+1,i+2,-c[i]);\n\n    int ans = INF;\n    rep(i,n){\n        int idx = drink[i].se;\n        ll A = a[idx];\n        if(A >= L){\n            ans = 1;\n            break;\n        }\n        // dbg(L-A);\n\n        vst.add(i,n+1,-drink[i].fi);\n\n        int ng=-1, ok=n;\n        while(ok-ng>1){\n            int mid = (ok+ng)/2;\n            if(vst.MAX(0,mid+1) >= L-A) ok = mid;\n            else ng = mid;\n        }\n\n        vst.add(i,n+1,drink[i].fi);\n        if(ok == n) continue;\n\n        st1.add(i,n+1,-drink[i].fi);\n        st2.add(i,n+1,-drink[i].fi);\n\n        int days;\n        if(ok<i){\n            days = ok+1 + 1;\n            if(st1.MIN(0,ok+1)>0) ans = min(ans,days);\n        }\n        else{\n            days = ok + 1;\n            if(st1.MIN(0,i)>0 && st2.MIN(i+1,ok+1)>0) ans = min(ans,days);\n        }\n\n        st1.add(i,n+1,drink[i].fi);\n        st2.add(i,n+1,drink[i].fi);\n    }\n\n    if(ans == INF) ans = -1;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* \" A computer would deserve to be called intelligent if it\ncould deceive a human into believing that it was human. \"\n                                            - Alan Turing */\n#include<bits/stdc++.h>\nusing namespace std;\n#define D               double\n#define LL              long long\n#define ULL             unsigned long long\n#define SF              scanf\n#define PF              printf\n#define FOR(i, a, b)    for(int i = a; i < b; i++)\n#define REV(i, a, b)    for(int i = a - 1; i >= b; i--)\n#define SET(a, v)       memset(a, v, sizeof a)\n#define VI              vector<int>\n#define PB              push_back\n#define ALL(v)          v.begin(), v.end()\n#define MII             map<int, int>\n#define MSI             map<string, int>\n#define PII             pair<int, int>\n#define MP              make_pair\n#define X               first\n#define Y               second\n// return the index     (match ? first match : immediate greater)\n#define lbA(a, n, x)    lower_bound(a, a + n, x) - a\n#define lbV(v, x)       lower_bound(ALL(v), x) - v.begin()\n// return the index     (match ? last match + 1 : immediate greater)\n#define ubA(a, n, x)    upper_bound(a, a + n, x) - a\n#define ubV(v, x)       upper_bound(ALL(v), x) - v.begin()\ntemplate <class T> inline T bigmod(T b, T p, T M) {\n    LL ret = 1;\n    for(; p > 0; p >>= 1) {\n        if(p & 1) ret = (ret * b) % M;\n        b = (b * b) % M;\n    }\n    return (T) ret;\n}\ntemplate <class T> inline T __lcm(T a, T b) {\n    return (a * b) / __gcd(a, b);\n}\nint dx4[] = {1, 0, -1, 0}; // 4 directions\nint dy4[] = {0, 1, 0, -1};\nint dx8[] = {0, 0, 1, 1, 1, -1, -1, -1}; // 8 directions\nint dy8[] = {1, -1, -1, 0, 1, -1, 0, 1};\nint kx8[] = {1, 1, 2, 2, -1, -1, -2, -2}; // Knight Moves\nint ky8[] = {2, -2, 1, -1, 2, -2, 1, -1};\n//freopen(\"in.txt\", \"r\", stdin);\n//freopen(\"out.txt\", \"w\", stdout);\n// int tc;SF(\"%d\",&tc);FOR(cs,1,tc+1){}\nconst LL                LINF = 1e18;\nconst int               INF = 1e9, NIL = -1;\nconst int               N = 1e5 + 5, M = 1e9 + 7;\n\nstruct z {\n    int a, b, d;\n    z() {}\n    z(int _a, int _b, int _d) {\n        a = _a, b = _b, d = _d;\n    }\n    bool friend operator < (z x, z y) {\n        if(x.d != y.d) return x.d > y.d;\n        return x.a < y.a;\n    }\n} a[N];\n\nint n, L, c[N], seg[4 * N];\n\nvoid update(int c, int s, int e, int p, int v) {\n    if(s == e) {\n        seg[c] = v;\n        return;\n    }\n    int mid = (s + e) / 2, L = 2 * c, R = L + 1;\n    if(p <= mid) update(L, s, mid, p, v);\n    else update(R, mid + 1, e, p, v);\n    seg[c] = max(seg[L], seg[R]);\n}\n\nint query(int c, int s, int e, int l, int r) {\n    if(s == l && e == r) return seg[c];\n    int mid = (s + e) / 2, L = 2 * c, R = L + 1;\n    if(r <= mid) return query(L, s, mid, l, r);\n    else if(l > mid) return query(R, mid + 1, e, l, r);\n    else {\n        int x = query(L, s, mid, l, mid);\n        int y = query(R, mid + 1, e, mid + 1, r);\n        return max(x, y);\n    }\n}\n\nint main() {\n    SF(\"%d%d\", &n, &L);\n    FOR(i, 1, n + 1) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        a[i] = z(x, y, x - y);\n    }\n    sort(a + 1, a + n + 1);\n    FOR(i, 1, n + 1) {\n        SF(\"%d\", &c[i]);\n        update(1, 1, n, i, a[i].a);\n    }\n    LL good = 0, bad = 0;\n    int ans = -1;\n    FOR(i, 1, n + 1) {\n        int mx = query(1, 1, n, i, n);\n        if(good + mx >= L) {\n            ans = i;\n            break;\n        }\n        good += a[i].d;\n        bad += c[i];\n        if(bad >= good) break;\n    }\n    PF(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct drink{\n  LL a;\n  LL b;\n  bool operator<(const struct drink& right) const{\n    return (a-b==right.a-right.b?a<right.a:a-b<right.a-right.b);\n  }\n};\n\nint main(){\n  LL n,l;\n  cin >> n >> l;\n  vector<struct drink> d(n);\n  LL total=0;\n  for(int i=0;i<n;i++){\n    cin >> d[i].a >> d[i].b;\n  }\n  sort(d.begin(),d.end());\n  vector<LL> mx(n);\n  mx[0]=-1000000000;\n  for(int i=1;i<n;i++){\n    mx[i]=max(mx[i-1],d[i-1].a);\n  }\n  vector<LL> c(n);\n  for(int i=0;i<n;i++){\n    cin >> c[i];\n  }\n  LL ruiD=0,ruiC=0;\n  for(int i=0;i<n-1;i++){\n    ruiD+=d[n-1-i].a-d[n-1-i].b;\n    ruiC+=c[i];\n    if(ruiD<=ruiC){\n      cout << -1 << endl;\n      return 0;\n    }\n    if(ruiD+mx[n-1-i]>=l){\n      cout << i+2 << endl;\n      return 0;\n    }\n  }\n  cout << -1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n;\n  bool dbg=0;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(dbg) cout<<i<<\" \"<<cur<<\" \"<<tmp<<endl;\n  }\n  if(dbg) for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  if(dbg) for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    {\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(dbg) cout<<i<<\";\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\";\"<<x<<\" \"<<pos<<\" \"<<endl;\n      if(rev[i]<=pos) continue;\n      ans=min(ans,pos+2);\n    }\n  }\n  for(int i=0;i<n;i++){\n    {\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      //cout<<pos<<endl;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<=y) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      if(pos<=rev[i]) continue;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <tr1/unordered_map>\n#include <bits/stdc++.h>\nusing namespace std;\nusing namespace std::tr1;\n\n#define N 100010\n#define M 1000010\n#define LL long long\n#define ULL unsigned long long \n#define eps 1e-8\n#define pii pair<LL, int>\n#define pdd pair<double, double>\n#define MP make_pair\n#define pb push_back\n#define inf 0x3f3f3f3f\n#define fi first\n#define se second\n#define md (ll+rr>>1)\n#define ls (i<<1)\n#define rs (i<<1|1)\n#define lson ll, md, ls\n#define rson md+1, rr, rs\n#define mod 1000000007\n\nint a[N], b[N], c[N];\nint n, L;\nLL dif[N];\nint id[N];\nLL sum[N];\nLL mi[N*4];\n\nbool cmp(int i, int j) {\n\treturn dif[i] > dif[j];\n}\nLL check(int i, int mid) {\n\tif(i > mid) return sum[mid];\n\telse return sum[mid] - dif[id[i]];\n}\n\nvoid build(int ll, int rr, int i) {\n\tif(ll == rr) {\n\t\tmi[i] = sum[ll] - c[ll-1];\n\t\treturn ;\n\t}\n\tbuild(lson);\n\tbuild(rson);\n\tmi[i] = min(mi[ls], mi[rs]);\n}\n\nLL query(int l, int r, int ll, int rr, int i) {\n\tif(l > r) return inf;\n\tif(l <= ll && rr <= r) return mi[i];\n\tif(r <= md) return query(l, r, lson);\n\telse if(l > md) return query(l, r, rson);\n\telse return min(query(l, md, lson), query(md+1, r, rson));\n}\n\n\nint main() {\n\twhile(~scanf(\"%d%d\", &n, &L)) {\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tscanf(\"%d\", &c[i]);\n\t\tfor(int i = 1; i <= n; ++i) c[i] += c[i-1];\n\t\tfor(int i = 1; i <= n; ++i) dif[i] = a[i] - b[i], id[i] = i;\n\t\tsort(id+1, id+n+1, cmp);\n\n\t\tfor(int i = 1; i <= n; ++i) \n\t\t\tsum[i] = sum[i-1] + dif[id[i]];\n\t\tint end = 1;\n\t\twhile(end <= n && sum[end] > c[end]) end++;\n\n\t\tbuild(1, n, 1);\n\t\tint ans = inf;\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tint l = 1, r = n+1;\n\t\t\twhile(l < r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif(check(i, mid) >= L-a[id[i]]) r = mid;\n\t\t\t\telse l = mid+1;\n\t\t\t}\n\t\t\tif(l > n) continue;\n\t\t\tif(l <= i) {\n\t\t\t\tif(l < end) \n\t\t\t\t\tans = min(ans, l + 1);\n\t\t\t}\n\t\t\telse if(query(i+1, l, 1, n, 1) > dif[id[i]]) {\n\t\t\t\tans = min(ans, l);\n\t\t\t}\n\t\t}\n\t\tif(ans == inf) ans = -1;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nconstexpr ll INF = 1LL << 60;\nconstexpr int SIZE = 1 << 17;\nstruct Seg {\n    int n_;\n    ll dat[2 * SIZE - 1];\n    Seg(const int x)\n    {\n        n_ = 1;\n        while (n_ < x) {\n            n_ *= 2;\n        }\n        rep(i, 2 * n_ - 1)\n        {\n            dat[i] = INF;\n        }\n    }\n\n    void update(int k, ll a)\n    {\n        k += n_ - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[2 * k + 1], dat[2 * k + 2]);\n        }\n    }\n\n    ll query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a or b <= l) {\n            return INF;\n        }\n        if (a <= l and r <= b) {\n            return dat[k];\n        } else {\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return min(vl, vr);\n        }\n    }\n    ll query(int a, int b)\n    {\n        return query(a, b, 0, 0, n_);\n    }\n};\n\nstruct Data {\n    ll A;\n    ll B;\n    ll Total;\n    bool operator>(const Data& d) const\n    {\n        return Total > d.Total;\n    }\n};\nostream& operator<<(ostream& os, const Data& d)\n{\n    os << d.A << \" \" << d.B << \" \" << d.Total;\n    return os;\n}\n\nint main()\n{\n    int N;\n    ll L;\n    cin >> N >> L;\n    vector<Data> data(N);\n    for (int i = 0; i < N; i++) {\n        ll A, B;\n        cin >> A >> B;\n        data[i] = Data{A, B, A - B};\n    }\n    sort(data.begin(), data.end(), greater<Data>{});\n    vector<ll> accum(N + 1, 0);\n    for (int i = 1; i <= N; i++) {\n        accum[i] = max(data[i - 1].Total, 0LL);\n    }\n    for (int i = 1; i <= N; i++) {\n        accum[i] += accum[i - 1];\n    }\n\n    vector<ll> C(N);\n    for (int i = 0; i < N; i++) {\n        cin >> C[i];\n    }\n\n    vector<ll> sum1(N + 1, 0);\n    for (int i = 1; i <= N; i++) {\n        sum1[i] = data[i - 1].Total - C[i - 1];\n    }\n    for (int i = 1; i <= N; i++) {\n        sum1[i] += sum1[i - 1];\n    }\n\n    vector<ll> sum2(N + 1, 0);\n    for (int i = 2; i <= N; i++) {\n        sum2[i] = data[i - 1].Total - C[i - 2];\n    }\n    for (int i = 1; i <= N; i++) {\n        sum2[i] += sum2[i - 1];\n    }\n\n    Seg seg1(N + 1);\n    Seg seg2(N + 1);\n    for (int i = 0; i <= N; i++) {\n        seg1.update(i, sum1[i]);\n    }\n    for (int i = 0; i <= N; i++) {\n        seg2.update(i, sum2[i]);\n    }\n\n    // show(sum1);\n    // show(sum2);\n    // show(accum);\n    // show(data);\n    constexpr int INF = 1 << 30;\n    int minimum = INF;\n\n    for (int i = 0; i < N; i++) {\n        // show(i);\n        ll goal = L - data[i].A;\n        const int lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n        if (lower < i) {\n            // show(\"hogeohoegoeodwqd\");\n            // show(goal);\n            // show(lower);\n            const ll mini = seg1.query(1, lower);\n            if (mini <= 0) {\n                continue;\n            } else {\n                minimum = min(minimum, lower + 1);\n            }\n        } else {\n            //            show(\"feffwuefwiuefwuef\");\n            if (lower >= N) {\n                continue;\n            }\n            goal = L - data[i].B;\n            //            show(goal);\n            const int lower = lower_bound(accum.begin(), accum.end(), goal) - accum.begin();\n            if (lower >= N) {\n                continue;\n            }\n            //            show(lower);\n            if (i == 0) {\n                // show(\"i=0\");\n                const ll mini = seg2.query(2, lower + 1);\n                // show(mini);\n                if (mini <= 0) {\n                    continue;\n                } else {\n                    minimum = min(minimum, lower);\n                }\n            } else {\n                // show(\"i!=0\");\n                const ll mini1 = seg1.query(1, i);\n                // show(mini1);\n                if (mini1 <= 0) {\n                    continue;\n                }\n                if (i == N - 1) {\n                    minimum = min(minimum, lower + 1);\n                } else {\n                    const ll mini2 = seg2.query(i + 2, lower + 1) - sum2[i + 1];\n                    // show(mini2);\n                    if (sum1[i] + mini2 <= 0) {\n                        continue;\n                    }\n                    minimum = min(minimum, lower + 1);\n                }\n            }\n        }\n    }\n    cout << ((minimum == INF) ? -1 : minimum) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM -2000000000\n#define SIZE 100000\n\nstruct Info{\n\tInfo(ll arg_A,ll arg_B){\n\t\tA = arg_A;\n\t\tB = arg_B;\n\t}\n\tbool operator<(const struct Info& arg) const{ //A-Bの降順\n\t\treturn A-B > arg.A-arg.B;\n\t}\n\tll A,B;\n};\n\nint N;\nll* table;\nll enemy[SIZE],self[SIZE],max_A[SIZE];\nvector<Info> info;\n\n//簡易化のため、要素数を2のべき乗にする関数\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int loc,ll value){\n\tloc += N-1;\n\n\ttable[loc] = value;\n\n\tif(N == 1)return;\n\n\tint parent = (loc-1)/2;\n\n\twhile(true){\n\t\ttable[parent] = max(table[2*parent+1],table[2*parent+2]); //親は左右の子の大きい方の値を持つ\n\n\t\tif(parent == 0)break;\n\t\telse{\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\n\n//任意の区間の最大値を求める関数\nll query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t//今回のノードが検索区間をカバーしていなければ、結果に関係ない値を返す\n\tif(search_right < node_left || search_left > node_right)return NUM;\n\n\t//今回のノードの区間が、検索区間の部分区間である場合、今回のノードの値を返す\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn table[node_id];\n\t}\n\n\t//今回のノードの区間に、一部検索区間と重なっている区間がある場合→再帰的に子どもに尋ねる\n\tll left_max= query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tll right_max = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn max(left_max,right_max);\n}\n\nint main(){\n\n\tint first_N;\n\tll L;\n\n\tscanf(\"%d %lld\",&first_N,&L);\n\n\tll A,B;\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld %lld\",&A,&B);\n\t\tinfo.push_back(Info(A,B));\n\t}\n\n\t//敵の高さを計算\n\tfor(int i = 0; i < first_N; i++){\n\t\tscanf(\"%lld\",&enemy[i]);\n\t\tif(i != 0){\n\t\t\tenemy[i] += enemy[i-1]; //累積和を計算\n\t\t}\n\t}\n\n\tsort(info.begin(),info.end());\n\n\t//自分の高さを計算\n\tfor(int i = 0; i < first_N; i++){\n\t\tself[i] = info[i].A-info[i].B;\n\t\tif(i != 0){\n\t\t\tself[i] += self[i-1];\n\t\t}\n\t}\n\t//ある日を含め、ある日より右にある、最大のAを求める\n\tmax_A[first_N-1] = info[first_N-1].A;\n\tfor(int i = first_N-2; i >= 0; i--){\n\t\tmax_A[i] = max(max_A[i+1],info[i].A);\n\t}\n\n\t//Bをセグメント木に登録する\n\tN = 1;\n\tinit(first_N);\n\n\ttable = new ll[2*N-1];\n\n\t//0～N-2が上位構造のアドレス、N-1～2*N-2が最小要素のアドレス\n\tfor(int i = 0; i <= 2*N-2; i++)table[i] = NUM;  //まずは範囲外値で初期化\n\t//Bを登録\n\tfor(int i = 0; i < first_N; i++){\n\t\tupdate(i,info[i].B);\n\t}\n\n\tint ans = BIG_NUM;\n\n\tll tmp_H;\n\t/*★A-Bの降順に値を採用、脱出日は最大のAを使用する場合★*/\n\n\t//初日で脱出可\n\tif(max_A[0] >= L){\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(int i = 1; i < first_N; i++){\n\n\t\tif(self[i-1] <= enemy[i-1]){ //敵に追いつかれたので終了\n\t\t\tbreak;\n\t\t}\n\t\ttmp_H = self[i-1]+max_A[i];\n\n\t\tif(tmp_H >= L){\n\t\t\tans = i+1; //解答は1オリジンのため\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbool FLG;\n\n\t/*★脱出日までの、どこか一日を、最終日に持ってくる場合★*/\n\tint left = 0,right,m;\n\tint min_index;\n\tll max_B;\n\n\tfor(int i = 1; i < first_N; i++){\n\n\t\tif(self[i-1] <= enemy[i-1]){ //敵に追いつかれたので終了\n\t\t\tbreak;\n\t\t}\n\t\t//0～i日目の間で、i日目に順番を回しても、敵に追いつかれないドリンクの範囲を二分探索で求める\n\t\tright = first_N-1,m = (left+right)/2; //★始点は随時右にずれていくので、初期化せずに値を引き継ぐ\n\n\t\tmin_index = BIG_NUM;\n\n\t\twhile(left <= right){\n\n\t\t\tFLG = true;\n\t\t\t//ドリンクmを飲むのをi日目にすることで、敵に追いつかれるか調べる\n\t\t\tfor(int k = m+1; k <= i; k++){\n\t\t\t\tif(self[k]-enemy[k-1] <= info[m].A-info[m].B){ //自分が抜けた翌日以降の敵との差が、自分の加算分以下ならout(追いつかれる)\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\n\t\t\t\tmin_index = m;\n\t\t\t\tright = m-1;\n\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tif(min_index == BIG_NUM)continue;\n\n\t\tmax_B = query(min_index,i,0,0,N-1); //★i日に回しても良いドリンクの中での、Bの最大値を取得★\n\n\t\ttmp_H = self[i]+max_B; //★★加算していたマイナスが消える分(マイナスのマイナス)、プラスになる\n\n\t\tif(tmp_H >= L){\n\t\t\tans = min(ans,i+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(ans == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2e5+5;\ntypedef long long ll;\n\nint n;\nll L,c[N],slen[N],dis[N];\npair<ll,ll>a[N];\n\nint cmp(pair<ll,ll> x,pair<ll,ll> y)\n{\n    return x.first-x.second>y.first-y.second;\n}\n\nstruct rmq\n{\n    ll mn[N][20],mx[N][20];\n    void init(ll *a)\n    {\n        for(int i=1;i<=n;i++) mn[i][0]=mx[i][0]=a[i];\n        int t=log(n)/log(2);\n        for(int j=1;j<=t;j++)\n            for(int i=1;i<=n-(1<<j)+1;i++)\n            {\n                mn[i][j]=min(mn[i][j-1],mn[i+(1<<(j-1))+1][j-1]);\n                mx[i][j]=max(mx[i][j-1],mx[i+(1<<(j-1))+1][j-1]);\n            }\n    }\n    ll get_mn(int l,int r)\n    {\n        int t=log(r-l+1)/log(2);\n        return min(mn[l][t],mn[r-(1<<t)+1][t]);\n    }\n    ll get_mx(int l,int r)\n    {\n        int t=log(r-l+1)/log(2);\n        return max(mx[l][t],mx[r-(1<<t)+1][t]);\n    }\n}rmqlen,rmqdis;\n\nint main()\n{\n    //freopen(\"F.in\",\"r\",stdin);\n    scanf(\"%d %d\",&n,&L);\n    for(int i=1;i<=n;i++)\n        scanf(\"%lld %lld\",&a[i].first,&a[i].second);\n    sort(a+1,a+1+n,cmp);\n    c[0]=0;\n    for(int i=1;i<=n;i++)\n        scanf(\"%lld\",&c[i]);\n    slen[0]=dis[0]=0;\n    for(int i=1;i<=n;i++) slen[i]=slen[i-1]+a[i].first-a[i].second;\n    for(int i=1;i<=n;i++) dis[i]=dis[i-1]+a[i].first-a[i].second-c[i-1];\n    rmqlen.init(slen);\n    rmqdis.init(dis);\n    ll sum=0,len=0;\n    int fin=0,ans=n+1;\n    for(int i=1;i<=n;i++)\n    {\n        if(i>1&&rmqlen.get_mx(1,i-1)+a[i].first>=L)\n        {\n            int l=0,r=i-1;\n            while(l+1<r)\n            {\n                int mid=l+r>>1;\n                if(rmqlen.get_mx(1,mid)+a[i].first>=L) r=mid;\n                else l=mid;\n            }\n            if(fin==0||fin>=r) ans=min(ans,r+1);\n            continue;\n        }\n        if(fin) continue;\n        if(i<n&&rmqlen.get_mx(i+1,n)+a[i].second>=L)\n        {\n            int l=i,r=n;\n            while(l+1<r)\n            {\n                int mid=l+r>>1;\n                if(rmqlen.get_mx(i+1,mid)+a[i].second>=L) r=mid;\n                else l=mid;\n            }\n            if(rmqdis.get_mn(i+1,r)-dis[i]+sum>0) ans=min(ans,r);\n        }\n        if(sum+a[i].first-a[i].second-c[i]<=0)\n        {\n            fin=i-1;\n            continue;\n        }\n        sum+=a[i].first-a[i].second-c[i];\n        len+=a[i].first-a[i].second;\n    }\n    if(ans==n+1) ans=-1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :obj(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= n) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT b0, b1;\n\trangeadd(int n) :b0(n), b1(n);\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n)if (a[i].first >= 0)max = i + 1;\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second < l) {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && b[p] + a[i].first + a[i].second >= l)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++);\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//????¬????BIT????????????????????????????????°??????????????????\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i] += x;\n\t\t\ti += i&-i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i) {\n\t\t\ts += bit[i];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\trangeadd(int n) :b0(n), b1(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, l;\n\tcin >> n >> l;\n\tvpii a(n);\n\tvi c(n);\n\trep(i, n)cin >> a[i].first >> a[i].second;\n\trep(i, n)cin >> c[i];\n\trep(i, n)a[i].first -= a[i].second;\n\tsort(ALL(a), greater<>());\n\tvi b(n+1);\n\tint max = 0;\n\trep(i, n)b[i] = a[i].first;\n\trep1(i, n - 1)b[i] += b[i - 1];\n\trep1(i, n - 1)c[i] += c[i - 1];\n\tsegtree<int> st1(n, 1e9, [](auto a, auto b) {return min(a, b); }), st2 = st1;\n\trep(i, n)st1[i] = b[i] - c[i];\n\trep(i, n - 1)st2[i] = b[i + 1] - c[i];\n\tst1.updateall();\n\tst2.updateall();\n\trep(i, n) {\n\t\tif (a[i].first > 0)max = i + 1;\n\t\telse break;\n\t}\n\tint res = 1e9;\n\trep(i, n) {\n\t\tif (a[i].first + a[i].second >= l)res = 1;\n\t\telse if (i < max&&b[i] + a[i].second <= l) {\n\t\t\tint p = lower_bound(b.begin() + i, b.begin() + max, l - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, i) > 0 && st2.query(i, p) - a[i].first>0 && p != max)cmin(res, p + 1);\n\t\t}\n\t\telse {\n\t\t\tint p = lower_bound(b.begin(), b.begin() + max, l - a[i].first - a[i].second) - b.begin();\n\t\t\tif (st1.query(0, p) > 0 && p != max)cmin(res, p + 2);\n\t\t}\n\t}\n\tif (res == 1e9)cout << -1 << endl;\n\telse cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(cur<tmp){\n      z=i;\n      break;\n    }\n  }\n  for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    if(z<=rev[i]){\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      //cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      //cout<<i<<\":\"<<x<<\" \"<<pos<<\" \"<<endl;\n      ans=min(ans,pos+2);\n    }else{\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<y) continue;\n      //cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      //cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n,lim=n;\n  bool dbg=0;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(cur<=tmp) lim=min(lim,i);\n    if(dbg) cout<<i<<\" \"<<cur<<\" \"<<tmp<<endl;\n  }\n  if(dbg) for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  if(dbg) for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    {\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(pos>=lim) continue;\n      if(dbg) cout<<i<<\";\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\";\"<<x<<\" \"<<pos<<\" \"<<endl;\n      if(rev[i]<=pos) continue;\n      ans=min(ans,pos+2);\n    }\n  }\n  for(int i=0;i<n;i++){\n    {\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      //cout<<pos<<endl;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<=y) continue;\n      if(dbg) cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<\" \"<<rev[i]<<endl;\n      if(dbg) cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      if(pos<=rev[i]) continue;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lson l, m, rt << 1\n#define rson m + 1, r, rt << 1 | 1\nusing namespace std;\ntypedef long long ll;\nconst ll inf = 1e15;\nconst int N = 111111 << 2;\nstruct pt{\n\tll x, y;\n\tpt(){}\n\tfriend bool operator < (pt a, pt b) {return a.x - a.y > b.x - b.y;}\n};\n\nll mn[N], tag[N];\nll c[N], L, b[N];\nint tot;\nvoid pd(int rt) {\n\tif (tag[rt]) {\n\t\tmn[rt << 1] += tag[rt];\n\t\tmn[rt << 1 | 1] += tag[rt];\n\t\ttag[rt << 1] += tag[rt];\n\t\ttag[rt << 1 | 1] += tag[rt];\n\t\ttag[rt] = 0;\n\t}\t\n}\nvoid up(int rt) {\n\tmn[rt] = min(mn[rt << 1], mn[rt << 1 | 1]);\n}\nvoid build(int l, int r, int rt) {\n\tif (l == r) {\n\t\tmn[rt] = c[l];\n\t\treturn;\n\t}\n\tint m = l + r >> 1;\n\tbuild(lson);\n\tbuild(rson);\n\tup(rt);\n}\n\nvoid add(int L, int R, ll x, int l, int r, int rt) {\t\n\tif (L <= l && r <= R) {\n\t\tmn[rt] += x;\n\t\ttag[rt] += x;\n\t\treturn;\n\t}\n\tpd(rt);\n\tint m = l + r >> 1;\n\tif (L <= m) add(L, R, x, lson);\n\tif (R > m) add(L, R, x, rson);\n\tup(rt);\n}\n\nll ask(int L, int R, int l, int r, int rt) {\n\tif (L <= l && r <= R) return mn[rt];\n\tpd(rt);\n\tint m = l + r >> 1;\n\tll ans = inf;\n\tif (L <= m) ans = min(ans, ask(L, R, lson));\n\tif (R > m) ans = min(ans, ask(L, R, rson));\n\treturn ans;\n}\n\nint n;\npt a[N];\nint ans = 1e8;\nvoid doit(int i) {\n\t//if (b[n] < L - a[i].x) return;\n\tint ps = lower_bound(b + 1, b + n + 1, L - a[i].x) - b;\n\tif (ps >= i) {\n\t//if (b[n] < L - a[i].y) return;\n\t\tps = lower_bound(b + 1, b + n + 1, L - a[i].y) - b - 1;\n\t}\n\t//if (ps > tot) return;\n\t//cout << ask(1, 4, 1, tot, 1) << endl;\n\t//cout << i << \"  \" << ps << endl;\n\tif (ask(1, ps, 1, tot, 1) > 0) ans = min(ans, ps);\n}\nll ct[N];\nint main() {\n\tscanf(\"%d%lld\", &n, &L);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%lld%lld\", &a[i].x, &a[i].y);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%lld\", &ct[i]);\n\tsort(a + 1, a + n + 1);\n\t\n\ttot = n - 1;\n\tfor (int i = 1; i <= n; ++i) b[i] = a[i].x - a[i].y;\n\t\n\t/*for (int i = 1; i <= n; ++i) {\n\t\tcout << a[i].x << \" \" << a[i].y << endl;\n\t}*/\n\t\n\tfor (int i = 1; i <= tot; ++i) c[i] = c[i - 1] + b[i + 1] - ct[i];\n\t/*\n\tfor (int i = 1; i <= tot; ++i) {\n\t\tcout << c[i] << endl;\n\t}*/\n\t\n\tbuild(1, tot, 1);\n\t\n\tfor (int i = 1; i <= n; ++i) b[i] += b[i - 1];\n\t\n/*\tfor (int i = 1; i <= n; ++i) {\n\t\tcout << b[i] << endl;\n\t}*/\n\t\n\tdoit(1);\n\tfor (int i = 2; i <= n; ++i) {\n\t\tadd(i - 1, tot, -(a[i].x - a[i].y), 1, tot, 1);\n\t\tadd(i - 1, tot, a[i - 1].x - a[i - 1].y, 1, tot, 1);\n\t\tdoit(i);\n\t}\n\t\n\tif (ans == 1e8 || ans == n) puts(\"-1\");\n\telse printf(\"%d\\n\", ans + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct RMQ{\n  int n;\n  vector<int> dat;\n  const int def=INT_MAX;\n  RMQ(){}\n  RMQ(int n_){init(n_);}\n  RMQ(int n_,int *a){init(n_);construct(n_,a);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,def);\n  }\n  void construct(int n_,int *a){\n    for(int i=0;i<n_;i++) dat[n-1+i]=a[i];\n    for(int i=n-2;i>=0;i--) \n      dat[i]=min(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,int a){\n    k+=n-1;\n    dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n#define MAX 114514\nint n,l;\nint a[MAX],b[MAX],c[MAX],d[MAX];\nint sum[MAX],rev[MAX];\ntypedef pair<int,int> P;\nvector<P> v;\nsigned main(){\n  cin>>n>>l;\n  for(int i=0;i<n;i++) cin>>a[i]>>b[i];\n  for(int i=0;i<n;i++) cin>>c[i];\n  for(int i=0;i<n;i++){\n    if(a[i]>=l){\n      cout<<1<<endl;\n      return 0;\n    }\n  }\n  for(int i=0;i<n;i++)\n    v.push_back(P(a[i]-b[i],i));\n  sort(v.begin(),v.end(),greater<P>());\n  for(int i=0;i<n;i++)\n    rev[v[i].second]=i;\n  int ans=n+1;\n  memset(sum,0,sizeof(sum));\n  int cur=0,tmp=0,z=n;\n  for(int i=0;i<n;i++){\n    if(v[i].first<0){\n      z=i;\n      break;\n    }\n    cur+=v[i].first;\n    if(i) d[i-1]=cur-tmp;\n    tmp+=c[i];\n    sum[i]=cur;\n    if(cur<tmp){\n      z=i;\n      break;\n    }\n  }\n  //for(int i=0;i<z-1;i++) cout<<i<<\" \"<<d[i]<<endl;\n  //for(int i=0;i<z;i++) cout<<i<<\":\"<<sum[i]<<endl;\n  //cout<<ans<<endl;\n  RMQ rmq(z-1,d);\n  for(int i=0;i<n;i++){\n    if(z<=rev[i]){\n      int x=l-a[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      //cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      //cout<<i<<\":\"<<x<<\" \"<<pos<<\" \"<<endl;\n      ans=min(ans,pos+2);\n    }else{\n      int x=l-b[i],y=a[i]-b[i];\n      int pos=lower_bound(sum,sum+z,x)-sum;\n      if(pos==z) continue;\n      if(rmq.query(rev[i],pos)<y) continue;\n      //cout<<i<<\":\"<<a[i]<<\" \"<<b[i]<<endl;\n      //cout<<i<<\":\"<<x<<\" \"<<y<<\" \"<<pos<<\" \"<<rmq.query(rev[i],pos)<<endl;\n      ans=min(ans,pos+1);\n    }\n  }\n  if(ans>n) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector <int>    VI;\ntypedef pair <int,int>  PII;\n#define FOR(i,x,y)  for(int i = (int)(x);i < (int)(y);++ i)\n#define IFOR(i,x,y) for(int i = (int)(x);i > (int)(y);-- i)\n#define pb  push_back\n#define mp  make_pair\n#define fi  first\n#define se  second\n#define fi  first\n#define se  second\n\nconst int maxn = 100010;\n\nint n, li[maxn];\nLL L, sum[maxn], c[maxn];\n\nstruct Num{\n    LL a, b;\n    bool operator < (const Num& rhs) const{\n        return a-b > rhs.a-rhs.b;\n    }\n}s[maxn];\n\nvoid Init() {\n    LL ca = 0;\n    int idx = 1;\n    FOR(i, 2, n+1) {\n        ca = ca+s[i].a-s[i].b-c[idx];\n        if(ca <= 0) break;\n        ++ idx;\n    }\n    li[1] = idx;\n    FOR(i, 2, n+1) {\n        if(i-1 > idx) {li[i] = idx; continue;}\n        if(idx == n) {li[i] = n; continue;}\n        ca += s[i-1].a-s[i-1].b+s[i].b-s[i].a;\n        while(ca > 0 && idx < n) {\n            ++ idx;\n            ca += s[idx+1].a-s[idx+1].b-c[idx];\n        }\n        li[i] = idx;\n    }\n}\n\nint ff = n+1;\n\nbool judge(int x) {\n    -- x;\n    FOR(i, 1, n+1) {\n        LL lim = L-s[i].a;\n        if(li[i] <= x) continue;\n        if(i > x && sum[x] >= lim)  return true;    \n        if(i <= x && sum[x+1]-s[i].a+s[i].b >= lim) return true;\n    }\n    return false;\n}\n\nint main() {\n    while(~scanf(\"%d%lld\", &n, &L)) {\n        LL mx = -1;\n        FOR(i, 1, n+1) \n            scanf(\"%lld%lld\", &s[i].a, &s[i].b), \n            mx = max(mx, s[i].a);\n        s[n+1].a = s[n+1].b = 0;\n        FOR(i, 1 ,n+1) scanf(\"%lld\", c+i);\n        if(mx >= L) {printf(\"1\\n\"); continue;}\n        sort(s+1, s+n+1);\n        ff = n;\n        FOR(i, 1, n+1) if(s[i].a <= s[i].b) {ff = i; break;}\n        sum[0] = 0;\n        FOR(i, 1, n+1) sum[i] = sum[i-1]+s[i].a-s[i].b;\n        Init();\n        int l = 1, r = ff;\n        //cout << l << \" \" << r << endl;\n        if(l > r) {printf(\"-1\\n\"); continue;}\n        while(l < r) {\n            int mid = (l+r) >> 1;\n            if(judge(mid))  r = mid;\n            else    l = mid+1;\n        }\n        if(judge(l))    printf(\"%d\\n\", l);\n        else    printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 1e5 + 5, INF = 0x3f3f3f3f;\n\nstruct P\n{\n\tll dif; int id;\n\tP(ll dif = 0, int id = -1) :dif(dif), id(id) {}\n\tP operator + (const P &a) const\n\t{\n\t\treturn P(dif + a.dif, id);\n\t}\n};\n\nbool cmp(P a,P b){\n    return a.dif>b.dif;\n}\n\nP p[N];\nint n, pos, ans, loc[N];\nll d1, d2, L, a[N], b[N], c[N], d[N];\nbool f, vis[N];\n\nll ok(int mid, int i)\n{\n\tif (i <= mid) return p[mid].dif - a[p[i].id] + b[p[i].id];\n\treturn p[mid].dif;\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%lld\", &n, &L))\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\t\tp[i] = P(a[i] - b[i], i);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &c[i]);\n\t\t\tif (i) c[i] += c[i - 1];\n\t\t}\n\t\tsort(p, p + n,cmp);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tloc[p[i].id] = i;\n        int fu = n;\n        for(int i = 0;i < n;i++){\n            if(p[i].dif<=0){\n                fu = i;\n                break;\n            }\n        }\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tp[i] = p[i] + p[i - 1];\n\t\tans = INF;\n\t\tint first = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tll len = L - a[i];\n\t\t\tint l = -1, r = fu-1;\n\n//\t\t\tif(len==10&&first){\n//                cout<<1<<endl;\n//\t\t\t}\n//\t\t\telse if(len==10&&!first){\n//                first = 1;\n//\t\t\t}\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tint mid = (l + r)/2;\n\t\t\t\tif (ok(mid, loc[i]) < len) l = mid;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\tint now = r - (r >= loc[i]);\n\t\t\tif (ok(r, loc[i])>=len&&ok(r, loc[i]) > c[now]) ans = min(ans, now + 2);\n\t\t}\n\t\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 1e5 + 5, INF = 0x3f3f3f3f;\n\nstruct P\n{\n\tll dif; int id;\n\tP(ll dif = 0, int id = -1) :dif(dif), id(id) {}\n\tP operator + (const P &a) const\n\t{\n\t\treturn P(dif + a.dif, id);\n\t}\n};\n\nbool cmp(P a,P b){\n    return a.dif>b.dif;\n}\n\nP p[N];\nint n, pos, ans, loc[N];\nll d1, d2, L, a[N], b[N], c[N], d[N];\nbool f, vis[N];\n\nll ok(int mid, int i)\n{\n\tif (i <= mid) return p[mid].dif - a[p[i].id] + b[p[i].id];\n\treturn p[mid].dif;\n}\n\nint main()\n{\n\twhile (~scanf(\"%d%lld\", &n, &L))\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\t\tp[i] = P(a[i] - b[i], i);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &c[i]);\n\t\t\tif (i) c[i] += c[i - 1];\n\t\t}\n\t\tsort(p, p + n,cmp);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tloc[p[i].id] = i;\n        int fu = n;\n        for(int i = 0;i < n;i++){\n            if(p[i].dif<=0){\n                fu = i;\n                break;\n            }\n        }\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tp[i] = p[i] + p[i - 1];\n\t\tans = INF;\n\t\tint first = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tll len = L - a[i];\n\t\t\tint l = -1, r = fu-1;\n\n//\t\t\tif(len==10&&first){\n//                cout<<1<<endl;\n//\t\t\t}\n//\t\t\telse if(len==10&&!first){\n//                first = 1;\n//\t\t\t}\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tint mid = (l + r)/2;\n\t\t\t\tif (ok(mid, loc[i]) < len) l = mid;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\tint now = r - (r >= loc[i]);\n\t\t\tif (ok(r, loc[i])>=len&&ok(r, loc[i]) > c[now]) ans = min(ans, now + 2);\n\t\t}\n\t\tprintf(\"%d\\n\", ans == INF ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, L = map(int, readline().split())\n    P = [list(map(int, readline().split())) for i in range(N)]\n    C = [int(readline()) for i in range(N)]\n\n    P.sort(key = lambda x: (x[0] - x[1]), reverse=1)\n\n    INF = 10**18\n\n    S = [0]*(N+1)\n    s = 0\n    for i in range(N):\n        a, b = P[i]\n        S[i+1] = s = s + (a - b)\n\n    min1 = [INF]*(N+1)\n    S0 = [0]*(N+1)\n    s = 0; cur = INF\n    for i in range(N):\n        a, b = P[i]\n        s += (a - b) - C[i]\n        S0[i+1] = s\n        min1[i+1] = cur = min(cur, s)\n\n    N0 = 2**N.bit_length()\n    data = [INF]*(N0*2)\n    s = 0\n    S1 = [0]*(N+1)\n    for i in range(1, N):\n        a, b = P[i]\n        s += (a - b) - C[i-1]\n        S1[i+1] = data[N0+i] = s\n    for i in range(N0-2, -1, -1):\n        data[i] = min(data[2*i+1], data[2*i+2])\n\n    def query(l, r):\n        L = l + N0; R = r + N0\n        s = INF\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = min(s, data[R-1])\n\n            if L & 1:\n                s = min(s, data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\n    if max(a for a, b in P) >= L:\n        write(\"1\\n\")\n        return\n\n    ans = N+1\n    k = N\n\n    m = 0\n    for i in range(N-1, -1, -1):\n        a, b = P[i]\n        m = max(m, a)\n        if S[i] + m >= L and min1[i] > 0:\n            ans = i+1\n            k = i+1\n\n    for i in range(k):\n        a, b = P[i]\n        left = 0; right = N+1\n        while left+1 < right:\n            mid = (left + right) >> 1\n            if (S[mid] if mid < i+1 else S[mid]-(a-b)) < L-a:\n                left = mid\n            else:\n                right = mid\n        r = left\n        if r == N:\n            continue\n        if r < i:\n            if min1[r+1] > 0:\n                ans = min(ans, r+2)\n        else:\n            if min1[i] > 0 and query(i+2, r+2) - S1[i+1] + S0[i] > 0:\n                ans = min(ans, r+1)\n\n    if ans == N+1:\n        write(\"-1\\n\")\n    else:\n        write(\"%d\\n\" % ans)\nsolve()\n"
  }
]