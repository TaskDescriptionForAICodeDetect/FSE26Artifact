[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n\nint H, W, K;\nchar grid[MAX_H][MAX_W];\nint visited[MAX_H][MAX_W];\n\ntypedef struct {\n    int x, y, strokes;\n} State;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint bfs(int x1, int y1, int x2, int y2) {\n    memset(visited, -1, sizeof(visited));\n    \n    State queue[MAX_H * MAX_W];\n    int front = 0, rear = 0;\n    \n    queue[rear++] = (State){x1, y1, 0};\n    visited[x1][y1] = 0;\n    \n    while (front < rear) {\n        State current = queue[front++];\n        \n        if (current.x == x2 && current.y == y2) {\n            return current.strokes;\n        }\n        \n        for (int dir = 0; dir < 4; dir++) {\n            for (int step = 1; step <= K; step++) {\n                int nx = current.x + dx[dir] * step;\n                int ny = current.y + dy[dir] * step;\n                \n                if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == '@') {\n                    break;\n                }\n                \n                if (visited[nx][ny] == -1 || visited[nx][ny] > current.strokes + 1) {\n                    visited[nx][ny] = current.strokes + 1;\n                    queue[rear++] = (State){nx, ny, current.strokes + 1};\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    \n    x1--; y1--; x2--; y2--;\n    \n    int result = bfs(x1, y1, x2, y2);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n#define MAX_K 1000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nPoint queue[MAX_H * MAX_W * 4];\nint front, rear;\nint dist[MAX_H][MAX_W];\nchar grid[MAX_H][MAX_W + 1];\nint H, W, K;\nint x1, y1, x2, y2;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvoid init() {\n    front = rear = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n}\n\nvoid enqueue(int x, int y) {\n    queue[rear].x = x;\n    queue[rear].y = y;\n    rear++;\n}\n\nPoint dequeue() {\n    Point p = queue[front];\n    front++;\n    return p;\n}\n\nint is_empty() {\n    return front == rear;\n}\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint bfs() {\n    init();\n    dist[x1][y1] = 0;\n    enqueue(x1, y1);\n\n    while (!is_empty()) {\n        Point current = dequeue();\n        int cx = current.x;\n        int cy = current.y;\n        if (cx == x2 && cy == y2) {\n            return dist[cx][cy];\n        }\n\n        for (int dir = 0; dir < 4; dir++) {\n            for (int k = 1; k <= K; k++) {\n                int nx = cx + dx[dir] * k;\n                int ny = cy + dy[dir] * k;\n                if (!is_valid(nx, ny) || grid[nx][ny] == '@') {\n                    break;\n                }\n                if (dist[nx][ny] < dist[cx][cy] + 1) {\n                    break;\n                }\n                if (dist[nx][ny] > dist[cx][cy] + 1) {\n                    dist[nx][ny] = dist[cx][cy] + 1;\n                    enqueue(nx, ny);\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &H, &W, &K);\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    x1--; y1--; x2--; y2--;\n\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    printf(\"%d\\n\", bfs());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:29:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint main() {\n    int H, W, K;\n    cin >> H >> W >> K;\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1--; y1--; x2--; y2--;\n\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n    queue<pair<int, int>> q;\n    dist[x1][y1] = 0;\n    q.push({x1, y1});\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n\n        if (x == x2 && y == y2) {\n            cout << dist[x][y] << endl;\n            return 0;\n        }\n\n        for (int dir = 0; dir < 4; ++dir) {\n            for (int step = 1; step <= K; ++step) {\n                int nx = x + dx[dir] * step;\n                int ny = y + dy[dir] * step;\n\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W) break;\n                if (grid[nx][ny] == '@') break;\n                if (dist[nx][ny] < dist[x][y] + 1) break;\n\n                if (dist[nx][ny] > dist[x][y] + 1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:30:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int H, W, K;\n    static int x1, y1, x2, y2;\n    static char[][] grid;\n    static int[][] dist;\n    static int[] dx = {1, 0, -1, 0};\n    static int[] dy = {0, 1, 0, -1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        K = sc.nextInt();\n        x1 = sc.nextInt() - 1;\n        y1 = sc.nextInt() - 1;\n        x2 = sc.nextInt() - 1;\n        y2 = sc.nextInt() - 1;\n        grid = new char[H][W];\n        dist = new int[H][W];\n        \n        for (int i = 0; i < H; i++) {\n            grid[i] = sc.next().toCharArray();\n            Arrays.fill(dist[i], -1);\n        }\n        \n        Deque<int[]> q = new ArrayDeque<>();\n        q.offer(new int[]{x1, y1});\n        dist[x1][y1] = 0;\n        \n        while (!q.isEmpty()) {\n            int[] curr = q.poll();\n            int x = curr[0];\n            int y = curr[1];\n            \n            if (x == x2 && y == y2) {\n                System.out.println(dist[x][y]);\n                return;\n            }\n            \n            for (int dir = 0; dir < 4; dir++) {\n                for (int k = 1; k <= K; k++) {\n                    int nx = x + dx[dir] * k;\n                    int ny = y + dy[dir] * k;\n                    \n                    if (nx < 0 || nx >= H || ny < 0 || ny >= W) break;\n                    if (grid[nx][ny] == '@') break;\n                    if (dist[nx][ny] != -1 && dist[nx][ny] <= dist[x][y]) break;\n                    \n                    if (dist[nx][ny] == -1) {\n                        dist[nx][ny] = dist[x][y] + 1;\n                        q.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n        \n        System.out.println(-1);\n    }\n}",
    "timestamp": "2025-08-05 22:30:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WaterStriderPath {\n    public static int findMinStrokes(char[][] grid, int x1, int y1, int x2, int y2, int K) {\n        int H = grid.length;\n        int W = grid[0].length;\n        \n        boolean[][] visited = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{x1, y1, 0});\n        visited[x1][y1] = true;\n        \n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], strokes = current[2];\n            \n            if (x == x2 && y == y2) {\n                return strokes;\n            }\n            \n            for (int[] dir : directions) {\n                for (int k = 1; k <= K; k++) {\n                    int nx = x + dir[0] * k;\n                    int ny = y + dir[1] * k;\n                    \n                    if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == '@') {\n                        break;\n                    }\n                    \n                    if (!visited[nx][ny]) {\n                        queue.offer(new int[]{nx, ny, strokes + 1});\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 22:30:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint H, W, K, x1, y1, x2, y2;\nvector<string> grid;\nvector<vector<int>> dist;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] == '.';\n}\n\nint bfs() {\n    dist = vector<vector<int>>(H, vector<int>(W, -1));\n    queue<pair<int, int>> q;\n    q.push({x1, y1});\n    dist[x1][y1] = 0;\n    \n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        \n        if (x == x2 && y == y2) return dist[x][y];\n        \n        for (int dir = 0; dir < 4; dir++) {\n            for (int step = 1; step <= K; step++) {\n                int nx = x + dx[dir] * step;\n                int ny = y + dy[dir] * step;\n                \n                if (!is_valid(nx, ny)) break;\n                \n                if (dist[nx][ny] == -1 || dist[nx][ny] > dist[x][y] + 1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    cin >> H >> W >> K;\n    grid.resize(H);\n    for (int i = 0; i < H; i++) {\n        cin >> grid[i];\n    }\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1--; y1--; x2--; y2--;\n    \n    cout << bfs() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:31:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_strokes_to_reach(H, W, K, grid, x1, y1, x2, y2):\n    # Directions: north, east, south, west\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    \n    # Initialize the distance grid with infinity\n    dist = [[float('inf')] * W for _ in range(H)]\n    dist[x1][y1] = 0\n    queue = deque([(x1, y1)])\n    \n    while queue:\n        x, y = queue.popleft()\n        current_strokes = dist[x][y]\n        \n        for dx, dy in directions:\n            for step in range(1, K + 1):\n                nx, ny = x + dx * step, y + dy * step\n                if not (0 <= nx < H and 0 <= ny < W):\n                    break\n                if grid[nx][ny] == '@':\n                    break\n                if dist[nx][ny] <= current_strokes:\n                    break\n                if dist[nx][ny] > current_strokes + 1:\n                    dist[nx][ny] = current_strokes + 1\n                    queue.append((nx, ny))\n    \n    return dist[x2][y2] if dist[x2][y2] != float('inf') else -1\n\n# Example usage\n# H, W, K = 3, 3, 2\n# grid = [\"...\", \".@.\", \"...\"]\n# x1, y1, x2, y2 = 0, 0, 2, 2\n# print(min_strokes_to_reach(H, W, K, grid, x1, y1, x2, y2))",
    "timestamp": "2025-08-13 11:01:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WaterStrider {\n    private static class Point {\n        int x, y, strokes;\n        Point(int x, int y, int strokes) {\n            this.x = x;\n            this.y = y;\n            this.strokes = strokes;\n        }\n    }\n\n    private static final int[] DX = {-1, 0, 1, 0};\n    private static final int[] DY = {0, 1, 0, -1};\n\n    public static int minStrokes(char[][] grid, int H, int W, int K, int x1, int y1, int x2, int y2) {\n        if (grid[x1][y1] == '@' || grid[x2][y2] == '@') return -1;\n\n        Queue<Point> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[H][W];\n        queue.add(new Point(x1, y1, 0));\n        visited[x1][y1] = true;\n\n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n            if (current.x == x2 && current.y == y2) return current.strokes;\n            \n            for (int d = 0; d < 4; d++) {\n                for (int step = 1; step <= K; step++) {\n                    int nx = current.x + step * DX[d];\n                    int ny = current.y + step * DY[d];\n                    \n                    if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == '@' || visited[nx][ny]) break;\n                    \n                    queue.add(new Point(nx, ny, current.strokes + 1));\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        \n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int K = sc.nextInt();\n        char[][] grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            grid[i] = sc.next().toCharArray();\n        }\n        int x1 = sc.nextInt();\n        int y1 = sc.nextInt();\n        int x2 = sc.nextInt();\n        int y2 = sc.nextInt();\n        \n        System.out.println(minStrokes(grid, H, W, K, x1, y1, x2, y2));\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 11:01:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y;\n    int strokes;\n} Node;\n\n// Directions: north, east, south, west\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool isValid(int x, int y, int H, int W, char **grid) {\n    return (x >= 0 && x < H && y >= 0 && y < W && grid[x][y] == '.');\n}\n\nint minStrokes(int H, int W, int K, char **grid, int x1, int y1, int x2, int y2) {\n    if (grid[x1][y1] == '@' || grid[x2][y2] == '@') return -1;\n\n    int **dist = (int **)malloc(H * sizeof(int *));\n    for (int i = 0; i < H; ++i) {\n        dist[i] = (int *)malloc(W * sizeof(int));\n        for (int j = 0; j < W; ++j) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n\n    dist[x1][y1] = 0;\n    Node *queue = (Node *)malloc(H * W * sizeof(Node));\n    int front = 0, back = 0;\n\n    queue[back++] = (Node){x1, y1, 0};\n\n    while (front < back) {\n        Node current = queue[front++];\n        int x = current.x, y = current.y, strokes = current.strokes;\n\n        if (x == x2 && y == y2) {\n            for (int i = 0; i < H; ++i) free(dist[i]);\n            free(dist);\n            free(queue);\n            return strokes;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            for (int k = 1; k <= K; ++k) {\n                int nx = x + k * dx[d];\n                int ny = y + k * dy[d];\n\n                if (!isValid(nx, ny, H, W, grid)) break;\n\n                if (dist[nx][ny] > strokes + 1) {\n                    dist[nx][ny] = strokes + 1;\n                    queue[back++] = (Node){nx, ny, strokes + 1};\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < H; ++i) free(dist[i]);\n    free(dist);\n    free(queue);\n    return -1;\n}\n\nint main() {\n    int H, W, K, x1, y1, x2, y2;\n    scanf(\"%d %d %d\", &H, &W, &K);\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    x1--; y1--; x2--; y2--;\n    char **grid = (char **)malloc(H * sizeof(char *));\n    for (int i = 0; i < H; ++i) {\n        grid[i] = (char *)malloc(W + 1);\n        scanf(\"%s\", grid[i]);\n    }\n\n    int result = minStrokes(H, W, K, grid, x1, y1, x2, y2);\n    printf(\"%d\\n\", result);\n\n    for (int i = 0; i < H; ++i) free(grid[i]);\n    free(grid);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:01:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minStrokes(H, W, K, grid, x1, y1, x2, y2) {\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const isValid = (x, y) => x >= 0 && x < H && y >= 0 && y < W && grid[x][y] !== '@';\n    \n    const visited = Array.from({ length: H }, () => Array(W).fill(Infinity));\n    const queue = [[x1, y1, 0]];\n\n    visited[x1][y1] = 0;\n\n    while (queue.length > 0) {\n        const [cx, cy, strokes] = queue.shift();\n        \n        for (const [dx, dy] of directions) {\n            for (let k = 1; k <= K; k++) {\n                const nx = cx + dx * k;\n                const ny = cy + dy * k;\n                \n                if (!isValid(nx, ny)) break;\n                if (visited[nx][ny] <= strokes + 1) continue;\n\n                visited[nx][ny] = strokes + 1;\n                queue.push([nx, ny, strokes + 1]);\n                \n                if (nx === x2 && ny === y2) {\n                    return strokes + 1;\n                }\n            }\n        }\n    }\n    \n    return visited[x2][y2] !== Infinity ? visited[x2][y2] : -1;\n}",
    "timestamp": "2025-08-13 11:01:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef min_strokes(H, W, K, grid, start, end):\n    dx = [0, 0, 1, -1]\n    dy = [1, -1, 0, 0]\n    \n    visited = [[float('inf') for _ in range(W)] for _ in range(H)]\n    visited[start[0]][start[1]] = 0\n    \n    queue = deque([(start[0], start[1], 0)])\n    \n    while queue:\n        x, y, strokes = queue.popleft()\n        \n        if (x, y) == end:\n            return strokes\n        \n        for d in range(4):\n            for step in range(1, K + 1):\n                nx, ny = x + dx[d] * step, y + dy[d] * step\n                \n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != '@':\n                    if strokes + 1 < visited[nx][ny]:\n                        visited[nx][ny] = strokes + 1\n                        queue.append((nx, ny, strokes + 1))\n                else:\n                    break\n    \n    return -1",
    "timestamp": "2025-08-13 11:01:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findMinStrokes(grid, x1, y1, x2, y2, K) {\n    const H = grid.length;\n    const W = grid[0].length;\n    const visited = Array.from({ length: H }, () => Array(W).fill(false));\n    const queue = [[x1, y1, 0]];\n    visited[x1][y1] = true;\n\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    while (queue.length > 0) {\n        const [x, y, strokes] = queue.shift();\n\n        if (x === x2 && y === y2) {\n            return strokes;\n        }\n\n        for (const [dx, dy] of directions) {\n            for (let step = 1; step <= K; step++) {\n                const nx = x + dx * step;\n                const ny = y + dy * step;\n\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] === '@') {\n                    break;\n                }\n\n                if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    queue.push([nx, ny, strokes + 1]);\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
    "timestamp": "2025-08-13 11:01:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W, K = map(int, sys.stdin.readline().split())\n    x1, y1, x2, y2 = map(int, sys.stdin.readline().split())\n    x1 -= 1\n    y1 -= 1\n    x2 -= 1\n    y2 -= 1\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    if x1 == x2 and y1 == y2:\n        print(0)\n        return\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    INF = float('inf')\n    dist = [[INF for _ in range(W)] for _ in range(H)]\n    dist[x1][y1] = 0\n    q = deque()\n    q.append((x1, y1))\n    \n    while q:\n        i, j = q.popleft()\n        current_dist = dist[i][j]\n        for di, dj in directions:\n            for step in range(1, K+1):\n                ni = i + di * step\n                nj = j + dj * step\n                if ni < 0 or ni >= H or nj < 0 or nj >= W:\n                    break\n                if grid[ni][nj] == '@':\n                    break\n                if dist[ni][nj] < current_dist + 1:\n                    break\n                if dist[ni][nj] > current_dist + 1:\n                    dist[ni][nj] = current_dist + 1\n                    if ni == x2 and nj == y2:\n                        print(dist[ni][nj])\n                        return\n                    q.append((ni, nj))\n    \n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 11:02:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const main = (input) => {\n  const lines = input.trim().split('\\n');\n  const [H, W, K] = lines[0].split(' ').map(Number);\n  const [x1, y1, x2, y2] = lines[1].split(' ').map(Number);\n  const grid = lines.slice(2).map(line => line.trim());\n  \n  const dx = [1, -1, 0, 0];\n  const dy = [0, 0, 1, -1];\n  \n  const dist = Array.from({ length: H }, () => Array(W).fill(Infinity));\n  const queue = [];\n  \n  const startX = x1 - 1;\n  const startY = y1 - 1;\n  const endX = x2 - 1;\n  const endY = y2 - 1;\n  \n  dist[startX][startY] = 0;\n  queue.push([startX, startY]);\n  \n  while (queue.length > 0) {\n    const [x, y] = queue.shift();\n    if (x === endX && y === endY) {\n      console.log(dist[x][y]);\n      return;\n    }\n    \n    for (let dir = 0; dir < 4; dir++) {\n      for (let step = 1; step <= K; step++) {\n        const nx = x + dx[dir] * step;\n        const ny = y + dy[dir] * step;\n        \n        if (nx < 0 || nx >= H || ny < 0 || ny >= W) break;\n        if (grid[nx][ny] === '@') break;\n        if (dist[nx][ny] < dist[x][y] + 1) break;\n        \n        if (dist[nx][ny] > dist[x][y] + 1) {\n          dist[nx][ny] = dist[x][y] + 1;\n          queue.push([nx, ny]);\n        }\n      }\n    }\n  }\n  \n  console.log(-1);\n};\n\nmain(require('fs').readFileSync('/dev/stdin', 'utf8'));",
    "timestamp": "2025-08-13 11:02:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Position {\n    int x, y, strokes;\n};\n\nint directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\nint bfs(const vector<string> &pond, int H, int W, int K, int sx, int sy, int ex, int ey) {\n    vector<vector<int>> min_strokes(H, vector<int>(W, INT_MAX));\n    queue<Position> q;\n    q.push({sx, sy, 0});\n    min_strokes[sx][sy] = 0;\n\n    while (!q.empty()) {\n        auto [x, y, strokes] = q.front();\n        q.pop();\n        \n        if (x == ex && y == ey) return strokes;\n        \n        for (auto &dir : directions) {\n            for (int step = 1; step <= K; ++step) {\n                int nx = x + step * dir[0];\n                int ny = y + step * dir[1];\n                \n                if (nx < 0 || ny < 0 || nx >= H || ny >= W || pond[nx][ny] == '@') break;\n                \n                if (min_strokes[nx][ny] <= strokes + 1) continue;\n                \n                min_strokes[nx][ny] = strokes + 1;\n                q.push({nx, ny, strokes + 1});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int H, W, K, x1, y1, x2, y2;\n    cin >> H >> W >> K >> x1 >> y1 >> x2 >> y2;\n    x1--, y1--, x2--, y2--; // convert to 0-indexed\n\n    vector<string> pond(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> pond[i];\n    }\n\n    int result = bfs(pond, H, W, K, x1, y1, x2, y2);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:07"
  }
]