[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N + 1];\nint dist[MAX_N + 1];\nint heap[MAX_N + 1];\nint heap_pos[MAX_N + 1];\nint heap_size;\n\nvoid init(int n) {\n    for (int i = 1; i <= n; i++) {\n        head[i] = -1;\n        dist[i] = INT_MAX;\n        heap_pos[i] = -1;\n    }\n    heap_size = 0;\n}\n\nvoid add_edge(int from, int to, int *edge_count) {\n    edges[*edge_count].to = to;\n    edges[*edge_count].next = head[from];\n    head[from] = (*edge_count)++;\n}\n\nvoid heap_swap(int i, int j) {\n    int temp = heap[i];\n    heap[i] = heap[j];\n    heap[j] = temp;\n    heap_pos[heap[i]] = i;\n    heap_pos[heap[j]] = j;\n}\n\nvoid heap_up(int i) {\n    while (i > 1 && dist[heap[i]] < dist[heap[i / 2]]) {\n        heap_swap(i, i / 2);\n        i /= 2;\n    }\n}\n\nvoid heap_down(int i) {\n    while (2 * i <= heap_size) {\n        int j = 2 * i;\n        if (j + 1 <= heap_size && dist[heap[j + 1]] < dist[heap[j]]) {\n            j++;\n        }\n        if (dist[heap[i]] <= dist[heap[j]]) {\n            break;\n        }\n        heap_swap(i, j);\n        i = j;\n    }\n}\n\nvoid heap_push(int v) {\n    heap[++heap_size] = v;\n    heap_pos[v] = heap_size;\n    heap_up(heap_size);\n}\n\nint heap_pop() {\n    int res = heap[1];\n    heap_swap(1, heap_size--);\n    heap_down(1);\n    heap_pos[res] = -1;\n    return res;\n}\n\nvoid dijkstra(int start, int n) {\n    dist[start] = 0;\n    heap_push(start);\n    while (heap_size > 0) {\n        int u = heap_pop();\n        for (int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].to;\n            if (dist[v] > dist[u] + 1) {\n                dist[v] = dist[u] + 1;\n                if (heap_pos[v] == -1) {\n                    heap_push(v);\n                } else {\n                    heap_up(heap_pos[v]);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, p, q;\n    scanf(\"%d %d %d %d\", &n, &m, &p, &q);\n    init(n);\n    int edge_count = 0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b, &edge_count);\n    }\n    dijkstra(p, n);\n    int original_dist = dist[q];\n    printf(\"%d\\n\", original_dist);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        init(n);\n        edge_count = 0;\n        for (int j = 0; j < m; j++) {\n            int u, v;\n            if (j == i) {\n                u = b;\n                v = a;\n            } else {\n                u = edges[j * 2].to;\n                v = edges[j * 2 + 1].to;\n            }\n            add_edge(u, v, &edge_count);\n        }\n        dijkstra(p, n);\n        printf(\"%d\\n\", dist[q]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int weight;\n};\n\nvoid dijkstra(const vector<vector<Edge>>& graph, int start, vector<int>& distances) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    distances[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (current_dist > distances[u]) continue;\n\n        for (const Edge& e : graph[u]) {\n            int v = e.to;\n            int weight = e.weight;\n            if (distances[v] > distances[u] + weight) {\n                distances[v] = distances[u] + weight;\n                pq.push({distances[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, P, Q;\n    cin >> N >> M >> P >> Q;\n\n    vector<vector<Edge>> graph(N + 1);\n    vector<vector<Edge>> reversed_graph(N + 1);\n    vector<pair<int, int>> edges;\n\n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n        reversed_graph[v].push_back({u, w});\n        edges.push_back({u, v});\n    }\n\n    vector<int> dist_pizzeria(N + 1, INT_MAX);\n    vector<int> dist_house(N + 1, INT_MAX);\n\n    dijkstra(graph, P, dist_pizzeria);\n    dijkstra(reversed_graph, Q, dist_house);\n\n    int original_shortest = dist_pizzeria[Q];\n    if (original_shortest == INT_MAX) {\n        original_shortest = -1;\n    }\n\n    for (int i = 0; i < M; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n\n        vector<int> new_dist_pizzeria(N + 1, INT_MAX);\n        vector<int> new_dist_house(N + 1, INT_MAX);\n\n        vector<vector<Edge>> temp_graph = graph;\n        auto it = find_if(temp_graph[u].begin(), temp_graph[u].end(), [v](const Edge& e) { return e.to == v; });\n        if (it != temp_graph[u].end()) {\n            temp_graph[u].erase(it);\n        }\n        temp_graph[v].push_back({u, it->weight});\n\n        dijkstra(temp_graph, P, new_dist_pizzeria);\n\n        int new_shortest = new_dist_pizzeria[Q];\n        if (new_shortest == INT_MAX) {\n            new_shortest = -1;\n        }\n\n        cout << new_shortest << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:57:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PizzaDelivery {\n    private int n;\n    private List<List<int[]>> originalGraph;\n    private List<List<int[]>> reversedGraph;\n\n    public PizzaDelivery(int n, int[][] streets) {\n        this.n = n;\n        this.originalGraph = new ArrayList<>();\n        this.reversedGraph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            originalGraph.add(new ArrayList<>());\n            reversedGraph.add(new ArrayList<>());\n        }\n        for (int[] street : streets) {\n            int u = street[0], v = street[1], w = street[2];\n            originalGraph.get(u).add(new int[]{v, w});\n            reversedGraph.get(v).add(new int[]{u, w});\n        }\n    }\n\n    private int[] dijkstra(int start, List<List<int[]>> graph) {\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.add(new int[]{start, 0});\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0], d = current[1];\n            if (d > dist[u]) continue;\n            for (int[] edge : graph.get(u)) {\n                int v = edge[0], w = edge[1];\n                if (dist[v] > dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                    pq.add(new int[]{v, dist[v]});\n                }\n            }\n        }\n        return dist;\n    }\n\n    public int[] getShortestPath(int pizzeria, int alyssaHouse, int[][] reversedSections) {\n        int[] originalDist = dijkstra(pizzeria, originalGraph);\n        int[] reversedDist = dijkstra(alyssaHouse, reversedGraph);\n        int shortestPath = originalDist[alyssaHouse];\n        int[] results = new int[reversedSections.length];\n\n        for (int i = 0; i < reversedSections.length; i++) {\n            int u = reversedSections[i][0], v = reversedSections[i][1], w = reversedSections[i][2];\n            int newPath = originalDist[v] + w + reversedDist[u];\n            results[i] = Math.min(shortestPath, newPath);\n        }\n        return results;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[][] streets = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            streets[i][0] = scanner.nextInt();\n            streets[i][1] = scanner.nextInt();\n            streets[i][2] = scanner.nextInt();\n        }\n        int pizzeria = scanner.nextInt();\n        int alyssaHouse = scanner.nextInt();\n        int k = scanner.nextInt();\n        int[][] reversedSections = new int[k][3];\n        for (int i = 0; i < k; i++) {\n            reversedSections[i][0] = scanner.nextInt();\n            reversedSections[i][1] = scanner.nextInt();\n            reversedSections[i][2] = scanner.nextInt();\n        }\n\n        PizzaDelivery pd = new PizzaDelivery(n, streets);\n        int[] results = pd.getShortestPath(pizzeria, alyssaHouse, reversedSections);\n        for (int result : results) {\n            System.out.println(result);\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:58:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Edge {\n        int dest, weight;\n        boolean reversed;\n        \n        Edge(int dest, int weight, boolean reversed) {\n            this.dest = dest;\n            this.weight = weight;\n            this.reversed = reversed;\n        }\n    }\n    \n    public static int[] shortestPath(int n, List<Edge>[] graph, int start, int end, Set<Integer> reversedStreets) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        int[] dist = new int[n];\n        int[] prev = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        Arrays.fill(prev, -1);\n        \n        dist[start] = 0;\n        pq.offer(new int[]{start, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int node = current[0];\n            int currentDist = current[1];\n            \n            if (node == end) break;\n            \n            if (currentDist > dist[node]) continue;\n            \n            for (Edge edge : graph[node]) {\n                int newDist = currentDist + edge.weight;\n                boolean canTraverse = !edge.reversed || reversedStreets.contains(node * n + edge.dest);\n                \n                if (canTraverse && newDist < dist[edge.dest]) {\n                    dist[edge.dest] = newDist;\n                    prev[edge.dest] = node;\n                    pq.offer(new int[]{edge.dest, newDist});\n                }\n            }\n        }\n        \n        return new int[]{dist[end], prev[end]};\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // number of nodes\n        int m = sc.nextInt(); // number of edges\n        \n        List<Edge>[] graph = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            int w = sc.nextInt();\n            graph[u].add(new Edge(v, w, false));\n            graph[v].add(new Edge(u, w, true));\n        }\n        \n        int q = sc.nextInt(); // number of queries\n        \n        for (int day = 0; day < q; day++) {\n            int reversedStreet = sc.nextInt() - 1;\n            int start = sc.nextInt() - 1;\n            int end = sc.nextInt() - 1;\n            \n            Set<Integer> reversedStreets = new HashSet<>();\n            reversedStreets.add(reversedStreet);\n            \n            int[] result = shortestPath(n, graph, start, end, reversedStreets);\n            \n            System.out.println(result[0] == Integer.MAX_VALUE ? -1 : result[0]);\n        }\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 20:58:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_NODES 1000\n#define MAX_EDGES 10000\n\ntypedef struct {\n    int src, dest, weight;\n} Edge;\n\ntypedef struct {\n    int V, E;\n    Edge* edges[MAX_EDGES];\n} Graph;\n\nGraph* createGraph(int V, int E) {\n    Graph* graph = malloc(sizeof(Graph));\n    graph->V = V;\n    graph->E = E;\n    return graph;\n}\n\nvoid bellmanFord(Graph* graph, int src, int* dist) {\n    int V = graph->V, E = graph->E;\n    \n    for (int i = 0; i < V; i++)\n        dist[i] = INT_MAX;\n    dist[src] = 0;\n    \n    for (int i = 1; i <= V - 1; i++) {\n        for (int j = 0; j < E; j++) {\n            int u = graph->edges[j]->src;\n            int v = graph->edges[j]->dest;\n            int weight = graph->edges[j]->weight;\n            \n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])\n                dist[v] = dist[u] + weight;\n        }\n    }\n}\n\nint findShortestPath(Graph* graph, int start, int end) {\n    int dist[MAX_NODES];\n    bellmanFord(graph, start, dist);\n    return dist[end] == INT_MAX ? -1 : dist[end];\n}\n\nvoid reverseEdge(Graph* graph, int edgeIndex) {\n    int temp = graph->edges[edgeIndex]->src;\n    graph->edges[edgeIndex]->src = graph->edges[edgeIndex]->dest;\n    graph->edges[edgeIndex]->dest = temp;\n}\n\nint main() {\n    int V, E, Q, pizzeria, home;\n    scanf(\"%d %d %d %d %d\", &V, &E, &Q, &pizzeria, &home);\n    \n    Graph* graph = createGraph(V, E);\n    \n    for (int i = 0; i < E; i++) {\n        graph->edges[i] = malloc(sizeof(Edge));\n        scanf(\"%d %d %d\", &graph->edges[i]->src, &graph->edges[i]->dest, &graph->edges[i]->weight);\n    }\n    \n    while (Q--) {\n        int reversedEdge;\n        scanf(\"%d\", &reversedEdge);\n        reverseEdge(graph, reversedEdge - 1);\n        \n        int shortestPath = findShortestPath(graph, pizzeria - 1, home - 1);\n        printf(\"%d\\n\", shortestPath);\n    }\n    \n    for (int i = 0; i < E; i++)\n        free(graph->edges[i]);\n    free(graph);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nclass Graph {\nprivate:\n    int V;\n    vector<vector<pair<int, int>>> adj;\n\npublic:\n    Graph(int vertices) : V(vertices), adj(vertices) {}\n\n    void addEdge(int u, int v, int weight) {\n        adj[u].push_back({v, weight});\n    }\n\n    void removeEdge(int u, int v) {\n        adj[u].erase(\n            remove_if(adj[u].begin(), adj[u].end(), \n                [v](const pair<int, int>& edge) { return edge.first == v; }),\n            adj[u].end()\n        );\n    }\n\n    int dijkstra(int start, int end) {\n        vector<int> dist(V, INF);\n        dist[start] = 0;\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push({0, start});\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            int curr_dist = pq.top().first;\n            pq.pop();\n\n            if (curr_dist > dist[u]) continue;\n\n            for (auto& edge : adj[u]) {\n                int v = edge.first;\n                int weight = edge.second;\n\n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n\n        return dist[end] == INF ? -1 : dist[end];\n    }\n};\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    Graph graph(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph.addEdge(u-1, v-1, w);\n    }\n\n    int pizzeria = 0, alyssa = n-1;\n\n    for (int day = 0; day < q; day++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n\n        graph.removeEdge(u, v);\n        graph.addEdge(v, u, graph.dijkstra(u, v));\n\n        int shortest_route = graph.dijkstra(pizzeria, alyssa);\n        cout << shortest_route << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef dijkstra(graph, start, end):\n    min_heap = [(0, start)]\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    while min_heap:\n        current_distance, current_node = heapq.heappop(min_heap)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(min_heap, (distance, neighbor))\n    return distances[end] if distances[end] != float('inf') else -1\n\ndef reverse_section(graph, u, v, w):\n    graph[u] = [(x, y) for x, y in graph[u] if x != v]\n    graph[v].append((u, w))\n\ndef add_section(graph, u, v, w):\n    graph[u].append((v, w))\n\ndef process_reversals(n, m, edges, start, end, reversals):\n    # Create graph representation\n    graph = {i: [] for i in range(1, n+1)}\n    for (u, v, w) in edges:\n        graph[u].append((v, w))\n    \n    results = []\n    for (u, v, w) in reversals:\n        reverse_section(graph, u, v, w)\n        shortest_path_cost = dijkstra(graph, start, end)\n        results.append(shortest_path_cost)\n        add_section(graph, u, v, w)\n        reverse_section(graph, v, u, w)\n    return results\n\n# Example Usage\nn = 5  # number of nodes\nm = 5  # number of edges\nedges = [\n    (1, 2, 2),\n    (2, 3, 2),\n    (3, 4, 2),\n    (4, 5, 2),\n    (5, 1, 10)\n]\nstart = 1\nend = 5\nreversals = [\n    (1, 2, 2),\n    (2, 3, 2),\n    (3, 4, 2)\n]\n\nresult = process_reversals(n, m, edges, start, end, reversals)\nprint(result)",
    "timestamp": "2025-08-13 04:15:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PizzaDelivery {\n    static class Edge {\n        int to, weight;\n        Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n    \n    public static int[] shortestPath(int n, List<Edge>[] graph, int start, int end) {\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        pq.offer(new int[]{0, start}); // distance, node\n        \n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int curDist = cur[0], u = cur[1];\n            \n            if (curDist > dist[u]) continue;\n            \n            for (Edge edge : graph[u]) {\n                int v = edge.to, weight = edge.weight;\n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.offer(new int[]{dist[v], v});\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt(); // number of nodes\n        int m = sc.nextInt(); // number of edges\n        int start = sc.nextInt(); // pizzeria node\n        int end = sc.nextInt(); // Alyssa's house node\n\n        // Graph representation\n        List<Edge>[] graph = new List[n];\n        List<Edge>[] reverseGraph = new List[n];\n        \n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n            reverseGraph[i] = new ArrayList<>();\n        }\n        \n        // Read edges\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            int w = sc.nextInt();\n            graph[u].add(new Edge(v, w));\n            reverseGraph[v].add(new Edge(u, w)); // reverse traffic\n        }\n\n        // Number of days\n        int d = sc.nextInt();\n        \n        // Process each day\n        for (int k = 0; k < d; k++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            \n            int originalWeight = -1;\n            \n            // Reverse the direction of the street u -> v\n            Iterator<Edge> iter = graph[u].iterator();\n            while (iter.hasNext()) {\n                Edge e = iter.next();\n                if (e.to == v) {\n                    originalWeight = e.weight;\n                    iter.remove();\n                    break;\n                }\n            }\n\n            reverseGraph[v].add(new Edge(u, originalWeight));\n            \n            // Update shortest path\n            // Compute new shortest path from start to end\n            int[] normalDist = shortestPath(n, graph, start, end);\n            int[] reversedDist = shortestPath(n, reverseGraph, start, end);\n\n            int shortestInNormal = normalDist[end];\n            int shortestInReversed = reversedDist[end];\n            \n            int shortestPath = Math.min(shortestInNormal, shortestInReversed);\n            \n            // Print result for the day\n            System.out.println(shortestPath == Integer.MAX_VALUE ? -1 : shortestPath);\n\n            // Revert back the change\n            graph[u].add(new Edge(v, originalWeight));\n            reverseGraph[v].removeIf(edge -> edge.to == u && edge.weight == originalWeight);\n        }\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 04:15:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_NODES 1000\n#define INF INT_MAX\n\ntypedef struct {\n    int from;\n    int to;\n    int cost;\n} Edge;\n\nEdge edges[MAX_NODES * MAX_NODES];\nint dist[MAX_NODES];\nint prev[MAX_NODES];\nint num_edges, num_vertices;\n\nvoid add_edge(int from, int to, int cost) {\n    edges[num_edges].from = from;\n    edges[num_edges].to = to;\n    edges[num_edges].cost = cost;\n    num_edges++;\n}\n\nvoid bellman_ford(int source) {\n    for (int i = 0; i < num_vertices; i++) {\n        dist[i] = INF;\n        prev[i] = -1;\n    }\n    dist[source] = 0;\n\n    for (int i = 0; i < num_vertices - 1; i++) {\n        for (int j = 0; j < num_edges; j++) {\n            int u = edges[j].from;\n            int v = edges[j].to;\n            int weight = edges[j].cost;\n            if (dist[u] != INF && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                prev[v] = u;\n            }\n        }\n    }\n}\n\nvoid print_shortest_path(int destination) {\n    if (dist[destination] == INF) {\n        printf(\"No path\\n\");\n        return;\n    }\n    printf(\"Shortest path cost: %d\\n\", dist[destination]);\n    printf(\"Path: \");\n    int path[MAX_NODES];\n    int count = 0;\n    for (int i = destination; i != -1; i = prev[i]) {\n        path[count++] = i;\n    }\n    for (int i = count - 1; i >= 0; i--) {\n        printf(\"%d \", path[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int pizzeria = 0, alyssa_home = 1;\n\n    scanf(\"%d %d\", &num_vertices, &num_edges);\n    for (int i = 0; i < num_edges; i++) {\n        int from, to, cost;\n        scanf(\"%d %d %d\", &from, &to, &cost);\n        add_edge(from, to, cost);\n    }\n\n    int num_days;\n    scanf(\"%d\", &num_days);\n    for (int i = 0; i < num_days; i++) {\n        int street_from, street_to;\n        scanf(\"%d %d\", &street_from, &street_to);\n\n        for (int j = 0; j < num_edges; j++) {\n            if (edges[j].from == street_from && edges[j].to == street_to) {\n                edges[j].from = street_to;\n                edges[j].to = street_from;\n                break;\n            }\n        }\n\n        bellman_ford(pizzeria);\n        print_shortest_path(alyssa_home);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:15:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\n\nclass Graph:\n    def __init__(self, n):\n        self.n = n\n        self.edges = [[] for _ in range(n)]\n    \n    def add_edge(self, u, v, w, bidirectional=False):\n        self.edges[u].append((v, w))\n        if bidirectional:\n            self.edges[v].append((u, w))\n    \n    def dijkstra(self, start, end):\n        dist = [float('inf')] * self.n\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            curr_dist, curr_node = heappop(pq)\n            \n            if curr_node == end:\n                return curr_dist\n            \n            if curr_dist > dist[curr_node]:\n                continue\n            \n            for next_node, weight in self.edges[curr_node]:\n                distance = curr_dist + weight\n                \n                if distance < dist[next_node]:\n                    dist[next_node] = distance\n                    heappush(pq, (distance, next_node))\n        \n        return float('inf')\n\ndef solve_pizza_route(n, edges, reversals):\n    results = []\n    graph = Graph(n)\n    \n    for u, v, w in edges:\n        graph.add_edge(u, v, w)\n    \n    for pizzeria, home, day_reversal in reversals:\n        reversed_edge = day_reversal\n        \n        # Temporarily modify graph for today's street reversal\n        graph.add_edge(reversed_edge[1], reversed_edge[0], reversed_edge[2])\n        \n        # Find shortest path\n        shortest_path = graph.dijkstra(pizzeria, home)\n        results.append(shortest_path)\n        \n        # Remove temporary reversal edge\n        graph.edges[reversed_edge[1]] = [\n            edge for edge in graph.edges[reversed_edge[1]] \n            if edge[0] != reversed_edge[0]\n        ]\n    \n    return results\n\n# Example usage\nn = 5  # number of nodes\nedges = [\n    (0, 1, 2),\n    (1, 2, 3),\n    (2, 3, 1),\n    (3, 4, 4)\n]\nreversals = [\n    (0, 4, (2, 3, 1)),  # pizzeria, home, reversed_edge\n    (0, 4, (3, 2, 1))\n]\n\nprint(solve_pizza_route(n, edges, reversals))",
    "timestamp": "2025-08-13 04:16:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    Q = int(data[idx])\n    idx += 1\n    pizzeria = int(data[idx]) - 1\n    idx += 1\n    house = int(data[idx]) - 1\n    idx += 1\n    \n    adj = [[] for _ in range(N)]\n    reverse_adj = [[] for _ in range(N)]\n    edges = []\n    \n    for _ in range(M):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        w = int(data[idx])\n        idx += 1\n        adj[u].append((v, w))\n        reverse_adj[v].append((u, w))\n        edges.append((u, v, w))\n    \n    def dijkstra(start, graph):\n        dist = [float('inf')] * N\n        dist[start] = 0\n        heap = [(0, start)]\n        visited = set()\n        \n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add(u)\n            for v, w in graph[u]:\n                if dist[v] > current_dist + w:\n                    dist[v] = current_dist + w\n                    heapq.heappush(heap, (dist[v], v))\n        return dist\n    \n    original_dist = dijkstra(pizzeria, adj)\n    \n    for _ in range(Q):\n        t = int(data[idx]) - 1\n        idx += 1\n        u, v, w = edges[t]\n        \n        # Reverse the edge\n        adj[u].remove((v, w))\n        adj[v].append((u, w))\n        \n        # Recompute distances\n        new_dist = dijkstra(pizzeria, adj)\n        \n        # Output the shortest path to the house\n        print(new_dist[house] if new_dist[house] != float('inf') else -1)\n        \n        # Restore the edge\n        adj[v].remove((u, w))\n        adj[u].append((v, w))\n\nsolve()",
    "timestamp": "2025-08-13 04:16:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nconst int INF = std::numeric_limits<int>::max();\n\nstruct Edge {\n    int to, weight;\n};\n\nusing Graph = std::vector<std::vector<Edge>>;\n\nstd::vector<int> dijkstra(const Graph& graph, int start) {\n    int n = graph.size();\n    std::vector<int> dist(n, INF);\n    dist[start] = 0;\n    using P = std::pair<int, int>; // (distance, vertex)\n    std::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        auto [current_dist, current] = pq.top();\n        pq.pop();\n        \n        if (current_dist > dist[current]) continue;\n        \n        for (const auto& edge : graph[current]) {\n            int next = edge.to;\n            int new_dist = dist[current] + edge.weight;\n            if (new_dist < dist[next]) {\n                dist[next] = new_dist;\n                pq.push({new_dist, next});\n            }\n        }\n    }\n    return dist;\n}\n\nint main() {\n    int n, m, s, t, d;\n    std::cin >> n >> m >> s >> t >> d;\n    \n    Graph graph(n);\n    \n    for (int i = 0; i < m; ++i) {\n        int u, v, w;\n        std::cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n    }\n    \n    auto initial_distances = dijkstra(graph, s);\n    \n    for (int day = 0; day < d; ++day) {\n        int u, v, w;\n        std::cin >> u >> v >> w;\n\n        // Reverse the road by reversing edges\n        for (auto it = graph[u].begin(); it != graph[u].end(); ++it) {\n            if (it->to == v) {\n                graph[u].erase(it);\n                break;\n            }\n        }\n        graph[v].push_back({u, w});\n\n        auto distances = dijkstra(graph, s);\n        int shortest_path = distances[t];\n        \n        if (shortest_path == INF) {\n            std::cout << \"unreachable\" << std::endl;\n        } else {\n            std::cout << shortest_path << std::endl;\n        }\n        \n        // Reverse back\n        for (auto it = graph[v].begin(); it != graph[v].end(); ++it) {\n            if (it->to == u) {\n                graph[v].erase(it);\n                break;\n            }\n        }\n        graph[u].push_back({v, w});\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:18:05"
  }
]