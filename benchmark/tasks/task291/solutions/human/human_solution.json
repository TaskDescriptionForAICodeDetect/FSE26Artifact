[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define ll long long\n \nconst int maxn=1e5+5;\n \nint n,m;\nbool bo[maxn];\nint a[maxn],b[maxn],c[maxn];\n \nint read() {\n    int x=0,f=1;char ch=getchar();\n    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n    for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n    return x*f;\n}\n \nstruct node {\n    ll v;\n    int u;\n \n    node() {}\n     \n    node(int _u,ll _v) {u=_u,v=_v;}\n \n    bool operator<(const node &a)const {\n        return v<a.v;\n    }\n};\n \nstruct Heap {\n    int tot;\n    node tree[maxn];\n     \n    void ins(node x) {\n        tree[++tot]=x;\n        int pos=tot;\n        while(pos>1) {\n            if(tree[pos]<tree[pos>>1])\n                swap(tree[pos],tree[pos>>1]),pos>>=1;\n            else break;\n        }\n    }\n \n    int pop() {\n        node res=tree[1];\n        tree[1]=tree[tot--];\n        int pos=1,son=2;\n        while(son<=tot) {\n            if(son<tot&&tree[son|1]<tree[son])son|=1;\n            if(tree[son]<tree[pos])\n                swap(tree[son],tree[pos]),pos=son;\n            else break;son=pos<<1;\n        }\n        return res.u;\n    }\n}T;\n \nstruct graph {\n    int tot,h,t;\n    ll dis[maxn],cnt[maxn];\n    int list[maxn],deg[maxn];\n    int now[maxn],pre[maxn],son[maxn],val[maxn];\n \n    void clear() {\n        tot=0;memset(now,0,sizeof(now));\n        memset(deg,0,sizeof(deg));\n    }\n     \n    void add(int a,int b,int c) {\n        pre[++tot]=now[a];\n        now[a]=tot;son[tot]=b;\n        val[tot]=c;deg[b]++;\n    }\n \n    void dij(int st) {\n        memset(dis,63,sizeof(dis));\n        dis[st]=0;T.ins(node(st,0));\n        while(T.tot) {\n            int u=T.pop();\n            for(int p=now[u],v=son[p];p;p=pre[p],v=son[p])\n                if(dis[v]>dis[u]+val[p]) {\n                    dis[v]=dis[u]+val[p];\n                    T.ins(node(v,dis[v]));\n                }\n        }\n    }\n \n    void calc(int st) {\n        cnt[st]=1;list[0]=st;h=0,t=1;\n        while(h!=t) {\n            int u=list[h++];\n            for(int p=now[u],v=son[p];p;p=pre[p],v=son[p]) {\n                cnt[v]+=cnt[u];\n                if(--deg[v]==0)list[t++]=v;\n            }\n        }\n    }\n}G1,G2;\n \nint main() {\n    n=read(),m=read();\n    for(int i=1;i<=m;i++) {\n        a[i]=read(),b[i]=read(),c[i]=read();\n        G1.add(a[i],b[i],c[i]);G2.add(b[i],a[i],c[i]);\n    }G1.dij(1),G2.dij(2);\n    G1.clear(),G2.clear();\n    for(int i=1;i<=m;i++)\n        if(G1.dis[a[i]]+G2.dis[b[i]]+c[i]==G1.dis[2]) {\n            bo[i]=1;\n            G1.add(a[i],b[i],c[i]),G2.add(b[i],a[i],c[i]);\n        }\n    G1.calc(1),G2.calc(2);\n    for(int i=1;i<=m;i++) {\n        if(bo[i]) {\n            if(G1.cnt[a[i]]*G2.cnt[b[i]]==G1.cnt[2])puts(\"SAD\");\n            else puts(\"SOSO\");\n        }\n        else {\n            if(G1.dis[b[i]]+c[i]+G2.dis[a[i]]<G1.dis[2])puts(\"HAPPY\");\n            else puts(\"SOSO\");\n        }\n         \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n\nusing namespace std;\nconst double eps=1e-6;\nconst double SQRT32=0.8660254037844386;\nconst double SQRT3=1.7320508075688772;\nconst double PI=3.141592653589793;\n\nint col[100][100];\nint inv[10];\nint f[10];\n\nint check(double x,double goal)\n{\n    if(x-goal>eps) return 1;\n    if(goal-x>eps) return -1;\n    return 0;\n}\n\nvoid print()\n{\n    int p=20;\n    for(int i=0;i<p;i++)\n    {\n        for(int j=i;j<p-1;j++) printf(\"  \");\n        for(int j=0;j<i*2+1;j++) printf(\"%d \",col[i][j]);\n        printf(\"\\n\");\n    }\n    return;\n}\n\nint init()\n{\n    inv[1]=3,inv[2]=4,inv[3]=1,inv[4]=2;\n    \n    col[0][0]=1;\n    col[1][0]=2;\n    col[1][1]=3;\n    col[1][2]=4;\n    for(int i=2;i<36;i++)\n    {\n        int len=(i<<1)|1;\n        int mid=i;\n        if(i&1)\n        {\n            col[i][i]=inv[col[i-1][i-1]];\n            col[i][i+1]=col[i-1][i];          \n        }\n        else\n        {\n            col[i][i]=col[i-1][i-1];\n            col[i][i+1]=inv[col[i-1][i]];    \n        }\n        for(int j=i+2;j<len;j+=2) col[i][j]=inv[col[i][j-2]];\n        for(int j=i-2;j>=0 ;j-=2) col[i][j]=inv[col[i][j+2]];\n        for(int j=i+3;j<len;j+=2) col[i][j]=inv[col[i][j-2]];\n        for(int j=i-1;j>=0 ;j-=2) col[i][j]=inv[col[i][j+2]];\n    }\n    //print();\n    return 0;\n}\n\nint getans(int d,int l)\n{\n    double x=l*sin((double)(d-30)/180.0*PI),y=l*cos((double)(d-30)/180.0*PI);\n    //printf(\"x=%lf y=%lf\\n\",x,y);\n    int xx=0;\n    while(check((xx+1)*SQRT32,y)<0) xx++;\n    \n    int yy=0;\n    double dis;\n    if(xx&1) dis=(xx+1)/2.0-y/SQRT3;\n    else dis=y/SQRT3-xx/2.0;\n    if(check(abs(x),dis)>0)\n    {\n        double curx=dis;\n        double tmpx=1.0-dis*2;\n        while(check(curx+tmpx,abs(x))<0)\n        {\n            yy++;\n            curx+=tmpx;\n            tmpx=1-tmpx;\n        }\n    }\n    \n    if(check(x,0)>=0)\n    {\n        //printf(\"xx=%d yy=%d\\n\",xx,yy);\n        return col[xx][xx+yy];\n    }\n    else\n    {\n        //printf(\"xx=%d yy=%d\\n\",xx,-yy);\n        return col[xx][xx-yy];\n    }\n}    \n\nint ans[2];\n        \nint main()\n{\n    \n    init();\n    char s[10];\n    int d,l;\n    for(int i=0;i<2;i++)\n    {\n        cin>>s>>d>>l;\n        \n        if(s[0]=='B')\n        {\n            f[1]=1;\n            f[2]=2;\n            f[3]=3;\n            f[4]=4;\n        }\n        if(s[0]=='C')\n        {\n            f[1]=4;\n            f[2]=1;\n            f[3]=3;\n            f[4]=2;\n        }\n        if(s[0]=='D')\n        {\n            f[1]=2;\n            f[2]=4;\n            f[3]=3;\n            f[4]=1;\n        }\n        ans[i]=f[getans(d,l)];\n        //printf(\"ans[%d]=%d\\n\",i,ans[i]);\n    }\n    \n    if(ans[0]==ans[1]) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n          \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define mod 1000000007\n#define dbg(x) cout<<#x\"=\"<<x<<endl\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1});\n  cnt[s]=1;\n  dist[s]=0;\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;  \n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] == d + c){\n        (cnt[u] += cnt[v])%=mod;\n      }else if(dist[u] > d + c){\n        dist[u] = d + c;\n        cnt[u]=cnt[v];\n        q.push((state) { d + c, u, v });\n      }\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v])%mod == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<queue>\n\nconst int maxn=100005;\nconst int maxm=100005;\n\nusing namespace std;\n\nint n,m;\nstruct edge{\n\tint to,w;\n};\nstruct data{\n\tint u,v,w;\n}q[maxm];\n\nvector<edge>son[maxn];\n\nint dis[maxn],vis[maxn],U,V,W;\nint spfa(){\n\tqueue<int>Q;\n\tmemset(vis,0,sizeof(vis));\n\tmemset(dis,0x3f3f3f,sizeof(dis));\n\tdis[1]=0;\n\tvis[1]=1;\n\tQ.push(1);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();\n\t\tQ.pop();\n\t\tvis[u]=0;\n\t\tint sz=son[u].size();\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tint v=son[u][i].to,w=son[u][i].w;\n\t\t\tif(U==u&&V==v) continue;\n\t\t\tif(dis[u]+w<dis[v]){\n\t\t\t\tdis[v]=dis[u]+w;\n\t\t\t\tif(!vis[v]){\n\t\t\t\t\tvis[v]=1;\n\t\t\t\t\tQ.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[2];\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint u,v,w;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tq[i]=(data){u,v,w};\n\t\tedge x=(edge){v,w};\n\t\tson[u].push_back(x);\n\t}\n\tU=-1,V=-1;\n\tint mindis=spfa();\n\tfor(int i=0;i<m;i++){\n\t\tU=q[i].u,V=q[i].v,W=q[i].w;\n\t\tson[V].push_back((edge){U,W});\n\t\tint dis=spfa();\n\t\tson[V].erase(son[V].end()-1);\n\t\tif(dis<mindis){\n\t\t\tprintf(\"HAPPY\\n\");\n\t\t}\n\t\tif(dis==mindis){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t}\n\t\tif(dis>mindis){\n\t\t\tprintf(\"SAD\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PP;\n\nint n,m;\nvector<P> G[100001];\nvector<P> rG[100001];\nll dist[100001];\nll cnt[100001];\nll dist2[100001];\nint a[100001],b[100001];\nll c[100001];\nset<PP> se;\nset<PP> multi;\nstack<int> s;\n\nvoid dijk(){\n\tfor(int i=0;i<n;i++){\n\t\tdist[i]=INF;\n\t}\n\tdist[0]=0;\n\tcnt[0]=1;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,0));\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tll co=p.first;\n\t\tif(co>dist[v])continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(dist[G[v][i].first]>dist[v]+G[v][i].second){\n\t\t\t\tdist[G[v][i].first]=dist[v]+G[v][i].second;\n\t\t\t\tcnt[G[v][i].first]=cnt[v];\n\t\t\t\tque.push(P(dist[G[v][i].first],G[v][i].first));\n\t\t\t}else if(dist[G[v][i].first]==dist[v]+G[v][i].second){\n\t\t\t\tcnt[G[v][i].first]+=cnt[v];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijk2(){\n\tfor(int i=0;i<n;i++){\n\t\tdist2[i]=INF;\n\t}\n\tdist2[1]=0;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,1));\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tll co=p.first;\n\t\tif(co>dist2[v])continue;\n\t\tfor(int i=0;i<rG[v].size();i++){\n\t\t\tif(dist2[rG[v][i].first]>dist2[v]+rG[v][i].second){\n\t\t\t\tdist2[rG[v][i].first]=dist2[v]+rG[v][i].second;\n\t\t\t\tque.push(P(dist2[rG[v][i].first],rG[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%lld\",&a[i],&b[i],&c[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\tG[a[i]].push_back(P(b[i],c[i]));\n\t\trG[b[i]].push_back(P(a[i],c[i]));\n\t\tif(se.find(PP(P(a[i],b[i]),c[i]))==se.end()){\n\t\t\tse.insert(PP(P(a[i],b[i]),c[i]));\n\t\t}else{\n\t\t\tmulti.insert(PP(P(a[i],b[i]),c[i]));\n\t\t}\n\t}\n\tdijk();\n\tdijk2();\n\tfor(int i=0;i<m;i++){\n\t\tll val=dist[b[i]];\n\t\tval+=dist2[a[i]];\n\t\tval+=c[i];\n\t\tif(val<dist[1]){\n\t\t\tputs(\"HAPPY\");\n\t\t}else if(dist[1]>=INF){\n\t\t\tputs(\"SAD\");\n\t\t}else if(val==dist[1]){\n\t\t\tputs(\"SOSO\");\n\t\t}else{\n\t\t\tif(dist[b[i]]-dist[a[i]]!=c[i]){\n\t\t\t\tputs(\"SOSO\");\n\t\t\t}else{\n\t\t\t\tif(multi.find(PP(P(a[i],b[i]),c[i]))!=multi.end()){\n\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t}else if(dist[a[i]]+c[i]+dist2[b[i]]==dist[1]){\n\t\t\t\t\tif(cnt[1]==cnt[a[i]]){\n\t\t\t\t\t\tputs(\"SAD\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n\nconst ll INF = 1e15;\n\nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n\tdist[f->dst] = e.weight + f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\tprev[f->dst].clear();\n\tprev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n\tprev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n\nGraph buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  stack<int> st;\n  st.push(t);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    for(auto&& p : prev[now]){\n      if(p < 0)\n\tcontinue;\n      g[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return g;\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w*2, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w*2 == befo.first)\n\tmp[P(s, d)] = P(w*2-1, befo.second + 1);\n      else\n\tmp[P(s, d)] = P(min(w*2, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree = buildPath(prev, 1);\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n\n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n\n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n    \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w*2)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    for(int i=0;i<tree[s].size();i++){\n      ok |= tree[s][i].dst == d;\n      //cout << \"tr: \" << tree[s][i].src << \" \" << tree[s][i].dst << endl;\n    }\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\nconstexpr ll inf = ll(1e18) + 9;\n\nvector<ll> dijkstra(vector<vector<pair<int, ll> > > const & g, int root) {\n    vector<ll> dist(g.size(), inf);\n    priority_queue<pair<ll, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        ll dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; ll cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n\npair<int, vector<int> > decompose_to_two_edge_connected_components(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> imos(n); { // imos[i] == 0  iff  the edge i -> parent is a bridge\n        vector<char> used(n); // 0: unused ; 1: exists on stack ; 2: removed from stack\n        function<void (int, int)> go = [&](int i, int parent) {\n            used[i] = 1;\n            for (int j : g[i]) if (j != parent) {\n                if (used[j] == 0) {\n                    go(j, i);\n                    imos[i] += imos[j];\n                } else if (used[j] == 1) {\n                    imos[i] += 1;\n                    imos[j] -= 1;\n                }\n            }\n            used[i] = 2;\n        };\n        REP (i, n) if (used[i] == 0) {\n            go(i, -1);\n        }\n    }\n    int size = 0;\n    vector<int> component_of(n, -1); {\n        function<void (int)> go = [&](int i) {\n            for (int j : g[i]) if (component_of[j] == -1) {\n                component_of[j] = imos[j] == 0 ? size ++ : component_of[i];\n                go(j);\n            }\n        };\n        REP (i, n) if (component_of[i] == -1) {\n            component_of[i] = size ++;\n            go(i);\n        }\n    }\n    return { size, move(component_of) };\n}\n\nenum result_t { HAPPY, SOSO, SAD };\nconstexpr int start = 0;\nconstexpr int goal = 1;\nint main() {\n    // input\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<tuple<int, int, int> > edges(m);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        edges[i] = make_tuple(a, b, c);\n    }\n    // solve\n    vector<vector<pair<int, ll >> > g(n);\n    vector<vector<pair<int, ll >> > rev_g(n);\n    map<tuple<int, int, int>, int> count_edges;\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        g[a].emplace_back(b, c);\n        rev_g[b].emplace_back(a, c);\n        count_edges[edge] += 1;\n    }\n    auto dist = dijkstra(g, start);\n    auto rev_dist = dijkstra(rev_g, goal);\n    vector<vector<int> > h(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            if (dist[i] + cost + rev_dist[j] == dist[goal]) {\n                h[i].push_back(j);\n                h[j].push_back(i);\n            }\n        }\n    }\n    auto component_of = decompose_to_two_edge_connected_components(h).second;\n    REP (i, n) cerr << i+1 << \" \" << component_of[i] << endl;\n    // output\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        result_t result =\n            dist[b] + c + rev_dist[a] <  dist[goal] ? HAPPY :\n            // dist[a] == inf or rev_dist[b] == inf ? SOSO :\n            dist[b] + c + rev_dist[a] == dist[goal] ? SOSO :\n            dist[a] + c + rev_dist[b] != dist[goal] ? SOSO :\n            count_edges[edge] >= 2 ? SOSO :\n            component_of[a] != component_of[b] ? SAD :\n            SOSO;\n        printf(\"%s\\n\",\n            result == HAPPY ? \"HAPPY\" :\n            result == SOSO ? \"SOSO\" :\n            result == SAD ? \"SAD\" :\n            \"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint c[1 << 17];\nstruct edge2 {\n\tint to, id;\n};\n\nvector<edge2> g[100000];\nint root;\nint parent[17][100000];\nint depth[100000];\nvoid dfs(int v, int p, int d) {\n\tparent[0][v] = p;\n\tdepth[v] = d;\n\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\tif (g[v][i].to != p)dfs(g[v][i].to, v, d + 1);\n\t}\n}\nvoid init(int V) {\n\tdfs(root, -1, 0);\n\tfor (int k = 0; k + 1 < 17; k++) {\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (parent[k][v] < 0)parent[k + 1][v] = -1;\n\t\t\telse parent[k + 1][v] = parent[k][parent[k][v]];\n\t\t}\n\t}\n}\nint lca(int u, int v) {\n\tif (depth[u] > depth[v])swap(u, v);\n\tfor (int k = 0; k < 17; k++) {\n\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\tif (u == v)return u;\n\tfor (int k = 16; k >= 0; k--) {\n\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}\n\nvector<int> ans;\nvoid dfs2(int id,int fr) {\n\trep(j, g[id].size()) {\n\t\tint to = g[id][j].to;\n\t\tif (to == fr)continue;\n\t\tdfs2(to, id);\n\t\tc[id] += c[to];\n\t\tif (c[to] > 0) {\n\t\t\tans[g[id][j].id] = 1;\n\t\t}\n\t}\n}\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstruct edge {\n\tint to; ll cost; int id;\n};\nvector<edge> G[1 << 17],rG[1<<17];\n\nll ds[1 << 17], dg[1 << 17];\npriority_queue<LP,vector<LP>,greater<LP>> q;\n\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tans.resize(m);\n\trep(i, m) {\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\tG[a].push_back({ b,c,i });\n\t\trG[b].push_back({ a,c,i });\n\t}\n\tfill(ds, ds + n, INF); fill(dg, dg + n, INF);\n\tds[0] = 0; q.push({ 0,0 });\n\twhile (!q.empty()) {\n\t\tLP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j].to;\n\t\t\tll nd = p.first + G[id][j].cost;\n\t\t\tif (nd < ds[to]) {\n\t\t\t\tds[to] = nd;\n\t\t\t\tq.push({ nd,to });\n\t\t\t}\n\t\t}\n\t}\n\tdg[1] = 0; q.push({ 0,1 });\n\twhile (!q.empty()) {\n\t\tLP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\trep(j, rG[id].size()) {\n\t\t\tint to = rG[id][j].to;\n\t\t\tll nd = p.first + rG[id][j].cost;\n\t\t\tif (nd < dg[to]) {\n\t\t\t\tdg[to] = nd;\n\t\t\t\tq.push({ nd,to });\n\t\t\t}\n\t\t}\n\t}\n\tll ma = ds[1];\n\tvector<P> banlist;\n\tuf u(n);\n\trep(i, n) {\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j].to;\n\t\t\tll cost = ds[i] + dg[to] + G[i][j].cost;\n\t\t\tif (cost == ma) {\n\t\t\t\tif (u.same(i, to)) {\n\t\t\t\t\tans[G[i][j].id] = 1;\n\t\t\t\t\tbanlist.push_back({ i,to });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tu.unite(i, to);\n\t\t\t\t\tg[i].push_back({ to,G[i][j].id });\n\t\t\t\t\tg[to].push_back({ i,G[i][j].id });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\troot = 0;\n\tinit(n);\n\trep(i, banlist.size()) {\n\t\tint le = banlist[i].first, ri = banlist[i].second;\n\t\tint cp = lca(le, ri);\n\t\tc[le]++; c[ri]++; c[cp] -= 2;\n\t}\n\tdfs2(root,-1);\n\trep(i, n) {\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j].to, id = G[i][j].id;\n\t\t\tll cost = G[i][j].cost;\n\t\t\t//cout << id<<\" \"<<cost + ds[to] + dg[i] << endl;\n\t\t\tif (cost + ds[to] + dg[i] < ma) {\n\t\t\t\t//cout << id << endl;\n\t\t\t\tans[id] = 2;\n\t\t\t}\n\t\t\telse if (cost + ds[i] + dg[to] > ma) {\n\t\t\t\tans[id] = 1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tif (ans[i] == 0) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse if (ans[i] == 1) {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass BECC{\nprivate:\n    int N;\n    vector<vector<int>> G,dcmp;\n    vector<int> order,inS;\n    stack<int> S,roots;\n    vector<int> cmp;\npublic:\n    vector<P> bridge;\n    vector<vector<int>> bccs;\n    BECC(int n,vector<vector<int>> graph){\n        N = n;\n        G = graph;\n        order = inS = cmp = vector<int>(N+1,0);\n    }\n    void dfs(int cur,int prev,int k){\n        order[cur] = ++k; //訪問順に番号付け\n        S.push(cur); inS[cur] = true;//訪問した頂点の集合に追加\n        roots.push(cur);//各bccの根を管理\n        for(auto to:G[cur]){\n            if(order[to]==0) dfs(to,cur,k);\n            else if(to!=prev && inS[to]){//後退辺なら\n                while(order[roots.top()]>order[to]) roots.pop();//(to,cur]を捨てる\n            }\n        }\n        if(cur==roots.top()){\n            if(prev!=-1) bridge.emplace_back(prev,cur);//根でないなら橋になる\n            vector<int> bcc;\n            while(true){\n                int node = S.top(); S.pop(); inS[node] = false;//nodeを捨てる\n                bcc.emplace_back(node);//nodeをbccに追加\n                cmp[node] = bccs.size()+1;\n                if(node==cur) break;\n            }\n            bccs.emplace_back(bcc);\n            roots.pop();\n        }\n    }\n    void bridge_detection(){\n        int k = 0;\n        for(int i=0;i<N;i++) if(order[i]==0) dfs(i,-1,k);\n    }\n    int find(int n){return cmp[n];}\n    int cmp_size(int n){return bccs[cmp[n]].size();}\n    void decomposition(){\n        int k = 0;\n        for(int i=0;i<N;i++) if(order[i]==0) dfs(i,-1,k);\n        dcmp = vector<vector<int>>(bccs.size()+1);\n        for(auto x:bridge){\n            dcmp[cmp[x.first]].push_back(cmp[x.second]);\n            dcmp[cmp[x.second]].push_back(cmp[x.first]);\n        }\n    }\n};\n\nint main(){\n    int N,M;\n    cin >> N >> M;\n    vector<ll> A(M),B(M),C(M);\n    vector<vector<P>> g(N),rg(N);\n    for(int i=0;i<M;i++){\n        cin >> A[i] >> B[i] >> C[i];\n        A[i]--,B[i]--;\n        g[A[i]].push_back({C[i],B[i]});\n        rg[B[i]].push_back({C[i],A[i]});\n    }\n    ll inf = 1e18;\n    vector<vector<ll>> dp(N,vector<ll>(2,inf));\n    auto dijkstra = [&](vector<vector<P>> v,int id){\n        dp[id][id] = 0;\n        priority_queue<P,vector<P>,greater<P>> Q;\n        Q.push({0,id});\n        while(!Q.empty()){\n            P now = Q.top(); Q.pop();\n            if(dp[now.second][id]<now.first) continue;\n            for(auto& e:v[now.second]){\n                ll nd = now.first+e.first;\n                if(dp[e.second][id]>nd){\n                    dp[e.second][id] = nd;\n                    Q.push({nd,e.second});\n                }\n            }\n        }\n    };\n    dijkstra(g,0);\n    dijkstra(rg,1);\n    vector<vector<int>> edges(N);\n    for(int i=0;i<M;i++){\n        if(dp[A[i]][0]+C[i]+dp[B[i]][1]==dp[1][0]){\n            edges[A[i]].push_back(B[i]);\n            edges[B[i]].push_back(A[i]);\n        }\n    }\n    BECC becc(N,edges);\n    becc.bridge_detection();\n    set<P> bridge;\n    for(auto& x:becc.bridge){\n        int a = min(x.first,x.second),b = max(x.first,x.second);\n        bridge.insert({a,b});\n    }\n    for(int i=0;i<M;i++){\n        int a = min(A[i],B[i]),b = max(A[i],B[i]);\n        ll nd = dp[B[i]][0]+C[i]+dp[A[i]][1];\n        if(nd<dp[1][0]) cout << \"HAPPY\" << endl;\n        else if(nd==dp[1][0]) cout << \"SOSO\" << endl;\n        else if(dp[A[i]][0]+C[i]+dp[B[i]][1]==dp[0][1] && bridge.count({a,b})) cout << \"SAD\" << endl;\n        else cout << \"SOSO\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nconst int mod = 1000000021;\nconst long long inf = 1LL << 61;\nstruct edge { int to, cost, id; };\nstruct state { int pos; long long cost; };\nbool operator<(const state& s1, const state& s2) { return s1.cost > s2.cost; }\nint N, M, dp[100009], dp2[100009], va[100009]; bool vis1[100009], vis2[100009];\nvector<long long> shortest_path(vector<vector<edge> > g, int src) {\n\tvector<long long> ret(g.size(), inf); ret[src] = 0;\n\tpriority_queue<state> que; que.push(state{ src, 0 });\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (edge e : g[u]) {\n\t\t\tlong long nd = ret[u] + e.cost;\n\t\t\tif (ret[e.to] > nd) {\n\t\t\t\tret[e.to] = nd;\n\t\t\t\tque.push(state{ e.to, nd });\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\tvector<int> a(M), b(M), c(M);\n\tvector<vector<edge> > g(N);\n\tvector<vector<edge> > rg(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t\tg[a[i]].push_back(edge{ b[i], c[i], i });\n\t\trg[b[i]].push_back(edge{ a[i], c[i], i });\n\t}\n\tvector<long long> ds = shortest_path(g, 0);\n\tvector<long long> dt = shortest_path(rg, 1);\n\tvector<bool> ok(M), ok2(M);\n\tvector<vector<int> > sg(N), sr(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ds[a[i]] + c[i] == ds[b[i]]) {\n\t\t\tok[i] = true;\n\t\t\tsg[a[i]].push_back(b[i]);\n\t\t}\n\t\tif (dt[b[i]] + c[i] == dt[a[i]]) {\n\t\t\tok2[i] = true;\n\t\t\tsr[b[i]].push_back(a[i]);\n\t\t}\n\t}\n\tpriority_queue<state> que; que.push(state{ 0, 0 }); dp[0] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis1[u]) {\n\t\t\tvis1[u] = true;\n\t\t\tfor (int i : sg[u]) {\n\t\t\t\tdp[i] += dp[u];\n\t\t\t\tif (dp[i] >= mod) dp[i] -= mod;\n\t\t\t\tque.push(state{ i, ds[i] });\n\t\t\t}\n\t\t}\n\t}\n\tque.push(state{ 1, 0 }); dp2[1] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis2[u]) {\n\t\t\tvis2[u] = true;\n\t\t\tfor (int i : sr[u]) {\n\t\t\t\tdp2[i] += dp2[u];\n\t\t\t\tif (dp2[i] >= mod) dp2[i] -= mod;\n\t\t\t\tque.push(state{ i, dt[i] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) va[i] = 1LL * dp[i] * dp2[i] % mod;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!ok[i] || !ok2[i]) {\n\t\t\tcout << (ds[b[i]] + dt[a[i]] + c[i] < ds[1] ? \"HAPPY\\n\" : \"SOSO\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (ds[b[i]] + dt[a[i]] + c[i] < ds[1]) cout << \"HAPPY\\n\";\n\t\t\telse if (ds[b[i]] + dt[a[i]] + c[i] == ds[1]) cout << \"SOSO\\n\";\n\t\t\telse {\n\t\t\t\tif (va[a[i]] == va[0] && va[b[i]] == va[0]) cout << \"SAD\\n\";\n\t\t\t\telse cout << \"SOSO\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <limits.h>\n#include <string.h>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <queue>\n#define pb push_back\n#define ll long long\n#define X first\n#define Y second\n#define pi acos(-1.0) \n#define maxn 100005\n#define mod 999999937\n#define inf 9999999999999999\nusing namespace std;\n\ntypedef pair<ll,int> P;\n\nstruct Edge{\n    int from,to;\n    ll cost;\n};\n\nint n,m;\nvector<Edge> edges;\nvector<int> v[maxn],rv[maxn];\nll d1[maxn],d2[maxn];\nbool used[maxn];\n\nvoid addedge(int from,int to,ll cost){\n    edges.push_back(Edge{from,to,cost});\n    edges.push_back(Edge{to,from,cost});\n    v[from].push_back(edges.size()-2);\n    rv[to].push_back(edges.size()-1);\n}\n\nvoid dijs1(int s,ll *dist){\n    fill(dist+1,dist+n+1,inf);\n    memset(used,0,sizeof(used));\n    dist[s]=0;\n    priority_queue<P,vector<P>,greater<P> > pq;\n    pq.push(P(0,s));\n    while(!pq.empty()){\n        int now=pq.top().second; pq.pop();\n        if(used[now]) continue;\n        used[now]=1;\n        for(int i=0;i<v[now].size();i++){\n            Edge e=edges[v[now][i]];\n            if(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n                dist[e.to]=dist[now]+e.cost;\n                pq.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n}\n\nvoid dijs2(int s,ll *dist){\n    fill(dist+1,dist+n+1,inf);\n    memset(used,0,sizeof(used));\n    dist[s]=0;\n    priority_queue<P,vector<P>,greater<P> > pq;\n    pq.push(P(0,s));\n    while(!pq.empty()){\n        int now=pq.top().second; pq.pop();\n        if(used[now]) continue;\n        used[now]=1;\n        for(int i=0;i<rv[now].size();i++){\n            Edge e=edges[rv[now][i]];\n            if(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n                dist[e.to]=dist[now]+e.cost;\n                pq.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n}\n\nll length;\nvector<int> G[maxn];\n\n//bcc模板 (橋雙連通分量)\nint dfs_clock;\nmap<int,bool> bridge[maxn];//用bridge[i][j]紀錄v[i][j]這條邊是不是橋 //常數有點大，如果需要加快再改 \nint pre[maxn];\n\nint dfs_bcc(int u,int fa){ \n    int lowu=pre[u]=++dfs_clock;\n    for(int i=0;i<G[u].size();i++){\n        int x=G[u][i];\n        if(!pre[x]){\n            int lowx=dfs_bcc(x,u);\n            lowu=min(lowu,lowx);\n            if(lowx>pre[u]) {\n                bridge[u][x]=1;\n                bridge[x][u]=1;\n            }\n        }\n        else if(pre[x]<pre[u]&&x!=fa) lowu=min(lowu,pre[x]);\n    }\n    return lowu;\n}\n\nvoid find_bcc(int nn){\n    memset(pre,0,sizeof(pre));\n    dfs_clock=0;\n    for(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n        bridge[i].clear();\n    }\n    for(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n        if(!pre[i]) dfs_bcc(i,-1);\n    }\n}\n//bcc模板結束 \n\n\nint main(){\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        int x,y;\n        ll c;\n        scanf(\"%d%d%lld\",&x,&y,&c);\n        addedge(x,y,c);\n    }\n    dijs1(1,d1);\n    dijs2(2,d2);\n    \n    //for(int i=1;i<=n;i++) printf(\"%d %d %d\\n\",i,d1[i],d2[i]);\n    \n    length=d1[2];\n    \n    for(int i=0;i<edges.size();i+=2){\n        Edge e=edges[i];\n        if(d1[e.from]+d2[e.to]+e.cost==length) G[e.from].push_back(e.to);\n    }\n    \n    find_bcc(n);\n    \n    //for(int i=1;i<=n;i++) for(map<int,bool>::iterator iter=bridge[i].begin();iter!=bridge[i].end();iter++){\n    //      if(iter->second) printf(\"%d %d\\n\",i,iter->first);}\n    \n    for(int i=0;i<edges.size();i+=2){\n        Edge e=edges[i];\n        if(d1[e.from]+d2[e.to]+e.cost==length&&bridge[e.from][e.to]){\n            printf(\"SAD\\n\");\n            continue;\n        }\n        if(d1[e.to]+d2[e.from]+e.cost<length){\n            printf(\"HAPPY\\n\");\n            continue;\n        }\n        printf(\"SOSO\\n\");\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream&\noperator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream&\noperator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n    \n    // debug(dist[1]);\n    // rep(i, N) {\n    //     debug(i);\n    //     for(auto e: shortest_graph[i]) {\n    //         cerr << e.from << \" -> \" << e.to << \" : \" << e.cost << endl;\n    //     }\n    // }\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i)) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, 1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    cnt[v] += p;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, cnt[v] });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd && dist1[u] + cost + dist2[v] > orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && cnt1[u] * cnt2[v] == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define SZ 131072\n#define pli pair<long long,int>\nusing namespace std;\nint n, m, Route[101000], PP[101000], ord[101000];\nvector<int>E[101000], L[101000], Num[101000], T[101000];\npriority_queue<pli>PQ;\nstruct Edge {\n\tint a, b, c;\n}Ed[101000];\nint Path[101000], chk[101000];\nlong long D[101000], D2[101000];\nvoid Ins(int a, long long d, int pp) {\n\tif (D[a] <= d)return;\n\tD[a] = d;\n\tPath[a] = pp;\n\tPQ.push(pli{ -d,a });\n}\nvoid Dijk(int st) {\n\tint i, a;\n\tfor (i = 1; i <= n; i++)D[i] = 1e18, Path[i] = -1;\n\tIns(st, 0, 0);\n\twhile (!PQ.empty()) {\n\t\tpli tp = PQ.top();\n\t\tPQ.pop();\n\t\tif (D[tp.second] != -tp.first)continue;\n\t\ta = tp.second;\n\t\tfor (i = 0; i < E[a].size(); i++) {\n\t\t\tIns(E[a][i], D[a] + L[a][i], Num[a][i]);\n\t\t}\n\t}\n}\nvoid DFS(int a, int pp) {\n\tint i;\n\tif (Route[a])pp = a;\n\tPP[a] = pp;\n\tfor (i = 0; i < T[a].size(); i++) {\n\t\tDFS(T[a][i], pp);\n\t}\n}\nint cnt;\nlong long IT[SZ + SZ];\nvoid Put(int b, int e, long long x) {\n\tb += SZ, e += SZ;\n\twhile (b <= e) {\n\t\tIT[b] = min(IT[b], x);\n\t\tIT[e] = min(IT[e], x);\n\t\tb = (b + 1) >> 1, e = (e - 1) >> 1;\n\t}\n}\nvoid Add(int a, int b, int c) {\n\tif (D[a] > 5e17 || D2[b] > 5e17)return;\n\tif (PP[a] > PP[b])Put(PP[b], PP[a] - 1, D[a] + D2[b] + c);\n}\nint main() {\n\tint i, a, b, c;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i < SZ + SZ; i++)IT[i] = 1e18;\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tE[b].push_back(a);\n\t\tL[b].push_back(c);\n\t\tNum[b].push_back(i);\n\t\tEd[i] = { a,b,c };\n\t}\n\tDijk(2);\n\tfor (i = 1; i <= n; i++)D2[i] = D[i], E[i].clear(),L[i].clear(), Num[i].clear();\n\tfor (i = 0; i < m; i++) {\n\t\ta = Ed[i].a, b = Ed[i].b, c = Ed[i].c;\n\t\tE[a].push_back(b);\n\t\tL[a].push_back(c);\n\t\tNum[a].push_back(i);\n\t}\n\tDijk(1);\n\ta = 2;\n\twhile (a != 1) {\n\t\tRoute[a] = ++cnt;\n\t\tchk[Path[a]] = 1;\n\t\tT[Ed[Path[a]].a].push_back(a);\n\t\ta = Ed[Path[a]].a;\n\t}\n\tRoute[a] = ++cnt;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (Path[i] != -1)T[Ed[Path[i]].a].push_back(i);\n\t}\n\tDFS(1, 1);\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i])continue;\n\t\tAdd(Ed[i].a, Ed[i].b, Ed[i].c);\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i]) {\n\t\t\tint t = SZ + min(Route[Ed[i].a], Route[Ed[i].b]);\n\t\t\tlong long rr = 1e18;\n\t\t\twhile (t) {\n\t\t\t\trr = min(rr, IT[t]);\n\t\t\t\tt >>= 1;\n\t\t\t}\n\t\t\tif (rr == D[2])printf(\"SOSO\\n\");\n\t\t\telse printf(\"SAD\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (D[Ed[i].b] + D2[Ed[i].a] + Ed[i].c < D[2])printf(\"HAPPY\\n\");\n\t\t\telse printf(\"SOSO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fi first\n#define sc second\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000013\nint n,m;\nvector<P>edge[100005],redge[100005];\nll dist[100005]; ll way[100005];\nll rdist[100005]; ll rway[100005];\nint x[100005],y[100005],z[100005];\nint main(){\n\tcin>>n>>m;\n\trep(i,m){\n\t\tint a,b,c; scanf(\"%d%d%d\",&a,&b,&c);\n\t\tedge[a].pb(mp(b,c));\n\t\tredge[b].pb(mp(a,c));\n\t\tx[i] = a;y[i] = b;z[i] = c;\n\t}\n\tfor(int i=1;i<=n;i++) dist[i] = rdist[i] = 1e18;\n\tpriority_queue<pair<ll,int>,vector<pair<ll,int> >, greater<pair<ll,int> > >que;\n\tque.push(mp(0,1)); dist[1] = 0; way[1] = 1;\n\twhile(!que.empty()){\n\t\tpair<ll,int>p = que.top(); que.pop();\n\t\tif(p.fi != dist[p.sc]) continue;\n\t\trep(i,edge[p.sc].size()){\n\t\t\tint x = edge[p.sc][i].fi;\n\t\t\tint add = edge[p.sc][i].sc;\n\t\t\tif(dist[x] > dist[p.sc]+add){\n\t\t\t\tdist[x] = dist[p.sc]+add;\n\t\t\t\tway[x] = way[p.sc];\n\t\t\t\tque.push(mp(dist[x],x));\n\t\t\t}\n\t\t\telse if(dist[x] == dist[p.sc]+add){\n\t\t\t\tway[x] = (way[x]+way[p.sc])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tque.push(mp(0,2)); rdist[2] = 0; rway[2] = 1;\n\twhile(!que.empty()){\n\t\tpair<ll,int>p = que.top(); que.pop();\n\t\tif(p.fi != rdist[p.sc]) continue;\n\t\trep(i,redge[p.sc].size()){\n\t\t\tint x = redge[p.sc][i].fi;\n\t\t\tint add = redge[p.sc][i].sc;\n\t\t\tif(rdist[x] > rdist[p.sc]+add){\n\t\t\t\trdist[x] = rdist[p.sc]+add;\n\t\t\t\trway[x] = rway[p.sc];\n\t\t\t\tque.push(mp(rdist[x],x));\n\t\t\t}\n\t\t\telse if(rdist[x] == rdist[p.sc]+add){\n\t\t\t\trway[x] = (rway[x]+rway[p.sc])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tassert(dist[2] == rdist[1]);\n\t//cout << way[2] << dist[2] << endl;\n\trep(i,m){\n\t\tll a = dist[y[i]];\n\t\tll b = rdist[x[i]];\n\t\tll c = way[x[i]];\n\t\tll d = rway[y[i]];\n\t\tif(a+b+z[i] < dist[2]) puts(\"HAPPY\");\n\t\telse if(a+b+z[i] == dist[2]) puts(\"SOSO\");\n\t\telse{\n\t\t\tif(dist[x[i]]+rdist[y[i]]+z[i]==dist[2] && c*d%mod == way[2]) puts(\"SAD\");\n\t\t\telse puts(\"SOSO\");\n\t\t}\n\t}\n}\n\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst long long mod = 2e9 + 89;\nconst long long inf = 1e18;\n\n/****** Tarjan’s SCC *******/\nvector< int > num, low, S, vis, comp, adj[N];\nint cntr, numCC;\n\nvoid tarjanSCC(int v, int bef = -1) {\n\tlow[v] = num[v] = ++cntr;\n\tvis[v] = 1;\n\tS.push_back(v);\n\tfor(auto u : adj[v]) {\n\t\tif (u == bef) continue;\n\t\tif(num[u] == -1)\n\t\t\ttarjanSCC(u, v);\n\t\tif(vis[u])\n\t\t\tlow[v] = min(low[v], low[u]);\n\t}\n\tif(low[v] == num[v]) {\n\t\tnumCC++;\n\t\twhile(1) {\n\t\t\tint u = S.back(); S.pop_back(); vis[u] = 0;\n\t\t\tcomp[u] = numCC;\n\t\t\tif(u == v)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid dijkstra(int start, long long* d, vector<tuple<int, int, int>> edge[N]) {\n\tfill(d, d + N, inf);\n\td[start] = 0;\n\tpriority_queue<pair<long long, int>> pq;\n\tpq.emplace(-d[start], start);\n\twhile (!pq.empty()) {\n\t\tlong long cost;\n\t\tint now;\n\t\ttie(cost, now) = pq.top();\n\t\tpq.pop();\n\t\tcost = -cost;\n\t\tif (d[now] != cost) continue;\n\t\tfor (auto it : edge[now]) {\n\t\t\tlong long add; int near;\n\t\t\ttie(near, add, ignore) = it;\n\t\t\tlong long ncos = cost + add;\n\t\t\tif (ncos < d[near]) {\n\t\t\t\td[near] = ncos;\n\t\t\t\tpq.emplace(-d[near], near);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long d[N], drev[N];\nint u[N], v[N], w[N];\nvector<tuple<int, int, int>> edge[N];           // node - cost - id\nvector<tuple<int, int, int>> rev[N];            // node - cost - id\nbool good[N], done[N];\n\nvoid dfs(int now) {\n\tif (done[now]) return;\n\tdone[now] = 1;\n\tfor (auto it : rev[now]) {\n\t\tint to, cost, id;\n\t\ttie(to, cost, id) = it;\n\t\tif (d[to] + cost == d[now]) {\n\t\t\tgood[id] = 1;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", u + i, v + i, w + i);\n\t\tedge[u[i]].emplace_back(v[i], w[i], i);\n\t\trev[v[i]].emplace_back(u[i], w[i], i);\n\t}\n\tdijkstra(1, d, edge);\n\tdijkstra(2, drev, rev);\n\n\tdfs(2);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (good[i]) {\n\t\t\tadj[u[i]].push_back(v[i]);\n\t\t\tadj[v[i]].push_back(u[i]);\n\t\t}\n\t}\n\tnum.assign(n + 1, -1);\n\tlow.assign(n + 1, 0);\n\tvis.assign(n + 1, 0);\n\tcomp.assign(n + 1, -1);\n\tcntr = numCC = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(num[i] == -1)\n\t\t\ttarjanSCC(i);\n\n\t/*\n\t\t puts(\"d\");\n\t\t for (int i = 1; i <= n; i++) printf(\"%lld \", d[i]); printf(\"\\n\");\n\t\t puts(\"good\");\n\t\t for (int i = 0; i < m; i++) printf(\"%d \", good[i]); printf(\"\\n\");\n\t\t puts(\"comp\");\n\t\t for (int i = 1; i <= n; i++) printf(\"%d \", comp[i]); printf(\"\\n\");\n\t\t */\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (d[v[i]] + drev[u[i]] + w[i] < d[2]) {\n\t\t\tputs(\"HAPPY\");\n\t\t} else if (good[i] && comp[u[i]] != comp[v[i]]) {\n\t\t\tputs(\"SAD\");\n\t\t} else {\n\t\t\tputs(\"SOSO\");\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\nconstexpr ll inf = ll(1e18) + 9;\n\nvector<ll> dijkstra(vector<vector<pair<int, ll> > > const & g, int root) {\n    vector<ll> dist(g.size(), inf);\n    priority_queue<pair<ll, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        ll dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; ll cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n\npair<int, vector<int> > decompose_to_two_edge_connected_components(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> imos(n); { // imos[i] == 0  iff  the edge i -> parent is a bridge\n        vector<char> used(n); // 0: unused ; 1: exists on stack ; 2: removed from stack\n        function<void (int, int)> go = [&](int i, int parent) {\n            used[i] = 1;\n            for (int j : g[i]) if (j != parent) {\n                if (used[j] == 0) {\n                    go(j, i);\n                    imos[i] += imos[j];\n                } else if (used[j] == 1) {\n                    imos[i] += 1;\n                    imos[j] -= 1;\n                }\n            }\n            used[i] = 2;\n        };\n        REP (i, n) if (used[i] == 0) {\n            go(i, -1);\n        }\n    }\n    int size = 0;\n    vector<int> component_of(n, -1); {\n        function<void (int)> go = [&](int i) {\n            for (int j : g[i]) if (component_of[j] == -1) {\n                component_of[j] = imos[j] == 0 ? size ++ : component_of[i];\n                go(j);\n            }\n        };\n        REP (i, n) if (component_of[i] == -1) {\n            component_of[i] = size ++;\n            go(i);\n        }\n    }\n    return { size, move(component_of) };\n}\n\nenum result_t { HAPPY, SOSO, SAD };\nconstexpr int start = 0;\nconstexpr int goal = 1;\nint main() {\n    // input\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<tuple<int, int, int> > edges(m);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        edges[i] = make_tuple(a, b, c);\n    }\n    // solve\n    vector<vector<pair<int, ll >> > g(n);\n    vector<vector<pair<int, ll >> > rev_g(n);\n    map<tuple<int, int, int>, int> count_edges;\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        g[a].emplace_back(b, c);\n        rev_g[b].emplace_back(a, c);\n        count_edges[edge] += 1;\n    }\n    auto dist = dijkstra(g, start);\n    auto rev_dist = dijkstra(rev_g, goal);\n    vector<vector<int> > h(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            if (dist[i] + cost == dist[j]) {\n                h[i].push_back(j);\n            }\n        }\n    }\n    auto component_of = decompose_to_two_edge_connected_components(h).second;\n    // output\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        result_t result =\n            count_edges[edge] >= 2 ? SOSO :\n            dist[a] == inf or rev_dist[b] == inf ? SOSO :\n            dist[b] + c + rev_dist[a] <  dist[goal] ? HAPPY :\n            dist[b] + c + rev_dist[a] == dist[goal] ? SOSO :\n            dist[a] + c + rev_dist[b] != dist[goal] ? SOSO :\n            component_of[a] != component_of[b] ? SAD :\n            SOSO;\n        printf(\"%s\\n\",\n            result == HAPPY ? \"HAPPY\" :\n            result == SOSO ? \"SOSO\" :\n            result == SAD ? \"SAD\" :\n            \"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define SZ 131072\n#define pli pair<long long,int>\nusing namespace std;\nint n, m, Route[101000], PP[101000], ord[101000];\nvector<int>E[101000], L[101000], Num[101000], T[101000];\npriority_queue<pli>PQ;\nstruct Edge {\n\tint a, b, c;\n}Ed[101000];\nint Path[101000], chk[101000];\nlong long D[101000], D2[101000];\nvoid Ins(int a, long long d, int pp) {\n\tif (D[a] <= d)return;\n\tD[a] = d;\n\tPath[a] = pp;\n\tPQ.push(pli{ -d,a });\n}\nvoid Dijk(int st) {\n\tint i, a;\n\tfor (i = 1; i <= n; i++)D[i] = 1e18, Path[i] = -1;\n\tIns(st, 0, 0);\n\twhile (!PQ.empty()) {\n\t\tpli tp = PQ.top();\n\t\tPQ.pop();\n\t\tif (D[tp.second] != -tp.first)continue;\n\t\ta = tp.second;\n\t\tfor (i = 0; i < E[a].size(); i++) {\n\t\t\tIns(E[a][i], D[a] + L[a][i], Num[a][i]);\n\t\t}\n\t}\n}\nvoid DFS(int a, int pp) {\n\tint i;\n\tif (Route[a])pp = Route[a];\n\tPP[a] = pp;\n\tfor (i = 0; i < T[a].size(); i++) {\n\t\tDFS(T[a][i], pp);\n\t}\n}\nint cnt;\nlong long IT[SZ + SZ];\nvoid Put(int b, int e, long long x) {\n\tb += SZ, e += SZ;\n\twhile (b <= e) {\n\t\tIT[b] = min(IT[b], x);\n\t\tIT[e] = min(IT[e], x);\n\t\tb = (b + 1) >> 1, e = (e - 1) >> 1;\n\t}\n}\nvoid Add(int a, int b, int c) {\n\tif (D[a] > 5e17 || D2[b] > 5e17)return;\n\tif (!PP[a] || !PP[b])return;\n\tif (PP[a] > PP[b])Put(PP[b], PP[a] - 1, D[a] + D2[b] + c);\n}\nint main() {\n\tint i, a, b, c;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i < SZ + SZ; i++)IT[i] = 1e18;\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tE[b].push_back(a);\n\t\tL[b].push_back(c);\n\t\tNum[b].push_back(i);\n\t\tEd[i] = { a,b,c };\n\t}\n\tDijk(2);\n\tfor (i = 1; i <= n; i++)D2[i] = D[i], E[i].clear(),L[i].clear(), Num[i].clear();\n\tfor (i = 0; i < m; i++) {\n\t\ta = Ed[i].a, b = Ed[i].b, c = Ed[i].c;\n\t\tE[a].push_back(b);\n\t\tL[a].push_back(c);\n\t\tNum[a].push_back(i);\n\t}\n\tDijk(1);\n\ta = 2;\n\twhile (a != 1) {\n\t\tRoute[a] = ++cnt;\n\t\tchk[Path[a]] = 1;\n\t\ta = Ed[Path[a]].a;\n\t}\n\tRoute[a] = ++cnt;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (Path[i] != -1)T[Ed[Path[i]].a].push_back(i);\n\t}\n\tDFS(1, 0);\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i])continue;\n\t\tAdd(Ed[i].a, Ed[i].b, Ed[i].c);\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i]) {\n\t\t\tint t = SZ + min(Route[Ed[i].a], Route[Ed[i].b]);\n\t\t\tlong long rr = 1e18;\n\t\t\twhile (t) {\n\t\t\t\trr = min(rr, IT[t]);\n\t\t\t\tt >>= 1;\n\t\t\t}\n\t\t\tif (rr == D[2])printf(\"SOSO\\n\");\n\t\t\telse printf(\"SAD\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (D[Ed[i].b] + D2[Ed[i].a] + Ed[i].c < D[2])printf(\"HAPPY\\n\");\n\t\t\telse printf(\"SOSO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c;\n};\n\nstruct Node{\n\tint p,c;\n};\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint order[100010];\nint currentTime = 0;\nint dfs(int x, const vector< vector<Edge> > &g){\n\tvisited[x] = true;\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\n\tint ans = currentTime;\n\tfor( auto &&e : g[x] ){\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, g));\n\t\t}\n\t}\n\torder[x] = ans;\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\t--a,--b;\n\t\tes.push_back({a,b,c});\n\t\tg[a].push_back({a,b,c});\n\t\trg[b].push_back({b,a,c});\n\t}\n\n\tint S = 0;\n\tint G = 1;\n\tauto gDist = dijkstra(S, g);\n\tauto rgDist = dijkstra(G, rg);\n\t\n\tvector< vector<Edge> > dag(n);\n\tfor( auto e : es ){\n\t\tif( gDist[e.a] + e.c + rgDist[e.b] == gDist[G] ){\n\t\t\tdag[e.a].push_back(e);\n\t\t}\n\t}\n\tdfs(0, dag);\n\n\tfor( auto e : es ){\n\t\tif( gDist[e.b] + e.c + rgDist[e.a] < gDist[G] ){\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}else if( gDist[e.a] + e.c + rgDist[e.b] != gDist[G] ){\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}else if( !visited[e.a] || !visited[e.b] || order[e.a] >= order[e.b] ){\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}else{\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PP;\n\nclass getbridge{\npublic:\n\tstatic const int MAX=200000;\n\tvector<int> G[MAX];\n\tbool visited[MAX];\n\tint prenum[MAX],parent[MAX],lowest[MAX],timer;\n\tvector<P> bridge;\n\n\tvoid dfs(int v,int prev){\n\t\tprenum[v]=lowest[v]=timer;\n\t\ttimer++;\n\t\tvisited[v]=true;\n\n\t\tint next;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tnext=G[v][i];\n\t\t\tif(!visited[next]){\n\t\t\t\tparent[next]=v;\n\t\t\t\tdfs(next,v);\n\t\t\t\tlowest[v]=min(lowest[v],lowest[next]);\n\t\t\t\tif(prenum[v]<lowest[G[v][i]]){\n\t\t\t\t\t//printf(\"%d %d\\n\",v,G[v][i]);\n\t\t\t\t\tbridge.push_back(P(min(v,G[v][i]),max(v,G[v][i])));\n\t\t\t\t}\n\t\t\t}else if(next!=prev){\n\t\t\t\tlowest[v]=min(lowest[v],prenum[next]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tset<int> art_points(int N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvisited[i]=false;\n\t\t}\n\t\ttimer=1;\n\t\tdfs(0,-1);\n\n\t\tset<int> ap;\n\t\tint np=0;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tint p=parent[i];\n\t\t\tif(p==0)np++;\n\t\t\telse if(prenum[p]<lowest[i])ap.insert(p);\n\t\t}\n\t\tif(np>1)ap.insert(0);\n\t\treturn ap;\n\t}\n};\n\ngetbridge bri;\n\nint n,m;\nvector<P> G[100001];\nvector<P> rG[100001];\nll dist[100001];\nll cnt[100001];\nll dist2[100001];\nint a[100001],b[100001];\nll c[100001];\nset<PP> se;\nset<PP> multi;\nstack<int> s;\n\nvoid dijk(){\n\tfor(int i=0;i<n;i++){\n\t\tdist[i]=INF;\n\t}\n\tdist[0]=0;\n\tcnt[0]=1;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,0));\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tll co=p.first;\n\t\tif(co>dist[v])continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(dist[G[v][i].first]>dist[v]+G[v][i].second){\n\t\t\t\tdist[G[v][i].first]=dist[v]+G[v][i].second;\n\t\t\t\tcnt[G[v][i].first]=cnt[v];\n\t\t\t\tque.push(P(dist[G[v][i].first],G[v][i].first));\n\t\t\t}else if(dist[G[v][i].first]==dist[v]+G[v][i].second){\n\t\t\t\tcnt[G[v][i].first]+=cnt[v];\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool used[100001];\nvoid make_graph(){\n\tqueue<int> que;\n\tque.push(1);\n\tused[1]=true;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<rG[v].size();i++){\n\t\t\tint next=rG[v][i].first;\n\t\t\tif(dist[v]==dist[next]+rG[v][i].second){\n\t\t\t\tif(!used[next]){\n\t\t\t\t\tused[next]=true;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t\tbri.G[v].push_back(next);\n\t\t\t\tbri.G[next].push_back(v);\n\t\t\t\t//printf(\"%d %d\\n\",v,next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijk2(){\n\tfor(int i=0;i<n;i++){\n\t\tdist2[i]=INF;\n\t}\n\tdist2[1]=0;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,1));\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tll co=p.first;\n\t\tif(co>dist2[v])continue;\n\t\tfor(int i=0;i<rG[v].size();i++){\n\t\t\tif(dist2[rG[v][i].first]>dist2[v]+rG[v][i].second){\n\t\t\t\tdist2[rG[v][i].first]=dist2[v]+rG[v][i].second;\n\t\t\t\tque.push(P(dist2[rG[v][i].first],rG[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%lld\",&a[i],&b[i],&c[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\tif(se.find(PP(P(a[i],b[i]),c[i]))==se.end()){\n\t\t\tse.insert(PP(P(a[i],b[i]),c[i]));\n\t\t\tG[a[i]].push_back(P(b[i],c[i]));\n\t\t\trG[b[i]].push_back(P(a[i],c[i]));\n\t\t}else{\n\t\t\tmulti.insert(PP(P(a[i],b[i]),c[i]));\n\t\t}\n\t}\n\tdijk();\n\tif(dist[1]<INF){\n\t\tmake_graph();\n\t\tbri.art_points(n);\n\t\tsort(bri.bridge.begin(),bri.bridge.end());\n\t}\n\tdijk2();\n\tfor(int i=0;i<m;i++){\n\t\tll val=dist[b[i]];\n\t\tval+=dist2[a[i]];\n\t\tval+=c[i];\n\t\tif(val<dist[1]){\n\t\t\tputs(\"HAPPY\");\n\t\t}else if(dist[1]>=INF){\n\t\t\tputs(\"SAD\");\n\t\t}else if(val==dist[1]){\n\t\t\tputs(\"SOSO\");\n\t\t}else{\n\t\t\tif(dist[b[i]]-dist[a[i]]!=c[i]){\n\t\t\t\tputs(\"SOSO\");\n\t\t\t}else{\n\t\t\t\tif(multi.find(PP(P(a[i],b[i]),c[i]))!=multi.end()){\n\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t}else if(dist[a[i]]+c[i]+dist2[b[i]]==dist[1]){\n\t\t\t\t\tint v=lower_bound(bri.bridge.begin(),bri.bridge.end(),P(min(a[i],b[i]),max(a[i],b[i])))-bri.bridge.begin();\n\t\t\t\t\tif(v<bri.bridge.size() && bri.bridge[v]==P(min(a[i],b[i]),max(a[i],b[i]))){\n\t\t\t\t\t\tputs(\"SAD\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nvector<vector<pii> > G, rG;\nvector<vector<int> > I, rI;\nll C[100100], rC[100100];\nbool tmp[100100];\nbool bridge[100100];\nint lst[100100][3];\nmap<pii,pii> mul;\n\nvoid shortest(vector<vector<pii> > g, ll *c, int s) {\n\tfor(int i = 0; i < 100100; i++) {\n\t\tc[i] = 1e15;\n\t}\n\tc[s] = 0;\n\tpriority_queue<pli> q;\n\tq.push(pli(0,s));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(c[a.se] < -a.fi) continue;\n\t\tfor(int i = 0; i < g[a.se].size(); i++) {\n\t\t\tint v = g[a.se][i].fi;\n\t\t\tll t = -a.fi + g[a.se][i].se;\n\t\t\tif(c[v] > t) {\n\t\t\t\tc[v] = t;\n\t\t\t\tq.push(pli(-t, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mkbridge() {\n\tll sp = C[1];\n\tpriority_queue<pli> q;\n\tq.push(pli(0,0));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(tmp[a.se]) continue;\n\t\ttmp[a.se] = true;\n\t\tint id =-1;\n\t\tint src,dst;\n\t\tfor(int i = 0; i < G[a.se].size(); i++) {\n\t\t\tint v = G[a.se][i].fi;\n\t\t\tif(sp == C[a.se] + G[a.se][i].se + rC[v]) {\n\t\t\t\tq.push(pli(-C[v], v));\n\t\t\t\tid = I[a.se][i];\n\t\t\t\tsrc=a.se;\n\t\t\t\tdst=v;\n\t\t\t}\n\t\t}\n\t\tif(q.size() == 1 && id >= 0 && mul[pii(src,dst)].se == 1) {\n\t\t\tbridge[id] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tG.resize(n);\n\trG.resize(n);\n\tI.resize(n);\n\trI.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tG[a].push_back(pii(b,c));\n\t\trG[b].push_back(pii(a,c));\n\t\tI[a].push_back(i);\n\t\trI[b].push_back(i);\n\t\tlst[i][0] = a; lst[i][1] = b; lst[i][2] = c;\n\n\t\tif(mul.find(pii(a,b)) == mul.end())\n\t\t\tmul[pii(a,b)] = pii(c,1);\n\t\telse if(mul[pii(a,b)].fi == c)\n\t\t\tmul[pii(a,b)].se++;\n\t\telse if(mul[pii(a,b)].se > c)\n\t\t\tmul[pii(a,b)] = pii(c,1);\n\t}\n\tshortest(G,C,0);\n\tshortest(rG,rC,1);\n\tmkbridge();\n\n\tll sp = C[1];\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = lst[i][0]; b = lst[i][1]; c = lst[i][2];\n\t\tif(C[b] + c + rC[a] < sp) {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t\telse if(bridge[i] && C[b] + c + rC[a] > sp && sp != (ll)(1e15)) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, m;\nll dist_s[111111], dist_t[111111];\nint ans[111111], low[111111], num[111111], N;\nvector<vector<tuple<int,int,int>>> e, re, g;\n\nvoid rec(int cur, int pid){\n\tnum[cur] = low[cur] = ++N;\n\tvector<tuple<int,int,int>> es;\n\tfor(auto p : g[cur]){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\tif(id == pid) continue;\n\t\tif(num[to] == 0){\n\t\t\trec(to, id);\n\t\t\tlow[cur] = min(low[cur], low[to]);\n\t\t\tes.emplace_back(p);\n\t\t}\n\t\telse low[cur] = min(low[cur], num[to]);\n\t}\n\tfor(auto p : es){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t//dbg(cur, to, num[cur], low[to]);\n\t\tif(low[to] > num[cur]) ans[id] = 1;\n\t}\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m;\n\te.resize(n); re.resize(n); g.resize(n);\n\trep(i, m){\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\te[a].emplace_back(b, c, i);\n\t\tre[b].emplace_back(a, c, i);\n\t}\n\tauto dij = [](ll *dist, int s, const vector<vector<tuple<int,int,int>>> &e){\n\t\tpriority_queue<pair<ll,int>> q;\n\t\tq.emplace(0, s);\n\t\trep(i, n) dist[i] = 1e18;\n\t\tdist[s] = 0;\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint c; ll co;\n\t\t\ttie(co, c) = q.top(); q.pop();\n\t\t\tif(dist[c] < -co) continue;\n\t\t\t\n\t\t\tfor(auto to : e[c]){\n\t\t\t\tll nco = -co + get<1>(to);\n\t\t\t\tif(dist[get<0>(to)] <= nco) continue;\n\t\t\t\tdist[get<0>(to)] = -co + get<1>(to);\n\t\t\t\tq.emplace(co - get<1>(to), get<0>(to));\n\t\t\t}\n\t\t}\n\t};\n\tdij(dist_s, 0, e);\n\tdij(dist_t, 1, re);\n\t{\n\t\tll dist = dist_s[1];\n\t\trep(i, n) for(auto p : e[i]){\n\t\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t\tif(dist_s[i] + cost + dist_t[to] == dist){\n\t\t\t\tg[i].emplace_back(to, cost, id);\n\t\t\t\tg[to].emplace_back(i, cost, id);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans[id] = dist_s[to] + cost + dist_t[i] < dist ? -1 : 0;\n\t\t\t}\n\t\t}\n\t\trec(0, -1);\n\t\trep(i, m){\n\t\t\tif(ans[i] < 0) cout << \"HAPPY\" << endl;\n\t\t\telse cout << (ans[i] == 0 ? \"SOSO\" : \"SAD\") << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rre(i,r,l) for(int i=(r);i>=(l);i--)\n#define re(i,l,r) for(int i=(l);i<=(r);i++)\n#define Clear(a,b) memset(a,b,sizeof(a))\n#define inout(x) printf(\"%d\",(x))\n#define douin(x) scanf(\"%lf\",&x)\n#define strin(x) scanf(\"%s\",(x))\n#define op operator\ntypedef unsigned long long ULL;\ntypedef const int cint;\ntypedef long long LL;\nusing namespace std;\ntemplate<typename Q>\nvoid inin(Q &x)\n{\n\tx=0;int f=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\tx=f?-x:x;\n}\nstruct bian\n{\n\tint u,v,w;\n}bi[100010];\nint n,m,head[100010],Next[200020],zhi[200020],w[200020],cap[200020],id[200020],ed=1;\nint zai[100010];\nLL dis[100010],dis2[100010];\nvoid add(int a,int b,int c,int ID)\n{\n\tNext[++ed]=head[a],head[a]=ed,zhi[ed]=b,w[ed]=c,cap[ed]=1,id[ed]=ID;\n\tNext[++ed]=head[b],head[b]=ed,zhi[ed]=a,w[ed]=c,cap[ed]=0,id[ed]=ID;\n}\nqueue<int> q;\nbool bo[100010];\nvoid spfa(int s)\n{\n\tre(i,1,n)dis[i]=10000000000LL;dis[s]=0;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();bo[x]=0;\n\t\tfor(int i=head[x];i;i=Next[i])if((i&1)==0)\n\t\t{\n\t\t\tif(dis[zhi[i]]>dis[x]+w[i])\n\t\t\t{\n\t\t\t\tdis[zhi[i]]=dis[x]+w[i];\n\t\t\t\tif(!bo[zhi[i]]){q.push(zhi[i]),bo[zhi[i]]=1;}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid spfa2(int s)\n{\n\tre(i,1,n)dis2[i]=10000000000LL;dis2[s]=0;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();bo[x]=0;\n\t\tfor(int i=head[x];i;i=Next[i])if(i&1)\n\t\t{\n\t\t\tif(dis2[zhi[i]]>dis2[x]+w[i])\n\t\t\t{\n\t\t\t\tdis2[zhi[i]]=dis2[x]+w[i];\n\t\t\t\tif(!bo[zhi[i]]){q.push(zhi[i]),bo[zhi[i]]=1;}\n\t\t\t}\n\t\t}\n\t}\n}\nqueue<int> h;int di[100010];\nbool bfs(int s,int t)\n{\n\tClear(di,0);\n\tdis[s]=1;h.push(s);\n\twhile(!h.empty())\n\t{\n\t\tint x=h.front();h.pop();\n\t\tfor(int i=head[x];i;i=Next[i])if(zai[id[i]])\n\t\t\tif(cap[i]&&!di[zhi[i]])\n\t\t\t{\n\t\t\t\tdi[zhi[i]]=di[x]+1;\n\t\t\t\th.push(zhi[i]);\n\t\t\t}\n\t}\n\treturn di[t];\n}\nint cur[100010];\nint dfs(int x,int Max,int t)\n{\n\tif(x==t||!Max)return Max;\n\tint temp,ret=0;\n\tfor(int &i=cur[x];i;i=Next[i])if(zai[id[i]])\n\t\tif(cap[i]&&di[zhi[i]]==di[x]+1)\n\t\t{\n\t\t\ttemp=dfs(zhi[i],min(Max,cap[i]),t);\n\t\t\tret+=temp,Max-=temp;\n\t\t\tcap[i]-=temp,cap[i^1]+=temp;\n\t\t\tif(!Max)return ret;\n\t\t}\n\tif(!ret)di[x]=-1;\n\treturn ret;\n}\nint dinic(int s,int t)\n{\n\tint ret=0;\n\twhile(bfs(s,t))\n\t{\n\t\tre(i,1,n)cur[i]=head[i];\n\t\tret+=dfs(s,2147483647,t);\n\t}\n\treturn ret;\n}\nint zuida,bizai[100010];\nint main()\n{\n\tinin(n),inin(m);\n\tre(i,1,m)\n\t{\n\t\tinin(bi[i].u),inin(bi[i].v),inin(bi[i].w);\n\t\tadd(bi[i].u,bi[i].v,bi[i].w,i);\n\t}\n\tspfa(1);\n\tspfa2(2);\n\tre(i,1,m)if(dis[bi[i].u]+bi[i].w+dis2[bi[i].v]==dis[2])zai[i]=1;\n\tzuida=dinic(1,2);\n\tif(zuida==1)re(i,1,ed)\n\t{\n\t\ti++;\n\t\tif(!cap[i])bizai[id[i]]=1;\n\t}\n\tre(i,1,m)\n\t{\n\t\tint u=bi[i].u,v=bi[i].v;\n\t\tLL temp=dis[v]+bi[i].w+dis2[u];\n\t\tif(temp<dis[2]){cout<<\"HAPPY\\n\";continue;}\n\t\tif(bizai[i])\n\t\t{\n\t\t\tif(temp==dis[2]){cout<<\"SOSO\\n\";}\n\t\t\telse {cout<<\"SAD\\n\";}\n\t\t}\n\t\telse cout<<\"SOSO\\n\";\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M;\nint A[111111],B[111111],C[111111];\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\n\nvoid dijkstra(int s,vector<vpint>&G,vint &dist,vint &way){\n    dist=vint(N,INF);\n    way=vint(N);\n    dist[s]=0;\n    way[s]=1;\n    priority_queue<pint,vector<pint>,greater<pint>>que;\n    que.push({0,s});\n    while(que.size()){\n        int c,v;\n        tie(c,v)=que.top();\n        que.pop();\n        if(dist[v]<c)continue;\n        for(auto &e:G[v]){\n            if(dist[e.fi]<c+e.se)continue;\n            if(dist[e.fi]==c+e.se)add(way[e.fi],way[v]);\n            else{\n                dist[e.fi]=c+e.se;\n                way[e.fi]=way[v];\n                que.push({dist[e.fi],e.fi});\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin.tie(0);ios_base::sync_with_stdio(0);\n\n    cin>>N>>M;\n    rep(i,M){\n        cin>>A[i]>>B[i]>>C[i];\n        A[i]--;B[i]--;\n    }\n\n    vint dist0,dist1;\n    vint way0,way1;\n\n    vector<vpint>G0(N),G1(N);\n    rep(i,M){\n        G0[A[i]].pb({B[i],C[i]});\n        G1[B[i]].pb({A[i],C[i]});\n    }\n    dijkstra(0,G0,dist0,way0);\n    dijkstra(1,G1,dist1,way1);\n\n\n    int X=dist0[1];\n\n    rep(i,M){\n        int tmp=dist0[B[i]]+C[i]+dist1[A[i]];\n        if(tmp<X){\n            cout<<\"HAPPY\"<<endl;\n        }\n        else if(dist0[A[i]]+C[i]+dist1[B[i]]>X){\n            cout<<\"SOSO\"<<endl;\n        }\n        else if(way0[A[i]]*way1[B[i]]%mod==way0[1]){\n            cout<<\"SAD\"<<endl;\n        }\n        else{\n            cout<<\"SOSO\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nconst int mod = 1000000021;\nconst long long inf = 1LL << 61;\nstruct edge { int to, cost, id; };\nstruct state { int pos; long long cost; };\nbool operator<(const state& s1, const state& s2) { return s1.cost > s2.cost; }\nint N, M, dp[100009], dp2[100009], va[100009];\nvector<long long> shortest_path(vector<vector<edge> > g, int src) {\n\tvector<long long> ret(g.size(), inf); ret[src] = 0;\n\tpriority_queue<state> que; que.push(state{ src, 0 });\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (edge e : g[u]) {\n\t\t\tlong long nd = ret[u] + e.cost;\n\t\t\tif (ret[e.to] > nd) {\n\t\t\t\tret[e.to] = nd;\n\t\t\t\tque.push(state{ e.to, nd });\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\tvector<int> a(M), b(M), c(M);\n\tvector<vector<edge> > g(N);\n\tvector<vector<edge> > rg(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t\tg[a[i]].push_back(edge{ b[i], c[i], i });\n\t\trg[b[i]].push_back(edge{ a[i], c[i], i });\n\t}\n\tvector<long long> ds = shortest_path(g, 0);\n\tvector<long long> dt = shortest_path(rg, 1);\n\tvector<bool> ok(200009);\n\tvector<vector<int> > sg(N), sr(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ds[a[i]] + c[i] == ds[b[i]]) {\n\t\t\tok[i] = true;\n\t\t\tsg[a[i]].push_back(b[i]);\n\t\t\tsr[b[i]].push_back(a[i]);\n\t\t}\n\t}\n\tpriority_queue<state> que; que.push(state{ 0, 0 }); dp[0] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (int i : sg[u]) {\n\t\t\tdp[i] += dp[u];\n\t\t\tif (dp[i] >= mod) dp[i] -= mod;\n\t\t\tque.push(state{ i, ds[i] });\n\t\t}\n\t}\n\tque.push(state{ 1, 0 }); dp2[1] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (int i : sr[u]) {\n\t\t\tdp2[i] += dp2[u];\n\t\t\tif (dp2[i] >= mod) dp2[i] -= mod;\n\t\t\tque.push(state{ i, dt[i] });\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) va[i] = 1LL * dp[i] * dp2[i] % mod;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!ok[i]) {\n\t\t\tcout << (ds[b[i]] + dt[a[i]] + c[i] < ds[1] ? \"HAPPY\\n\" : \"SOSO\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (ds[b[i]] + dt[a[i]] + c[i] < ds[1]) cout << \"HAPPY\\n\";\n\t\t\telse if (ds[b[i]] + dt[a[i]] + c[i] == ds[1]) cout << \"SOSO\\n\";\n\t\t\telse {\n\t\t\t\tif (va[a[i]] == va[0] && va[b[i]] == va[0]) cout << \"SAD\\n\";\n\t\t\t\telse cout << \"SOSO\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 100000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  dist[s] = 0;\n  cnt[s] = 1;\n\n  priority_queue<state> q;\n  q.push((state) { 0, s });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v;\n    q.pop();\n\n    if(dist[v] < d) continue;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] == d + c) {\n        (cnt[u] += cnt[v]) %= MOD;\n      } else if(dist[u] > d + c) {\n        dist[u] = d + c;\n        cnt[u] = cnt[v];\n        q.push((state) { d + c, u });\n      }\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1});\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    (cnt[v] += (p != -1 ? cnt[p] : 1))%=mod;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, v }); // modified\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v])%mod == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nint min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\tdijkstra_NORMAL();\n\tdijkstra_REVERSE();\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\tint from,to;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*if(in_MIN_PATH[i] == false){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}*/\n\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nint min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\tdijkstra_NORMAL();\n\tdijkstra_REVERSE();\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\tint from,to;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define SZ(x) (int)(x.size())\n \nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n \ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n \ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n \n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n \n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n \n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n \n  operator int() const { return to; }\n};\n \ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n \ntemplate< typename T >\nvector< T > dijkstra(WeightedGraph< T > &g, int s) {\n  const auto INF = numeric_limits< T >::max();\n  vector< T > dist(g.size(), INF);\n \n  using Pi = pair< T, int >;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  dist[s] = 0;\n  que.emplace(dist[s], s);\n  while(!que.empty()) {\n    T cost;\n    int idx;\n    tie(cost, idx) = que.top();\n    que.pop();\n    if(dist[idx] < cost) continue;\n    for(auto &e : g[idx]) {\n      auto next_cost = cost + e.cost;\n      if(dist[e.to] <= next_cost) continue;\n      dist[e.to] = next_cost;\n      que.emplace(dist[e.to], e.to);\n    }\n  }\n  return dist;\n}\n \ntemplate< typename G >\nstruct LowLink {\n  const G &g;\n  vector< int > used, ord, low;\n  vector< int > articulation;\n  vector< pair< int, int > > bridge;\n \n  LowLink(const G &g) : g(g) {}\n \n  int dfs(int idx, int k, int par) {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n    bool is_articulation = false;\n    int cnt = 0;\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        ++cnt;\n        k = dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        is_articulation |= ~par && low[to] >= ord[idx];\n        if(ord[idx] < low[to]) bridge.emplace_back(minmax(idx, (int) to));\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n    is_articulation |= par == -1 && cnt > 1;\n    if(is_articulation) articulation.push_back(idx);\n    return k;\n  }\n \n  virtual void build() {\n    used.assign(g.size(), 0);\n    ord.assign(g.size(), 0);\n    low.assign(g.size(), 0);\n    int k = 0;\n    for(int i = 0; i < g.size(); i++) {\n      if(!used[i]) k = dfs(i, k, -1);\n    }\n  }\n};\n \n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n \n  int n, m; cin >> n >> m;\n  \n  WeightedGraph<ll> g(n), revg(n);\n  Edges<ll> edges;\n  for(int i=0;i<m;++i) {\n    int a, b; ll c; cin >> a >> b >> c;\n    a--; b--;\n    g[a].emplace_back(edge<ll>(a, b, c));\n    revg[b].emplace_back(edge<ll>(b, a, c));\n    edges.emplace_back(edge<ll>(a, b, c));\n  }\n \n  vector<ll> d = dijkstra(g, 0);\n  vector<ll> revd = dijkstra(revg, 1);\n \n  // printv(d);\n  // printv(revd);\n \n  ll mi = d[1];\n \n  UnWeightedGraph mig(n);\n  for(int i=0;i<m;++i) {\n    int a = edges[i].src, b = edges[i].to;\n    ll c = edges[i].cost;\n    if(d[a] + c + revd[b] == mi) {\n      mig[a].emplace_back(b);\n      mig[b].emplace_back(a);\n    }\n  }\n \n  LowLink<UnWeightedGraph> lowlink(mig);\n  lowlink.build();\n  set<P> br;\n  for(const auto &e: lowlink.bridge) {\n    //cout << e.first << \":\" << e.second << endl;\n    br.insert(e);\n  }\n \n  for(int i=0;i<m;++i) {\n    int a = edges[i].src, b = edges[i].to;\n    ll c = edges[i].cost;\n \n    if(d[b] != LLONG_MAX && revd[a] != LLONG_MAX && d[b] + c + revd[a] < mi) {\n      cout << \"HAPPY\" << endl;\n    } else if(d[a] + c + revd[b] == mi) {\n      //cout << a << \":\" << b << endl;\n      if(br.find(make_pair(a, b)) == br.end() && br.find(make_pair(b, a)) == br.end()) {\n        cout << \"SOSO\" << endl;\n      } else {\n        cout << \"SAD\" << endl;\n      }\n    } else {\n      cout << \"SOSO\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(int to, int cost):to(to), cost(cost){}\n};\nusing Graph = vector<vector<edge>>;\n\nvint dijkstra(int s, const Graph& g) {\n  int n = g.size();\n  vint res(n, inf);\n  priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n  res[s] = 0;\n  que.emplace(0, s);\n  while(!que.empty()) {\n    Pi p = que.top(); que.pop();\n    int v = p.second;\n    if(res[v] < p.first) continue;\n    for(auto&& e : g[v]) {\n      if(res[v]+e.cost < res[e.to]) {\n\tres[e.to] = res[v]+e.cost;\n\tque.emplace(res[e.to], e.to);\n      }\n    }\n  }\n\n  return res;\n}\n\n#define MAX_N 100010\n\nint ord[MAX_N], low[MAX_N];\nvoid dfs(int u, int p, int k, const Graph& g) {\n  ord[u] = low[u] = k++;\n  for(auto&& e : g[u]) {\n    if(e.to == p) continue;\n    if(ord[e.to] == -1) {\n      dfs(e.to, u, k, g);\n      chmin(low[u], low[e.to]);\n    } else {\n      chmin(low[u], ord[e.to]);\n    }\n  }\n}\nbool is_bridge(int u, int v) {\n  if(ord[u] > ord[v]) swap(u, v);\n  return ord[u] < low[v];\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph rg(n);\n  vint a(m), b(m), c(m);\n  rep(i, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    --a[i], --b[i];\n    g[a[i]].emplace_back(b[i], c[i]);\n    rg[b[i]].emplace_back(a[i], c[i]);\n  }\n  vint d0 = dijkstra(0, g);\n  vint d1 = dijkstra(1, rg);\n  Graph h(n);\n  vint used(m, 0);\n  rep(i, m) {\n    //cout<<d0[a[i]]<<\" \"<<d1[b[i]]<<\" \"<<c[i]<<endl;\n    if(d0[a[i]]+d1[b[i]]+c[i] == d0[1]) {\n      h[a[i]].emplace_back(b[i], 0);\n      h[b[i]].emplace_back(a[i], 0);\n      used[i] = 1;\n    }\n  }\n  memset(ord, -1, sizeof(ord));\n  dfs(0, -1, 0, h);\n  rep(i, m) {\n    int d = d0[b[i]]+d1[a[i]]+c[i];\n    //cout<<d<<\" \"<<d0[1]<<endl;\n    /*\n    if(d == d0[1]) {\n      cout << \"SOSO\" << endl;\n    } else if(d < d0[1]) {\n      cout << \"HAPPY\" << endl;\n    } else if(!used[i]) {\n      cout << \"SOSO\" << endl;\n    } else if(is_bridge(a[i], b[i])) {\n      cout << \"SAD\" << endl;\n    } else {\n      cout << \"SOSO\" << endl;\n    }\n    */\n    if(used[i]) {\n      if(is_bridge(a[i], b[i])) cout << \"SAD\" << endl;\n      else cout << \"SOSO\" << endl;\n    } else {\n      if(d < d0[1]) cout << \"HAPPY\" << endl;\n      else cout << \"SOSO\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\nconst ll INF=0x3f3f3f3f;\nstruct HeapNode\n{\n    ll d;\n    int u;\n    bool operator<(const HeapNode &rhs)const\n    {\n        return d>rhs.d;\n    }\n};\nstruct Edge\n{\n    int from,to;\n    ll cost;\n};\nstruct Dij\n{\n    int n,m;\n    vector<int>G[maxn];\n    vector<int>G1[maxn];\n    vector<Edge>edges;\n    vector<Edge>edges1;\n    bool done[maxn];\n    ll d[maxn];\n    vector<int>p[maxn];\n    vector<int>p2[maxn];\n    ll d1[maxn];\n    void init(int n)\n    {\n        this->n=n;\n        for(int i=0;i<=n;i++)\n        {\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    void addedge(int from,int to,int cost)\n    {\n        edges.push_back(Edge{from,to,cost});\n        edges1.push_back((Edge){to,from,cost});\n        m=edges.size();\n        G[from].push_back(m-1);\n        G1[to].push_back(m-1);\n    }\n    void dij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d[i]=INF;\n        d[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G[u].size();i++)\n            {\n                Edge &e=edges[G[u][i]];\n                if(d[e.to]>d[u]+e.cost)\n                {\n                    p[e.to].clear();\n                    p[e.to].push_back(u);\n                    d[e.to]=d[u]+e.cost;\n                    Q.push((HeapNode){d[e.to],e.to});\n                }\n                else if(d[e.to]==d[u]+e.cost)\n                {\n                    p[e.to].push_back(u);\n                }\n            }\n        }\n    }\n\n    void redij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d1[i]=INF;\n        d1[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G1[u].size();i++)\n            {\n                Edge &e=edges1[G1[u][i]];\n                //cout<<e.to<<endl;\n                if(d1[e.to]>d1[u]+e.cost)\n                {\n                    p2[e.to].clear();\n                    p2[e.to].push_back(u);\n                    d1[e.to]=d1[u]+e.cost;\n                    Q.push((HeapNode){d1[e.to],e.to});\n                }\n                else if(d1[e.to]==d1[u]+e.cost)\n                {\n                    p2[e.to].push_back(u);\n                }\n            }\n        }\n    }\n}D;\n\nstruct node\n{\n    int x,y;\n    ll z;\n}s[maxn];\nint c[maxn];\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    D.init(n);\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].z);\n        D.addedge(s[i].x,s[i].y,s[i].z);\n    }\n    D.dij(1);\n    D.redij(2);\n    int num=D.p[2].size();\n\n    for(int i=0;i<m;i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[y]+D.d1[x]+z<D.d[2])\n        {\n            printf(\"HAPPY\\n\");\n        }\n        else\n        {\n            //int num1=D.p[y].size();\n           // cout<<c[x]<<endl;\n          // cout<<D.d[x]<<\" \"<<D.d1[y]<<\" \"<<z<<\" \"<<D.p[x].size()<<\" \"<<D.p2[y].size()<<endl;\n            if(D.d[x]+D.d1[y]+z==D.d[2]&&max(D.p[x].size(),D.p2[y].size())==num)\n            {\n\n                printf(\"SAD\\n\");\n            }\n            else\n            {\n                printf(\"SOSO\\n\");\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nint min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\nvector<int> SHORTEST_EDGES[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tSHORTEST_EDGES[next_node].clear();\n\t\t\t\t\tSHORTEST_EDGES[next_node].push_back(G[Q.top().node_id][i].edge_id); //最小エッジ群に今回のパスを追加\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\n\t\t\t\t}else if(min_cost[next_node] == Q.top().sum_cost+G[Q.top().node_id][i].cost){ //過去最少タイである場合\n\n\t\t\t\t\tSHORTEST_EDGES[next_node].push_back(G[Q.top().node_id][i].edge_id); //最小エッジ群に今回のパスを追加するのみ\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint tmp_id;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\t//最小経路で使った辺により、最短経路木を構築する\n\tfor(int i = 0; i < V; i++){\n\n\t\tfor(int k = 0; k < SHORTEST_EDGES[i].size(); i++){\n\t\t\ttmp_id =  SHORTEST_EDGES[i][k];\n\t\t\tin_MIN_PATH[tmp_id] = true;\n\t\t\t//printf(\"エッジ%dは最小経路に含まれている\\n\",tmp_id);\n\t\t\tMIN_G[edge[tmp_id].from].push_back(Info(edge[tmp_id].to,edge[tmp_id].cost,tmp_id));\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to,goal = 1;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[goal] == BIG_NUM){ //元々ゴールに行けない場合\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < BIG_NUM){ //新たに行けるようになる\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to] && min_cost[from]+edge[i].cost+rev_min_cost[to] == min_cost[goal]){ //最短経路上のブリッジ、かつcost(start-from)++cost(to-goal)がmin_cost[goal]と等しい\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//変わらない\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, m, reachable[111111];\nll dist[111111];\nint ans[111111], low[111111], num[111111], N;\nvector<vector<tuple<int,int,int>>> e, g;\n\nvoid rec(int cur, int pid){\n\tnum[cur] = low[cur] = ++N;\n\tvector<tuple<int,int,int>> es;\n\tfor(auto p : g[cur]){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\tif(id == pid) continue;\n\t\tif(num[to] == 0){\n\t\t\trec(to, id);\n\t\t\tlow[cur] = min(low[cur], low[to]);\n\t\t\tes.emplace_back(p);\n\t\t}\n\t\telse low[cur] = min(low[cur], num[to]);\n\t}\n\tfor(auto p : es){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t//dbg(cur, to, num[cur], low[to]);\n\t\tif(low[to] > num[cur]) ans[id] = 1;\n\t}\n}\nint reachablility(int cur, int pid){\n\tif(cur == 1) return reachable[cur] = 1;\n\tif(reachable[cur] != -1) return reachable[cur];\n\t\n\tfor(auto p : e[cur]){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\tif(pid == id) continue;\n\t\tif(dist[to] == dist[cur] + cost && reachablility(to, id)) return reachable[cur] = 1;\n\t}\n\treturn reachable[cur] = 0;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m;\n\te.resize(n); g.resize(n);\n\trep(i, m){\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\te[a].emplace_back(b, c, i);\n\t}\n\t{\n\t\tpriority_queue<pi> q;\n\t\tq.emplace(0, 0);\n\t\trep(i, n) dist[i] = 1e18;\n\t\tdist[0] = 0;\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint c, co;\n\t\t\ttie(co, c) = q.top(); q.pop();\n\t\t\tif(dist[c] < -co) continue;\n\t\t\t\n\t\t\tfor(auto to : e[c]){\n\t\t\t\tint nco = -co + get<1>(to);\n\t\t\t\tif(dist[get<0>(to)] <= nco) continue;\n\t\t\t\tdist[get<0>(to)] = -co + get<1>(to);\n\t\t\t\tq.emplace(co - get<1>(to), get<0>(to));\n\t\t\t}\n\t\t}\n\t\trep(i, n) reachable[i] = -1;\n\t\treachablility(0, -1);\n\t\t//rep(i, n) dbg(i, reachable[i]);\n\t}\n\t{\n\t\trep(i, n) for(auto p : e[i]){\n\t\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t\tif(reachable[i] != 1 || reachable[to] != 1) continue;\n\t\t\tif(dist[i] > dist[to] + cost) ans[id] = -1;\n\t\t\tif(dist[to] == dist[i] + cost){\n\t\t\t\tg[to].emplace_back(i, cost, id);\n\t\t\t\tg[i].emplace_back(to, cost, id);\n\t\t\t\t//dbg(i, to, id);\n\t\t\t}\n\t\t}\n\t\trec(0, -1);\n\t\trep(i, m){\n\t\t\tif(ans[i] < 0) cout << \"HAPPY\" << endl;\n\t\t\telse cout << (ans[i] == 0 ? \"SOSO\" : \"SAD\") << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define int long long\n#define lint long long\n#define pii pair<int, int>\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n#define SZ(v) ((int)v.size())\n#define ZERO(a) memset(a, 0, sizeof(a))\n#define MINUS(a) memset(a, 0xff, sizeof(a))\n#define MINF(a) memset(a, 0x3f, sizeof(a))\n#define POW(n) (1LL << (n))\n#define POPCNT(n) (__builtin_popcount(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e, v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-10;\n\ntemplate <typename T> struct Edge {\n    int to;\n    T cost;\n    Edge() {}\n    Edge(int t, T c) : to(t), cost(c) {}\n};\ntemplate <typename T> using Edges = vector<Edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\n\n\n// Dijkstra のアルゴリズム\n// 負辺を持つグラフは受け付けない\ntemplate <typename T> vector<T> dijkstra(WeightedGraph<T> &g, int s, T inf = numeric_limits<T>::max()) {\n    const int n = g.size();\n    vector<T> dis(n, inf);\n    using P = pair<int, int>;\n    priority_queue<P, vector<P>, greater<P>> que;\n\n    dis[s] = 0;\n    que.emplace(0, s);\n    while (!que.empty()) {\n        const P p = que.top();\n        const int u = p.second;\n        que.pop();\n        if (dis[u] < p.first) continue;\n        for (auto &e : g[u]) {\n            const int v = e.to;\n            if (dis[v] > dis[u] + e.cost) {\n                dis[v] = dis[u] + e.cost;\n                que.emplace(dis[v], v);\n            }\n        }\n    }\n    return dis;\n}\n\nclass LowLink {\n    void dfs(int u, int &k, int p = -1) {\n        low[u] = ord[u] = k++;\n\n        // 関節点の判定に使用\n        int num_of_child = 0;\n        bool exist = false;\n\n        for (auto &v : g[u]) if (v != p) {\n            if (ord[v] >= 0) {\n                low[u] = min(low[u], ord[v]);   // back edge\n                continue;\n            }\n            dfs(v, k, u);\n            low[u] = min(low[u], low[v]);   // forward edge\n            if (ord[u] < low[v]) brs.emplace_back(minmax(u, v));\n            if (ord[u] <= low[v]) exist = true;\n            ++num_of_child;\n        }\n        if ((p == -1 && num_of_child > 1) || (p != -1 && exist))\n            aps.emplace_back(u);\n    }\n\n    // Lowlinkを実行\n    void build() {\n        const int n = g.size();\n        ord.assign(n, -1);\n        low.resize(n);\n        int k = 0;\n        for (int i = 0; i < n; ++i) {\n            if (ord[i] < 0) dfs(i, k);\n        }\n        sort(brs.begin(), brs.end());\n        sort(aps.begin(), aps.end());\n    }\n\npublic:\n    using UnweightedGraph = vector<vector<int>>;\n    vector<pair<int, int>> brs; // 橋\n    vector<int> aps; // 関節点\n\n    const UnweightedGraph &g;\n    vector<int> ord, low;\n\n    LowLink(const UnweightedGraph &g) : g(g) { build(); }\n};\n\nint n, m;\nint a[100010], b[100010], c[100010];\nWeightedGraph<int> g1, g2;\nvector<vector<int>> g;\n\nvoid _main() {\n    cin >> n >> m;\n    g1.resize(n);\n    g2.resize(n);\n    REP(i, m) {\n        cin >> a[i] >> b[i] >> c[i];\n        a[i]--; b[i]--;\n        g1[a[i]].emplace_back(b[i], c[i]);\n        g2[b[i]].emplace_back(a[i], c[i]);\n    }\n    auto d1 = dijkstra(g1, 0, INF);\n    auto d2 = dijkstra(g2, 1, INF);\n    g.resize(n);\n    vector<int> used(m, false);\n    for (int i = 0; i < m; ++i) {\n        if (d1[a[i]] + c[i] + d2[b[i]] == d1[1]) {\n            g[a[i]].emplace_back(b[i]);\n            g[b[i]].emplace_back(a[i]);\n            used[i] = true;\n        }\n    }\n    LowLink ll(g);\n    REP(i, m) {\n        int dis = d1[b[i]] + d2[a[i]] + c[i];\n        if (dis < d1[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if (!used[i] || ll.brs.empty()) {\n            cout << \"SOSO\" << endl;\n        } else {\n            auto p = make_pair(min(a[i], b[i]), max(a[i], b[i]));\n            auto q = LB(ll.brs, p);\n            cout << (p == q ? \"SAD\" : \"SOSO\") << endl;\n        }\n    }\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        if (strchr(argv[1], 'i')) freopen(\"input.txt\", \"r\", stdin);\n        if (strchr(argv[1], 'o')) freopen(\"output.txt\", \"w\", stdout);\n    }\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nint min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\tdijkstra_NORMAL();\n\tdijkstra_REVERSE();\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\tint from,to;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, m, reachable[111111];\nll dist[111111];\nint ans[111111], low[111111], num[111111], N;\nvector<vector<tuple<int,int,int>>> e, g;\n\nvoid rec(int cur, int pid){\n\tnum[cur] = low[cur] = ++N;\n\tvector<tuple<int,int,int>> es;\n\tfor(auto p : g[cur]){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\tif(id == pid) continue;\n\t\tif(num[to] == 0){\n\t\t\trec(to, id);\n\t\t\tlow[cur] = min(low[cur], low[to]);\n\t\t\tes.emplace_back(p);\n\t\t}\n\t\telse low[cur] = min(low[cur], num[to]);\n\t}\n\tfor(auto p : es){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t//dbg(cur, to, num[cur], low[to]);\n\t\tif(low[to] > num[cur]) ans[id] = 1;\n\t}\n}\nint reachablility(int cur, int pid){\n\tif(cur == 1) return reachable[cur] = 1;\n\tif(reachable[cur] != -1) return reachable[cur];\n\t\n\tfor(auto p : e[cur]){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\tif(pid == id) continue;\n\t\tif(dist[to] == dist[cur] + cost && reachablility(to, id)) return reachable[cur] = 1;\n\t}\n\treturn reachable[cur] = 0;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m;\n\te.resize(n); g.resize(n);\n\trep(i, m){\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\te[a].emplace_back(b, c, i);\n\t}\n\t{\n\t\tpriority_queue<pair<ll,int>> q;\n\t\tq.emplace(0, 0);\n\t\trep(i, n) dist[i] = 1e18;\n\t\tdist[0] = 0;\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint c; ll co;\n\t\t\ttie(co, c) = q.top(); q.pop();\n\t\t\tif(dist[c] < -co) continue;\n\t\t\t\n\t\t\tfor(auto to : e[c]){\n\t\t\t\tll nco = -co + get<1>(to);\n\t\t\t\tif(dist[get<0>(to)] <= nco) continue;\n\t\t\t\tdist[get<0>(to)] = -co + get<1>(to);\n\t\t\t\tq.emplace(co - get<1>(to), get<0>(to));\n\t\t\t}\n\t\t}\n\t\trep(i, n) reachable[i] = -1;\n\t\treachablility(0, -1);\n\t\t//rep(i, n) dbg(i, reachable[i]);\n\t}\n\t{\n\t\trep(i, n) for(auto p : e[i]){\n\t\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t\tif(reachable[i] != 1 || reachable[to] != 1) continue;\n\t\t\tif(dist[i] > dist[to] + cost) ans[id] = -1;\n\t\t\tif(dist[to] == dist[i] + cost){\n\t\t\t\tg[to].emplace_back(i, cost, id);\n\t\t\t\tg[i].emplace_back(to, cost, id);\n\t\t\t\t//dbg(i, to, id);\n\t\t\t}\n\t\t}\n\t\trec(0, -1);\n\t\trep(i, m){\n\t\t\tif(ans[i] < 0) cout << \"HAPPY\" << endl;\n\t\t\telse cout << (ans[i] == 0 ? \"SOSO\" : \"SAD\") << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct BiconectedGraph{\n  typedef pair<Int,int> P;\n  Int n;\n  vector<vector<Int> > G,C,T;\n  vector<Int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){};\n  BiconectedGraph(Int sz):n(sz),G(sz),C(sz),T(sz){};\n  \n  void add_edge(Int u,Int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n\n  bool is_bridge(Int u,Int v){\n    if(ord[u] > ord[v]) swap(u,v);\n    return ord[u] < low[v];\n  }\n\n  void dfs(Int u,Int p,Int &k){\n    ord[u] = low[u] = k;\n    ++k;\n    for(Int v:G[u]){\n      if(v == p) continue;\n      if(ord[v] >=0){\n\tlow[u] = min(low[u],ord[v]);\n      } else {\n\tdfs(v,u,k);\n\tlow[u] = min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(Int c,Int u){\n    C[c].push_back(u);\n    belong[u] = c;\n    for(Int v:G[u]){\n      if(belong[v] >= 0 || is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n  \n  void add_component(Int u,Int &k){\n    if(belong[u] >=0) return;\n    fill_component(k++,u);\n  }\n  \n  Int build(){\n    Int k = 0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(Int u=0;u<n;u++){\n      if(ord[u] >= 0) continue;\n      dfs(u,-1,k);\n    }\n    k = 0;\n    for(Int i=0;i<(Int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    \n    for(Int u=0;u<n;u++) add_component(u,k);\n    for(Int i=0;i<(Int)B.size();i++){\n      Int u = belong[B[i].first], v = belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T>\nvector<T> dijkstra(Int s,vector<vector<pair<Int,T> > > &G,T INF){\n  using P = pair<T,Int>;\n  Int n = G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  d[s] = 0;\n  q.emplace(d[s],s);\n  while(!q.empty()){\n    P p = q.top();q.pop();\n    Int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto &e:G[v]){\n      Int u = e.first;\n      T c = e.second;\n      if(d[u] > d[v]+c){\n\td[u] = d[v] + c;\n\tb[u] = v;\n\tq.emplace(d[u],u);\n      } \n    }\n    \n  }\n  return d;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(m),b(m),c(m);\n  for(Int i=0;i<m;i++) cin>>a[i]>>b[i]>>c[i];\n  \n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  vector<vector<P> > rG(n);\n  for(Int i=0;i<m;i++){\n    a[i]--;b[i]--;\n    G[a[i]].emplace_back(b[i],c[i]);\n    rG[b[i]].emplace_back(a[i],c[i]);\n  }\n  const Int INF = 1e12;\n  auto d1=dijkstra(0,G,INF);\n  auto d2=dijkstra(1,rG,INF);\n  //for(Int i=0;i<n;i++) cout<<\"D1:\"<<i<<\" \"<<d1[i]<<endl;\n  //for(Int i=0;i<n;i++) cout<<\"D2:\"<<i<<\" \"<<d2[i]<<endl;\n\n  vector<Int> used(m,0);\n  BiconectedGraph bg(n);\n  for(Int i=0;i<m;i++){\n    if(d1[a[i]]==INF||d2[b[i]]==INF) continue;\n    if(d1[a[i]]+d2[b[i]]+c[i]==d1[1]){\n      bg.add_edge(a[i],b[i]);\n      used[i]=1;\n      //cout<<i<<endl;\n    }\n  }\n  bg.build();\n  \n  for(Int i=0;i<m;i++){\n    if(d1[b[i]]+d2[a[i]]+c[i]<d1[1]){\n      cout<<\"HAPPY\"<<endl;\n      continue;\n    }\n    if(d1[b[i]]+d2[a[i]]+c[i]==d1[1]){\n      cout<<\"SOSO\"<<endl;\n      continue;\n    }\n    if(!used[i]){\n      cout<<\"SOSO\"<<endl;\n      continue;\n    }\n    if(bg.is_bridge(a[i],b[i])) cout<<\"SAD\"<<endl;\n    else cout<<\"SOSO\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nint inf2=1000000000ll*100000ll;\nint n,m;\nvector<pa>G[100030],G2[100030];\nvector<int> dag[100030],dag2[100030];\nint s1[100030],s2[100030],a[100030],b[100030],c[100030];\nint ans[100030]={0};\nbool sumi[100030]={0};\npriority_queue<pa,vector<pa>,greater<pa>> pq;\nint nyu[100030]={0},shu[100030]={0};\nint ok[100030]={0};\n\n\nvector<int> topo;\nint jisuu[100030]={0};\n\nvoid toporoji(){\n\t\n\tqueue<int> qu;\n\tqu.push(1);\n\t\n\tfor(int i=1;i<=n;i++)for(auto v:dag[i])jisuu[v]++;\n\t\n\twhile(qu.size()>0){\n\t\tint r=qu.front();\n\t\tqu.pop();\n\t\ttopo.pb(r);\n\t\t\n\t\tfor(auto v:dag[r]){\n\t\t\tjisuu[v]--;\n\t\t\tif(jisuu[v]==0) qu.push(v);\n\t\t}\n\t}\n \t\n}\n\nvoid saiki(int u){\n\t\n\tint s=dag[u].size(),nn=dag2[u].size();\n\t\n\tfor(auto v:dag2[u]){\n\t\ts+=shu[v];\n\t\tnn+=nyu[v];\n\t}\n\tshu[u]=s,nyu[u]=nn;\n\n\t\n}\n \n            signed main(){\n   cin>>n>>m;\n            \tfor(int i=0;i<m;i++){\n            \tint y,yy,yyy;\n            \t\tcin>>y>>yy>>yyy;\n            \t\tG[y].pb(mp(yy,yyy));\n            \t\tG2[yy].pb(mp(y,yyy));\n            \t\ta[i]=y;\n            \t\tb[i]=yy;\n            \t\tc[i]=yyy;\n            \t\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s1[i]=inf2;\n            \tpq.push(mp(0,1));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts1[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s2[i]=inf2;\n            \tpq.push(mp(0,2));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts2[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G2[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \t\n            \tint len=s1[2];\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\tif(s1[a[i]]+s2[b[i]]+c[i]==len){\n            \t\t\tdag[a[i]].pb(b[i]);\n            \t\t\tdag2[b[i]].pb(a[i]);\n            \t\t\t\n            \t//\t\tcout<<a[i]<<\" \"<<b[i]<<endl;\n            \t\t\n            \t\t}\n            \t\telse{\n            \t\t\tif(s1[b[i]]+s2[a[i]]+c[i]<len)ans[i]=1;\n            \t\t\telse ans[i]=3;\n            \t\t\t\n            \t\t\t\n            \t\t}\n            \t\t\n            \t}\n            //\tsaiki(1);\n            \ttoporoji();\n            \t\n            \tfor(auto v:topo)saiki(v);\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\t\n            \t\tif(ans[i])continue;\n            \t\tif(dag[a[i]].size()>1)ans[i]=3;\n            \t\telse if(dag2[b[i]].size()>1)ans[i]=3;\n            \t\telse if(shu[a[i]]-1!=nyu[a[i]])ans[i]=3;\n            \t\telse ans[i]=2;\n            \t}\n            \tfor(int i=0;i<m;i++){\n            \t\tif(ans[i]==1)cout<<\"HAPPY\"<<endl;\n            \t\tif(ans[i]==2)cout<<\"SAD\"<<endl;\n            \t\tif(ans[i]==3)cout<<\"SOSO\"<<endl;\n            \t}\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#define llint long long int\n#define lldo long double\n#define fir first\n#define sec second\n#define pub push_back\n#define mp make_pair\n#define mt make_tuple\n#define res resize\nconst llint big=5e15;\nvoid maxeq(int &a,int b){if(a<b){a=b;}}\nbool mineq(llint &a,llint b){if(a>b){a=b;return true;}return false;}\nusing namespace std;\nvector<vector<pair<int,int>>>nizyu;\nvector<bool>sad;\nvector<int>fuka;\nvector<int>imos;\nint dfs_tree(int ter,int oyhen=-1,int dep=0){\n\tfuka[ter]=dep;\n\tfor(auto it:nizyu[ter]){\n\t\tif(it.sec==oyhen){continue;}\n\t\tif(fuka[ter]>=fuka[it.fir]){imos[it.fir]--;imos[ter]++;}\n\t\telse if(fuka[it.fir]!=114514){continue;}\n\t\telse{imos[ter]+=dfs_tree(it.fir,it.sec,dep+1);}\n\t}\n\tif(imos[ter]==0&&oyhen!=-1){sad[oyhen]=true;}\n\treturn imos[ter];\n}\nint main(void){\n\t//???????????£?????????????§£\n\tint i,n,m;cin>>n>>m;\n\tvector<vector<pair<llint,int>>> hen(n);\n\tvector<vector<pair<llint,int>>> rehen(n);\n\tvector<tuple<int,int,llint>>edges(m);\n\tfor(i=0;i<m;i++){\n\t\tint a,b;llint c;cin>>a>>b>>c;a--;b--;\n\t\then[a].pub(mp(c,b));\n\t\trehen[b].pub(mp(c,a));\n\t\tedges[i]=mt(a,b,c);\n\t}\n\tvector<llint>dis(n,big);dis[0]=0;\n\tpriority_queue<pair<llint,int>,vector<pair<llint,int>>,greater<pair<llint,int>>> tourist;\n\t//que_tourist!w\n\ttourist.push(mp(0,0));\n\twhile(tourist.size()>0){\n\t\tllint time=tourist.top().fir;\n\t\tint town=tourist.top().sec;\n\t\ttourist.pop();\n\t\tif(dis[town]<time){continue;}\n\t\tfor(auto it:hen[town]){\n\t\t\tif(!mineq(dis[it.sec],time+it.fir)){continue;}\n\t\t\ttourist.push(mp(dis[it.sec],it.sec));\n\t\t}\n\t}\n\tvector<llint>redis(n,big);redis[1]=0;\n\ttourist.push(mp(0,1));\n\twhile(tourist.size()>0){\n\t\tllint time=tourist.top().fir;\n\t\tint town=tourist.top().sec;\n\t\ttourist.pop();\n\t\tif(redis[town]<time){continue;}\n\t\tfor(auto it:rehen[town]){\n\t\t\tif(!mineq(redis[it.sec],time+it.fir)){continue;}\n\t\t\ttourist.push(mp(redis[it.sec],it.sec));\n\t\t}\n\t}\n\t//????????????????????????\n\t//???????????£?????????????§£\n\tllint mtotime=dis[1];\n\tnizyu.res(n);//???????????????\n\tsad.res(m);//true=sad\n\tfor(i=0;i<m;i++){\n\t\tif(dis[get<0>(edges[i])]+redis[get<1>(edges[i])]+get<2>(edges[i])==mtotime)\n\t\t{nizyu[get<0>(edges[i])].pub(mp(get<1>(edges[i]),i));\n\t\tnizyu[get<1>(edges[i])].pub(mp(get<0>(edges[i]),i));}\n\t}\n\tfuka.res(n,114514);\n\timos.res(n);\n\tdfs_tree(0,-1,0);\n\tfor(i=0;i<m;i++){\n\t\tint a,b;llint c;\n\t\ttie(a,b,c)=edges[i];\n\t\tif(dis[b]+redis[a]+c<mtotime){cout<<\"HAPPY\"<<endl;}\n\t\telse if(dis[b]+redis[a]+c==mtotime){cout<<\"SOSO\"<<endl;}\n\t\telse if(sad[i]){cout<<\"SAD\"<<endl;}\n\t\telse{cout<<\"SOSO\"<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, 1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    if(dist[v] == d) (cnt[v] += p) %= MOD;\n    if(dist[v] > d) {\n      dist[v] = d;\n      cnt[v] = p;\n    }\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, cnt[v] });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 99999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 58;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int Soso  = 1;\nconst int Happy = 2;\nconst int Sad   = 3;\n\nusing Edge = tuple<int, int, int>;\n\nvll dijkstra(vector<vector<Edge>>& G, int sv){\n    int n = G.size();\n    vll min_dist(n, inf);\n    min_dist[sv] = 0;\n\n    using Elem = tuple<ll, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    q.push(Elem(0, sv));\n\n    while(q.size()){\n        ll c; int v; tie(c, v) = q.top(); q.pop();\n        if(min_dist[v] != c) continue;\n\n        for(auto& e : G[v]){\n            int nv, dc, ei; tie(nv, dc, ei) = e;\n            ll nc = c + dc;\n            if(chmin(min_dist[nv], nc)){\n                q.push(Elem(nc, nv));\n            }\n        }\n    }\n    return min_dist;\n}\n\nint depthMax;\nvi etype;\nvi depth;\nvi used;\nvi path;\nvi imo;\nvi oute;\n\nbool dfs(vector<vector<Edge>>& G, int v, int tv, int d){\n    if(v == tv){\n        path.emplace_back(v);\n        depth[v] = d;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(dfs(G, nv, tv, d + 1)){\n            path.emplace_back(v);\n            depth[v] = d;\n            used[ei] = true;\n            oute.emplace_back(ei);\n            return true;\n        }\n    }\n    return false;\n}\n\nvi visited;\nvoid dfs2(vector<vector<Edge>>& G, int v, int d){\n    if(depth[v] > d){\n        imo[d]++;\n        imo[depth[v]]--;\n        return;\n    }\n    if(depth[v] == -1) visited[v] = true;\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(visited[nv]) continue;\n        if(used[ei]){\n            assert(oute[d] == ei);\n            continue;\n        }\n        dfs2(G, nv, d);\n    }\n\n    if(depth[v] == d and d < depthMax - 1){\n        dfs2(G, path[d + 1], d + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m; cin >> n >> m;\n    vector<vector<Edge>> G(n), Gr(n);\n    vi as(m), bs(m), cs(m);\n    rep(i, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        G [a].emplace_back(Edge(b, c, i));\n        Gr[b].emplace_back(Edge(a, c, i));\n        as[i] = a, bs[i] = b, cs[i] = c;\n    }\n\n    int sv = 0, tv = 1;\n    auto min_dist     = dijkstra(G, sv);\n    auto min_dist_rev = dijkstra(Gr, tv);\n\n    etype = vi(m, Soso);\n\n    vector<vector<Edge>> Gs(n);\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[a] + c == min_dist[b]){\n            Gs[a].emplace_back(Edge(b, c, i));\n        }\n    }\n    depth = vi(n, -1);\n    used  = vi(m);\n    dfs(Gs, sv, tv, 0);\n    reverse(_all(path));\n    reverse(_all(oute));\n    depthMax = path.size();\n\n    // for(auto& e : path) cerr << e+1 << \" \"; cerr << endl;\n    // for(auto& e : oute) cerr << e+1 << \" \"; cerr << endl;\n\n    imo = vi(depthMax);\n    visited = vi(n);\n    dfs2(Gs, sv, 0);\n    rep(i, 1, depthMax) imo[i] += imo[i - 1];\n    rep(i, depthMax - 1){\n        if(imo[i] == 0){\n            etype[oute[i]] = Sad;\n        }\n    }\n\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[b] + min_dist_rev[a] + c < min_dist[tv]){\n            etype[i] = Happy;\n        }\n    }\n\n    rep(i, m){\n        string res = \"SOSO\";\n        if(etype[i] == Happy){\n            res = \"HAPPY\";\n        }\n        else if(etype[i] == Sad){\n            res = \"SAD\";\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nint inf2=1000000000ll*100000ll;\nint n,m;\nvector<pa>G[100030],G2[100030];\nvector<int> dag[100030],dag2[100030];\nint s1[100030],s2[100030],a[100030],b[100030],c[100030];\nint ans[100030]={0};\nbool sumi[100030]={0};\npriority_queue<pa,vector<pa>,greater<pa>> pq;\nint nyu[100030]={0},shu[100030]={0};\nint ok[100030]={0};\n\nvoid saiki(int u){\n\t\n\tint s=dag[u].size(),nn=dag2[u].size();\n\tfor(auto v:dag2[u]){\n\t\tif(ok[v]==0) return;\n\t}\n\tfor(auto v:dag2[u]){\n\t\ts+=shu[v];\n\t\tnn+=nyu[v];\n\t}\n\tshu[u]=s,nyu[u]=nn;\n\tok[u]=1;\n\t\n\tfor(auto v:dag[u])saiki(v);\n}\n \n            signed main(){\n   cin>>n>>m;\n            \tfor(int i=0;i<m;i++){\n            \tint y,yy,yyy;\n            \t\tcin>>y>>yy>>yyy;\n            \t\tG[y].pb(mp(yy,yyy));\n            \t\tG2[yy].pb(mp(y,yyy));\n            \t\ta[i]=y;\n            \t\tb[i]=yy;\n            \t\tc[i]=yyy;\n            \t\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s1[i]=inf2;\n            \tpq.push(mp(0,1));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts1[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s2[i]=inf2;\n            \tpq.push(mp(0,2));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts2[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G2[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \t\n            \tint len=s1[2];\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\tif(s1[a[i]]+s2[b[i]]+c[i]==len){\n            \t\t\tdag[a[i]].pb(b[i]);\n            \t\t\tdag2[b[i]].pb(a[i]);\n            \t\t\t\n            \t//\t\tcout<<a[i]<<\" \"<<b[i]<<endl;\n            \t\t\n            \t\t}\n            \t\telse{\n            \t\t\tif(s1[b[i]]+s2[a[i]]+c[i]<len)ans[i]=1;\n            \t\t\telse ans[i]=3;\n            \t\t\t\n            \t\t\t\n            \t\t}\n            \t\t\n            \t}\n            \tsaiki(1);\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\t\n            \t\tif(ans[i])continue;\n            \t\tif(dag[a[i]].size()>1)ans[i]=3;\n            \t\telse if(dag2[b[i]].size()>1)ans[i]=3;\n            \t\telse if(shu[a[i]]-1!=nyu[a[i]])ans[i]=3;\n            \t\telse ans[i]=2;\n            \t}\n            \tfor(int i=0;i<m;i++){\n            \t\tif(ans[i]==1)cout<<\"HAPPY\"<<endl;\n            \t\tif(ans[i]==2)cout<<\"SAD\"<<endl;\n            \t\tif(ans[i]==3)cout<<\"SOSO\"<<endl;\n            \t}\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P>P2;\n#define fi first\n#define se second\n\nstruct Bridge{\n  int n;\n  vector<vector<int> > G;\n  vector<int>low,used,depth;\n  set<pair<int,int> >ans;\n  Bridge(){}\n  Bridge(int sz):n(sz),low(sz),used(sz),depth(sz),G(sz){}\n  void add(int a,int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  void dfs(int x,int d,int prev){\n    depth[x]=d;\n    for(int i=0;i<G[x].size();i++){\n      int nx=G[x][i];\n      if(nx==prev)continue;\n      if(!used[nx]){\n        used[nx]=true;\n        dfs(nx,d+1,x);\n        if(!low[nx]) ans.insert(P(min(x,nx),max(x,nx)));\n        low[x]+=low[nx];\n      }\n      else if(d>depth[nx])low[nx]--,low[x]++;\n    }\n  }\n  void build(){if(!n)return ;\n    fill(used.begin(),used.end(),0);\n    fill(low.begin(),low.end(),0);\n    fill(depth.begin(),depth.end(),0);\n    used[0]=1;\n    dfs(0,0,0);\n  }\n  void prin(){\n    set<P>::iterator it=ans.begin();\n    while(it!=ans.end()){\n      cout<< (*it).first <<' '<< (*it).second <<endl;\n      it++;\n    }\n  }\n};\n\nvector<P>v[100009],v2[100009];\nint d1[100009],d2[100009],s,t,n,m;\nint a[100009],b[100009],c[100009];\nmap<P,int>MIN,TT;\n\nset<P2> iru;\n\nvoid dij1(){\n    r(i,100009)d1[i]=1e14;\n    d1[s]=0;\n    priority_queue<P,vector<P>,greater<P> >q;\n    q.push(P(0,s));\n    while(!q.empty()){\n        P p=q.top();q.pop();\n        int now=p.se;\n        int cost=p.fi;\n        if(d1[now]<cost)continue;\n        r(i,v[now].size()){\n            int nex=v[now][i].fi;\n            int cost2=cost+v[now][i].se;\n            if(d1[nex]<=cost2)continue;\n            d1[nex]=cost2;\n            q.push(P(cost2,nex));\n        }\n    }\n}\n\nvoid dij2(){\n    r(i,100009)d2[i]=1e14;\n    d2[t]=0;\n    priority_queue<P,vector<P>,greater<P> >q;\n    q.push(P(0,t));\n    while(!q.empty()){\n        P p=q.top();q.pop();\n        int now=p.se;\n        int cost=p.fi;\n        if(d2[now]<cost)continue;\n        r(i,v2[now].size()){\n            int nex=v2[now][i].fi;\n            int cost2=cost+v2[now][i].se;\n            if(d2[nex]<=cost2)continue;\n            d2[nex]=cost2;\n            q.push(P(cost2,nex));\n        }\n    }\n}\n\nint cnt=0;\nset<int>st;\nset<P>PPP;\n\nvoid iranai(){\n    r(i,m){//cout<<d1[a[i]]<<' '<<d2[b[i]]<<\" \"<<c[i]<<endl;\n        if(d1[a[i]]+d2[b[i]]+c[i]==d1[t]){\n            iru.insert(P2(a[i],P(b[i],c[i])));\n            cnt++;\n            st.insert(a[i]);\n            st.insert(b[i]);\n        }\n    }\n}\n\nsigned main(){\n    cin>>n>>m;\n    r(i,m){\n        cin>>a[i]>>b[i]>>c[i];\n        a[i]--;\n        b[i]--;\n        v[a[i]].push_back(P(b[i],c[i]));\n        v2[b[i]].push_back(P(a[i],c[i]));\n        if(MIN.count(P(a[i],b[i]))){\n            if(MIN[P(a[i],b[i])]==c[i])TT[P(a[i],b[i])]=1;\n            MIN[P(a[i],b[i])]=min(MIN[P(a[i],b[i])],c[i]);\n        }\n        else MIN[P(a[i],b[i])]=c[i];\n    }\n    s=0;\n    t=1;\n    dij1();\n    dij2();\n    iranai();\n    set<P2>::iterator it=iru.begin();\n    int N=st.size();\n    Bridge B(N);\n    set<int>::iterator it2=st.begin();\n    map<int,int>m1,m2;\n    set<int>sss;\n    int cc=0;\n    for(;it2!=st.end();it2++){\n        int A=(*it2);\n        if(!sss.count(A)){\n            sss.insert(A);//cout<<A<<endl;\n            m1[A]=cc;\n            m2[cc]=A;\n            cc++;\n        }\n    }\n    for(;it!=iru.end();it++){\n        P2 p=(*it);\n        int A=p.fi;\n        int BB=p.se.fi;//cout<<m1[A]<<' '<<m1[BB]<<endl;\n        PPP.insert(P(A,BB));\n        B.add(m1[A],m1[BB]);\n    }\n    B.build();//cout<<d1[t]<<endl;\n    r(i,m){\n        int g=d1[b[i]]+d2[a[i]]+c[i];\n        if(g<d1[t])cout<<\"HAPPY\"<<endl;\n        else if(g==d1[t])cout<<\"SOSO\"<<endl;\n        else{\n            if((MIN[P(a[i],b[i])]==c[i])&&\n                !TT.count(P(a[i],b[i]))&&\n                m1.count(a[i])&&\n                m1.count(b[i])&&\n                PPP.count(P(a[i],b[i]))&&\n                B.ans.count(P(min(m1[a[i]],m1[b[i]]),max(m1[a[i]],m1[b[i]]))))cout<<\"SAD\"<<endl;\n            else cout<<\"SOSO\"<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    typedef long long ll;\n    const ll INF = 1LL << 56;\n    int N, M;\n\n    struct Edge {\n        int from, to; ll cost;\n        Edge(int from, int to, ll cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            if (from == e.from) {\n                return to == e.to ? cost < e.cost : to < e.to;\n            } else {\n                return from < e.from;\n            }\n        }\n        bool operator==(const Edge& e) {\n            return to == e.to and from == e.from and cost == e.cost;\n        }\n    };\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \",\" << e.to << \",\" << e.cost << \")\";\n    }\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    vector<vector<Edge>> G, RG;\n    vector<Edge> es;\n    map<Edge, int> X;\n\n    vector<pair<int, int>> findBridges(const vector<vector<Edge>>& G) {\n        int V = N;\n        vector<int> dfs_order(V, -1);\n        vector<int> lowlink(V, 0);\n        int c = 0;\n        vector<pair<int, int>> bridges;\n        function<void(int, int)> dfs = [&](int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            for (auto& e : G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) {\n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges.emplace_back(l, g);\n                }\n            }\n        };\n        dfs(0, -1);\n        return bridges;\n    }\n\n    void input() {\n        cin >> N >> M;\n        G.resize(N);\n        RG.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b; ll c;\n            cin >> a >> b >> c;\n            a--; b--;\n            Edge e(a, b, c);\n            if (X.count(e)) {\n                X[e]++;\n            } else {\n                G[a].emplace_back(a, b, c);\n                RG[b].emplace_back(b, a, c);\n                X[e] = 1;\n            }\n            es.emplace_back(a, b, c);\n        }\n    }\n\n    struct S {\n        int v; ll cost;\n        S(int v, ll cost) : v(v), cost(cost) {}\n        bool operator<(const S& s) const {\n            return cost > s.cost;\n        }\n    };\n\n    void dijkstra(const vector<vector<Edge>>& G, int start, vector<ll>& D, vector<vector<Edge>>& prev) {\n        priority_queue<S> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : G[cur.v]) {\n                auto next = e.to;\n                auto ncost = D[cur.v] + e.cost;\n                if (D[next] > ncost) {\n                    prev[next].clear();\n                    prev[next].push_back(e);\n                    D[next] = ncost;\n                    PQ.emplace(next, ncost);\n                } else if (D[next] == ncost) {\n                    prev[next].push_back(e);\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<ll> D(N, INF);\n        vector<ll> RD(N, INF);\n        vector<vector<Edge>> prev(N, vector<Edge>());\n        vector<vector<Edge>> rprev(N, vector<Edge>());\n        dijkstra(G, 0, D, prev);\n        dijkstra(RG, 1, RD, rprev);\n\n        vector<vector<Edge>> shortest_paths(N, vector<Edge>());\n        vector<bool> used(N, false);\n        function<void(int)> dfs = [&](int v) {\n            if (prev[v].empty()) {\n                //assert(v == 0);\n                return;\n            }\n            if (used[v]) return;\n            used[v] = true;\n            for (auto e : prev[v]) {\n                shortest_paths[e.from].push_back(e);\n                shortest_paths[e.to].emplace_back(e.to, e.from, -1);\n                dfs(e.from);\n            }\n        };\n        dfs(1);\n        //cout << shortest_paths << endl;\n\n        auto _bridges = findBridges(shortest_paths);\n        //cout << _bridges << endl;\n        set<pair<int, int>> bridges;\n        for (auto b : _bridges) { bridges.insert(b); }\n\n        for (int i = 0; i < M; i++) {\n            auto e = es[i];\n            if (D[e.from] + e.cost + RD[e.to] == D[1]) {\n                if (\n                    (bridges.count(make_pair(e.from, e.to)) \n                     or bridges.count(make_pair(e.to, e.from)))\n                     and X[e] <= 1) {\n                    cout << \"SAD\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            } else {\n                auto ncost = D[e.to] + e.cost + RD[e.from];\n                if (ncost < D[1]) {\n                    cout << \"HAPPY\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <tuple>\n#include <map>\n#include <limits>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll INF = numeric_limits<ll>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nstruct CostGraph {\n    using T = ll;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge() {}\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        int from;\n        int to;\n        T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\nostream& operator<<(ostream& os, const CostGraph::Edge& e)\n{\n    os << \"(\" << e.from << \"->\" << e.to << \": \" << e.cost << \")\" << endl;\n    return os;\n}\n\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\nvoid ReverseDijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.rev_edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nstruct BiconnectedComponent {\npublic:\n    BiconnectedComponent(const CostGraph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            bridge_dfs(g_, i);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    CostGraph toTree() const\n    {\n        CostGraph tree(comp_num);\n        for (const auto& e : bridge) {\n            tree.addEdge(comp[e.from], comp[e.to], 1);\n            tree.addEdge(comp[e.to], comp[e.from], 1);\n        }\n        return tree;\n    }\n    const vector<CostGraph::Edge>& getEdge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i];\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    void bridge_dfs(const CostGraph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n            }\n            if (isBridge(s, to)) {\n                bridge.push_back(e);\n            }\n        }\n    }\n\n    void comp_dfs(const CostGraph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n    int num;\n    int comp_num;\n    const int size;\n    vector<CostGraph::Edge> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    CostGraph g(n);\n    using E = tuple<int, int, ll>;\n    vector<E> edge(m);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--, b--;\n        g.addEdge(a, b, c);\n        edge[i] = make_tuple(a, b, c);\n    }\n    vector<ll> ds(n, INF);\n    Dijkstra(g, 0, ds);\n    vector<ll> dt(n, INF);\n    ReverseDijkstra(g, 1, dt);\n    show(ds);\n    show(dt);\n    const ll D = ds[1];\n    CostGraph undg(n);\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[u] + c + dt[v] == D) {\n            undg.addEdge(u, v, c);\n            undg.addEdge(v, u, c);\n        }\n    }\n\n    using pii = pair<int, int>;\n    BiconnectedComponent bic(undg);\n    show(bic.bridge);\n    set<E> bridge;\n    for (const auto& e : bic.bridge) {\n        const int u = e.from;\n        const int v = e.to;\n        bridge.insert(make_tuple(u, v, e.cost));\n    }\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[v] + c + dt[u] < D) {\n            cout << \"HAPPY\" << endl;\n        } else {\n            if (not(bridge.find(make_tuple(u, v, c)) == bridge.end() and bridge.find(make_tuple(v, u, c)) == bridge.end())) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nvector<vector<pii> > G, rG;\nvector<vector<int> > I, rI;\nll C[100100], rC[100100];\nbool tmp[100100];\nbool bridge[100100];\nint lst[100100][3];\n\nvoid shortest(vector<vector<pii> > g, ll *c, int s) {\n\tfor(int i = 0; i < 100100; i++) {\n\t\tc[i] = 1e15;\n\t}\n\tc[s] = 0;\n\tpriority_queue<pli> q;\n\tq.push(pli(0,s));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(c[a.se] < -a.fi) continue;\n\t\tfor(int i = 0; i < g[a.se].size(); i++) {\n\t\t\tint v = g[a.se][i].fi;\n\t\t\tll t = -a.fi + g[a.se][i].se;\n\t\t\tif(c[v] > t) {\n\t\t\t\tc[v] = t;\n\t\t\t\tq.push(pli(-t, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mkbridge() {\n\tll sp = C[1];\n\tpriority_queue<pli> q;\n\tq.push(pli(0,0));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(tmp[a.se]) continue;\n\t\ttmp[a.se] = true;\n\t\tint id =-1;\n\t\tfor(int i = 0; i < G[a.se].size(); i++) {\n\t\t\tint v = G[a.se][i].fi;\n\t\t\tif(sp == C[a.se] + G[a.se][i].se + rC[v]) {\n\t\t\t\tq.push(pli(-C[v], v));\n\t\t\t\tid = I[a.se][i];\n\t\t\t}\n\t\t}\n\t\tif(q.size() == 1 && id >= 0) {\n\t\t\tbridge[id] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tG.resize(n);\n\trG.resize(n);\n\tI.resize(n);\n\trI.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tG[a].push_back(pii(b,c));\n\t\trG[b].push_back(pii(a,c));\n\t\tI[a].push_back(i);\n\t\trI[b].push_back(i);\n\t\tlst[i][0] = a; lst[i][1] = b; lst[i][2] = c;\n\t}\n\tshortest(G,C,0);\n\tshortest(rG,rC,1);\n\tmkbridge();\n\n\tll sp = C[1];\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = lst[i][0]; b = lst[i][1]; c = lst[i][2];\n\t\tif(C[b] + c + rC[a] < sp) {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t\telse if(bridge[i] && C[b] + c + rC[a] > sp && sp != (ll)(1e15)) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mem(t, v)   memset ((t) , v, sizeof(t))\n#define all(x)      x.begin(),x.end()\n#define un(x)       x.erase(unique(all(x)), x.end())\n#define sf(n)       scanf(\"%d\", &n)\n#define sff(a,b)    scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define sl(n)       scanf(\"%lld\", &n)\n#define sll(a,b)    scanf(\"%lld %lld\", &a, &b)\n#define slll(a,b,c) scanf(\"%lld %lld %lld\", &a, &b, &c)\n#define D(x)        cerr << #x \" = \" << (x) << '\\n'\n#define DD(x,y) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << endl\n#define DDD(x,y,z) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << \"   \" << #z << \" = \" << z << endl\n#define DBG         cerr << \"Hi\" << '\\n'\n#define pb          push_back\n#define PI          acos(-1.00)\n#define xx          first\n#define yy          second\n#define eps         1e-9\n\ntypedef unsigned long long int ULL;\ntypedef long long int LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\n\ninline int setBit(int N, int pos) { return N=N | (1<<pos); }\ninline int resetBit(int N, int pos) { return N= N & ~(1<<pos); }\ninline bool checkBit(int N, int pos) { return (bool)(N & (1<<pos)); }\n\n//int fx[] = {+0, +0, +1, -1, -1, +1, -1, +1};\n//int fy[] = {-1, +1, +0, +0, +1, +1, -1, -1}; //Four & Eight Direction\n\n#define MAX     100000\nnamespace dom{\nvector<int>g[MAX+5], tree[MAX+5], rg[MAX+5], bucket[MAX+5];\nint sdom[MAX+5], par[MAX+5], dom[MAX+5], dsu[MAX+5], label[MAX+5];\nint arr[MAX+5], rev[MAX+5], T, n, source;\nconst int dest = 2;\nvoid init(int _n, int _source)\n{\n    T = 0;\n    n = _n;\n    source = _source;\n    for(int i = 1; i<=n; i++)\n    {\n        g[i].clear(), rg[i].clear(), tree[i].clear(), bucket[i].clear();\n        arr[i] = sdom[i] = par[i] = dom[i] = dsu[i] = label[i] = rev[i] = 0;\n    }\n}\nvoid dfs(int u)\n{\n    T++;\n    arr[u] = T;\n    rev[T] = u;\n    label[T] = T;\n    sdom[T] = T;\n    dsu[T] = T;\n    for(int i = 0; i<g[u].size(); i++)\n    {\n        int w = g[u][i];\n        if(!arr[w])\n        {\n            dfs(w);\n            par[arr[w]] = arr[u];\n        }\n        rg[arr[w]].push_back(arr[u]);\n    }\n}\n\nint Find(int u, int x = 0)\n{\n    if(u == dsu[u]) return x ? -1:u;\n    int v = Find(dsu[u], x+1);\n    if(v < 0) return u;\n    if(sdom[label[dsu[u]]] < sdom[label[u]])\n        label[u] = label[dsu[u]];\n    dsu[u] = v;\n    return x?v:label[u];\n}\n\nvoid Union(int u, int v)\n{\n    dsu[v] = u;\n}\n\nvoid build()\n{\n    dfs(source);\n    for(int i = n; i>=1; i--)\n    {\n        for(int j = 0; j<rg[i].size(); j++)\n            sdom[i] = min(sdom[i], sdom[Find(rg[i][j])]);\n        if(i > 1) bucket[sdom[i]].push_back(i);\n        for(int j = 0; j<bucket[i].size(); j++)\n        {\n            int w = bucket[i][j], v = Find(w);\n            if(sdom[v] == sdom[w]) dom[w] = sdom[w];\n            else dom[w] = v;\n        }\n        if(i > 1) Union(par[i], i);\n    }\n\n    for(int i = 2; i<=n; i++)\n    {\n        if(dom[i] != sdom[i]) dom[i] = dom[dom[i]];\n        tree[rev[dom[i]]].push_back(rev[i]);\n        par[rev[i]] = rev[dom[i]];\n    }\n}\n\nbool hasDest[MAX+10];\nbool go(int node)\n{\n    if(node == dest)\n        return hasDest[node] =  1;\n    for(auto v: tree[node])\n    {\n        if(go(v))\n            return hasDest[node] = 1;\n    }\n    return hasDest[node] = 0;\n}\n\nbool check(int u, int v)\n{\n    return (par[v] == u && hasDest[v]);\n}\n\n}\n\nstruct edgeData{\n    int u, v;\n    LL w;\n};\n\nvector<pll>E[MAX+10], Rev[MAX+10];\nvector<edgeData>edge;\n\nint n, m;\n\nLL dist[3][MAX+10];\nconst LL inf = 1e15;\nstruct data{\n    int v;\n    LL cost;\n};\n\nbool operator < (data a, data b)\n{\n    return a.cost > b.cost;\n}\n\npriority_queue<data>PQ;\nLL SP;\n\nvoid dijkstra(int source, vector<pll>E[])\n{\n    for(int i = 1; i<=n; i++)\n        dist[source][i] = inf;\n    dist[source][source] = 0;\n    while(!PQ.empty())\n        PQ.pop();\n    PQ.push({source, 0});\n    while(!PQ.empty())\n    {\n        int u = PQ.top().v;\n        PQ.pop();\n//        if(dist[source][u] < PQ.top().cost)\n//            continue;\n        for(auto v: E[u])\n        {\n            if(dist[source][v.xx] > dist[source][u] + v.yy)\n            {\n                dist[source][v.xx] = dist[source][u] + v.yy;\n                PQ.push({(int)v.xx, dist[source][v.xx]});\n            }\n        }\n    }\n}\n\n\nbool imp[MAX+10];\n#define SRC     1\n#define DEST    2\nmap<int,int>M[MAX+10];\nmap<int,int>cnt[MAX+10];\nvoid buildDAG()\n{\n    for(int i = 0; i<edge.size(); i++)\n    {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        LL w = edge[i].w;\n        if(M[u].find(v) == M[u].end())\n            M[u][v] = w;\n        else\n            M[u][v] = min(M[u][v], (int)w);\n        if(dist[SRC][u] + w + dist[DEST][v] == SP)\n            dom::g[u].pb(v), imp[i] = true;\n    }\n    for(int i = 0; i<edge.size(); i++)\n    {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        LL w = edge[i].w;\n        if(M[u][v] == w)\n            cnt[u][v]++;\n    }\n    for(int i = 0; i<edge.size(); i++)\n    {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        LL w = edge[i].w;\n        if(!(M[u][v] == w && cnt[u][v] == 1))\n            imp[i] = 0;\n    }\n}\n\nvoid solve(int i)\n{\n    int u = edge[i].u;\n    int v = edge[i].v;\n    LL w = edge[i].w;\n\n    LL tmp = dist[SRC][v] + w + dist[DEST][u];\n    if(imp[i] && dom::check(u,v))\n    {\n        puts(\"SAD\");\n        return;\n    }\n    else if(tmp < SP)\n    {\n        puts(\"HAPPY\");\n        return;\n    }\n    else\n    {\n        puts(\"SOSO\");\n        return;\n    }\n}\n\n\nint main()\n{\n//    freopen(\"maxon.txt\",\"r\",stdin);\n//    freopen(\"out.txt\",\"w\",stdout);\n    sff(n,m);\n    int u, v, w;\n    for(int i = 1; i<=m; i++)\n    {\n        sfff(u,v,w);\n        E[u].pb({v,w});\n        Rev[v].pb({u,w});\n        edge.pb({u,v,w});\n    }\n\n    dijkstra(SRC, E);\n    SP = dist[SRC][DEST];\n    dijkstra(DEST, Rev);\n\n\n    dom::init(n, SRC);\n    buildDAG();\n    dom::build();\n    mem(dom::hasDest, 0);\n    dom::go(SRC);\n    for(int i = 0; i<edge.size(); i++)\n        solve(i);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<algorithm>\nstruct bridge{\n\tvector<int>ord,low;\n\tvector<bool>art;\n\tvector<pair<int,int> >bridges;\n\tvector<vector<int> >G;\n\tbridge(int n_=0):ord(n_,-1),low(n_),art(n_,false),G(n_){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool operator[](int a){return art[a];}\n\tbool is_bridge(int a,int b)\n\t{\n\t\tif(ord[a]>ord[b])swap(a,b);\n\t\treturn ord[a]<low[b];\n\t}\n\tvoid dfs(int u,int p,int&k)\n\t{\n\t\tlow[u]=ord[u]=k++;\n\t\tfor(int&v:G[u])\n\t\t{\n\t\t\tif(ord[v]==-1)\n\t\t\t{\n\t\t\t\tdfs(v,u,k);\n\t\t\t\tlow[u]=min(low[u],low[v]);\n\t\t\t\tart[u]=art[u]|ord[u]<=low[v];\n\t\t\t\tif(ord[u]<low[v])bridges.push_back(u<v?make_pair(u,v):make_pair(v,u));\n\t\t\t}\n\t\t\telse if(v!=p)\n\t\t\t{\n\t\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid build()\n\t{\n\t\tint k=1,cnt=0;\n\t\tlow[0]=ord[0]=0;\n\t\tfor(int&v:G[0])if(ord[v]==-1)\n\t\t{\n\t\t\tdfs(v,0,k);\n\t\t\tif(ord[0]<low[v])bridges.push_back(make_pair(0,v));\n\t\t\tcnt++;\n\t\t}\n\t\tif(cnt>=2)art[0]=true;\n\t}\n};\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nvector<T>dijkstra(int s,const vector<vector<pair<int,T> > >&G,T INF=numeric_limits<T>::max())\n{\n\tint n=G.size();\n\tvector<T>d(n,INF);\n\tvector<int>parent(n,-1);\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\td[s]=0;\n\tP.push(make_pair(d[s],s));\n\twhile(!P.empty())\n\t{\n\t\tpair<T,int>p=P.top();P.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(const pair<int,T>&e:G[v])\n\t\t{\n\t\t\tint u=e.first;\n\t\t\tT cost=d[v]+e.second;\n\t\t\tif(d[u]>cost)\n\t\t\t{\n\t\t\t\td[u]=cost;\n\t\t\t\tparent[u]=v;\n\t\t\t\tP.push(make_pair(d[u],u));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nint n,m;\nmain()\n{\n\tcin>>n>>m;\n\tvector<vector<pair<int,long long> > >G(n),H(n);\n\tvector<pair<pair<int,int>,long long> >e;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\ta--,b--;\n\t\tG[a].push_back(make_pair(b,c));\n\t\tH[b].push_back(make_pair(a,c));\n\t\te.push_back(make_pair(make_pair(a,b),c));\n\t}\n\tvector<long long>dg=dijkstra(0,G,(long long)1e18);\n\tvector<long long>dh=dijkstra(1,H,(long long)1e18);\n\tbridge b(n);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(dg[e[i].first.first]+dh[e[i].first.second]+e[i].second==dg[1])\n\t\t\tb.add_edge(e[i].first.first,e[i].first.second);\n\t}\n\tb.build();\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(dg[e[i].first.second]+dh[e[i].first.first]+e[i].second<dg[1])cout<<\"HAPPY\"<<endl;\n\t\telse if(dg[e[i].first.first]+dh[e[i].first.second]+e[i].second==dg[1]&&\n\t\t\tb.is_bridge(e[i].first.first,e[i].first.second))cout<<\"SAD\"<<endl;\n\t\telse cout<<\"SOSO\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <tuple>\n#include <map>\n#include <limits>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll INF = numeric_limits<ll>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nstruct CostGraph {\n    using T = ll;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge() {}\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        int from;\n        int to;\n        T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\nostream& operator<<(ostream& os, const CostGraph::Edge& e)\n{\n    os << \"(\" << e.from << \"->\" << e.to << \": \" << e.cost << \")\" << endl;\n    return os;\n}\n\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\nvoid ReverseDijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.rev_edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nstruct BiconnectedComponent {\npublic:\n    BiconnectedComponent(const CostGraph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            bridge_dfs(g_, i);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    CostGraph toTree() const\n    {\n        CostGraph tree(comp_num);\n        for (const auto& e : bridge) {\n            tree.addEdge(comp[e.from], comp[e.to], 1);\n            tree.addEdge(comp[e.to], comp[e.from], 1);\n        }\n        return tree;\n    }\n    const vector<CostGraph::Edge>& getEdge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i];\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    void bridge_dfs(const CostGraph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n            }\n            if (isBridge(s, to)) {\n                bridge.push_back(e);\n            }\n        }\n    }\n\n    void comp_dfs(const CostGraph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n    int num;\n    int comp_num;\n    const int size;\n    vector<CostGraph::Edge> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    CostGraph g(n);\n    using E = tuple<int, int, ll>;\n    vector<E> edge(m);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--, b--;\n        g.addEdge(a, b, c);\n        edge[i] = make_tuple(a, b, c);\n    }\n    vector<ll> ds(n, INF);\n    Dijkstra(g, 0, ds);\n    vector<ll> dt(n, INF);\n    ReverseDijkstra(g, 1, dt);\n    const ll D = ds[1];\n    CostGraph undg(n);\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[u] + c + dt[v] == D) {\n            undg.addEdge(u, v, c);\n            undg.addEdge(v, u, c);\n        }\n    }\n\n    using pii = pair<int, int>;\n    BiconnectedComponent bic(undg);\n    set<E> bridge;\n    for (const auto& e : bic.bridge) {\n        const int u = e.from;\n        const int v = e.to;\n        bridge.insert(make_tuple(u, v, e.cost));\n    }\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[v] + c + dt[u] < D) {\n            cout << \"HAPPY\" << endl;\n        } else {\n            if (not(bridge.find(make_tuple(u, v, c)) == bridge.end() and bridge.find(make_tuple(v, u, c)) == bridge.end())) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nconst int mod = 1000000021;\nconst long long inf = 1LL << 61;\nstruct edge { int to, cost, id; };\nstruct state { int pos; long long cost; };\nbool operator<(const state& s1, const state& s2) { return s1.cost > s2.cost; }\nint N, M, dp[100009], dp2[100009], va[100009]; bool vis1[100009], vis2[100009];\nvector<long long> shortest_path(vector<vector<edge> > g, int src) {\n\tvector<long long> ret(g.size(), inf); ret[src] = 0;\n\tpriority_queue<state> que; que.push(state{ src, 0 });\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (edge e : g[u]) {\n\t\t\tlong long nd = ret[u] + e.cost;\n\t\t\tif (ret[e.to] > nd) {\n\t\t\t\tret[e.to] = nd;\n\t\t\t\tque.push(state{ e.to, nd });\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\tvector<int> a(M), b(M), c(M);\n\tvector<vector<edge> > g(N);\n\tvector<vector<edge> > rg(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t\tg[a[i]].push_back(edge{ b[i], c[i], i });\n\t\trg[b[i]].push_back(edge{ a[i], c[i], i });\n\t}\n\tvector<long long> ds = shortest_path(g, 0);\n\tvector<long long> dt = shortest_path(rg, 1);\n\tvector<bool> ok(M);\n\tvector<vector<int> > sg(N), sr(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ds[a[i]] + c[i] == ds[b[i]]) {\n\t\t\tok[i] = true;\n\t\t\tsg[a[i]].push_back(b[i]);\n\t\t\tsr[b[i]].push_back(a[i]);\n\t\t}\n\t}\n\tpriority_queue<state> que; que.push(state{ 0, 0 }); dp[0] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis1[u]) {\n\t\t\tvis1[u] = true;\n\t\t\tfor (int i : sg[u]) {\n\t\t\t\tdp[i] += dp[u];\n\t\t\t\tif (dp[i] >= mod) dp[i] -= mod;\n\t\t\t\tque.push(state{ i, ds[i] });\n\t\t\t}\n\t\t}\n\t}\n\tque.push(state{ 1, 0 }); dp2[1] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis2[u]) {\n\t\t\tvis2[u] = true;\n\t\t\tfor (int i : sr[u]) {\n\t\t\t\tdp2[i] += dp2[u];\n\t\t\t\tif (dp2[i] >= mod) dp2[i] -= mod;\n\t\t\t\tque.push(state{ i, dt[i] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) va[i] = 1LL * dp[i] * dp2[i] % mod;\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!ok[i]) {\n\t\t\tcout << (ds[b[i]] + dt[a[i]] + c[i] < ds[1] ? \"HAPPY\\n\" : \"SOSO\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (ds[b[i]] + dt[a[i]] + c[i] < ds[1]) cout << \"HAPPY\\n\";\n\t\t\telse if (ds[b[i]] + dt[a[i]] + c[i] == ds[1]) cout << \"SOSO\\n\";\n\t\t\telse {\n\t\t\t\tif (va[a[i]] == va[0] && va[b[i]] == va[0]) cout << \"SAD\\n\";\n\t\t\t\telse cout << \"SOSO\\n\";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n\nconst ll INF = 1e15;\n\nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n\tdist[f->dst] = e.weight + f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\tprev[f->dst].clear();\n\tprev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n\tprev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n\npair<Graph, Graph> buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  Graph g2(n);\n  stack<int> st;\n  st.push(t);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    for(auto&& p : prev[now]){\n      if(p < 0)\n\tcontinue;\n      g[p].push_back(Edge(p, now, 1));\n      g2[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return pair<Graph, Graph>(g, g2);\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w*2, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w*2 == befo.first)\n\tmp[P(s, d)] = P(w*2-1, befo.second + 1);\n      else\n\tmp[P(s, d)] = P(min(w*2, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree, tree2;\n  tie(tree, tree2) = buildPath(prev, 1);\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n\n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n\n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n    \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w*2)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    for(int i=0;i<tree2[s].size();i++){\n      ok |= tree2[s][i].dst == d;\n      //cout << \"tr: \" << tree[s][i].src << \" \" << tree[s][i].dst << endl;\n    }\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}\n/*\n11 15\n1 3 1\n3 6 2\n6 10 1\n1 5 3\n3 7 1\n5 9 1\n9 11 1\n7 8 1\n1 4 2\n4 8 1\n8 10 1\n10 11 1\n11 2 1\n10 7 1\n10 1 1\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll inf = 1e18;\n\nstruct edge {\n    int from, to;\n    ll cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, ll cost) {\n    g[from].push_back(edge{from, to, cost});\n}\n\nclass lowlink { // multiple edges ok\npublic:\n    lowlink(graph const& g)\n        : ord(g.size()), low(g.size())\n    {\n        const int n = g.size();\n        std::vector<bool> visited(n);\n        int cnt = 0;\n        for(int i = 0; i < n; ++i) {\n            if(!visited[i]) {\n                dfs(g, i, -1, cnt, visited);\n            }\n        }\n    }\n\n    std::vector<int> get_articulation_points() const { return articulation_points; }\n    std::vector<edge> get_bridges() const            { return bridges; }\n\n    bool is_bridge(int u, int v) const {\n        if(ord[u] > ord[v]) std::swap(u, v);\n        return ord[u] < low[v];\n    }\n\nprivate:\n    void dfs(graph const& g, int v, int prev, int& cnt, std::vector<bool>& visited) {\n        visited[v] = true;\n        low[v] = ord[v] = cnt++;\n        bool is_articulation = false;\n        int cnt2 = 0, pcnt = 0;\n\n        for(auto& e : g[v]) {\n            if((e.to != prev || (e.to == prev && pcnt == 1)) && visited[e.to]) {\n                low[v] = min(low[v], ord[e.to]);\n            } else if(!visited[e.to]) {\n                cnt2++;\n                dfs(g, e.to, v, cnt, visited);\n                low[v] = min(low[v], low[e.to]);\n                if(prev != -1 && ord[v] <= low[e.to]) {\n                    is_articulation = true;\n                }\n                if(is_bridge(v, e.to)) {\n                    bridges.push_back(edge{min(v, e.to), max(v, e.to), e.cost});\n                }\n            }\n            pcnt += e.to == prev;\n        }\n        is_articulation |= (prev == -1 && cnt2 > 1);\n        if(is_articulation) articulation_points.push_back(v);\n    }\n\nprivate:\n    std::vector<int> articulation_points;\n    std::vector<edge> bridges;\n    std::vector<int> ord, low;\n};\n\nvector<ll> djikstra(graph const& g, int s) {\n    const int n = g.size();\n    vector<ll> d(n, inf);\n    d[s] = 0;\n    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> que;\n    que.emplace(0, s);\n    while(!que.empty()) {\n        auto now = que.top(); que.pop();\n        const int v = now.second;\n        if(d[v] < now.first) continue;\n        for(auto& e : g[v]) {\n            if(d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.emplace(d[e.to], e.to);\n            }\n        }\n    }\n    return d;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    const int s = 0, t = 1;\n    edges es;\n    graph g(n), rg(n);\n    for(int i = 0; i < m; ++i) {\n        int a, b, c; cin >> a >> b >> c;\n        es.push_back(edge{a - 1, b - 1, c});\n        add_edge(g, a - 1, b - 1, c);\n        add_edge(rg, b - 1, a - 1, c);\n    }\n    auto from_s = djikstra(g, s), from_t = djikstra(rg, t);\n    const ll dist = from_s[t];\n    graph sg(n);\n    for(auto& e : es) {\n        if(from_s[e.from] + e.cost + from_t[e.to] == dist) {\n            add_edge(sg, e.from, e.to, e.cost);\n            add_edge(sg, e.to, e.from, e.cost);\n        }\n    }\n    lowlink helper(sg);\n    for(auto& e : es) {\n        if(from_s[e.to] + from_t[e.from] + e.cost <= dist) {\n            if(from_s[e.to] + from_t[e.from] + e.cost < dist) {\n                cout << \"HAPPY\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        } else if(from_s[e.from] + from_t[e.to] + e.cost == dist && helper.is_bridge(e.from, e.to)) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\nconst ll INF=0x3f3f3f3f;\nstruct HeapNode\n{\n    ll d;\n    int u;\n    bool operator<(const HeapNode &rhs)const\n    {\n        return d>rhs.d;\n    }\n};\nstruct Edge\n{\n    int from,to;\n    ll cost;\n};\nstruct Dij\n{\n    int n,m;\n    vector<int>G[maxn];\n    vector<int>G1[maxn];\n    vector<Edge>edges;\n    vector<Edge>edges1;\n    bool done[maxn];\n    ll d[maxn];\n    ll d1[maxn];\n    void init(int n)\n    {\n        this->n=n;\n        for(int i=0;i<=n;i++)\n        {\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    void addedge(int from,int to,int cost)\n    {\n        edges.push_back(Edge{from,to,cost});\n        edges1.push_back((Edge){to,from,cost});\n        m=edges.size();\n        G[from].push_back(m-1);\n        G1[to].push_back(m-1);\n    }\n    void dij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d[i]=INF;\n        d[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G[u].size();i++)\n            {\n                Edge &e=edges[G[u][i]];\n                if(d[e.to]>d[u]+e.cost)\n                {\n                    d[e.to]=d[u]+e.cost;\n                    Q.push((HeapNode){d[e.to],e.to});\n                }\n            }\n        }\n    }\n\n    void redij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d1[i]=INF;\n        d1[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G1[u].size();i++)\n            {\n                Edge &e=edges1[G1[u][i]];\n                //cout<<e.to<<endl;\n                if(d1[e.to]>d1[u]+e.cost)\n                {\n                    d1[e.to]=d1[u]+e.cost;\n                    Q.push((HeapNode){d1[e.to],e.to});\n                }\n            }\n        }\n    }\n}D;\n\nstruct node\n{\n    int x,y;\n    ll z;\n}s[maxn];\ntypedef pair<int,int>P;\nvector<P>G[maxn];\nint dfs_clock,pre[maxn],low[maxn];\nbool is_bridge[maxn];\nint dfs(int u,int fa)\n{\n    int lowu=pre[u]=++dfs_clock;\n    for(int i=0;i<G[u].size();i++)\n    {\n        int v=G[u][i].first;\n        if(!pre[v])\n        {\n            int lowv=dfs(v,u);\n            lowu=min(lowu,lowv);\n            if(lowv>pre[u])\n            {\n                is_bridge[G[u][i].second]=true;\n            }\n        }\n        else if(pre[v]<pre[u]&&fa!=v)\n            low[u]=min(low[u],pre[v]);\n    }\n    return low[u]=lowu;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    D.init(n);\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].z);\n        D.addedge(s[i].x,s[i].y,s[i].z);\n    }\n    D.dij(1);\n    D.redij(2);\n    for(int i=0;i<m;i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[x]+D.d1[y]+z==D.d[2])\n        {\n            G[x].push_back(make_pair(y,i));\n           // G[y].push_back(make_pair(x,i));\n        }\n    }\n    dfs(1,0);\n    for(int i=0;i<m;i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[y]+D.d1[x]+z<D.d[2])\n        {\n            printf(\"HAPPY\\n\");\n        }\n        else\n        {\n\n            if(D.d[x]+D.d1[y]+z==D.d[2]&&is_bridge[i])\n            {\n                printf(\"SAD\\n\");\n            }\n            else\n            {\n                printf(\"SOSO\\n\");\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long inf = 0x3f3f3f3f3f3f3f3fLL;\ntypedef pair<int, int> PII;\ntypedef unsigned int uint;\ntypedef unsigned long long uLL;\n\nconst int N = 1e5 + 10;\n\nint n, m;\n\nvector<PII> adj[N], radj[N];\n\nuLL cnt1[N], cnt2[N];\nlong long dis1[N], dis2[N];\n\nstruct node {\n\tint u, v; long long dis;\n\tnode (int u = 0, int v = 0, long long dis = 0)\n\t\t:u(u), v(v), dis(dis) {}\n\tbool operator < (const node &rhs) const {\n\t\treturn dis > rhs.dis;\n\t}\n};\n\nvector<node> E;\n\nint main() {\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\tadj[u].push_back(make_pair(v, w));\n\t\tradj[v].push_back(make_pair(u, w));\n\t\tE.push_back(node(u, v, w));\n\t}\n\n\tmemset (dis1, 0x3f, sizeof dis1);\n\tmemset (dis2, 0x3f, sizeof dis2);\n\t//count all shortest route from 1 to other nodes\n\tpriority_queue<node> pq;\n\tpq.push(node(0, 1, 0));\n\tcnt1[0] = 1;\n\twhile (!pq.empty()) {\n\t\tnode cur = pq.top(); pq.pop();\n\t\tif (dis1[cur.v] < cur.dis) continue;\n\t\tif (dis1[cur.v] == cur.dis) {\n\t\t\tcnt1[cur.v] += cnt1[cur.u];\n\t\t\tcontinue;\n\t\t}\n\t\tdis1[cur.v] = cur.dis;\n\t\tcnt1[cur.v] = cnt1[cur.u];\n\t\tfor (int i = 0; i < adj[cur.v].size(); i++) {\n\t\t\tlong long d = dis1[cur.v] + adj[cur.v][i].second;\n\t\t\tif (dis1[adj[cur.v][i].first] >= d) \n\t\t\t\tpq.push(node(cur.v, adj[cur.v][i].first, d));\n\t\t}\n\t}\n\n\tassert (pq.empty() == true);\n\t//count all shortest route from 2 to other nodes\n\tpq.push(node(0, 2, 0));\n\tcnt2[0] = 1;\n\twhile (!pq.empty()) {\n\t\tnode cur = pq.top(); pq.pop();\n\t\tif (dis2[cur.v] < cur.dis) continue;\n\t\tif (dis2[cur.v] == cur.dis) {\n\t\t\tcnt2[cur.v] += cnt2[cur.u];\n\t\t\tcontinue;\n\t\t}\n\t\tdis2[cur.v] = cur.dis;\n\t\tcnt2[cur.v] = cnt2[cur.u];\n\t\tfor (int i = 0; i < radj[cur.v].size(); i++) {\n\t\t\tlong long d = dis2[cur.v] + radj[cur.v][i].second;\n\t\t\tif (dis2[radj[cur.v][i].first] >= d) \n\t\t\t\tpq.push(node(cur.v, radj[cur.v][i].first, d));\n\t\t}\n\t}\n\n\tlong long shortdis = dis1[2];\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tif (i == 5)\n\t\t\ti = i;\n\t\tnode cur = E[i];\n\t\tlong long newdis = dis1[cur.v] + dis2[cur.u] + cur.dis;\n\t\tif (shortdis > dis1[cur.v] + dis2[cur.u] + cur.dis) {\n\t\t\tputs(\"HAPPY\");\n\t\t} else if (shortdis == newdis) {\n\t\t\tputs(\"SOSO\");\n\t\t} else if (shortdis < dis1[cur.u] + dis2[cur.v] + cur.dis) {\n\t\t\tputs(\"SOSO\");\n\t\t} else if (cnt1[cur.u] * cnt2[cur.v] == cnt1[2]) {\n\t\t\tputs(\"SAD\");\n\t\t} else {\n\t\t\tputs(\"SOSO\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n/*\n4 5\n1 3 5\n3 4 6\n4 2 7\n2 1 18\n3 2 13\n*/\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n\nconst ll INF = 1e15;\n\nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n\tdist[f->dst] = e.weight + f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\tprev[f->dst].clear();\n\tprev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n\tprev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n\npair<Graph, Graph> buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  Graph g2(n);\n  stack<int> st;\n  st.push(t);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    for(auto&& p : prev[now]){\n      if(p < 0)\n\tcontinue;\n      g[p].push_back(Edge(p, now, 1));\n      g2[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return pair<Graph, Graph>(g, g2);\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  n += 100;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w*2, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w*2 == befo.first)\n\tmp[P(s, d)] = P(w*2-1, befo.second + 1);\n      else\n\tmp[P(s, d)] = P(min(w*2, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree, tree2;\n  tie(tree, tree2) = buildPath(prev, 1);\n  for(int i=0;i<tree2.size();i++){\n    sort(tree2[i].begin(), tree2[i].end());\n  }\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n\n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n\n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n    \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w*2)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    ok |= binary_search(tree2[s].begin(), tree2[s].end(), Edge(s, d, 1));\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}\n/*\n11 15\n1 3 1\n3 6 2\n6 10 1\n1 5 3\n3 7 1\n5 9 1\n9 11 1\n7 8 1\n1 4 2\n4 8 1\n8 10 1\n10 11 1\n11 2 1\n10 7 1\n10 1 1\n */"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<ll,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %lld\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tll tmp_code;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_code = edge[i].from*100000+edge[i].to;\n\n\t\t\tauto at = MAP.find(tmp_code);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_code]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_code] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_code = edge[i].from*100000+edge[i].to;\n\n\t\tif(MAP[tmp_code] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N=1e6+10,mod=1e9+7,inf=0x3f3f3f3f3f3f3f3f;\nstruct sc\n{\n    ll id,dis;\n    bool operator<(const sc &a)const\n    {\n        return a.dis<dis;\n    }\n}p[N];\nvector<sc>link1[N],link2[N];\nll n,m,val1[N],val2[N],dis1[N],dis2[N],vis[N],a[N],b[N],c[N];\nvoid dij(ll s,vector<sc>link[],ll dis[],ll val[])\n{\n    priority_queue<sc>q;\n    for(ll i=1;i<=n;i++)dis[i]=inf,vis[i]=0,val[i]=0;\n    dis[s]=0;\n    val[s]=1;\n    vis[s]=1;\n    q.push({s,0});\n    while(!q.empty())\n    {\n        sc tep=q.top();q.pop();\n        //if(tep.dis>dis[tep.id])continue;\n        vis[tep.id]++;\n        for(sc p:link[tep.id])\n        {\n            if(tep.dis+p.dis==dis[p.id])\n            {\n                val[p.id]=(val[p.id]+val[tep.id])%mod;\n            }\n            if(!vis[p.id]&&tep.dis+p.dis<dis[p.id])\n            {\n                dis[p.id]=tep.dis+p.dis;\n                q.push({p.id,tep.dis+p.dis});\n                val[p.id]=val[tep.id];\n            }\n        }\n    }\n}\nint main()\n{\n    //freopen(\"i.txt\",\"r\",stdin);\n    scanf(\"%lld %lld\",&n,&m);\n    for(ll i=0;i<m;i++)\n    {\n        scanf(\"%lld %lld %lld\",&a[i],&b[i],&c[i]);\n        link1[a[i]].push_back({b[i],c[i]});\n        link2[b[i]].push_back({a[i],c[i]});\n    }\n    dij(1,link1,dis1,val1);\n    dij(2,link2,dis2,val2);\n    for(ll i=0;i<m;i++)\n    {\n        if(dis1[b[i]]+dis2[a[i]]+c[i]<dis1[2])puts(\"HAPPY\");\n        else if(dis1[a[i]]+dis2[b[i]]+c[i]==dis1[2]&&val1[a[i]]*val2[b[i]]%mod==val1[2])puts(\"SAD\");\n        else puts(\"SOSO\");\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int,int> PII;\ntypedef pair <long long,long long> PLL;\n\n#define si(a)           scanf(\"%d\",&a)\n#define sii(a,b)        scanf(\"%d %d\",&a,&b)\n#define siii(a,b,c)     scanf(\"%d %d %d\",&a,&b,&c)\n\n#define sl(a)           scanf(\"%lld\",&a)\n#define sll(a,b)        scanf(\"%lld %lld\",&a,&b)\n#define slll(a,b,c)     scanf(\"%lld %lld %lld\",&a,&b,&c)\n\n#define un(x)           x.erase(unique(all(x)), x.end())\n#define xx              first\n#define yy              second\n#define pb              push_back\n#define mp              make_pair\n#define all(v)          v.begin(),v.end()\n#define D(x)            cerr << #x \" = \" << x << '\\n'\n#define DBG             cerr << \"Hi!\" << '\\n'\n\n#define CLR(a)          memset(a,0,sizeof(a))\n#define SET(a)          memset(a,-1,sizeof(a))\n\n#define eps             1e-9\n#define PI              acos(-1.0)\n\nint setBit(int n,int pos) { return n = n | (1 << pos); }\nint resetBit(int n,int pos) { return n = n & ~(1 << pos); }\nbool checkBit(ll n,ll pos) { return (bool)(n & (1LL << pos)); }\n\n//int fx[] = {+0, +0, +1, -1, -1, +1, -1, +1};\n//int fy[] = {-1, +1, +0, +0, +1, +1, -1, -1}; //Four & Eight Direction\n\n/******************************************************************************************/\n\nconst int MAX = 100010;\nconst int INF = 200000000;\n\nvector <int> g[MAX], rg[MAX] , ed[MAX],bucket[MAX];\n\nint sdom[MAX],par[MAX],dom[MAX],dsu[MAX],label[MAX];\nint arr[MAX],rev[MAX],Time,n,source;\n\nvoid init(int _n,int _source) {\n    Time = 0;\n    n = _n;\n    source = _source;\n    for(int i=1;i<=n;i++) {\n        g[i].clear() , rg[i].clear() , ed[i].clear() , bucket[i].clear();\n        arr[i] = sdom[i] = par[i] = dom[i] = dsu[i] = label[i] = rev[i] = 0;\n    }\n}\n\n\nvoid dfs(int u) {\n    Time++;\n    arr[u] = Time;\n    rev[Time] = u;\n    label[Time] = Time;\n    sdom[Time] = Time;\n    dsu[Time] = Time;\n    int i,w;\n    for(i=0;i<g[u].size();i++) {\n        w = g[u][i];\n        if(!arr[w]) {\n            dfs(w);\n            par[arr[w]] = arr[u];\n        }\n        rg[arr[w]].pb(arr[u]);\n    }\n}\n\ninline int Find(int u,int x=0) {\n    if(u==dsu[u]) return x ? - 1 : u;\n    int v = Find(dsu[u],x+1);\n    if(v<0) return u;\n    if(sdom[label[dsu[u]]] < sdom[label[u]])\n        label[u] = label[dsu[u]];\n    dsu[u] = v;\n    return x ? v : label[u];\n}\n\n\ninline void Union(int u,int v) {\n    dsu[v] = u;\n}\n\nvoid build() {\n    dfs(source);\n    for(int i=n;i>=1;i--) {\n        for(int j=0;j<rg[i].size();j++)\n            sdom[i] = min(sdom[i],sdom[Find(rg[i][j])]);\n        if(i>1)\n            bucket[sdom[i]].pb(i);\n        for(int j=0;j<bucket[i].size();j++) {\n            int w = bucket[i][j] , v = Find(w);\n            if(sdom[v] == sdom[w]) dom[w] = sdom[w];\n            else dom[w] = v;\n        }\n        if(i>1) Union(par[i],i);\n\n        for(int i=2;i<=n;i++) {\n            if(dom[i]!=sdom[i]) dom[i] = dom[dom[i]];\n\n            if(rev[i]==0 or rev[dom[i]]==0) continue;\n\n            ed[rev[i]].pb(rev[dom[i]]);\n            ed[rev[dom[i]]].pb(rev[i]);\n        }\n    }\n}\n\nvector <int> G[2][MAX];\nvector <int> co[2][MAX];\nint dis[2][MAX];\nbool vis[2][MAX];\n\nstruct node {\n    int city,cost;\n};\n\nbool operator < (node a,node b) {\n    return a.cost > b.cost;\n}\n\nvoid dijkstra(int s,int n,int id) {\n    int i,x,u,v,c;\n    node a,b;\n    for(int i=1;i<=n;i++) dis[id][i] = INF;\n    dis[id][s] = 0;\n    a = {s,0};\n    priority_queue <node> Q;\n    Q.push(a);\n\n    while(!Q.empty()) {\n        a = Q.top();\n        Q.pop();\n        u = a.city;\n        if(!vis[id][u]) {\n            vis[id][u] = true;\n            for(int i=0;i<G[id][u].size();i++) {\n                v = G[id][u][i];\n                c = co[id][u][i];\n                if(dis[id][v] > dis[id][u] + c) {\n                    dis[id][v] = dis[id][u] + c;\n                    b = {v,dis[id][v]};\n                    Q.push(b);\n                }\n            }\n        }\n    }\n}\n\nint lg;\nint L[MAX],P[MAX][22];\n\nvoid dfss(int s,int par,int l) {\n    int i,x;\n    L[s] = l;\n    for(int i=0;i<ed[s].size();i++) {\n        x = ed[s][i];\n        if(x!=par) {\n            P[x][0] = s;\n            dfss(x,s,l+1);\n        }\n    }\n}\n\nvoid lca_build(int n,int root) {\n    SET(P);\n    dfss(root,-1,0);\n    lg = (log(n)/log(2.0))+2;\n\n    int i,j;\n    for(int j=1;(1<<j)<=n;j++) {\n        for(i=1;i<=n;i++) {\n            if(P[i][j-1]!=-1) P[i][j] = P[P[i][j-1]][j-1];\n        }\n    }\n}\n\ninline int lca_query(int x,int y) {\n    if(L[x]<L[y]) swap(x,y);\n    int i,j;\n    for(i=lg;i>=0;i--) {\n        if(L[x] - (1<<i) >= L[y]) x = P[x][i];\n    }\n\n    if(x==y) return x;\n    for(i=lg;i>=0;i--) {\n        if(P[x][i]!=-1 && P[x][i]!=P[y][i]) {\n            x = P[x][i];\n            y = P[y][i];\n        }\n    }\n    return P[x][0];\n}\n\n\nstruct Edge {\n    int u,v,w;\n} edges[MAX];\n\nmap < PII , int > Mn;\nmap < PII , int > Cnt;\n\nbool ase[MAX];\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    int m,u,v,w;\n    sii(n,m);\n\n    init(n,1);\n\n    for(int i=1;i<=m;i++) {\n        siii(u,v,w);\n        edges[i] = {u,v,w};\n\n        if(Mn.find({u,v})==Mn.end()) {\n            Mn[{u,v}] = w;\n            Cnt[{u,v}] = 1;\n        }\n        else {\n            if(w==Mn[{u,v}]) Cnt[{u,v}]++;\n            else if(w<Mn[{u,v}]){\n                Mn[{u,v}] = w;\n                Cnt[{u,v}] = 1;\n            }\n        }\n        G [0][u].push_back(v);\n        co[0][u].push_back(w);\n\n        G [1][v].push_back(u);\n        co[1][v].push_back(w);\n    }\n\n    dijkstra(1,n,0);\n    dijkstra(2,n,1);\n\n\n\n\n    for(int i=1;i<=m;i++) {\n        u = edges[i].u;\n        v = edges[i].v;\n        w = edges[i].w;\n        if(dis[0][u] + w + dis[1][v] == dis[0][2]) {\n            g[u].pb(v);\n            ase[i] = true;\n        }\n    }\n\n    build();\n    lca_build(n,1);\n    for(int i=1;i<=m;i++) {\n        u = edges[i].u;\n        v = edges[i].v;\n        w = edges[i].w;\n\n        if(dis[0][v] + w + dis[1][u] < dis[0][2]) {\n            puts(\"HAPPY\");\n            continue;\n        }\n\n        if(!ase[i]) {\n            puts(\"SOSO\");\n            continue;\n        }\n\n\n        if( Cnt[{u,v}] >=2 ) {\n            puts(\"SOSO\");\n            continue;\n        }\n\n        if(lca_query(u,2)==u && lca_query(v,2)==v) {\n            puts(\"SAD\");\n            continue;\n        }\n        else {\n            puts(\"SOSO\");\n            continue;\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n\nHeart beats fast\nColours and promises\nHow to be brave?\nHow can I love when I'm afraid to fall?\nBut watching you stand alone,\nAll of my doubt suddenly goes away somehow.\n\nOne step closer\n\nI have died every day waiting for you\nDarling, don't be afraid.\nI have loved you for a thousand years\nI'll love you for a thousand more\n\nTime stands still\nBeauty in all she is\nI will be brave\nI will not let anything take away\nWhat's standing in front of me\nEvery breath\nEvery hour has come to this\n\nOne step closer\nOne step closer\n\nI have died every day waiting for you\nDarling, don't be afraid.\nI have loved you for a thousand years\nI'll love you for a thousand more\n\nAnd all along I believed I would find you\nTime has brought your heart to me\nI have loved you for a thousand years\nI'll love you for a thousand more\n\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst long long mod = 2e9 + 89;\nconst long long inf = 1e18;\n\n/****** Tarjan???s SCC *******/\nvector< int > num, low, S, vis, comp, adj[N];\nint cntr, numCC;\n\nvoid tarjanSCC(int v, int bef = -1) {\n  low[v] = num[v] = ++cntr;\n  vis[v] = 1;\n  S.push_back(v);\n  for(auto u : adj[v]) {\n    if (u == bef) continue;\n    if(num[u] == -1)\n      tarjanSCC(u, v);\n    if(vis[u])\n      low[v] = min(low[v], low[u]);\n  }\n  if(low[v] == num[v]) {\n    numCC++;\n    while(1) {\n      int u = S.back(); S.pop_back(); vis[u] = 0;\n      comp[u] = numCC;\n      if(u == v)\n        break;\n    }\n  }\n}\n\nlong long d[N];\nint u[N], v[N], w[N];\nvector<pair<int, int>> edge[N];           // node - cost\nvector<tuple<int, int, int>> rev[N];      // node - cost - id\nbool good[N], done[N];\n\nvoid dfs(int now) {\n  if (done[now]) return;\n  done[now] = 1;\n  for (auto it : rev[now]) {\n    int to, cost, id;\n    tie(to, cost, id) = it;\n    if (d[to] + cost == d[now]) {\n      good[id] = 1;\n      dfs(to);\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", u + i, v + i, w + i);\n    edge[u[i]].emplace_back(v[i], w[i]);\n    rev[v[i]].emplace_back(u[i], w[i], i);\n  }\n  fill(d, d + N, inf);\n  d[1] = 0;\n  priority_queue<pair<long long, int>> pq;\n  pq.emplace(-d[1], 1);\n  while (!pq.empty()) {\n    long long cost;\n    int now;\n    tie(cost, now) = pq.top();\n    pq.pop();\n    cost = -cost;\n    if (d[now] != cost) continue;\n    for (auto it : edge[now]) {\n      long long ncos = cost + it.second;\n      int near = it.first;\n      if (ncos < d[near]) {\n        d[near] = ncos;\n        pq.emplace(-d[near], near);\n      }\n    }\n  }\n  dfs(2);\n  for (int i = 0; i < m; i++) {\n    if (good[i]) {\n      adj[u[i]].push_back(v[i]);\n      adj[v[i]].push_back(u[i]);\n    }\n  }\n  num.assign(n + 1, -1);\n  low.assign(n + 1, 0);\n  vis.assign(n + 1, 0);\n  comp.assign(n + 1, -1);\n  cntr = numCC = 0;\n  for(int i = 1; i <= n; i++)\n    if(num[i] == -1)\n      tarjanSCC(i);\n  \n  /*\n  puts(\"d\");\n  for (int i = 1; i <= n; i++) printf(\"%lld \", d[i]); printf(\"\\n\");\n  puts(\"good\");\n  for (int i = 0; i < m; i++) printf(\"%d \", good[i]); printf(\"\\n\");\n  puts(\"comp\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", comp[i]); printf(\"\\n\");\n  */\n  for (int i = 0; i < m; i++) {\n    if (d[u[i]] > d[v[i]] + w[i] && done[u[i]]) {\n      puts(\"HAPPY\");\n    } else if (good[i] && comp[u[i]] != comp[v[i]]) {\n      puts(\"SAD\");\n    } else {\n      puts(\"SOSO\");\n    }\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    typedef long long ll;\n    const ll INF = 1LL << 56;\n    int N, M;\n\n    struct Edge {\n        int from, to; ll cost;\n        Edge(int from, int to, ll cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            if (from == e.from) {\n                return to == e.to ? cost < e.cost : to < e.to;\n            } else {\n                return from < e.from;\n            }\n        }\n        bool operator==(const Edge& e) {\n            return to == e.to and from == e.from and cost == e.cost;\n        }\n    };\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \",\" << e.to << \",\" << e.cost << \")\";\n    }\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    vector<vector<Edge>> G, RG;\n    vector<Edge> es;\n    map<Edge, int> X;\n\n    vector<pair<int, int>> findBridges(const vector<vector<Edge>>& G) {\n        int V = N;\n        vector<int> dfs_order(V, -1);\n        vector<int> lowlink(V, 0);\n        int c = 0;\n        vector<pair<int, int>> bridges;\n        function<void(int, int)> dfs = [&](int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            for (auto& e : G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) {\n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges.emplace_back(l, g);\n                }\n            }\n        };\n        dfs(0, -1);\n        return bridges;\n    }\n\n    void input() {\n        cin >> N >> M;\n        G.resize(N);\n        RG.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b; ll c;\n            cin >> a >> b >> c;\n            a--; b--;\n            Edge e(a, b, c);\n            if (X.count(e)) {\n                X[e]++;\n            } else {\n                G[a].emplace_back(a, b, c);\n                RG[b].emplace_back(b, a, c);\n                X[e] = 1;\n            }\n            es.emplace_back(a, b, c);\n        }\n    }\n\n    struct S {\n        int v; ll cost;\n        S(int v, ll cost) : v(v), cost(cost) {}\n        bool operator<(const S& s) const {\n            return cost > s.cost;\n        }\n    };\n\n    void dijkstra(const vector<vector<Edge>>& G, int start, vector<ll>& D, vector<vector<Edge>>& prev) {\n        priority_queue<S> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : G[cur.v]) {\n                auto next = e.to;\n                auto ncost = D[cur.v] + e.cost;\n                if (D[next] > ncost) {\n                    prev[next].clear();\n                    prev[next].push_back(e);\n                    D[next] = ncost;\n                    PQ.emplace(next, ncost);\n                } else if (D[next] == ncost) {\n                    prev[next].push_back(e);\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<ll> D(N, INF);\n        vector<ll> RD(N, INF);\n        vector<vector<Edge>> prev(N, vector<Edge>());\n        vector<vector<Edge>> rprev(N, vector<Edge>());\n        dijkstra(G, 0, D, prev);\n        dijkstra(RG, 1, RD, rprev);\n\n        vector<vector<Edge>> shortest_paths(N, vector<Edge>());\n        function<void(int)> dfs = [&](int v) {\n            if (prev[v].empty()) return;\n            for (auto e : prev[v]) {\n                shortest_paths[e.from].push_back(e);\n                dfs(e.from);\n            }\n        };\n        dfs(1);\n\n        auto _bridges = findBridges(shortest_paths);\n        //cout << _bridges << endl;\n        set<pair<int, int>> bridges;\n        for (auto b : _bridges) { bridges.insert(b); }\n\n        for (int i = 0; i < M; i++) {\n            auto e = es[i];\n            if (D[e.from] + e.cost + RD[e.to] == D[1]) {\n                if (\n                    (bridges.count(make_pair(e.from, e.to)) \n                     or bridges.count(make_pair(e.to, e.from)))\n                     and X[e] <= 1) {\n                    cout << \"SAD\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            } else {\n                auto ncost = D[e.to] + e.cost + RD[e.from];\n                if (ncost < D[1]) {\n                    cout << \"HAPPY\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n            if(ord[now] < low[nxt]) {\n                bridges.insert(nxt_e.index);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    dfs(0, -1);\n    // rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;    \n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        edges.push_back(Edge{i, a - 1, b - 1, c, false});\n    }\n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return make_tuple(a.from, a.to, a.cost) < make_tuple(b.from, b.to, b.cost);\n        });\n    rep(i, M) {\n        auto &e = edges[i]; // mut\n        int index = e.index;\n        int a = e.from;\n        int b = e.to;\n        int c = e.cost;\n        if(i > 0) {\n            auto &pe = edges[i - 1]; // mut\n            if(pe.from == a and pe.to == b) {\n                e.multi = true;\n                if(pe.cost == e.cost) edges[i - 1].multi = true;\n                continue;\n            }\n        }\n        E[a].push_back(Edge{index, a, b, c});\n        rE[b].push_back(Edge{index, b, a, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        const Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and not e.multi) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n  llint to, cost, id;\n  edge(){}\n  edge(llint a, llint b, llint c){\n    to = a, cost = b, id = c;\n  }\n};\n\nllint n, m;\nvector<edge> G[100005], revG[100005];\nvector<llint> pathG[100005];\nllint distS[100005], distT[100005];\nbool path[100005], only[100005];\nconst int S = 1, T = 2;\nllint ans[100005];\nbool used[100005], valid[100005];\nvector<llint> brgG[100005], revbrgG[100005];\nllint scc[100005];\n\nvoid pathdfs(int v)\n{\n  if(used[v]) return;\n  used[v] = true;\n  for(int i = 0; i < revG[v].size(); i++){\n    if(!path[revG[v][i].id]) continue;\n    valid[revG[v][i].id] = true;\n    pathG[revG[v][i].to].push_back(v);\n    pathG[v].push_back(revG[v][i].to);\n    pathdfs(revG[v][i].to);\n  }\n}\n\nvoid brgdfs(int v, int pre)\n{\n  if(used[v]) return;\n  used[v] = true;\n  for(int i = 0; i < pathG[v].size(); i++){\n    if(pathG[v][i] == pre) continue;\n    brgG[v].push_back(pathG[v][i]);\n    revbrgG[pathG[v][i]].push_back(v);\n    brgdfs(pathG[v][i], v);\n  }\n}\n\nvector<llint> topo;\nvoid tpsort(llint v, llint pre)\n{\n  used[v] = true;\n  for(int i = 0; i < brgG[v].size(); i++){\n    if(brgG[v][i] == pre) continue;\n    if(used[brgG[v][i]]) continue;\n    tpsort(brgG[v][i], v);\n  }\n  topo.push_back(v);\n}\n\nvoid sccdfs(int v, int pre, int id)\n{\n  used[v] = true;\n  scc[v] = id;\n  for(int i = 0; i < revbrgG[v].size(); i++){\n    if(revbrgG[v][i] == pre) continue;\n    if(used[revbrgG[v][i]]) continue;\n    sccdfs(revbrgG[v][i], v, id);\n  }\n}\n\nvoid findBridge(){\n  for(int i = 1; i <= n; i++) used[i] = false;\n  brgdfs(1, -1);\n\n  for(int i = 1; i <= n; i++) used[i] = false;\n  for(int i = 1; i <= n; i++){\n    if(!used[i]) tpsort(i, -1);\n  }\n  reverse(topo.begin(), topo.end());\n\n  int id = 1;\n  for(int i = 1; i <= n; i++) used[i] = false;\n  for(int i = 0; i < topo.size(); i++){\n    if(!used[topo[i]]) sccdfs(topo[i], -1, id++);\n  }\n\n  for(int i = 1; i <= n; i++){\n    for(int j = 0; j < G[i].size(); j++){\n      if(!path[G[i][j].id] || !valid[G[i][j].id]) continue;\n      if(scc[i] != scc[G[i][j].to]) only[G[i][j].id] = true;\n    }\n  }\n}\n\nvoid dijkstra(vector<edge> G[], llint S, llint dist[])\n{\n  for(int i = 1; i <= n; i++) used[i] = false;\n  for(int i = 1; i <= n; i++) dist[i] = inf;\n  used[S] = 0, dist[S] = 0;\n\n  priority_queue<P, vector<P>, greater<P> > Q;\n  Q.push(make_pair(0LL, S));\n  while(Q.size()){\n    llint d = Q.top().first;\n    llint v = Q.top().second;\n    Q.pop();\n    if(dist[v] < d)  continue;\n    for(int i = 0; i < G[v].size(); i++){\n      llint u = G[v][i].to;\n      if(dist[u] > dist[v] + G[v][i].cost){\n        dist[u] = dist[v] + G[v][i].cost;\n        Q.push(make_pair(dist[u], u));\n      }\n    }\n  }\n}\n\nint main(void)\n{\n  cin >> n >> m;\n  llint a, b, c;\n  for(int i = 1; i <= m; i++){\n    cin >> a >> b >> c;\n    G[a].push_back(edge(b, c, i));\n    revG[b].push_back(edge(a, c, i));\n  }\n\n  dijkstra(G, 1, distS);\n  dijkstra(revG, 2, distT);\n\n  for(int i = 1; i <= n; i++){\n    for(int j = 0; j < G[i].size(); j++){\n      if(distS[i] + G[i][j].cost == distS[G[i][j].to]){\n        path[G[i][j].id] = true;\n      }\n    }\n  }\n\n  for(int i = 1; i <= n; i++) used[i] = false;\n  pathdfs(T);\n  findBridge();\n\n  for(int i = 1; i <= n; i++){\n    for(int j = 0; j < G[i].size(); j++){\n      if(!path[G[i][j].id]){\n        if(distS[T] > distS[G[i][j].to] + G[i][j].cost + distT[i]) ans[G[i][j].id] = 1;\n        else ans[G[i][j].id] = 0;\n      }\n      else{\n        if(only[G[i][j].id]) ans[G[i][j].id] = -1;\n        else ans[G[i][j].id] = 0;\n      }\n    }\n  }\n\n  for(int i = 1;i <= m; i++){\n    if(ans[i] == 1) cout << \"HAPPY\";\n    if(ans[i] == 0) cout << \"SOSO\";\n    if(ans[i] == -1) cout << \"SAD\";\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %lld\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\tdijkstra_NORMAL();\n\tdijkstra_REVERSE();\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\tstring tmp_str;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str.clear();\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\tint from,to;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\ttmp_str.clear();\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n            if(ord[now] < low[nxt]) {\n                bridges.insert(nxt_e.index);\n            }\n        }\n    };\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n    map<pii, int> min_edge;\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        edges.push_back(Edge{i, a, b, c});\n        auto p = make_pair(a, b);\n        if(!min_edge.count(p) or min_edge[p] > c) min_edge[p] = c;        \n    }\n    map<pii, int> min_edge_count;\n    rep(i, M) {\n        auto &e = edges[i]; // mut\n        auto p = make_pair(e.from, e.to);\n        if(min_edge[p] == e.cost) min_edge_count[p]++;\n        E[e.from].push_back(e);\n        rE[e.to].push_back(Edge{e.index, e.to, e.from, e.cost});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n    shortest_graph[1].clear();\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        const Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and min_edge_count[make_pair(e.from, e.to)] == 1) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 99999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n \nint par[500100],ranks[500100],kosuu[500100];     \n \nvoid shoki(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        ranks[i]=0;\n        kosuu[i]=1;\n    }\n}\n \nint root(int x){\n    return par[x]==x ? x : par[x]=root(par[x]);\n}\n \nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n \nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n    int xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n    if(ranks[x]<ranks[y]){\n        par[x]=y;\n        kosuu[y]=yy+xx;\n    }\n else {\n    par[y]=x;\n    if(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n    kosuu[x]=yy+xx;\n }\n    return;\n}\n \nint gcd(int a1,int a2){\n    if(a1<a2) return gcd(a2,a1);\n    if(a2==1) return 1;\n    if(a1%a2==0) return a2;\n    return gcd(a2,a1%a2);\n}\n \n \nint rui2(int e,int r){\n    if(r==0) return 1;\n    if(r==1) return e%inf;\n    if(r%2==1) return (e*rui2(e,r-1))%inf;\n    int w=rui2(e,r/2)%inf;\n    return (w*w)%inf;\n}\n \nint inf2=1000000000ll*100000ll;\nint n,m;\nvector<pa>G[100030],G2[100030];\nvector<int> dag[100030],dag2[100030];\nint s1[100030],s2[100030],a[100030],b[100030],c[100030];\nint ans[100030]={0};\nbool sumi[100030]={0};\npriority_queue<pa,vector<pa>,greater<pa>> pq;\nint nyu[100030]={0},shu[100030]={0};\nint ok[100030]={0};\n \n \nvector<int> topo;\nint jisuu[100030]={0};\n \nint hashi[100030]={0};\nint dagk1[100030]={0},dagk2[100030]={0};\n \nvoid dagkosuu(int u){\n    if(dagk1[u])return;\n    int ans=0;\n    for(auto v:dag2[u])ans+=dagk1[v],ans%=inf;\n    dagk1[u]=ans%inf;\n}\n \nvoid dagkosuu2(int u){\n    if(dagk2[u])return;\n    int ans=0;\n    for(auto v:dag[u])ans+=dagk2[v],ans%=inf;\n    dagk2[u]=ans%inf;\n}\n \n \nvoid toporoji(){\n     \n    queue<int> qu;\n    qu.push(1);\n     \n    for(int i=1;i<=n;i++)for(auto v:dag[i])jisuu[v]++;\n     \n    while(qu.size()>0){\n        int r=qu.front();\n        qu.pop();\n        topo.pb(r);\n         \n        for(auto v:dag[r]){\n            jisuu[v]--;\n            if(jisuu[v]==0) qu.push(v);\n        }\n    }\n     \n}\n \nbool  check(int i){\n    return (dagk1[a[i]]*dagk2[b[i]])%inf==dagk1[2]%inf;\n     \n}\n  \n  \nint dfsb( vector<pa>& res, int v, int& count, int from, VI& low, VI& pre) {\n  pre[v] = count++;\n  low[v] = pre[v];\n\tbool bbb=false;\n  for (auto it = dag[v].begin(); it != dag[v].end(); it++) {\n    int to = *it;\n  //    bool b=false;\n    if (pre[to] == -1) {\n      // destination has not been visited\n      // visit destination and update low[v]\n      low[v] = min(low[v], dfsb( res, to, count, v, low, pre));\n      if (low[to] == pre[to]) {\n        // edge is not contained in a closed path -> bridge\n        res.pb(mp(v, to));\n      }\n    } else {\n      if (from == to &&!bbb) {\n       bbb=1;\n        // ignore a path to parent\n        continue;\n      }\n      low[v] = min(low[v], low[to]);\n    }\n  }\n  return low[v];\n}\n \n \nvector<pa> bridges(int V) {\n  vector<pa> res;\n  if (V > 0) {\n    // assume at least the first vertex exists\n    vector<int> low(V+1, -1);  // lowest reacheable index\n    vector<int> pre(V+1, -1);  // pre-order index\n    int count = 0;  // pre-order index counter\n    dfsb(res, 1, count, -1, low, pre);  // start dfs from vertex 0\n  }\n  return res;\n}\nset<pa> se;\n  \n            signed main(){\n   cin>>n>>m;\n                for(int i=0;i<m;i++){\n                int y,yy,yyy;\n                    cin>>y>>yy>>yyy;\n                    G[y].pb(mp(yy,yyy));\n                    G2[yy].pb(mp(y,yyy));\n                    a[i]=y;\n                    b[i]=yy;\n                    c[i]=yyy;\n                 \n                }\n                for(int i=0;i<n+10;i++)sumi[i]=0,s1[i]=inf2;\n                pq.push(mp(0,1));\n                while(pq.size()){\n                    pa z=pq.top();\n                    pq.pop();\n                    if(sumi[z.second])continue;\n                    s1[z.second]=z.first;\n                    sumi[z.second]=1;\n                    for(auto v:G[z.second])pq.push(mp(z.first+v.second,v.first));\n                }\n                for(int i=0;i<n+10;i++)sumi[i]=0,s2[i]=inf2;\n                pq.push(mp(0,2));\n                while(pq.size()){\n                    pa z=pq.top();\n                    pq.pop();\n                    if(sumi[z.second])continue;\n                    s2[z.second]=z.first;\n                    sumi[z.second]=1;\n                    for(auto v:G2[z.second])pq.push(mp(z.first+v.second,v.first));\n                }\n                 \n                int len=s1[2];\n                 \n                for(int i=0;i<m;i++){\n                    if(s1[a[i]]+s2[b[i]]+c[i]==len){\n                        dag[a[i]].pb(b[i]);\n                        dag[b[i]].pb(a[i]);\n                         \n                //      cout<<\"dag \"<<a[i]<<\" \"<<b[i]<<endl;\n                     \n                    }\n                    else{\n                        if(s1[b[i]]+s2[a[i]]+c[i]<len)ans[i]=1;\n                        else ans[i]=3;\n                         \n                         \n                    }\n                     \n                }\n            //  saiki(1);\n                vector<pa> w=bridges(n);\n                for(auto v:w){\n                //  cout<<v.first<<\" \"<<v.second<<endl;\n                    se.insert(v);\n                    swap(v.first,v.second);\n                    se.insert(v);\n                }\n                for(int i=0;i<m;i++){\n                    if(ans[i])continue;\n           //       cout<<a[i]<<\" \"<<b[i]<<endl;\n                    if(se.find(mp(a[i],b[i]))!=se.end()) ans[i]=2;\n                    else ans[i]=3;\n                     \n                }\n                 \n                for(int i=0;i<m;i++){\n                    if(ans[i]==1)cout<<\"HAPPY\"<<endl;\n                    if(ans[i]==2)cout<<\"SAD\"<<endl;\n                    if(ans[i]==3)cout<<\"SOSO\"<<endl;\n                }\n            }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef vector< vector< edge > > Graph;\n\ntemplate< typename T = int >\nvector< T > Dijkstra(Graph &g, int s)\n{\n  typedef pair< T, int > Pi;\n  vector< T > min_cost(g.size(), numeric_limits< T >::max() / 3);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, s);\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > min_cost[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost >= min_cost[e.to]) continue;\n      min_cost[e.to] = p.first + e.cost;\n      que.emplace(min_cost[e.to], e.to);\n    }\n  }\n  return (min_cost);\n}\n\n\nint main()\n{\n  int N, M, A[100000], B[100000], C[100000];\n\n  scanf(\"%d %d\", &N, &M);\n  Graph g(N), rg(N), dag(N);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n    --A[i], --B[i];\n    g[A[i]].emplace_back((edge) {B[i], C[i]});\n    rg[B[i]].emplace_back((edge) {A[i], C[i]});\n  }\n  auto latte = Dijkstra< int64 >(g, 0);\n  auto malta = Dijkstra< int64 >(rg, 1);\n  vector< int > ans(M, -1);\n  for(int i = 0; i < M; i++) {\n    if(latte[A[i]] + malta[B[i]] + C[i] == latte[1]) {\n      dag[A[i]].emplace_back((edge) {B[i], i});\n      dag[B[i]].emplace_back((edge) {A[i], i});\n    } else if(latte[B[i]] + malta[A[i]] + C[i] < latte[1]) {\n      ans[i] = 1;\n    } else {\n      ans[i] = 0;\n    }\n  }\n\n  vector< int > dp(N), order(N);\n  bool v[100000] = {};\n  int ord = 0;\n  function< void(int, int) > dfs = [&](int idx, int par)\n  {\n    v[idx] = true;\n    dp[idx] = ord++;\n    order[idx] = dp[idx];\n    for(auto &e : dag[idx]) {\n      if(e.cost == par) continue;\n      if(!v[e.to]) dfs(e.to, e.cost), dp[idx] = min(dp[idx], dp[e.to]);\n      else dp[idx] = min(dp[idx], order[e.to]);\n      if(dp[e.to] <= order[idx]) ans[e.cost] = 0;\n    }\n  };\n  dfs(0, -1);\n\n  for(int i = 0; i < M; i++) {\n    if(ans[i] == 0) puts(\"SOSO\");\n    else if(ans[i] == 1) puts(\"HAPPY\");\n    else puts(\"SAD\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 58;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int Soso  = 1;\nconst int Happy = 2;\nconst int Sad   = 3;\n\nusing Edge = tuple<int, int, int>;\n\nvll dijkstra(vector<vector<Edge>>& G, int sv){\n    int n = G.size();\n    vll min_dist(n, inf);\n    min_dist[sv] = 0;\n\n    using Elem = tuple<ll, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    q.push(Elem(0, sv));\n\n    while(q.size()){\n        ll c; int v; tie(c, v) = q.top(); q.pop();\n        if(min_dist[v] != c) continue;\n\n        for(auto& e : G[v]){\n            int nv, dc, ei; tie(nv, dc, ei) = e;\n            ll nc = c + dc;\n            if(chmin(min_dist[nv], nc)){\n                q.push(Elem(nc, nv));\n            }\n        }\n    }\n    return min_dist;\n}\n\nint depthMax;\nvi etype;\nvi depth;\nvi used;\nvi path;\nvi imo;\nvi oute;\n\nbool dfs(vector<vector<Edge>>& G, int v, int tv, int d){\n    if(v == tv){\n        path.emplace_back(v);\n        depth[v] = d;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(dfs(G, nv, tv, d + 1)){\n            path.emplace_back(v);\n            depth[v] = d;\n            used[ei] = true;\n            oute.emplace_back(ei);\n            return true;\n        }\n    }\n    return false;\n}\n\nvi visited;\nbool dfs2(vector<vector<Edge>>& G, int v, int d){\n    if(depth[v] > d){\n        imo[d]++;\n        imo[depth[v]]--;\n        return true;\n    }\n    visited[v] = true;\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(visited[nv]) continue;\n        if(used[ei]) continue;\n        if(dfs2(G, nv, d)){\n            // etype[ei] = Soso;\n        }\n    }\n\n    if(d < depthMax - 1){\n        return dfs2(G, path[d + 1], d + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m; cin >> n >> m;\n    vector<vector<Edge>> G(n), Gr(n);\n    vi as(m), bs(m), cs(m);\n    rep(i, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        G [a].emplace_back(Edge(b, c, i));\n        Gr[b].emplace_back(Edge(a, c, i));\n        as[i] = a, bs[i] = b, cs[i] = c;\n    }\n\n    int sv = 0, tv = 1;\n    auto min_dist     = dijkstra(G, sv);\n    auto min_dist_rev = dijkstra(Gr, tv);\n\n    etype = vi(m, Soso);\n\n    vector<vector<Edge>> Gs(n);\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[a] + c == min_dist[b]){\n            Gs[a].emplace_back(Edge(b, c, i));\n        }\n    }\n    depth = vi(n, -1);\n    used  = vi(m);\n    dfs(Gs, sv, tv, 0);\n    reverse(_all(path));\n    reverse(_all(oute));\n    depthMax = path.size();\n\n    // for(auto& e : path) cerr << e+1 << \" \"; cerr << endl;\n    // for(auto& e : oute) cerr << e+1 << \" \"; cerr << endl;\n\n    imo = vi(depthMax);\n    visited = vi(n);\n    dfs2(Gs, sv, 0);\n    rep(i, 1, depthMax) imo[i] += imo[i - 1];\n    rep(i, depthMax - 1){\n        if(imo[i] == 0){\n            etype[oute[i]] = Sad;\n        }\n    }\n\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[b] + min_dist_rev[a] + c < min_dist[tv]){\n            etype[i] = Happy;\n        }\n    }\n\n    rep(i, m){\n        string res = \"SOSO\";\n        if(etype[i] == Happy){\n            res = \"HAPPY\";\n        }\n        else if(etype[i] == Sad){\n            res = \"SAD\";\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n\nHeart beats fast\nColours and promises\nHow to be brave?\nHow can I love when I'm afraid to fall?\nBut watching you stand alone,\nAll of my doubt suddenly goes away somehow.\n\nOne step closer\n\nI have died every day waiting for you\nDarling, don't be afraid.\nI have loved you for a thousand years\nI'll love you for a thousand more\n\nTime stands still\nBeauty in all she is\nI will be brave\nI will not let anything take away\nWhat's standing in front of me\nEvery breath\nEvery hour has come to this\n\nOne step closer\nOne step closer\n\nI have died every day waiting for you\nDarling, don't be afraid.\nI have loved you for a thousand years\nI'll love you for a thousand more\n\nAnd all along I believed I would find you\nTime has brought your heart to me\nI have loved you for a thousand years\nI'll love you for a thousand more\n\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst long long mod = 2e9 + 89;\nconst long long inf = 1e18;\n\n/****** Tarjan???s SCC *******/\nvector< int > num, low, S, vis, comp, adj[N];\nint cntr, numCC;\n\nvoid tarjanSCC(int v, int bef = -1) {\n  low[v] = num[v] = ++cntr;\n  vis[v] = 1;\n  S.push_back(v);\n  for(auto u : adj[v]) {\n    if (u == bef) continue;\n    if(num[u] == -1)\n      tarjanSCC(u, v);\n    if(vis[u])\n      low[v] = min(low[v], low[u]);\n  }\n  if(low[v] == num[v]) {\n    numCC++;\n    while(1) {\n      int u = S.back(); S.pop_back(); vis[u] = 0;\n      comp[u] = numCC;\n      if(u == v)\n        break;\n    }\n  }\n}\n\nvoid dijkstra(int start, long long* d, vector<tuple<int, int, int>> edge[N]) {\n  fill(d, d + N, inf);\n  d[start] = 0;\n  priority_queue<pair<long long, int>> pq;\n  pq.emplace(-d[start], start);\n  while (!pq.empty()) {\n    long long cost;\n    int now;\n    tie(cost, now) = pq.top();\n    pq.pop();\n    cost = -cost;\n    if (d[now] != cost) continue;\n    for (auto it : edge[now]) {\n      long long add; int near;\n      tie(near, add, ignore) = it;\n      long long ncos = cost + add;\n      if (ncos < d[near]) {\n        d[near] = ncos;\n        pq.emplace(-d[near], near);\n      }\n    }\n  }\n}\n\nlong long d[N], drev[N];\nint u[N], v[N], w[N];\nvector<tuple<int, int, int>> edge[N];           // node - cost - id\nvector<tuple<int, int, int>> rev[N];            // node - cost - id\nbool good[N], done[N];\n\nvoid dfs(int now) {\n  if (done[now]) return;\n  done[now] = 1;\n  for (auto it : rev[now]) {\n    int to, cost, id;\n    tie(to, cost, id) = it;\n    if (d[to] + cost == d[now]) {\n      good[id] = 1;\n      dfs(to);\n    }\n  }\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d %d\", u + i, v + i, w + i);\n    edge[u[i]].emplace_back(v[i], w[i], i);\n    rev[v[i]].emplace_back(u[i], w[i], i);\n  }\n  dijkstra(1, d, edge);\n  dijkstra(2, drev, rev);\n  \n  dfs(2);\n  for (int i = 0; i < m; i++) {\n    if (good[i]) {\n      adj[u[i]].push_back(v[i]);\n      adj[v[i]].push_back(u[i]);\n    }\n  }\n  num.assign(n + 1, -1);\n  low.assign(n + 1, 0);\n  vis.assign(n + 1, 0);\n  comp.assign(n + 1, -1);\n  cntr = numCC = 0;\n  for(int i = 1; i <= n; i++)\n    if(num[i] == -1)\n      tarjanSCC(i);\n  \n  /*\n  puts(\"d\");\n  for (int i = 1; i <= n; i++) printf(\"%lld \", d[i]); printf(\"\\n\");\n  puts(\"good\");\n  for (int i = 0; i < m; i++) printf(\"%d \", good[i]); printf(\"\\n\");\n  puts(\"comp\");\n  for (int i = 1; i <= n; i++) printf(\"%d \", comp[i]); printf(\"\\n\");\n  */\n  for (int i = 0; i < m; i++) {\n    if (d[v[i]] + drev[u[i]] + w[i] < d[2]) {\n      puts(\"HAPPY\");\n    } else if (good[i] && comp[u[i]] != comp[v[i]]) {\n      puts(\"SAD\");\n    } else {\n      puts(\"SOSO\");\n    }\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    (cnt[v] += (p != -1 ? cnt[p] : 1)) %= MOD;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] > d + c) q.push((state) { d + c, u, v });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, m;\nint a[N], b[N], c[N], p[N], load[N], sn;\nvector<int> con[N], val[N], dcon[N], dval[N], id[N];\ntypedef pair<long long, int> PII;\npriority_queue<PII> que;\nlong long tab[N], dtab[N];\nbool chk[N];\nint use[N];\nlong long fs;\nvoid DFS(int u){\n\tif (u == 2){\n\t\tsn++; return;\n\t}\n\tfor (int i = 0; i < con[u].size(); i++){\n\t\tint v = con[u][i];\n\t\tuse[id[u][i]]++;\n\t\tDFS(v);\n\t}\n}\nint main(){\n//\tfreopen (\"in.txt\", \"r\", stdin);\n\tscanf (\"%d%d\", &n, &m); int u, v;\n\tfor (int i = 0; i < m; i++){\n\t\tscanf (\"%d %d %d\", a + i, b + i, c + i);\n\t\tcon[a[i]].push_back(b[i]); val[a[i]].push_back(c[i]);\n\t\tdcon[b[i]].push_back(a[i]); dval[b[i]].push_back(c[i]);\n\t}\n\twhile(!que.empty()) que.pop();\n\tmemset (chk, 0, sizeof chk);\n\tmemset (tab, 9, sizeof tab);\n\tque.push(make_pair(0, 1));\n\ttab[1] = 0;\n\twhile(!que.empty()){\n\t\tPII t = que.top(); que.pop();\n\t\tu = t.second;\n\t\tif (chk[u]) continue;\n\t\tchk[u] = 1;\n\t\tfor (int i = 0; i < con[u].size(); i++){\n\t\t\tv = con[u][i];\n\t\t\tif (chk[v]) continue;\n\t\t\tif (tab[v] > tab[u] + val[u][i]) {\n\t\t\t\ttab[v] = tab[u] + val[u][i];\n\t\t\t\tque.push(make_pair(-tab[v], v));\n\t\t\t}\n\t\t}\n\t}\n\tfs = tab[2];\n\twhile(!que.empty()) que.pop();\n\t\n\tmemset (chk, 0, sizeof chk);\n\tmemset (dtab, 9, sizeof dtab);\n\tque.push(make_pair(0, 2));\n\tdtab[2] = 0;\n\twhile(!que.empty()){\n\t\tPII t = que.top(); que.pop();\n\t\tu = t.second, v;\n\t\tif (chk[u]) continue;\n\t\tchk[u] = 1;\n\t\tfor (int i = 0; i < dcon[u].size(); i++){\n\t\t\tv = dcon[u][i];\n\t\t\tif (chk[v]) continue;\n\t\t\tif (dtab[v] > dtab[u] + dval[u][i]) {\n\t\t\t\tdtab[v] = dtab[u] + dval[u][i];\n\t\t\t\tque.push(make_pair(-dtab[v], v));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) con[i].clear(), val[i].clear();\n\tfor (int i = 0; i < m; i++){\n\t\tu = a[i], v = b[i];\n\t\tlong long dr = tab[u] + dtab[v] + c[i];\n\t\tif (dr == fs) con[u].push_back(v), id[u].push_back(i);\n\t}\n\tDFS(1);\n\tfor (int i = 0; i < m; i++){\n\t\tu = a[i], v = b[i];\n\t\tlong long r = tab[v] + dtab[u] + c[i];\n\t\tif (r < fs) puts(\"HAPPY\");\n\t\telse if (use[i] != sn || r == fs) puts(\"SOSO\");\n\t\telse if (r > fs) puts(\"SAD\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int INF = 1e+18;\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nvector<T> dijkstra(const WeightedGraph<T> &G,int source = 0){\n\tusing P = pair<T,int>;\n\tvector<T> dist(G.size(),INF);\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tdist[source] = 0;\n\tque.emplace(dist[source],source);\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first) continue;\n\t\tfor(const auto &e : G[v]){\n\t\t\tif(dist[e.to] > dist[v] + e.cost){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.emplace(dist[e.to],e.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\ntemplate<class T>\nstruct TwoEdgeConnectedComponents{\n\tT G;\n\tGraph nG;\n\tvector<int> cmp,depth,s;\n\tvector<vector<int>> tecc;\n\tstack<int> vs;\n\tvector<pair<int,int>> bridge;\n\n\tint operator[](int i) const{ return cmp[i]; }\n\n\tTwoEdgeConnectedComponents(const T &G) : G(G),cmp(G.size()),depth(G.size(),-1),s(G.size()){}\n\n\tvoid dfs(int v,int par,int d){\n\t\tdepth[v] = d;\n\t\tvs.push(v);\n\t\tfor(const auto &e : G[v]){\n\t\t\tint to = (int)e;\n\t\t\tif(depth[to] == -1){\n\t\t\t\tdfs(to,v,d + 1);\n\t\t\t\ts[v] += s[to];\n\t\t\t}else if(to != par && depth[v] > depth[to]) s[to]--,s[v]++;\n\t\t}\n\t\tif(!s[v]){\n\t\t\tif(par != -1) bridge.push_back(minmax(v,par));\n\t\t\ttecc.emplace_back();\n\t\t\twhile(1){\n\t\t\t\tint u = vs.top(); vs.pop();\n\t\t\t\ttecc.back().push_back(u);\n\t\t\t\tcmp[u] = tecc.size() - 1;\n\t\t\t\tif(u == v) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid build(){\n\t\tfor(int i = 0;i < G.size();i++) if(depth[i] == -1) dfs(i,-1,0);\n\t\tnG.resize(tecc.size());\n\t\tfor(const auto &e : bridge){\n\t\t\tint x = cmp[e.first],y = cmp[e.second];\n\t\t\tnG[x].push_back(y);\n\t\t\tnG[y].push_back(x);\n\t\t}\n\t}\n};\n\nsigned main(){\n\tint n,m,a[100010],b[100010],c[100010];\n\tcin >> n >> m;\n\tWeightedGraph<int> G(n),rG(n);\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\ta[i]--; b[i]--;\n\t\tG[a[i]].emplace_back(b[i],c[i]);\n\t\trG[b[i]].emplace_back(a[i],c[i]);\n\t}\n\tauto dist0 = dijkstra(G,0),dist1 = dijkstra(rG,1);\n\tGraph saitan(n);\n\tfor(int i = 0;i < m;i++){\n\t\tif(dist0[a[i]] + c[i] + dist1[b[i]] == dist0[1]){\n\t\t\tsaitan[a[i]].push_back(b[i]);\n\t\t\tsaitan[b[i]].push_back(a[i]);\n\t\t}\n\t}\n\tTwoEdgeConnectedComponents<Graph> tecc(saitan);\n\ttecc.build();\n\tfor(int i = 0;i < m;i++){\n\t\tif(dist0[a[i]] + c[i] + dist1[b[i]] == dist0[1]){\n\t\t\tif(tecc[a[i]] != tecc[b[i]]) cout << \"SAD\" << endl;\n\t\t\telse cout << \"SOSO\" << endl;\n\t\t}else{\n\t\t\tif(dist0[b[i]] + c[i] + dist1[a[i]] < dist0[1]) cout << \"HAPPY\" << endl;\n\t\t\telse cout << \"SOSO\" << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef Wavator\n#define de(...) fprintf(stderr, __VA_ARGS__), fflush(stderr);\n#else\n#define de(...) 98;\n#endif\n#define pb push_back\n#define XX first\n#define YY second\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VLL;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<pair<int, int> > VPI;\nconst int N = 100005;\n\nll posDis[N], revDis[N];\n\nstruct bian\n{\n    int id, to, w;\n};\n\nvector<bian> zheng[N], fan[N],e[N];\nbool vis[N];\nstring ans[N];\nstring soso=\"SOSO\", sad = \"SAD\", happy = \"HAPPY\";\n\n\n\nint clk,dfn[N],bridge[N],low[N];\n\nvoid dfs(int u, int fa)\n{\n    dfn[u]=low[u]=++clk;\n    for(auto &x: e[u])\n    {\n        int v = x.to;\n        if (!dfn[v])\n        {\n            dfs(v,u);\n            low[u]=min(low[v],low[u]);\n            if(dfn[u] < low[v])\n            {\n                bridge[x.id]=1;\n            }\n        }\n        else if(fa != v)\n            low[u]=min(dfn[v],low[u]);\n    }\n}\n\nint main()\n{\n#ifdef Wavator\n    freopen(\"test.in\", \"r\", stdin);\n#endif\n    int n, m;\n    scanf(\"%d%d\",&n,&m);\n\n\n\n    for (int i = 0; i < m; ++i)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        zheng[u].push_back(bian{i,v,w});\n        fan[v].push_back(bian{i,u,w});\n    }\n\n    priority_queue<pair<ll, int> > q;\n\n    const ll inf = 1LL<<60LL;\n\n    for (int i = 0; i <= n; ++i)\n        posDis[i]=inf, revDis[i]=inf;\n\n    q.push(make_pair(posDis[1]=0,1));\n\n    while (!q.empty())\n    {\n        int u = q.top().second;\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto &e: zheng[u])\n        {\n            ll c = e.w;\n            if (posDis[e.to] > c + posDis[u])\n            {\n\n                posDis[e.to] = c + posDis[u];\n                q.push(make_pair(-posDis[e.to],e.to));\n            }\n        }\n    }\n\n\n\n    memset(vis,0,sizeof(vis));\n\n    q.push(make_pair(revDis[2]=0,2));\n\n    while (!q.empty())\n    {\n        int u = q.top().second;\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto &e: fan[u])\n        {\n            ll c = e.w;\n            if (revDis[e.to] > revDis[u] + c)\n            {\n                revDis[e.to] = revDis[u] + c;\n                q.push(make_pair(-revDis[e.to],e.to));\n            }\n        }\n    }\n\n    //for (int i = 1; i <= n; ++i) cerr  << revDis[i] << endl;\n\n    for (int i = 1; i <= n; ++i)\n        for (auto &x: zheng[i])\n        {\n            int v=x.to;\n            if(posDis[v]+revDis[v]==posDis[2]&&posDis[i]+x.w==posDis[v])\n            {\n                e[i].push_back(x);\n                e[v].push_back(bian{x.id,i,x.w});\n            }\n        }\n\n\n    dfs(1,-1);\n\n\n\n    for(int i = 1; i <= n; ++i)\n    {\n        for (auto &x: zheng[i])\n        {\n            if(bridge[x.id])\n                ans[x.id]=sad;\n            else if(posDis[x.to] + x.w + revDis[i] < posDis[2])\n                ans[x.id]=happy;\n            else\n                ans[x.id]=soso;\n        }\n    }\n\n    for(int i=0;i<m;++i)\n        cout<<ans[i]<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define pb push_back\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nstruct Edge {\n  int s,t;\n  ll c;\n};\n\nconst bool debug = 0;\n\n#define MAX 100001\nint V,E;\nvector<Edge> edges;\nvector<vector<Edge>> sG, eG;\nll mini[2][MAX];\n\nconst string HA = \"HAPPY\";\nconst string SA = \"SAD\";\nconst string SO = \"SOSO\";\n\nint par[MAX];\nint find(int x) {\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\nvoid unite(int x,int y) {\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nstruct Data {\n  int cur;\n  ll v;\n  bool operator < ( const Data &d ) const {\n    if( v != d.v ) return v > d.v;\n    return cur < d.cur;\n  }\n};\n\nvoid dijkstra(int sp, vector<vector<Edge>> &G) {\n  int flag = sp;\n  rep(i,V) mini[flag][i] = LLONG_MAX;\n  mini[flag][sp] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){sp,0});\n  while( !Q.empty() ) {\n    Data d = Q.top(); Q.pop();\n    rep(i,(int)G[d.cur].size()) {\n      Edge &e = G[d.cur][i];\n      if( mini[flag][e.t] > d.v + e.c ) {\n\tmini[flag][e.t] = d.v + e.c;\n\tQ.push((Data){e.t, mini[flag][e.t]});\n      }\n    }\n  }\n}\n\ntypedef vector<ii>   vii;\ntypedef vector<int>   vi;\nconst int DFS_WHITE = -1; // unvisited\nconst int DFS_BLACK =  1; // visited\n\n\n\nstruct EdgeH { int src,dst,w; };\nconst int MAX_V = MAX; //\nint V2,E2; //\nvector<EdgeH> G[MAX_V]; // undirected graph\nvector<int> dfs_num,dfs_low,dfs_parent,articulation_vertex;\nint dfsNumberCounter, dfsRoot, rootChildren;\nset<ii> ban;\n\n#define UNVISITED -1\nvoid articulationPointAndBridge(int u){\n  dfs_low[u] = dfs_num[u] = dfsNumberCounter++;\n  rep(j,(int)G[u].size()){\n    EdgeH &v = G[u][j];\n    if( dfs_num[v.dst] == UNVISITED ) {\n      dfs_parent[v.dst] = u;\n      if( u == dfsRoot ) rootChildren++;\n\n      articulationPointAndBridge(v.dst);\n\n      if( dfs_low[v.dst] >= dfs_num[u] ) articulation_vertex[u] = true;\n      if( dfs_low[v.dst] >  dfs_num[u] ) {\n        //printf(\"Edge (%d,%d) is a bridge\\n\",u,v.dst);\n\tban.insert(ii(u,v.dst));\n\tban.insert(ii(v.dst,u));\n      }\n      dfs_low[u] = min(dfs_low[u],dfs_low[v.dst]);\n    } else if( v.dst != dfs_parent[u] ) {\n      dfs_low[u] = min(dfs_low[u],dfs_num[v.dst]);\n    }\n  }\n}\n\nvoid calculateArticulationPointAndBridge(){\n  dfsNumberCounter = 0;\n  dfs_num.assign(V2,UNVISITED);\n  dfs_low.assign(V2,0);\n  dfs_parent.assign(V2,0);\n  articulation_vertex.assign(V2,0);\n  \n  //printf(\"Bridges:\\n\");\n  rep(i,V2) {\n    if( dfs_num[i] == UNVISITED ) {\n      dfsRoot = i, rootChildren = 0;\n      articulationPointAndBridge(i);\n      articulation_vertex[dfsRoot] = ( rootChildren > 1 );\n    }\n  }\n  \n  //printf(\"Articulation Points:\\n\");\n  //rep(i,V2) if( articulation_vertex[i] ) printf(\"Vertex %d\\n\",i);\n}\n\n\n\n\nvoid constructMinGraph(ll default_mini, set<ii> &S) {\n  rep(i,E) {\n    Edge &e = edges[i];\n    if( mini[0][e.s] == LLONG_MAX ) continue;\n    if( mini[1][e.t] == LLONG_MAX ) continue;\n    if( mini[0][e.s] + e.c + mini[1][e.t] == default_mini ) {\n      if( debug ) {\n\tcout << \"  ADD (\" << e.s << \", \" << e.t << \")\" << endl;\n      }\n      S.insert(ii(e.s, e.t));\n      G[e.s].pb((EdgeH){e.s, e.t, (int)e.c});\n      G[e.t].pb((EdgeH){e.t, e.s, (int)e.c});\n    }\n  }\n  V2 = V;\n}\n\nmap<ii,int> mini_mp;\nvoid solve() {\n  dijkstra(0,sG);\n  dijkstra(1,eG);\n  sG.clear();\n  eG.clear();\n\n  if( debug ) {\n    cout << \"* min dist info -- from source\" << endl;\n    rep(i,V) {\n      cout << \"  - mini[0][\" << i << \"] = \" << mini[0][i] << endl;\n    }\n    cout << \"* min dist info -- from dst\" << endl;\n    rep(i,V) {\n      cout << \"  - mini[1][\" << i << \"] = \" << mini[1][i] << endl;\n    }    \n  }\n  \n  ll default_mini = mini[0][1];\n  if( debug ) {\n    cout << \"* default mini = \" << default_mini << endl;\n    cout << \"* grahp construction for max flow\" << endl;\n  }\n  set<ii> S;\n  constructMinGraph(default_mini, S);\n  calculateArticulationPointAndBridge();\n  \n  rep(i,E) {\n    Edge &e = edges[i];\n    if( find(0) != find(e.s) ) {\n      puts(SO.c_str());\n      continue;\n    }\n    if( mini[0][e.t] != LLONG_MAX && mini[1][e.s] != LLONG_MAX ) {\n      ll cost = mini[0][e.t] + e.c + mini[1][e.s];\n      if( cost <  default_mini ) { puts(HA.c_str()); continue; }\n      if( cost == default_mini ) { puts(SO.c_str()); continue; }\n    }\n\n    if( mini_mp[ii(e.s,e.t)] != e.c ) {\n      puts(SO.c_str());\n      continue;\n    }\n    \n    if( !S.count(ii(e.s,e.t)) ) {\n      puts(SO.c_str());\n      continue;\n    }\n\n    if( !ban.count(ii(e.s, e.t)) ) {\n      puts(SO.c_str());\n      continue;\n    }\n    \n    puts(SA.c_str());\n  }\n}\n\nint main() {\n  scanf(\"%d%d\",&V,&E);\n  int a,b,c;\n  sG.resize(V);\n  eG.resize(V);\n  rep(i,V) par[i] = i;\n  rep(i,E) {\n    scanf(\"%d%d%d\",&a,&b,&c);\n    --a, --b;\n    if( mini_mp.count(ii(a,b)) ) {\n      mini_mp[ii(a,b)] = min(mini_mp[ii(a,b)], c);\n    }  else {\n      mini_mp[ii(a,b)] = c;\n    }\n    edges.pb((Edge){a,b,c});\n    sG[a].pb((Edge){a,b,c});\n    eG[b].pb((Edge){b,a,c});\n    unite(a,b);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <limits.h>\n#include <string.h>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <queue>\n#define pb push_back\n#define ll long long\n#define X first\n#define Y second\n#define pi acos(-1.0) \n#define maxn 100005\n#define mod 999999937\n#define inf 99999999999999999\nusing namespace std;\n\ntypedef pair<ll,int> P;\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nint n,m;\nvector<Edge> edges;\nvector<int> v[maxn],rv[maxn];\nll d1[maxn],d2[maxn];\nbool used[maxn];\n\nvoid addedge(int from,int to,ll cost){\n\tedges.push_back(Edge{from,to,cost});\n\tedges.push_back(Edge{to,from,cost});\n\tv[from].push_back(edges.size()-2);\n\trv[to].push_back(edges.size()-1);\n}\n\nvoid dijs1(int s,ll *dist){\n\tfill(dist+1,dist+n+1,inf);\n\tmemset(used,0,sizeof(used));\n\tdist[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > pq;\n\tpq.push(P(0,s));\n\twhile(!pq.empty()){\n\t\tint now=pq.top().second; pq.pop();\n\t\tif(used[now]) continue;\n\t\tused[now]=1;\n\t\tfor(int i=0;i<v[now].size();i++){\n\t\t\tEdge e=edges[v[now][i]];\n\t\t\tif(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n\t\t\t\tdist[e.to]=dist[now]+e.cost;\n\t\t\t\tpq.push(P(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijs2(int s,ll *dist){\n\tfill(dist+1,dist+n+1,inf);\n\tmemset(used,0,sizeof(used));\n\tdist[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > pq;\n\tpq.push(P(0,s));\n\twhile(!pq.empty()){\n\t\tint now=pq.top().second; pq.pop();\n\t\tif(used[now]) continue;\n\t\tused[now]=1;\n\t\tfor(int i=0;i<rv[now].size();i++){\n\t\t\tEdge e=edges[rv[now][i]];\n\t\t\tif(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n\t\t\t\tdist[e.to]=dist[now]+e.cost;\n\t\t\t\tpq.push(P(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll length;\nvector<int> G[maxn];\n\n//bcc模板 (橋雙連通分量)\nint dfs_clock;\nmap<int,bool> bridge[maxn];//用bridge[i][j]紀錄v[i][j]這條邊是不是橋 //常數有點大，如果需要加快再改 \nint pre[maxn];\n\nint dfs_bcc(int u,int fa){ \n\tint lowu=pre[u]=++dfs_clock;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tint x=G[u][i];\n\t\tif(!pre[x]){\n\t\t\tint lowx=dfs_bcc(x,u);\n\t\t\tlowu=min(lowu,lowx);\n\t\t\tif(lowx>pre[u]) {\n\t\t\t\tbridge[u][x]=1;\n\t\t\t\t//bridge[x][u]=1;\n\t\t\t}\n\t\t}\n\t\telse if(pre[x]<pre[u]&&x!=fa) lowu=min(lowu,pre[x]);\n\t}\n\treturn lowu;\n}\n\nvoid find_bcc(int nn){\n\tmemset(pre,0,sizeof(pre));\n\tdfs_clock=0;\n\tfor(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n\t\tbridge[i].clear();\n\t}\n\tfor(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n\t\tif(!pre[i]) dfs_bcc(i,-1);\n\t}\n}\n//bcc模板結束 \n\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\",&x,&y,&c);\n\t\taddedge(x,y,c);\n\t}\n\tdijs1(1,d1);\n\tdijs2(2,d2);\n\t\n\t//for(int i=1;i<=n;i++) printf(\"%d %d %d\\n\",i,d1[i],d2[i]);\n\t\n\tlength=d1[2];\n\t\n\tfor(int i=0;i<edges.size();i+=2){\n\t\tEdge e=edges[i];\n\t\tif(d1[e.from]+d2[e.to]+e.cost==length) G[e.from].push_back(e.to);\n\t}\n\t\n\tfind_bcc(n);\n\t\n\t//for(int i=1;i<=n;i++) for(map<int,bool>::iterator iter=bridge[i].begin();iter!=bridge[i].end();iter++){\n\t//\t\tif(iter->second) printf(\"%d %d\\n\",i,iter->first);}\n\t\n\tfor(int i=0;i<edges.size();i+=2){\n\t\tEdge e=edges[i];\n\t\tif(d1[e.to]+d2[e.from]+e.cost<length){\n\t\t\tprintf(\"HAPPY\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(bridge[e.from][e.to]&&d1[e.to]+d2[e.from]+e.cost>length&&d1[e.from]+d2[e.to]+e.cost==length){\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"SOSO\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n \n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n \n#include <complex>\n \n#include <functional>\n#include <cassert>\n \ntypedef long long ll;\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n \n \n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Bridges */\n\nint bridges_dfs(int now, int path, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n  \n  visited[now] = 1;\n\n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == path) continue;\n\n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n\n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n\n//無向辺 & 多重辺考慮\nvector<bool> bridges(int n, const vector<pair<int,int> > &path){\n  vector<vector<pair<int,int> > >  way(n);\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n\n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n\n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n\n  return bridges_flag;\n}\n\n \nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE], c[SIZE];\n  vector<int> way[SIZE], rway[SIZE];\n   \n  scanf(\"%d%d\",&n,&m);\n \n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n \n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n \n  //Dijkstra\n  priority_queue<pair<ll,int> > pq;\n  bool visited[SIZE] = {}, rvisited[SIZE];\n  ll cost[SIZE], rcost[SIZE];\n   \n  pq.push({0,0});\n \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n \n    int now = p.second;\n    ll cur_cost = p.first;\n \n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n \n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n \n  pq.push({0,1});\n   \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n \n    int now = p.second;\n    ll cur_cost = p.first;\n \n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n \n  vector<pair<int,int> > Graph;\n  vector<int> pathID;\n  bool visited2[SIZE] = {};\n \n  pq.push({cost[1], 1});\n   \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n \n    int now = p.second;\n    ll cur_cost = p.first;\n \n    if(visited2[now]) continue;\n    visited2[now] = true;\n     \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n      }\n    }\n  }\n \n  auto res = bridges(n, Graph);\n  bool isBridge[SIZE] = {};\n \n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n   \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n   \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\nconst ll INF=1e18;\nstruct HeapNode\n{\n    ll d;\n    int u;\n    bool operator<(const HeapNode &rhs)const\n    {\n        return d>rhs.d;\n    }\n};\nstruct Edge\n{\n    int from,to;\n    ll cost;\n};\nstruct Dij\n{\n    int n,m;\n    vector<int>G[maxn];\n    vector<int>G1[maxn];\n    vector<Edge>edges;\n    vector<Edge>edges1;\n    bool done[maxn];\n    ll d[maxn];\n    ll d1[maxn];\n    void init(int n)\n    {\n        this->n=n;\n        for(int i=0; i<=n; i++)\n        {\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    void addedge(int from,int to,int cost)\n    {\n        edges.push_back(Edge{from,to,cost});\n        edges1.push_back((Edge)\n        {\n            to,from,cost\n        });\n        m=edges.size();\n        G[from].push_back(m-1);\n        G1[to].push_back(m-1);\n    }\n    void dij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0; i<=n; i++) d[i]=INF;\n        d[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode)\n        {\n            0,s\n        });\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top();\n            Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0; i<G[u].size(); i++)\n            {\n                Edge &e=edges[G[u][i]];\n                if(d[e.to]>d[u]+e.cost)\n                {\n                    d[e.to]=d[u]+e.cost;\n                    Q.push((HeapNode)\n                    {\n                        d[e.to],e.to\n                    });\n                }\n            }\n        }\n    }\n\n    void redij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0; i<=n; i++) d1[i]=INF;\n        d1[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode)\n        {\n            0,s\n        });\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top();\n            Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0; i<G1[u].size(); i++)\n            {\n                Edge &e=edges1[G1[u][i]];\n                if(d1[e.to]>d1[u]+e.cost)\n                {\n                    d1[e.to]=d1[u]+e.cost;\n                    Q.push((HeapNode)\n                    {\n                        d1[e.to],e.to\n                    });\n                }\n            }\n        }\n    }\n} D;\n\nstruct node\n{\n    int x,y;\n    ll z;\n} s[maxn];\ntypedef pair<int,int>P;\nvector<P>G[maxn];\nint dfs_clock,pre[maxn],low[maxn];\nbool is_bridge[maxn];\nint dfs(int u,int fa)\n{\n    //cout<<u<<\" \"<<fa<<endl;\n    int lowu;\n    lowu=pre[u]=++dfs_clock;\n   // cout<<u<<\" \"<<fa<<\" \"<<dfs_clock<<endl;\n    for(int i=0; i<G[u].size(); i++)\n    {\n        int v=G[u][i].first;\n     //   cout<<v<<endl;\n    // cout<<u<<\" \"<<v<<\" \"<<dfs_clock<<\" \"<<pre[v]<<endl;\n        if(!pre[v])\n        {\n\n            int lowv=dfs(v,u);\n            lowu=min(lowu,lowv);\n            //cout<<lowv<<\" \"<<pre[u]<<endl;\n            if(lowv>pre[u])\n            {\n                //cout<<G[u][i].second<<endl;\n                is_bridge[G[u][i].second]=true;\n            }\n        }\n        else if(pre[v]<pre[u]&&fa!=v)\n            lowu=min(lowu,pre[v]);\n        //cout<<\"qwdrsada\"<<endl;\n    }\n    return low[u]=lowu;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n   // freopen(\"out.txt\",\"w\",stdout);\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    D.init(n);\n    for(int i=0; i<m; i++)\n    {\n        scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].z);\n        D.addedge(s[i].x,s[i].y,s[i].z);\n    }\n    D.dij(1);\n    D.redij(2);\n    //cout<<D.d[2]<<endl;\n    for(int i=0; i<m; i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[x]+D.d1[y]+z==D.d[2])\n        {\n            G[x].push_back(make_pair(y,i));\n           // cout<<x<<\" \"<<y<<\" \"<<i<<\" \"<<D.d[x]<<\" \"<<D.d1[y]<<\" \"<<z<<endl;\n        }\n\n    }\n//    for(int i=3;i<=n;i++)\n//    {\n//        cout<<i<<\" \"<<G[i][0].first<<endl;\n//    }\n    dfs(1,-1);\n//    for(int i=0;i<m;i++)\n//    {\n//        if(is_bridge[i]) cout<<i<<endl;\n//    }\n\n    for(int i=0; i<m; i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(is_bridge[i])\n        {\n            printf(\"SAD\\n\");\n        }\n        else if(D.d[y]+D.d1[x]+z<D.d[2])\n        {\n            printf(\"HAPPY\\n\");\n        }\n        else\n        {\n            printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    typedef long long ll;\n    const ll INF = 1LL << 56;\n    int N, M;\n\n    struct Edge {\n        int from, to; ll cost;\n        Edge(int from, int to, ll cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            if (from == e.from) {\n                return to == e.to ? cost < e.cost : to < e.to;\n            } else {\n                return from < e.from;\n            }\n        }\n        bool operator==(const Edge& e) {\n            return to == e.to and from == e.from and cost == e.cost;\n        }\n    };\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \",\" << e.to << \",\" << e.cost << \")\";\n    }\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    vector<vector<Edge>> G, RG;\n    vector<Edge> es;\n    map<Edge, int> X;\n\n    vector<pair<int, int>> findBridges(const vector<vector<Edge>>& G) {\n        int V = N;\n        vector<int> dfs_order(V, -1);\n        vector<int> lowlink(V, 0);\n        int c = 0;\n        vector<pair<int, int>> bridges;\n        function<void(int, int)> dfs = [&](int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            for (auto& e : G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) {\n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges.emplace_back(l, g);\n                }\n            }\n        };\n        dfs(0, -1);\n        return bridges;\n    }\n\n    void input() {\n        cin >> N >> M;\n        G.resize(N);\n        RG.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b; ll c;\n            cin >> a >> b >> c;\n            a--; b--;\n            Edge e(a, b, c);\n            if (X.count(e)) {\n                X[e]++;\n            } else {\n                G[a].emplace_back(a, b, c);\n                RG[b].emplace_back(b, a, c);\n                X[e] = 1;\n            }\n            es.emplace_back(a, b, c);\n        }\n    }\n\n    struct S {\n        int v; ll cost;\n        S(int v, ll cost) : v(v), cost(cost) {}\n        bool operator<(const S& s) const {\n            return cost > s.cost;\n        }\n    };\n\n    void dijkstra(const vector<vector<Edge>>& G, int start, vector<ll>& D, vector<vector<Edge>>& prev) {\n        priority_queue<S> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : G[cur.v]) {\n                auto next = e.to;\n                auto ncost = D[cur.v] + e.cost;\n                if (D[next] > ncost) {\n                    prev[next].clear();\n                    prev[next].push_back(e);\n                    D[next] = ncost;\n                    PQ.emplace(next, ncost);\n                } else if (D[next] == ncost) {\n                    prev[next].push_back(e);\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<ll> D(N, INF);\n        vector<ll> RD(N, INF);\n        vector<vector<Edge>> prev(N, vector<Edge>());\n        vector<vector<Edge>> rprev(N, vector<Edge>());\n        dijkstra(G, 0, D, prev);\n        dijkstra(RG, 1, RD, rprev);\n\n        vector<vector<Edge>> shortest_paths(N, vector<Edge>());\n        set<Edge> shortest_paths_edges;\n        for (int v = 0; v < N; v++) {\n            if (prev[v].empty()) continue;\n            for (auto e : prev[v]) {\n                auto from = e.from;\n                shortest_paths[from].push_back(e);\n                shortest_paths_edges.insert(e);\n            }\n        }\n\n        auto _bridges = findBridges(shortest_paths);\n        //cout << _bridges << endl;\n        set<pair<int, int>> bridges;\n        for (auto b : _bridges) { bridges.insert(b); }\n\n        for (int i = 0; i < M; i++) {\n            auto e = es[i];\n            if (D[e.from] + e.cost + RD[e.to] == D[1]) {\n                if (\n                    (bridges.count(make_pair(e.from, e.to)) \n                     or bridges.count(make_pair(e.to, e.from)))\n                     and X[e] <= 1) {\n                    cout << \"SAD\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            } else {\n                auto ncost = D[e.to] + e.cost + RD[e.from];\n                if (ncost < D[1]) {\n                    cout << \"HAPPY\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cout<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nclass Lowlink{\npublic:\n  int V;\n  vector<vector<int> > G;\n  vector<int> ord;           //ord[i] := ノードiに訪れた順番\n  vector<int> low;           //low[i] := ノードiから訪れることができる最小のord[j]の値。\n  vector<int> articulation;\n  int ok;\n  \n  Lowlink():V(-1),ok(false){};\n  Lowlink(int V):V(V),G(V),ok(false){};\n    \n  void add_edge(int a,int b){\n    ok = false;\n    assert(a < V && b < V);\n    assert(a >=0 && b >= 0);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  void build(int root = 0){\n    ok = true;\n    ord.clear(); ord.resize(V,-1);\n    low.clear(); low.resize(V,-1);\n    articulation.clear(); articulation.resize(V,0); /*関節点用*/\n    \n    int cnt = 0;\n    function<int(int,int)> dfs=[&](int pos,int pre){\n      ord[pos] = low[pos] = cnt++;\n      for(int to:G[pos]) {\n        if(to == pre) continue; \n        if(ord[to] != -1) low[pos] = min(low[pos], ord[to]);\n        else {\n          low[pos] = min(low[pos], dfs(to, pos));\n\t  \n\t  /*関節点用*/\n\t  if(pos == root) articulation[pos]++;\n\t  else articulation[pos] |= ord[pos] <= low[to];\n\t  \n\t}\n      }\n      return low[pos];\n    };\n    \n    dfs(root , -1);\n    articulation[root] = articulation[root] >= 2; /*関節点用*/\n  }\n\n  int isBridge(int a,int b){\n    assert(ok);\n    assert(a < V && b < V);\n    assert(a >= 0 && b >= 0);\n    if(ord[a] > ord[b]) swap(a, b);\n    return ord[a] < low[b];\n  }\n  \n  int isArticulation(int a){\n    assert(ok);\n    assert(a >= 0 && a < V);\n    return articulation[a];\n  }\n};\n\ntemplate<typename ctype, ctype INF>\nclass Dijkstra{\npublic:\n  typedef tuple<int,ctype> T;  //for edge\n  typedef tuple<ctype,int> T2; //for priority_queue\n  int V;\n  vector<vector<T> > G;\n  vector<vector<T> > rG;\n  \n  Dijkstra():V(-1){}\n  Dijkstra(int V):V(V),G(V),rG(V){}\n  \n  void add_edge(int a,int b,ctype c,int oneway = 0){\n    assert(a >= 0 && b >= 0);\n    assert(a < V && b < V);\n    G[a].push_back(T(b, c));\n    rG[b].push_back(T(a, c));\n    if(!oneway) G[b].push_back(T(a, c)), rG[a].push_back(T(b, c));\n  }\n\n  vector<ctype> dijkstra(int start, int rev = 0){\n    vector<ctype> D(V, INF);\n    vector<int> visited(V,0);\n    priority_queue<T2, vector<T2>, greater<T2> > Q;\n    Q.push(T2(0, start));\n    D[start] = 0;\n    while(!Q.empty()){\n      ctype cost;\n      int pos;\n      tie(cost,pos) = Q.top(); Q.pop();\n      assert(!visited[pos] || D[pos] <= cost);\n      if(visited[pos]++) continue;\n      \n      for(auto t:rev == 0? G[pos]:rG[pos]){\n\tint to = get<0>(t);\n        ctype ncost = cost + get<1>(t);\n        if(D[to] <= ncost) continue;\n        D[to] = ncost;\n        Q.push(T2(ncost, to));\n      }\n    }\n    return D;\n  }\n  \n  vector<vector<int> > getDAG(int start, int goal){\n    auto DS = dijkstra(start, 0);\n    auto DT = dijkstra(goal, 1);\n    vector<vector<int> > DAG(V);\n    vector<int> visited(V,0);\n    queue<int> Q;\n    Q.push(start);\n    while(!Q.empty()){\n      int pos; pos = Q.front(); Q.pop();\n      if(visited[pos]++) continue;\n      \n      for(auto t:G[pos]){\n        int to = get<0>(t);\n        ctype cost = get<1>(t);\n\tif(DS[pos] + DT[to] + cost != DS[goal]) continue;\n\tQ.push(to);\n\tDAG[pos].push_back(to);\n      }\n    }\n    return DAG;\n  }\n};\n\nusing T = tuple<int,int,int>;\nconst int start = 0,  goal= 1;\nint n, m;\nvector<T> edge;\nvector<Int> DS, DT;\nLowlink lowlink;\n\nint happy(int i){\n  int a, b, c; tie(a, b, c) = edge[i];\n  return DS[goal] > DS[b] + DT[a] + c;\n}\n\nint  soso(int i){\n  int a, b, c; tie(a, b, c) = edge[i];\n  if(DS[a] + DT[b] + c != DS[goal]) return 1;\n  return !lowlink.isBridge(a, b);\n}\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>n>>m;\n  edge.resize(m);\n  Dijkstra<Int, INF> dijkstra(n);\n  Dijkstra<Int, INF> dijkstra2(n);\n  \n  for(int i=0;i < m;i++){\n    Int a, b, c;\n    cin>>a>>b>>c; a--,b--;\n    edge[i] = T(a, b, c);\n    dijkstra.add_edge(a, b, c, 1);\n    dijkstra2.add_edge(b, a, c, 1);\n  }\n  DS = dijkstra.dijkstra(start);\n  DT = dijkstra2.dijkstra(goal);\n\n  auto G = dijkstra.getDAG(start, goal);\n  lowlink = Lowlink(n);\n  for(int i=0;i<n;i++)\n    for(int to:G[i]) lowlink.add_edge(i, to);\n\n  lowlink.build();\n\n  for(int i=0;i<m;i++){\n    if(happy(i)) cout<<\"HAPPY\"<<endl;\n    else if(soso(i)) cout<<\"SOSO\"<<endl;\n    else cout<<\"SAD\"<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nvector<vector<pii> > G, rG;\nvector<vector<int> > I, rI;\nll C[100100], rC[100100];\nbool tmp[100100];\nbool bridge[100100];\nint lst[100100][3];\n\nvoid shortest(vector<vector<pii> > g, ll *c, int s) {\n\tfor(int i = 0; i < 100100; i++) {\n\t\tc[i] = 1e15;\n\t}\n\tc[s] = 0;\n\tpriority_queue<pli> q;\n\tq.push(pli(0,s));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(c[a.se] < -a.fi) continue;\n\t\tfor(int i = 0; i < g[a.se].size(); i++) {\n\t\t\tint v = g[a.se][i].fi;\n\t\t\tll t = -a.fi + g[a.se][i].se;\n\t\t\tif(c[v] > t) {\n\t\t\t\tc[v] = t;\n\t\t\t\tq.push(pli(-t, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mkbridge() {\n\tll sp = C[1];\n\tpriority_queue<pli> q;\n\tq.push(pli(0,0));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(tmp[a.se]) continue;\n\t\ttmp[a.se] = true;\n\t\tint id;\n\t\tfor(int i = 0; i < G[a.se].size(); i++) {\n\t\t\tint v = G[a.se][i].fi;\n\t\t\tif(sp == C[a.se] + G[a.se][i].se + rC[v]) {\n\t\t\t\tq.push(pli(-C[v], v));\n\t\t\t\tid = I[a.se][i];\n\t\t\t}\n\t\t}\n\t\tif(q.size() == 1) {\n\t\t\tbridge[id] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tG.resize(n);\n\trG.resize(n);\n\tI.resize(n);\n\trI.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tG[a].push_back(pii(b,c));\n\t\trG[b].push_back(pii(a,c));\n\t\tI[a].push_back(i);\n\t\trI[b].push_back(i);\n\t\tlst[i][0] = a; lst[i][1] = b; lst[i][2] = c;\n\t}\n\tshortest(G,C,0);\n\tshortest(rG,rC,1);\n\tmkbridge();\n\n\tll sp = C[1];\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = lst[i][0]; b = lst[i][1]; c = lst[i][2];\n\t\tif(C[b] + c + rC[a] < sp) {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t\telse if(bridge[i] && C[b] + c + rC[a] > sp && sp != (ll)(1e15)) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;    \n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        edges.push_back(Edge{i, a - 1, b - 1, c, false});\n    }\n    sort(begin(edges), end(edges), [] (Edge &a, Edge &b) {\n            return make_tuple(a.from, a.to, a.cost) < make_tuple(b.from, b.to, b.cost);\n        });\n    rep(i, M) {\n        auto &e = edges[i];\n        int index = e.index;\n        int a = e.from;\n        int b = e.to;\n        int c = e.cost;\n        if(i > 0) {\n            auto &pe = edges[i - 1];\n            if(pe.from == a and pe.to == b) {\n                e.multi = true;\n                if(pe.cost == e.cost) edges[i - 1].multi = true;\n                continue;\n            }\n        }\n        E[a].push_back(Edge{index, a, b, c});\n        rE[b].push_back(Edge{index, b, a, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    auto bridges = enumerate_bridges(shortest_graph);\n    assert(enumerate_bridges(shortest_graph) == bridges);\n    \n    sort(begin(edges), end(edges), [] (Edge &a, Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and not e.multi) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    typedef long long ll;\n    const ll INF = 1LL << 56;\n    int N, M;\n\n    struct Edge {\n        int from, to; ll cost;\n        Edge(int from, int to, ll cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            if (from == e.from) {\n                return to == e.to ? cost < e.cost : to < e.to;\n            } else {\n                return from < e.from;\n            }\n        }\n        bool operator==(const Edge& e) {\n            return to == e.to and from == e.from and cost == e.cost;\n        }\n    };\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \",\" << e.to << \",\" << e.cost << \")\";\n    }\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    vector<vector<Edge>> G, RG;\n    vector<Edge> es;\n    map<Edge, int> X;\n\n    vector<pair<int, int>> findBridges(const vector<vector<Edge>>& G) {\n        int V = N;\n        vector<int> dfs_order(V, -1);\n        vector<int> lowlink(V, 0);\n        int c = 0;\n        vector<pair<int, int>> bridges;\n        function<void(int, int)> dfs = [&](int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            for (auto& e : G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) {\n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges.emplace_back(l, g);\n                }\n            }\n        };\n        dfs(0, -1);\n        return bridges;\n    }\n\n    void input() {\n        cin >> N >> M;\n        G.resize(N);\n        RG.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b; ll c;\n            cin >> a >> b >> c;\n            a--; b--;\n            Edge e(a, b, c);\n            if (X.count(e)) {\n                X[e]++;\n            } else {\n                G[a].emplace_back(a, b, c);\n                RG[b].emplace_back(b, a, c);\n                X[e] = 1;\n            }\n            es.emplace_back(a, b, c);\n        }\n    }\n\n    struct S {\n        int v; ll cost;\n        S(int v, ll cost) : v(v), cost(cost) {}\n        bool operator<(const S& s) const {\n            return cost > s.cost;\n        }\n    };\n\n    void dijkstra(const vector<vector<Edge>>& G, int start, vector<ll>& D, vector<vector<Edge>>& prev) {\n        priority_queue<S> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : G[cur.v]) {\n                auto next = e.to;\n                auto ncost = D[cur.v] + e.cost;\n                if (D[next] > ncost) {\n                    prev[next].clear();\n                    prev[next].push_back(e);\n                    D[next] = ncost;\n                    PQ.emplace(next, ncost);\n                } else if (D[next] == ncost) {\n                    prev[next].push_back(e);\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<ll> D(N, INF);\n        vector<ll> RD(N, INF);\n        vector<vector<Edge>> prev(N, vector<Edge>());\n        vector<vector<Edge>> rprev(N, vector<Edge>());\n        dijkstra(G, 0, D, prev);\n        dijkstra(RG, 1, RD, rprev);\n\n        vector<vector<Edge>> shortest_paths(N, vector<Edge>());\n        function<void(int)> dfs = [&](int v) {\n            if (prev[v].empty()) {\n                //assert(v == 0);\n                return;\n            }\n            for (auto e : prev[v]) {\n                shortest_paths[e.from].push_back(e);\n                shortest_paths[e.to].emplace_back(e.to, e.from, -1);\n                dfs(e.from);\n            }\n        };\n        dfs(1);\n        //cout << shortest_paths << endl;\n\n        auto _bridges = findBridges(shortest_paths);\n        //cout << _bridges << endl;\n        set<pair<int, int>> bridges;\n        for (auto b : _bridges) { bridges.insert(b); }\n\n        for (int i = 0; i < M; i++) {\n            auto e = es[i];\n            if (D[e.from] + e.cost + RD[e.to] == D[1]) {\n                if (\n                    (bridges.count(make_pair(e.from, e.to)) \n                     or bridges.count(make_pair(e.to, e.from)))\n                     and X[e] <= 1) {\n                    cout << \"SAD\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            } else {\n                auto ncost = D[e.to] + e.cost + RD[e.from];\n                if (ncost < D[1]) {\n                    cout << \"HAPPY\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n            if(ord[now] < low[nxt]) {\n                bridges.insert(nxt_e.index);\n            }\n        }\n    };\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0 and now.from != 1) {\n            shortest_graph[now.from].push_back(now.e);\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n    map<pii, int> min_edge;\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        edges.push_back(Edge{i, a, b, c});\n        auto p = make_pair(a, b);\n        if(!min_edge.count(p) or min_edge[p] > c) min_edge[p] = c;        \n    }\n    map<pii, int> min_edge_count;\n    rep(i, M) {\n        auto &e = edges[i]; // mut\n        auto p = make_pair(e.from, e.to);\n        if(min_edge[p] == e.cost) min_edge_count[p]++;\n        E[e.from].push_back(e);\n        rE[e.to].push_back(Edge{e.index, e.to, e.from, e.cost});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        const Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and min_edge_count[make_pair(e.from, e.to)] == 1) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c, id;\n};\n\nstruct Node{\n\tint p,c;\n};\n\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\n\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint currentTime = 0;\n\nset<int> bridges;\n\nmap< pair<int,int> , int> counter;\n\nint dfs(int x, int p, const vector< vector<Edge> > &g){\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\n\tint ans = currentTime;\n\tfor( auto &&e : g[x] ){\n\t\tif( e.b == p ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, g));\n\t\t}\n\t}\n\tif( p != -1 && ans > visited[p]){\n\t\n\t\tcounter[{x, p}]++;\n\t\tcounter[{p, x}]++;\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\t--a,--b;\n\t\tes.push_back({a,b,c, i});\n\t\tg[a].push_back({a,b,c, i});\n\t\trg[b].push_back({b,a,c, i});\n\t}\n\n\tint S = 0;\n\tint G = 1;\n\tauto gDist = dijkstra(S, g);\n\tauto rgDist = dijkstra(G, rg);\n\t\n\tvector< vector<Edge> > dag(n);\n\tfor( auto e : es ){\n\t\tif( gDist[e.a] + e.c + rgDist[e.b] == gDist[G] ){\n\t\t\tdag[e.a].push_back(e);\n\t\t\tdag[e.b].push_back({e.b,e.a,e.c,e.id});\n\t\t}\n\t}\n\tdfs(0, -1, dag);\n\n\tfor( auto e : es ){\n\t\tif( gDist[e.b] + e.c + rgDist[e.a] < gDist[G] ){\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}else if( gDist[e.a] + e.c + rgDist[e.b] != gDist[G] ){\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}else if( counter[{e.a,e.b}] != 1 ){\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}else{\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, 1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    (cnt[v] += p) %= MOD;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, cnt[v] });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    if(dist[v] == d) (cnt[v] += (p != -1 ? cnt[p] : 1)) %= MOD;\n    if(dist[v] > d) {\n      dist[v] = d;\n      cnt[v] = (p != -1 ? cnt[p] : 1);\n    }\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, v });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PP;\n\nclass getbridge{\npublic:\n\tstatic const int MAX=200000;\n\tvector<int> G[MAX];\n\tbool visited[MAX];\n\tint prenum[MAX],parent[MAX],lowest[MAX],timer;\n\tvector<P> bridge;\n\n\tvoid dfs(int v,int prev){\n\t\tprenum[v]=lowest[v]=timer;\n\t\ttimer++;\n\t\tvisited[v]=true;\n\n\t\tint next;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tnext=G[v][i];\n\t\t\tif(!visited[next]){\n\t\t\t\tparent[next]=v;\n\t\t\t\tdfs(next,v);\n\t\t\t\tlowest[v]=min(lowest[v],lowest[next]);\n\t\t\t\tif(prenum[v]<lowest[G[v][i]]){\n\t\t\t\t\t//printf(\"%d %d\\n\",v,G[v][i]);\n\t\t\t\t\tbridge.push_back(P(min(v,G[v][i]),max(v,G[v][i])));\n\t\t\t\t}\n\t\t\t}else if(next!=prev){\n\t\t\t\tlowest[v]=min(lowest[v],prenum[next]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tset<int> art_points(int N){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvisited[i]=false;\n\t\t}\n\t\ttimer=1;\n\t\tdfs(0,-1);\n\n\t\tset<int> ap;\n\t\tint np=0;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tint p=parent[i];\n\t\t\tif(p==0)np++;\n\t\t\telse if(prenum[p]<lowest[i])ap.insert(p);\n\t\t}\n\t\tif(np>1)ap.insert(0);\n\t\treturn ap;\n\t}\n};\n\ngetbridge bri;\n\nint n,m;\nvector<P> G[100001];\nvector<P> rG[100001];\nll dist[100001];\nll cnt[100001];\nll dist2[100001];\nint a[100001],b[100001];\nll c[100001];\nset<PP> se;\nset<PP> multi;\nstack<int> s;\n\nvoid dijk(){\n\tfor(int i=0;i<n;i++){\n\t\tdist[i]=INF;\n\t}\n\tdist[0]=0;\n\tcnt[0]=1;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,0));\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tll co=p.first;\n\t\tif(co>dist[v])continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(dist[G[v][i].first]>dist[v]+G[v][i].second){\n\t\t\t\tdist[G[v][i].first]=dist[v]+G[v][i].second;\n\t\t\t\tcnt[G[v][i].first]=cnt[v];\n\t\t\t\tque.push(P(dist[G[v][i].first],G[v][i].first));\n\t\t\t}else if(dist[G[v][i].first]==dist[v]+G[v][i].second){\n\t\t\t\tcnt[G[v][i].first]+=cnt[v];\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool used[100001];\nvoid make_graph(){\n\tqueue<int> que;\n\tque.push(1);\n\tused[1]=true;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<rG[v].size();i++){\n\t\t\tint next=rG[v][i].first;\n\t\t\tif(dist[v]==dist[next]+rG[v][i].second){\n\t\t\t\tif(!used[next]){\n\t\t\t\t\tused[next]=true;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t\tbri.G[v].push_back(next);\n\t\t\t\tbri.G[next].push_back(v);\n\t\t\t\t//printf(\"%d %d\\n\",v,next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijk2(){\n\tfor(int i=0;i<n;i++){\n\t\tdist2[i]=INF;\n\t}\n\tdist2[1]=0;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,1));\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tll co=p.first;\n\t\tif(co>dist2[v])continue;\n\t\tfor(int i=0;i<rG[v].size();i++){\n\t\t\tif(dist2[rG[v][i].first]>dist2[v]+rG[v][i].second){\n\t\t\t\tdist2[rG[v][i].first]=dist2[v]+rG[v][i].second;\n\t\t\t\tque.push(P(dist2[rG[v][i].first],rG[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%lld\",&a[i],&b[i],&c[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\tif(se.find(PP(P(a[i],b[i]),c[i]))==se.end()){\n\t\t\tse.insert(PP(P(a[i],b[i]),c[i]));\n\t\t\tG[a[i]].push_back(P(b[i],c[i]));\n\t\t\trG[b[i]].push_back(P(a[i],c[i]));\n\t\t}else{\n\t\t\tmulti.insert(PP(P(a[i],b[i]),c[i]));\n\t\t}\n\t}\n\tdijk();\n\tif(dist[1]<INF){\n\t\tmake_graph();\n\t\tbri.art_points(n);\n\t\tsort(bri.bridge.begin(),bri.bridge.end());\n\t}\n\tdijk2();\n\tfor(int i=0;i<m;i++){\n\t\tll val=dist[b[i]];\n\t\tval+=dist2[a[i]];\n\t\tval+=c[i];\n\t\tif(val<dist[1]){\n\t\t\tputs(\"HAPPY\");\n\t\t}else if(dist[1]>=INF){\n\t\t\tputs(\"SAD\");\n\t\t}else if(val==dist[1]){\n\t\t\tputs(\"SOSO\");\n\t\t}else{\n\t\t\tif(dist[b[i]]-dist[a[i]]!=c[i]){\n\t\t\t\tputs(\"SOSO\");\n\t\t\t}else{\n\t\t\t\tif(multi.find(PP(P(a[i],b[i]),c[i]))!=multi.end()){\n\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t}else if(dist[a[i]]+c[i]+dist2[b[i]]==dist[1]){\n\t\t\t\t\tint v=lower_bound(bri.bridge.begin(),bri.bridge.end(),P(min(a[i],b[i]),max(a[i],b[i])))-bri.bridge.begin();\n\t\t\t\t\tif(v<bri.bridge.size() && bri.bridge[v]==P(min(a[i],b[i]),max(a[i],b[i]))){\n\t\t\t\t\t\tputs(\"SAD\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tputs(\"SOSO\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <tuple>\n#include <map>\n#include <limits>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nstruct CostGraph {\n    using T = ll;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge() {}\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        int from;\n        int to;\n        T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\nostream& operator<<(ostream& os, const CostGraph::Edge& e)\n{\n    os << \"(\" << e.from << \"->\" << e.to << \": \" << e.cost << \")\" << endl;\n    return os;\n}\n\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\nvoid ReverseDijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.rev_edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nstruct BiconnectedComponent {\npublic:\n    BiconnectedComponent(const CostGraph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            bridge_dfs(g_, i);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    CostGraph toTree() const\n    {\n        CostGraph tree(comp_num);\n        for (const auto& e : bridge) {\n            tree.addEdge(comp[e.from], comp[e.to], 1);\n            tree.addEdge(comp[e.to], comp[e.from], 1);\n        }\n        return tree;\n    }\n    const vector<CostGraph::Edge>& getEdge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i];\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    void bridge_dfs(const CostGraph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n            }\n            if (isBridge(s, to)) {\n                bridge.push_back(e);\n            }\n        }\n    }\n\n    void comp_dfs(const CostGraph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n    int num;\n    int comp_num;\n    const int size;\n    vector<CostGraph::Edge> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    CostGraph g(n);\n    using E = tuple<int, int, ll>;\n    vector<E> edge(m);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--, b--;\n        g.addEdge(a, b, c);\n        edge[i] = make_tuple(a, b, c);\n    }\n    vector<ll> ds(n, INF<ll>);\n    Dijkstra(g, 0, ds);\n    vector<ll> dt(n, INF<ll>);\n    ReverseDijkstra(g, 1, dt);\n    show(ds);\n    show(dt);\n    const ll D = ds[1];\n    CostGraph undg(n);\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[u] + c + dt[v] == D) {\n            undg.addEdge(u, v, c);\n            undg.addEdge(v, u, c);\n        }\n    }\n\n    using pii = pair<int, int>;\n    BiconnectedComponent bic(undg);\n    show(bic.bridge);\n    set<E> bridge;\n    for (const auto& e : bic.bridge) {\n        const int u = e.from;\n        const int v = e.to;\n        bridge.insert(make_tuple(u, v, e.cost));\n    }\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[v] + c + dt[u] < D) {\n            cout << \"HAPPY\" << endl;\n        } else {\n            if (not(bridge.find(make_tuple(u, v, c)) == bridge.end() and bridge.find(make_tuple(v, u, c)) == bridge.end())) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n// #define _GLIBCXX_DEBUG // for STL debug\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\n// 関節点を求める (artPoints)\n// 橋を求める (bridges)\n// 二重辺連結成分分解をする (BICC)\n\n// 関節点は、取り除いたときに連結でなくなってしまうような頂点のこと\n// 橋は、取り除いた時に連結でなくなってしまうような辺のこと\n\ntemplate <typename T>\nstruct graphLink {\n    vector<int> ord, low, parent, cmp;\n    vector< vector< Edge<T> > > G, H;\n\n    // 橋の情報 (first < second となるように格納)\n    vector< pair<int, int> > bridges;\n    int cnt, v;\n\n    // init\n    graphLink(vector< vector< Edge<T> > > &S, int root=0) {\n        int n = S.size();\n        ord.resize(n, -1), low.resize(n, 0),\n        parent.resize(n, -1), cmp.resize(n, -1);\n        cnt = 0, v = n;\n        G = S;\n        dfs(root);\n    }\n\n    // 橋であるかの判定\n    bool is_bridge(int x, int y) {\n        if(ord[x] > ord[y]) swap(x, y);\n        return ord[x] < low[y];\n    }\n\n    // dfs 木の作成と橋の列挙 (初期化と同時にやる)\n    // usage: dfs(root);\n    void dfs(int cur, int prev=-1) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n\n        for(auto x : G[cur]) {\n            if(x.to == prev) continue;\n            if(ord[x.to] < 0) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n            if(is_bridge(cur, x.to)) {\n                int a = min(cur, x.to);\n                int b = max(cur, x.to);\n                bridges.emplace_back(make_pair(a, b));\n            }\n        }\n    }\n\n    // 関節点を求める (root は dfs 木の root と一致させる)\n    // root は子を 2 つ持っていれば関節点になる\n    // それ以外の頂点に関しては ord[parent] <= low[i] のとき関節点になる\n    // (lowlink でも親より深さが低い頂点にたどり着けないため)\n    set<int> artPoints(int root) {\n        set<int> se;\n        int num = 0;\n        for(int i=0; i<v; i++) {\n            if(parent[i] < 0) continue;\n            if(parent[i] == root) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num >= 2) se.insert(0);\n        return se;\n    }\n\n    // 二重辺連結成分分解 (橋となる辺を使わないように DFS)\n    // Verified: AtCoder Regular Contest D: 旅行会社高橋君\n    void BICC() {\n        int k = 0;\n        // point, number\n        stack<pii> S;\n        for(int i=0; i<v; i++) {\n            if(cmp[i] >= 0) continue;\n            cmp[i] = k;\n            S.push(make_pair(i, k++));\n            while(!S.empty()) {\n                pii cur = S.top(); S.pop();\n                for(auto x : G[cur.first]) {\n                    if(cmp[x.to] >= 0) continue;\n                    if(is_bridge(cur.first, x.to)) continue;\n                    cmp[x.to] = cur.second;\n                    S.push(make_pair(x.to, cmp[x.to]));\n                }\n            }\n        }\n\n        set< pair<int, int> > edge_set;\n        H.resize(k);\n        for(int i=0; i<v; i++) {\n            for(auto x : G[i]) {\n                int ca = cmp[i], cb = cmp[x.to];\n                if(ca == cb) continue;\n                if(ca > cb) swap(ca, cb);\n                if(edge_set.count(make_pair(ca, cb))) continue;\n                edge_set.insert(make_pair(ca, cb));\n                H[ca].push_back(Edge<T>(cb, 1));\n                H[cb].push_back(Edge<T>(ca, 1));\n            }\n        }\n    }\n};\n\nconst int HAPPY = 1;\nconst int SOSO  = 2;\nconst int SAD   = 3;\n\nconst int source = 0;\nconst int sink   = 1;\n\nint N, M, u[100010], v[100010], w[100010], ans[100010];\n\nvector<int> getMinDist(const Graph<int> &G, int s) {\n    vector<int> res(N, INF);\n    res[s] = 0;\n\n    priority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > que;\n    que.emplace(0, s);\n\n    while(que.size()) {\n        auto cur = que.top(); que.pop();\n        int cost, pos; tie(cost, pos) = cur;\n\n        if(res[pos] < cost) continue;\n        for(auto e : G[pos]) {\n            int to = e.to, dist = cost + e.cost;\n            if(res[to] > dist) {\n                res[to] = dist;\n                que.emplace(dist, to);\n            }\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> N >> M;\n    fill(ans, ans + M, SOSO);\n\n    Graph<int> G(N), revG(N);\n    for(int i=0; i<M; i++) {\n        cin >> u[i] >> v[i] >> w[i];\n        u[i]--; v[i]--;\n           G[ u[i] ].push_back(Edge<int>(v[i], w[i]));\n        revG[ v[i] ].push_back(Edge<int>(u[i], w[i]));\n    }\n\n    vector<int> recG    = getMinDist(G   , source);\n    vector<int> recrevG = getMinDist(revG, sink  );\n    int origMin = recG[sink];\n\n    Graph<int> H(N);\n    map< pair<int, int>, int > edgecnt;\n    map< pair<int, int>, int > edgeid;\n    for(int i=0; i<M; i++) {\n        int L = recG[ v[i] ], R = recrevG[ u[i] ];\n        // ひっくり返すと最短路に使われるが長さ変わらない\n        if(L + R + w[i] == origMin) {\n            ans[i] = SOSO;\n        }\n        // ひっくり返すと最短路がさらに短くなる\n        else if(L + R + w[i] < origMin) {\n            ans[i] = HAPPY;\n        }\n        else {\n            L = recG[ u[i] ], R = recrevG[ v[i] ];\n            // fprintf(stderr, \"#debug: u = %lld, v = %lld, weight = %lld, L = %lld, R = %lld\\n\", u[i], v[i], w[i], L, R);\n\n            // そのままの状態で最短路に使われる\n            if(L + R + w[i] == origMin) {\n                int cnt = edgecnt[ make_pair(u[i], v[i]) ]++;\n                if(cnt == 0) {\n                    // fprintf(stderr, \"edge: (%lld, %lld)\\n\", u[i], v[i]);\n                    edgeid[ make_pair(u[i], v[i]) ] = i;\n                    H[ u[i] ].push_back(Edge<int>(v[i], w[i]));\n                    H[ v[i] ].push_back(Edge<int>(u[i], 0   ));\n                }\n            }\n        }\n    }\n\n    graphLink<int> gl(H, source);\n    for(int i=0; i<N; i++) {\n        for(auto e : H[i]) {\n            int x = i, y = e.to;\n            if(e.cost == 0) continue;\n            if(edgecnt[ make_pair(x, y) ] == 1) {\n                if(gl.is_bridge(x, y)) {\n                    int id = edgeid[ make_pair(x, y) ];\n                    ans[id] = SAD;\n                }\n            }\n        }\n    }\n\n    for(int i=0; i<M; i++) {\n        if(ans[i] == SAD  ) cout << \"SAD\" << endl;\n        if(ans[i] == SOSO ) cout << \"SOSO\" << endl;\n        if(ans[i] == HAPPY) cout << \"HAPPY\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#define llint long long int\n#define lldo long double\n#define fir first\n#define sec second\n#define pub push_back\n#define mp make_pair\n#define mt make_tuple\n#define res resize\nconst llint big=5e15;\nvoid maxeq(int &a,int b){if(a<b){a=b;}}\nbool mineq(llint &a,llint b){if(a>b){a=b;return true;}return false;}\nusing namespace std;\nvector<vector<pair<int,int>>>nizyu;\nvector<bool>sad;\nvector<int>fuka;\nvector<int>imos;\nint dfs_tree(int ter,int oyhen=-1,int dep=0){\n\tfuka[ter]=dep;\n\tfor(auto it:nizyu[ter]){\n\t\tif(it.sec==oyhen){continue;}\n\t\tif(fuka[ter]>=fuka[it.fir]){imos[it.fir]--;imos[ter]++;}\n\t\telse{imos[ter]+=dfs_tree(it.fir,it.sec,dep+1);}\n\t}\n\tif(imos[ter]==0&&oyhen!=-1){sad[oyhen]=true;}\n\treturn imos[ter];\n}\nint main(void){\n\t//???????????£?????????????§£\n\tint i,n,m;cin>>n>>m;\n\tvector<vector<pair<llint,int>>> hen(n);\n\tvector<vector<pair<llint,int>>> rehen(n);\n\tvector<tuple<int,int,llint>>edges(m);\n\tfor(i=0;i<m;i++){\n\t\tint a,b;llint c;cin>>a>>b>>c;a--;b--;\n\t\then[a].pub(mp(c,b));\n\t\trehen[b].pub(mp(c,a));\n\t\tedges[i]=mt(a,b,c);\n\t}\n\tvector<llint>dis(n,big);dis[0]=0;\n\tpriority_queue<pair<llint,int>,vector<pair<llint,int>>,greater<pair<llint,int>>> tourist;\n\t//que_tourist!w\n\ttourist.push(mp(0,0));\n\twhile(tourist.size()>0){\n\t\tllint time=tourist.top().fir;\n\t\tint town=tourist.top().sec;\n\t\ttourist.pop();\n\t\tif(dis[town]<time){continue;}\n\t\tfor(auto it:hen[town]){\n\t\t\tif(!mineq(dis[it.sec],time+it.fir)){continue;}\n\t\t\ttourist.push(mp(dis[it.sec],it.sec));\n\t\t}\n\t}\n\tvector<llint>redis(n,big);redis[1]=0;\n\ttourist.push(mp(0,1));\n\twhile(tourist.size()>0){\n\t\tllint time=tourist.top().fir;\n\t\tint town=tourist.top().sec;\n\t\ttourist.pop();\n\t\tif(redis[town]<time){continue;}\n\t\tfor(auto it:rehen[town]){\n\t\t\tif(!mineq(redis[it.sec],time+it.fir)){continue;}\n\t\t\ttourist.push(mp(redis[it.sec],it.sec));\n\t\t}\n\t}\n\t//????????????????????????\n\t//???????????£?????????????§£\n\tllint mtotime=dis[1];\n\tnizyu.res(n);//???????????????\n\tsad.res(m);//true=sad\n\tfor(i=0;i<m;i++){\n\t\tif(dis[get<0>(edges[i])]+redis[get<1>(edges[i])]+get<2>(edges[i])==mtotime)\n\t\t{nizyu[get<0>(edges[i])].pub(mp(get<1>(edges[i]),i));\n\t\tnizyu[get<1>(edges[i])].pub(mp(get<0>(edges[i]),i));}\n\t}\n\tfuka.res(n,114514);\n\timos.res(n);\n\tdfs_tree(0,-1,0);\n\tfor(i=0;i<m;i++){\n\t\tint a,b;llint c;\n\t\ttie(a,b,c)=edges[i];\n\t\tif(dis[b]+redis[a]+c<mtotime){cout<<\"HAPPY\"<<endl;}\n\t\telse if(dis[b]+redis[a]+c==mtotime){cout<<\"SOSO\"<<endl;}\n\t\telse if(sad[i]){cout<<\"SAD\"<<endl;}\n\t\telse{cout<<\"SOSO\"<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long LL;\npriority_queue<pair<LL,int>,vector<pair<LL,int> >,greater<pair<LL,int> > > q;\nconst LL INF=1e15;\nLL dis[110000];\nLL fdis[110000];\nint pp[110000];\nint last[110000],pre[210000],e[210000],num;\nLL w[210000];\nint n,m;\nvoid dijkstra(int x)\n{\tint i,u;\n\tfor (i=1;i<=n;++i)\n\t\tdis[i]=INF,pp[i]=0;\n\tdis[x]=0;\n\tfor (i=1;i<=n;++i)\n\t\tq.push(make_pair(dis[i],i));\n\twhile (!q.empty())\n\t{\t\n\t\tu=q.top().second;\n\t\tq.pop();\n\t\tif (pp[u])\n\t\t\tcontinue ;\n\t\tpp[u]=1;\n\t\tfor (i=last[u];i!=0;i=pre[i])\n\t\t\tif (dis[e[i]]>dis[u]+w[i])\n\t\t\t{\tdis[e[i]]=dis[u]+w[i];\n\t\t\t\tq.push(make_pair(dis[e[i]],e[i]));\n\t\t\t}\n\t}\n}\null f[110000];\nstruct edge\n{\n\tint x,y;\n\tLL z;\n}a[110000];\nstruct node\n{\n\tLL dis;\n\tint id;\n\tfriend bool operator < (node a, node b)\n\t{\n\t\tif (a.dis!=b.dis) return a.dis>b.dis;\n\t\treturn a.id<b.id;\n\t}\n}b[110000];\nstring ans[110000];\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\te[++num]=y,pre[num]=last[x],last[x]=num,w[num]=z;\n\t\ta[i].x=x,a[i].y=y,a[i].z=z;\n\t}\n\tdijkstra(1);\n\tf[2]=1;\n\tint nn=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (i!=2) b[++nn].dis=dis[i],b[nn].id=i;\n\tsort(b+1,b+n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x=b[i].id;\n\t\tfor (int j=last[x];j;j=pre[j])\n\t\t\tif (dis[x]+(LL)w[j]==dis[e[j]]) f[x]+=f[e[j]];\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].x,y=a[i].y;\n\t\tLL z=a[i].z;\n\t\tif (dis[x]+z==dis[y])\n\t\t{\n\t\t\tif (f[1]==f[y]) ans[i]=\"SAD\";\n\t\t\telse ans[i]=\"SOSO\";\n\t\t}\n\t}\n\tnum=0;\n\tfor (int i=1;i<=n;i++)\n\t\tlast[i]=0,fdis[i]=dis[i];\n\tfor (int i=1;i<=m;i++)\n\t\te[++num]=a[i].x,pre[num]=last[a[i].y],last[a[i].y]=num,w[num]=a[i].z;\n\tdijkstra(2);\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].x,y=a[i].y;\n\t\tLL z=a[i].z;\n\t\tif (fdis[x]+z!=fdis[y])\n\t\t{\n\t\t\tif (fdis[y]+z+dis[x]<dis[1]) ans[i]=\"HAPPY\";\n\t\t\telse ans[i]=\"SOSO\";\n\t\t}\n\t}\n\tfor (int i=1;i<=m;i++)\n\t\tcout<<ans[i]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#define inf 2147483647\n#define N 1000010\n#define p(a) putchar(a)\n#define For(i,a,b) for(long long i=a;i<=b;++i)\n\nusing namespace std;\nconst long long base[]={20200422,1000000007,9997,7};\nlong long n,m;\nbool bi[N];\nmap<long long,long long>mp;\nvoid in(long long &x){\n    long long y=1;char c=getchar();x=0;\n    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}\n    while(c<='9'&&c>='0'){ x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n    x*=y;\n}\nvoid o(long long x){\n    if(x<0){p('-');x=-x;}\n    if(x>9)o(x/10);\n    p(x%10+'0');\n}\n\nstruct edge{\n\tlong long l,r,v;\n}E[N];\n\nstruct Graph{\n\tlong long cnt;\n\tlong long d[N],low[N],dfn[N];\n\tbool vis[N];\n\tdeque<long long>q;\n\tstruct node{\n\t\tlong long n;\n\t\tlong long v;\n\t\tlong long id;\n\t\tnode *next;\n\t}*e[N];\n\t// Graph(){\n\t// \tcnt=0;\n\t// \tmemset(d,0,sizeof(d));\n\t// \tmemset(low,0,sizeof(low));\n\t// \tmemset(dfn,0,sizeof(dfn));\n\t// \tmemset(vis,0,sizeof(vis));\n\t// \tmemset(e,0,sizeof(e));\n\t// }\n\tvoid push(long long x,long long y,long long v,long long id){\n\t\tnode *p;\n\t\tp=new node();\n\t\tp->n=y;\n\t\tp->v=v;\n\t\tp->id=id;\n\t\tif(e[x]==0)\n\t\t\te[x]=p;\n\t\telse{\n\t\t\tp->next=e[x]->next;\n\t\t\te[x]->next=p;\n\t\t}\n\t}\n\n\tvoid spfa(long long s){\n\t\tmemset(d,0x3f,sizeof(d));\t\t\n\t\td[s]=0;\n\t\tq.push_front(s);\n\t\twhile(!q.empty()){\n\t\t\tlong long x=q.front();q.pop_front();\n\t\t\tvis[x]=1;\n\t\t\tfor(node *i=e[x];i;i=i->next){\n\t\t\t\tif(d[i->n]>d[x]+i->v){\n\t\t\t\t\td[i->n]=d[x]+i->v;\n\t\t\t\t\tif(!vis[i->n]){\n\t\t\t\t\t\tif(!q.empty()&&d[i->n]<d[q.front()]) q.push_front(i->n);\n\t\t\t\t\t\telse q.push_back(i->n);\n\t\t\t\t\t\tvis[i->n]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[x]=0;\t\t\t\n\t\t}\n\t}\n\n\tvoid tarjan(long long x,long long fa){\n\t\tdfn[x]=low[x]=++cnt;\n\t    vis[x]=1;\n\t    for(node *i=e[x];i;i=i->next){\n\t        if(i->n==fa) continue;\n\t        if(!dfn[i->n]){\n\t            tarjan(i->n,x);\n\t            low[x]=min(low[x],low[i->n]);\n\t            if(low[i->n]>dfn[x]) bi[i->id]=1;\n\t        }\n\t        else\n\t            if(vis[i->n])\n\t                low[x]=min(low[x],dfn[i->n]);\n\t    }\n\t}\n}G1,G2,G3;\n\nsigned main(){\n\t//freopen(\"t.in\",\"r\",stdin);\n \t//freopen(\"t2.out\",\"w\",stdout);\n    in(n);in(m);\n    For(i,1,m){\n    \tin(E[i].l);in(E[i].r);in(E[i].v);\n    \tG1.push(E[i].l,E[i].r,E[i].v,i);\n    \tG2.push(E[i].r,E[i].l,E[i].v,i);\n    \tmp[E[i].l*base[1]+E[i].r*base[2]+E[i].v*base[3]]++;\n    }\n    G1.spfa(1);G2.spfa(2);\n    For(i,1,m){\n    \tif(G1.d[E[i].l]+G2.d[E[i].r]+E[i].v==G1.d[2]){\n    \t\tG3.push(E[i].l,E[i].r,E[i].v,i);\n    \t\tG3.push(E[i].r,E[i].l,E[i].v,i);\n    \t}\n    }\n    G3.tarjan(1,1);\n    For(i,1,m){\n    \tif(G1.d[E[i].r]+G2.d[E[i].l]+E[i].v<G1.d[2]) puts(\"HAPPY\");\n    \telse if(bi[i]&&mp[E[i].l*base[1]+E[i].r*base[2]+E[i].v*base[3]]==1) puts(\"SAD\");\n    \telse puts(\"SOSO\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;    \n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        // E[a].push_back(Edge{i, a, b, c});\n        // rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c, false});\n    }\n    sort(begin(edges), end(edges), [] (Edge &a, Edge &b) {\n            return make_tuple(a.from, a.to, a.cost) < make_tuple(b.from, b.to, b.cost);\n        });\n    rep(i, M) {\n        int index = edges[i].index;\n        int a = edges[i].from;\n        int b = edges[i].to;\n        int c = edges[i].cost;\n        if(i > 0) {\n            auto &pe = edges[i - 1];\n            if(pe.from == a and pe.to == b and pe.cost > c) {\n                edges[i].multi = true;\n                // continue;\n            }\n            if(pe.from == a and pe.to == b and pe.cost == c) {\n                edges[i].multi = true;\n                edges[i - 1].multi = true;\n                // continue;\n            }\n        }  \n        E[a].push_back(Edge{index, a, b, c});\n        rE[b].push_back(Edge{index, b, a, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    // cerr << \"shortest path\" << endl;\n    // for(auto es : shortest_graph) {\n    //     for(Edge e : es) {\n    //         cerr << e.from + 1 << \" \" << e.to + 1 << endl;\n    //     }\n    // }\n    // debug(\"--\");\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n\n    // for(int b : bridges) {\n    //     debug(b);\n    // }\n    sort(begin(edges), end(edges), [] (Edge &a, Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and not e.multi){\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for (int i = (s); i < (int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for (int i = (int)(s - 1); i >= (int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(), r.end()\n#define rall(r) r.rbegin(), r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\ntemplate <typename T>\nT chmax(T &a, const T &b) { return a = (a > b ? a : b); }\ntemplate <typename T>\nT chmin(T &a, const T &b) { return a = (a < b ? a : b); }\n\n#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << \" \"\n#define dumpL(x) cout << #x << \" : \" << x << '\\n'\n#define LINE cout << \"line : \" << __LINE__ << \" \"\n#define LINEL cout << \"line : \" << __LINE__ << '\\n'\n#define dumpV(v)           \\\n    cout << #v << \" : [\";  \\\n    for (auto &t : v)      \\\n        cout << t << \", \"; \\\n    cout << \"]\"            \\\n         << \" \"\n#define dumpVL(v)          \\\n    cout << #v << \" : [\";  \\\n    for (auto &t : v)      \\\n        cout << t << \", \"; \\\n    cout << \"]\" << endl\n#define STOP assert(false)\n#else\n#define dump(x)\n#define dumpL(x)\n#define LINE\n#define LINEL\n#define dumpV(v)\n#define dumpVL(v)\n#define STOP assert(false)\n#endif\n#define mp make_pair\n\nnamespace std\n{\ntemplate <class S, class T>\nostream &operator<<(ostream &out, const pair<S, T> &a)\n{\n    out << '(' << a.fi << \", \" << a.se << ')';\n    return out;\n}\n} // namespace std\n\n//有向、無向グラフ共通クラス(隣接リスト)\nstruct Graph\n{\n    int n;\n    using WEIGHT_TYPE = ll;\n    static const WEIGHT_TYPE INF = 1e18;\n    struct Edge\n    {\n        int to;\n        WEIGHT_TYPE weight;\n        int id;\n    };\n    struct Edge2\n    {\n        int from;\n        int to;\n        WEIGHT_TYPE weight;\n        int id;\n    };\n    vector<vector<Edge>> es;\n    Graph(int n) : n(n), es(n) {}\n\n    // dijkstra O(E log V)\n    vector<WEIGHT_TYPE> dijkstra(int s)\n    {\n        vector<WEIGHT_TYPE> d(n, INF);\n        d[s] = 0;\n        using P = pair<WEIGHT_TYPE, int>;\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push({0LL, s});\n        while (!q.empty())\n        {\n            auto p = q.top();\n            q.pop();\n            int cur = p.se;\n            auto cost = p.fi;\n            if (d[cur] < p.fi)\n                continue;\n            for (auto &e : es[cur])\n            {\n                int to = e.to;\n                auto dist = e.weight + cost;\n                if (dist < d[to])\n                {\n                    d[to] = dist;\n                    q.push({dist, to});\n                }\n            }\n        }\n        return d;\n    }\n    // warshall_floyd O(n^3)\n    vector<vector<WEIGHT_TYPE>> warshall_floyd()\n    {\n        vector<vector<WEIGHT_TYPE>> d(n, vector<WEIGHT_TYPE>(n, INF));\n        rep(i, n) d[i][i] = 0LL;\n        rep(i, n) for (auto &&e : es[i])\n        {\n            int j = e.to;\n            chmin(d[i][j], e.weight);\n        }\n        rep(k, n) rep(i, n) rep(j, n)\n        {\n            chmin(d[i][j], d[i][k] + d[k][j]);\n        }\n        return d;\n    }\n    // 頂点sから到達できるか\n    vector<bool> getVisitable(int s)\n    {\n        vector<bool> ret(n);\n        queue<int> q;\n        q.push(s);\n        ret[s] = true;\n        while (!q.empty())\n        {\n            auto cur = q.front();\n            q.pop();\n            for (auto &&e : es[cur])\n            {\n                if (!ret[e.to])\n                {\n                    ret[e.to] = true;\n                    q.push(e.to);\n                }\n            }\n        }\n        return ret;\n    }\n    //2部グラフ判定\n    bool isBipartile()\n    {\n        vector<int> memo(n, -1);\n        rep(i, n)\n        {\n            if (memo[i] != -1)\n                continue;\n            queue<int> q;\n            q.push(i);\n            memo[i] = 0;\n            while (!q.empty())\n            {\n                auto v = q.front();\n                q.pop();\n                for (auto &&e : es[v])\n                {\n                    auto u = e.to;\n                    if (memo[u] == -1)\n                    {\n                        memo[u] = !memo[v];\n                        q.push(u);\n                    }\n                    else if (memo[u] == memo[v])\n                    {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n};\n\n// 無向グラフ\nstruct GraphUD : public Graph\n{\n    GraphUD(int n) : Graph(n) {}\n    void add_edge(int from, int to, WEIGHT_TYPE weight, int id)\n    {\n        es[from].push_back({to, weight, id});\n        es[to].push_back({from, weight, id});\n    }\n    vector<Edge2> getEdge2()\n    {\n        vector<Edge2> ret;\n        rep(i, n) for (auto &&e : es[i])\n        {\n            if (i < e.to)\n                ret.push_back({i, e.to, e.weight, e.id});\n        }\n        return ret;\n    }\n    // 橋の検出\n    // http://nupioca.hatenadiary.jp/entry/2013/11/03/200006\n    // Calculate bridges in a undirected graph.\n    // Assume graph is connected and has no parallel edges or self-loops.\n    vector<Edge2> getBridges()\n    {\n        int V = n;\n        // res: bridges\n        vector<Edge2> res;\n        // assume at least the first vertex exists\n        vector<int> low(V, -1); // lowest reacheable index\n        vector<int> pre(V, -1); // pre-order index\n        int count = 0;          // pre-order index counter\n\n        // v: current node\n        // from: parent node\n        function<int(int, int)> dfs = [&](int v, int from) {\n            pre[v] = count++;\n            low[v] = pre[v];\n            for (auto &&e : es[v])\n            {\n                int to = e.to;\n                if (pre[to] == -1)\n                {\n                    // destination has not been visited\n                    // visit destination and update low[v]\n                    low[v] = min(low[v], dfs(to, v));\n                    if (low[to] == pre[to])\n                    {\n                        // edge is not contained in a closed path -> bridge\n                        res.push_back({v, to, e.weight, e.id});\n                    }\n                }\n                else\n                {\n                    if (from == to)\n                    {\n                        // ignore a path to parent\n                        continue;\n                    }\n                    low[v] = min(low[v], low[to]);\n                }\n            }\n            return low[v];\n        };\n\n        dfs(0, -1); // start dfs from vertex 0\n\n        return res;\n    }\n};\n\n// 有向グラフ\nstruct GraphD : public Graph\n{\n    GraphD(int n) : Graph(n) {}\n    void add_edge(int from, int to, WEIGHT_TYPE weight, int id)\n    {\n        es[from].push_back({to, weight, id});\n    }\n    vector<Edge2> getEdge2()\n    {\n        vector<Edge2> ret;\n        rep(i, n) for (auto &&e : es[i])\n        {\n            ret.push_back({i, e.to, e.weight, e.id});\n        }\n        return ret;\n    }\n    GraphD getReverseGraph()\n    {\n        GraphD g(n);\n        rep(i, n) for (auto &&e : es[i])\n        {\n            g.add_edge(e.to, i, e.weight, e.id);\n        }\n        return g;\n    }\n    vector<vector<int>> scc()\n    {\n        vector<vector<int>> res;\n        vector<int> cmp(n);\n        vector<int> vs;\n        vector<vector<int>> r_es(n);\n        rep(i, n) for (auto &&e : es[i])\n        {\n            int j = e.to;\n            r_es[j].push_back(i);\n        }\n\n        vector<bool> used(n);\n        function<void(int)> dfs = [&](int v) {\n            used[v] = true;\n            for (auto &&e : es[v])\n            {\n                int to = e.to;\n                if (!used[to])\n                    dfs(to);\n            }\n            vs.push_back(v);\n        };\n        function<void(int, int)> rdfs = [&](int v, int k) {\n            used[v] = true;\n            cmp[v] = k;\n            for (auto &&to : r_es[v])\n            {\n                if (!used[to])\n                    rdfs(to, k);\n            }\n        };\n\n        fill(all(used), 0);\n        vs.clear();\n        for (int v = 0; v < n; v++)\n        {\n            if (!used[v])\n                dfs(v);\n        }\n        fill(all(used), 0);\n        int k = 0;\n        for (int i = vs.size() - 1; i >= 0; i--)\n        {\n            if (!used[vs[i]])\n                rdfs(vs[i], k++);\n        }\n        res.clear();\n        res.resize(k);\n        for (int i = 0; i < n; i++)\n        {\n            res[cmp[i]].push_back(i);\n        }\n        return res;\n    }\n    // bellmanFord 負閉路があるなら, dist[s] = INF | O(VE)\n    vector<WEIGHT_TYPE> bellmanFord(int s)\n    {\n        vector<WEIGHT_TYPE> dist(n, INF);\n        dist[s] = 0;\n        auto es = getEdge2();\n        rep(i, n)\n        {\n            for (auto &&e : es)\n            {\n                if (dist[e.to] > dist[e.from] + e.weight)\n                {\n                    dist[e.to] = dist[e.from] + e.weight;\n                    if (i == n - 1)\n                    {\n                        dist[s] = INF;\n                        return dist;\n                    }\n                }\n            }\n        }\n        return dist;\n    }\n    // bellmanFord s->tの経路上に負閉路があるなら, dist[s] = INF | O(VE)\n    vector<WEIGHT_TYPE> bellmanFord2(int s, int t)\n    {\n        vector<WEIGHT_TYPE> dist(n, INF);\n        auto f1 = getVisitable(s);\n        auto f2 = getReverseGraph().getVisitable(t);\n        dist[s] = 0;\n        auto es = getEdge2();\n        rep(i, n)\n        {\n            for (auto &&e : es)\n            {\n                if (!(f1[e.from] && f2[e.to]))\n                    continue;\n                if (dist[e.to] > dist[e.from] + e.weight)\n                {\n                    dist[e.to] = dist[e.from] + e.weight;\n                    if (i == n - 1)\n                    {\n                        dist[s] = INF;\n                        return dist;\n                    }\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    GraphD g(n);\n    vector<int> A(m), B(m), C(m);\n    rep(i, m)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        g.add_edge(a - 1, b - 1, c, i);\n        A[i] = a - 1;\n        B[i] = b - 1;\n        C[i] = c;\n    }\n    auto x = g.dijkstra(0);\n    auto y = g.getReverseGraph().dijkstra(1);\n\n    vector<int> usedMinGraph(m);\n\n    map<int, int> mp;\n\n    rep(i, m)\n    {\n        int frm = A[i], to = B[i], cost = C[i];\n        usedMinGraph[i] = ((x[frm] + cost == x[to]) && (y[to] + cost == y[frm]));\n        if (usedMinGraph[i])\n        {\n            mp[frm] = 1;\n            mp[to] = 1;\n        }\n    }\n    {\n        int cnt = 0;\n        for (auto &p : mp)\n            p.se = cnt++;\n    }\n    GraphUD f(mp.size());\n    rep(i, m) if (usedMinGraph[i])\n    {\n        int u = A[i], v = B[i];\n        f.add_edge(mp[u], mp[v], 1, i);\n    }\n    auto b = f.getBridges();\n    // dumpL(b.size());\n    vector<int> isBrdg(m);\n    for (auto &&e2 : b)\n    {\n        isBrdg[e2.id] = true;\n    }\n    auto dist = x[1];\n    rep(i, m)\n    {\n        if (usedMinGraph[i])\n        {\n            if (isBrdg[i])\n                cout << \"SAD\" << '\\n';\n            else\n                cout << \"SOSO\" << '\\n';\n        }\n        else\n        {\n            int u = A[i], v = B[i], cost = C[i];\n            if (x[v] + cost + y[u] < dist)\n                cout << \"HAPPY\" << '\\n';\n            else\n                cout << \"SOSO\" << '\\n';\n        }\n    }\n    // dumpVL(usedMinGraph);\n    // dumpVL(isBrdg);\n    // dumpVL(x);\n    // dumpVL(y);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int,int> PII;\ntypedef pair <long long,long long> PLL;\n\n#define si(a)           scanf(\"%d\",&a)\n#define sii(a,b)        scanf(\"%d %d\",&a,&b)\n#define siii(a,b,c)     scanf(\"%d %d %d\",&a,&b,&c)\n\n#define sl(a)           scanf(\"%lld\",&a)\n#define sll(a,b)        scanf(\"%lld %lld\",&a,&b)\n#define slll(a,b,c)     scanf(\"%lld %lld %lld\",&a,&b,&c)\n\n#define un(x)           x.erase(unique(all(x)), x.end())\n#define xx              first\n#define yy              second\n#define pb              push_back\n#define mp              make_pair\n#define all(v)          v.begin(),v.end()\n#define D(x)            cerr << #x \" = \" << x << '\\n'\n#define DBG             cerr << \"Hi!\" << '\\n'\n\n#define CLR(a)          memset(a,0,sizeof(a))\n#define SET(a)          memset(a,-1,sizeof(a))\n\n#define eps             1e-9\n#define PI              acos(-1.0)\n\nint setBit(int n,int pos) { return n = n | (1 << pos); }\nint resetBit(int n,int pos) { return n = n & ~(1 << pos); }\nbool checkBit(ll n,ll pos) { return (bool)(n & (1LL << pos)); }\n\n//int fx[] = {+0, +0, +1, -1, -1, +1, -1, +1};\n//int fy[] = {-1, +1, +0, +0, +1, +1, -1, -1}; //Four & Eight Direction\n\n/******************************************************************************************/\n\nconst int MAX = 100010;\nconst ll INF = 2000000000000LL;\n\nvector <int> g[MAX], rg[MAX] , ed[MAX],bucket[MAX];\n\nint sdom[MAX],par[MAX],dom[MAX],dsu[MAX],label[MAX];\nint arr[MAX],rev[MAX],Time,n,source;\n\nvoid init(int _n,int _source) {\n    Time = 0;\n    n = _n;\n    source = _source;\n    for(int i=1;i<=n;i++) {\n        g[i].clear() , rg[i].clear() , ed[i].clear() , bucket[i].clear();\n        arr[i] = sdom[i] = par[i] = dom[i] = dsu[i] = label[i] = rev[i] = 0;\n    }\n}\n\n\nvoid dfs(int u) {\n    Time++;\n    arr[u] = Time;\n    rev[Time] = u;\n    label[Time] = Time;\n    sdom[Time] = Time;\n    dsu[Time] = Time;\n    int i,w;\n    for(i=0;i<g[u].size();i++) {\n        w = g[u][i];\n        if(!arr[w]) {\n            dfs(w);\n            par[arr[w]] = arr[u];\n        }\n        rg[arr[w]].pb(arr[u]);\n    }\n}\n\ninline int Find(int u,int x=0) {\n    if(u==dsu[u]) return x ? - 1 : u;\n    int v = Find(dsu[u],x+1);\n    if(v<0) return u;\n    if(sdom[label[dsu[u]]] < sdom[label[u]])\n        label[u] = label[dsu[u]];\n    dsu[u] = v;\n    return x ? v : label[u];\n}\n\n\ninline void Union(int u,int v) {\n    dsu[v] = u;\n}\n\nvoid build() {\n    dfs(source);\n    for(int i=n;i>=1;i--) {\n        for(int j=0;j<rg[i].size();j++)\n            sdom[i] = min(sdom[i],sdom[Find(rg[i][j])]);\n        if(i>1)\n            bucket[sdom[i]].pb(i);\n        for(int j=0;j<bucket[i].size();j++) {\n            int w = bucket[i][j] , v = Find(w);\n            if(sdom[v] == sdom[w]) dom[w] = sdom[w];\n            else dom[w] = v;\n        }\n        if(i>1) Union(par[i],i);\n\n        for(int i=2;i<=n;i++) {\n            if(dom[i]!=sdom[i]) dom[i] = dom[dom[i]];\n\n            if(rev[i]==0 or rev[dom[i]]==0) continue;\n\n            ed[rev[i]].pb(rev[dom[i]]);\n            ed[rev[dom[i]]].pb(rev[i]);\n        }\n    }\n}\n\nvector <int> G[2][MAX];\nvector <int> co[2][MAX];\nll dis[2][MAX];\nbool vis[MAX];\n\nstruct node {\n    int city;\n    ll cost;\n};\n\nbool operator < (node a,node b) {\n    return a.cost > b.cost;\n}\n\nvoid dijkstra(int s,int n,int id,int d) {\n    int i,x,u,v,c;\n    node a,b;\n    for(int i=1;i<=n;i++) dis[id][i] = INF;\n    dis[id][s] = 0;\n    a = {s,0};\n    priority_queue <node> Q;\n    Q.push(a);\n\n    while(!Q.empty()) {\n        a = Q.top();\n        Q.pop();\n        u = a.city;\n        if(!vis[u]) {\n            vis[u] = true;\n            for(int i=0;i<G[id][u].size();i++) {\n                v = G[id][u][i];\n                c = co[id][u][i];\n                if(dis[id][v] > dis[id][u] + c) {\n                    dis[id][v] = dis[id][u] + c;\n                    b = {v,dis[id][v]};\n                    if(v!=d) Q.push(b);\n                }\n            }\n        }\n    }\n}\n\nint lg;\nint L[MAX],P[MAX][22];\n\nvoid dfss(int s,int par,int l) {\n    int i,x;\n    L[s] = l;\n    for(int i=0;i<ed[s].size();i++) {\n        x = ed[s][i];\n        if(x!=par) {\n            P[x][0] = s;\n            dfss(x,s,l+1);\n        }\n    }\n}\n\nvoid lca_build(int n,int root) {\n    SET(P);\n    dfss(root,-1,0);\n    lg = (log(n)/log(2.0))+2;\n\n    int i,j;\n    for(int j=1;(1<<j)<=n;j++) {\n        for(i=1;i<=n;i++) {\n            if(P[i][j-1]!=-1) P[i][j] = P[P[i][j-1]][j-1];\n        }\n    }\n}\n\ninline int lca_query(int x,int y) {\n    if(L[x]<L[y]) swap(x,y);\n    int i,j;\n    for(i=lg;i>=0;i--) {\n        if(L[x] - (1<<i) >= L[y]) x = P[x][i];\n    }\n\n    if(x==y) return x;\n    for(i=lg;i>=0;i--) {\n        if(P[x][i]!=-1 && P[x][i]!=P[y][i]) {\n            x = P[x][i];\n            y = P[y][i];\n        }\n    }\n    return P[x][0];\n}\n\n\nstruct Edge {\n    int u,v,w;\n} edges[MAX];\n\nmap < PII , int > Mn;\nmap < PII , int > Cnt;\n\nbool ase[MAX];\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n\n    int m,u,v,w;\n    sii(n,m);\n\n    init(n,1);\n\n    for(int i=1;i<=m;i++) {\n        siii(u,v,w);\n        edges[i] = {u,v,w};\n\n        if(Mn.find({u,v})==Mn.end()) {\n            Mn[{u,v}] = w;\n            Cnt[{u,v}] = 1;\n        }\n        else {\n            if(w==Mn[{u,v}]) Cnt[{u,v}]++;\n            else if(w<Mn[{u,v}]){\n                Mn[{u,v}] = w;\n                Cnt[{u,v}] = 1;\n            }\n        }\n        G [0][u].push_back(v);\n        co[0][u].push_back(w);\n\n        G [1][v].push_back(u);\n        co[1][v].push_back(w);\n    }\n\n    dijkstra(1,n,0,2);\n    dijkstra(2,n,1,1);\n\n\n\n\n    for(int i=1;i<=m;i++) {\n        u = edges[i].u;\n        v = edges[i].v;\n        w = edges[i].w;\n        if(dis[0][u] + w + dis[1][v] == dis[0][2]) {\n            g[u].pb(v);\n            ase[i] = true;\n        }\n    }\n\n    build();\n    lca_build(n,1);\n    for(int i=1;i<=m;i++) {\n        u = edges[i].u;\n        v = edges[i].v;\n        w = edges[i].w;\n\n        if(dis[0][v] + w + dis[1][u] < dis[0][2]) {\n            puts(\"HAPPY\");\n            continue;\n        }\n\n        if(!ase[i]) {\n            puts(\"SOSO\");\n            continue;\n        }\n\n\n        if( Cnt[{u,v}] >=2 ) {\n            puts(\"SOSO\");\n            continue;\n        }\n\n        if(lca_query(u,2)==u && lca_query(v,2)==v) {\n            puts(\"SAD\");\n            continue;\n        }\n        else {\n            puts(\"SOSO\");\n            continue;\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int v, w; };\nconst ll INF = LLONG_MAX / 3;\nconst int MOD = 1e9 + 114514;\n\npair<vector<ll>, vector<int>> dijkstra(int N, vector<vector<edge>>& G, int s) {\n\tvector<ll> d(N, INF); d[s] = 0;\n\tvector<int> way(N); way[s] = 1;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i>> pq;\n\tpq.push(ll_i(0, s));\n\twhile (pq.size()) {\n\t\tll_i p = pq.top(); pq.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (edge e: G[u]) {\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tway[e.v] = 0;\n\t\t\t\tpq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t\t\tif (d[e.v] == d[u] + e.w)\n\t\t\t\tway[e.v] = (way[e.v] + way[u]) % MOD;\n\t\t}\n\t}\n\treturn {d, way};\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<int> a(M), b(M), c(M);\n\trep(i, M) scanf(\"%d%d%d\", &a[i], &b[i], &c[i]), a[i]--, b[i]--;\n\tvector<vector<edge>> G(N), _G(N);\n\trep(i, M) G[a[i]].pb({b[i], c[i]}), _G[b[i]].pb({a[i], c[i]});\n\tauto z = dijkstra(N, G, 0), _z = dijkstra(N, _G, 1);\n\tvector<ll> d = z.first, _d = _z.first;\n\tvector<int> way = z.second, _way = _z.second;\n\tll D = d[1]; int WAY = way[1];\n\trep(i, M) {\n\t\tint u = a[i], v = b[i];\n\t\tif (d[u] + c[i] + _d[v] == D && (ll)way[u] * way[v] % MOD == WAY)\n\t\t\tprintf(\"SAD\\n\");\n\t\telse if (d[v] + c[i] + _d[u] < D)\n\t\t\tprintf(\"HAPPY\\n\");\n\t\telse\n\t\t\tprintf(\"SOSO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000021;\nconst long long inf = 1LL << 61;\nstruct edge { int to, cost, id; };\nstruct edge2 { int to, id; };\nstruct state { int pos; long long cost; };\nbool operator<(const state& s1, const state& s2) { return s1.cost > s2.cost; }\nint N, M, dp[100009], dp2[100009], va[100009]; bool vis1[100009], vis2[100009]; vector<int> a, b, c;\nvector<long long> shortest_path(vector<vector<edge> > g, int src) {\n\tvector<long long> ret(g.size(), inf); ret[src] = 0;\n\tpriority_queue<state> que; que.push(state{ src, 0 });\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (edge e : g[u]) {\n\t\t\tlong long nd = ret[u] + e.cost;\n\t\t\tif (ret[e.to] > nd) {\n\t\t\t\tret[e.to] = nd;\n\t\t\t\tque.push(state{ e.to, nd });\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvector<int> solve() {\n\tvector<vector<edge> > g(N);\n\tvector<vector<edge> > rg(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tg[a[i]].push_back(edge{ b[i], c[i], i });\n\t\trg[b[i]].push_back(edge{ a[i], c[i], i });\n\t}\n\tvector<long long> ds = shortest_path(g, 0);\n\tvector<long long> dt = shortest_path(rg, 1);\n\tvector<bool> ok(M);\n\tvector<vector<edge2> > sg(N), sr(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ds[a[i]] + c[i] + dt[b[i]] == ds[1]) {\n\t\t\tsg[a[i]].push_back(edge2{ b[i], i });\n\t\t\tsr[b[i]].push_back(edge2{ a[i], i });\n\t\t\tok[i] = true;\n\t\t}\n\t}\n\tfill(vis1, vis1 + N, false);\n\tfill(vis2, vis2 + N, false);\n\tfill(dp, dp + N, 0);\n\tfill(dp2, dp2 + N, 0);\n\tvector<int> dpm1(M), dpm2(M);\n\tpriority_queue<state> que; que.push(state{ 0, 0 }); dp[0] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis1[u]) {\n\t\t\tvis1[u] = true;\n\t\t\tfor (edge2 i : sg[u]) {\n\t\t\t\tdp[i.to] += dp[u];\n\t\t\t\tdpm1[i.id] = dp[u];\n\t\t\t\tif (dp[i.to] >= mod) dp[i.to] -= mod;\n\t\t\t\tque.push(state{ i.to, ds[i.to] });\n\t\t\t}\n\t\t}\n\t}\n\tque.push(state{ 1, 0 }); dp2[1] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis2[u]) {\n\t\t\tvis2[u] = true;\n\t\t\tfor (edge2 i : sr[u]) {\n\t\t\t\tdp2[i.to] += dp2[u];\n\t\t\t\tdpm2[i.id] = dp2[u];\n\t\t\t\tif (dp2[i.to] >= mod) dp2[i.to] -= mod;\n\t\t\t\tque.push(state{ i.to, dt[i.to] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) va[i] = 1LL * dp[i] * dp2[i] % mod;\n\tmap<tuple<int, int, int>, int> cnts;\n\tfor (int i = 0; i < M; i++) {\n\t\tcnts[make_tuple(a[i], b[i], c[i])]++;\n\t}\n\tvector<int> ret(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!ok[i]) {\n\t\t\tret[i] = (ds[b[i]] + dt[a[i]] + c[i] < ds[1] ? 2 : 1);\n\t\t}\n\t\telse {\n\t\t\tif (ds[b[i]] + dt[a[i]] + c[i] < ds[1]) ret[i] = 2;\n\t\t\telse if (ds[b[i]] + dt[a[i]] + c[i] == ds[1]) ret[i] = 1;\n\t\t\telse {\n\t\t\t\tif (1LL * dpm1[i] * dpm2[i] % mod == va[0] && cnts[make_tuple(a[i], b[i], c[i])] == 1) ret[i] = 0;\n\t\t\t\telse ret[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\ta = vector<int>(M);\n\tb = vector<int>(M);\n\tc = vector<int>(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t}\n\tvector<int> ret = solve();\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ret[i] == 2) cout << \"HAPPY\\n\";\n\t\telse if (ret[i] == 1) cout << \"SOSO\\n\";\n\t\telse cout << \"SAD\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n            if(ord[now] < low[nxt]) {\n                bridges.insert(nxt_e.index);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    dfs(0);\n    // rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;    \n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        edges.push_back(Edge{i, a - 1, b - 1, c, false});\n    }\n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return make_tuple(a.from, a.to, a.cost) < make_tuple(b.from, b.to, b.cost);\n        });\n    rep(i, M) {\n        auto &e = edges[i]; // mut\n        int index = e.index;\n        int a = e.from;\n        int b = e.to;\n        int c = e.cost;\n        if(i > 0) {\n            auto &pe = edges[i - 1]; // mut\n            if(pe.from == a and pe.to == b) {\n                e.multi = true;\n                if(pe.cost == e.cost) edges[i - 1].multi = true;\n                continue;\n            }\n        }\n        E[a].push_back(Edge{index, a, b, c});\n        rE[b].push_back(Edge{index, b, a, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        const Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and not e.multi) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Bridges */\n\nint bridges_dfs(int now, int backID, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n  \n  visited[now] = 1;\n  \n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == backID) continue;\n    \n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n  \n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n\nvector<bool> bridges(int n, const vector<pair<int,int> > &path){ //無向辺 & 多重辺考慮\n  vector<vector<pair<int,int> > >  way(n);\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n  \n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n  \n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n  \n  return bridges_flag;\n}\n\n\nint n, m;\nint a[SIZE], b[SIZE], c[SIZE];\nvector<int> way[SIZE], rway[SIZE];\n\npriority_queue<pair<ll,int> > pq;\nbool visited[SIZE] = {}, rvisited[SIZE] = {};\nll cost[SIZE], rcost[SIZE];\n\nvector<pair<int,int> > Graph;\nvector<int> pathID;\nbool visited2[SIZE] = {};\n\nbool isBridge[SIZE] = {};\n\nint main(){\n  \n  scanf(\"%d%d\",&n,&m);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n\n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n\n  //Dijkstra\n  \n  pq.push({0,0});\n\n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n\n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n\n  pq.push({0,1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n\n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n\n\n  pq.push({cost[1], 1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    int cur_cost = p.first;\n\n    if(visited2[now]) continue;\n    visited2[now] = true;\n    \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n      }\n    }\n  }\n\n  auto res = bridges(n, Graph);\n  \n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n  \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nvector<vector<pii> > G, rG;\nvector<vector<int> > I, rI;\nll C[100100], rC[100100];\nbool tmp[100100];\nbool bridge[100100];\nint lst[100100][3];\nmap<pii,pii> mul;\nconst ll INF = 1e15;\n\nvoid shortest(vector<vector<pii> > g, ll *c, int s) {\n\tfor(int i = 0; i < 100100; i++) {\n\t\tc[i] = INF;\n\t}\n\tc[s] = 0;\n\tpriority_queue<pli> q;\n\tq.push(pli(0,s));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(c[a.se] < -a.fi) continue;\n\t\tfor(int i = 0; i < g[a.se].size(); i++) {\n\t\t\tint v = g[a.se][i].fi;\n\t\t\tll t = -a.fi + g[a.se][i].se;\n\t\t\tif(c[v] > t) {\n\t\t\t\tc[v] = t;\n\t\t\t\tq.push(pli(-t, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mkbridge() {\n\tll sp = C[1];\n\tpriority_queue<pli> q;\n\tq.push(pli(0,0));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(tmp[a.se]) continue;\n\t\ttmp[a.se] = true;\n\t\tint id =-1;\n\t\tint src,dst;\n\t\tfor(int i = 0; i < G[a.se].size(); i++) {\n\t\t\tint v = G[a.se][i].fi;\n\t\t\tif(sp == C[a.se] + G[a.se][i].se + rC[v]) {\n\t\t\t\tif(mul[pii(a.se,v)].fi == G[a.se][i].se && mul[pii(a.se,v)].se > 0) {\n\t\t\t\t\tmul[pii(a.se,v)].se = -mul[pii(a.se,v)].se;\n\t\t\t\t\tq.push(pli(-C[v], v));\n\t\t\t\t\tid = I[a.se][i];\n\t\t\t\t\tsrc=a.se;\n\t\t\t\t\tdst=v;\n\t\t\t\t\t//cout << a.se << \" \" << v << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.size() == 1 && id >= 0 && mul[pii(src,dst)].se == -1) {\n\t\t\tbridge[id] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tG.resize(n);\n\trG.resize(n);\n\tI.resize(n);\n\trI.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tG[a].push_back(pii(b,c));\n\t\trG[b].push_back(pii(a,c));\n\t\tI[a].push_back(i);\n\t\trI[b].push_back(i);\n\t\tlst[i][0] = a; lst[i][1] = b; lst[i][2] = c;\n\n\t\tif(mul.find(pii(a,b)) == mul.end())\n\t\t\tmul[pii(a,b)] = pii(c,1);\n\t\telse if(mul[pii(a,b)].fi == c)\n\t\t\tmul[pii(a,b)].se++;\n\t\telse if(mul[pii(a,b)].se > c)\n\t\t\tmul[pii(a,b)] = pii(c,1);\n\t}\n\tshortest(G,C,0);\n\tshortest(rG,rC,1);\n\tmkbridge();\n\t/*\n\tfor(int i = 0; i < m; i++)\n\t\tcout << bridge[i] << \" \";cout << endl;\n\t// */\n\n\tll sp = C[1];\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = lst[i][0]; b = lst[i][1]; c = lst[i][2];\n\t\tif(C[b] + c + rC[a] < sp) {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t\telse if(bridge[i] && C[b] + c + rC[a] > sp && sp != INF) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, 1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    if(dist[v] == d) (cnt[v] += p) %= MOD;\n    if(dist[v] < d) {\n      dist[v] = d;\n      cnt[v] = p;\n    }\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, cnt[v] });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define SZ(i) int(i.size())\n#ifdef tmd\n#define IOS()\n#define debug(...) fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);_do(__VA_ARGS__);\ntemplate<typename T> void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T, typename ...S> void _do(T &&x, S &&...y){cerr<<x<<\", \";_do(y...);}\n#else\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(...)\n#endif\n\nconst int MAXN = 100005;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\ntypedef pair<int, int> pii;\n\nint n, m;\n\nstruct Edge {\n    int u, v, c;\n    Edge (int i1, int i2, int i3) : u(i1), v(i2), c(i3){};\n};\nvector<Edge> org;\nvector<int> edg[MAXN];\nvector<int> rev[MAXN];\nbool is_tree[MAXN];\nbool on_path[MAXN];\nll fdi[MAXN], rdi[MAXN];\n\nstruct PQ {\n    int nd, id;\n    ll w;\n    PQ (int v, int idd, ll c) : nd(v), id(idd), w(c){}\n    bool operator < (const PQ &p) const {\n        return w > p.w;\n    }\n};\nbool vis[MAXN];\nvoid dijkstra (ll *dis, vector<int> edge[], int src) {\n    memset(dis, 0x3f3f3f3f, sizeof(ll)*MAXN);\n    memset(vis, 0, sizeof(bool)*MAXN);\n    memset(is_tree, 0, sizeof(bool)*MAXN);\n    dis[src] = 0;\n    priority_queue<PQ> pq;\n    pq.emplace(src, MAXN-1, 0);\n\n    while (pq.size()) {\n        PQ cur = pq.top();\n        pq.pop();\n        if (vis[cur.nd]) {\n            continue;\n        }\n        debug(cur.nd, cur.w);\n        vis[cur.nd] = true;\n        is_tree[cur.id] = true;\n\n        for (int eid : edge[cur.nd]) {\n            int t = org[eid].u ^ org[eid].v ^ cur.nd;\n            if (dis[t] > dis[cur.nd] + org[eid].c) {\n                dis[t] = dis[cur.nd] + org[eid].c;\n                pq.emplace(t, eid, dis[t]);\n            }\n        }\n    }\n}\n\nvector<int> path;\nbool path_edge[MAXN];\nvoid revisit (int src) {\n    while (src != 1) {\n        int cnt = 0, prv = -1, id = -1;\n        for (auto eid : rev[src]) {\n            if (is_tree[eid]) {\n                cnt++;\n                prv = org[eid].u;\n                id = eid;\n                path_edge[id] = true;\n            }\n        }\n        path.emplace_back(id);\n        assert(cnt == 1);\n        on_path[src] = true;\n        src = prv;\n    }\n    reverse(path.begin(), path.end());\n    on_path[1] = true;\n}\n\nint path_anc[MAXN];\nvoid dfs (int nd, int cur) {\n    path_anc[nd] = cur;\n    for (auto eid : edg[nd]) {\n        if (is_tree[eid]) {\n            if (path_edge[eid]) {\n                dfs(org[eid].v, org[eid].v);\n            } else {\n                dfs(org[eid].v, cur);\n            }\n        }\n    }\n}\n\nvector<int> alt[MAXN];\nbool n_sad[MAXN];\n/*********************GoodLuck***********************/\nint main () {\n    IOS();\n\n    cin >> n >> m;\n\n    REP (i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        org.emplace_back(a, b, c);\n        edg[a].emplace_back(i);\n        rev[b].emplace_back(i);\n    }\n\n    dijkstra(rdi, rev, 2);\n    dijkstra(fdi, edg, 1);\n    revisit(2);\n    dfs(1, 1);\n    ll bs = fdi[2];\n    debug(path_anc[5]);\n    REP (i, m) {\n        if (!is_tree[i] && on_path[org[i].v]) {\n            if (fdi[org[i].u] + rdi[org[i].v] + org[i].c == bs) {\n                int f = path_anc[org[i].u];\n                alt[f].emplace_back(org[i].v);\n                debug(f, org[i].v);\n                debug(org[i].u, org[i].v);\n            }\n        }\n    }\n\n    int s = 1;\n    set<int> ep;\n    for (auto e : path) {\n        ep.erase(s);\n        int t = org[e].u ^ org[e].v ^ s;\n        for (auto p : alt[s]) {\n            ep.insert(p);\n        }\n        if (SZ(ep)) {\n            n_sad[e] = true;\n        }\n        s = t;\n    }\n\n    REP (i, m) {\n        ll cur = rdi[org[i].u] + fdi[org[i].v] + org[i].c;\n\n        if (cur < bs) {\n            cout << \"HAPPY\" << endl;\n        } else if (n_sad[i] || (!path_edge[i]) || cur == bs){\n            cout << \"SOSO\" << endl;\n        } else {\n            cout << \"SAD\" << endl;\n        }\n    }\n\n    return 0;\n}\n\n/*\n6 7\n1 3 2\n3 4 4\n4 5 3\n5 2 5\n4 2 8\n1 6 1\n6 3 1\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nint min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\nvector<int> SHORTEST_EDGES[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tSHORTEST_EDGES[next_node].clear();\n\t\t\t\t\tSHORTEST_EDGES[next_node].push_back(G[Q.top().node_id][i].edge_id);\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\n\t\t\t\t}else if(min_cost[next_node] == Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tSHORTEST_EDGES[next_node].push_back(G[Q.top().node_id][i].edge_id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\tdijkstra_NORMAL();\n\tdijkstra_REVERSE();\n\n\tint tmp_id;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\tfor(int i = 0; i < V; i++){\n\n\t\tfor(int k = 0; k < SHORTEST_EDGES[i].size(); i++){\n\t\t\ttmp_id =  SHORTEST_EDGES[i][k];\n\t\t\tin_MIN_PATH[tmp_id] = true;\n\t\t\tMIN_G[edge[tmp_id].from].push_back(Info(edge[tmp_id].to,edge[tmp_id].cost,tmp_id));\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to,goal = 1;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[goal] == BIG_NUM){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < BIG_NUM){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) < min_cost[goal]){\n\t\t\tprintf(\"HAPPY\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to] && min_cost[from]+edge[i].cost+rev_min_cost[to] == min_cost[goal]){\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 58;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int Soso  = 1;\nconst int Happy = 2;\nconst int Sad   = 3;\n\nusing Edge = tuple<int, int, int>;\n\nvll dijkstra(vector<vector<Edge>>& G, int sv){\n    int n = G.size();\n    vll min_dist(n, inf);\n    min_dist[sv] = 0;\n\n    using Elem = tuple<ll, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    q.push(Elem(0, sv));\n\n    while(q.size()){\n        ll c; int v; tie(c, v) = q.top(); q.pop();\n        if(min_dist[v] != c) continue;\n\n        for(auto& e : G[v]){\n            int nv, dc, ei; tie(nv, dc, ei) = e;\n            ll nc = c + dc;\n            if(chmin(min_dist[nv], nc)){\n                q.push(Elem(nc, nv));\n            }\n        }\n    }\n    return min_dist;\n}\n\nint depthMax;\nvi etype;\nvi depth;\nvi used;\nvi path;\nvi imo;\nvi oute;\n\nbool dfs(vector<vector<Edge>>& G, int v, int tv, int d){\n    if(v == tv){\n        path.emplace_back(v);\n        depth[v] = d;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(dfs(G, nv, tv, d + 1)){\n            path.emplace_back(v);\n            depth[v] = d;\n            used[ei] = true;\n            oute.emplace_back(ei);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool dfs2(vector<vector<Edge>>& G, int v, int d){\n    if(depth[v] > d){\n        imo[d]++;\n        imo[depth[v]]--;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(used[ei]) continue;\n        if(dfs2(G, nv, d)){\n            // etype[ei] = Soso;\n        }\n    }\n\n    if(d < depthMax - 1){\n        return dfs2(G, path[d + 1], d + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m; cin >> n >> m;\n    vector<vector<Edge>> G(n), Gr(n);\n    vi as(m), bs(m), cs(m);\n    rep(i, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        G [a].emplace_back(Edge(b, c, i));\n        Gr[b].emplace_back(Edge(a, c, i));\n        as[i] = a, bs[i] = b, cs[i] = c;\n    }\n\n    int sv = 0, tv = 1;\n    auto min_dist     = dijkstra(G, sv);\n    auto min_dist_rev = dijkstra(Gr, tv);\n\n    etype = vi(m, Soso);\n\n    vector<vector<Edge>> Gs(n);\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[a] + c == min_dist[b]){\n            Gs[a].emplace_back(Edge(b, c, i));\n        }\n    }\n    depth = vi(n, -1);\n    used  = vi(m);\n    dfs(Gs, sv, tv, 0);\n    reverse(_all(path));\n    reverse(_all(oute));\n    depthMax = path.size();\n\n    // for(auto& e : path) cerr << e+1 << \" \"; cerr << endl;\n    // for(auto& e : oute) cerr << e+1 << \" \"; cerr << endl;\n\n    imo = vi(depthMax);\n    dfs2(Gs, sv, 0);\n    rep(i, 1, depthMax) imo[i] += imo[i - 1];\n    rep(i, depthMax - 1){\n        if(imo[i] == 0){\n            etype[oute[i]] = Sad;\n        }\n    }\n\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[b] + min_dist_rev[a] + c < min_dist[tv]){\n            etype[i] = Happy;\n        }\n    }\n\n    rep(i, m){\n        string res = \"SOSO\";\n        if(etype[i] == Happy){\n            res = \"HAPPY\";\n        }\n        else if(etype[i] == Sad){\n            res = \"SAD\";\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef vector< vector< edge > > Graph;\n\ntemplate< typename T = int >\nvector< T > Dijkstra(Graph &g, int s)\n{\n  typedef pair< T, int > Pi;\n  vector< T > min_cost(g.size(), numeric_limits< T >::max() / 3);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, s);\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > min_cost[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost >= min_cost[e.to]) continue;\n      min_cost[e.to] = p.first + e.cost;\n      que.emplace(min_cost[e.to], e.to);\n    }\n  }\n  return (min_cost);\n}\n\n\nint main()\n{\n  int N, M, A[100000], B[100000], C[100000];\n\n  scanf(\"%d %d\", &N, &M);\n  Graph g(N), rg(N), dag(N);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n    --A[i], --B[i];\n    g[A[i]].emplace_back((edge) {B[i], C[i]});\n    rg[B[i]].emplace_back((edge) {A[i], C[i]});\n  }\n  auto latte = Dijkstra< int64 >(g, 0);\n  auto malta = Dijkstra< int64 >(rg, 1);\n  vector< int > ans(M, -1);\n  for(int i = 0; i < M; i++) {\n    if(latte[A[i]] + malta[B[i]] + C[i] == latte[1]) {\n      dag[A[i]].emplace_back((edge) {B[i], i});\n    } else if(latte[B[i]] + malta[A[i]] + C[i] < latte[1]) {\n      ans[i] = 1;\n    } else {\n      ans[i] = 0;\n    }\n  }\n\n  vector< int > dp(N), order(N);\n  bool v[100000] = {};\n  function< void(int, int &) > dfs = [&](int idx, int &ord)\n  {\n    v[idx] = true;\n    dp[idx] = ord++;\n    order[idx] = dp[idx];\n    for(auto &e : dag[idx]) {\n      if(!v[e.to]) dfs(e.to, ord), dp[idx] = min(dp[idx], dp[e.to]);\n      else dp[idx] = min(dp[idx], order[e.to]);\n      if(dp[e.to] <= order[idx]) ans[e.cost] = 0;\n    }\n  };\n\n  int k = 0;\n  dfs(0, k);\n\n  for(int i = 0; i < M; i++) {\n    if(ans[i] == 0) puts(\"SOSO\");\n    else if(ans[i] == 1) puts(\"HAPPY\");\n    else puts(\"SAD\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define SZ 131072\n#define pli pair<long long,int>\nusing namespace std;\nint n, m, Route[101000], PP[101000], ord[101000];\nvector<int>E[101000], L[101000], Num[101000], T[101000];\npriority_queue<pli>PQ;\nstruct Edge {\n\tint a, b, c;\n}Ed[101000];\nint Path[101000], chk[101000];\nlong long D[101000], D2[101000];\nvoid Ins(int a, long long d, int pp) {\n\tif (D[a] <= d)return;\n\tD[a] = d;\n\tPath[a] = pp;\n\tPQ.push(pli{ -d,a });\n}\nvoid Dijk(int st) {\n\tint i, a;\n\tfor (i = 1; i <= n; i++)D[i] = 1e18, Path[i] = -1;\n\tIns(st, 0, 0);\n\twhile (!PQ.empty()) {\n\t\tpli tp = PQ.top();\n\t\tPQ.pop();\n\t\tif (D[tp.second] != -tp.first)continue;\n\t\ta = tp.second;\n\t\tfor (i = 0; i < E[a].size(); i++) {\n\t\t\tIns(E[a][i], D[a] + L[a][i], Num[a][i]);\n\t\t}\n\t}\n}\nvoid DFS(int a, int pp) {\n\tint i;\n\tif (Route[a])pp = a;\n\tPP[a] = pp;\n\tfor (i = 0; i < T[a].size(); i++) {\n\t\tDFS(T[a][i], pp);\n\t}\n}\nint cnt;\nlong long IT[SZ + SZ];\nvoid Put(int b, int e, long long x) {\n\tb += SZ, e += SZ;\n\twhile (b <= e) {\n\t\tIT[b] = min(IT[b], x);\n\t\tIT[e] = min(IT[e], x);\n\t\tb = (b + 1) >> 1, e = (e - 1) >> 1;\n\t}\n}\nvoid Add(int a, int b, int c) {\n\tif (D[a] > 5e17 || D2[b] > 5e17)return;\n\tif (!PP[a] || !PP[b])return;\n\tif (PP[a] > PP[b])Put(PP[b], PP[a] - 1, D[a] + D2[b] + c);\n}\nint main() {\n\tint i, a, b, c;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i < SZ + SZ; i++)IT[i] = 1e18;\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tE[b].push_back(a);\n\t\tL[b].push_back(c);\n\t\tNum[b].push_back(i);\n\t\tEd[i] = { a,b,c };\n\t}\n\tDijk(2);\n\tfor (i = 1; i <= n; i++)D2[i] = D[i], E[i].clear(),L[i].clear(), Num[i].clear();\n\tfor (i = 0; i < m; i++) {\n\t\ta = Ed[i].a, b = Ed[i].b, c = Ed[i].c;\n\t\tE[a].push_back(b);\n\t\tL[a].push_back(c);\n\t\tNum[a].push_back(i);\n\t}\n\tDijk(1);\n\ta = 2;\n\twhile (a != 1) {\n\t\tRoute[a] = ++cnt;\n\t\tchk[Path[a]] = 1;\n\t\tT[Ed[Path[a]].a].push_back(a);\n\t\ta = Ed[Path[a]].a;\n\t}\n\tRoute[a] = ++cnt;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (Path[i] != -1)T[Ed[Path[i]].a].push_back(i);\n\t}\n\tDFS(1, 1);\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i])continue;\n\t\tAdd(Ed[i].a, Ed[i].b, Ed[i].c);\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i]) {\n\t\t\tint t = SZ + min(Route[Ed[i].a], Route[Ed[i].b]);\n\t\t\tlong long rr = 1e18;\n\t\t\twhile (t) {\n\t\t\t\trr = min(rr, IT[t]);\n\t\t\t\tt >>= 1;\n\t\t\t}\n\t\t\tif (rr == D[2])printf(\"SOSO\\n\");\n\t\t\telse printf(\"SAD\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (D[Ed[i].b] + D2[Ed[i].a] + Ed[i].c < D[2])printf(\"HAPPY\\n\");\n\t\t\telse printf(\"SOSO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define DEBUG(a) (cout << #a << \": \" << a << endl)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1});\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    cnt[v] += (p != -1 ? cnt[p] : 1);\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] > d + c) q.push((state) { d + c, u, v });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && cnt1[u] * cnt2[v] == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nint inf2=1000000000ll*100000ll;\nint n,m;\nvector<pa>G[100030],G2[100030];\nvector<int> dag[100030],dag2[100030];\nint s1[100030],s2[100030],a[100030],b[100030],c[100030];\nint ans[100030]={0};\nbool sumi[100030]={0};\npriority_queue<pa,vector<pa>,greater<pa>> pq;\nint nyu[100030]={0},shu[100030]={0};\nint ok[100030]={0};\n\n\nvector<int> topo;\nint jisuu[100030]={0};\n\nint hashi[100030]={0};\nint dagk1[100030]={0},dagk2[100030]={0};\n\nvoid dagkosuu(int u){\n\tif(dagk1[u])return;\n\tint ans=0;\n\tfor(auto v:dag2[u])ans+=dagk1[v];\n\tdagk1[u]=ans;\n}\n\nvoid dagkosuu2(int u){\n\tif(dagk2[u])return;\n\tint ans=0;\n\tfor(auto v:dag[u])ans+=dagk2[v];\n\tdagk2[u]=ans;\n}\n\n\nvoid toporoji(){\n\t\n\tqueue<int> qu;\n\tqu.push(1);\n\t\n\tfor(int i=1;i<=n;i++)for(auto v:dag[i])jisuu[v]++;\n\t\n\twhile(qu.size()>0){\n\t\tint r=qu.front();\n\t\tqu.pop();\n\t\ttopo.pb(r);\n\t\t\n\t\tfor(auto v:dag[r]){\n\t\t\tjisuu[v]--;\n\t\t\tif(jisuu[v]==0) qu.push(v);\n\t\t}\n\t}\n \t\n}\n\nbool  check(int i){\n\treturn dagk1[a[i]]*dagk2[b[i]]==dagk1[2];\n\t\n}\n \n            signed main(){\n   cin>>n>>m;\n            \tfor(int i=0;i<m;i++){\n            \tint y,yy,yyy;\n            \t\tcin>>y>>yy>>yyy;\n            \t\tG[y].pb(mp(yy,yyy));\n            \t\tG2[yy].pb(mp(y,yyy));\n            \t\ta[i]=y;\n            \t\tb[i]=yy;\n            \t\tc[i]=yyy;\n            \t\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s1[i]=inf2;\n            \tpq.push(mp(0,1));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts1[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s2[i]=inf2;\n            \tpq.push(mp(0,2));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts2[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G2[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \t\n            \tint len=s1[2];\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\tif(s1[a[i]]+s2[b[i]]+c[i]==len){\n            \t\t\tdag[a[i]].pb(b[i]);\n            \t\t\tdag2[b[i]].pb(a[i]);\n            \t\t\t\n            \t//\t\tcout<<\"dag \"<<a[i]<<\" \"<<b[i]<<endl;\n            \t\t\n            \t\t}\n            \t\telse{\n            \t\t\tif(s1[b[i]]+s2[a[i]]+c[i]<len)ans[i]=1;\n            \t\t\telse ans[i]=3;\n            \t\t\t\n            \t\t\t\n            \t\t}\n            \t\t\n            \t}\n            //\tsaiki(1);\n            \ttoporoji();\n            \tdagk1[1]=1;\n            \tdagk2[2]=1;\n            \tfor(auto v:topo)dagkosuu(v);\n            \tfor(int j=topo.size()-1;j>=0;j--) dagkosuu2(topo[j]);\n            \t\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\t\n            \t\tif(ans[i])continue;\n            \t\tif(dag[a[i]].size()>1)ans[i]=3;\n            \t\telse if(dag2[b[i]].size()>1)ans[i]=3;\n            \t\telse if(!check(i))ans[i]=3;\n            \t\telse ans[i]=2;\n            \t}\n            \tfor(int i=0;i<m;i++){\n            \t\tif(ans[i]==1)cout<<\"HAPPY\"<<endl;\n            \t\tif(ans[i]==2)cout<<\"SAD\"<<endl;\n            \t\tif(ans[i]==3)cout<<\"SOSO\"<<endl;\n            \t}\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include <cassert>\n#include <functional>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(...) ;\n#else\n#define debug(...) cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \" << _tostr(__VA_ARGS__) << endl;\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n\nvoid _tostr_rec(ostringstream &oss) {\n  oss << \"\\b\\b \\b\";\n}\n\ntemplate<typename Head, typename... Tail>\nvoid _tostr_rec(ostringstream &oss, Head &&head, Tail &&... tail) {\n  oss << head << \", \";\n  _tostr_rec(oss, forward<Tail>(tail)...);\n}\n\ntemplate<typename... T>\nstring _tostr(T &&... args) {\n  ostringstream oss;\n  int size = sizeof...(args);\n  if (size > 1) oss << \"{\";\n  _tostr_rec(oss, forward<T>(args)...);\n  if (size > 1) oss << \"}\";\n  return oss.str();\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* Bridges & 2-edge-connected Components */\n\nstruct Bridges {\n  vector<pair<int, int>> edges;\n  vector<vector<pair<int, int>>> G;\n\n  vector<int> cmp, isBridge; //圧縮後に属するComponent番号, 橋であるか\n  vector<pair<int, int>> cmpEdges; //圧縮後のedge\n\n  int idx, cmpIdx;\n  vector<int> ord, inSt;\n  stack<int> roots, st;\n\n  Bridges(int N): G(N, vector<pair<int, int>>()), cmp(N), idx(0), cmpIdx(0), ord(N, -1), inSt(N, 0) {}\n\n  void add_edge(int u, int v) {\n    G[u].push_back({v, edges.size()});\n    G[v].push_back({u, edges.size()});\n    edges.push_back({u, v});\n    isBridge.push_back(false);\n  }\n\n  void dfs(int now, int eid = -1) {\n    ord[now] = idx++;\n    roots.push(now);\n    st.push(now);\n    inSt[now] = true;\n\n    for (auto e : G[now]) {\n      int to = e.first;\n      if (ord[to] == -1)\n        dfs(to, e.second);\n      else if (eid != e.second && inSt[to])\n        while (ord[roots.top()] > ord[to]) roots.pop();\n    }\n    if (now == roots.top()) {\n      while (1) {\n        int w = st.top();\n        st.pop();\n        inSt[w] = false;\n        cmp[w] = cmpIdx;\n        if (now == w) break;\n      }\n      if (eid != -1) isBridge[eid] = true;\n      roots.pop();\n      cmpIdx++;\n    }\n  }\n\n  void build() {\n    for (int i = 0; i < (int)ord.size(); i++)\n      if (ord[i] == -1)\n        dfs(i);\n\n    for (int i = 0; i < (int)edges.size(); i++) {\n      if (isBridge[i])\n        cmpEdges.push_back({cmp[edges[i].first], cmp[edges[i].second]});\n    }\n  }\n};\n\nint a[SIZE], b[SIZE], c[SIZE];\nvector<int> way[SIZE], rway[SIZE];\n\nint main() {\n  int n, m;\n\n  scanf(\"%d%d\", &n, &m);\n\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", a + i, b + i, c + i);\n    a[i]--;\n    b[i]--;\n\n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n\n  //Dijkstra\n  priority_queue<pair<ll, int>> pq;\n  bool visited[SIZE] = {}, rvisited[SIZE];\n  ll cost[SIZE], rcost[SIZE];\n\n  pq.push({0, 0});\n\n  while (pq.size()) {\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if (visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n\n    for (int i = 0; i < (int)way[now].size(); i++) {\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n\n  pq.push({0, 1});\n\n  while (pq.size()) {\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if (rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n\n    for (int i = 0; i < (int)rway[now].size(); i++) {\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n\n  vector<pair<int, int>> Graph;\n  Bridges bridges(n);\n  vector<int> pathID;\n  bool visited2[SIZE] = {};\n\n  pq.push({cost[1], 1});\n\n  while (pq.size()) {\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if (visited2[now]) continue;\n    visited2[now] = true;\n\n    for (int i = 0; i < (int)rway[now].size(); i++) {\n      int id = rway[now][i];\n      if (cur_cost - c[id] == cost[a[id]]) {\n        pq.push({cost[a[id]], a[id]});\n        bridges.add_edge(a[id], b[id]);\n        pathID.push_back(id);\n      }\n    }\n  }\n\n  bridges.build();\n\n  bool isBridge[SIZE] = {};\n\n  for (int i = 0; i < (int)pathID.size(); i++) {\n    int id = pathID[i];\n    isBridge[id] = bridges.isBridge[i];\n    debug(id, isBridge[id]);\n  }\n\n  for (int i = 0; i < m; i++) {\n    if (isBridge[i]) {\n      puts(\"SAD\");\n    } else if (visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]) {\n      puts(\"HAPPY\");\n    } else {\n      puts(\"SOSO\");\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <tuple>\nusing namespace std;\n\ntypedef long long LL;\nconst LL INF = (LL)1e16;\nconst int maxn = 100000 + 10;\nstruct Edge {\n    int u,v;\n    LL w;\n    Edge(int a,int b,LL c):u(a),v(b),w(c) {}\n    Edge() {}\n};\nvector<Edge> G[maxn],P[maxn],graph[maxn],Es;\nset<tuple<int,int,int> > s;\nmap<tuple<int,int,int>,int> cnt;\nLL d1[maxn],d2[maxn];\nbool visit[maxn];\nint n,m;\n\nvoid dij(int st,vector<Edge>* gra,LL* d) {\n    for(int i = 0; i < maxn; i++) d[i] = INF;\n    priority_queue<pair<LL,int>,vector<pair<LL,int> >,greater<pair<LL,int> > > q;\n    q.push(pair<LL,int>(0,st));\n    d[st] = 0;\n    while(!q.empty()) {\n        pair<LL,int> t = q.top();\n        q.pop();\n        int u = t.second;\n        if(d[u] < t.first) continue;\n        for(int i = 0; i < gra[u].size(); i++) {\n            Edge& es = gra[u][i];\n            if(d[es.v] > d[u] + es.w) {\n                d[es.v] = d[u] + es.w;\n                q.push(pair<LL,int>(d[es.v],es.v));\n            }\n        }\n    }\n}\n\nvoid dfs(int u,int fa) {\n    if(visit[u]) return;\n    visit[u] = 1;\n    for(int i = 0; i < P[u].size(); i++) {\n        Edge& es = P[u][i];\n        if(es.v != fa && d1[u] == d1[es.v] + es.w) {\n            graph[es.v].push_back(Edge(es.v,u,es.w));\n            graph[u].push_back(Edge(u,es.v,es.w));\n            dfs(es.v,u);\n        }\n    }\n}\n\nint pre[maxn];\nint iscut[maxn];\nint low[maxn];\nint dfs_clock;\n\nint  tarjan(int u,int fa) {\n    int lowu = pre[u] = ++dfs_clock;\n    int child = 0;\n    for(int i = 0; i < graph[u].size(); i++) {\n        int v = graph[u][i].v;\n        if(!pre[v]) {\n            child++;\n            int lowv = tarjan(v,u);\n            lowu = min(lowu,lowv);\n            if(lowv > pre[u]) {\n                s.insert(make_tuple(u,v,graph[u][i].w));\n            }\n        } else if(pre[v] < pre[u] && v != fa) {\n            lowu = min(lowu,pre[v]);\n        }\n    }\n    low[u] = lowu;\n    return lowu;\n}\n\nint main() {\n    scanf(\"%d %d\",&n,&m);\n    for(int i = 0; i < m; i++) {\n        int u,v;\n        LL w;\n        scanf(\"%d %d %lld\",&u,&v,&w);\n        Es.push_back(Edge(u,v,w));\n        cnt[make_tuple(u,v,w)]++;\n        G[u].push_back(Edge(u,v,w));\n        P[v].push_back(Edge(v,u,w));\n    }\n    dij(1,G,d1);\n    dij(2,P,d2);\n    memset(visit,0,sizeof(visit));\n    dfs(2,-1);\n    tarjan(1,-1);\n    for(int i = 0; i < m; i++) {\n        int u = Es[i].u,v = Es[i].v;\n        LL w = Es[i].w;\n        if(d1[v] + d2[u] + w < d1[2]) {\n            printf(\"HAPPY\\n\");\n        } else {\n            if(s.count(make_tuple(u,v,w)) && cnt[make_tuple(u,v,w)] == 1) {\n                printf(\"SAD\\n\");\n            } else {\n                printf(\"SOSO\\n\");\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nint inf2=1000000000ll*100000ll;\nint n,m;\nvector<pa>G[100030],G2[100030];\nvector<int> dag[100030],dag2[100030];\nint s1[100030],s2[100030],a[100030],b[100030],c[100030];\nint ans[100030]={0};\nbool sumi[100030]={0};\npriority_queue<pa,vector<pa>,greater<pa>> pq;\nint nyu[100030]={0},shu[100030]={0};\nint ok[100030]={0};\n\n\nvector<int> topo;\nint jisuu[100030]={0};\n\nint hashi[100030]={0};\nint dagk1[100030]={0},dagk2[100030]={0};\n\nvoid dagkosuu(int u){\n\tif(dagk1[u])return;\n\tint ans=0;\n\tfor(auto v:dag2[u])ans+=dagk1[v],ans%=inf;\n\tdagk1[u]=ans%inf;\n}\n\nvoid dagkosuu2(int u){\n\tif(dagk2[u])return;\n\tint ans=0;\n\tfor(auto v:dag[u])ans+=dagk2[v],ans%=inf;\n\tdagk2[u]=ans%inf;\n}\n\n\nvoid toporoji(){\n\t\n\tqueue<int> qu;\n\tqu.push(1);\n\t\n\tfor(int i=1;i<=n;i++)for(auto v:dag[i])jisuu[v]++;\n\t\n\twhile(qu.size()>0){\n\t\tint r=qu.front();\n\t\tqu.pop();\n\t\ttopo.pb(r);\n\t\t\n\t\tfor(auto v:dag[r]){\n\t\t\tjisuu[v]--;\n\t\t\tif(jisuu[v]==0) qu.push(v);\n\t\t}\n\t}\n \t\n}\n\nbool  check(int i){\n\treturn (dagk1[a[i]]*dagk2[b[i]])%inf==dagk1[2]%inf;\n\t\n}\n \n            signed main(){\n   cin>>n>>m;\n            \tfor(int i=0;i<m;i++){\n            \tint y,yy,yyy;\n            \t\tcin>>y>>yy>>yyy;\n            \t\tG[y].pb(mp(yy,yyy));\n            \t\tG2[yy].pb(mp(y,yyy));\n            \t\ta[i]=y;\n            \t\tb[i]=yy;\n            \t\tc[i]=yyy;\n            \t\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s1[i]=inf2;\n            \tpq.push(mp(0,1));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts1[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s2[i]=inf2;\n            \tpq.push(mp(0,2));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts2[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G2[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \t\n            \tint len=s1[2];\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\tif(s1[a[i]]+s2[b[i]]+c[i]==len){\n            \t\t\tdag[a[i]].pb(b[i]);\n            \t\t\tdag2[b[i]].pb(a[i]);\n            \t\t\t\n            \t//\t\tcout<<\"dag \"<<a[i]<<\" \"<<b[i]<<endl;\n            \t\t\n            \t\t}\n            \t\telse{\n            \t\t\tif(s1[b[i]]+s2[a[i]]+c[i]<len)ans[i]=1;\n            \t\t\telse ans[i]=3;\n            \t\t\t\n            \t\t\t\n            \t\t}\n            \t\t\n            \t}\n            //\tsaiki(1);\n            \ttoporoji();\n            \tdagk1[1]=1;\n            \tdagk2[2]=1;\n            \tfor(auto v:topo)dagkosuu(v);\n            \tfor(int j=topo.size()-1;j>=0;j--) dagkosuu2(topo[j]);\n            \t\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\t\n            \t\tif(ans[i])continue;\n            \t\tif(dag[a[i]].size()>1)ans[i]=3;\n            \t\telse if(dag2[b[i]].size()>1)ans[i]=3;\n            \t\telse if(!check(i))ans[i]=3;\n            \t\telse ans[i]=2;\n            \t}\n            \tfor(int i=0;i<m;i++){\n            \t\tif(ans[i]==1)cout<<\"HAPPY\"<<endl;\n            \t\tif(ans[i]==2)cout<<\"SAD\"<<endl;\n            \t\tif(ans[i]==3)cout<<\"SOSO\"<<endl;\n            \t}\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> pii;\ntypedef pair<ll,ll> pli;\nconst ll maxn=1e5+100;\nvector<pii>edge[2][maxn];\nbool inque[maxn];\nll dis[2][maxn];\null cnt[2][maxn];\nstruct node{\n    ll x,y,w;\n}p[maxn];\nvoid add(ll x,ll y,ll w,vector<pii> *edge){\n    edge[x].push_back({y,w});\n}\nll n,m;\nvoid dij(ll st,vector<pii> *edge,ll dis[],ull cnt[]){\n    priority_queue<pli,vector<pli>,greater<pli>>q;\n    memset(inque,0,sizeof(inque));\n    dis[st]=0;\n    q.push({0,st});\n    cnt[st]=1;\n    while(q.size()){\n        auto it=q.top();\n        q.pop();\n        ll u=it.second;\n        ll val=it.first;\n        if(inque[u])  continue;\n        inque[u]=1;\n        for(auto itt:edge[u]){\n            ll v=itt.first,w=itt.second;\n            if(inque[v]) continue;\n            if(dis[v]>val+w){\n                dis[v]=val+w;\n                cnt[v]=cnt[u];\n                q.push({val+w,v});\n            }\n            else if(dis[v]==val+w){\n                cnt[v]+=cnt[u];\n            }\n        }\n    }\n}\n\nll vis[maxn];\nint main(){\n    memset(dis,0x3f,sizeof(dis));\n    scanf(\"%lld%lld\",&n,&m);\n    for(ll i=1;i<=m;i++){\n        ll x,y,w;\n        scanf(\"%lld%lld%lld\",&x,&y,&w);\n        add(x,y,w,edge[0]);\n        add(y,x,w,edge[1]);\n        p[i]={x,y,w};\n    }\n    dij(1,edge[0],dis[0],cnt[0]);\n    dij(2,edge[1],dis[1],cnt[1]);\n    for(ll i=1;i<=n;i++) edge[0][i].clear(),edge[1][i].clear();\n    for(ll i=1;i<=m;i++){\n        ll x=p[i].x,y=p[i].y,w=p[i].w;\n        if(dis[0][y]+dis[1][x]+w<dis[0][2]){\n            printf(\"HAPPY\\n\");\n        }\n        else if(dis[0][y]+dis[1][x]+w==dis[0][2]){\n            printf(\"SOSO\\n\");\n        }\n        else{\n            if(dis[0][x]+dis[1][y]+w==dis[0][2]){\n                if(cnt[0][x]*cnt[1][y]==cnt[0][2]) printf(\"SAD\\n\");\n                else printf(\"SOSO\\n\");\n            }\n            else{\n                printf(\"SOSO\\n\");\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100000;\nconst int maxm = 100000;\n\nclass Node\n{\npublic:\n\tint u;\n\tlong long d;\n\n\tNode(void);\n\tNode(const int &, const long long &);\n\n\tbool operator < (const Node &) const;\n};\n\nclass Edge\n{\npublic:\n\tint u;\n\tint v;\n\tint w;\n\n\tEdge(void);\n\tEdge(const int &, const int &, const int &);\n};\n\nNode::Node(void) : u(0), d(0)\n{\n\n}\n\nNode::Node(const int & u, const long long & d) : u(u), d(d)\n{\n\n}\n\nbool Node::operator < (const Node & rhs) const\n{\n\treturn d > rhs.d;\n}\n\nEdge::Edge(void) : u(0), v(0), w(0)\n{\n\n}\n\nEdge::Edge(const int & u, const int & v, const int & w) : u(u), v(v), w(w)\n{\n\n}\n\nint n, m;\nvector<Edge> E;\nvector<int> Eid[maxn];\nvector<Edge> Et;\nvector<int> Etid[maxn];\nlong long d[maxn];\nlong long deg[maxn];\nlong long dt[maxn];\nlong long degt[maxn];\n\nvoid dijkstra(const int & s, vector<Edge> & E, vector<int> Eid[], long long d[], long long deg[])\n{\n\tNode cur, tgt;\n\tpriority_queue<Node> que;\n\n\tmemset(d, 0x3f, sizeof(d[0]) * n);\n\tmemset(deg, 0, sizeof(deg[0]) * n);\n\td[s] = 0;\n\tdeg[s] = 1;\n\tfor (que.push(Node(s, 0)); !que.empty(); )\n\t{\n\t\tcur = que.top();\n\t\tque.pop();\n\n\t\tif (d[cur.u] < cur.d)\n\t\t\tcontinue;\n\n\t\tint u = cur.u, v, w;\n\t\tfor (int i = 0; i < Eid[u].size(); ++ i)\n\t\t{\n\t\t\tv = E[Eid[u][i]].v;\n\t\t\tw = E[Eid[u][i]].w;\n\t\t\tif (d[v] > d[u] + w)\n\t\t\t{\n\t\t\t\td[v] = d[u] + w;\n\t\t\t\tdeg[v] = deg[u];\n\t\t\t\tque.push(Node(v, d[v]));\n\t\t\t}\n\t\t\telse if (d[v] == d[u] + w)\n\t\t\t\tdeg[v] += deg[u];\n\t\t}\n\t}\n}\n\ninline int check_edge(const int & idx)\n{\n\tif (d[E[idx].v] + E[idx].w + dt[E[idx].u] < d[1])\n\t\treturn -1;\n\telse if (d[E[idx].u] + E[idx].w + dt[E[idx].v] == d[1] && deg[E[idx].u] * degt[E[idx].v] == deg[1])\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++ i)\n\t{\n\t\tint u, v, w;\n\n\t\tcin >> u >> v >> w;\n\t\t-- u;\n\t\t-- v;\n\t\tE.push_back(Edge(u, v, w));\n\t\tEid[u].push_back(i);\n\t\tEt.push_back(Edge(v, u, w));\n\t\tEtid[v].push_back(i);\n\t}\n\n\tdijkstra(0, E, Eid, d, deg);\n\tdijkstra(1, Et, Etid, dt, degt);\n\n\tint ans;\n\tfor (int k = 0; k < m; ++ k)\n\t{\n\t\tans = check_edge(k);\n\n\t\tif (ans == -1)\n\t\t\tcout << \"HAPPY\";\n\t\telse if (ans == 0)\n\t\t\tcout << \"SOSO\";\n\t\telse\n\t\t\tcout << \"SAD\";\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    typedef long long ll;\n    const ll INF = 1LL << 56;\n    int N, M;\n\n    struct Edge {\n        int from, to; ll cost;\n        Edge(int from, int to, ll cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            if (from == e.from) {\n                return to == e.to ? cost < e.cost : to < e.to;\n            } else {\n                return from < e.from;\n            }\n        }\n        bool operator==(const Edge& e) {\n            return to == e.to and from == e.from and cost == e.cost;\n        }\n    };\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \",\" << e.to << \",\" << e.cost << \")\";\n    }\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    vector<vector<Edge>> G, RG;\n    vector<Edge> es;\n    map<Edge, int> X;\n\n    vector<pair<int, int>> findBridges(const vector<vector<Edge>>& G) {\n        int V = N;\n        vector<int> dfs_order(V, -1);\n        vector<int> lowlink(V, 0);\n        int c = 0;\n        vector<pair<int, int>> bridges;\n        function<void(int, int)> dfs = [&](int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            for (auto& e : G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) {\n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges.emplace_back(l, g);\n                }\n            }\n        };\n        dfs(0, -1);\n        return bridges;\n    }\n\n    void input() {\n        cin >> N >> M;\n        G.resize(N);\n        RG.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b; ll c;\n            cin >> a >> b >> c;\n            a--; b--;\n            Edge e(a, b, c);\n            if (X.count(e)) {\n                X[e]++;\n            } else {\n                G[a].emplace_back(a, b, c);\n                RG[b].emplace_back(b, a, c);\n                X[e] = 1;\n            }\n            es.emplace_back(a, b, c);\n        }\n    }\n\n    struct S {\n        int v; ll cost;\n        S(int v, ll cost) : v(v), cost(cost) {}\n        bool operator<(const S& s) const {\n            return cost > s.cost;\n        }\n    };\n\n    void dijkstra(const vector<vector<Edge>>& G, int start, vector<ll>& D, vector<vector<Edge>>& prev) {\n        priority_queue<S> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : G[cur.v]) {\n                auto next = e.to;\n                auto ncost = D[cur.v] + e.cost;\n                if (D[next] > ncost) {\n                    prev[next].clear();\n                    prev[next].push_back(e);\n                    D[next] = ncost;\n                    PQ.emplace(next, ncost);\n                } else if (D[next] == ncost) {\n                    prev[next].push_back(e);\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<ll> D(N, INF);\n        vector<ll> RD(N, INF);\n        vector<vector<Edge>> prev(N, vector<Edge>());\n        vector<vector<Edge>> rprev(N, vector<Edge>());\n        dijkstra(G, 0, D, prev);\n        dijkstra(RG, 1, RD, rprev);\n\n        vector<vector<Edge>> shortest_paths(N, vector<Edge>());\n        function<void(int)> dfs = [&](int v) {\n            if (prev[v].empty()) {\n                assert(v == 0);\n                return;\n            }\n            for (auto e : prev[v]) {\n                shortest_paths[e.from].push_back(e);\n                dfs(e.from);\n            }\n        };\n        dfs(1);\n        //cout << shortest_paths << endl;\n\n        auto _bridges = findBridges(shortest_paths);\n        //cout << _bridges << endl;\n        set<pair<int, int>> bridges;\n        for (auto b : _bridges) { bridges.insert(b); }\n\n        for (int i = 0; i < M; i++) {\n            auto e = es[i];\n            if (D[e.from] + e.cost + RD[e.to] == D[1]) {\n                if (\n                    (bridges.count(make_pair(e.from, e.to)) \n                     or bridges.count(make_pair(e.to, e.from)))\n                     and X[e] <= 1) {\n                    cout << \"SAD\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            } else {\n                auto ncost = D[e.to] + e.cost + RD[e.from];\n                if (ncost < D[1]) {\n                    cout << \"HAPPY\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n \nconstexpr ll inf = ll(1e18) + 9;\n \nvector<ll> dijkstra(vector<vector<pair<int, ll> > > const & g, int root) {\n    vector<ll> dist(g.size(), inf);\n    priority_queue<pair<ll, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        ll dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; ll cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n \npair<int, vector<int> > decompose_to_two_edge_connected_components(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> imos(n); { // imos[i] == 0  iff  the edge i -> parent is a bridge\n        vector<char> used(n); // 0: unused ; 1: exists on stack ; 2: removed from stack\n        function<void (int, int)> go = [&](int i, int parent) {\n            used[i] = 1;\n            for (int j : g[i]) if (j != parent) {\n                if (used[j] == 0) {\n                    go(j, i);\n                    imos[i] += imos[j];\n                } else if (used[j] == 1) {\n                    imos[i] += 1;\n                    imos[j] -= 1;\n                }\n            }\n            used[i] = 2;\n        };\n        REP (i, n) if (used[i] == 0) {\n            go(i, -1);\n        }\n    }\n    int size = 0;\n    vector<int> component_of(n, -1); {\n        function<void (int)> go = [&](int i) {\n            for (int j : g[i]) if (component_of[j] == -1) {\n                component_of[j] = imos[j] == 0 ? size ++ : component_of[i];\n                go(j);\n            }\n        };\n        REP (i, n) if (component_of[i] == -1) {\n            component_of[i] = size ++;\n            go(i);\n        }\n    }\n    return { size, move(component_of) };\n}\n \nenum result_t { HAPPY, SOSO, SAD };\nconstexpr int start = 0;\nconstexpr int goal = 1;\nint main() {\n    // input\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<tuple<int, int, int> > edges(m);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        edges[i] = make_tuple(a, b, c);\n    }\n    // solve\n    vector<vector<pair<int, ll >> > g(n);\n    vector<vector<pair<int, ll >> > rev_g(n);\n    map<tuple<int, int, int>, int> count_edges;\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        g[a].emplace_back(b, c);\n        rev_g[b].emplace_back(a, c);\n        count_edges[edge] += 1;\n    }\n    auto dist = dijkstra(g, start);\n    auto rev_dist = dijkstra(rev_g, goal);\n    vector<vector<int> > h(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            if (dist[i] + cost + rev_dist[j] == dist[goal]) {\n                h[i].push_back(j);\n                h[j].push_back(i);\n            }\n        }\n    }\n    auto component_of = decompose_to_two_edge_connected_components(h).second;\n    // output\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        result_t result =\n            dist[b] + c + rev_dist[a] <  dist[goal] ? HAPPY :\n            dist[b] + c + rev_dist[a] == dist[goal] ? SOSO :\n            dist[a] + c + rev_dist[b] != dist[goal] ? SOSO :\n            count_edges[edge] >= 2 ? SOSO :\n            component_of[a] != component_of[b] ? SAD :\n            SOSO;\n        printf(\"%s\\n\",\n            result == HAPPY ? \"HAPPY\" :\n            result == SOSO ? \"SOSO\" :\n            result == SAD ? \"SAD\" :\n            \"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nint min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n\nconst ll INF = 1e15;\n\nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n\tdist[f->dst] = e.weight + f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\tprev[f->dst].clear();\n\tprev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n\tprev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n\npair<Graph, Graph> buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  Graph g2(n);\n  stack<int> st;\n  st.push(t);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    for(auto&& p : prev[now]){\n      if(p < 0)\n\tcontinue;\n      g[p].push_back(Edge(p, now, 1));\n      g2[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return pair<Graph, Graph>(g, g2);\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w*2, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w*2 == befo.first)\n\tmp[P(s, d)] = P(w*2-1, befo.second + 1);\n      else\n\tmp[P(s, d)] = P(min(w*2, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree, tree2;\n  tie(tree, tree2) = buildPath(prev, 1);\n  for(int i=0;i<tree2.size();i++){\n    sort(tree2[i].begin(), tree2[i].end());\n  }\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n\n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n\n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n    \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w*2)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    ok |= binary_search(tree2[s].begin(), tree2[s].end(), Edge(s, d, 1));\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}\n/*\n11 15\n1 3 1\n3 6 2\n6 10 1\n1 5 3\n3 7 1\n5 9 1\n9 11 1\n7 8 1\n1 4 2\n4 8 1\n8 10 1\n10 11 1\n11 2 1\n10 7 1\n10 1 1\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\nconstexpr ll inf = ll(1e18) + 9;\n\nvector<ll> dijkstra(vector<vector<pair<int, ll> > > const & g, int root) {\n    vector<ll> dist(g.size(), inf);\n    priority_queue<pair<ll, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        ll dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; ll cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n\npair<int, vector<int> > decompose_to_two_edge_connected_components(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> imos(n); { // imos[i] == 0  iff  the edge i -> parent is a bridge\n        vector<char> used(n); // 0: unused ; 1: exists on stack ; 2: removed from stack\n        function<void (int, int)> go = [&](int i, int parent) {\n            used[i] = 1;\n            for (int j : g[i]) if (j != parent) {\n                if (used[j] == 0) {\n                    go(j, i);\n                    imos[i] += imos[j];\n                } else if (used[j] == 1) {\n                    imos[i] += 1;\n                    imos[j] -= 1;\n                }\n            }\n            used[i] = 2;\n        };\n        REP (i, n) if (used[i] == 0) {\n            go(i, -1);\n        }\n    }\n    int size = 0;\n    vector<int> component_of(n, -1); {\n        function<void (int)> go = [&](int i) {\n            for (int j : g[i]) if (component_of[j] == -1) {\n                component_of[j] = imos[j] == 0 ? size ++ : component_of[i];\n                go(j);\n            }\n        };\n        REP (i, n) if (component_of[i] == -1) {\n            component_of[i] = size ++;\n            go(i);\n        }\n    }\n    return { size, move(component_of) };\n}\n\nenum result_t { HAPPY, SOSO, SAD };\nconstexpr int start = 0;\nconstexpr int goal = 1;\nint main() {\n    // input\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<tuple<int, int, int> > edges(m);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        edges[i] = make_tuple(a, b, c);\n    }\n    // solve\n    vector<vector<pair<int, ll >> > g(n);\n    vector<vector<pair<int, ll >> > rev_g(n);\n    map<tuple<int, int, int>, int> count_edges;\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        g[a].emplace_back(b, c);\n        rev_g[b].emplace_back(a, c);\n        count_edges[edge] += 1;\n    }\n    auto dist = dijkstra(g, start);\n    auto rev_dist = dijkstra(rev_g, goal);\n    vector<vector<int> > h(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            if (dist[i] + cost == dist[j] and dist[j] <= dist[goal]) {\n                h[i].push_back(j);\n                h[j].push_back(i);\n            }\n        }\n    }\n    auto component_of = decompose_to_two_edge_connected_components(h).second;\n    // output\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        result_t result =\n            count_edges[edge] >= 2 ? SOSO :\n            dist[a] == inf or rev_dist[b] == inf ? SOSO :\n            dist[b] + c + rev_dist[a] <  dist[goal] ? HAPPY :\n            dist[b] + c + rev_dist[a] == dist[goal] ? SOSO :\n            dist[a] + c + rev_dist[b] != dist[goal] ? SOSO :\n            component_of[a] != component_of[b] ? SAD :\n            SOSO;\n        printf(\"%s\\n\",\n            result == HAPPY ? \"HAPPY\" :\n            result == SOSO ? \"SOSO\" :\n            result == SAD ? \"SAD\" :\n            \"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    cnt[v] += (p != -1 ? cnt[p] : 1);\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, v });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd && dist1[u] + cost + dist2[v] > orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && cnt1[u] * cnt2[v] == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge{\n\tedge(){}\n\tedge(ll from, ll to, ll cost, ll id) :from(from), to(to), cost(cost), id(id){}\n\tll from, to, cost, id;\n};\n\nedge es[100000];\nusing Graph = vector<vector<edge>>;\n\nint N, M;\n\nconst ll INF = 1LL << 55;\n\nvoid dijkstra(int s, const Graph& g, vector<ll>& dist){\n\tusing P = pair<ll, int>;\n\tdist = vector<ll>(N, INF);\n\tdist[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push({ 0, s });\n\twhile(q.size()){\n\t\tll d = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tfor(auto e : g[v]){\n\t\t\tif(dist[e.to] > d + e.cost){\n\t\t\t\tdist[e.to] = d + e.cost;\n\t\t\t\tq.push({ d + e.cost, e.to });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint use[100000];\nint bri[100000];\n\nusing Pii = pair<int, int>;\n\nstd::pair<std::vector<int>, vector<Pii>> bridge(const Graph& g){\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tstd::vector<int> ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tvector<Pii> brdg;\n\tstd::function<void(int, int)> dfs = [&](int v, int u){\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor(auto& e : g[v]){\n\t\t\tint w = e.to;\n\t\t\tif(ord[w] == -1)\n\t\t\t\tdfs(w, v);\n\t\t\telse if(u != w && onS[w])\n\t\t\t\twhile(ord[roots[t - 1]] > ord[w]) --t;\n\t\t}\n\t\tif(v == roots[t - 1]){\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile(1){\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif(v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor(int u = 0; u < n; u++){\n\t\tif(ord[u] == -1){\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn std::make_pair(cmp, brdg);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> N >> M;\n\n\tGraph G(N), Gr(N);\n\tfor(int i = 0; i < M; i++){\n\t\tll u, v, cost;\n\t\tcin >> u >> v >> cost;\n\t\tu--, v--;\n\t\tes[i] = edge(u, v, cost, i);\n\t\tG[u].push_back(edge(u, v, cost, i));\n\t\tGr[v].push_back(edge(v, u, cost, i));\n\t}\n\n\tvector<ll> d(N), dr(N);\n\tdijkstra(0, G, d);\n\tdijkstra(1, Gr, dr);\n\n\tll dist = d[1];\n\tGraph G2(N);\n\tmap<Pii, int> idmap;\n\tfor(int i = 0; i < M; i++){\n\t\tedge e = es[i];\n\t\tll dd = d[e.from] + e.cost + dr[e.to];\n\t\tif(dist == dd){\n\t\t\tuse[i] = 1;\n\t\t\tfor(int loop = 0; loop < 2; loop++){\n\t\t\t\tG2[e.from].push_back(e);\n\t\t\t\tswap(e.from, e.to);\n\t\t\t\tidmap[{e.from, e.to}] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tauto res = bridge(G2);\n\tfor(auto p : res.second){\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tif(idmap.count(p)){\n\t\t\t\tbri[idmap[p]] = 1;\n\t\t\t}\n\t\t\tswap(p.first, p.second);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(!use[i]){\n\t\t\tedge e = es[i];\n\t\t\tll dd = d[e.to] + e.cost + dr[e.from];\n\t\t\tif(dist > dd){\n\t\t\t\tcout << \"HAPPY\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"SOSO\" << endl;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(bri[i]){\n\t\t\t\tcout << \"SAD\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"SOSO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//construct DAG by dijkstra and then create dominator tree\n#define uu second\ntypedef long long ll;\nconst ll maxN = 100007;\nconst ll inf=1e15;\nstruct DominatorTree {\n    ll par[maxN][25], level[maxN],dis[maxN];\n    ll dis2[maxN];\n    vector<ll>adj[maxN],cost[maxN],mama[maxN] ;\n    vector<ll>adj2[maxN],cost2[maxN] ;\n    vector<pair<ll,ll> >nodes ;\n    void addEdge(int u,int v,int w){\n        adj[u].push_back(v);\n        adj2[v].push_back(u);\n        cost[u].push_back(w);\n        cost2[v].push_back(w);\n    }\n\n    ll lca(ll u,ll v) {\n        if(level[u]< level[v])swap(u,v);\n        ll tmp=1;\n        for(; (1<<tmp)<=level[u]; ++tmp);\n        --tmp;\n        for(ll i=tmp; i>=0; --i) {\n            if(level[u]-(1<<i)>=level[v])u=par[u][i];\n        }\n        if(u==v)return u ;\n        for(ll i = tmp ; i >= 0 ; --i) if(par[u][i]!=par[v][i])u=par[u][i],v=par[v][i] ;\n        return par[u][0];\n    }\n    void dijkstra( ll n, ll src ) {\n        priority_queue< pair < ll, ll > > pq ;\n        pq.push( make_pair( 0, src ) ) ;\n        for( ll i = 0 ; i <= n ; i++ ) dis[i] = inf ;\n        dis[src] = 0LL ;\n        while( !pq.empty() ) {\n            pair<ll,ll>node = pq.top() ;\n            pq.pop();\n            for( ll i  = 0 ; i < adj[node.uu].size() ; i++  ) {\n                ll v = adj[node.uu][i] ;\n                ll w = cost[node.uu][i] ;\n                if(dis[node.uu]+w<dis[v]) {\n                    dis[v]=dis[node.uu]+w;\n                    pq.push(make_pair(-dis[v], v) );\n                }\n            }\n        }\n        //for( ll i = 0 ; i <= n ; i++ )cout <<i << \" - \"<< dis[i] << endl;\n        //for( ll i = 0 ; i <= n ; i++ )cout <<i << \" \"<< dis[i] << endl;\n    }\n    void dijkstra2( ll n, ll src ) {\n        priority_queue< pair < ll, ll > > pq ;\n        pq.push( make_pair( 0, src ) ) ;\n        for( ll i = 0 ; i <= n ; i++ ) dis2[i] = inf ;\n        dis2[src] = 0LL ;\n        while( !pq.empty() ) {\n            pair<ll,ll>node = pq.top() ;\n            pq.pop();\n            for( ll i  = 0 ; i < adj2[node.uu].size() ; i++  ) {\n                ll v = adj2[node.uu][i] ;\n                ll w = cost2[node.uu][i] ;\n                if(dis2[node.uu]+w<dis2[v]) {\n                    dis2[v]=dis2[node.uu]+w;\n                    pq.push(make_pair(-dis2[v], v) );\n                }\n            }\n        }\n    }\n    void constructDag(ll n, ll src) {\n        for(ll i =1 ; i <=n; i++)\n            nodes.push_back(make_pair(dis[i],i));\n        sort(nodes.begin(),nodes.end());\n        for(ll i = 0 ; i < n ; i++) {\n            ll u = nodes[i].uu;\n            for(ll j=0; j < adj[u].size() ; j++ ) {\n                ll v = adj[u][j];\n                ll w = cost[u][j];\n                if(dis[u]+w==dis[v])mama[v].push_back(u);//,cout << u << \" -> \" << v << endl;\n            }\n        }\n    }\n    void dominatorTree(ll n,map<pair<ll,ll>,ll>& koyta) {\n        dijkstra(n,1);\n        dijkstra2(n,2);\n        ll src=1;\n        constructDag(n,src);\n        for(ll i = 0; i<20; i++)par[1][i]=1;\n        level[1]=1;\n        n=nodes.size();\n        for(ll i =1; i < n ; i++) {\n            ll u = nodes[i].second ;\n            if(mama[u].size()==0) {\n                continue;\n            }\n            ll sz = mama[u].size();\n            ll jaime = mama[u][0] ;\n            ll cur = 1 ;\n            while(cur < sz ) {\n                jaime = lca( jaime, mama[u][cur]) ;\n                cur++;\n            }\n            par[u][0]=jaime;\n            if(sz>1)koyta[{jaime,u}]++;\n            level[u]=1+level[jaime];\n            for( ll i = 1 ; i <20 ; i++ )par[u][i] = par[par[u][i-1]][i-1] ;\n        }\n    }\n};\nll n, m;\nll x[maxN],y[maxN],z[maxN];\nDominatorTree dtree;\nll ans[maxN];\nmap<pair<ll,ll>,ll>id;\nmap<pair<ll,ll>,ll>koyta;\nmap<pair<ll,ll>,ll>mn;\n\nvoid go(ll u){\n    if(u==0)return ;\n    if(u==1)return ;\n    ll p = dtree.par[u][0];\n    if(koyta[{p,u}]==1){\n        ans[id[{p,u}]]=1;\n    }\n    go(p);\n}\nint main(){\n    cin>>n>>m;\n    for(ll i=0;i<m;i++){\n        scanf(\"%lld %lld %lld\",&x[i],&y[i],&z[i]);\n        dtree.addEdge(x[i],y[i],z[i]);\n        if(id.find({x[i],y[i]})==id.end()){\n            id[{x[i],y[i]}]=i;\n            koyta[{x[i],y[i]}]=1;\n            mn[{x[i],y[i]}]=z[i];\n        }\n        else if(mn[{x[i],y[i]}]==z[i]){\n           koyta[{x[i],y[i]}]++;\n           id[{x[i],y[i]}]=i;\n        }\n        else if(mn[{x[i],y[i]}]<z[i]){}\n        else{\n            id[{x[i],y[i]}]=i;\n            koyta[{x[i],y[i]}]=1;\n            mn[{x[i],y[i]}]=z[i];\n        }\n    }\n    dtree.dominatorTree(n,koyta);\n    go(2);\n    for(int i=0;i<m;i++){\n        if(dtree.dis[2]>dtree.dis[y[i]]+dtree.dis2[x[i]]+z[i])\n            ans[i]=-1;\n        if(ans[i]==-1)printf(\"HAPPY\\n\");\n        else if(ans[i]==1)printf(\"SAD\\n\");\n        else printf(\"SOSO\\n\");\n    }\n\n\nreturn 0;\n}\n/*\n\n10 90\n5 8 5\n10 5 6\n9 6 9\n1 10 9\n9 10 3\n1 7 4\n6 5 7\n7 6 3\n8 4 3\n9 1 6\n7 1 7\n6 10 3\n2 7 9\n3 7 1\n5 6 1\n3 2 6\n2 10 8\n6 1 6\n3 6 8\n8 10 9\n10 9 5\n2 6 1\n10 3 1\n5 2 10\n7 2 3\n2 9 4\n10 1 1\n2 1 9\n3 5 7\n2 4 3\n6 8 4\n4 10 4\n10 2 3\n8 5 10\n2 5 8\n9 7 4\n3 1 4\n10 4 4\n9 4 6\n2 3 3\n10 7 7\n8 6 6\n3 9 4\n4 7 2\n1 4 10\n6 4 5\n1 3 3\n10 8 7\n5 7 10\n7 3 8\n8 9 1\n6 2 5\n4 8 4\n1 6 4\n7 4 1\n1 5 10\n7 5 9\n7 10 6\n1 9 8\n3 8 2\n6 3 5\n4 5 1\n4 6 9\n8 3 2\n7 8 4\n9 5 5\n1 8 10\n8 7 7\n3 10 5\n4 2 8\n7 9 5\n5 4 5\n4 1 10\n5 10 1\n8 1 6\n5 9 5\n3 4 3\n6 7 9\n5 3 6\n10 6 7\n4 3 4\n9 3 6\n9 2 5\n8 2 5\n9 8 1\n6 9 5\n5 1 4\n2 8 8\n1 2 8\n4 9 3\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    typedef long long ll;\n    const ll INF = 1LL << 56;\n    int N, M;\n\n    struct Edge {\n        int from, to; ll cost;\n        Edge(int from, int to, ll cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            if (from == e.from) {\n                return to == e.to ? cost < e.cost : to < e.to;\n            } else {\n                return from < e.from;\n            }\n        }\n        bool operator==(const Edge& e) {\n            return to == e.to and from == e.from and cost == e.cost;\n        }\n    };\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \",\" << e.to << \",\" << e.cost << \")\";\n    }\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    vector<vector<Edge>> G, RG;\n    vector<Edge> es;\n    map<Edge, int> X;\n\n    vector<pair<int, int>> findBridges(const vector<vector<Edge>>& G) {\n        int V = N;\n        vector<int> dfs_order(V, -1);\n        vector<int> lowlink(V, 0);\n        int c = 0;\n        vector<pair<int, int>> bridges;\n        function<void(int, int)> dfs = [&](int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            for (auto& e : G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) {\n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges.emplace_back(l, g);\n                }\n            }\n        };\n        dfs(0, -1);\n        return bridges;\n    }\n\n    void input() {\n        cin >> N >> M;\n        G.resize(N);\n        RG.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b; ll c;\n            cin >> a >> b >> c;\n            a--; b--;\n            Edge e(a, b, c);\n            if (X.count(e)) {\n                X[e]++;\n            } else {\n                G[a].emplace_back(a, b, c);\n                RG[b].emplace_back(b, a, c);\n                X[e] = 1;\n            }\n            es.emplace_back(a, b, c);\n        }\n    }\n\n    struct S {\n        int v; ll cost;\n        S(int v, ll cost) : v(v), cost(cost) {}\n        bool operator<(const S& s) const {\n            return cost > s.cost;\n        }\n    };\n\n    void dijkstra(const vector<vector<Edge>>& G, int start, vector<ll>& D, vector<vector<Edge>>& prev) {\n        priority_queue<S> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : G[cur.v]) {\n                auto next = e.to;\n                auto ncost = D[cur.v] + e.cost;\n                if (D[next] > ncost) {\n                    prev[next].clear();\n                    prev[next].push_back(e);\n                    D[next] = ncost;\n                    PQ.emplace(next, ncost);\n                } else if (D[next] == ncost) {\n                    prev[next].push_back(e);\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<ll> D(N, INF);\n        vector<ll> RD(N, INF);\n        vector<vector<Edge>> prev(N, vector<Edge>());\n        vector<vector<Edge>> rprev(N, vector<Edge>());\n        dijkstra(G, 0, D, prev);\n        dijkstra(RG, 1, RD, rprev);\n\n        vector<vector<Edge>> shortest_paths(N, vector<Edge>());\n        function<void(int)> dfs = [&](int v) {\n            if (prev[v].empty()) {\n                assert(v == 0);\n                return;\n            }\n            for (auto e : prev[v]) {\n                shortest_paths[e.from].push_back(e);\n                shortest_paths[e.to].emplace_back(e.to, e.from, -1);\n                dfs(e.from);\n            }\n        };\n        dfs(1);\n        //cout << shortest_paths << endl;\n\n        auto _bridges = findBridges(shortest_paths);\n        //cout << _bridges << endl;\n        set<pair<int, int>> bridges;\n        for (auto b : _bridges) { bridges.insert(b); }\n\n        for (int i = 0; i < M; i++) {\n            auto e = es[i];\n            if (D[e.from] + e.cost + RD[e.to] == D[1]) {\n                if (\n                    (bridges.count(make_pair(e.from, e.to)) \n                     or bridges.count(make_pair(e.to, e.from)))\n                     and X[e] <= 1) {\n                    cout << \"SAD\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            } else {\n                auto ncost = D[e.to] + e.cost + RD[e.from];\n                if (ncost < D[1]) {\n                    cout << \"HAPPY\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mem(t, v)   memset ((t) , v, sizeof(t))\n#define all(x)      x.begin(),x.end()\n#define un(x)       x.erase(unique(all(x)), x.end())\n#define sf(n)       scanf(\"%d\", &n)\n#define sff(a,b)    scanf(\"%d %d\", &a, &b)\n#define sfff(a,b,c) scanf(\"%d %d %d\", &a, &b, &c)\n#define sl(n)       scanf(\"%lld\", &n)\n#define sll(a,b)    scanf(\"%lld %lld\", &a, &b)\n#define slll(a,b,c) scanf(\"%lld %lld %lld\", &a, &b, &c)\n#define D(x)        cerr << #x \" = \" << (x) << '\\n'\n#define DD(x,y) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << endl\n#define DDD(x,y,z) cout << #x << \" = \" << x << \"   \" << #y << \" = \" << y << \"   \" << #z << \" = \" << z << endl\n#define DBG         cerr << \"Hi\" << '\\n'\n#define pb          push_back\n#define PI          acos(-1.00)\n#define xx          first\n#define yy          second\n#define eps         1e-9\n\ntypedef unsigned long long int ULL;\ntypedef long long int LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\n\ninline int setBit(int N, int pos) { return N=N | (1<<pos); }\ninline int resetBit(int N, int pos) { return N= N & ~(1<<pos); }\ninline bool checkBit(int N, int pos) { return (bool)(N & (1<<pos)); }\n\n//int fx[] = {+0, +0, +1, -1, -1, +1, -1, +1};\n//int fy[] = {-1, +1, +0, +0, +1, +1, -1, -1}; //Four & Eight Direction\n\n#define MAX     100000\nnamespace dom{\nvector<int>g[MAX+5], tree[MAX+5], rg[MAX+5], bucket[MAX+5];\nint sdom[MAX+5], par[MAX+5], dom[MAX+5], dsu[MAX+5], label[MAX+5];\nint arr[MAX+5], rev[MAX+5], T, n, source;\nconst int dest = 2;\nvoid init(int _n, int _source)\n{\n    T = 0;\n    n = _n;\n    source = _source;\n    for(int i = 1; i<=n; i++)\n    {\n        g[i].clear(), rg[i].clear(), tree[i].clear(), bucket[i].clear();\n        arr[i] = sdom[i] = par[i] = dom[i] = dsu[i] = label[i] = rev[i] = 0;\n    }\n}\nvoid dfs(int u)\n{\n    T++;\n    arr[u] = T;\n    rev[T] = u;\n    label[T] = T;\n    sdom[T] = T;\n    dsu[T] = T;\n    for(int i = 0; i<g[u].size(); i++)\n    {\n        int w = g[u][i];\n        if(!arr[w])\n        {\n            dfs(w);\n            par[arr[w]] = arr[u];\n        }\n        rg[arr[w]].push_back(arr[u]);\n    }\n}\n\nint Find(int u, int x = 0)\n{\n    if(u == dsu[u]) return x ? -1:u;\n    int v = Find(dsu[u], x+1);\n    if(v < 0) return u;\n    if(sdom[label[dsu[u]]] < sdom[label[u]])\n        label[u] = label[dsu[u]];\n    dsu[u] = v;\n    return x?v:label[u];\n}\n\nvoid Union(int u, int v)\n{\n    dsu[v] = u;\n}\n\nvoid build()\n{\n    dfs(source);\n    for(int i = n; i>=1; i--)\n    {\n        for(int j = 0; j<rg[i].size(); j++)\n            sdom[i] = min(sdom[i], sdom[Find(rg[i][j])]);\n        if(i > 1) bucket[sdom[i]].push_back(i);\n        for(int j = 0; j<bucket[i].size(); j++)\n        {\n            int w = bucket[i][j], v = Find(w);\n            if(sdom[v] == sdom[w]) dom[w] = sdom[w];\n            else dom[w] = v;\n        }\n        if(i > 1) Union(par[i], i);\n    }\n\n    for(int i = 2; i<=n; i++)\n    {\n        if(dom[i] != sdom[i]) dom[i] = dom[dom[i]];\n        tree[rev[dom[i]]].push_back(rev[i]);\n        par[rev[i]] = rev[dom[i]];\n    }\n}\n\nbool hasDest[MAX+10];\nbool go(int node)\n{\n    if(node == dest)\n        return hasDest[node] =  1;\n    for(auto v: tree[node])\n    {\n        if(go(v))\n            return hasDest[node] = 1;\n    }\n    return hasDest[node] = 0;\n}\n\nbool check(int u, int v)\n{\n    return (par[v] == u && hasDest[v]);\n}\n\n}\n\nstruct edgeData{\n    int u, v;\n    LL w;\n};\n\nvector<pll>E[MAX+10], Rev[MAX+10];\nvector<edgeData>edge, revEdge;\n\nint n, m;\n\nLL dist[3][MAX+10];\nconst LL inf = 1e15;\nstruct data{\n    int v;\n    LL cost;\n};\n\nbool operator < (data a, data b)\n{\n    return a.cost > b.cost;\n}\n\npriority_queue<data>PQ;\nLL SP;\n\nvoid dijkstra(int source, vector<pll>E[])\n{\n    for(int i = 1; i<=n; i++)\n        dist[source][i] = inf;\n    dist[source][source] = 0;\n    while(!PQ.empty())\n        PQ.pop();\n    PQ.push({source, 0});\n    while(!PQ.empty())\n    {\n        int u = PQ.top().v;\n        PQ.pop();\n//        if(dist[source][u] < PQ.top().cost)\n//            continue;\n        for(auto v: E[u])\n        {\n            if(dist[source][v.xx] > dist[source][u] + v.yy)\n            {\n                dist[source][v.xx] = dist[source][u] + v.yy;\n                PQ.push({(int)v.xx, dist[source][v.xx]});\n            }\n        }\n    }\n}\n\n\nbool imp[MAX+10];\n#define SRC     1\n#define DEST    2\nmap<int,int>M[MAX+10];\nmap<int,int>cnt[MAX+10];\n\nstruct myData{\n    pll best[2];/// xx is edge id, yy is distance\n    void fix(LL tmp, LL idx)\n    {\n        if(best[0].xx == -1)\n            best[0] = {idx, tmp};\n        else if(best[0].yy > tmp)\n        {\n            best[1] = best[0];\n            best[0] = {idx, tmp};\n        }\n        else if(best[1].xx == -1)\n            best[1] = {idx, tmp};\n        else if(best[1].yy > tmp)\n            best[1] = {idx, tmp};\n    }\n}my[3][MAX+10];\n\nint myDist[3][MAX+10][2];\n\nvoid buildBest(int source, vector<edgeData>edge)\n{\n    for(int i = 1; i<=n; i++)\n        for(int j = 0; j<2; j++)\n            my[source][i].best[j].xx = -1, my[source][i].best[j].yy = inf;\n\n\n    my[source][source].best[0] = {1e7, 0};\n\n    for(int i = 0; i<edge.size(); i++)\n    {\n        auto cur = edge[i];\n        int u = cur.u;\n        int v = cur.v;\n        LL w = cur.w;\n        LL tmp = dist[source][u] + w;\n        my[source][v].fix(tmp, i);\n    }\n//    for(int i = 1; i<=n; i++)\n//    {\n//        DDD(i, dist[source][i], my[source][i].best[0].yy);\n//        assert(dist[source][i] == my[source][i].best[0].yy);\n//    }\n}\n\nvoid buildDAG()\n{\n    for(int i = 0; i<edge.size(); i++)\n    {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        LL w = edge[i].w;\n        if(M[u].find(v) == M[u].end())\n            M[u][v] = w;\n        else\n            M[u][v] = min(M[u][v], (int)w);\n        if(dist[SRC][u] + w + dist[DEST][v] == SP)\n            dom::g[u].pb(v), imp[i] = true;\n    }\n    for(int i = 0; i<edge.size(); i++)\n    {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        LL w = edge[i].w;\n        if(M[u][v] == w)\n            cnt[u][v]++;\n    }\n    for(int i = 0; i<edge.size(); i++)\n    {\n        int u = edge[i].u;\n        int v = edge[i].v;\n        LL w = edge[i].w;\n        if(!(M[u][v] == w && cnt[u][v] == 1))\n            imp[i] = 0;\n    }\n}\n\nvoid solve(int i)\n{\n    int u = edge[i].u;\n    int v = edge[i].v;\n    LL w = edge[i].w;\n    if(u == SRC && v == DEST)\n    {\n        if(SP == w && my[SRC][v].best[1].xx == -1)\n            puts(\"SAD\");\n        else\n            puts(\"SOSO\");\n        return;\n    }\n    LL SV, DU;\n    if(my[SRC][v].best[0].xx == i )\n        SV = my[SRC][v].best[1].yy;\n    else\n        SV = my[SRC][v].best[0].yy;\n\n    if(my[DEST][u].best[0].xx == i )\n        DU = my[DEST][u].best[1].yy;\n    else\n        DU = my[DEST][u].best[0].yy;\n\n//    if(DU != dist[DEST][u])\n//    {\n//        DDD(u,DU,dist[DEST][u]);\n//    }\n//    assert(DU == dist[DEST][u]);\n//    assert(SV == dist[SRC][v]);\n//    LL SV = dist[SRC][v];\n//    LL DU = dist[DEST][u];\n    LL tmp = SV + w + DU;\n    if(tmp < SP)\n    {\n        puts(\"HAPPY\");\n        return;\n    }\n    else if(tmp == SP)\n    {\n        puts(\"SOSO\");\n        return;\n    }\n    else\n    {\n        if(imp[i] && dom::check(u,v))\n        {\n            puts(\"SAD\");\n            return;\n        }\n        else\n        {\n            puts(\"SOSO\");\n            return;\n        }\n    }\n}\n\n\nint main()\n{\n//    freopen(\"maxon.txt\",\"r\",stdin);\n//    freopen(\"out.txt\",\"w\",stdout);\n    sff(n,m);\n    int u, v, w;\n    for(int i = 1; i<=m; i++)\n    {\n        sfff(u,v,w);\n        E[u].pb({v,w});\n        Rev[v].pb({u,w});\n        edge.pb({u,v,w});\n        revEdge.pb({v,u,w});\n    }\n\n    dijkstra(SRC, E);\n    SP = dist[SRC][DEST];\n    dijkstra(DEST, Rev);\n\n\n    dom::init(n, SRC);\n    buildDAG();\n    buildBest(SRC, edge);\n//    exit(0);\n    buildBest(DEST, revEdge);\n    dom::build();\n    mem(dom::hasDest, 0);\n    dom::go(SRC);\n    for(int i = 0; i<edge.size(); i++)\n        solve(i);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)(1e18)\nusing namespace std;\n\nusing P = pair<int, int>;\n\n\n#define N 100006\n\nvector<int> G[N];\n\nvector<P> bs;\nint used[N], val[N];\nint dfs(int v, int p) {\n  int res = 0, cnt = 0;\n  used[v] = 1; // searching\n  for(int w : G[v]) {\n    if(w == v) {\n      // self-loop edge\n      continue;\n    }\n    if(w == p) {\n      if(cnt > 0) {\n        // (p, v): multiple edges\n        res += 1;\n        val[w] += 1;\n      }\n      ++cnt;\n      continue;\n    }\n    if(!used[w]) {\n      res += dfs(w, v);\n    } else if(used[w] == 1) {\n      res += 1;\n      val[w] += 1;\n    }\n  }\n  used[v] = 2; // searched\n  res -= val[v];\n\n  if(p != -1 && res == 0) {\n    bs.push_back(p < v ? P(p, v) : P(v, p));\n  }\n  return res;\n}\n\nvoid bridge() {\n  bs.clear();\n  for(int i=0; i<N; ++i) used[i] = val[i] = 0;\n  dfs(0, -1);\n}\n\nint main(){\n  int n,m;\n  scanf(\"%d%d\", &n, &m);\n  vector<pair<int, pair<long long, int> > > g[n];\n  vector<pair<int, pair<long long, int> > > invg[n];\n  for(int i=0;i<m;i++){\n    int a,b;\n    long long c;\n    scanf(\"%d%d%lld\", &a, &b, &c);\n    a--;b--;\n    g[a].push_back(make_pair(b, make_pair(c, i)));\n    invg[b].push_back(make_pair(a, make_pair(c, i)));\n  }\n  // cerr << \"ok\" << endl;\n  for(int i=0;i<n;i++)sort(g[i].begin(), g[i].end());\n  for(int i=0;i<n;i++)sort(invg[i].begin(), invg[i].end());\n  long long mincost;\n  vector<long long> cost(n, inf);\n  vector<long long> invcost(n, inf);\n\n  priority_queue<vector<long long>,vector<vector<long long>>,greater<vector<long long>>> pq;\n  pq.push(vector<long long>({0, 0}));\n  while(!pq.empty()){\n    long long c = pq.top()[0];\n    long long p = pq.top()[1];\n    pq.pop();\n    if(cost[p] < inf) continue;\n    cost[p] = c;\n    for(auto y : g[p]){\n      pq.push(vector<long long>({c+y.second.first,y.first}));\n    }\n  }\n\n  pq.push(vector<long long>({0, 1}));\n  while(!pq.empty()){\n    long long c = pq.top()[0];\n    long long p = pq.top()[1];\n    pq.pop();\n    if(invcost[p] < inf) continue;\n    invcost[p] = c;\n    for(auto y : invg[p]){\n      pq.push(vector<long long>({c+y.second.first,y.first}));\n    }\n  }\n  // cerr << \"ok\" << endl;\n  long long path = cost[1];\n\n  //vector<pair<int, pair<long long, int> > > dagG[m];\n\n  for(int i=0;i<n;i++)for(int j=0;j<g[i].size();j++){\n    if(cost[i] + invcost[g[i][j].first] + g[i][j].second.first == path){\n      //dagG[i].push_back(g[i][j]);\n      G[i].push_back(g[i][j].first);\n      G[g[i][j].first].push_back(i);\n    }\n  }\n\n  int ans[m]={};\n\n  bridge();\n  // cerr << \"ok\" << endl;\n  for(int i=0;i<bs.size();i++){\n    pair<int, pair<long long, int> > tmp ;\n    if(lower_bound(g[bs[i].first].begin(), g[bs[i].first].end(), make_pair(bs[i].second, make_pair(0ll, 0))) != g[bs[i].first].end()){\n      tmp = *lower_bound(g[bs[i].first].begin(), g[bs[i].first].end(), make_pair(bs[i].second, make_pair(0ll, 0)));\n      if(tmp.first == bs[i].second && cost[bs[i].first] + tmp.second.first + invcost[bs[i].second] == path){\n        ans[tmp.second.second] = -1;\n      }\n    }\n    if(lower_bound(g[bs[i].second].begin(), g[bs[i].second].end(), make_pair(bs[i].first, make_pair(0ll, 0))) != g[bs[i].second].end()){\n      tmp = *lower_bound(g[bs[i].second].begin(), g[bs[i].second].end(), make_pair(bs[i].first, make_pair(0ll, 0)));\n      if(tmp.first == bs[i].first && cost[bs[i].second] + tmp.second.first + invcost[bs[i].first] == path){\n        ans[tmp.second.second] = -1;\n      }\n    }\n  }\n\n  for(int i=0;i<n;i++)for(int j=0;j<g[i].size();j++){\n    if(ans[g[i][j].second.second] != -1){\n      if(cost[g[i][j].first] + g[i][j].second.first + invcost[i] < path){\n        ans[g[i][j].second.second] = 1;\n      }\n    }\n  }\n  // cerr << \"ok\" << endl;\n  for(int i=0;i<m;i++){\n    if(ans[i]==-1)printf(\"SAD\\n\");\n    if(ans[i]==0)printf(\"SOSO\\n\");\n    if(ans[i]==1)printf(\"HAPPY\\n\");\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstruct BiconectedGraph{  \n  typedef pair<int,int> P;  \n  int n;  \n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){};\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){};\n   \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n   \n \n  bool is_bridge(int u,int v){\n    if(ord[u] > ord[v]) swap(u,v);\n    return ord[u] < low[v];\n  }\n \n  void dfs(int u,int p,int &k){\n    ord[u] = low[u] = k;\n    ++k;\n    for(int v:G[u]){\n      if(v == p) continue;\n      if(ord[v] >=0){\n    low[u] = min(low[u],ord[v]);\n      } else {\n    dfs(v,u,k);\n    low[u] = min(low[u],low[v]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n   \n  void fill_component(int c,int u){\n    C[c].push_back(u);\n    belong[u] = c;\n    for(int v:G[u]){\n      if(belong[v] >= 0 || is_bridge(u,v)) continue;\n      fill_component(c,v);\n    }\n  }\n   \n  void add_component(int u,int &k){\n    if(belong[u] >=0) return;\n    fill_component(k++,u);\n  }\n   \n  int build(){\n    int k = 0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int u=0;u<n;u++){\n      if(ord[u] >= 0) continue;\n      dfs(u,-1,k);\n    }\n    k = 0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n     \n    for(int u=0;u<n;u++) add_component(u,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u = belong[B[i].first], v = belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n\ntemplate <typename T>\nvector<T> dij(int s, vector<vector<pair<int, T> > > &G, T INF) {\n  using P = pair<T, int>;\n  int n = G.size();\n  vector<T> d(n, INF);\n  vector<int> b(n, -1);\n  priority_queue<P, vector<P>, greater<P> > q;\n  d[s] = 0;\n  q.emplace(d[s], s);  \n  while ( !q.empty() ) {\n    P p = q.top(); q.pop();\n    int v = p.second;\n    if ( d[v] < p.first ) continue;\n    for ( auto& e : G[v] ) {\n      int u = e.first;\n      T c = e.second;\n      if ( d[u] > d[v]+c ) {\n\td[u] = d[v]+c;\n\tb[u] = v;\n\tq.emplace(d[u], u);\t\n      }\n    }\n  }\n  \n  return d;\n}\n\nstruct Edge {\n  int u, v, c;  \n};\n\ntypedef pair<int, int> P;\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  \n  vector<vector<pair<int, int> > > G(n), bG(n);\n  vector<Edge> edges(m);  \n  for ( int i = 0; i < m; i++ ) {\n    int u, v, c;\n    cin >> u >> v >> c;\n    u--; v--;\n    edges[i] = {u, v, c};    \n    G[u].emplace_back(P(v, c));\n    bG[v].emplace_back(P(u, c));\n  }\n\n  vector<int> d = dij<int>(0, G, (int)1e13);  \n  vector<int> bd = dij<int>(1, bG, (int)1e13);\n  int mi = d[1];  \n\n  BiconectedGraph ll(n);  \n  int used[100001] = {};  \n  for ( int i = 0; i < m; i++ ) {\n    int u = edges[i].u, v = edges[i].v, c = edges[i].c;    \n    if ( d[u]+bd[v]+c == mi ) {\n      ll.add_edge(u, v);\n      used[i] = true;      \n    }\n  }\n\n  ll.build();  \n\n  for ( int i = 0; i < m; i++ ) {\n    int u = edges[i].u, v = edges[i].v, c = edges[i].c;\n    int nc = d[v]+bd[u]+c;        \n    if ( nc < mi ) {\n      cout << \"HAPPY\" << endl;\n    } else if ( !used[i] || nc == mi ) {      \n      cout << \"SOSO\" << endl;      \n    } else {\n      if ( ll.is_bridge(u, v) ) cout << \"SAD\" << endl;\n      else cout << \"SOSO\" << endl;      \n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    template<typename K, typename V>\n    ostream& operator<<(ostream& os, const pair<K, V>& p) {\n        return os << \"(\" << p.first << \",\" << p.second << \")\";\n    }\n    typedef long long ll;\n    const ll INF = 1LL << 56;\n    int N, M;\n\n    struct Edge {\n        int from, to; ll cost;\n        Edge(int from, int to, ll cost) : from(from), to(to), cost(cost) {}\n        bool operator<(const Edge& e) const {\n            if (from == e.from) {\n                return to == e.to ? cost < e.cost : to < e.to;\n            } else {\n                return from < e.from;\n            }\n        }\n        bool operator==(const Edge& e) {\n            return to == e.to and from == e.from and cost == e.cost;\n        }\n    };\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \",\" << e.to << \",\" << e.cost << \")\";\n    }\n    /** output whole vector. ex) vector<int>{1, 2, 3} -> '1 2 3'. */\n    template<typename T>\n    ostream& operator<<(ostream& os, const vector<T>& xs) {\n       if (xs.empty()) return os;\n       os << xs[0];\n       for (auto i = 1; i < xs.size(); i++) os << ' ' << xs[i];\n       return os;\n    }\n    vector<vector<Edge>> G, RG;\n    vector<Edge> es;\n    map<Edge, int> X;\n\n    vector<pair<int, int>> findBridges(const vector<vector<Edge>>& G) {\n        int V = N;\n        vector<int> dfs_order(V, -1);\n        vector<int> lowlink(V, 0);\n        int c = 0;\n        vector<pair<int, int>> bridges;\n        function<void(int, int)> dfs = [&](int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            for (auto& e : G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) {\n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                if (dfs_order[v] < lowlink[next]) {\n                    auto l = min(v, next);\n                    auto g = max(v, next);\n                    bridges.emplace_back(l, g);\n                }\n            }\n        };\n        dfs(0, -1);\n        return bridges;\n    }\n\n    void input() {\n        cin >> N >> M;\n        G.resize(N);\n        RG.resize(N);\n        for (int i = 0; i < M; i++) {\n            int a, b; ll c;\n            cin >> a >> b >> c;\n            a--; b--;\n            Edge e(a, b, c);\n            if (X.count(e)) {\n                X[e]++;\n            } else {\n                G[a].emplace_back(a, b, c);\n                RG[b].emplace_back(b, a, c);\n                X[e] = 1;\n            }\n            es.emplace_back(a, b, c);\n        }\n    }\n\n    struct S {\n        int v; ll cost;\n        S(int v, ll cost) : v(v), cost(cost) {}\n        bool operator<(const S& s) const {\n            return cost > s.cost;\n        }\n    };\n\n    void dijkstra(const vector<vector<Edge>>& G, int start, vector<ll>& D, vector<vector<Edge>>& prev) {\n        priority_queue<S> PQ;\n        PQ.emplace(start, 0);\n        D[start] = 0;\n        while (not PQ.empty()) {\n            auto cur = PQ.top(); PQ.pop();\n            for (auto& e : G[cur.v]) {\n                auto next = e.to;\n                auto ncost = D[cur.v] + e.cost;\n                if (D[next] > ncost) {\n                    prev[next].clear();\n                    prev[next].push_back(e);\n                    D[next] = ncost;\n                    PQ.emplace(next, ncost);\n                } else if (D[next] == ncost) {\n                    prev[next].push_back(e);\n                }\n            }\n        }\n    }\n\n    void solve() {\n        vector<ll> D(N, INF);\n        vector<ll> RD(N, INF);\n        vector<vector<Edge>> prev(N, vector<Edge>());\n        vector<vector<Edge>> rprev(N, vector<Edge>());\n        dijkstra(G, 0, D, prev);\n        dijkstra(RG, 1, RD, rprev);\n\n        vector<vector<Edge>> shortest_paths(N, vector<Edge>());\n        vector<bool> used(N, false);\n        function<void(int)> dfs = [&](int v) {\n            if (prev[v].empty()) {\n                //assert(v == 0);\n                return;\n            }\n            if (used[v]) return;\n            used[v] = true;\n            for (auto e : prev[v]) {\n                shortest_paths[e.from].push_back(e);\n                shortest_paths[e.to].emplace_back(e.to, e.from, -1);\n                dfs(e.from);\n            }\n        };\n        dfs(1);\n        //cout << shortest_paths << endl;\n\n        auto _bridges = findBridges(shortest_paths);\n        //cout << _bridges << endl;\n        set<pair<int, int>> bridges;\n        for (auto b : _bridges) { bridges.insert(b); }\n\n        for (int i = 0; i < M; i++) {\n            auto e = es[i];\n            if (D[e.from] + e.cost + RD[e.to] == D[1]) {\n                if (\n                    (bridges.count(make_pair(e.from, e.to)) \n                     or bridges.count(make_pair(e.to, e.from)))\n                     and X[e] <= 1) {\n                    cout << \"SAD\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            } else {\n                auto ncost = D[e.to] + e.cost + RD[e.from];\n                if (ncost < D[1]) {\n                    cout << \"HAPPY\" << endl;\n                } else {\n                    cout << \"SOSO\" << endl;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\n#define INF 0x3f3f3f3f\n#define eps 1e-8\nusing namespace std;\ntypedef long long ll;\n\nint n,m,a,b,x;\nstruct graph\n{\n    int from[maxn],to[maxn],no;\n    int head[maxn],nxt[maxn],val[maxn];\n    ll dis[maxn];\n    bool vis[maxn];\n    inline void init()\n    {\n        memset(head,-1,sizeof(head));\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<=n;i++)dis[i]=INF;\n        no=0;\n    }\n    inline void add(int a,int b,int x)\n    {\n        from[no]=a,to[no]=b;\n        val[no]=x;\n        nxt[no]=head[a];\n        head[a]=no++;\n    }\n    void spfa(int st)\n    {\n        queue<int>q;\n        vis[st]=1,dis[st]=0;\n        q.push(st);\n        while(!q.empty())\n        {\n            int u=q.front();\n            q.pop();\n            vis[u]=0;\n            for(int i=head[u];i!=-1;i=nxt[i])\n            {\n                int v=to[i];\n                if(dis[v]>dis[u]+val[i])\n                {\n                    dis[v]=dis[u]+val[i];\n                    if(!vis[v])\n                    {\n                        vis[v]=1;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n}G,opG;\n\nstruct node\n{\n    int to[maxn],nxt[maxn],head[maxn];\n    int dfn[maxn],low[maxn],pre[maxn];\n    int dep,no;\n    map< pair<int,int>,int >mo;\n    void init()\n    {\n        memset(head,-1,sizeof(head));\n        memset(dfn,-1,sizeof(dfn));\n        memset(low,-1,sizeof(low));\n        no=dep=0;\n    }\n    void add(int a,int b)\n    {\n        to[no]=b;\n        nxt[no]=head[a];\n        head[a]=no++;\n    }\n    void tarjan(int u,int fa)\n    {\n        pre[u]=fa;\n        dfn[u]=low[u]=dep++;\n        for(int i=head[u];i!=-1;i=nxt[i])\n        {\n            int v=to[i];\n            if(dfn[v]==-1)\n            {\n                tarjan(v,u);\n                low[u]=min(low[u],low[v]);\n            }\n            else if(fa!=v)\n                low[u]=min(low[u],dfn[v]);\n        }\n    }\n    void solve()\n    {\n        tarjan(1,0);\n        for(int i=1;i<=n;i++)\n        {\n            int v=pre[i];\n            if(v>0&&low[i]>dfn[v])\n            {\n                //cout<<i<<\" \"<<v<<endl;\n                if(i<v)mo[make_pair(i,v)]++;\n                else mo[make_pair(v,i)]++;\n            }\n        }\n    }\n}DAG;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    G.init(),opG.init();\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&a,&b,&x);\n        G.add(a,b,x);\n        opG.add(b,a,x);\n    }\n    G.spfa(1);\n    opG.spfa(2);\n    DAG.init();\n    /*for(int i=1;i<=n;i++)\n        cout<<G.dis[i]<<\" \";\n    cout<<endl;\n    for(int i=1;i<=n;i++)\n        cout<<opG.dis[i]<<\" \";\n    cout<<endl;*/\n    for(int i=0;i<m;i++)\n    {\n        int u=G.from[i];\n        int v=G.to[i];\n        int w=G.val[i];\n        if(G.dis[u]+w+opG.dis[v]==G.dis[2])\n        {\n            DAG.add(u,v);\n            //cout<<u<<\" \"<<v<<endl;\n        }\n    }\n    DAG.solve();\n    for(int i=0;i<m;i++)\n    {\n        int u=G.from[i];\n        int v=G.to[i];\n        int w=G.val[i];\n        if(G.dis[v]+w+opG.dis[u]<G.dis[2])\n            printf(\"HAPPY\\n\");\n        else\n        {\n            if(u>v)swap(u,v);\n            if(DAG.mo[make_pair(u,v)])\n                printf(\"SAD\\n\");\n            else printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream&\noperator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream&\noperator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0)\n            shortest_graph[now.from].push_back(now.e);\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    \n    // debug(dist[1]);\n    // rep(i, N) {\n    //     debug(i);\n    //     for(auto e: shortest_graph[i]) {\n    //         cerr << e.from << \" -> \" << e.to << \" : \" << e.cost << endl;\n    //     }\n    // }\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i)) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <iomanip>\n#include <climits>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst long long int mod = 1e9 + 7;\n\n#define EDGE_SIZE 100010\n#define VERTEX_SIZE 100010\n\ntypedef struct _Edge\n{\n    int to;\n    int len;\n    int next;\n} Edge;\n\nEdge arr[2][EDGE_SIZE];\nint head[2][VERTEX_SIZE], arrPt[2];\n\nlong long int dis[2][VERTEX_SIZE], num[2][VERTEX_SIZE];\nbool isShortest[VERTEX_SIZE];\n\nint vertexNum, edgeNum;\n\nvoid addEdge(int id, int from, int to, int len)\n{\n    arr[id][arrPt[id]] = {to, len, head[id][from]};\n    head[id][from] = arrPt[id]++;\n}\n\nvoid dijkstra(int id, int startPt)\n{\n    for (int i = 0; i < vertexNum; i++)\n    {\n        dis[id][i] = LLONG_MAX;\n        num[id][i] = 0;\n        isShortest[i] = false;\n    }\n\n    priority_queue<pair<long long int, int> > pq;\n    pq.push(make_pair(0, startPt));\n    dis[id][startPt] = 0;\n    num[id][startPt] = 1;\n\n    while (!pq.empty())\n    {\n        int cntPt = pq.top().second;\n        pq.pop();\n\n        if (isShortest[cntPt])\n            continue;\n        isShortest[cntPt] = true;\n\n        for (int i = head[id][cntPt]; i != -1; i = arr[id][i].next)\n        {\n            int nextPt = arr[id][i].to;\n            if (dis[id][cntPt] != LLONG_MAX)\n            {\n                if (dis[id][nextPt] > dis[id][cntPt] + arr[id][i].len)\n                {\n                    dis[id][nextPt] = dis[id][cntPt] + arr[id][i].len;\n                    num[id][nextPt] = num[id][cntPt];\n                    pq.push(make_pair(-dis[id][nextPt], nextPt));\n                }\n                else if (dis[id][nextPt] == dis[id][cntPt] + arr[id][i].len)\n                {\n                    num[id][nextPt] = (num[id][nextPt] + num[id][cntPt]) % mod;\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    while (cin >> vertexNum >> edgeNum)\n    {\n        memset(head, -1, sizeof(head));\n        memset(arrPt, 0, sizeof(arrPt));\n        for (int i = 0; i < edgeNum; i++)\n        {\n            int from, to, len;\n            cin >> from >> to >> len;\n            from--;\n            to--;\n            addEdge(0, from, to, len);\n            addEdge(1, to, from, len);\n        }\n\n        dijkstra(0, 0);\n        dijkstra(1, 1);\n\n        for (int i = 0; i < edgeNum; i++)\n        {\n            int from = arr[1][i].to;\n            int to = arr[0][i].to;\n            int len = arr[0][i].len;\n\n            if (dis[0][to] != LLONG_MAX && dis[1][from] != LLONG_MAX && dis[0][to] + dis[1][from] + len < dis[0][1])\n            {\n                cout << \"HAPPY\" << endl;\n            }\n            else if (dis[0][from] != LLONG_MAX && dis[1][to] != LLONG_MAX && dis[0][from] + dis[1][to] + len == dis[0][1] && num[0][from] * num[1][to] % mod == num[0][1])\n            {\n                // is Bridge\n                cout << \"SAD\" << endl;\n            }\n            else\n            {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <tuple>\n\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    int id;\n    Edge(int src = -1, int dst = -1, Cost cost = 1, int id = -1)\n        : src(src), dst(dst), cost(cost), id(id){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nusing lint = long long;\nconstexpr lint INF = 1LL << 60;\n\ntemplate <class Cost>\nstd::vector<Cost> dijkstra(const Graph<Cost>& graph, int s) {\n    std::vector<Cost> dist(graph.size(), INF);\n    dist[s] = 0;\n    MinHeap<std::pair<Cost, int>> que;\n    que.emplace(0, s);\n\n    while (!que.empty()) {\n        int v;\n        Cost d;\n        std::tie(d, v) = que.top();\n        que.pop();\n        if (d > dist[v]) continue;\n\n        for (auto e : graph[v]) {\n            if (dist[e.dst] <= dist[v] + e.cost) continue;\n            dist[e.dst] = dist[v] + e.cost;\n            que.emplace(dist[e.dst], e.dst);\n        }\n    }\n    return dist;\n}\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    Graph<lint> graph(n), rgraph(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        lint d;\n        std::cin >> u >> v >> d;\n        --u, --v;\n        graph[u].emplace_back(u, v, d, i);\n        rgraph[v].emplace_back(v, u, d, i);\n    }\n\n    auto sdist = dijkstra(graph, 0);\n    auto gdist = dijkstra(rgraph, 1);\n    lint dmin = sdist[1];\n\n    std::vector<int> ans(m, -1);\n    for (int u = 0; u < n; ++u) {\n        for (auto e : graph[u]) {\n            int v = e.dst;\n            lint nd = sdist[v] + e.cost + gdist[u];\n\n            if (nd < dmin) {\n                ans[e.id] = 0;\n            } else if (nd == dmin) {\n                ans[e.id] = 1;\n            }\n        }\n    }\n\n    std::vector<mint> spat(n, 0), gpat(n, 0);\n    std::vector<int> vs(n);\n    std::iota(vs.begin(), vs.end(), 0);\n\n    {\n        std::sort(vs.begin(), vs.end(),\n                  [&](int u, int v) { return sdist[u] < sdist[v]; });\n\n        spat[0] = 1;\n        for (auto u : vs) {\n            for (auto e : graph[u]) {\n                int v = e.dst;\n                auto nd = sdist[u] + e.cost + gdist[v];\n\n                if (nd > dmin) {\n                    if (ans[e.id] == -1) ans[e.id] = 1;  // SOSO\n                    continue;\n                }\n\n                spat[v] += spat[u];\n            }\n        }\n    }\n\n    {\n        std::sort(vs.begin(), vs.end(),\n                  [&](int u, int v) { return gdist[u] < gdist[v]; });\n\n        gpat[1] = 1;\n        for (auto u : vs) {\n            for (auto e : rgraph[u]) {\n                int v = e.dst;\n                auto nd = gdist[u] + e.cost + sdist[v];\n\n                if (nd > dmin) continue;\n\n                gpat[v] += gpat[u];\n            }\n        }\n    }\n\n    for (auto u : vs) {\n        for (auto e : graph[u]) {\n            int v = e.dst;\n            if (ans[e.id] != -1) continue;\n            ans[e.id] = (spat[u] * gpat[v] == spat[1] ? 2 : 1);\n        }\n    }\n\n    std::vector<std::string> ss{\"HAPPY\", \"SOSO\", \"SAD\"};\n    for (auto a : ans) std::cout << ss[a] << \"\\n\";\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    (cnt[v] += (p != -1 ? cnt[p] : 1)) %= MOD;\n\n    if(dist[v] > d) {\n      dist[v] = d;\n      REP(i, 0, E[v].size()) {\n        ll u = E[v][i].first, c = E[v][i].second;\n        if(dist[u] > d + c) q.push((state) { d + c, u, v });\n      }\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define SZ 131072\n#define pli pair<long long,int>\nusing namespace std;\nint n, m, Route[101000], PP[101000], ord[101000];\nvector<int>E[101000], L[101000], Num[101000], T[101000];\npriority_queue<pli>PQ;\nstruct Edge {\n\tint a, b, c;\n}Ed[101000];\nint Path[101000], chk[101000];\nlong long D[101000], D2[101000];\nvoid Ins(int a, long long d, int pp) {\n\tif (D[a] <= d)return;\n\tD[a] = d;\n\tPath[a] = pp;\n\tPQ.push(pli{ -d,a });\n}\nvoid Dijk(int st) {\n\tint i, a;\n\tfor (i = 1; i <= n; i++)D[i] = 1e18, Path[i] = -1;\n\tIns(st, 0, 0);\n\twhile (!PQ.empty()) {\n\t\tpli tp = PQ.top();\n\t\tPQ.pop();\n\t\tif (D[tp.second] != -tp.first)continue;\n\t\ta = tp.second;\n\t\tfor (i = 0; i < E[a].size(); i++) {\n\t\t\tIns(E[a][i], D[a] + L[a][i], Num[a][i]);\n\t\t}\n\t}\n}\nvoid DFS(int a, int pp) {\n\tint i;\n\tif (Route[a])pp = a;\n\tPP[a] = pp;\n\tfor (i = 0; i < T[a].size(); i++) {\n\t\tDFS(T[a][i], pp);\n\t}\n}\nint cnt;\nlong long IT[SZ + SZ];\nvoid Put(int b, int e, long long x) {\n\tb += SZ, e += SZ;\n\twhile (b <= e) {\n\t\tIT[b] = min(IT[b], x);\n\t\tIT[e] = min(IT[e], x);\n\t\tb = (b + 1) >> 1, e = (e - 1) >> 1;\n\t}\n}\nvoid Add(int a, int b, int c) {\n\tif (D[a] > 5e17 || D2[b] > 5e17)return;\n\tif (!PP[a] || !PP[b])return;\n\tif (PP[a] > PP[b])Put(PP[b], PP[a] - 1, D[a] + D2[b] + c);\n}\nint main() {\n\tint i, a, b, c;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i < SZ + SZ; i++)IT[i] = 1e18;\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tE[b].push_back(a);\n\t\tL[b].push_back(c);\n\t\tNum[b].push_back(i);\n\t\tEd[i] = { a,b,c };\n\t}\n\tDijk(2);\n\tfor (i = 1; i <= n; i++)D2[i] = D[i], E[i].clear(),L[i].clear(), Num[i].clear();\n\tfor (i = 0; i < m; i++) {\n\t\ta = Ed[i].a, b = Ed[i].b, c = Ed[i].c;\n\t\tE[a].push_back(b);\n\t\tL[a].push_back(c);\n\t\tNum[a].push_back(i);\n\t}\n\tDijk(1);\n\ta = 2;\n\twhile (a != 1) {\n\t\tRoute[a] = ++cnt;\n\t\tchk[Path[a]] = 1;\n\t\ta = Ed[Path[a]].a;\n\t}\n\tRoute[a] = ++cnt;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (Path[i] != -1)T[Ed[Path[i]].a].push_back(i);\n\t}\n\tDFS(1, 1);\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i])continue;\n\t\tAdd(Ed[i].a, Ed[i].b, Ed[i].c);\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i]) {\n\t\t\tint t = SZ + min(Route[Ed[i].a], Route[Ed[i].b]);\n\t\t\tlong long rr = 1e18;\n\t\t\twhile (t) {\n\t\t\t\trr = min(rr, IT[t]);\n\t\t\t\tt >>= 1;\n\t\t\t}\n\t\t\tif (rr == D[2])printf(\"SOSO\\n\");\n\t\t\telse printf(\"SAD\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (D[Ed[i].b] + D2[Ed[i].a] + Ed[i].c < D[2])printf(\"HAPPY\\n\");\n\t\t\telse printf(\"SOSO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000021;\nconst long long inf = 1LL << 61;\nstruct edge { int to, cost, id; };\nstruct edge2 { int to, id; };\nstruct state { int pos; long long cost; };\nbool operator<(const state& s1, const state& s2) { return s1.cost > s2.cost; }\nint N, M, dp[100009], dp2[100009], va[100009]; bool vis1[100009], vis2[100009]; vector<int> a, b, c;\nvector<long long> shortest_path(vector<vector<edge> > g, int src) {\n\tvector<long long> ret(g.size(), inf); ret[src] = 0;\n\tpriority_queue<state> que; que.push(state{ src, 0 });\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (edge e : g[u]) {\n\t\t\tlong long nd = ret[u] + e.cost;\n\t\t\tif (ret[e.to] > nd) {\n\t\t\t\tret[e.to] = nd;\n\t\t\t\tque.push(state{ e.to, nd });\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvector<int> solve() {\n\tvector<vector<edge> > g(N);\n\tvector<vector<edge> > rg(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tg[a[i]].push_back(edge{ b[i], c[i], i });\n\t\trg[b[i]].push_back(edge{ a[i], c[i], i });\n\t}\n\tvector<long long> ds = shortest_path(g, 0);\n\tvector<long long> dt = shortest_path(rg, 1);\n\tvector<bool> ok(M);\n\tvector<vector<edge2> > sg(N), sr(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ds[a[i]] + c[i] + dt[b[i]] == ds[1]) {\n\t\t\tsg[a[i]].push_back(edge2{ b[i], i });\n\t\t\tsr[b[i]].push_back(edge2{ a[i], i });\n\t\t\tok[i] = true;\n\t\t}\n\t}\n\tfill(vis1, vis1 + N, false);\n\tfill(vis2, vis2 + N, false);\n\tfill(dp, dp + N, 0);\n\tfill(dp2, dp2 + N, 0);\n\tvector<int> dpm1(M), dpm2(M);\n\tpriority_queue<state> que; que.push(state{ 0, 0 }); dp[0] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis1[u]) {\n\t\t\tvis1[u] = true;\n\t\t\tfor (edge2 i : sg[u]) {\n\t\t\t\tdp[i.to] += dp[u];\n\t\t\t\tdpm1[i.id] = dp[u];\n\t\t\t\tif (dp[i.to] >= mod) dp[i.to] -= mod;\n\t\t\t\tque.push(state{ i.to, ds[i.to] });\n\t\t\t}\n\t\t}\n\t}\n\tque.push(state{ 1, 0 }); dp2[1] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis2[u]) {\n\t\t\tvis2[u] = true;\n\t\t\tfor (edge2 i : sr[u]) {\n\t\t\t\tdp2[i.to] += dp2[u];\n\t\t\t\tdpm2[i.id] = dp2[u];\n\t\t\t\tif (dp2[i.to] >= mod) dp2[i.to] -= mod;\n\t\t\t\tque.push(state{ i.to, dt[i.to] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) va[i] = 1LL * dp[i] * dp2[i] % mod;\n\tmap<tuple<int, int, int>, int> cnts;\n\tfor (int i = 0; i < M; i++) {\n\t\tcnts[make_tuple(a[i], b[i], c[i])]++;\n\t}\n\tvector<int> ret(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!ok[i]) {\n\t\t\tret[i] = (ds[b[i]] + dt[a[i]] + c[i] < ds[1] ? 2 : 1);\n\t\t}\n\t\telse {\n\t\t\tif (ds[b[i]] + dt[a[i]] + c[i] < ds[1]) ret[i] = 2;\n\t\t\telse if (ds[b[i]] + dt[a[i]] + c[i] == ds[1]) ret[i] = 1;\n\t\t\telse {\n\t\t\t\tif (1LL * dpm1[i] * dpm2[i] % mod == va[0] && cnts[make_tuple(a[i], b[i], c[i])] == 1) ret[i] = 0;\n\t\t\t\telse ret[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvector<int> brute_force() {\n\tvector<int> ret(M);\n\tvector<vector<edge> > ig(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tig[a[i]].push_back(edge{ b[i], c[i] });\n\t}\n\tlong long res = shortest_path(ig, 0)[1];\n\tif (res == inf) return { -1 };\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<vector<edge> > g(M);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i != j) g[a[j]].push_back(edge{ b[j], c[j] });\n\t\t\telse g[b[j]].push_back(edge{ a[j], c[j] });\n\t\t}\n\t\tlong long re = shortest_path(g, 0)[1];\n\t\tif (re < res) ret[i] = 2;\n\t\tif (re == res) ret[i] = 1;\n\t\tif (re > res) ret[i] = 0;\n\t}\n\treturn ret;\n}\nint rand_rng(int l, int r) {\n\tlong long seed = rand() * 123456789LL + rand() * 3456789LL + rand() * 12345LL;\n\treturn l + (seed) % (r - l);\n}\nvoid random_test() {\n\tN = 7; M = 7;\n\tfor (int i = 0; i < 10000; i++) {\n\t\ta = vector<int>(M);\n\t\tb = vector<int>(M);\n\t\tc = vector<int>(M);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\twhile (a[j] == b[j]) {\n\t\t\t\ta[j] = rand_rng(0, N);\n\t\t\t\tb[j] = rand_rng(0, N);\n\t\t\t}\n\t\t\tc[j] = rand_rng(1, 10);\n\t\t}\n\t\tvector<int> ret1 = brute_force();\n\t\tif (ret1[0] != -1) {\n\t\t\tvector<int> ret2 = solve();\n\t\t\tif (ret1 != ret2) {\n\t\t\t\tcout << \"BUG\" << endl;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t\tif (i % 100 == 99) cout << i + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\nint main() {\n\trandom_test();\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\ta = vector<int>(M);\n\tb = vector<int>(M);\n\tc = vector<int>(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t}\n\tvector<int> ret = solve();\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ret[i] == 2) cout << \"HAPPY\\n\";\n\t\telse if (ret[i] == 1) cout << \"SOSO\\n\";\n\t\telse cout << \"SAD\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,j,k) for(int i=j;i<=k;i++)\n#define MAX 200010\n#define F first\n#define S second\n#define LL long long\n#define PB push_back\n#define MP make_pair\ntypedef pair<LL,int>pr;\n\nclass Compare\n{\npublic:\n    bool operator()(pr x,pr y)\n    {\n        return x.F < y.F;\n    }\n};\n\nvector<int> mat[MAX], rmat[MAX];\nvector<LL> cost[MAX], rcost[MAX];\n\npriority_queue<pr,vector<pr>,Compare> que;\n\nint n, m;\nLL dis[2][MAX];\n\nvoid dijkstra(int p,int ty)\n{\n    dis[ty][p] = 0;\n    que.push(MP(dis[ty][p], p));\n\n    while(!que.empty())\n    {\n        pr use = que.top();\n        p = use.S;\n        que.pop();\n\n        if(use.F != dis[ty][p]) continue;\n\n        int sz;\n        if(!ty) sz = mat[p].size();\n        else sz = rmat[p].size();\n\n        FOR(i,0,sz-1)\n        {\n            int x, y;\n            if(!ty)\n            {\n                 x = mat[p][i];\n                 y = cost[p][i];\n            }\n            else\n            {\n                 x = rmat[p][i];\n                 y = rcost[p][i];\n            }\n\n            if(dis[ty][x] > dis[ty][p] + y)\n            {\n                dis[ty][x] = dis[ty][p] + y;\n                que.push(MP(dis[ty][x], x));\n            }\n        }\n\n    }\n\n    return;\n}\n\nstruct info\n{\n    int x, y, z;\n}in[MAX];\n\nvoid dijkstra_input()\n{\n    LL x, y, z;\n\n    FOR(i,1,m)\n    {\n        cin >> x >> y >> z;\n\n        mat[x].PB(y);   cost[x].PB(z);\n        rmat[y].PB(x);   rcost[y].PB(z);\n        in[i].x = x; in[i].y = y; in[i].z = z;\n    }\n\n    LL v = 1000000000000000000;\n    FOR(i,1,n)\n    {\n        dis[1][i] = dis[0][i] = v;\n    }\n\n    dijkstra(1, 0);\n    dijkstra(2, 1 );\n\n    return;\n}\n\nint shot(int u,int v,LL c,LL Val)\n{\n    if(dis[0][u] + c + dis[1][v] == Val) return 1;\n    if(dis[0][u] + c + dis[1][v] < Val) return 2;\n    return 0;\n}\n\nint goPa[MAX], goCha[MAX];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n   /// freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdin);\n\n    cin >> n >> m;\n\n    dijkstra_input();\n\n    FOR(p,1,n)\n    FOR(i,0,(int)rmat[p].size()-1)\n    {\n        int x = rmat[p][i];\n        int v = rcost[p][i];\n        if(shot(x, p, v, dis[0][2])) goPa[p]++;\n    }\n\n    FOR(p,1,n)\n    FOR(i,0,(int)mat[p].size()-1)\n    {\n        int x = mat[p][i];\n        int v = cost[p][i];\n        if(shot(p, x, v, dis[0][2])) goCha[p]++;\n    }\n\n    int p = 2;\n    set<pr> sota;\n    set<pr>::iterator it;\n    map<pr,int> mopa;\n\n    sota.insert( MP(dis[0][p], p) );\n\n    while(!sota.empty())\n    {\n        int px = -1, vx;\n        it = sota.end();\n        it--;\n\n        pr use = *it; sota.erase( it );\n        int p = use.S;\n\n        FOR(i,0,(int)rmat[p].size()-1)\n        {\n            int x = rmat[p][i];\n            int v = rcost[p][i];\n\n            if(shot(x, p, v, dis[0][2]))\n            {\n                px = x; vx = rcost[p][i];\n                sota.insert(MP(dis[0][x], x));\n            }\n        }\n\n        if(sota.size() == 1 && goPa[p] == 1 && goCha[px] == 1)\n        {\n            ///cout << px << ' ' << p << endl;\n            mopa[ MP(px, p) ] = vx;\n        }\n    }\n\n    FOR(i,1,m)\n    {\n        int x = in[i].x, y = in[i].y, z = in[i].z;\n\n        if(mopa[ MP(x, y) ] == z)\n        {\n            if(shot(y, x, z, dis[0][2]) == 2) cout << \"HAPPY\" << endl;\n            else  if(shot(y, x, z, dis[0][2]) == 1) cout << \"SOSO\" << endl;\n            else cout << \"SAD\" << endl;\n        }\n        else\n        {\n            if(shot(y, x, z, dis[0][2]) == 2) cout << \"HAPPY\" << endl;\n            else cout << \"SOSO\" << endl;\n        }\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it,a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a,value,sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\nconst double PI = acos(-1.0);\n\nconst int MAX = 500500;\nconst int LEN = 20;\n\nvector<PII> g[MAX];\nvector<PII> gr[MAX];\nVI I[MAX];\n\nVI G[MAX];\n\nLL D[2][MAX];\n\nset<pair<LL, int> > S;\n\nbool U[MAX];\nint UP[MAX][LEN];\nint H[MAX];\n\nint n, m;\n\nLL d;\n\nint RES[MAX];\n\nvoid dijk(vector<PII>* g, LL* D, int s)\n{\n\tFOR (i, 0, n)\n\t{\n\t\tD[i] = LINF;\n\t}\n\t\n\tS.clear();\n\t\n\tD[s] = 0;\n\tS.insert(MP(D[s], s));\n\t\n\twhile(SZ(S))\n\t{\n\t\tint x = S.begin()->second;\n\t\tS.erase(S.begin());\n\t\t\n\t\tFOR (i, 0, SZ(g[x]))\n\t\t{\n\t\t\tint to = g[x][i].first;\n\t\t\tint c = g[x][i].second;\n\t\t\t\n\t\t\tif (D[to] > D[x] + c)\n\t\t\t{\n\t\t\t\tS.erase(MP(D[to], to));\n\t\t\t\tD[to] = D[x] + c;\n\t\t\t\tS.insert(MP(D[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint lca(int x, int y)\n{\n\tRFOR(i, LEN, 0)\n\t{\n\t\tif (H[UP[x][i]] > H[y]) x = UP[x][i];\n\t\tif (H[UP[y][i]] > H[x]) y = UP[y][i];\n\t}\n\t\n\tif (H[y] > H[x]) y = UP[y][0];\n\tif (H[x] > H[y]) x = UP[x][0];\n\t\n\tRFOR(i, LEN, 0)\n\t{\n\t\tif (UP[x][i] != UP[y][i])\n\t\t{\n\t\t\tx = UP[x][i];\n\t\t\ty = UP[y][i];\n\t\t}\n\t}\n\t\n\treturn UP[x][0];\n}\n\nvoid add(int x, int p)\n{\n//\tcout<<\"% \"<<x<<' '<<p<<endl;\n\tif (p == -1)\n\t{\n\t\tH[x] = 0;\n\t\t\n\t\tFOR (i, 0, LEN)\n\t\t{\n\t\t\tUP[x][i] = x;\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tH[x] = H[p] + 1;\n\tUP[x][0] = p;\n\tFOR (i, 1, LEN)\n\t{\n\t\tUP[x][i] = UP[UP[x][i-1]][i-1];\n\t}\n}\n\nvoid dfs(int x)\n{\n\tif (U[x]) return;\n\tU[x] = true;\n\tFOR (i, 0, SZ(G[x]))\n\t{\n\t\tint to = G[x][i];\n\t\tdfs(to);\n\t}\n\t\n\tint v = -1;\n\tFOR (i, 0, SZ(G[x]))\n\t{\n\t\tint to = G[x][i];\n\t\t\n\t\tif (v == -1) v = to;\n\t\telse v = lca(v, to);\n\t}\n\t\n\tadd(x, v);\n}\n\nvoid build()\n{\n\tFOR (i, 0, n)\n\t{\n\t\tFOR (j, 0, SZ(g[i]))\n\t\t{\n\t\t\tint to = g[i][j].first;\n\t\t\tint c = g[i][j].second;\n\t\t\t\n\t\t\tif (D[0][to] == D[0][i] + c)\n\t\t\t{\n\t\t\t\tint ind = I[i][j];\n\t\t\t\t\n\t\t\t\tG[to].PB(n + ind);\n\t\t\t\tG[n + ind].PB(i);\n\t\t\t\t\n//\t\t\t\tcout<<\"@@ \"<<i<<' '<<n+ind<<endl;\n//\t\t\t\tcout<<\"@@ \"<<n + ind<<' '<<to<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tFILL(U, false);\n\t\n\tFOR (i, 0, n+m)\n\t{\n\t\tdfs(i);\n\t}\n}\n\nint check(int x, int y, int c, int ind)\n{\n\tLL dist = D[0][y] + c + D[1][x];\n//\tcout<<\"!! \"<<x<<' '<<y<<' '<<c<<' '<<ind<<\": \"<<dist<<' '<<d<<endl;\n\tif (dist < d)\n\t{\n\t\tRES[ind] = 0;\n\t\treturn 0;\n\t}\n\t\n//\tdist = D[0][x] + c + D[1][y];\n//\tif (dist == d)\n//\t{\n//\t\tint par = UP[y][0];\n//\t\t\n//\t\tcout<<\"!! \"<<x<<' '<<y<<' '<<ind<<\": \"<<par<<' '<<ind + n<<endl;\n//\t\t\n//\t\tif (par == ind + n)\n//\t\t{\n//\t\t\tRES[ind] = 2;\n//\t\t\treturn 2;\n//\t\t}\n//\t}\n\t\n\tRES[ind] = 1;\n\treturn 1;\n}\n\nstring T[3] = {\"HAPPY\", \"SOSO\", \"SAD\"};\n\nint main()\n{\n//\tfreopen(\"in.txt\",\"r\", stdin);\n\t//ios::sync_with_stdio(false);cin.tie(0);\n\t\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tFOR (i, 0, m)\n\t{\n\t\tint x, y, c;\n\t\tscanf(\"%d%d%d\", &x, &y, &c);\n\t\tx--;\n\t\ty--;\n\t\t\n\t\tg[x].PB(MP(y, c));\n\t\tgr[y].PB(MP(x, c));\n\t\t\n\t\tI[x].PB(i);\n\t}\n\t\n\tFILL(RES, -1);\n\t\n\tdijk(g, D[0], 0);\n\tdijk(gr, D[1], 1);\n\t\n//\tFOR (i, 0, n)\n//\t{\n//\t\tcout<<D[0][i]<<' ';\n//\t}\n//\tcout<<endl;\n//\t\n//\tFOR (i, 0, n)\n//\t{\n//\t\tcout<<D[1][i]<<' ';\n//\t}\n//\tcout<<endl;\n\n\tFILL(UP, -1);\n\t\n\tbuild();\n\t\n//\tFOR (i, 0, n+m)\n//\t{\n//\t\tcout<<i<<\": \"<<UP[i][0]<<endl;\n//\t}\n\t\n\t::d = D[0][1];\n\t\n//\tcout<<check(0, 2, 5, 0)<<endl;\n//\treturn 0;\n\t\n\tFOR (i, 0, n)\n\t{\n\t\tFOR (j, 0, SZ(g[i]))\n\t\t{\n\t\t\tint to = g[i][j].first;\n\t\t\tint c = g[i][j].second;\n\t\t\t\n\t\t\tcheck(i, to, c, I[i][j]);\n\t\t}\n\t}\n\t\n\tint x = 1;\n\twhile(true)\n\t{\n\t\tif (UP[x][0] == x) break;\n\t\tx = UP[x][0];\n\t\t\n\t\tif (x >= n)\n\t\t{\n\t\t\tRES[x - n] = 2;\n\t\t}\n\t}\n\t\n\tFOR (i, 0, m)\n\t{\n\t\tprintf(\"%s\\n\", T[RES[i]].c_str());\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nvector<vector<pii> > G, rG;\nvector<vector<int> > I, rI;\nll C[100100], rC[100100];\nbool tmp[100100];\nbool bridge[100100];\nint lst[100100][3];\n\nvoid shortest(vector<vector<pii> > g, ll *c, int s) {\n\tfor(int i = 0; i < 100100; i++) {\n\t\tc[i] = 1e15;\n\t}\n\tc[s] = 0;\n\tpriority_queue<pli> q;\n\tq.push(pli(0,s));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(c[a.se] < -a.fi) continue;\n\t\tfor(int i = 0; i < g[a.se].size(); i++) {\n\t\t\tint v = g[a.se][i].fi;\n\t\t\tll t = -a.fi + g[a.se][i].se;\n\t\t\tif(c[v] > t) {\n\t\t\t\tc[v] = t;\n\t\t\t\tq.push(pli(-t, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mkbridge() {\n\tll sp = C[1];\n\tpriority_queue<pli> q;\n\tq.push(pli(0,0));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(tmp[a.se]) continue;\n\t\ttmp[a.se] = true;\n\t\tint id =-1;\n\t\tfor(int i = 0; i < G[a.se].size(); i++) {\n\t\t\tint v = G[a.se][i].fi;\n\t\t\tif(sp == C[a.se] + G[a.se][i].se + rC[v]) {\n\t\t\t\tq.push(pli(-C[v], v));\n\t\t\t\tid = I[a.se][i];\n\t\t\t}\n\t\t}\n\t\tif(q.size() == 1 && id >= 01) {\n\t\t\tbridge[id] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tG.resize(n);\n\trG.resize(n);\n\tI.resize(n);\n\trI.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tG[a].push_back(pii(b,c));\n\t\trG[b].push_back(pii(a,c));\n\t\tI[a].push_back(i);\n\t\trI[b].push_back(i);\n\t\tlst[i][0] = a; lst[i][1] = b; lst[i][2] = c;\n\t}\n\tshortest(G,C,0);\n\tshortest(rG,rC,1);\n\tmkbridge();\n\n\tll sp = C[1];\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = lst[i][0]; b = lst[i][1]; c = lst[i][2];\n\t\tif(C[b] + c + rC[a] < sp) {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t\telse if(bridge[i] && C[b] + c + rC[a] > sp && sp != (ll)(1e15)) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n\nconst ll INF = 1e15;\n\nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n\tdist[f->dst] = e.weight + f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\tprev[f->dst].clear();\n\tprev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n\tprev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n\nGraph buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  stack<int> st;\n  st.push(t);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    for(auto&& p : prev[now]){\n      if(p < 0)\n\tcontinue;\n      g[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return g;\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w == befo.first)\n\tmp[P(s, d)] = P(w-1, befo.second + 1);\n      else\n\tmp[P(s, d)] = P(min(w, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree = buildPath(prev, 1);\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n\n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n\n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n    \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    for(int i=0;i<tree[s].size();i++){\n      ok |= tree[s][i].dst == d;\n      //cout << \"tr: \" << tree[s][i].src << \" \" << tree[s][i].dst << endl;\n    }\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000021;\nconst long long inf = 1LL << 61;\nstruct edge { int to, cost, id; };\nstruct edge2 { int to, id; };\nstruct state { int pos; long long cost; };\nbool operator<(const state& s1, const state& s2) { return s1.cost > s2.cost; }\nint N, M, dp[100009], dp2[100009], va[100009]; bool vis1[100009], vis2[100009]; vector<int> a, b, c;\nvector<long long> shortest_path(vector<vector<edge> > g, int src) {\n\tvector<long long> ret(g.size(), inf); ret[src] = 0;\n\tpriority_queue<state> que; que.push(state{ src, 0 });\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (edge e : g[u]) {\n\t\t\tlong long nd = ret[u] + e.cost;\n\t\t\tif (ret[e.to] > nd) {\n\t\t\t\tret[e.to] = nd;\n\t\t\t\tque.push(state{ e.to, nd });\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvector<int> solve() {\n\tvector<vector<edge> > g(N);\n\tvector<vector<edge> > rg(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tg[a[i]].push_back(edge{ b[i], c[i], i });\n\t\trg[b[i]].push_back(edge{ a[i], c[i], i });\n\t}\n\tvector<long long> ds = shortest_path(g, 0);\n\tvector<long long> dt = shortest_path(rg, 1);\n\tvector<bool> ok(M);\n\tvector<vector<edge2> > sg(N), sr(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ds[a[i]] + c[i] + dt[b[i]] == ds[1]) {\n\t\t\tsg[a[i]].push_back(edge2{ b[i], i });\n\t\t\tsr[b[i]].push_back(edge2{ a[i], i });\n\t\t\tok[i] = true;\n\t\t}\n\t}\n\tfill(vis1, vis1 + N, false);\n\tfill(vis2, vis2 + N, false);\n\tfill(dp, dp + N, 0);\n\tfill(dp2, dp2 + N, 0);\n\tvector<int> dpm1(M), dpm2(M);\n\tpriority_queue<state> que; que.push(state{ 0, 0 }); dp[0] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis1[u]) {\n\t\t\tvis1[u] = true;\n\t\t\tfor (edge2 i : sg[u]) {\n\t\t\t\tdp[i.to] += dp[u];\n\t\t\t\tdpm1[i.id] = dp[u];\n\t\t\t\tif (dp[i.to] >= mod) dp[i.to] -= mod;\n\t\t\t\tque.push(state{ i.to, ds[i.to] });\n\t\t\t}\n\t\t}\n\t}\n\tque.push(state{ 1, 0 }); dp2[1] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis2[u]) {\n\t\t\tvis2[u] = true;\n\t\t\tfor (edge2 i : sr[u]) {\n\t\t\t\tdp2[i.to] += dp2[u];\n\t\t\t\tdpm2[i.id] = dp2[u];\n\t\t\t\tif (dp2[i.to] >= mod) dp2[i.to] -= mod;\n\t\t\t\tque.push(state{ i.to, dt[i.to] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) va[i] = 1LL * dp[i] * dp2[i] % mod;\n\tmap<tuple<int, int, int>, int> cnts;\n\tfor (int i = 0; i < M; i++) {\n\t\tcnts[make_tuple(a[i], b[i], c[i])]++;\n\t}\n\tvector<int> ret(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!ok[i]) {\n\t\t\tret[i] = (ds[b[i]] + dt[a[i]] + c[i] < ds[1] ? 2 : 1);\n\t\t}\n\t\telse {\n\t\t\tif (ds[b[i]] + dt[a[i]] + c[i] < ds[1]) ret[i] = 2;\n\t\t\telse if (ds[b[i]] + dt[a[i]] + c[i] == ds[1]) ret[i] = 1;\n\t\t\telse {\n\t\t\t\tif (1LL * dpm1[i] * dpm2[i] % mod == va[0] && cnts[make_tuple(a[i], b[i], c[i])] == 1) ret[i] = 0;\n\t\t\t\telse ret[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvector<int> brute_force() {\n\tvector<int> ret(M);\n\tvector<vector<edge> > ig(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tig[a[i]].push_back(edge{ b[i], c[i] });\n\t}\n\tlong long res = shortest_path(ig, 0)[1];\n\tif (res == inf) return { -1 };\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<vector<edge> > g(M);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i != j) g[a[j]].push_back(edge{ b[j], c[j] });\n\t\t\telse g[b[j]].push_back(edge{ a[j], c[j] });\n\t\t}\n\t\tlong long re = shortest_path(g, 0)[1];\n\t\tif (re < res) ret[i] = 2;\n\t\tif (re == res) ret[i] = 1;\n\t\tif (re > res) ret[i] = 0;\n\t}\n\treturn ret;\n}\nint rand_rng(int l, int r) {\n\tlong long seed = rand() * 123456789LL + rand() * 3456789LL + rand() * 12345LL;\n\treturn l + (seed) % (r - l);\n}\nvoid random_test() {\n\tN = 7; M = 7;\n\tfor (int i = 0; i < 10000; i++) {\n\t\ta = vector<int>(M);\n\t\tb = vector<int>(M);\n\t\tc = vector<int>(M);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\twhile (a[j] == b[j]) {\n\t\t\t\ta[j] = rand_rng(0, N);\n\t\t\t\tb[j] = rand_rng(0, N);\n\t\t\t}\n\t\t\tc[j] = rand_rng(1, 10);\n\t\t}\n\t\tvector<int> ret1 = brute_force();\n\t\tif (ret1[0] != -1) {\n\t\t\tvector<int> ret2 = solve();\n\t\t\tif (ret1 != ret2) {\n\t\t\t\tcout << \"BUG\" << endl;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t\tif (i % 100 == 99) cout << i + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\nint main() {\n\t//random_test();\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\ta = vector<int>(M);\n\tb = vector<int>(M);\n\tc = vector<int>(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t}\n\tvector<int> ret = solve();\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ret[i] == 2) cout << \"HAPPY\\n\";\n\t\telse if (ret[i] == 1) cout << \"SOSO\\n\";\n\t\telse cout << \"SAD\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream&\noperator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream&\noperator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());\n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(now.from >= 0)\n            shortest_graph[now.from].push_back(now.e);\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{-i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else {\n            if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i)) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\nconst ll INF=1e18;\nstruct HeapNode\n{\n    ll d;\n    int u;\n    bool operator<(const HeapNode &rhs)const\n    {\n        return d>rhs.d;\n    }\n};\nstruct Edge\n{\n    int from,to;\n    ll cost;\n};\nstruct Dij\n{\n    int n,m;\n    vector<int>G[maxn];\n    vector<int>G1[maxn];\n    vector<Edge>edges;\n    vector<Edge>edges1;\n    bool done[maxn];\n    ll d[maxn];\n    ll d1[maxn];\n    void init(int n)\n    {\n        this->n=n;\n        for(int i=0;i<=n;i++)\n        {\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    void addedge(int from,int to,int cost)\n    {\n        edges.push_back(Edge{from,to,cost});\n        edges1.push_back((Edge){to,from,cost});\n        m=edges.size();\n        G[from].push_back(m-1);\n        G1[to].push_back(m-1);\n    }\n    void dij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d[i]=INF;\n        d[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G[u].size();i++)\n            {\n                Edge &e=edges[G[u][i]];\n                if(d[e.to]>d[u]+e.cost)\n                {\n                    d[e.to]=d[u]+e.cost;\n                    Q.push((HeapNode){d[e.to],e.to});\n                }\n            }\n        }\n    }\n\n    void redij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d1[i]=INF;\n        d1[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G1[u].size();i++)\n            {\n                Edge &e=edges1[G1[u][i]];\n                //cout<<e.to<<endl;\n                if(d1[e.to]>d1[u]+e.cost)\n                {\n                    d1[e.to]=d1[u]+e.cost;\n                    Q.push((HeapNode){d1[e.to],e.to});\n                }\n            }\n        }\n    }\n}D;\n\nstruct node\n{\n    int x,y;\n    ll z;\n}s[maxn];\ntypedef pair<int,int>P;\nvector<P>G[maxn];\nint dfs_clock,pre[maxn],low[maxn];\nbool is_bridge[maxn];\nint dfs(int u,int fa)\n{\n    int lowu=pre[u]=++dfs_clock;\n    for(int i=0;i<G[u].size();i++)\n    {\n        int v=G[u][i].first;\n        if(!pre[v])\n        {\n            int lowv=dfs(v,u);\n            lowu=min(lowu,lowv);\n            if(lowv>pre[u])\n            {\n                is_bridge[G[u][i].second]=true;\n            }\n        }\n        else if(pre[v]<pre[u]&&fa!=v)\n            low[u]=min(low[u],pre[v]);\n    }\n    return low[u]=lowu;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    D.init(n);\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].z);\n        D.addedge(s[i].x,s[i].y,s[i].z);\n    }\n    D.dij(1);\n    D.redij(2);\n    for(int i=0;i<m;i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[x]+D.d1[y]+z==D.d[2])\n        {\n            G[x].push_back(make_pair(y,i));\n           // G[y].push_back(make_pair(x,i));\n        }\n    }\n    dfs(1,0);\n    for(int i=0;i<m;i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[y]+D.d1[x]+z<D.d[2])\n        {\n            printf(\"HAPPY\\n\");\n        }\n        else\n        {\n\n            if(D.d[x]+D.d1[y]+z==D.d[2]&&is_bridge[i])\n            {\n                printf(\"SAD\\n\");\n            }\n            else\n            {\n                printf(\"SOSO\\n\");\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<ll,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %lld\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tll tmp_code;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_code = edge[i].from*1000000+edge[i].to;\n\n\t\t\tauto at = MAP.find(tmp_code);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_code]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_code] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_code = edge[i].from*1000000+edge[i].to;\n\n\t\tif(MAP[tmp_code] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Ti = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(int to, int cost):to(to), cost(cost){}\n};\nusing Graph = vector<vector<edge>>;\n\nvint dijkstra(int s, const Graph& g) {\n  int n = g.size();\n  vint res(n, inf);\n  priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n  res[s] = 0;\n  que.emplace(0, s);\n  while(!que.empty()) {\n    Pi p = que.top(); que.pop();\n    int v = p.second;\n    if(res[v] < p.first) continue;\n    for(auto&& e : g[v]) {\n      if(res[v]+e.cost < res[e.to]) {\n\tres[e.to] = res[v]+e.cost;\n\tque.emplace(res[e.to], e.to);\n      }\n    }\n  }\n\n  return res;\n}\n\n#define MAX_N 100010\n\nint ord[MAX_N], low[MAX_N];\nvoid dfs(int u, int p, int k, const Graph& g) {\n  ord[u] = low[u] = k++;\n  for(auto&& e : g[u]) {\n    if(e.to == p) continue;\n    if(ord[e.to] == -1) {\n      dfs(e.to, u, k, g);\n      chmin(low[u], low[e.to]);\n    } else {\n      chmin(low[u], ord[e.to]);\n    }\n  }\n}\nbool is_bridge(int u, int v) {\n  if(ord[u] > ord[v]) swap(u, v);\n  return ord[u] < low[v];\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph rg(n);\n  vint a(m), b(m), c(m);\n  rep(i, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    --a[i], --b[i];\n    g[a[i]].emplace_back(b[i], c[i]);\n    rg[b[i]].emplace_back(a[i], c[i]);\n  }\n  vint d0 = dijkstra(0, g);\n  vint d1 = dijkstra(1, rg);\n  Graph h(n);\n  vint used(m, 0);\n  rep(i, m) {\n    //cout<<d0[a[i]]<<\" \"<<d1[b[i]]<<\" \"<<c[i]<<endl;\n    if(d0[a[i]]+d1[b[i]]+c[i] == d0[1]) {\n      h[a[i]].emplace_back(b[i], 0);\n      h[b[i]].emplace_back(a[i], 0);\n      used[i] = 1;\n    }\n  }\n  memset(ord, -1, sizeof(ord));\n  dfs(0, -1, 0, h);\n  rep(i, m) {\n    int d = d0[b[i]]+d1[a[i]]+c[i];\n    //cout<<d<<\" \"<<d0[1]<<endl;\n    if(d == d0[1]) {\n      cout << \"SOSO\" << endl;\n    } else if(d < d0[1]) {\n      cout << \"HAPPY\" << endl;\n    } else if(!used[i]) {\n      cout << \"SOSO\" << endl;\n    } else if(is_bridge(a[i], b[i])) {\n      cout << \"SAD\" << endl;\n    } else {\n      cout << \"SOSO\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define rep(i, j) for(ll i=0; i < (ll)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    ll index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<ll> enumerate_bridges(const EdgeList &E) {\n    ll N = E.size();\n    vector<ll> ord(N, -1), low(N);\n    ll cnt = 0;\n    set<ll> bridges;\n    function<void(ll, ll)> dfs = [&] (ll now, ll pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            ll nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    ll index;    \n    ll cost;\n    ll from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, ll start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n\n    rep(i, M) {\n        ll a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    // cerr << \"shortest path\" << endl;\n    // for(auto es : shortest_graph) {\n    //     for(Edge e : es) {\n    //         cerr << e.from + 1 << \" \" << e.to + 1 << endl;\n    //     }\n    // }\n    // debug(\"--\");\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n\n    // for(ll b : bridges) {\n    //     debug(b);\n    // }\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i)) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nvector<vector<pii> > G, rG;\nvector<vector<int> > I, rI;\nll C[100100], rC[100100];\nbool tmp[100100];\nbool bridge[100100];\nint lst[100100][3];\n\nvoid shortest(vector<vector<pii> > g, ll *c, int s) {\n\tfor(int i = 0; i < 100100; i++) {\n\t\tc[i] = 1e15;\n\t}\n\tc[s] = 0;\n\tpriority_queue<pli> q;\n\tq.push(pli(0,s));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(c[a.se] < -a.fi) continue;\n\t\tfor(int i = 0; i < g[a.se].size(); i++) {\n\t\t\tint v = g[a.se][i].fi;\n\t\t\tll t = -a.fi + g[a.se][i].se;\n\t\t\tif(c[v] > t) {\n\t\t\t\tc[v] = t;\n\t\t\t\tq.push(pli(-t, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mkbridge() {\n\tll sp = C[1];\n\tpriority_queue<pli> q;\n\tq.push(pli(0,0));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(tmp[a.se]) continue;\n\t\ttmp[a.se] = true;\n\t\tint id;\n\t\tfor(int i = 0; i < G[a.se].size(); i++) {\n\t\t\tint v = G[a.se][i].fi;\n\t\t\t//cout << C[a.se] << \",\" << rC[v] << \" \" << a.se << \",\" << v << \" \" << G[a.se][i].se << endl;\n\t\t\tif(sp == C[a.se] + G[a.se][i].se + rC[v]) {\n\t\t\t\tq.push(pli(-C[v], v));\n\t\t\t\tid = I[a.se][i];\n\t\t\t}\n\t\t}\n\t\tif(q.size() == 1) {\n\t\t\tbridge[id] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tG.resize(n);\n\trG.resize(n);\n\tI.resize(n);\n\trI.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n//\t\tcout << a << \",\" << b << \",\" << c << endl;\n\t\ta--; b--;\n\t\tG[a].push_back(pii(b,c));\n\t\trG[b].push_back(pii(a,c));\n\t\tI[a].push_back(i);\n\t\trI[b].push_back(i);\n\t\tlst[i][0] = a; lst[i][1] = b; lst[i][2] = c;\n//\tcout << \"piyo\" << endl;\n\t}\n\t//cout << \"hoge\" << endl;\n\tshortest(G,C,0);\n\tshortest(rG,rC,1);\n\t//cout << \"hoge\" << endl;\n\tmkbridge();\n\t//for(int i = 0; i < n; i++) cout << C[i] << \" \";cout << endl;\n\n\tll sp = C[1];\n\t//cout << \"+\" << C[0] << endl;\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = lst[i][0]; b = lst[i][1]; c = lst[i][2];\n\t\t//cout << C[b] << \",\" << c << \",\" << rC[a] << endl;\n\t\tif(C[b] + c + rC[a] < sp) {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t\telse if(bridge[i] && C[b] + c + rC[a] > sp) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n//\t\tcout << \"*\" << bridge[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mx 100009\n\nvector<int>edge[mx],cost[mx],ind[mx],redge[mx],rcost[mx];\n\nvector<int>dedge[mx],dind[mx],dredge[mx];\n\nstruct node\n{\n    int ind;\n    long long c;\n    node(){}\n    node(int _ind, long long int _c){\n        ind=_ind;\n        c=_c;\n    }\n    bool operator<(const struct node& a)const{\n        return c>a.c;\n    }\n};\n\nlong long int dist1[mx],dist2[mx];\nbool vs[mx];\n\nvoid dijkstra(int s, long long  dist[], int n, vector<int>edge[mx], vector<int> cost[mx])\n{\n    int i,v;\n    long long c,cc;\n    for(i=1;i<=n;i++){\n        dist[i]=1e16;\n        vs[i]=0;\n    }\n    node u;\n    priority_queue<node>pq;\n    dist[s]=0;\n    pq.push(node(s,0));\n\n    while(!pq.empty()){\n        u=pq.top();\n        pq.pop();\n        s=u.ind;\n        c=u.c;\n        if(vs[s]) continue;\n        vs[s]=1;\n\n        for(i=0;i<edge[s].size();i++){\n            v=edge[s][i];\n            cc=cost[s][i];\n            if(dist[v]>c+cc){\n                dist[v]=c+cc;\n                pq.push(node(v,dist[v]));\n            }\n        }\n    }\n}\n\nvoid make_dag(int n) ///dist1\n{\n    int s,i,v;\n    for(s=1;s<=n;s++){\n        for(i=0;i<edge[s].size();i++){\n            v=edge[s][i];\n            if(dist1[v]==dist1[s]+cost[s][i]){\n                dedge[s].push_back(v);\n\n                dredge[v].push_back(s);\n                dind[v].push_back(ind[s][i]);\n            }\n        }\n    }\n}\nvector<int>srl;\nvoid dagdfs(int s)\n{\n    int i,v;\n    vs[s]=1;\n    for(i=0;i<dedge[s].size();i++){\n        v=dedge[s][i];\n        if(!vs[v]){\n            //printf(\"%d to %d\\n\",s,v);\n            dagdfs(v);\n        }\n    }\n    srl.push_back(s);\n}\n\nvoid toposort(int n)\n{\n    srl.clear();\n    memset(vs,0,sizeof(vs));\n    dagdfs(1);\n}\n\nint res[mx]; // 0, +2 add, -2 less... memset to -1\n\nint kpr[mx][19];\nint lvl[mx];\n\nvoid updatelca(int s, int p)\n{\n    kpr[s][0]=p;\n    lvl[s]=lvl[p]+1;\n    for(int i=1;i<19;i++){\n        kpr[s][i]=kpr[kpr[s][i-1]][i-1];\n    }\n}\n\nint lca(int a, int b)\n{\n    if(lvl[a]<lvl[b]){\n        swap(a,b);\n    }\n\n    int l=lvl[a]-lvl[b];\n\n    for(int i=18;i>=0;i--){\n        if((l&(1<<i))){\n            a=kpr[a][i];\n        }\n    }\n    if(a==b)\n        return a;\n    for(int i=18;i>=0;i--){\n        if(kpr[a][i]!=kpr[b][i]){\n            a=kpr[a][i];\n            b=kpr[b][i];\n        }\n    }\n    assert(kpr[a][0]==kpr[b][0]);\n    return kpr[a][0];\n}\n\nvoid path()\n{\n    int s,i;\n    for(s=2;s!=1 && s;s=kpr[s][0]){\n        //printf(\"s %d\\n\",s);\n        for(int i=0;i<dredge[s].size();i++){\n            if(kpr[s][0]==dredge[s][i]){\n                res[dind[s][i]]=+2;\n            }\n        }\n    }\n}\n\nvoid make_domtree(int n)\n{\n    dijkstra(1,dist1,n,edge,cost);\n    dijkstra(2,dist2,n,redge,rcost);\n\n    make_dag(n);\n\n    toposort(n);\n\n    reverse(srl.begin(),srl.end());\n\n    for(int j=0;j<srl.size();j++){\n        int s=srl[j];\n        //printf(\"s %d\\n\",s);\n        if(dredge[s].size()==0){\n            lvl[s]=1;\n            continue;\n        }\n        int p=dredge[s][0];\n        for(int i=1;i<dredge[s].size();i++){\n            p=lca(p,dredge[s][i]);\n            //printf(\"->%d\\n\",dredge[s][i]);\n        }\n        if(s!=p){\n            updatelca(s,p);\n            //printf(\"dom %d to %d\\n\",s,p);\n        }\n    }\n}\n\nint main()\n{\n    int n,m,a,b,c,i;\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        scanf(\"%d %d %d\",&a,&b,&c);\n        edge[a].push_back(b);\n        redge[b].push_back(a);\n\n        cost[a].push_back(c);\n        rcost[b].push_back(c);\n\n        ind[a].push_back(i);\n    }\n    //printf(\"..\\n\");\n\n    memset(res,-1,sizeof(res));\n    make_domtree(n);\n    path();\n    //printf(\"..\\n\");\n    int s,v;\n\n    for(s=1;s<=n;s++){\n        for(i=0;i<edge[s].size();i++){\n            if(~res[ind[s][i]])\n                continue;\n            v=edge[s][i];\n            c=cost[s][i]; //s to v, so 1-v, +c + v-c\n\n            if(dist1[v]+c+dist2[s]<dist1[2]){\n                res[ind[s][i]]=-2;\n            }\n            else if(dist1[v]+c+dist2[s]==dist1[2]){\n                res[ind[s][i]]=0;\n            }\n            else{\n                res[ind[s][i]]=0;\n            }\n        }\n    }\n    for(i=1;i<=m;i++){\n        if(res[i]==0)\n            printf(\"SOSO\\n\");\n        else if(res[i]==-2)\n            printf(\"HAPPY\\n\");\n        else\n            printf(\"SAD\\n\");\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge{\n\tedge(){}\n\tedge(ll from, ll to, ll cost, ll id) :from(from), to(to), cost(cost), id(id){}\n\tll from, to, cost, id;\n};\n\nedge es[100000];\nusing Graph = vector<vector<edge>>;\n\nint N, M;\n\nconst ll INF = 1LL << 55;\n\nvoid dijkstra(int s, const Graph& g, vector<ll>& dist){\n\tusing P = pair<ll, int>;\n\tdist = vector<ll>(N, INF);\n\tdist[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push({ 0, s });\n\twhile(q.size()){\n\t\tll d = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tfor(auto e : g[v]){\n\t\t\tif(dist[e.to] > d + e.cost){\n\t\t\t\tdist[e.to] = d + e.cost;\n\t\t\t\tq.push({ d + e.cost, e.to });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint use[100000];\nint bri[100000];\n\nusing Pii = pair<int, int>;\n\nstd::pair<std::vector<int>, vector<Pii>> bridge(const Graph& g){\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tstd::vector<int> ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tvector<Pii> brdg;\n\tstd::function<void(int, int)> dfs = [&](int v, int u){\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor(auto& e : g[v]){\n\t\t\tint w = e.to;\n\t\t\tif(ord[w] == -1)\n\t\t\t\tdfs(w, v);\n\t\t\telse if(u != w && onS[w])\n\t\t\t\twhile(ord[roots[t - 1]] > ord[w]) --t;\n\t\t}\n\t\tif(v == roots[t - 1]){\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile(1){\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif(v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor(int u = 0; u < n; u++){\n\t\tif(ord[u] == -1){\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn std::make_pair(cmp, brdg);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> N >> M;\n\n\tGraph G(N), Gr(N);\n\tfor(int i = 0; i < M; i++){\n\t\tll u, v, cost;\n\t\tcin >> u >> v >> cost;\n\t\tu--, v--;\n\t\tes[i] = edge(u, v, cost, i);\n\t\tG[u].push_back(edge(u, v, cost, i));\n\t\tGr[v].push_back(edge(v, u, cost, i));\n\t}\n\n\tvector<ll> d(N), dr(N);\n\tdijkstra(0, G, d);\n\tdijkstra(1, Gr, dr);\n\n\tll dist = d[1];\n\tGraph G2(N);\n\tmap<Pii, int> idmap;\n\tfor(int i = 0; i < M; i++){\n\t\tedge e = es[i];\n\t\tll dd = d[e.from] + e.cost + dr[e.to];\n\t\tif(dist == dd){\n\t\t\tuse[i] = 1;\n\t\t\tG2[e.from].push_back(e);\n\t\t\tidmap[{e.from, e.to}] = i;\n\t\t}\n\t}\n\n\tauto res = bridge(G2);\n\tfor(auto p : res.second){\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tif(idmap.count(p)){\n\t\t\t\tbri[idmap[p]] = 1;\n\t\t\t}\n\t\t\tswap(p.first, p.second);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(!use[i]){\n\t\t\tedge e = es[i];\n\t\t\tll dd = d[e.to] + e.cost + dr[e.from];\n\t\t\tif(dist > dd){\n\t\t\t\tcout << \"HAPPY\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"SOSO\" << endl;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(bri[i]){\n\t\t\t\tcout << \"SAD\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"SOSO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n\nconst ll INF = 1e15;\n\nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n\tdist[f->dst] = e.weight + f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\tprev[f->dst].clear();\n\tprev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n\tprev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n\npair<Graph, Graph> buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  Graph g2(n);\n  stack<int> st;\n  st.push(t);\n  vector<int> visited(n);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    if(visited[now])\n      continue;\n    visited[now] = true;\n    for(auto&& p : prev[now]){\n      if(p < 0)\n\tcontinue;\n      g[p].push_back(Edge(p, now, 1));\n      g2[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return pair<Graph, Graph>(g, g2);\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  n += 100;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w*2, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w*2 == befo.first)\n\tmp[P(s, d)] = P(w*2-1, befo.second + 1);\n      else\n\tmp[P(s, d)] = P(min(w*2, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree, tree2;\n  tie(tree, tree2) = buildPath(prev, 1);\n  for(int i=0;i<tree2.size();i++){\n    sort(tree2[i].begin(), tree2[i].end());\n  }\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n\n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n\n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n    \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w*2)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    ok |= binary_search(tree2[s].begin(), tree2[s].end(), Edge(s, d, 1));\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}\n/*\n11 15\n1 3 1\n3 6 2\n6 10 1\n1 5 3\n3 7 1\n5 9 1\n9 11 1\n7 8 1\n1 4 2\n4 8 1\n8 10 1\n10 11 1\n11 2 1\n10 7 1\n10 1 1\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n    map<int, map<int, pii>> min_edge_num;\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n        if(!min_edge_num[a].count(b)) min_edge_num[a][b] = make_pair(0, 1e9);\n        if(min_edge_num[a][b].second > c) {\n            min_edge_num[a][b] = make_pair(1, c);\n        } else if(min_edge_num[a][b].second == c) {\n            min_edge_num[a][b].first++;\n        }\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    // cerr << \"shortest path\" << endl;\n    // for(auto es : shortest_graph) {\n    //     for(Edge e : es) {\n    //         cerr << e.from + 1 << \" \" << e.to + 1 << endl;\n    //     }\n    // }\n    // debug(\"--\");\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n\n    // for(int b : bridges) {\n    //     debug(b);\n    // }\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and min_edge_num[e.from][e.to].first == 1) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\n#define INF 0x7f7f7f7f\nconst int maxed = 100000 + 10;\ntypedef long long ll;\n\nstruct Node\n{\n    int u;\n    ll val;\n    bool operator < (const Node& n1) const\n    {\n        return val > n1.val;\n    }\n};\nstruct E\n{\n    int u, v, val, bef, id;\n}e[maxed * 2][3];\n\nint n, m, ans[3], head[maxed][3];\nll d[maxed][2];\nbool vis[maxed];\nint cnt, pre[maxed], low[maxed], dfn[maxed];\nbool is_cut[maxed];\n\nvoid add_(int x, int y, int val, int id, int cur);\nvoid slove(int s, int cur);\nvoid tarjan(int u, int fa);\n\nint main()\n{\n    ans[0] = ans[1] = ans[2] = 1;\n    memset(head, -1, sizeof(head));\n    scanf(\"%d%d\", &n, &m);\n    int a, b, c;\n    for (int i = 1; i <= m; ++i) {\n        scanf(\"%d%d%d\", &a, &b, &c);\n        add_(a, b, c, i, 0);\n        add_(b, a, c, i, 1);\n    }\n    for (int i = 1; i <= n; ++i)\n        d[i][0] = INF, d[i][1] = INF;\n    slove(1, 0);\n    slove(2, 1);\n    for (int i = 1; i < ans[0]; ++i)\n        if (d[e[i][0].u][0] + e[i][0].val + d[e[i][0].v][1] == d[2][0]) {\n            add_(e[i][0].u, e[i][0].v, e[i][0].val, e[i][0].id, 2);\n            add_(e[i][0].v, e[i][0].u, e[i][0].val, e[i][0].id, 2);\n        }\n    tarjan(1, 1);\n    for (int i = 1; i < ans[2]; ++i)\n        if (pre[e[i][2].u] == e[i][2].v && dfn[e[i][2].v] < low[e[i][2].u])\n            is_cut[e[i][2].id] = true;\n    for (int i = 1; i < ans[0]; ++i) {\n        if (d[e[i][0].u][0] + e[i][0].val + d[e[i][0].v][1] == d[2][0]) {\n            if (is_cut[e[i][0].id])\n                printf(\"SAD\\n\");\n            else {\n                if (d[e[i][0].v][0] + e[i][0].val + d[e[i][0].u][1] < d[2][0])\n                    printf(\"HAPPY\\n\");\n                else\n                    printf(\"SOSO\\n\");\n            }\n        }\n        else {\n            if (d[e[i][0].v][0] + e[i][0].val + d[e[i][0].u][1] < d[2][0])\n                printf(\"HAPPY\\n\");\n            else\n                printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\nvoid add_(int x, int y, int val, int id, int cur)\n{\n    e[ans[cur]][cur].u = x;\n    e[ans[cur]][cur].v = y;\n    e[ans[cur]][cur].val = val;\n    e[ans[cur]][cur].id = id;\n    e[ans[cur]][cur].bef = head[x][cur];\n    head[x][cur] = ans[cur]++;\n}\n\nvoid slove(int s, int cur)\n{\n    memset(vis, false, sizeof(vis));\n    std::priority_queue<Node> pq;\n    pq.push((Node){s, 0});\n    d[s][cur] = 0;\n    while (!pq.empty()) {\n        Node no = pq.top();\n        pq.pop();\n        if (vis[no.u])\n            continue;\n        vis[no.u] = true;\n        for (int i = head[no.u][cur]; i != -1; i = e[i][cur].bef) {\n            int v = e[i][cur].v;\n            ll val = d[no.u][cur] + e[i][cur].val;\n            if (d[v][cur] > val) {\n                d[v][cur] = val;\n                pq.push((Node){v, val});\n            }\n        }\n    }\n}\n\nvoid tarjan(int u, int fa)\n{\n    pre[u] = fa;\n    dfn[u] = low[u] = ++cnt;\n    for (int i = head[u][2]; i != -1; i = e[i][2].bef) {\n        int v = e[i][2].v;\n        if (!dfn[v]) {\n            tarjan(v, u);\n            low[u] = std::min(low[u], low[v]);\n        }\n        else if (v != fa)\n            low[u] = std::min(low[u], dfn[v]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 58;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int Soso  = 1;\nconst int Happy = 2;\nconst int Sad   = 3;\n\nusing Edge = tuple<int, int, int>;\n\nvll dijkstra(vector<vector<Edge>>& G, int sv){\n    int n = G.size();\n    vll min_dist(n, inf);\n    min_dist[sv] = 0;\n\n    using Elem = tuple<ll, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    q.push(Elem(0, sv));\n\n    while(q.size()){\n        ll c; int v; tie(c, v) = q.top(); q.pop();\n        if(min_dist[v] != c) continue;\n\n        for(auto& e : G[v]){\n            int nv, dc, ei; tie(nv, dc, ei) = e;\n            ll nc = c + dc;\n            if(chmin(min_dist[nv], nc)){\n                q.push(Elem(nc, nv));\n            }\n        }\n    }\n    return min_dist;\n}\n\nint depthMax;\nvi etype;\nvi depth;\nvi used;\nvi path;\nvi imo;\nvi oute;\n\nbool dfs(vector<vector<Edge>>& G, int v, int tv, int d){\n    if(v == tv){\n        path.emplace_back(v);\n        depth[v] = d;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(dfs(G, nv, tv, d + 1)){\n            path.emplace_back(v);\n            depth[v] = d;\n            used[ei] = true;\n            oute.emplace_back(ei);\n            return true;\n        }\n    }\n    return false;\n}\n\nvi visited;\nvoid dfs2(vector<vector<Edge>>& G, int v, int d){\n    if(depth[v] > d){\n        imo[d]++;\n        imo[depth[v]]--;\n        return;\n    }\n    if(depth[v] == -1) visited[v] = true;\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(visited[nv]) continue;\n        if(used[ei]){\n            assert(oute[d] == ei);\n            continue;\n        }\n        dfs2(G, nv, d);\n    }\n\n    if(d < depthMax - 1){\n        dfs2(G, path[d + 1], d + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m; cin >> n >> m;\n    vector<vector<Edge>> G(n), Gr(n);\n    vi as(m), bs(m), cs(m);\n    rep(i, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        G [a].emplace_back(Edge(b, c, i));\n        Gr[b].emplace_back(Edge(a, c, i));\n        as[i] = a, bs[i] = b, cs[i] = c;\n    }\n\n    int sv = 0, tv = 1;\n    auto min_dist     = dijkstra(G, sv);\n    auto min_dist_rev = dijkstra(Gr, tv);\n\n    etype = vi(m, Soso);\n\n    vector<vector<Edge>> Gs(n);\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[a] + c == min_dist[b]){\n            Gs[a].emplace_back(Edge(b, c, i));\n        }\n    }\n    depth = vi(n, -1);\n    used  = vi(m);\n    dfs(Gs, sv, tv, 0);\n    reverse(_all(path));\n    reverse(_all(oute));\n    depthMax = path.size();\n\n    // for(auto& e : path) cerr << e+1 << \" \"; cerr << endl;\n    // for(auto& e : oute) cerr << e+1 << \" \"; cerr << endl;\n\n    imo = vi(depthMax);\n    visited = vi(n);\n    dfs2(Gs, sv, 0);\n    rep(i, 1, depthMax) imo[i] += imo[i - 1];\n    rep(i, depthMax - 1){\n        if(imo[i] == 0){\n            etype[oute[i]] = Sad;\n        }\n    }\n\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[b] + min_dist_rev[a] + c < min_dist[tv]){\n            etype[i] = Happy;\n        }\n    }\n\n    rep(i, m){\n        string res = \"SOSO\";\n        if(etype[i] == Happy){\n            res = \"HAPPY\";\n        }\n        else if(etype[i] == Sad){\n            res = \"SAD\";\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pi pair<ll, int>\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\n#define ll long long\n\nconst int N = (int)2e5 + 10;\n\nint gi(){\n\tchar c = getchar(); int ret = 0;\n\twhile (!isdigit(c)) c = getchar();\n\twhile (isdigit(c)){\n\t\tret = ret * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\treturn ret;\n}\n\nint n, m, edge[N][2], c[N];\nint cnt[2], lst[2][N], to[2][N], nxt[2][N], w[2][N];\n\nvoid add(int u, int v, int c){\n\tnxt[0][++ cnt[0]] = lst[0][u]; lst[0][u] = cnt[0]; to[0][cnt[0]] = v; w[0][cnt[0]] = c;\n\tnxt[1][++ cnt[1]] = lst[1][v]; lst[1][v] = cnt[1]; to[1][cnt[1]] = u; w[1][cnt[1]] = c;\n}\n\nll dis[2][N]; // 0: 1 -> i; 1: i -> 2;\nbool vis[N]; priority_queue<pi > Q;\nconst ll inf = 1LL << 60;\nvoid djkstra(int s, ll *dis, int *lst, int *nxt, int *to, int *w){\n\tfor (int i = 1; i <= n; i ++) dis[i] = inf;\n\tdis[s] = 0;\n\n\tmemset(vis, 0, sizeof(vis));\n\twhile (Q.size()) Q.pop();\n\tQ.push(mp(-dis[s], s));\n\n\twhile (Q.size()){\n\t\tint u = Q.top().se;\n\t\tQ.pop();\n\t\tif (vis[u]) continue;\n\t\tvis[u] = 1;\n\n\t\tfor (int j = lst[u]; j; j = nxt[j]){\n\t\t\tint v = to[j];\n\t\t\tif (vis[v]) continue;\n\t\t\tif (dis[v] > dis[u] + w[j]){\n\t\t\t\tdis[v] = dis[u] + w[j];\n\t\t\t\tQ.push(mp(-dis[v], v));\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nll ans; int pre[N];\n\nint main()\n{\n\n\tn = gi(); m = gi();\n\tfor (int i = 1; i <= m; i ++){\n\t\t//scanf(\"%d %d %d\", edge[i] + 0, edge[i] + 1, c + i);\n\t\tedge[i][0] = gi(); edge[i][1] = gi(); c[i] = gi();\n\t\tadd(edge[i][0], edge[i][1], c[i]); \n\t}\n\n\tdjkstra(1, dis[0], lst[0], nxt[0], to[0], w[0]);\n\tdjkstra(2, dis[1], lst[1], nxt[1], to[1], w[1]);\n\n\t\n\tans = dis[0][2];\n\t\n\tfor (int u = 1; u <= n; u ++){\n\t\tfor (int j = lst[0][u]; j; j = nxt[0][j]){\n\t\t\tint v = to[0][j];\n\t\t\tif (dis[0][u] + w[0][j] + dis[1][v] == ans) pre[u] ++; \n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= m; i ++){\n\t\tint u = edge[i][0], v = edge[i][1];\n\t\tif (dis[0][u] + c[i] + dis[1][v] == ans){\n\t\t\tll ret = dis[0][v] + c[i] + dis[1][u];\n\t\t\t\n\t\t\tif (pre[u] > 1){\n\t\t\t\tif (ret < ans) puts(\"HAPPY\");\n\t\t\t\telse puts(\"SOSO\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (ret < ans) puts(\"HAPPY\");\n\t\t\t\telse puts(\"SAD\");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tll ret = dis[0][v] + c[i] + dis[1][u];\n\t\t\tif (ret < ans) puts(\"HAPPY\");\n\t\t\telse puts(\"SOSO\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<tuple>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\n#define INF 0x3f3f3f3f\n#define eps 1e-8\nusing namespace std;\ntypedef long long ll;\n\nint n,m,a,b,x;\nstruct graph\n{\n    int from[maxn],to[maxn],no;\n    int head[maxn],nxt[maxn],val[maxn];\n    ll dis[maxn];\n    bool vis[maxn];\n    void init()\n    {\n        memset(head,-1,sizeof(head));\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<=n;i++)dis[i]=INF;\n        no=0;\n    }\n    void add(int a,int b,int x)\n    {\n        from[no]=a,to[no]=b;\n        val[no]=x;\n        nxt[no]=head[a];\n        head[a]=no++;\n    }\n    void spfa(int st)\n    {\n        queue<int>q;\n        vis[st]=1,dis[st]=0;\n        q.push(st);\n        while(!q.empty())\n        {\n            int u=q.front();\n            q.pop();\n            vis[u]=0;\n            for(int i=head[u];i!=-1;i=nxt[i])\n            {\n                int v=to[i];\n                if(dis[v]>dis[u]+val[i])\n                {\n                    dis[v]=dis[u]+val[i];\n                    if(!vis[v])\n                    {\n                        vis[v]=1;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n}G,opG;\n\nstruct node\n{\n    int to[maxn],nxt[maxn],head[maxn],vis[maxn];\n    int dfn[maxn],low[maxn],pre[maxn],val[maxn];\n    int dep,no;\n    map< tuple<int,int,int>,int >mo;\n    void init()\n    {\n        memset(vis,0,sizeof(vis));\n        memset(head,-1,sizeof(head));\n        memset(dfn,-1,sizeof(dfn));\n        memset(low,-1,sizeof(low));\n        no=dep=0;\n    }\n    void add(int a,int b,int x)\n    {\n        val[no]=x;\n        to[no]=b;\n        nxt[no]=head[a];\n        head[a]=no++;\n    }\n    void tarjan(int u,int fa)\n    {\n        dfn[u]=low[u]=++dep;\n        vis[u]=1;\n        for(int i=head[u];i!=-1;i=nxt[i])\n        {\n            int v=to[i];\n            if(!vis[v])\n            {\n                tarjan(v,u);\n                low[u]=min(low[u],low[v]);\n                if(dfn[u]<low[v])\n                {\n                    if(u<v)mo[make_tuple(u,v,val[i])]++;\n                    else mo[make_tuple(v,u,val[i])]++;\n                }\n            }\n            else if(fa!=v)\n                low[u]=min(low[u],dfn[v]);\n        }\n    }\n}DAG;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    G.init(),opG.init();\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&a,&b,&x);\n        G.add(a,b,x);\n        opG.add(b,a,x);\n    }\n    G.spfa(1);\n    opG.spfa(2);\n    DAG.init();\n    /*for(int i=1;i<=n;i++)\n        cout<<G.dis[i]<<\" \";\n    cout<<endl;\n    for(int i=1;i<=n;i++)\n        cout<<opG.dis[i]<<\" \";\n    cout<<endl;*/\n    for(int i=0;i<m;i++)\n    {\n        int u=G.from[i];\n        int v=G.to[i];\n        int w=G.val[i];\n        if(G.dis[u]+w+opG.dis[v]==G.dis[2])\n        {\n            DAG.add(u,v,w);\n            //cout<<u<<\" \"<<v<<endl;\n        }\n    }\n    //cout<<endl;\n    DAG.tarjan(1,0);\n    for(int i=0;i<m;i++)\n    {\n        int u=G.from[i];\n        int v=G.to[i];\n        int w=G.val[i];\n        if(G.dis[v]+w+opG.dis[u]<G.dis[2])\n            printf(\"HAPPY\\n\");\n        else\n        {\n            if(u>v)swap(u,v);\n            if(DAG.mo[make_tuple(u,v,w)])\n                printf(\"SAD\\n\");\n            else printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, 1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    cnt[v] += p;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, cnt[v] });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && cnt1[u] * cnt2[v] == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Bridges */\n\nint bridges_dfs(int now, int backID, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n  \n  visited[now] = 1;\n  \n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == backID) continue;\n    \n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n  \n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n\nvector<bool> bridges(int n, const vector<pair<int,int> > &path){ //無向辺 & 多重辺考慮\n  vector<vector<pair<int,int> > >  way(n);\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n  \n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n  \n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n  \n  return bridges_flag;\n}\n\n\n\nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE], c[SIZE];\n  vector<int> way[SIZE], rway[SIZE];\n  \n  scanf(\"%d%d\",&n,&m);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n\n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n\n  //Dijkstra\n  priority_queue<pair<ll,int> > pq;\n  bool visited[SIZE] = {}, rvisited[SIZE];\n  ll cost[SIZE], rcost[SIZE];\n  \n  pq.push({0,0});\n\n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n\n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n\n  pq.push({0,1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n\n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n\n  vector<pair<int,int> > Graph;\n  vector<int> pathID;\n  bool visited2[SIZE] = {};\n\n  pq.push({cost[1], 1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    int cur_cost = p.first;\n\n    if(visited2[now]) continue;\n    visited2[now] = true;\n    \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n      }\n    }\n  }\n\n  auto res = bridges(n, Graph);\n  bool isBridge[SIZE] = {};\n\n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n  \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, m, reachable[111111];\nint dist[111111], ans[111111], low[111111], num[111111], N;\nvector<vector<tuple<int,int,int>>> e, g;\n\nvoid rec(int cur, int pid){\n\tnum[cur] = low[cur] = ++N;\n\tvector<tuple<int,int,int>> es;\n\tfor(auto p : g[cur]){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\tif(id == pid) continue;\n\t\tif(num[to] == 0){\n\t\t\trec(to, id);\n\t\t\tlow[cur] = min(low[cur], low[to]);\n\t\t\tes.emplace_back(p);\n\t\t}\n\t\telse low[cur] = min(low[cur], num[to]);\n\t}\n\tfor(auto p : es){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t//dbg(cur, to, num[cur], low[to]);\n\t\tif(low[to] > num[cur]) ans[id] = 1;\n\t}\n}\nint reachablility(int cur, int pid){\n\tif(cur == 1) return reachable[cur] = 1;\n\tif(reachable[cur] != -1) return reachable[cur];\n\t\n\tfor(auto p : e[cur]){\n\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\tif(pid == id) continue;\n\t\tif(dist[to] == dist[cur] + cost && reachablility(to, id)) return reachable[cur] = 1;\n\t}\n\treturn reachable[cur] = 0;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m;\n\te.resize(n); g.resize(n);\n\trep(i, m){\n\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\te[a].emplace_back(b, c, i);\n\t}\n\t{\n\t\tpriority_queue<pi> q;\n\t\tq.emplace(0, 0);\n\t\trep(i, n) dist[i] = inf;\n\t\tdist[0] = 0;\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tint c, co;\n\t\t\ttie(co, c) = q.top(); q.pop();\n\t\t\tif(dist[c] < -co) continue;\n\t\t\t\n\t\t\tfor(auto to : e[c]){\n\t\t\t\tint nco = -co + get<1>(to);\n\t\t\t\tif(dist[get<0>(to)] <= nco) continue;\n\t\t\t\tdist[get<0>(to)] = -co + get<1>(to);\n\t\t\t\tq.emplace(co - get<1>(to), get<0>(to));\n\t\t\t}\n\t\t}\n\t\trep(i, n) reachable[i] = -1;\n\t\treachablility(0, -1);\n\t\t//rep(i, n) dbg(i, reachable[i]);\n\t}\n\t{\n\t\trep(i, n) for(auto p : e[i]){\n\t\t\tint to, cost, id; tie(to, cost, id) = p;\n\t\t\tif(reachable[i] != 1 || reachable[to] != 1) continue;\n\t\t\tif(dist[i] > dist[to] + cost) ans[id] = -1;\n\t\t\tif(dist[to] == dist[i] + cost){\n\t\t\t\tg[to].emplace_back(i, cost, id);\n\t\t\t\tg[i].emplace_back(to, cost, id);\n\t\t\t\t//dbg(i, to, id);\n\t\t\t}\n\t\t}\n\t\trec(0, -1);\n\t\trep(i, m){\n\t\t\tif(ans[i] < 0) cout << \"HAPPY\" << endl;\n\t\t\telse cout << (ans[i] == 0 ? \"SOSO\" : \"SAD\") << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> i_i;\n\nvector< pair<int, int> > lowlink(const vector< vector<int> >& g) {\n    int n = g.size();\n    vector<int> ord(n, -1), low(n, -1);\n    vector < pair<int, int> > bridges;\n    int t = 0;\n    auto dfs = [&](auto& F, int v, int p) -> void {\n        ord[v] = low[v] = t++;\n        int d = 0;\n        bool f = false;\n        for (int w : g[v]) if (w != p) {\n            if (ord[w] == -1) {\n                F(F, w, v);\n                low[v] = min(low[v], low[w]);\n                f |= ord[v] <= low[w];\n                if (ord[v] < low[w]) bridges.emplace_back(minmax(v, w));\n                ++d;\n            } else {\n                low[v] = min(low[v], ord[w]);\n            }\n        }\n    };\n    dfs(dfs, 0, -1);\n    sort(begin(bridges), end(bridges));\n    return bridges;\n}\n\ntypedef pair<ll, ll> l_l;\nvector<l_l> paths[100500][2];\nll N, M;\nll dist[100500][2];\nll a[100500], b[100500], c[100500];\nvector<vector<int>> G;\nvector<l_l> costs[100500];\nbool chmin(ll &a, ll b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nvoid Dijkstra(int s, int index) {\n    for(int i = 0; i < N; i++) {\n        dist[i][index] = 1e18;\n    }\n    dist[s][index] = 0;\n    priority_queue<l_l, vector<l_l>, greater<l_l>> que;\n    que.push({0, s});\n    while(!que.empty()) {\n        l_l now = que.top();\n        que.pop();\n        ll pos = now.second;\n        ll nowcost = now.first;\n        if(now.first != dist[pos][index]) continue;\n        for(auto e : paths[pos][index]) {\n            ll newcost = nowcost + e.second;\n            ll to = e.first;\n            if(chmin(dist[to][index], newcost)) {\n                que.push({newcost, to});\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> N >> M;\n    for(int i = 0; i < M; i++) {\n        cin >> a[i] >> b[i] >> c[i];\n        a[i]--;\n        b[i]--;\n        paths[a[i]][0].push_back({b[i], c[i]});\n        paths[b[i]][1].push_back({a[i], c[i]});\n    }\n    Dijkstra(0, 0);\n    Dijkstra(1, 1);\n    /*\n    for(int i = 0; i < N; i++) {\n        for(auto e : paths[i][0]) {\n            ll to = e.first;\n            ll cost = dist[i][0] + e.second + dist[to][1];\n            costs[i].push_back({cost, to});\n        }\n        sort(costs[i].begin(), costs[i].end());\n        cerr << \"--\" << i << \"---\" << endl;\n        for(auto val : costs[i]) {\n            cerr << val.second << \" \" << val.first << endl;\n        }\n    }\n    */\n   /*\n    ll Default = dist[2][0];\n    for(int i = 1; i <= M; i++) {\n        if(cost[i])\n        ll ans = 2e18;\n        ll now = dist[b[i]][0];\n        now += c[i];\n        now += dist[a[i]][1];\n        chmin(ans, now);\n\n    }\n    */\n    //for(int i = 0; i < N; i++) cerr << dist[i][0] << endl;\n    //for(int i = 0; i < N; i++) cerr << dist[i][1] << endl;\n    G.resize(N);\n    for(int i = 0; i < M; i++) {\n        ll nowcost = dist[a[i]][0] + c[i] + dist[b[i]][1];\n        if(nowcost == dist[1][0]) {\n            G[a[i]].push_back(b[i]);\n            G[b[i]].push_back(a[i]);\n            //cerr << a[i] << \" \" << b[i] << endl;\n        }\n    }\n    vector< pair<int, int> > bridges = lowlink(G);\n    set<i_i> st;\n    st.insert({-1, -1});\n    for(auto e : bridges) {\n        st.insert(e);\n        swap(e.first, e.second);\n        st.insert(e);\n        //cerr << e.first << \" \" << e.second << endl;\n    }\n    for(int i = 0; i < M; i++) {\n        ll newcost = dist[b[i]][0] + c[i] + dist[a[i]][1];\n        if(newcost < dist[1][0]) {\n            cout << \"HAPPY\" << endl;\n            continue;\n        }\n        if(newcost == dist[1][0]) {\n            cout << \"SOSO\" << endl;\n            continue;\n        }\n        if(dist[a[i]][0] + c[i] + dist[b[i]][1] == dist[0][1]) {\n            if(st.find({a[i], b[i]}) != st.end()) {\n                cout << \"SAD\" << endl;\n                continue;\n            }\n        }\n        cout << \"SOSO\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 58;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int Soso  = 1;\nconst int Happy = 2;\nconst int Sad   = 3;\n\nusing Edge = tuple<int, int, int>;\n\nvll dijkstra(vector<vector<Edge>>& G, int sv){\n    int n = G.size();\n    vll min_dist(n, inf);\n    min_dist[sv] = 0;\n\n    using Elem = tuple<ll, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    q.push(Elem(0, sv));\n\n    while(q.size()){\n        ll c; int v; tie(c, v) = q.top(); q.pop();\n        if(min_dist[v] != c) continue;\n\n        for(auto& e : G[v]){\n            int nv, dc, ei; tie(nv, dc, ei) = e;\n            ll nc = c + dc;\n            if(chmin(min_dist[nv], nc)){\n                q.push(Elem(nc, nv));\n            }\n        }\n    }\n    return min_dist;\n}\n\nint depthMax;\nvi etype;\nvi depth;\nvi used;\nvi path;\nvi imo;\nvi oute;\n\nbool dfs(vector<vector<Edge>>& G, int v, int tv, int d){\n    if(v == tv){\n        path.emplace_back(v);\n        depth[v] = d;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(dfs(G, nv, tv, d + 1)){\n            path.emplace_back(v);\n            depth[v] = d;\n            used[ei] = true;\n            oute.emplace_back(ei);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool dfs2(vector<vector<Edge>>& G, int v, int d){\n    if(depth[v] > d){\n        imo[d]++;\n        imo[depth[v]]--;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(used[ei]) continue;\n        if(dfs2(G, nv, d)){\n            // etype[ei] = Soso;\n        }\n    }\n\n    if(d != depthMax){\n        return dfs2(G, path[d + 1], d + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m; cin >> n >> m;\n    vector<vector<Edge>> G(n), Gr(n);\n    vi as(m), bs(m), cs(m);\n    rep(i, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        G [a].emplace_back(Edge(b, c, i));\n        Gr[b].emplace_back(Edge(a, c, i));\n        as[i] = a, bs[i] = b, cs[i] = c;\n    }\n\n    int sv = 0, tv = 1;\n    auto min_dist     = dijkstra(G, sv);\n    auto min_dist_rev = dijkstra(Gr, tv);\n\n    etype = vi(m, Soso);\n\n    vector<vector<Edge>> Gs(n);\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[a] + c == min_dist[b]){\n            Gs[a].emplace_back(Edge(b, c, i));\n        }\n    }\n    depth = vi(n, -1);\n    used  = vi(m);\n    dfs(Gs, sv, tv, 0);\n    reverse(_all(path));\n    reverse(_all(oute));\n    depthMax = path.size();\n\n    // for(auto& e : path) cerr << e+1 << \" \"; cerr << endl;\n    // for(auto& e : oute) cerr << e+1 << \" \"; cerr << endl;\n\n    imo = vi(depthMax);\n    dfs2(Gs, sv, 0);\n    rep(i, 1, depthMax) imo[i] += imo[i - 1];\n    rep(i, depthMax - 1){\n        if(imo[i] == 0){\n            etype[oute[i]] = Sad;\n        }\n    }\n\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[b] + min_dist_rev[a] + c < min_dist[tv]){\n            etype[i] = Happy;\n        }\n    }\n\n    rep(i, m){\n        string res = \"SOSO\";\n        if(etype[i] == Happy){\n            res = \"HAPPY\";\n        }\n        else if(etype[i] == Sad){\n            res = \"SAD\";\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <limits.h>\n#include <string.h>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <queue>\n#define pb push_back\n#define ll long long\n#define X first\n#define Y second\n#define pi acos(-1.0) \n#define maxn 100005\n#define mod 999999937\n#define inf 99999999999999999\nusing namespace std;\n\ntypedef pair<ll,int> P;\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nint n,m;\nvector<Edge> edges;\nvector<int> v[maxn],rv[maxn];\nll d1[maxn],d2[maxn];\nbool used[maxn];\n\nvoid addedge(int from,int to,ll cost){\n\tedges.push_back(Edge{from,to,cost});\n\tedges.push_back(Edge{to,from,cost});\n\tv[from].push_back(edges.size()-2);\n\trv[to].push_back(edges.size()-1);\n}\n\nvoid dijs1(int s,ll *dist){\n\tfill(dist+1,dist+n+1,inf);\n\tmemset(used,0,sizeof(used));\n\tdist[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > pq;\n\tpq.push(P(0,s));\n\twhile(!pq.empty()){\n\t\tint now=pq.top().second; pq.pop();\n\t\tif(used[now]) continue;\n\t\tused[now]=1;\n\t\tfor(int i=0;i<v[now].size();i++){\n\t\t\tEdge e=edges[v[now][i]];\n\t\t\tif(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n\t\t\t\tdist[e.to]=dist[now]+e.cost;\n\t\t\t\tpq.push(P(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijs2(int s,ll *dist){\n\tfill(dist+1,dist+n+1,inf);\n\tmemset(used,0,sizeof(used));\n\tdist[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > pq;\n\tpq.push(P(0,s));\n\twhile(!pq.empty()){\n\t\tint now=pq.top().second; pq.pop();\n\t\tif(used[now]) continue;\n\t\tused[now]=1;\n\t\tfor(int i=0;i<rv[now].size();i++){\n\t\t\tEdge e=edges[rv[now][i]];\n\t\t\tif(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n\t\t\t\tdist[e.to]=dist[now]+e.cost;\n\t\t\t\tpq.push(P(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll length;\nvector<int> G[maxn];\n\n//bcc模板 (橋雙連通分量)\nint dfs_clock;\nmap<int,bool> bridge[maxn];//用bridge[i][j]紀錄v[i][j]這條邊是不是橋 //常數有點大，如果需要加快再改 \nint pre[maxn];\n\nint dfs_bcc(int u,int fa){ \n\tint lowu=pre[u]=++dfs_clock;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tint x=G[u][i];\n\t\tif(!pre[x]){\n\t\t\tint lowx=dfs_bcc(x,u);\n\t\t\tlowu=min(lowu,lowx);\n\t\t\tif(lowx>pre[u]) {\n\t\t\t\tbridge[u][x]=1;\n\t\t\t\t//bridge[x][u]=1;\n\t\t\t}\n\t\t}\n\t\telse if(pre[x]<pre[u]&&x!=fa) lowu=min(lowu,pre[x]);\n\t}\n\treturn lowu;\n}\n\nvoid find_bcc(int nn){\n\tmemset(pre,0,sizeof(pre));\n\tdfs_clock=0;\n\tfor(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n\t\tbridge[i].clear();\n\t}\n\tfor(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n\t\tif(!pre[i]) dfs_bcc(i,-1);\n\t}\n}\n//bcc模板結束 \n\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y;\n\t\tll c;\n\t\tscanf(\"%d%d%lld\",&x,&y,&c);\n\t\taddedge(x,y,c);\n\t}\n\tdijs1(1,d1);\n\tdijs2(2,d2);\n\t\n\t//for(int i=1;i<=n;i++) printf(\"%d %d %d\\n\",i,d1[i],d2[i]);\n\t\n\tlength=d1[2];\n\t\n\tfor(int i=0;i<edges.size();i+=2){\n\t\tEdge e=edges[i];\n\t\tif(d1[e.from]+d2[e.to]+e.cost==length) G[e.from].push_back(e.to);\n\t}\n\t\n\tfind_bcc(n);\n\t\n\t//for(int i=1;i<=n;i++) for(map<int,bool>::iterator iter=bridge[i].begin();iter!=bridge[i].end();iter++){\n\t//\t\tif(iter->second) printf(\"%d %d\\n\",i,iter->first);}\n\t\n\tfor(int i=0;i<edges.size();i+=2){\n\t\tEdge e=edges[i];\n\t\tif(d1[e.to]+d2[e.from]+e.cost<length){\n\t\t\tprintf(\"HAPPY\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(bridge[e.from][e.to]&&d1[e.to]+d2[e.from]+e.cost>length&&length!=inf){\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"SOSO\\n\");\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\n\nvector<vector<pii> > G, rG;\nvector<vector<int> > I;\nll C[100100], rC[100100];\nbool tmp[100100];\nbool bridge[100100];\nint lst[100100][3];\nmap<pii,pii> mul;\nconst ll INF = 1e15;\n\nvoid shortest(vector<vector<pii> > g, ll *c, int s) {\n\tfor(int i = 0; i < 100100; i++) {\n\t\tc[i] = INF;\n\t}\n\tc[s] = 0;\n\tpriority_queue<pli> q;\n\tq.push(pli(0,s));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\tif(c[a.se] < -a.fi) continue;\n\t\tfor(int i = 0; i < g[a.se].size(); i++) {\n\t\t\tint v = g[a.se][i].fi;\n\t\t\tll t = -a.fi + g[a.se][i].se;\n\t\t\tif(c[v] > t) {\n\t\t\t\tc[v] = t;\n\t\t\t\tq.push(pli(-t, v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid mkbridge() {\n\tll sp = C[1];\n\tpriority_queue<pli> q;\n\tq.push(pli(0,0));\n\twhile(q.size()) {\n\t\tpli a = q.top(); q.pop();\n\t\twhile(q.size() && q.top() == a) q.pop();\n\t\tif(tmp[a.se]) continue;\n\t\ttmp[a.se] = true;\n\t\tint id =-1;\n\t\tint src,dst;\n\t\tfor(int i = 0; i < G[a.se].size(); i++) {\n\t\t\tint v = G[a.se][i].fi;\n\t\t\tif(sp == C[a.se] + G[a.se][i].se + rC[v]) {\n\t\t\t\tif(mul[pii(a.se,v)].fi == G[a.se][i].se && mul[pii(a.se,v)].se > 0) {\n\t\t\t\t\tmul[pii(a.se,v)].se = -mul[pii(a.se,v)].se;\n\t\t\t\t\tq.push(pli(-C[v], v));\n\t\t\t\t\tid = I[a.se][i];\n\t\t\t\t\tsrc=a.se;\n\t\t\t\t\tdst=v;\n\t\t\t\t\t//cout << a.se << \" \" << v << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(q.size() == 1 && id >= 0 && mul[pii(src,dst)].se == -1) {\n\t\t\tbridge[id] = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tG.resize(n);\n\trG.resize(n);\n\tI.resize(n);\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tG[a].push_back(pii(b,c));\n\t\trG[b].push_back(pii(a,c));\n\t\tI[a].push_back(i);\n\t\tlst[i][0] = a; lst[i][1] = b; lst[i][2] = c;\n\n\t\tif(mul.find(pii(a,b)) == mul.end())\n\t\t\tmul[pii(a,b)] = pii(c,1);\n\t\telse if(mul[pii(a,b)].fi == c)\n\t\t\tmul[pii(a,b)].se++;\n\t\telse if(mul[pii(a,b)].se > c)\n\t\t\tmul[pii(a,b)] = pii(c,1);\n\t}\n\tshortest(G,C,0);\n\tshortest(rG,rC,1);\n\tmkbridge();\n\t/*\n\tfor(int i = 0; i < m; i++)\n\t\tcout << bridge[i] << \" \";cout << endl;\n\t// */\n\n\tll sp = C[1];\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = lst[i][0]; b = lst[i][1]; c = lst[i][2];\n\t\tif(C[b] + c + rC[a] < sp) {\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}\n\t\telse if(bridge[i] && C[b] + c + rC[a] > sp && sp != INF) {\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream&\noperator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream&\noperator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());\n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(now.from >= 0)\n            shortest_graph[now.from].push_back(now.e);\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    \n    // debug(dist[1]);\n    // rep(i, N) {\n    //     debug(i);\n    //     for(auto e: shortest_graph[i]) {\n    //         cerr << e.from << \" -> \" << e.to << \" : \" << e.cost << endl;\n    //     }\n    // }\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else {\n            if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i)) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\nconst ll INF=1e18;\nstruct HeapNode\n{\n    ll d;\n    int u;\n    bool operator<(const HeapNode &rhs)const\n    {\n        return d>rhs.d;\n    }\n};\nstruct Edge\n{\n    int from,to;\n    ll cost;\n};\nstruct Dij\n{\n    int n,m;\n    vector<int>G[maxn];\n    vector<int>G1[maxn];\n    vector<Edge>edges;\n    vector<Edge>edges1;\n    bool done[maxn];\n    ll d[maxn];\n    ll d1[maxn];\n    void init(int n)\n    {\n        this->n=n;\n        for(int i=0; i<=n; i++)\n        {\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    void addedge(int from,int to,int cost)\n    {\n        edges.push_back(Edge{from,to,cost});\n        edges1.push_back((Edge)\n        {\n            to,from,cost\n        });\n        m=edges.size();\n        G[from].push_back(m-1);\n        G1[to].push_back(m-1);\n    }\n    void dij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0; i<=n; i++) d[i]=INF;\n        d[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode)\n        {\n            0,s\n        });\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top();\n            Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0; i<G[u].size(); i++)\n            {\n                Edge &e=edges[G[u][i]];\n                if(d[e.to]>d[u]+e.cost)\n                {\n                    d[e.to]=d[u]+e.cost;\n                    Q.push((HeapNode)\n                    {\n                        d[e.to],e.to\n                    });\n                }\n            }\n        }\n    }\n\n    void redij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0; i<=n; i++) d1[i]=INF;\n        d1[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode)\n        {\n            0,s\n        });\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top();\n            Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0; i<G1[u].size(); i++)\n            {\n                Edge &e=edges1[G1[u][i]];\n                if(d1[e.to]>d1[u]+e.cost)\n                {\n                    d1[e.to]=d1[u]+e.cost;\n                    Q.push((HeapNode)\n                    {\n                        d1[e.to],e.to\n                    });\n                }\n            }\n        }\n    }\n} D;\n\nstruct node\n{\n    int x,y;\n    ll z;\n} s[maxn];\ntypedef pair<int,int>P;\nvector<P>G[maxn];\nint dfs_clock,pre[maxn],low[maxn];\nbool is_bridge[maxn];\nint cnt;\nint dfs(int u,int fa)\n{\n    int lowu;\n    lowu=pre[u]=++dfs_clock;\n    for(int i=0; i<G[u].size(); i++)\n    {\n        int v=G[u][i].first;\n        if(!pre[v])\n        {\n            //cout<<u<<\" \"<<v<<endl;\n            int lowv=dfs(v,u);\n            lowu=min(lowu,lowv);\n            //cout<<lowv<<\" \"<<pre[u]<<endl;\n            if(lowv>pre[u])\n            {\n                is_bridge[G[u][i].second]=true;\n                cnt++;\n            }\n        }\n        else if(pre[v]<pre[u]&&fa!=v)\n            lowu=min(lowu,pre[v]);\n    }\n    return low[u]=lowu;\n}\n\nint main()\n{\n //   freopen(\"in.txt\",\"r\",stdin);\n  //  freopen(\"out.txt\",\"w\",stdout);\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    D.init(n);\n    for(int i=0; i<m; i++)\n    {\n        scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].z);\n        D.addedge(s[i].x,s[i].y,s[i].z);\n    }\n    D.dij(1);\n    D.redij(2);\n   // int cnt=0;\n    for(int i=0; i<m; i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[y]+D.d1[y]==D.d[2]&&D.d[x]+z==D.d[y])\n        {\n  //          cnt++;\n            G[y].push_back(make_pair(x,i));\n        }\n    }\n//cout<<cnt<<endl;\n    dfs(1,-1);\n\n\n    for(int i=0; i<m; i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(is_bridge[i])\n        {\n            printf(\"SAD\\n\");\n        }\n        else if(D.d[y]+D.d1[x]+z<D.d[2])\n        {\n            printf(\"HAPPY\\n\");\n        }\n        else\n        {\n            printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 58;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int Soso  = 1;\nconst int Happy = 2;\nconst int Sad   = 3;\n\nusing Edge = tuple<int, int, int>;\n\nvll dijkstra(vector<vector<Edge>>& G, int sv){\n    int n = G.size();\n    vll min_dist(n, inf);\n    min_dist[sv] = 0;\n\n    using Elem = tuple<ll, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n    q.push(Elem(0, sv));\n\n    while(q.size()){\n        ll c; int v; tie(c, v) = q.top(); q.pop();\n        if(min_dist[v] != c) continue;\n\n        for(auto& e : G[v]){\n            int nv, dc, ei; tie(nv, dc, ei) = e;\n            ll nc = c + dc;\n            if(chmin(min_dist[nv], nc)){\n                q.push(Elem(nc, nv));\n            }\n        }\n    }\n    return min_dist;\n}\n\nint depthMax;\nvi etype;\nvi depth;\nvi used;\nvi path;\nvi imo;\nvi oute;\n\nbool dfs(vector<vector<Edge>>& G, int v, int tv, int d){\n    if(v == tv){\n        path.emplace_back(v);\n        depth[v] = d;\n        return true;\n    }\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(dfs(G, nv, tv, d + 1)){\n            path.emplace_back(v);\n            depth[v] = d;\n            used[ei] = true;\n            oute.emplace_back(ei);\n            return true;\n        }\n    }\n    return false;\n}\n\nvi visited;\nbool dfs2(vector<vector<Edge>>& G, int v, int d){\n    if(depth[v] > d){\n        imo[d]++;\n        imo[depth[v]]--;\n        return true;\n    }\n    if(depth[v] == -1) visited[v] = true;\n    for(auto& e : G[v]){\n        int nv, ei; tie(nv, ignore, ei) = e;\n        if(visited[nv]) continue;\n        if(used[ei]) continue;\n        if(dfs2(G, nv, d)){\n            // etype[ei] = Soso;\n        }\n    }\n\n    if(d < depthMax - 1){\n        return dfs2(G, path[d + 1], d + 1);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m; cin >> n >> m;\n    vector<vector<Edge>> G(n), Gr(n);\n    vi as(m), bs(m), cs(m);\n    rep(i, m){\n        int a, b, c; cin >> a >> b >> c;\n        a--, b--;\n        G [a].emplace_back(Edge(b, c, i));\n        Gr[b].emplace_back(Edge(a, c, i));\n        as[i] = a, bs[i] = b, cs[i] = c;\n    }\n\n    int sv = 0, tv = 1;\n    auto min_dist     = dijkstra(G, sv);\n    auto min_dist_rev = dijkstra(Gr, tv);\n\n    etype = vi(m, Soso);\n\n    vector<vector<Edge>> Gs(n);\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[a] + c == min_dist[b]){\n            Gs[a].emplace_back(Edge(b, c, i));\n        }\n    }\n    depth = vi(n, -1);\n    used  = vi(m);\n    dfs(Gs, sv, tv, 0);\n    reverse(_all(path));\n    reverse(_all(oute));\n    depthMax = path.size();\n\n    // for(auto& e : path) cerr << e+1 << \" \"; cerr << endl;\n    // for(auto& e : oute) cerr << e+1 << \" \"; cerr << endl;\n\n    imo = vi(depthMax);\n    visited = vi(n);\n    dfs2(Gs, sv, 0);\n    rep(i, 1, depthMax) imo[i] += imo[i - 1];\n    rep(i, depthMax - 1){\n        if(imo[i] == 0){\n            etype[oute[i]] = Sad;\n        }\n    }\n\n    rep(i, m){\n        int a = as[i], b = bs[i], c = cs[i];\n        if(min_dist[b] + min_dist_rev[a] + c < min_dist[tv]){\n            etype[i] = Happy;\n        }\n    }\n\n    rep(i, m){\n        string res = \"SOSO\";\n        if(etype[i] == Happy){\n            res = \"HAPPY\";\n        }\n        else if(etype[i] == Sad){\n            res = \"SAD\";\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, x, y) for (decay<decltype(y)>::type i = (x), _##i = (y); i < _##i; ++i)\n#define FORD(i, x, y) for (decay<decltype(x)>::type i = (x), _##i = (y); i > _##i; --i)\n#ifdef zerol\n#define dbg(args...) do { cout << \"\\033[32;1m\" << #args << \" -> \"; err(args); } while (0)\n#else\n#define dbg(...)\n#endif\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... Args>\nvoid err(T<t> a, Args... args) { for (auto x: a) cout << x << ' '; err(args...); }\ntemplate<typename T, typename... Args>\nvoid err(T a, Args... args) { cout << a << ' '; err(args...); }\n////////////////////////////////////////////////////////////////////////////////////\n\nstruct Edge { int to, c, id; };\n\nconst int N = 1E5 + 100;\nvector<Edge> G[N], rG[N], H[N];\nvector<int> orders;\nconst int S = 1, T = 2;\nconst LL INF = 1E15;\nLL ds[N], dt[N];\n\nstruct HeapNode {\n    LL d; int u;\n    bool operator < (const HeapNode &x) const {\n        return d > x.d || (d == x.d && u < x.u);\n    }\n};\nvoid dijkstra(vector<Edge>* G, int s, int n, LL* dis) {\n    static int done[N];\n    memset(done, 0, sizeof done);\n    fill(dis, dis + n + 1, INF);\n    priority_queue<HeapNode> q;\n    dis[s] = 0; q.push({0, s});\n    while (!q.empty()) {\n        HeapNode x = q.top(); q.pop();\n        int u = x.u; if (done[u]) continue;\n        done[u] = 1;\n        for (Edge &e: G[u]) {\n            if (!done[e.to] && dis[e.to] > dis[u] + e.c) {\n                dis[e.to] = dis[u] + e.c;\n                q.push({dis[e.to], e.to});\n            }\n        }\n    }\n}\nint st[N], ed[N], wt[N], n, m;\nint in[N], out[N], ans[N];\n\nvoid toposort(int s) {\n    static int dg[N];\n    copy(in + 1, in + n + 1, dg + 1);\n    assert (dg[s] == 0);\n    queue<int> q; q.push(s); orders.push_back(s);\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (Edge &e: H[u]) {\n            dg[e.to]--;\n            if (dg[e.to] == 0) {\n                orders.push_back(e.to);\n                q.push(e.to);\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m;\n    FOR (i, 0, m) {\n        int u, v, w; cin >> u >> v >> w;\n        G[u].push_back({v, w, i});\n        rG[v].push_back({u, w, i});\n        st[i] = u; ed[i] = v; wt[i] = w;\n    }\n    dijkstra(G, S, n, ds);\n    dijkstra(rG, T, n, dt);\n    LL presumed = ds[T];\n    // dbg(presumed);\n\n    FOR (i, 0, m) {\n        int u = st[i], v = ed[i], w = wt[i];\n        if (ds[u] + w + dt[v] == presumed) {\n            H[u].push_back({v, w, i});\n            in[v]++; out[u]++;\n            dbg(u, v, w);\n        }\n    }\n    toposort(S);\n    int ctr = 0;\n    for (int u: orders) {\n        ctr -= in[u];\n        ctr += out[u];\n        if (ctr == 1) {\n            assert ((int) H[u].size() == 1);\n            ans[H[u][0].id] = 1;\n        }\n    }\n\n    FOR (i, 0, m) {\n        int u = st[i], v = ed[i], w = wt[i];\n        // dbg(u, v, ds[v], dt[u]);\n        if (ds[v] + w + dt[u] < presumed) {\n            puts(\"HAPPY\");\n        } else {\n            if (ans[i]) puts(\"SAD\");\n            else puts(\"SOSO\");\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream&\noperator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream&\noperator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i)) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\nconst lli inf = 1e18;\n\nvector<lli> shortest_path(int from, vector<vector<pair<int,lli>>> &graph){\n    int n = graph.size();\n    vector<lli> mincost(n, inf);\n    mincost[from] = 0;\n    priority_queue<pair<lli,int>> wait;\n    wait.push({0LL, from});\n    while(!wait.empty()){\n        lli cost = -wait.top().first;\n        int pos = wait.top().second;\n        wait.pop();\n        if(cost > mincost[pos]) continue;\n        for(auto next: graph[pos]){\n            lli ncost = cost + next.second;\n            int npos = next.first;\n            if(ncost < mincost[npos]){\n                mincost[npos] = ncost;\n                wait.push({-ncost, npos});\n            }\n        }\n    }\n    return mincost;\n}\n\nint bridges_dfs(int curr, int prev, int &count,\n                vector<int> &pre, vector<int> &low,\n                vector<pair<int,int>> &res, vector<vector<int>> &graph){\n    if(pre[curr] != -1) return low[curr];\n    pre[curr] = count++;\n    low[curr] = pre[curr];\n    for(int next: graph[curr]){\n        if(next == prev) continue;\n        int ret = bridges_dfs(next, curr, count, pre, low, res, graph);\n        if(ret > pre[curr]){\n            res.emplace_back(curr, next);\n        }\n        low[curr] = min(low[curr], ret);\n    }\n    return low[curr];\n}\nvector<pair<int,int>> bridges(vector<vector<int>> &graph){\n    int n = graph.size();\n    vector<pair<int,int>> res;\n    vector<int> pre(n, -1), low(n);\n    int count = 0;\n    bridges_dfs(0, -1, count, pre, low, res, graph);\n    return res;\n}\nset<pair<int,int>> bridge_list(vector<vector<pair<int,lli>>> &graph, vector<lli> &mincost_s, vector<lli> &mincost_t){\n    int n = graph.size();\n    vector<vector<int>> adj(n);\n    for(int i=0; i<n; i++){\n        for(auto next: graph[i]){\n            int j = next.first;\n            int cost = next.second;\n            if(mincost_s[1] == mincost_s[i] +cost +mincost_t[j]){\n                adj[i].push_back(j);\n                adj[j].push_back(i);\n            }\n        }\n    }\n    for(auto &v: adj){\n        sort(v.begin(), v.end());\n        v.erase(unique(v.begin(), v.end()), v.end());\n    }\n    auto ret = bridges(adj);\n    set<pair<int, int>> res;\n    for(auto p: ret){\n        if(mincost_s[p.first] < mincost_s[p.second]){\n            res.insert(p);\n        }else{\n            res.insert({p.second, p.first});\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> a(m),b(m),c(m);\n    map<pair<int,int>, int> minedge, duality;\n    vector<vector<pair<int, lli>>> adj(n), adjrev(n);\n    for(int i=0; i<m; i++){\n        cin >> a[i] >> b[i] >> c[i];\n        a[i]--; b[i]--;\n        adj[a[i]].emplace_back(b[i], c[i]);\n        adjrev[b[i]].emplace_back(a[i], c[i]);\n        pair<int, int> pab(a[i], b[i]);\n        if(minedge.count(pab) == 0){\n            minedge[pab] = c[i];\n        }else{\n            minedge[pab] = min(minedge[pab], c[i]);\n        }\n    }\n    for(int i=0; i<m; i++){\n        pair<int, int> pab(a[i], b[i]);\n        if(minedge[pab] == c[i]){\n            duality[pab]++;\n        }\n    }\n    int s=0, t=1;\n    auto sp_s = shortest_path(s, adj);\n    auto sp_t = shortest_path(t, adjrev);\n    auto bridge = bridge_list(adj, sp_s, sp_t);\n    for(int i=0; i<m; i++){\n        pair<int, int> pab(a[i], b[i]);\n        if(sp_s[b[i]] +c[i] +sp_t[a[i]] < sp_s[t]){\n            cout << \"HAPPY\" << endl;\n        }else if(bridge.find(pab)==bridge.end() or minedge[pab]!=c[i] or duality[pab]>1){\n            cout << \"SOSO\" << endl;\n        }else{\n            cout << \"SAD\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef vector< vector< edge > > Graph;\n\ntemplate< typename T = int >\nvector< T > Dijkstra(Graph &g, int s)\n{\n  typedef pair< T, int > Pi;\n  vector< T > min_cost(g.size(), numeric_limits< T >::max() / 3);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.emplace(0, s);\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > min_cost[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost >= min_cost[e.to]) continue;\n      min_cost[e.to] = p.first + e.cost;\n      que.emplace(min_cost[e.to], e.to);\n    }\n  }\n  return (min_cost);\n}\n\n\nint main()\n{\n  int N, M, A[100000], B[100000], C[100000];\n\n  scanf(\"%d %d\", &N, &M);\n  Graph g(N), rg(N), dag(N);\n  for(int i = 0; i < M; i++) {\n    scanf(\"%d %d %d\", &A[i], &B[i], &C[i]);\n    --A[i], --B[i];\n    g[A[i]].emplace_back((edge) {B[i], C[i]});\n    rg[B[i]].emplace_back((edge) {A[i], C[i]});\n  }\n  auto latte = Dijkstra< int64 >(g, 0);\n  auto malta = Dijkstra< int64 >(rg, 1);\n  vector< int > ans(M, -1);\n  for(int i = 0; i < M; i++) {\n    if(latte[A[i]] + malta[B[i]] + C[i] == latte[1]) {\n      dag[A[i]].emplace_back((edge) {B[i], i});\n      dag[B[i]].emplace_back((edge) {A[i], i});\n    } else if(latte[B[i]] + malta[A[i]] + C[i] < latte[1]) {\n      ans[i] = 1;\n    } else {\n      ans[i] = 0;\n    }\n  }\n\n  vector< int > dp(N), order(N);\n  bool v[100000] = {};\n  function< void(int, int &) > dfs = [&](int idx, int &ord)\n  {\n    v[idx] = true;\n    dp[idx] = ord++;\n    order[idx] = dp[idx];\n    for(auto &e : dag[idx]) {\n      if(!v[e.to]) dfs(e.to, ord), dp[idx] = min(dp[idx], dp[e.to]);\n      else dp[idx] = min(dp[idx], order[e.to]);\n      if(dp[e.to] <= order[idx]) ans[e.cost] = 0;\n    }\n  };\n\n  int k = 0;\n  dfs(0, k);\n\n  for(int i = 0; i < M; i++) {\n    if(ans[i] == 0) puts(\"SOSO\");\n    else if(ans[i] == 1) puts(\"HAPPY\");\n    else puts(\"SAD\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\nconstexpr ll inf = ll(1e18) + 9;\n\nvector<ll> dijkstra(vector<vector<pair<int, ll> > > const & g, int root) {\n    vector<ll> dist(g.size(), inf);\n    priority_queue<pair<ll, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        ll dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; ll cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n\npair<int, vector<int> > decompose_to_two_edge_connected_components(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> imos(n); { // imos[i] == 0  iff  the edge i -> parent is a bridge\n        vector<char> used(n); // 0: unused ; 1: exists on stack ; 2: removed from stack\n        function<void (int, int)> go = [&](int i, int parent) {\n            used[i] = 1;\n            for (int j : g[i]) if (j != parent) {\n                if (used[j] == 0) {\n                    go(j, i);\n                    imos[i] += imos[j];\n                } else if (used[j] == 1) {\n                    imos[i] += 1;\n                    imos[j] -= 1;\n                }\n            }\n            used[i] = 2;\n        };\n        REP (i, n) if (used[i] == 0) {\n            go(i, -1);\n        }\n    }\n    int size = 0;\n    vector<int> component_of(n, -1); {\n        function<void (int)> go = [&](int i) {\n            for (int j : g[i]) if (component_of[j] == -1) {\n                component_of[j] = imos[j] == 0 ? size ++ : component_of[i];\n                go(j);\n            }\n        };\n        REP (i, n) if (component_of[i] == -1) {\n            component_of[i] = size ++;\n            go(i);\n        }\n    }\n    return { size, move(component_of) };\n}\n\nenum result_t { HAPPY, SOSO, SAD };\nconstexpr int start = 0;\nconstexpr int goal = 1;\nint main() {\n    // input\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<tuple<int, int, int> > edges(m);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        edges[i] = make_tuple(a, b, c);\n    }\n    // solve\n    vector<vector<pair<int, ll >> > g(n);\n    vector<vector<pair<int, ll >> > rev_g(n);\n    map<tuple<int, int, int>, int> count_edges;\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        g[a].emplace_back(b, c);\n        rev_g[b].emplace_back(a, c);\n        count_edges[edge] += 1;\n    }\n    auto dist = dijkstra(g, start);\n    auto rev_dist = dijkstra(rev_g, goal);\n    vector<vector<int> > h(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            if (dist[i] + cost == dist[j] and dist[j] <= dist[goal]) {\n                h[i].push_back(j);\n                h[j].push_back(i);\n            }\n        }\n    }\n    auto component_of = decompose_to_two_edge_connected_components(h).second;\n    // output\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        result_t result =\n            dist[b] + c + rev_dist[a] <  dist[goal] ? HAPPY :\n            dist[a] == inf or rev_dist[b] == inf ? SOSO :\n            dist[b] + c + rev_dist[a] == dist[goal] ? SOSO :\n            dist[a] + c + rev_dist[b] != dist[goal] ? SOSO :\n            count_edges[edge] >= 2 ? SOSO :\n            component_of[a] != component_of[b] ? SAD :\n            SOSO;\n        printf(\"%s\\n\",\n            result == HAPPY ? \"HAPPY\" :\n            result == SOSO ? \"SOSO\" :\n            result == SAD ? \"SAD\" :\n            \"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cout<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nclass Lowlink{\npublic:\n  int V;\n  vector<vector<int> > G;\n  vector<int> ord;           //ord[i] := ノードiに訪れた順番\n  vector<int> low;           //low[i] := ノードiから訪れることができる最小のord[j]の値。\n  vector<int> articulation;\n  int ok;\n  \n  Lowlink():V(-1),ok(false){};\n  Lowlink(int V):V(V),G(V),ok(false){};\n    \n  void add_edge(int a,int b){\n    ok = false;\n    assert(a < V && b < V);\n    assert(a >=0 && b >= 0);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  void build(int root = 0){\n    ok = true;\n    ord.clear(); ord.resize(V,-1);\n    low.clear(); low.resize(V,-1);\n    articulation.clear(); articulation.resize(V,0); /*関節点用*/\n    \n    int cnt = 0;\n    function<int(int,int)> dfs=[&](int pos,int pre){\n      ord[pos] = low[pos] = cnt++;\n      for(int to:G[pos]) {\n        if(to == pre) continue; \n        if(ord[to] != -1) low[pos] = min(low[pos], ord[to]);\n        else {\n          low[pos] = min(low[pos], dfs(to, pos));\n\t  \n\t  /*関節点用*/\n\t  if(pos == root) articulation[pos]++;\n\t  else articulation[pos] |= ord[pos] <= low[to];\n\t  \n\t}\n      }\n      return low[pos];\n    };\n    \n    dfs(root , -1);\n    articulation[root] = articulation[root] >= 2; /*関節点用*/\n  }\n\n  int isBridge(int a,int b){\n    assert(ok);\n    assert(a < V && b < V);\n    assert(a >= 0 && b >= 0);\n    if(ord[a] > ord[b]) swap(a, b);\n    return ord[a] < low[b];\n  }\n  \n  int isArticulation(int a){\n    assert(ok);\n    assert(a >= 0 && a < V);\n    return articulation[a];\n  }\n};\n\ntemplate<typename ctype, ctype INF>\nclass Dijkstra{\npublic:\n  typedef tuple<int,ctype> T;  //for edge\n  typedef tuple<ctype,int> T2; //for priority_queue\n  int V;\n  vector<vector<T> > G;\n  vector<vector<T> > rG;\n  \n  Dijkstra():V(-1){}\n  Dijkstra(int V):V(V),G(V),rG(V){}\n  \n  void add_edge(int a,int b,ctype c,int oneway = 0){\n    assert(a >= 0 && b >= 0);\n    assert(a < V && b < V);\n    G[a].push_back(T(b, c));\n    rG[b].push_back(T(a, c));\n    if(!oneway) G[b].push_back(T(a, c)), rG[a].push_back(T(b, c));\n  }\n\n  vector<ctype> dijkstra(int start, int rev = 0){\n    vector<ctype> D(V, INF);\n    vector<int> visited(V,0);\n    priority_queue<T2, vector<T2>, greater<T2> > Q;\n    Q.push(T2(0, start));\n    D[start] = 0;\n    while(!Q.empty()){\n      ctype cost;\n      int pos;\n      tie(cost,pos) = Q.top(); Q.pop();\n      assert(!visited[pos] || D[pos] <= cost);\n      if(visited[pos]++) continue;\n      \n      for(auto t:rev == 0? G[pos]:rG[pos]){\n\tint to = get<0>(t);\n        ctype ncost = cost + get<1>(t);\n        if(D[to] <= ncost) continue;\n        D[to] = ncost;\n        Q.push(T2(ncost, to));\n      }\n    }\n    return D;\n  }\n  \n  vector<vector<int> > getDAG(int start, int goal){\n    auto DS = dijkstra(start, 0);\n    auto DT = dijkstra(goal, 1);\n    vector<vector<int> > DAG(V);\n    vector<int> visited(V,0);\n    queue<int> Q;\n    Q.push(start);\n    while(!Q.empty()){\n      int pos; pos = Q.front(); Q.pop();\n      if(visited[pos]++) continue;\n      \n      for(auto t:G[pos]){\n        int to = get<0>(t);\n        ctype cost = get<1>(t);\n\tif(DS[pos] + DT[to] + cost != DS[goal]) continue;\n\tQ.push(to);\n\tDAG[pos].push_back(to);\n      }\n    }\n    return DAG;\n  }\n};\n\nusing T = tuple<int,int,int>;\nconst int start = 0,  goal= 1;\nint n, m;\nvector<T> edge;\nvector<Int> DS, DT;\nLowlink lowlink;\n\nint happy(int i){\n  int a, b, c; tie(a, b, c) = edge[i];\n  return DS[goal] > DS[b] + DT[a] + c;\n}\n\nint  soso(int i){\n  int a, b, c; tie(a, b, c) = edge[i];\n  if(DS[a] + DT[b] + c != DS[goal]) return 1;\n  return !lowlink.isBridge(a, b);\n}\n\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>n>>m;\n  edge.resize(m);\n  Dijkstra<Int, INF> dijkstra(n);\n  Dijkstra<Int, INF> dijkstra2(n);\n  \n  for(int i=0;i < m;i++){\n    Int a, b, c;\n    cin>>a>>b>>c; a--,b--;\n    edge[i] = T(a, b, c);\n    dijkstra.add_edge(a, b, c, 1);\n    dijkstra2.add_edge(b, a, c, 1);\n  }\n  DS = dijkstra.dijkstra(start);\n  DT = dijkstra2.dijkstra(goal);\n\n  auto G = dijkstra.getDAG(start, goal);\n  lowlink = Lowlink(n);\n  for(int i=0;i<n;i++)\n    for(int to:G[i]) lowlink.add_edge(i, to);\n\n  lowlink.build();\n\n  for(int i=0;i<m;i++){\n    if(happy(i)) cout<<\"HAPPY\"<<endl;\n    else if(soso(i)) cout<<\"SOSO\"<<endl;\n    else cout<<\"SAD\"<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int64)1e9\n#define REP(i, n) for(int64 i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int64 i = (a); i < (b); i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint32_t;\nusing int64 = int64_t;\nusing uint64 = uint64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if (a > b) a = b; }\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if (a < b) a = b; }\n\nconst int32 DIRECTED = 0;\nconst int32 UNDIRECTED = 1;\ntemplate<int32 isUNDIRECTED=0>\nclass Graph {\npublic:\n  struct Edge {\n    int32 u, v, id;\n    int64 c;\n    Edge(int32 u, int32 v, int64 c = 0, int32 id=0): u(u), v(v), c(c), id(id) {}\n  };\n  int32 V, E;\n  vector<vector<Edge>> G;\n  vector<Edge> Es;\npublic:\n  Graph() {}\n  Graph(int32 V):V(V) { G.resize(V); }\n  Graph(const Graph<isUNDIRECTED>& g): V(g.V), E(g.E), G(g.G), Es(g.Es) {}\n\n  void add_edge(int32 u, int32 v, int64 c = 0, int32 id = 0) {\n    G[u].emplace_back(u, v, c, id);\n    if (isUNDIRECTED) G[v].emplace_back(v, u, c, id);\n    E++;\n  }\n\n  const vector<Edge>& operator[](int32 k) {\n    return G[k];\n  }\n};\n\ntemplate<int isUNDIRECTED=1>\nclass Lowlink : public Graph<isUNDIRECTED> {\n  vector<int32> ord, low;\n  vector<int32> articulation;\n  vector<pair<int32, int32>> bridge;\npublic:\n  Lowlink() {}\n  Lowlink(int32 V): Graph<isUNDIRECTED>(V) {}\n\n  void build() {\n    ord.resize(this->V, -1);\n    low.resize(this->V, -1);\n    int32 k = 0;\n\n    function<void(int32, int32)> dfs = [&, this](int32 v, int32 p) {\n      ord[v] = k++;\n      low[v] = ord[v];\n      bool isArt = 0;\n      int32 cnt = 0;\n\n      for (auto &e : this->G[v]) {\n        if (e.v == p) continue;\n        if (ord[e.v] == -1) {\n          cnt++;\n          dfs(e.v, v);\n          low[v] = min(low[v], low[e.v]);\n          if (~p && ord[v] <= low[e.v]) isArt = 1;\n        } else {\n          low[v] = min(low[v], ord[e.v]);\n        }\n      }\n      if (p == -1 && cnt > 1) isArt = 1;\n    };\n    for (int32 i = 0; i < this->V; i++)\n      if (ord[i] == -1) dfs(i, -1);\n  }\n\n  const vector<pair<int32, int32>>& getBridge() {\n    return bridge;\n  }\n\n  const vector<int32>& getArticulation() {\n    return articulation;\n  }\n\n  bool isBridge(int32 u, int32 v) const {\n    if (ord[u] > ord[v]) swap(u, v);\n    return ord[u] < low[v];\n  }\n};\n\nint64 n, m;\nvector<vector<PLL>> G, rG;\n\nint main(void) {\n  cin >> n >> m;\n  G.resize(n); rG.resize(n);\n  using T = tuple<int64, int64, int64>;\n  vector<T> es(m);\n  REP(i, m) {\n    int64 a, b, c;\n    cin >> a >> b >> c; a--; b--;\n    G[a].emplace_back(c, b);\n    rG[b].emplace_back(c, a);\n    es[i] = T(a, b, c);\n  }\n\n  vector<int64> d, rd;\n\n  auto dijkstra = [&](const vector<vector<PLL>>& G, int64 st, vector<int64>& d) {\n    d = vector<int64>(n, INF_LL);\n    d[st] = 0;\n    priority_queue<PLL, vector<PLL>, greater<PLL>> pq;\n    pq.emplace(0, st);\n    while (pq.size()) {\n      int64 v, c;\n      tie(c, v) = pq.top(); pq.pop();\n      if (c > d[v]) continue;\n      for (auto &e : G[v]) {\n        if (e.fs + c < d[e.sc]) {\n          d[e.sc] = e.fs + c;\n          pq.emplace(d[e.sc], e.sc);\n        }\n      }\n    }\n  };\n  dijkstra(G, 0, d); dijkstra(rG, 1, rd);\n  Lowlink<> low(n);\n  queue<PLL> q;\n  q.emplace(d[1], 1);\n  vector<int> used(n, 0);\n  while (q.size()) {\n    int64 v, c;\n    tie(c, v) = q.front(); q.pop();\n    for (auto &e : rG[v]) {\n      if (c - e.fs == d[e.sc]) {\n        low.add_edge(e.sc, v);\n        if (!used[e.sc])\n          q.emplace(d[e.sc], e.sc);\n        used[e.sc] = 1;\n      }\n    }\n  }\n  low.build();\n\n  REP(i, m) {\n    int64 u, v, c;\n    tie(u, v, c) = es[i];\n    if (d[v] + rd[u] + c < d[1]) {\n      cout << \"HAPPY\" << endl;\n      continue;\n    } else if (low.isBridge(u, v) && d[u] + c == d[v] && d[v] + rd[v] == d[1]){\n      cout << \"SAD\" << endl;\n    } else {\n      cout << \"SOSO\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\nconstexpr ll inf = ll(1e18) + 9;\n\nvector<ll> dijkstra(vector<vector<pair<int, ll> > > const & g, int root) {\n    vector<ll> dist(g.size(), inf);\n    priority_queue<pair<ll, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        ll dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; ll cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n\nenum result_t { HAPPY, SOSO, SAD };\nconstexpr int start = 0;\nconstexpr int goal = 1;\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<tuple<int, int, int> > edges(m);\n    vector<vector<pair<int, ll >> > g(n);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        edges[i] = make_tuple(a, b, c);\n        g[a].emplace_back(b, c);\n    }\n    ll prv = dijkstra(g, start)[goal];\n    REP (i, m) {\n        vector<vector<pair<int, ll >> > h(n);\n        REP (j, m) {\n            int a, b, c; tie(a, b, c) = edges[j];\n            if (i == j) {\n                h[b].emplace_back(a, c);\n            } else {\n                h[a].emplace_back(b, c);\n            }\n        }\n        ll cur = dijkstra(h, start)[goal];\n        result_t result =\n            cur <  prv ? HAPPY :\n            cur == prv ? SOSO :\n            SAD;\n        printf(\"%s\\n\",\n            result == HAPPY ? \"HAPPY\" :\n            result == SOSO ? \"SOSO\" :\n            result == SAD ? \"SAD\" :\n            \"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < (int)(n) ; i++)\n#define INF 1e15\n#define int long long\n\nstruct Edge{\n\tint a,b,c, id;\n};\n\nstruct Node{\n\tint p,c;\n};\n\nbool operator < (Node a,Node b){\n\treturn a.c > b.c;\n}\n\nvector<int> dijkstra(int s, vector< vector<Edge> > g){\n\tvector<int> dist(g.size(), INF);\n\tpriority_queue<Node> Q;\n\tQ.push({s,0});\n\twhile( Q.size() ){\n\t\tauto q = Q.top(); Q.pop();\n\t\tif( dist[q.p] != INF ) continue;\n\t\tdist[q.p] = q.c;\n\t\tfor( auto e : g[q.p] ){\n\t\t\tQ.push({e.b, q.c + e.c});\n\t\t}\n\t}\n\treturn dist;\n}\n\nint visited[100010];\nint currentTime = 0;\n\nset<int> bridges;\n\nmap< pair<int,int> , int> counter;\n\nint dfs(int x, int p, const vector< vector<Edge> > &g){\n\tcurrentTime++;\n\tvisited[x] = currentTime;\n\n\tint ans = currentTime;\n\tfor( auto &&e : g[x] ){\n\t\tif( e.b == p ) continue;\n\n\t\tif( visited[e.b] != 0 ){\n\t\t\tans = min(ans, visited[e.b]);\n\t\t}else{\n\t\t\tans = min(ans, dfs(e.b, x, g));\n\t\t}\n\t}\n\tif( p != -1 && ans > visited[p]){\n\t\n\t\tcounter[{x, p}]++;\n\t\tcounter[{p, x}]++;\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<Edge> es;\n\tvector< vector<Edge> > g(n),rg(n);\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\t--a,--b;\n\t\tes.push_back({a,b,c, i});\n\t\tg[a].push_back({a,b,c, i});\n\t\trg[b].push_back({b,a,c, i});\n\t}\n\n\tint S = 0;\n\tint G = 1;\n\tauto gDist = dijkstra(S, g);\n\tauto rgDist = dijkstra(G, rg);\n\t\n\tvector< vector<Edge> > dag(n);\n\tfor( auto e : es ){\n\t\tif( gDist[e.a] + e.c + rgDist[e.b] == gDist[G] ){\n\t\t\tdag[e.a].push_back(e);\n\t\t}\n\t}\n\tdfs(0, -1, dag);\n\n\tfor( auto e : es ){\n\t\tif( gDist[e.b] + e.c + rgDist[e.a] < gDist[G] ){\n\t\t\tcout << \"HAPPY\" << endl;\n\t\t}else if( gDist[e.a] + e.c + rgDist[e.b] != gDist[G] ){\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}else if( counter[{e.a,e.b}] != 1 ){\n\t\t\tcout << \"SOSO\" << endl;\n\t\t}else{\n\t\t\tcout << \"SAD\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll V,E;\nstruct edge{\n\tll to,cost,id;\n};\nconst ll maxn = 100005;\nconst ll INF = 102120027425345LL;\nvector<edge> G[maxn],rG[maxn],sG[maxn];\nll d[maxn], d2[maxn];\nbool isBridge[maxn];\nvoid dijkstra(ll s, vector<edge> G[maxn], ll d[maxn]) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d+V, INF);\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tll v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (auto e:G[v]){\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n\tmap<P,ll> M;\nll dfs_clock,pre[maxn],low[maxn];\nll dfs(ll u, ll edge_id) {\n\tll lowu = pre[u] = ++dfs_clock;\n\tfor (auto e: sG[u]) {\n\t\tll v = e.to;\n\t\tif (!pre[v]) {\n\t\t\tll lowv = dfs(v,e.id);\n\t\t\tlowu = min(lowu, lowv);\n\t\t\tif (lowv > pre[u]){\n\t\t\t\tif (M[P(u,v)]==1) isBridge[e.id] = true;\n\t\t\t}\n\t\t}\n\t\telse if (pre[v] <pre[u]&&e.id!=edge_id) lowu = min(lowu, pre[v]);\n\t}\n\treturn low[u] = lowu;\n}\n\nll ans[maxn];\n\n\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\n\tfor (ll i = 0; i < E; i++) {\n\t\tll x,y,cost;\n\t\tscanf(\"%lld%lld%lld\",&x,&y,&cost);\n\t\t--x,--y;\n\t\t\n\t\tG[x].push_back(edge{y,cost,i});\n\t\trG[y].push_back(edge{x,cost,i});\t\n\t}\n\tdijkstra(0,G,d);\n\tdijkstra(1,rG,d2);\n\tfor(ll i = 0; i < V; i++)\n\tfor (auto e:G[i]) {\n\t\t//cerr << i << \" \"  <<e.to <<\" \" << d[i] << \" \" << e.cost << \" \" << d[e.to] << endl;\n\t\tif (d[i] + e.cost == d[e.to]&&d[e.to]+d2[e.to]==d[1]) \n\t\t{\n\t\t\tsG[i].push_back(e),sG[e.to].push_back(edge{i,e.cost,e.id});//cerr << i << \" \"  <<e.to<<endl; \n\t\t\tM[P(i,e.to)]++;\n\t\t}\n\t}\n\t//cerr << \"------\" << endl;\n\tdfs(0,-1);\n\t//for (ll i = 0; i < E; i++) cerr<< isBridge[i] << \" \" ;\n\t//cerr<<endl;\n\tfor(ll i = 0; i < V; i++)\n\tfor (auto e:G[i]) {\n\t\tif (isBridge[e.id]) ans[e.id] = -1;\n\t\telse {\n\t\t\tif (d[e.to] + e.cost + d2[i] < d[1]) ans[e.id] = 1;\n\t\t\telse ans[e.id] = 0;\n\t\t}\n\t}\n\tfor (ll i = 0; i < E; i++) {\n\t\tif (ans[i] == -1) puts(\"SAD\");\n\t\telse if (ans[i] == 0) puts(\"SOSO\");\n\t\telse puts(\"HAPPY\");\n\t}\n\t\n\t\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN (100010)\n#define ll long long\n\nint n, m;\nstruct edge {\n    int u, v, w;\n}e[MAXN];\nstd::vector<std::pair<int, int>> vec[2][MAXN];\nstd::vector<int> mat[MAXN];\nint low[MAXN], dfn[MAXN], tot;\nll dis[2][MAXN];\nbool canbad[MAXN];\n\nvoid dijkstra(int type, ll *dis, bool *vis, int s) {\n    std::priority_queue<std::pair<ll, int>> pq;\n    memset(dis + 1, 0x3f, n * sizeof(ll));\n    memset(vis + 1, false, n * sizeof(bool));\n    dis[s] = 0;\n    pq.push({dis[s], s});\n    while (!pq.empty()) {\n        int u = pq.top().second; pq.pop();\n        if (vis[u]) continue;\n        vis[u] = true;\n        for (auto &p : vec[type][u]) {\n            int v = p.first, w = p.second;\n            if (dis[v] > dis[u] + w) {\n                dis[v] = dis[u] + w;\n                pq.push({-dis[v], v});\n            }\n        }\n    }\n}\n\nvoid dfs(int u) {\n    dfn[u] = low[u] = ++tot;\n    for (auto &v : mat[u]) {\n        if (!dfn[v]) {\n            dfs(v);\n            low[u] = std::min(low[u], low[v]);\n        } else {\n            low[u] = std::min(low[u], dfn[v]);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= m; ++i) {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        e[i] = {a, b, c};\n        vec[0][a].push_back({b, c});\n        vec[1][b].push_back({a, c});\n    }\n    dijkstra(0, dis[0], canbad, 1);\n    dijkstra(1, dis[1], canbad, 2);\n    ll origin = dis[0][2];\n\n    memset(canbad + 1, false, m * sizeof(bool));\n    for (int i = 1; i <= m; ++i) {\n        int u = e[i].u, v = e[i].v, w = e[i].w;\n        if (dis[0][u] + w == dis[0][v] && dis[1][v] + w == dis[1][u]) {\n            mat[u].push_back(v);\n            canbad[i] = true;\n        }\n    }\n    dfs(1);\n    for (int i = 1; i <= m; ++i) {\n        int u = e[i].u, v = e[i].v, w = e[i].w;\n        ll now = dis[0][v] + w + dis[1][u];\n        if (!canbad[i] || (canbad[i] && low[v] <= dfn[u])) {\n            now = std::min(now, origin);\n        }\n        if (now < origin) puts(\"HAPPY\");\n        else if (now == origin) puts(\"SOSO\");\n        else puts(\"SAD\");\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<tuple>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\n#define INF 0x3f3f3f3f\n#define eps 1e-8\nusing namespace std;\ntypedef long long ll;\n\nint n,m,a,b,x;\nstruct graph\n{\n    int from[maxn],to[maxn],no;\n    int head[maxn],nxt[maxn],val[maxn];\n    ll dis[maxn];\n    bool vis[maxn];\n    inline void init()\n    {\n        memset(head,-1,sizeof(head));\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<=n;i++)dis[i]=INF;\n        no=0;\n    }\n    inline void add(int a,int b,int x)\n    {\n        from[no]=a,to[no]=b;\n        val[no]=x;\n        nxt[no]=head[a];\n        head[a]=no++;\n    }\n    void spfa(int st)\n    {\n        queue<int>q;\n        vis[st]=1,dis[st]=0;\n        q.push(st);\n        while(!q.empty())\n        {\n            int u=q.front();\n            q.pop();\n            vis[u]=0;\n            for(int i=head[u];i!=-1;i=nxt[i])\n            {\n                int v=to[i];\n                if(dis[v]>dis[u]+val[i])\n                {\n                    dis[v]=dis[u]+val[i];\n                    if(!vis[v])\n                    {\n                        vis[v]=1;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n}G,opG;\n\nstruct node\n{\n    int to[maxn],nxt[maxn],head[maxn],vis[maxn];\n    int dfn[maxn],low[maxn],pre[maxn],val[maxn];\n    int dep,no;\n    map< tuple<int,int,int>,int >mo;\n    void init()\n    {\n        memset(vis,0,sizeof(vis));\n        memset(head,-1,sizeof(head));\n        memset(dfn,-1,sizeof(dfn));\n        memset(low,-1,sizeof(low));\n        no=dep=0;\n    }\n    void add(int a,int b,int x)\n    {\n        val[no]=x;\n        to[no]=b;\n        nxt[no]=head[a];\n        head[a]=no++;\n    }\n    void tarjan(int u,int fa)\n    {\n        dfn[u]=low[u]=++dep;\n        vis[u]=1;\n        for(int i=head[u];i!=-1;i=nxt[i])\n        {\n            int v=to[i];\n            if(!vis[v])\n            {\n                tarjan(v,u);\n                low[u]=min(low[u],low[v]);\n                if(dfn[u]<low[v])\n                {\n                    if(u<v)mo[make_tuple(u,v,val[i])]++;\n                    else mo[make_tuple(v,u,val[i])]++;\n                }\n            }\n            else if(fa!=v)\n                low[u]=min(low[u],dfn[v]);\n        }\n    }\n    void solve()\n    {\n        tarjan(1,0);\n        for(int i=1;i<=n;i++)\n        {\n            int v=pre[i];\n            if(v>0&&low[i]>dfn[v])\n            {\n                //cout<<i<<\" \"<<v<<endl;\n                if(i<v)mo[make_pair(i,v)]++;\n                else mo[make_pair(v,i)]++;\n            }\n        }\n    }\n}DAG;\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    G.init(),opG.init();\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%d\",&a,&b,&x);\n        G.add(a,b,x);\n        opG.add(b,a,x);\n    }\n    G.spfa(1);\n    opG.spfa(2);\n    DAG.init();\n    /*for(int i=1;i<=n;i++)\n        cout<<G.dis[i]<<\" \";\n    cout<<endl;\n    for(int i=1;i<=n;i++)\n        cout<<opG.dis[i]<<\" \";\n    cout<<endl;*/\n    for(int i=0;i<m;i++)\n    {\n        int u=G.from[i];\n        int v=G.to[i];\n        int w=G.val[i];\n        if(G.dis[u]+w+opG.dis[v]==G.dis[2])\n        {\n            DAG.add(u,v,w);\n            //cout<<u<<\" \"<<v<<endl;\n        }\n    }\n    //cout<<endl;\n    DAG.solve();\n    for(int i=0;i<m;i++)\n    {\n        int u=G.from[i];\n        int v=G.to[i];\n        int w=G.val[i];\n        if(G.dis[v]+w+opG.dis[u]<G.dis[2])\n            printf(\"HAPPY\\n\");\n        else\n        {\n            if(u>v)swap(u,v);\n            if(DAG.mo[make_tuple(u,v,w)])\n                printf(\"SAD\\n\");\n            else printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\n#define INF 0x7f7f7f7f\nconst int maxed = 100000 + 10;\ntypedef long long ll;\n\nstruct Node\n{\n    int u;\n    ll val;\n    bool operator < (const Node& n1) const\n    {\n        return val > n1.val;\n    }\n};\nstruct E\n{\n    int u, v, val, bef, id;\n}e[maxed * 2][3];\n\nint n, m, ans[3], head[maxed][3];\nll d[maxed][2];\nbool vis[maxed];\nint cnt, pre[maxed], low[maxed], dfn[maxed];\nbool is_cut[maxed];\n\nvoid add_(int x, int y, int val, int id, int cur);\nvoid slove(int s, int cur);\nvoid tarjan(int u, int fa);\n\nint main()\n{\n    ans[0] = ans[1] = ans[2] = 1;\n    memset(head, -1, sizeof(head));\n    scanf(\"%d%d\", &n, &m);\n    int a, b, c;\n    for (int i = 1; i <= m; ++i) {\n        scanf(\"%d%d%d\", &a, &b, &c);\n        add_(a, b, c, i, 0);\n        add_(b, a, c, i, 1);\n    }\n    for (int i = 1; i <= n; ++i)\n        d[i][0] = INF, d[i][1] = INF;\n    slove(1, 0);\n    slove(2, 1);\n    for (int i = 1; i < ans[0]; ++i)\n        if (d[e[i][0].u][0] + e[i][0].val + d[e[i][0].v][1] == d[2][0]) {\n            add_(e[i][0].u, e[i][0].v, e[i][0].val, e[i][0].id, 2);\n            add_(e[i][0].v, e[i][0].u, e[i][0].val, e[i][0].id, 2);\n        }\n    tarjan(1, 1);\n    for (int i = 1; i < ans[2]; ++i)\n        if (pre[e[i][2].u] == e[i][2].v && dfn[e[i][2].v] < low[e[i][2].u])\n            is_cut[e[i][2].id] = true;\n    for (int i = 1; i < ans[0]; ++i) {\n        if (d[e[i][0].u][0] + e[i][0].val + d[e[i][0].v][1] == d[2][0]) {\n            if (is_cut[e[i][0].id])\n                printf(\"SAD\\n\");\n            else\n                printf(\"SOSO\\n\");\n        }\n        else {\n            if (d[e[i][0].v][0] + e[i][0].val + d[e[i][0].u][1] < d[2][0])\n                printf(\"HAPPY\\n\");\n            else\n                printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\nvoid add_(int x, int y, int val, int id, int cur)\n{\n    e[ans[cur]][cur].u = x;\n    e[ans[cur]][cur].v = y;\n    e[ans[cur]][cur].val = val;\n    e[ans[cur]][cur].id = id;\n    e[ans[cur]][cur].bef = head[x][cur];\n    head[x][cur] = ans[cur]++;\n}\n\nvoid slove(int s, int cur)\n{\n    memset(vis, false, sizeof(vis));\n    std::priority_queue<Node> pq;\n    pq.push((Node){s, 0});\n    d[s][cur] = 0;\n    while (!pq.empty()) {\n        Node no = pq.top();\n        pq.pop();\n        if (vis[no.u])\n            continue;\n        vis[no.u] = true;\n        for (int i = head[no.u][cur]; i != -1; i = e[i][cur].bef) {\n            int v = e[i][cur].v;\n            ll val = d[no.u][cur] + e[i][cur].val;\n            if (d[v][cur] > val) {\n                d[v][cur] = val;\n                pq.push((Node){v, val});\n            }\n        }\n    }\n}\n\nvoid tarjan(int u, int fa)\n{\n    pre[u] = fa;\n    dfn[u] = low[u] = ++cnt;\n    for (int i = head[u][2]; i != -1; i = e[i][2].bef) {\n        int v = e[i][2].v;\n        if (!dfn[v]) {\n            tarjan(v, u);\n            low[u] = std::min(low[u], low[v]);\n        }\n        else if (v != fa)\n            low[u] = std::min(low[u], dfn[v]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Bridges */\n\nint bridges_dfs(int now, int backID, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n  \n  visited[now] = 1;\n  \n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == backID) continue;\n    \n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n  \n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n\nvector<bool> bridges(int n, const vector<pair<int,int> > &path){ //無向辺 & 多重辺考慮\n  vector<vector<pair<int,int> > >  way(n);\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n  \n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n  \n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n  \n  return bridges_flag;\n}\n\n\n\nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE], c[SIZE];\n  vector<int> way[SIZE], rway[SIZE];\n  \n  scanf(\"%d%d\",&n,&m);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n\n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n\n  //Dijkstra\n  priority_queue<pair<ll,int> > pq;\n  bool visited[SIZE] = {}, rvisited[SIZE] = {};\n  ll cost[SIZE], rcost[SIZE];\n  \n  pq.push({0,0});\n\n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n\n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n\n  pq.push({0,1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n\n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n\n  vector<pair<int,int> > Graph;\n  vector<int> pathID;\n  bool visited2[SIZE] = {};\n\n  pq.push({cost[1], 1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    int cur_cost = p.first;\n\n    if(visited2[now]) continue;\n    visited2[now] = true;\n    \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n      }\n    }\n  }\n\n  auto res = bridges(n, Graph);\n  bool isBridge[SIZE] = {};\n\n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n  \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    cnt[v] += (p != -1 ? cnt[p] : 1);\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, v });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && cnt1[u] * cnt2[v] == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %lld\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define N 200005\n#define MOD 1000000007\n#define bas 8741\n#define pli pair<LL, int>\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nint n, m, head[2][N], num[2], x, y, z, headb[N], cnt, low[N], dfn[N], cnt1;\nconst LL INF = (LL)1 << 50;\nbool flag[N], flage[N << 1];\nLL dis[3][N], ans, stand;\nstruct edge {\n    int fr, to, nxt, w, id;\n}a[2][N << 1], b[N << 1];\nvoid add(int x, int y, int z, int _id) {\n    a[0][++num[0]] = (edge){x, y, head[0][x], z, _id}, head[0][x] = num[0];\n    a[1][++num[1]] = (edge){y, x, head[1][y], z, _id}, head[1][y] = num[1];\n}\nvoid add2(int x, int y, int z, int _id) {\n    b[++cnt] = (edge){x, y, headb[x], z, _id}, headb[x] = cnt;\n}\npriority_queue<pli, vector<pli>, greater<pli> >q;\nvoid sssp(int st, int type) {\n    for(int i = 1; i <= n; ++i) {\n        dis[st][i] = INF;\n        flag[i] = 0;\n    }\n    dis[st][st] = 0;\n    while(!q.empty()) q.pop();\n    pli temp = mp(0, st);\n    q.push(temp);\n    while(!q.empty()) {\n        temp = q.top();\n        q.pop();\n        x = temp.se;\n        flag[x] = 1;\n        for(int e = head[type][x]; e; e = a[type][e].nxt) {\n            y = a[type][e].to, z = a[type][e].w;\n            if(dis[st][y] > dis[st][x] + z) {\n                dis[st][y] = dis[st][x] + z;\n                temp = mp(dis[st][y], y);\n                q.push(temp);\n            }\n        }\n    }\n}\nvoid dfs(int x, int f) {\n    low[x] = dfn[x] = ++cnt1;\n    flag[x] = 1;\n    for(int e = headb[x]; e; e = b[e].nxt) {\n        int k = b[e].to;\n        if(!flag[k]) {\n            dfs(k, x);\n            low[x] = min(low[x], low[k]);\n        }\n        else if(k != f) {\n            low[x] = min(low[x], dfn[k]);\n        }\n    }\n}\nvoid print(LL x, LL y) {\n    if(x > y) printf(\"SAD\\n\");\n    else if(x == y) printf(\"SOSO\\n\");\n    else printf(\"HAPPY\\n\");\n}\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i <= m; ++i) {\n        scanf(\"%d%d%d\", &x, &y, &z);\n        add(x, y, z, i);\n    }\n    sssp(1, 0);\n    sssp(2, 1);\n    for(int i = 1; i <= m; ++i) {\n        x = a[0][i].fr, y = a[0][i].to;\n        if(dis[1][x] + a[0][i].w == dis[1][y] && dis[2][y] + a[0][i].w == dis[2][x]) {\n            add2(x, y, z, i);\n            add2(y, x, z, i);\n            flage[i] = 1;\n        }\n    }\n    for(int i = 1; i <= n; ++i) flag[i] = 0;\n    dfs(1, 0);\n    for(int i = 1; i <= m; ++i) {\n        if(!flage[i]) continue;\n        x = a[0][i].fr, y = a[0][i].to;\n        if(low[y] <= dfn[x]) flage[i] = 0;\n    }\n    stand = dis[1][2];\n    for(int i = 1; i <= m; ++i) {\n        x = a[0][i].fr, y = a[0][i].to;\n        if(flage[i]) {\n            ans = dis[1][y] + a[0][i].w + dis[2][x];\n            print(ans, stand);\n        }\n        else {\n            ans = min(stand, dis[1][y] + a[0][i].w + dis[2][x]);\n            print(ans, stand);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000021;\nconst long long inf = 1LL << 61;\nstruct edge { int to, cost, id; };\nstruct state { int pos; long long cost; };\nbool operator<(const state& s1, const state& s2) { return s1.cost > s2.cost; }\nint N, M, dp[100009], dp2[100009], va[100009]; bool vis1[100009], vis2[100009]; vector<int> a, b, c;\nvector<long long> shortest_path(vector<vector<edge> > g, int src) {\n\tvector<long long> ret(g.size(), inf); ret[src] = 0;\n\tpriority_queue<state> que; que.push(state{ src, 0 });\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tfor (edge e : g[u]) {\n\t\t\tlong long nd = ret[u] + e.cost;\n\t\t\tif (ret[e.to] > nd) {\n\t\t\t\tret[e.to] = nd;\n\t\t\t\tque.push(state{ e.to, nd });\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvector<int> solve() {\n\tvector<vector<edge> > g(N);\n\tvector<vector<edge> > rg(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tg[a[i]].push_back(edge{ b[i], c[i], i });\n\t\trg[b[i]].push_back(edge{ a[i], c[i], i });\n\t}\n\tvector<long long> ds = shortest_path(g, 0);\n\tvector<long long> dt = shortest_path(rg, 1);\n\tvector<bool> ok(M);\n\tvector<vector<int> > sg(N), sr(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ds[a[i]] + c[i] + dt[b[i]] == ds[1]) {\n\t\t\tsg[a[i]].push_back(b[i]);\n\t\t\tsr[b[i]].push_back(a[i]);\n\t\t\tok[i] = true;\n\t\t}\n\t}\n\tfill(vis1, vis1 + N, false);\n\tfill(vis2, vis2 + N, false);\n\tfill(dp, dp + N, 0);\n\tfill(dp2, dp2 + N, 0);\n\tpriority_queue<state> que; que.push(state{ 0, 0 }); dp[0] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis1[u]) {\n\t\t\tvis1[u] = true;\n\t\t\tfor (int i : sg[u]) {\n\t\t\t\tdp[i] += dp[u];\n\t\t\t\tif (dp[i] >= mod) dp[i] -= mod;\n\t\t\t\tque.push(state{ i, ds[i] });\n\t\t\t}\n\t\t}\n\t}\n\tque.push(state{ 1, 0 }); dp2[1] = 1;\n\twhile (!que.empty()) {\n\t\tint u = que.top().pos; que.pop();\n\t\tif (!vis2[u]) {\n\t\t\tvis2[u] = true;\n\t\t\tfor (int i : sr[u]) {\n\t\t\t\tdp2[i] += dp2[u];\n\t\t\t\tif (dp2[i] >= mod) dp2[i] -= mod;\n\t\t\t\tque.push(state{ i, dt[i] });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) va[i] = 1LL * dp[i] * dp2[i] % mod;\n\tmap<tuple<int, int, int>, int> cnts;\n\tfor (int i = 0; i < M; i++) {\n\t\tcnts[make_tuple(a[i], b[i], c[i])]++;\n\t}\n\tvector<int> ret(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!ok[i]) {\n\t\t\tret[i] = (ds[b[i]] + dt[a[i]] + c[i] < ds[1] ? 2 : 1);\n\t\t}\n\t\telse {\n\t\t\tif (ds[b[i]] + dt[a[i]] + c[i] < ds[1]) ret[i] = 2;\n\t\t\telse if (ds[b[i]] + dt[a[i]] + c[i] == ds[1]) ret[i] = 1;\n\t\t\telse {\n\t\t\t\tif (va[a[i]] == va[0] && va[b[i]] == va[0] && cnts[make_tuple(a[i], b[i], c[i])] == 1) ret[i] = 0;\n\t\t\t\telse ret[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvector<int> brute_force() {\n\tvector<int> ret(M);\n\tvector<vector<edge> > ig(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tig[a[i]].push_back(edge{ b[i], c[i] });\n\t}\n\tlong long res = shortest_path(ig, 0)[1];\n\tif (res == inf) return { -1 };\n\tfor (int i = 0; i < M; i++) {\n\t\tvector<vector<edge> > g(M);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (i != j) g[a[j]].push_back(edge{ b[j], c[j] });\n\t\t\telse g[b[j]].push_back(edge{ a[j], c[j] });\n\t\t}\n\t\tlong long re = shortest_path(g, 0)[1];\n\t\tif (re < res) ret[i] = 2;\n\t\tif (re == res) ret[i] = 1;\n\t\tif (re > res) ret[i] = 0;\n\t}\n\treturn ret;\n}\nint rand_rng(int l, int r) {\n\tlong long seed = rand() * 123456789LL + rand() * 3456789LL + rand() * 12345LL;\n\treturn l + (seed) % (r - l);\n}\nvoid random_test() {\n\tN = 4; M = 4;\n\tfor (int i = 0; i < 10000; i++) {\n\t\ta = vector<int>(M);\n\t\tb = vector<int>(M);\n\t\tc = vector<int>(M);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\twhile (a[j] == b[j]) {\n\t\t\t\ta[j] = rand_rng(0, N);\n\t\t\t\tb[j] = rand_rng(0, N);\n\t\t\t}\n\t\t\tc[j] = rand_rng(1, 10);\n\t\t}\n\t\tvector<int> ret1 = brute_force();\n\t\tif (ret1[0] != -1) {\n\t\t\tvector<int> ret2 = solve();\n\t\t\tif (ret1 != ret2) {\n\t\t\t\tcout << \"BUG\" << endl;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\nint main() {\n\t//random_test();\n\tios::sync_with_stdio(false);\n\tcin >> N >> M;\n\ta = vector<int>(M);\n\tb = vector<int>(M);\n\tc = vector<int>(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; a[i]--, b[i]--;\n\t}\n\tvector<int> ret = solve();\n\tfor (int i = 0; i < M; i++) {\n\t\tif (ret[i] == 2) cout << \"HAPPY\\n\";\n\t\telse if (ret[i] == 1) cout << \"SOSO\\n\";\n\t\telse cout << \"SAD\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                 \n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nint inf2=1000000000ll*100000ll;\nint n,m;\nvector<pa>G[100030],G2[100030];\nvector<int> dag[100030],dag2[100030];\nint s1[100030],s2[100030],a[100030],b[100030],c[100030];\nint ans[100030]={0};\nbool sumi[100030]={0};\npriority_queue<pa,vector<pa>,greater<pa>> pq;\nint nyu[100030]={0},shu[100030]={0};\nint ok[100030]={0};\n\n\nvector<int> topo;\nint jisuu[100030]={0};\n\nvoid toporoji(){\n\t\n\tqueue<int> qu;\n\tqu.push(1);\n\t\n\tfor(int i=1;i<=n;i++)for(auto v:dag[i])jisuu[v]++;\n\t\n\twhile(qu.size()>0){\n\t\tint r=qu.front();\n\t\tqu.pop();\n\t\ttopo.pb(r);\n\t\t\n\t\tfor(auto v:dag[r]){\n\t\t\tjisuu[v]--;\n\t\t\tif(jisuu[v]==0) qu.push(v);\n\t\t}\n\t}\n \t\n}\n\nvoid saiki(int u){\n\t\n\tint s=dag[u].size(),nn=dag2[u].size();\n\t\n\tfor(auto v:dag2[u]){\n\t\ts+=shu[v];\n\t\tnn+=nyu[v];\n\t}\n\tshu[u]=s,nyu[u]=nn;\n\n\t\n}\n \n            signed main(){\n   cin>>n>>m;\n            \tfor(int i=0;i<m;i++){\n            \tint y,yy,yyy;\n            \t\tcin>>y>>yy>>yyy;\n            \t\tG[y].pb(mp(yy,yyy));\n            \t\tG2[yy].pb(mp(y,yyy));\n            \t\ta[i]=y;\n            \t\tb[i]=yy;\n            \t\tc[i]=yyy;\n            \t\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s1[i]=inf2;\n            \tpq.push(mp(0,1));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts1[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s2[i]=inf2;\n            \tpq.push(mp(0,2));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts2[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G2[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \t\n            \tint len=s1[2];\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\tif(s1[a[i]]+s2[b[i]]+c[i]==len){\n            \t\t\tdag[a[i]].pb(b[i]);\n            \t\t\tdag2[b[i]].pb(a[i]);\n            \t\t\t\n            \t//\t\tcout<<a[i]<<\" \"<<b[i]<<endl;\n            \t\t\n            \t\t}\n            \t\telse{\n            \t\t\tif(s1[b[i]]+s2[a[i]]+c[i]<len)ans[i]=1;\n            \t\t\telse ans[i]=3;\n            \t\t\t\n            \t\t\t\n            \t\t}\n            \t\t\n            \t}\n            //\tsaiki(1);\n            \ttoporoji();\n            \t\n            \tfor(auto v:topo)saiki(v);\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\t\n            \t\tif(ans[i])continue;\n            \t\tif(dag[a[i]].size()>1)ans[i]=3;\n            \t\telse if(dag2[b[i]].size()>1)ans[i]=3;\n            \t\telse if(shu[a[i]]-1!=nyu[a[i]])ans[i]=3;\n            \t\telse ans[i]=2;\n            \t}\n            \tfor(int i=0;i<m;i++){\n            \t\tif(ans[i]==1)cout<<\"HAPPY\"<<endl;\n            \t\tif(ans[i]==2)cout<<\"SAD\"<<endl;\n            \t\tif(ans[i]==3)cout<<\"SOSO\"<<endl;\n            \t}\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n\nconst ll INF = 1e15;\n\nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n\tdist[f->dst] = e.weight + f->weight;\n\tQ.push(Edge(f->src, f->dst, e.weight + f->weight));\n\tprev[f->dst].clear();\n\tprev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n\tprev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n\npair<Graph, Graph> buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  Graph g2(n);\n  stack<int> st;\n  st.push(t);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    for(auto&& p : prev[now]){\n      if(p < 0)\n\tcontinue;\n      g[p].push_back(Edge(p, now, 1));\n      g2[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return pair<Graph, Graph>(g, g2);\n}\n\nint main(){\n  ll n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w*2, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w*2 == befo.first)\n\tmp[P(s, d)] = P(w*2-1, befo.second + 1);\n      else\n\tmp[P(s, d)] = P(min(w*2, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree, tree2;\n  tie(tree, tree2) = buildPath(prev, 1);\n  for(int i=0;i<tree2.size();i++){\n    sort(tree2[i].begin(), tree2[i].end());\n  }\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n\n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n\n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n    \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w*2)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    for(int i=0;i<tree2[s].size();i++){\n      ok |= binary_search(tree2[s].begin(), tree2[s].end(), Edge(s, d, 1));\n      //cout << \"tr: \" << tree[s][i].src << \" \" << tree[s][i].dst << endl;\n    }\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}\n/*\n11 15\n1 3 1\n3 6 2\n6 10 1\n1 5 3\n3 7 1\n5 9 1\n9 11 1\n7 8 1\n1 4 2\n4 8 1\n8 10 1\n10 11 1\n11 2 1\n10 7 1\n10 1 1\n */"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 99999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tll node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <tuple>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nstruct CostGraph {\n    using T = ll;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge() {}\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        int from;\n        int to;\n        T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\n\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\nvoid ReverseDijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.rev_edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nclass BiconnectedComponent\n{\npublic:\n    BiconnectedComponent(const CostGraph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            bridge_dfs(g_, i);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    CostGraph toTree() const\n    {\n        CostGraph tree(comp_num);\n        for (const auto& e : bridge) {\n            tree.addEdge(comp[e.from], comp[e.to], 1);\n            tree.addEdge(comp[e.to], comp[e.from], 1);\n        }\n        return tree;\n    }\n    const vector<CostGraph::Edge>& getEdge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i];\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\nprivate:\n    void bridge_dfs(const CostGraph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n            }\n            if (isBridge(s, to)) {\n                bridge.push_back(e);\n            }\n        }\n    }\n\n    void comp_dfs(const CostGraph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n    int num;\n    int comp_num;\n    const int size;\n    vector<CostGraph::Edge> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    CostGraph g(n);\n    using pii = pair<int, int>;\n    map<pii, ll> cost;\n    vector<pii> edge(m);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--, b--;\n        g.addEdge(a, b, c);\n        edge[i] = make_pair(a, b);\n        cost[edge[i]] = c;\n    }\n    vector<ll> ds(n, INF<ll>);\n    Dijkstra(g, 0, ds);\n    vector<ll> dt(n, INF<ll>);\n    ReverseDijkstra(g, 1, dt);\n    show(ds);\n    show(dt);\n    const ll D = ds[1];\n    CostGraph undg(n);\n    for (int i = 0; i < m; i++) {\n        const pii e = edge[i];\n        const int u = e.first;\n        const int v = e.second;\n        const ll c = cost[e];\n        if (ds[u] + c == ds[v]) {\n            undg.addEdge(u, v, 1);\n            undg.addEdge(v, u, 1);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (const auto& e : undg.edge[i]) {\n            cerr << e.from << \"->\" << e.to << endl;\n        }\n    }\n\n    BiconnectedComponent bic(undg);\n    for (int i = 0; i < m; i++) {\n        const pii e = edge[i];\n        const int u = e.first;\n        const int v = e.second;\n        const ll c = cost[e];\n        if (ds[v] + c + dt[u] < D) {\n            cout << \"HAPPY\" << endl;\n        } else {\n            if (bic.isBridge(u, v)) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(I,A,B) for (int I=(A),_END_=(B);I<=_END_;I++)\n#define FOR(I,A,B) for (int I=(A),_END_=(B);I<_END_;I++)\n#define REPD(I,A,B) for (int I=(A),_END_=(B);I>=_END_;I--)\n\nusing namespace std;\n\nconst int MAXN = 101010;\nconst int MAXM = 102020;\nconst long long inf = 1000000000000000000ll;\n\nint n,m;\nstruct line{\n\tint a,b,c;\n\tint id;\n}L[MAXN];\n\nstruct dis_graph{\n\tint tot;\n\tint nxt[MAXM];\n\tint to[MAXM];\n\tint hd[MAXN];\n\tint val[MAXM];\n\n\tlong long dis[MAXN];\n\tint vis[MAXN];\n\n\tinline void add(const int &x, const int &y,const int &VL){\n\t\t++tot;\n\t\tto[tot]=y;\n\t\tnxt[tot]=hd[x];\n\t\tval[tot]=VL;\n\t\thd[x]=tot;\n\t}\n\n\tvoid ssap(int ST){\n\t\tqueue<int> Q;\n\t\tmemset(vis, 0 ,sizeof vis);\n\t\tREP(i,1,n) dis[i]=inf;\n\t\tdis[ST]=0;\n\t\tQ.push(ST);\n\t\twhile (!Q.empty()){\n\t\t\tint now = Q.front(); Q.pop();\n\t\t\tvis[now]=0;\n\t\t\tfor (int i=hd[now]; i ; i=nxt[i])\n\t\t\tif ( dis[to[i]] > dis[now] + val[i])\n\t\t\t{\n\t\t\t\tdis[to[i]] = dis[now] + val[i];\n\t\t\t\tif ( !vis[ to[i] ] ) { vis[ to[i] ] = 1; Q.push( to[i] ); }\n\t\t\t}\n\t\t}\n\t}\n\n}F,G;\n\nstruct DAG{\n\tint br[MAXM];\n\tint to[MAXM];\n\tint nxt[MAXM];\n\tint vis[MAXM];\n\n\tint dfn[MAXN];\n\tint low[MAXN];\n\tint hd[MAXN];\n\n\tint df_time;\n\tint tot;\n\n\tinline void init(){\n\t\tdf_time=0;\n\t\ttot=-1;\n\t\tmemset(hd,-1,sizeof hd);\n\t}\n\t\n\tvoid add(const int &x,const int &y){\n\t\t++tot;\n\t\tto[tot]=y;\n\t\tnxt[tot]=hd[x];\n\t\thd[x]=tot;\n\t}\n\n\tvoid tarjan( int u, int fa =-1)\n\t{\n\t\tdfn[u]=low[u]=++df_time;\n\t\tvis[u] =1;\n\t\tfor ( int i=hd[u]; i!=-1 ; i=nxt[i] )\n\t\tif ( fa!=i )\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif ( !vis[v] )\n\t\t\t{\n\t\t\t\ttarjan(v,i^1);\n\t\t\t\tlow[u]=min(low[v],low[u]);\n\t\t\t\tif ( dfn[u] < low[v])\n\t\t\t\t\tbr[i] = br[i^1] =1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlow[u]=min( low[u] , dfn[v] );\n\t\t}\n\t}\n}H;\n\n\nvoid init(){\n\tscanf(\"%d%d\",&n,&m);\n\tint a,b,c;\n\tREP(i,1,m)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tL[i].a=a;\n\t\tL[i].b=b;\n\t\tL[i].c=c;\n\t\tF.add(a,b,c);\n\t\tG.add(b,a,c);\n\t}\n\tF.ssap(1);\n\tG.ssap(2);\n\n\tH.init();\n\tREP(i,1,m)\n\t{\n\t\ta=L[i].a;\n\t\tb=L[i].b;\n\t\tc=L[i].c;\n\t\tif ( F.dis[a]+c+G.dis[b] == F.dis[2] )\n\t\t{\n\t\t\tH.add(a,b);\n\t\t\tH.add(b,a);\n\t\t\tL[i].id=H.tot;\n\t\t}\n\t}\n\n\tH.tarjan(1);\n\n}\n\nvoid work(){\n\tint a,b,c;\n\tREP(i,1,m)\n\t{\n\t\ta=L[i].a;\n\t\tb=L[i].b;\n\t\tc=L[i].c;\n\n\t\tif ( F.dis[b] + c + G.dis[a] < F.dis[2] )\n\t\t\tprintf(\"HAPPY\\n\");\n\t\telse\n\t\t{\n\t\t\tif (L[i].id && H.br[ L[i].id ])\n\t\t\t\tprintf(\"SAD\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n            if(ord[now] < low[nxt]) {\n                bridges.insert(nxt_e.index);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;    \n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        edges.push_back(Edge{i, a - 1, b - 1, c, false});\n    }\n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return make_tuple(a.from, a.to, a.cost) < make_tuple(b.from, b.to, b.cost);\n        });\n    rep(i, M) {\n        auto &e = edges[i]; // mut\n        int index = e.index;\n        int a = e.from;\n        int b = e.to;\n        int c = e.cost;\n        if(i > 0) {\n            auto &pe = edges[i - 1]; // mut\n            if(pe.from == a and pe.to == b) {\n                e.multi = true;\n                if(pe.cost == e.cost) edges[i - 1].multi = true;\n                continue;\n            }\n        }\n        E[a].push_back(Edge{index, a, b, c});\n        rE[b].push_back(Edge{index, b, a, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    auto bridges = enumerate_bridges(shortest_graph);\n    \n    sort(begin(edges), end(edges), [] (const Edge &a, const Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        const Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and not e.multi) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef Wavator\n#define de(...) fprintf(stderr, __VA_ARGS__), fflush(stderr);\n#else\n#define de(...) 98;\n#endif\n#define pb push_back\n#define XX first\n#define YY second\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VLL;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<pair<int, int> > VPI;\nconst int N = 100005;\n\nll posDis[N], revDis[N];\n\nstruct bian\n{\n    int id, to, w;\n};\n\nvector<bian> zheng[N], fan[N],e[N];\nbool vis[N];\nstring ans[N];\nstring soso=\"SOSO\", sad = \"SAD\", happy = \"HAPPY\";\n\n\n\nint clk,dfn[N],bridge[N],low[N];\n\nvoid dfs(int u, int fa)\n{\n    dfn[u]=low[u]=++clk;\n    for(auto &x: e[u])\n    {\n        int v = x.to;\n        if (!dfn[v])\n        {\n            dfs(v,u);\n            low[u]=min(low[v],low[u]);\n            if(dfn[u] < low[v])\n            {\n                bridge[x.id]=1;\n            }\n        }\n        else if(fa != v)\n            low[u]=min(dfn[v],low[u]);\n    }\n}\n\nint main()\n{\n#ifdef Wavator\n    freopen(\"test.in\", \"r\", stdin);\n#endif\n    int n, m;\n    scanf(\"%d%d\",&n,&m);\n\n\n\n    for (int i = 0; i < m; ++i)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        zheng[u].push_back(bian{i,v,w});\n        fan[v].push_back(bian{i,u,w});\n    }\n\n    priority_queue<pair<ll, int> > q;\n\n    const ll inf = 1LL<<60LL;\n\n    for (int i = 0; i <= n; ++i)\n        posDis[i]=inf, revDis[i]=inf;\n\n    q.push(make_pair(posDis[1]=0,1));\n\n    while (!q.empty())\n    {\n        int u = q.top().second;\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto &e: zheng[u])\n        {\n            ll c = e.w;\n            if (posDis[e.to] > c + posDis[u])\n            {\n\n                posDis[e.to] = c + posDis[u];\n                q.push(make_pair(-posDis[e.to],e.to));\n            }\n        }\n    }\n\n\n\n    memset(vis,0,sizeof(vis));\n\n    q.push(make_pair(revDis[2]=0,2));\n\n    while (!q.empty())\n    {\n        int u = q.top().second;\n        q.pop();\n        if (vis[u])\n            continue;\n        vis[u] = 1;\n        for (auto &e: fan[u])\n        {\n            ll c = e.w;\n            if (revDis[e.to] > revDis[u] + c)\n            {\n                revDis[e.to] = revDis[u] + c;\n                q.push(make_pair(-revDis[e.to],e.to));\n            }\n        }\n    }\n\n    //for (int i = 1; i <= n; ++i) cerr  << revDis[i] << endl;\n\n    for (int i = 1; i <= n; ++i)\n        for (auto &x: zheng[i])\n        {\n            int v=x.to;\n            if(posDis[v]+revDis[v]==posDis[2]&&posDis[i]+x.w==posDis[v])\n            {\n                e[i].push_back(x);\n                e[v].push_back(bian{x.id,i,x.w});\n            }\n        }\n\n\n    dfs(1,-1);\n\n\n\n    for(int i = 1; i <= n; ++i)\n    {\n        for (auto &x: zheng[i])\n        {\n            if(bridge[x.id])\n                ans[x.id]=sad;\n            else if(posDis[x.to] + x.w + revDis[i] < posDis[2])\n                ans[x.id]=happy;\n            else\n                ans[x.id]=soso;\n        }\n    }\n\n    for(int i=0;i<m;++i)\n        cout<<ans[i]<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<ll,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %lld\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tll tmp_code;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_code = edge[i].from*1000000000+edge[i].to;\n\n\t\t\tauto at = MAP.find(tmp_code);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_code]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_code] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_code = edge[i].from*1000000000+edge[i].to;\n\n\t\tif(MAP[tmp_code] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n    bool multi;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;    \n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        // E[a].push_back(Edge{i, a, b, c});\n        // rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c, false});\n    }\n    sort(begin(edges), end(edges), [] (Edge &a, Edge &b) {\n            return make_tuple(a.from, a.to, a.cost) < make_tuple(b.from, b.to, b.cost);\n        });\n    rep(i, M) {\n        int index = edges[i].index;\n        int a = edges[i].from;\n        int b = edges[i].to;\n        int c = edges[i].cost;\n        if(i > 0) {\n            auto &pe = edges[i - 1];\n            if(pe.from == a and pe.to == b and pe.cost > c) {\n                edges[i].multi = true;\n                continue;\n            }\n            if(pe.from == a and pe.to == b and pe.cost == c) {\n                edges[i].multi = true;\n                edges[i - 1].multi = true;\n                continue;\n            }\n        }  \n        E[a].push_back(Edge{index, a, b, c});\n        rE[b].push_back(Edge{index, b, a, c});\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    // cerr << \"shortest path\" << endl;\n    // for(auto es : shortest_graph) {\n    //     for(Edge e : es) {\n    //         cerr << e.from + 1 << \" \" << e.to + 1 << endl;\n    //     }\n    // }\n    // debug(\"--\");\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n\n    // for(int b : bridges) {\n    //     debug(b);\n    // }\n    sort(begin(edges), end(edges), [] (Edge &a, Edge &b) {\n            return a.index < b.index;\n        });\n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and not e.multi){\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n    vector<vector<pii>> min_edge_num(N, vector<pii>(N, make_pair(0, 1e9)));\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        E[a].push_back(Edge{i, a, b, c});\n        rE[b].push_back(Edge{i, b, a, c});\n        edges.push_back(Edge{i, a, b, c});\n        if(min_edge_num[a][b].second > c) {\n            min_edge_num[a][b] = make_pair(1, c);\n        } else if(min_edge_num[a][b].second == c) {\n            min_edge_num[a][b].first++;\n        }\n    }\n\n    vector<ll> dist, r_dist;\n    vector<vector<Edge>> shortest_graph, r_shortest_graph;\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    tie(r_dist, r_shortest_graph) = dijkstra(rE, 1);\n\n    assert(dist[1] < INFL);\n    assert(dist[1] == r_dist[0]);\n\n    // cerr << \"shortest path\" << endl;\n    // for(auto es : shortest_graph) {\n    //     for(Edge e : es) {\n    //         cerr << e.from + 1 << \" \" << e.to + 1 << endl;\n    //     }\n    // }\n    // debug(\"--\");\n    \n    auto bridges = enumerate_bridges(shortest_graph);\n\n    // for(int b : bridges) {\n    //     debug(b);\n    // }\n    \n    rep(i, M) {\n        Edge &e = edges[i];\n        if(dist[e.to] + e.cost + r_dist[e.from] < dist[1]) {\n            cout << \"HAPPY\" << endl;\n        } else if(dist[e.to] + e.cost + r_dist[e.from] == dist[1]) {\n            cout << \"SOSO\" << endl;\n        } else if(dist[e.from] + e.cost + r_dist[e.to] == dist[1] and bridges.count(i) and min_edge_num[e.from][e.to].first == 1) {\n            cout << \"SAD\" << endl;\n        } else {\n            cout << \"SOSO\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n \n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n \n#include <complex>\n \n#include <functional>\n#include <cassert>\n \ntypedef long long ll;\nusing namespace std;\n \n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n \n \n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n \n/* Bridges */\n \nint bridges_dfs(int now, int backID, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n   \n  visited[now] = 1;\n   \n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == backID) continue;\n     \n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n   \n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n \nvector<bool> bridges(int n, const vector<pair<int,int> > &path){ //無向辺 & 多重辺考慮\n  vector<vector<pair<int,int> > >  way(n);\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n   \n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n   \n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n   \n  return bridges_flag;\n}\n \n \n \nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE], c[SIZE];\n  vector<int> way[SIZE], rway[SIZE];\n   \n  scanf(\"%d%d\",&n,&m);\n \n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n \n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n \n  //Dijkstra\n  priority_queue<pair<ll,int> > pq;\n  bool visited[SIZE] = {}, rvisited[SIZE];\n  ll cost[SIZE], rcost[SIZE];\n   \n  pq.push({0,0});\n \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n \n    int now = p.second;\n    ll cur_cost = p.first;\n \n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n \n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n \n  pq.push({0,1});\n   \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n \n    int now = p.second;\n    ll cur_cost = p.first;\n \n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n \n  vector<pair<int,int> > Graph;\n  vector<int> pathID;\n  bool visited2[SIZE] = {};\n \n  pq.push({cost[1], 1});\n   \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n \n    int now = p.second;\n    ll cur_cost = p.first;\n \n    if(visited2[now]) continue;\n    visited2[now] = true;\n     \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n      }\n    }\n  }\n \n  auto res = bridges(n, Graph);\n  bool isBridge[SIZE] = {};\n \n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n   \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n   \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n\nusing std::vector;\nusing std::queue;\nusing std::priority_queue;\n\nconst long long INF=1ll<<60;\n\nvector <int> e[2][200000];\n\nlong long dis1[2][200000];\nlong long dis2[2][200000];\nint from[2][200000];\n\nint in[200000];\n\nstruct po\n{\n\tint no;\n\tlong long v;\n\tpo(){};\n\tpo(int no,long long v):no(no),v(v){};\n};\nbool operator < (const po &fi,const po &se)\n{\n\treturn fi.v!=se.v?fi.v<se.v:fi.no<se.no;\n}\npriority_queue <po> pq;\n\nint n,m;\n\nstruct edge\n{\n\tint u,v,w;\n};\n\nedge r[400000];\n\nvoid dij(int s,int o)\n{\n\twhile(!pq.empty())\n\t\tpq.pop();\n\tmemset(in,0,sizeof(in));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdis1[o][i]=dis2[o][i]=INF;\n\t\tfrom[o][i]=-1;\n\t}\n\tdis1[o][s]=0;\n\tpq.push(po(s,dis1[o][s]));\n\twhile(!pq.empty())\n\t{\n\t\tint cur=pq.top().no;\n\t\tpq.pop();\n\t\tif(in[cur])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tin[cur]=1;\n\t\tfor(size_t i=0;i<e[o][cur].size();i++)\n\t\t{\n\t\t\tint w=e[o][cur][i];\n\t\t\tint t=r[w].v;\n\t\t\tlong long v=dis1[o][cur]+r[w].w;\n\t\t\tif(v<=dis1[o][t])\n\t\t\t{\n\t\t\t\tif(v<dis1[o][t])\n\t\t\t\t{\n\t\t\t\t\tif(!in[t])\n\t\t\t\t\t{\n\t\t\t\t\t\tpq.push(po(t,-v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(from[o][t]!=e[o][cur][i])\n\t\t\t\t{\n\t\t\t\t\tdis2[o][t]=dis1[o][t];\n\t\t\t\t}\n\t\t\t\tdis1[o][t]=v;\n\t\t\t\tfrom[o][t]=e[o][cur][i];\n\t\t\t}\n\t\t\telse if(v<dis2[o][t]&&e[o][cur][i]!=from[o][t])\n\t\t\t{\n\t\t\t\tdis2[o][t]=v;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\nvoid spfa(int s,int o)\n{\n\tmemset(in,0,sizeof(in));\n\twhile(!pq.empty())\n\t\tpq.pop_front();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdis1[o][i]=dis2[o][i]=INF;\n\t\tfrom[o][i]=-1;\n\t}\n\tpq.push_front(s);\n\tdis1[o][s]=0;\n\twhile(!pq.empty())\n\t{\n\t\tint cur=pq.front();\n\t\tpq.pop_front();\n\t\tin[cur]=0;\n\t\tfor(size_t i=0;i<e[o][cur].size();i++)\n\t\t{\n\t\t\tint t=r[e[o][cur][i]].v;\n\t\t\tlong long v=(long long)r[e[o][cur][i]].w+dis1[o][cur];;\n\t\t\tif(v<=dis1[o][t])\n\t\t\t{\n\t\t\t\tif(from[o][t]!=e[o][cur][i])\n\t\t\t\t{\n\t\t\t\t\tdis2[o][t]=dis1[o][t];\n\t\t\t\t}\n\t\t\t\tdis1[o][t]=v;\n\t\t\t\tfrom[o][t]=e[o][cur][i];\n\t\t\t\tif(!in[t])\n\t\t\t\t{\n\t\t\t\t\tif(rand()&1)\n\t\t\t\t\t\tpq.push_back(t);\n\t\t\t\t\telse\n\t\t\t\t\t\tpq.push_front(t);\n\t\t\t\t\tin[t]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(v<dis2[o][t]&&e[o][cur][i]!=from[o][t])\n\t\t\t{\n\t\t\t\tdis2[o][t]=v;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n*/\n\nlong long dp[2][200000];\nint deg[2][200000];\nconst long long MOD=19990523ll;\n\nqueue <int> q;\nvoid bfs(int s,int o)\n{\n\twhile(!q.empty())\n\t\tq.pop();\n\tdp[o][s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint cur=q.front();\n\t\tq.pop();\n\t\tfor(size_t i=0;i<e[o][cur].size();i++)\n\t\t{\n\t\t\tint w=e[o][cur][i];\n\t\t\tif(dis1[o][cur]+r[w].w==dis1[o][r[w].v])\n\t\t\t{\n\t\t\t\tdeg[o][r[w].v]--;\n\t\t\t\tdp[o][r[w].v]=(dp[o][r[w].v]+dp[o][cur])%MOD;\n\t\t\t\tif(deg[o][r[w].v]==0)\n\t\t\t\t{\n\t\t\t\t\tq.push(r[w].v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tsrand(time(0));\n#ifdef LYT_LOCAL\n\tfreopen(\"f.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v,k;\n\t\tscanf(\"%d %d %d\",&u,&v,&k);\n\t\tr[i].u=u;\n\t\tr[i].v=v;\n\t\tr[i].w=k;\n\t\tr[i+m].u=v;\n\t\tr[i+m].v=u;\n\t\tr[i+m].w=k;\n\t\te[0][u].push_back(i);\n\t\te[1][v].push_back(i+m);\n\t}\n\tdij(1,0);\n\tdij(2,1);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(dis1[0][r[i].u]+r[i].w==dis1[0][r[i].v])\n\t\t\tdeg[0][r[i].v]++;\n\t}\n\tfor(int i=m+1;i<=2*m;i++)\n\t{\n\t\tif(dis1[1][r[i].u]+r[i].w==dis1[1][r[i].v])\n\t\t\tdeg[1][r[i].v]++;\n\t}\n\tbfs(1,0);\n\tbfs(2,1);\n\tlong long ini=dis1[0][2];\n\tlong long bi=dp[0][2];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tlong long now=r[i].w;\n\t\tint u=r[i].u,v=r[i].v;\n\t\tif(i!=from[0][v])\n\t\t{\n\t\t\tnow+=dis1[0][v];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnow+=dis2[0][v];\n\t\t}\n\t\tif(i+m!=from[1][u])\n\t\t{\n\t\t\tnow+=dis1[1][u];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnow+=dis2[1][u];\n\t\t}\n\t\tif(now<ini)\n\t\t{\n\t\t\tputs(\"HAPPY\");\n\t\t}\n\t\telse if(now==ini)\n\t\t{\n\t\t\tputs(\"SOSO\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(dis1[0][r[i].u]+r[i].w+dis1[1][r[i].v]==ini&&dp[0][r[i].u]*dp[1][r[i].v]%MOD==bi)\n\t\t\t{\n\t\t\t\tputs(\"SAD\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"SOSO\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define rep(i, j) for(int i = 0; i < (int)(j); i++)\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> ostream&\noperator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n\nconst ll INFL = 1LL << 40;\n\nstruct Edge {\n    int index, from, to;\n    ll cost;\n};\n\nusing EdgeList = vector<vector<Edge>>;\n\n// ?????£?????????????????°?????? E ???????????????\n// O(N + M) N: ????????°, M: ?????°\nset<int> enumerate_bridges(const EdgeList &E) {\n    int N = E.size();\n    vector<int> ord(N, -1), low(N);\n    int cnt = 0;\n    set<int> bridges;\n    function<void(int, int)> dfs = [&] (int now, int pre) {\n        ord[now] = cnt++;\n        low[now] = ord[now];\n        for(const Edge &nxt_e : E[now]) {\n            int nxt = nxt_e.to;\n            if(ord[nxt] < 0) {\n                // not visited\n                dfs(nxt, now);\n                low[now] = min(low[now], low[nxt]);\n                if(ord[now] < low[nxt]) {\n                    bridges.insert(nxt_e.index);\n                }\n            } else if(nxt != pre) {\n                // visited\n                low[now] = min(low[now], ord[nxt]);\n            }\n        }\n    };\n    // ??£?????°????????????dfs(0)????????§OK?????????\n    rep(i, N) if(ord[i] < 0) dfs(i, -1);\n    return bridges;\n}\n\n\nstruct State {\n    int index;    \n    ll cost;\n    int from;\n    Edge e;\n    bool operator > (const State &r) const { return cost > r.cost; }\n};\n\ntuple<vector<ll>, vector<vector<Edge>>> dijkstra(const EdgeList &G, int start) {    \n    priority_queue<State, vector<State>, greater<State>> que;\n    vector<ll> dist(G.size(), INFL);\n    vector<vector<Edge>> shortest_graph(G.size());    \n    que.push(State{start, 0, -1});\n    dist[start] = 0;\n    while(not que.empty()) {\n        State now = que.top(); que.pop();\n        if(dist[now.index] < now.cost) continue;\n        if(now.from >= 0) {\n            shortest_graph[now.from].push_back(now.e);\n            shortest_graph[now.index].push_back(Edge{now.e.index, now.e.from, now.e.to, now.e.cost});\n        }\n        for(Edge e : G[now.index]){\n            if(dist[e.to] >= now.cost + e.cost){\n                State nxt = State{ e.to, now.cost + e.cost, now.index, e};\n                dist[e.to] = nxt.cost;\n                que.push(nxt);\n            }\n        }\n    }\n    return make_tuple(dist, shortest_graph);\n}\n\n\nll solve(int N, const vector<Edge> &es) {\n    vector<ll> dist;\n    vector<vector<Edge>> shortest_graph;\n    EdgeList E(N);\n    for(auto &e : es) E[e.from].push_back(e);\n    tie(dist, shortest_graph) = dijkstra(E, 0);\n    return dist[1];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M; cin >> N >> M;\n    EdgeList E(N), rE(N);\n    vector<Edge> edges;\n\n    rep(i, M) {\n        int a, b, c; cin >> a >> b >> c;\n        a--; b--;\n        edges.push_back(Edge{i, a, b, c});\n    }\n    ll best = solve(N, edges);\n    rep(i, M) {\n        swap(edges[i].from, edges[i].to);\n        ll ans = solve(N, edges);\n        cout << (ans < best ? \"HAPPY\" : ans == best ? \"SOSO\" : \"SAD\") << endl;\n        swap(edges[i].from, edges[i].to);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\nconst ll INF=0x3f3f3f3f;\nstruct HeapNode\n{\n    ll d;\n    int u;\n    bool operator<(const HeapNode &rhs)const\n    {\n        return d>rhs.d;\n    }\n};\nstruct Edge\n{\n    int from,to;\n    ll cost;\n};\nstruct Dij\n{\n    int n,m;\n    vector<int>G[maxn];\n    vector<int>G1[maxn];\n    vector<Edge>edges;\n    vector<Edge>edges1;\n    bool done[maxn];\n    ll d[maxn];\n    vector<int>p[maxn];\n    vector<int>p2[maxn];\n    ll d1[maxn];\n    void init(int n)\n    {\n        this->n=n;\n        for(int i=0;i<=n;i++)\n        {\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    void addedge(int from,int to,int cost)\n    {\n        edges.push_back(Edge{from,to,cost});\n        edges1.push_back((Edge){to,from,cost});\n        m=edges.size();\n        G[from].push_back(m-1);\n        G1[to].push_back(m-1);\n    }\n    void dij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d[i]=INF;\n        d[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G[u].size();i++)\n            {\n                Edge &e=edges[G[u][i]];\n                if(d[e.to]>d[u]+e.cost)\n                {\n                    p[e.to].clear();\n                    p[e.to].push_back(u);\n                    d[e.to]=d[u]+e.cost;\n                    Q.push((HeapNode){d[e.to],e.to});\n                }\n                else if(d[e.to]==d[u]+e.cost)\n                {\n                    p[e.to].push_back(u);\n                }\n            }\n        }\n    }\n\n    void redij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0;i<=n;i++) d1[i]=INF;\n        d1[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode){0,s});\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top(); Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0;i<G1[u].size();i++)\n            {\n                Edge &e=edges1[G1[u][i]];\n                //cout<<e.to<<endl;\n                if(d1[e.to]>d1[u]+e.cost)\n                {\n                    p2[e.to].clear();\n                    p2[e.to].push_back(u);\n                    d1[e.to]=d1[u]+e.cost;\n                    Q.push((HeapNode){d1[e.to],e.to});\n                }\n                else if(d1[e.to]==d1[u]+e.cost)\n                {\n                    p2[e.to].push_back(u);\n                }\n            }\n        }\n    }\n}D;\n\nstruct node\n{\n    int x,y;\n    ll z;\n}s[maxn];\ntypedef pair<int,int>P;\nvector<P>G[maxn];\nint dfs_clock,pre[maxn],low[maxn];\nbool is_bridge[maxn];\nint dfs(int u,int fa)\n{\n    int lowu=pre[u]=++dfs_clock;\n    for(int i=0;i<G[u].size();i++)\n    {\n        int v=G[u][i].first;\n        if(!pre[v])\n        {\n            int lowv=dfs(v,u);\n            lowu=min(lowu,lowv);\n            if(lowv>pre[u])\n            {\n                is_bridge[G[u][i].second]=true;\n            }\n        }\n        else if(pre[v]<pre[u]&&fa!=v)\n            low[u]=min(low[u],pre[v]);\n    }\n    return low[u]=lowu;\n}\n\nint main()\n{\n  //  freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    D.init(n);\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].z);\n        D.addedge(s[i].x,s[i].y,s[i].z);\n    }\n    D.dij(1);\n    D.redij(2);\n    int num=D.p[2].size();\n    for(int i=0;i<m;i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[x]+D.d1[y]+z==D.d[2])\n        {\n            G[x].push_back(make_pair(y,i));\n           // G[y].push_back(make_pair(x,i));\n        }\n    }\n    dfs(1,0);\n    for(int i=0;i<m;i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[y]+D.d1[x]+z<D.d[2])\n        {\n            printf(\"HAPPY\\n\");\n        }\n        else\n        {\n\n            if(D.d[x]+D.d1[y]+z==D.d[2]&&is_bridge[i])\n            {\n                printf(\"SAD\\n\");\n            }\n            else\n            {\n                printf(\"SOSO\\n\");\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mxn = 1e5 + 10;\nconst ll inf = 1e15;\n\nvector< pair< pair< ll , ll> , int > > adj[mxn] , radj[mxn] , dac[mxn] ;\nvector< pair< pair<ll , ll >  , ll > > edge;\nmap< pair< pair< ll , ll > , ll> , int > mp;\nll dis[mxn] , rdis[mxn] , spath[mxn] , rpath[mxn] , low[mxn];\nbool eflag[mxn] , nflag[mxn];\nvoid dks(int src , int des)\n{\n    priority_queue< pair<ll , ll > > PQ;\n\n    dis[src] = 0;\n    PQ.push(make_pair(0 , src));\n    while(!PQ.empty())\n    {\n        pair<ll , ll > p = PQ.top();\n        PQ.pop();\n        for(int i = 0; i < adj[p.second].size(); i++)\n        {\n            pair<ll , ll > q = adj[p.second][i].first;\n            if(dis[q.second] > q.first  + dis[p.second])\n            {\n                dis[q.second] = dis[p.second] + q.first;\n                PQ.push(make_pair((-1)*dis[q.second] , q.second));\n            }\n        }\n    }\n}\n\n\n\nvoid rdks(int src , int des)\n{\n    priority_queue< pair<ll , ll > > PQ;\n    rdis[src] = 0;\n    PQ.push(make_pair(0 , src));\n    while(!PQ.empty())\n    {\n        pair<ll , ll > p = PQ.top();\n        PQ.pop();\n        for(int i = 0; i < radj[p.second].size(); i++)\n        {\n            pair<ll , ll > q = radj[p.second][i].first;\n            if(rdis[q.second] > q.first  + rdis[p.second])\n            {\n                rdis[q.second] = rdis[p.second] + q.first;\n                PQ.push(make_pair((-1)*rdis[q.second] , q.second));\n            }\n        }\n    }\n}\nint cnt = 0;\nll dv[mxn];\nvoid dfs(int u , int par)\n{\n\t//cout<<u<<\" \"<<par<<endl;\n\tdv[u] = low[u] = ++cnt;\n\tnflag[u] = true;\n\tfor(int i = 0; i < dac[u].size(); i++)\n\t{\n\t\tint v  = dac[u][i].first.second;\n\t\tif(!nflag[v])\n\t\t{\n\t\t\tdfs(v , u);\n\t\t\tlow[u] = min(low[u],low[v]);\n\t\t}\n\t\telse if(v!=par)\n\t\t{\n\t\t\tlow[u] = min(low[u],dv[v]);\n\t\t}\n\t}\n}\n\n\nvoid print(int cur , int old)\n{\n\tif(cur < old)\n\t{\n\t\tcout<<\"HAPPY\"<<endl;\n\t}\n\telse if(old < cur)\n\t{\n\t\tcout<<\"SAD\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<\"SOSO\"<<endl;\n\t}\n}\n\nint main()\n{\n    int n, m , u , v;\n    ll w;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++)\n    {\n        cin>>u>>v>>w;\n        adj[u].push_back(make_pair( make_pair(w,v) , i));\n        radj[v].push_back(make_pair(make_pair(w , u) , i));\n        edge.push_back(make_pair(make_pair(u , v) , w));\n       mp[make_pair(make_pair(u , v), w)] ++;\n    }\n\n    for(int i = 0; i < mxn ; i++)\n    {\n        dis[i] = inf;\n        rdis[i] = inf;\n    }\n    dks(1 , 2);\n\trdks(2 , 1);\n\t/*for(int i = 1; i <= n; i++)\n\t{\n\t\tcout<<dis[i]<<\" \";\n\t}\n\tcout<<endl;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcout<<rdis[i]<<\" \";\n\t}\n\tcout<<endl;*/\n    for(int i=1; i<=n; i++)\n    {\n        for(int j=0; j<adj[i].size(); j++)\n        {\n\t\t//\tcout<<(dis[i]+adj[i][j].first.first) <<\" \"<<dis[adj[i][j].first.second]<<\" \"<<rdis[i]<<\" \"<<rdis[adj[i][j].first.second]+adj[i][j].first.first<<endl;\n            if(dis[i]+adj[i][j].first.first==dis[adj[i][j].first.second] && rdis[i]==rdis[adj[i][j].first.second]+adj[i][j].first.first)\n                {\n\t\t\t\t\tdac[i].push_back(adj[i][j]);\n\t\t\t\t\tdac[adj[i][j].first.second].push_back(make_pair(make_pair(adj[i][j].first.first, i) , adj[i][j].second));\n\t\t\t\t\teflag[adj[i][j].second] = true;\n\t\t\t\t}\n        }\n    }\n   \n    memset(nflag , false ,sizeof nflag);\n    /*for(int i = 1; i <= n; i++)\n    {\n\t\tcout<<i<<\":\";\n\t\tfor(int j = 0; j < dac[i].size(); j++)\n\t\t{\n\t\t\tcout<<dac[i][j].first.second<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}*/\n    dfs(1 , 0);\n    /*for(int i = 1; i <= n; i++)\n    {\n\t\tcout<<low[i]<<\" \";\n\t}\n\tcout<<endl; */\n\t\n\tfor(int i = 0; i < edge.size(); i++)\n\t{\n\t\tif(!eflag[i]) continue;\n\t\tint u = edge[i].first.first , v = edge[i].first.second;\n\t\tif(dv[u] >= low[v] ) eflag[i] = 0;\n\t\t\n\t}\n\tfor(int i =0; i < edge.size(); i++)\n\t{\n\t\tint u = edge[i].first.first , v = edge[i].first.second ;\n\t\tll w = edge[i].second;\n\t\tif(eflag[i])\n\t\t{\n\t\t\tll nw = min( inf , dis[v] + w+ rdis[u]);\n\t\t\tprint(nw , dis[2]);  \n\t\t}\n\t\telse\n\t\t{\n\t\t\tll nw = min(dis[2] , dis[v] + w + rdis[u]);\n\t\t\tprint(nw , dis[2]);\n\t\t}\n\t}\n    return 0;\n}\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge{\n\tedge(){}\n\tedge(ll from, ll to, ll cost, ll id) :from(from), to(to), cost(cost), id(id){}\n\tll from, to, cost, id;\n};\n\nedge es[100000];\nusing Graph = vector<vector<edge>>;\n\nint N, M;\n\nconst ll INF = 1LL << 55;\n\nvoid dijkstra(int s, const Graph& g, vector<ll>& dist){\n\tusing P = pair<ll, int>;\n\tdist = vector<ll>(N, INF);\n\tdist[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push({ 0, s });\n\twhile(q.size()){\n\t\tll d = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tfor(auto e : g[v]){\n\t\t\tif(dist[e.to] > d + e.cost){\n\t\t\t\tdist[e.to] = d + e.cost;\n\t\t\t\tq.push({ d + e.cost, e.to });\n\t\t\t}\n\t\t}\n\t}\n}\n\nint use[100000];\nint bri[100000];\n\nusing Pii = pair<int, int>;\n\nstd::pair<std::vector<int>, vector<Pii>> bridge(const Graph& g){\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tstd::vector<int> ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tvector<Pii> brdg;\n\tstd::function<void(int, int)> dfs = [&](int v, int u){\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor(auto& e : g[v]){\n\t\t\tint w = e.to;\n\t\t\tif(ord[w] == -1)\n\t\t\t\tdfs(w, v);\n\t\t\telse if(u != w && onS[w])\n\t\t\t\twhile(ord[roots[t - 1]] > ord[w]) --t;\n\t\t}\n\t\tif(v == roots[t - 1]){\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile(1){\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif(v == w) break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor(int u = 0; u < n; u++){\n\t\tif(ord[u] == -1){\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn std::make_pair(cmp, brdg);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tcin >> N >> M;\n\n\tGraph G(N), Gr(N);\n\tfor(int i = 0; i < M; i++){\n\t\tll u, v, cost;\n\t\tcin >> u >> v >> cost;\n\t\tu--, v--;\n\t\tes[i] = edge(u, v, cost, i);\n\t\tG[u].push_back(edge(u, v, cost, i));\n\t\tGr[v].push_back(edge(v, u, cost, i));\n\t}\n\n\tvector<ll> d(N), dr(N);\n\tdijkstra(0, G, d);\n\tdijkstra(1, Gr, dr);\n\n\tll dist = d[1];\n\tGraph G2(N);\n\tmap<Pii, int> idmap;\n\tfor(int i = 0; i < M; i++){\n\t\tedge e = es[i];\n\t\tll dd = d[e.from] + e.cost + dr[e.to];\n\t\tif(dist == dd){\n\t\t\tuse[i] = 1;\n\t\t\tfor(int loop = 0; loop < 2; loop++){\n\t\t\t\tG2[e.from].push_back(e);\n\t\t\t\tidmap[{e.from, e.to}] = i;\n\t\t\t\tswap(e.from, e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\tauto res = bridge(G2);\n\tfor(auto p : res.second){\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tif(idmap.count(p)){\n\t\t\t\tbri[idmap[p]] = 1;\n\t\t\t}\n\t\t\tswap(p.first, p.second);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(!use[i]){\n\t\t\tedge e = es[i];\n\t\t\tll dd = d[e.to] + e.cost + dr[e.from];\n\t\t\tif(dist > dd){\n\t\t\t\tcout << \"HAPPY\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"SOSO\" << endl;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(bri[i]){\n\t\t\t\tcout << \"SAD\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"SOSO\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Bridges */\n\nint bridges_dfs(int now, int backID, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n  \n  visited[now] = 1;\n  \n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == backID) continue;\n    \n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n  \n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n\nvector<bool> bridges(int n, const vector<pair<int,int> > &path){ //無向辺 & 多重辺考慮\n  vector<vector<pair<int,int> > >  way(n);\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n  \n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n  \n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n  \n  return bridges_flag;\n}\n\n\n\nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE], c[SIZE];\n  vector<int> way[SIZE], rway[SIZE];\n  \n  scanf(\"%d%d\",&n,&m);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n\n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n\n  //Dijkstra\n  priority_queue<pair<ll,int> > pq;\n  bool visited[SIZE] = {}, rvisited[SIZE];\n  ll cost[SIZE], rcost[SIZE];\n  \n  pq.push({0,0});\n\n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n\n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n\n  pq.push({0,1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n\n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n\n  vector<pair<int,int> > Graph;\n  vector<int> pathID;\n  bool visited2[SIZE] = {};\n\n  pq.push({cost[1], 1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    int cur_cost = p.first;\n\n    if(visited2[now]) continue;\n    visited2[now] = true;\n    \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n        debug(id);\n      }\n    }\n  }\n\n  auto res = bridges(n, Graph);\n  bool isBridge[SIZE] = {};\n\n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n\n  debug(cost[1]);\n  \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<ll,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %lld\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tll tmp_code;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_code = edge[i].from*100000+edge[i].to;\n\n\t\t\tauto at = MAP.find(tmp_code);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_code]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_code] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_code = edge[i].from*100000+edge[i].to;\n\n\t\tif(MAP[tmp_code] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int v, w; };\nconst ll INF = LLONG_MAX / 3;\nconst int MOD = 1e9 + 114514;\n\npair<vector<ll>, vector<int>> dijkstra(int N, vector<vector<edge>>& G, int s) {\n\tvector<ll> d(N, INF); d[s] = 0;\n\tvector<int> way(N); way[s] = 1;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i>> pq;\n\tpq.push(ll_i(0, s));\n\twhile (pq.size()) {\n\t\tll_i p = pq.top(); pq.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (edge e: G[u]) {\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tway[e.v] = 0;\n\t\t\t\tpq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t\t\tif (d[e.v] == d[u] + e.w)\n\t\t\t\tway[e.v] = (way[e.v] + way[u]) % MOD;\n\t\t}\n\t}\n\treturn {d, way};\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<int> a(M), b(M), c(M);\n\trep(i, M) scanf(\"%d%d%d\", &a[i], &b[i], &c[i]), a[i]--, b[i]--;\n\tvector<vector<edge>> G(N), _G(N);\n\trep(i, M) G[a[i]].pb({b[i], c[i]}), _G[b[i]].pb({a[i], c[i]});\n\tauto z = dijkstra(N, G, 0), _z = dijkstra(N, _G, 1);\n\tvector<ll> d = z.first, _d = _z.first;\n\tvector<int> way = z.second, _way = _z.second;\n\tll D = d[1]; int WAY = way[1];\n\trep(i, M) {\n\t\tint u = a[i], v = b[i];\n\t\tif (d[u] + c[i] + _d[v] == D && (ll)way[u] * _way[v] % MOD == WAY)\n\t\t\tprintf(\"SAD\\n\");\n\t\telse if (d[v] + c[i] + _d[u] < D)\n\t\t\tprintf(\"HAPPY\\n\");\n\t\telse\n\t\t\tprintf(\"SOSO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mxn = 1e5 + 10;\nconst ll inf = 1e15;\nvector< pair< ll , ll> > adj[mxn] , radj[mxn] , dac[mxn] ;\nvector< pair< pair<ll , ll >  , ll > > edge;\n\nll dis[mxn] , rdis[mxn] , spath[mxn] , rpath[mxn];\n\nvoid dks(int src , int des)\n{\n    priority_queue< pair<ll , ll > > PQ;\n\n    dis[src] = 0;\n    PQ.push(make_pair(0 , src));\n    while(!PQ.empty())\n    {\n        pair<ll , ll > p = PQ.top();\n        PQ.pop();\n        for(int i = 0; i < adj[p.second].size(); i++)\n        {\n            pair<ll , ll > q = adj[p.second][i];\n            if(dis[q.second] > q.first  + dis[p.second])\n            {\n                dis[q.second] = dis[p.second] + q.first;\n                PQ.push(make_pair((-1)*dis[q.second] , q.second));\n            }\n        }\n    }\n}\n\n\n\nvoid rdks(int src , int des)\n{\n    priority_queue< pair<ll , ll > > PQ;\n    rdis[src] = 0;\n    PQ.push(make_pair(0 , src));\n    while(!PQ.empty())\n    {\n        pair<ll , ll > p = PQ.top();\n        PQ.pop();\n        for(int i = 0; i < radj[p.second].size(); i++)\n        {\n            pair<ll , ll > q = radj[p.second][i];\n            if(rdis[q.second] > q.first  + rdis[p.second])\n            {\n                rdis[q.second] = rdis[p.second] + q.first;\n                PQ.push(make_pair((-1)*rdis[q.second] , q.second));\n            }\n        }\n    }\n}\n\n\nll path(int u)\n{\n    if(rpath[u] != -1) return rpath[u];\n    if(u==2)\n    {\n        return rpath[2] = 1;\n    }\n    rpath[u] = 0;\n    for(int i = 0; i < dac[u].size(); i++)\n    {\n        int v = dac[u][i].second;\n        spath[v] +=1;\n        rpath[u] += path(v);\n        //cout<<u<<\" runn \"<<v<<\" \"<<rpath[u]<<\" \"<<rpath[v]<<endl;//\n    }\n    return rpath[u];\n}\n\nint solve(int u , int v , ll w, ll num , ll mn)\n{\n    if(spath[u] < 0 || rpath[u] < 0 || spath[v] < 0 || rpath[v] < 0)\n    {\n    //    cout<<\" from here \"<<endl;\n        if(dis[v] + w + rdis[u] < mn) return -1;\n        else return 0;\n    }\n    else\n    {\n\t\t//cout<<\"cal \"<<dis[u]+w+rdis[v]<<\" \"<<mn<<\" \"<<dis[u]<<\" \"<<rdis[v]<<\" \"<<w<<endl;\n\t\t if(dis[v] + w + rdis[u] < mn) return -1;\n        //cout<<\"else\"<<endl;\n       // cout<<spath[u]<<\" \"<<num<<endl;\n        if(u !=1 && spath[u] < num) return 0;\n       // cout<<\"else 2\"<<endl;\n        if(rpath[u]==1 && rpath[v] == 1 && dis[u] + w + rdis[v] == mn) return 2;\n        else return 0;\n    }\n}\n\nint main()\n{\n    int n, m , u , v;\n    ll w;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++)\n    {\n        cin>>u>>v>>w;\n        adj[u].push_back(make_pair(w,v));\n        radj[v].push_back(make_pair(w , u));\n        edge.push_back(make_pair(make_pair(u , v) , w));\n    }\n\n    for(int i = 0; i < mxn ; i++)\n    {\n        dis[i] = inf;\n    }\n    dks(1 , 2);\n\n    for(int i=1; i<=n; i++)\n    {\n        for(int j=0; j<adj[i].size(); j++)\n        {\n            if(dis[i]+adj[i][j].first==dis[adj[i][j].second])\n                dac[i].push_back(adj[i][j]);\n        }\n    }\n\n    memset(rpath , -1 ,sizeof rpath);\n    ll ret = path(1);\n    for(int i = 0; i < mxn ; i++)\n    {\n        rdis[i] = INT_MAX;\n    }\n    rdks(2 , 1);\n    for(int i = 0; i < edge.size(); i++)\n    {\n        int ret1 = solve(edge[i].first.first , edge[i].first.second , edge[i].second , ret , dis[2] );\n        if(ret1 == 0)\n        {\n            cout<<\"SOSO\"<<endl;\n        }\n        else if(ret1==-1)\n        {\n            cout<<\"HAPPY\"<<endl;\n        }\n        else\n        {\n            cout<<\"SAD\"<<endl;\n        }\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\nconstexpr ll inf = ll(1e18) + 9;\n\nvector<ll> dijkstra(vector<vector<pair<int, ll> > > const & g, int root) {\n    vector<ll> dist(g.size(), inf);\n    priority_queue<pair<ll, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        ll dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; ll cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n\npair<int, vector<int> > decompose_to_two_edge_connected_components(vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> imos(n); { // imos[i] == 0  iff  the edge i -> parent is a bridge\n        vector<char> used(n); // 0: unused ; 1: exists on stack ; 2: removed from stack\n        function<void (int, int)> go = [&](int i, int parent) {\n            used[i] = 1;\n            for (int j : g[i]) if (j != parent) {\n                if (used[j] == 0) {\n                    go(j, i);\n                    imos[i] += imos[j];\n                } else if (used[j] == 1) {\n                    imos[i] += 1;\n                    imos[j] -= 1;\n                }\n            }\n            used[i] = 2;\n        };\n        REP (i, n) if (used[i] == 0) {\n            go(i, -1);\n        }\n    }\n    int size = 0;\n    vector<int> component_of(n, -1); {\n        function<void (int)> go = [&](int i) {\n            for (int j : g[i]) if (component_of[j] == -1) {\n                component_of[j] = imos[j] == 0 ? size ++ : component_of[i];\n                go(j);\n            }\n        };\n        REP (i, n) if (component_of[i] == -1) {\n            component_of[i] = size ++;\n            go(i);\n        }\n    }\n    return { size, move(component_of) };\n}\n\nenum result_t { HAPPY, SOSO, SAD };\nconstexpr int start = 0;\nconstexpr int goal = 1;\nint main() {\n    // input\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<tuple<int, int, int> > edges(m);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        edges[i] = make_tuple(a, b, c);\n    }\n    // solve\n    vector<vector<pair<int, ll >> > g(n);\n    vector<vector<pair<int, ll >> > rev_g(n);\n    map<tuple<int, int, int>, int> count_edges;\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        g[a].emplace_back(b, c);\n        rev_g[b].emplace_back(a, c);\n        count_edges[edge] += 1;\n    }\n    auto dist = dijkstra(g, start);\n    auto rev_dist = dijkstra(rev_g, goal);\n    vector<vector<int> > h(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            if (dist[i] + cost + rev_dist[j] == dist[goal]) {\n                h[i].push_back(j);\n                h[j].push_back(i);\n            }\n        }\n    }\n    auto component_of = decompose_to_two_edge_connected_components(h).second;\n    // output\n    for (auto edge : edges) {\n        int a, b, c; tie(a, b, c) = edge;\n        result_t result =\n            dist[b] + c + rev_dist[a] <  dist[goal] ? HAPPY :\n            // dist[a] == inf or rev_dist[b] == inf ? SOSO :\n            dist[b] + c + rev_dist[a] == dist[goal] ? SOSO :\n            dist[a] + c + rev_dist[b] != dist[goal] ? SOSO :\n            count_edges[edge] >= 2 ? SOSO :\n            component_of[a] != component_of[b] ? SAD :\n            SOSO;\n        printf(\"%s\\n\",\n            result == HAPPY ? \"HAPPY\" :\n            result == SOSO ? \"SOSO\" :\n            result == SAD ? \"SAD\" :\n            \"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\n#define pb push_back\n#define mkp make_pair\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define per(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,a,b) for (int i=(a);i<=(b);i++)\n#define PER(i,a,b) for (int i=(b);i>=(a);i--)\n#define de(x) cout<<\">> \"<<#x<<\" = \"<<x<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, int> P;\nLL powmod(LL a,LL b,LL mod) {LL res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nLL gcd(LL a, LL b) {if (b==0)return a;else return gcd(b,a%b);}\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 1000005; // 1e6;\nint u[MAXN],v[MAXN],c[MAXN];\nint mark[MAXN];\nint bridge[MAXN];\nvector<P> G[MAXN];\nvector<P> RG[MAXN];\nvector<P> NG[MAXN];\nLL d[MAXN],rd[MAXN];\nint ans[MAXN];\nint n,m;\nvoid dij(vector<P> GG[], LL dis[], int s)\n{\n\tdis[s]=0;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(mkp(0, s));\n\twhile(!que.empty()){\n\t\tint x=que.top().se;\n\t\tLL d=que.top().fi;\n\t\tque.pop();\n\t\tif (d>dis[x]) continue;\n\t\trep(i,0,SZ(GG[x]))\n\t\t{\n\t\t\tint v=GG[x][i].fi, e = GG[x][i].se;\n\t\t\tif (dis[v]>dis[x]+e){\n\t\t\t\tdis[v]=dis[x]+e;\n\t\t\t\tque.push(mkp(dis[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\nint dfn[MAXN],low[MAXN],idx;\nvoid Tarjan(int i, int fa)\n{\n        low[i]=dfn[i]=idx++;\n        rep(j,0,NG[i].size())\n        {\n                int v = NG[i][j].fi;\n                if (v==fa) continue;\n                if (!dfn[v])\n                {\n                        Tarjan(v,i);\n                        low[i] = min(low[i],low[v]);\n                        if (low[v] > dfn[i]) bridge[NG[i][j].se]=true;\n                }\n                else if (dfn[v] < dfn[i])\n                {\n                        low[i]=min(low[i],dfn[v]);\n                }\n        }\n}\nint main()\n{\n\t// freopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\t// de(m)\n\trep(i, 1, m+1){\n\t\tscanf(\"%d%d%d\",u+i,v+i,c+i);\n\t\tG[u[i]].pb(mkp(v[i],c[i]));\n\t\tRG[v[i]].pb(mkp(u[i],c[i]));\n\t}\n\t// de(m)\n\tmemset(d,INF,sizeof d);\n\tmemset(rd,INF,sizeof rd);\n\tdij(G,d,1);\n\tdij(RG,rd,2);\n\t// de(m)\n\trep(i, 1, m+1){\n\t\tif (d[u[i]] + rd[v[i]] + c[i] == d[2]) \n\t\t{\n\t\t\tmark[i]=true;\n\t\t\tNG[u[i]].pb(mkp(v[i], i));\n\t\t\tNG[v[i]].pb(mkp(u[i], i));\n\t\t}\n\t}\n\t// de(m)\n\tTarjan(1,-1);\n\t// de(m)\n\trep(i, 1, m+1)\n\t{\n\t\t// de(1)\n\t\tif (mark[i] && bridge[i]) puts(\"SAD\");\n\t\telse if (mark[i] && !bridge[i]) puts(\"SOSO\");\n\t\telse if (!mark[i] && d[v[i]] + rd[u[i]] + c[i] < d[2]) puts(\"HAPPY\");\n\t\telse if (!mark[i] && d[v[i]] + rd[u[i]] + c[i] >= d[2]) puts(\"SOSO\");\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <tuple>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nstruct CostGraph {\n    using T = ll;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge() {}\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        int from;\n        int to;\n        T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\n\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\nvoid ReverseDijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.rev_edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nclass BiconnectedComponent\n{\npublic:\n    BiconnectedComponent(const CostGraph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            bridge_dfs(g_, i);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    CostGraph toTree() const\n    {\n        CostGraph tree(comp_num);\n        for (const auto& e : bridge) {\n            tree.addEdge(comp[e.from], comp[e.to], 1);\n            tree.addEdge(comp[e.to], comp[e.from], 1);\n        }\n        return tree;\n    }\n    const vector<CostGraph::Edge>& getEdge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i];\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\nprivate:\n    void bridge_dfs(const CostGraph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n            }\n            if (isBridge(s, to)) {\n                bridge.push_back(e);\n            }\n        }\n    }\n\n    void comp_dfs(const CostGraph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n    int num;\n    int comp_num;\n    const int size;\n    vector<CostGraph::Edge> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    CostGraph g(n);\n    using pii = pair<int, int>;\n    map<pii, ll> cost;\n    vector<pii> edge(m);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--, b--;\n        g.addEdge(a, b, c);\n        edge[i] = make_pair(a, b);\n        cost[edge[i]] = c;\n    }\n    vector<ll> ds(n, INF<ll>);\n    Dijkstra(g, 0, ds);\n    vector<ll> dt(n, INF<ll>);\n    ReverseDijkstra(g, 1, dt);\n    show(ds);\n    show(dt);\n    const ll D = ds[1];\n    CostGraph undg(n);\n    for (int i = 0; i < m; i++) {\n        const pii e = edge[i];\n        const int u = e.first;\n        const int v = e.second;\n        const ll c = cost[e];\n        if (ds[u] + c == ds[v]) {\n            undg.addEdge(u, v, 1);\n            undg.addEdge(v, u, 1);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (const auto& e : undg.edge[i]) {\n            cerr << e.from << \"->\" << e.to << endl;\n        }\n    }\n\n    BiconnectedComponent bic(undg);\n    for (int i = 0; i < m; i++) {\n        const pii e = edge[i];\n        const int u = e.first;\n        const int v = e.second;\n        const ll c = cost[e];\n        if (ds[v] + c + dt[u] < D) {\n            cout << \"HAPPY\" << endl;\n        } else {\n            if (not bic.isBridge(u, v)) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Bridges */\n\nint bridges_dfs(int now, int backID, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n  \n  visited[now] = 1;\n  \n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == backID) continue;\n    \n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n  \n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n\nvector<bool> bridges(int n, const vector<pair<int,int> > &path){ //無向辺 & 多重辺考慮\n  vector<vector<pair<int,int> > >  way(n, vector<pair<int,int> >());\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n  \n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n  \n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n  \n  return bridges_flag;\n}\n\n\nint n, m;\nint a[SIZE], b[SIZE], c[SIZE];\nvector<int> way[SIZE], rway[SIZE];\n\npriority_queue<pair<ll,int> > pq;\nbool visited[SIZE] = {}, rvisited[SIZE] = {};\nll cost[SIZE], rcost[SIZE];\n\nvector<pair<int,int> > Graph;\nvector<int> pathID;\nbool visited2[SIZE] = {};\n\nbool isBridge[SIZE] = {};\n\nint main(){\n  \n  scanf(\"%d%d\",&n,&m);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n\n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n\n  //Dijkstra\n  \n  pq.push({0,0});\n\n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n\n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n\n  pq.push({0,1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n\n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n\n\n  pq.push({cost[1], 1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    int cur_cost = p.first;\n\n    if(visited2[now]) continue;\n    visited2[now] = true;\n    \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n      }\n    }\n  }\n\n  auto res = bridges(n, Graph);\n  \n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n  \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n\n  debug(\"False\");\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to,cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,int arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,cost,edge_id;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nint min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %d\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(I,A,B) for (int I=(A),_END_=(B);I<=_END_;I++)\n#define FOR(I,A,B) for (int I=(A),_END_=(B);I<_END_;I++)\n#define REPD(I,A,B) for (int I=(A),_END_=(B);I>=_END_;I--)\n\nusing namespace std;\n\nconst int MAXN = 101010;\nconst int MAXM = 102020;\nconst long long inf = 1000000000000000000ll;\n\nint n,m;\nstruct line{\n\tint a,b,c;\n\tint id;\n}L[MAXN];\n\nint good[MAXN];\nint done[MAXN];\n\nstruct dis_graph{\n\tint tot;\n\tint nxt[MAXM];\n\tint to[MAXM];\n\tint hd[MAXN];\n\tint val[MAXM];\n\n\tlong long dis[MAXN];\n\tint vis[MAXN];\n\n\tinline void add(const int &x, const int &y,const int &VL){\n\t\t++tot;\n\t\tto[tot]=y;\n\t\tnxt[tot]=hd[x];\n\t\tval[tot]=VL;\n\t\thd[x]=tot;\n\t}\n\n\tvoid ssap(int ST){\n\t\tqueue<int> Q;\n\t\tmemset(vis, 0 ,sizeof vis);\n\t\tREP(i,1,n) dis[i]=inf;\n\t\tdis[ST]=0;\n\t\tQ.push(ST);\n\t\twhile (!Q.empty()){\n\t\t\tint now = Q.front(); Q.pop();\n\t\t\tvis[now]=0;\n\t\t\tfor (int i=hd[now]; i ; i=nxt[i])\n\t\t\tif ( dis[to[i]] > dis[now] + val[i])\n\t\t\t{\n\t\t\t\tdis[to[i]] = dis[now] + val[i];\n\t\t\t\tif ( !vis[ to[i] ] ) { vis[ to[i] ] = 1; Q.push( to[i] ); }\n\t\t\t}\n\t\t}\n\t}\n\n}F,G;\n\nstruct DAG{\n\tint to[MAXM];\n\tint nxt[MAXM];\n\tint vis[MAXM];\n\n\tint dfn[MAXN];\n\tint low[MAXN];\n\tint hd[MAXN];\n\n\tint comp[MAXN];\n\n\tint df_time;\n\tint tot;\n\tvector<int> S;\n\tint num_cc;\n\n\tvoid add(const int &x,const int &y){\n\t\t++tot;\n\t\tto[tot]=y;\n\t\tnxt[tot]=hd[x];\n\t\thd[x]=tot;\n\t}\n\t\n\tvoid tarjanSCC(int v,int bef=-1){\n\t\tlow[v]=dfn[v] = ++ df_time;\n\t\tvis[v] =1;\n\t\tS.push_back(v);\n\n\t\tfor (int i=hd[v];i;i=nxt[i])\n\t\tif (to[i]!=bef)\n\t\t{\n\t\t\tif (dfn[ to[i] ]== 0) tarjanSCC( to[i], v );\n\t\t\tif (vis[ to[i] ]) low[v] = min ( low[v], low[ to[i] ] );\n\t\t}\n\n\t\tif (low[v]==dfn[v]){\n\t\t\tnum_cc++;\n\t\t\twhile (1){\n\t\t\t\tint u = S.back(); S.pop_back(); vis[u]=0;\n\t\t\t\tcomp[u] = num_cc;\n\t\t\t\tif (u == v)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n}H;\n\nvoid dfs(int now){\n\tif ( done[now] ) return ;\n\tdone[now] = 1;\n\tfor (int i = G.hd[now]; i ; i= G.nxt[i])\n\tif (F.dis[ G.to[i] ] + G. val[i] == F.dis[now])\n\t{\n\t\tgood[i]=1;\n\t\tdfs(G.to[i]);\n\t}\n}\n\nvoid init(){\n\tscanf(\"%d%d\",&n,&m);\n\tint a,b,c;\n\tREP(i,1,m)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tL[i].a=a;\n\t\tL[i].b=b;\n\t\tL[i].c=c;\n\t\tF.add(a,b,c);\n\t\tG.add(b,a,c);\n\t}\n\tF.ssap(1);\n\tG.ssap(2);\n\n\tdfs(2);\n\n\tREP(i,1,m)\n\t\tif (good[i])\n\t\t{\n\t\t\tH.add(L[i].a,L[i].b);\n\t\t\tH.add(L[i].b,L[i].a);\n\t\t}\n}\n\nvoid work(){\n\tint a,b,c;\n\n\tREP(i,1,n)\n\t\tif (H.dfn[i] == 0)\n\t\t\tH.tarjanSCC(i);\n\n\tREP(i,1,m)\n\t{\n\t\ta=L[i].a;\n\t\tb=L[i].b;\n\t\tc=L[i].c;\n\n\t\tif ( F.dis[b] + c + G.dis[a] < F.dis[2] )\n\t\t\tprintf(\"HAPPY\\n\");\n\t\telse\n\t\t{\n\t\t\tif ( good[i] && H.comp[ a ] != H.comp[ b] )\n\t\t\t\tprintf(\"SAD\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    (cnt[v] += (p != -1 ? cnt[p] : 1)) %= MOD;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] > d + c) q.push((state) { d + c, u, v });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* Bridges */\n\nint bridges_dfs(int now, int backID, vector<vector<pair<int,int> > > &way,\n                vector<int> &visited, vector<int> &sum, vector<bool> &bridges_flag){\n  int res_sum = 0;\n  \n  visited[now] = 1;\n  \n  for(int i=0;i<way[now].size();i++){\n    pair<int,int> p = way[now][i];\n    if(p.second == backID) continue;\n    \n    if(visited[p.first] == 1){\n      sum[p.first]--;\n      sum[now]++;\n      bridges_flag[p.second] = false;\n    }else if(visited[p.first] == 0){\n      int res = bridges_dfs(p.first, p.second, way, visited, sum, bridges_flag);\n      res_sum += res;\n      if(res > 0){\n        bridges_flag[p.second] = false;\n      }\n    }\n  }\n  \n  visited[now] = 2;\n  return res_sum + sum[now];\n}\n\nvector<bool> bridges(int n, const vector<pair<int,int> > &path){ //無向辺 & 多重辺考慮\n  vector<vector<pair<int,int> > >  way(n, vector<pair<int,int> >());\n  vector<int> visited(n,0), sum(n,0);\n  vector<bool> bridges_flag(path.size(), true);\n  \n  for(int i=0;i<path.size();i++){\n    way[path[i].first].push_back({path[i].second,i});\n    way[path[i].second].push_back({path[i].first,i});\n  }\n  \n  bridges_dfs(0, -1, way, visited, sum, bridges_flag);\n  \n  return bridges_flag;\n}\n\n\nint n, m;\nint a[SIZE], b[SIZE], c[SIZE];\nvector<int> way[SIZE], rway[SIZE];\n\npriority_queue<pair<ll,int> > pq;\nbool visited[SIZE] = {}, rvisited[SIZE] = {};\nll cost[SIZE], rcost[SIZE];\n\nvector<pair<int,int> > Graph;\nvector<int> pathID;\nbool visited2[SIZE] = {};\n\nbool isBridge[SIZE] = {};\n\nint main(){\n  \n  scanf(\"%d%d\",&n,&m);\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d\",a+i, b+i, c+i);\n    a[i]--; b[i]--;\n\n    way[a[i]].push_back(i);\n    rway[b[i]].push_back(i);\n  }\n\n  //Dijkstra\n  \n  pq.push({0,0});\n\n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(visited[now]) continue;\n    visited[now] = true;\n    cost[now] = -cur_cost;\n\n    for(int i=0;i<way[now].size();i++){\n      int id = way[now][i];\n      pq.push({cur_cost - c[id], b[id]});\n    }\n  }\n\n  pq.push({0,1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    ll cur_cost = p.first;\n\n    if(rvisited[now]) continue;\n    rvisited[now] = true;\n    rcost[now] = -cur_cost;\n\n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      pq.push({cur_cost - c[id], a[id]});\n    }\n  }\n\n\n  pq.push({cost[1], 1});\n  \n  while(pq.size()){\n    auto p = pq.top();\n    pq.pop();\n\n    int now = p.second;\n    int cur_cost = p.first;\n\n    if(visited2[now]) continue;\n    visited2[now] = true;\n    \n    for(int i=0;i<rway[now].size();i++){\n      int id = rway[now][i];\n      if(cur_cost - c[id] == cost[a[id]]){\n        pq.push({cost[a[id]], a[id]});\n        Graph.push_back({a[id], b[id]});\n        pathID.push_back(id);\n      }\n    }\n  }\n\n  auto res = bridges(n, Graph);\n  \n  for(int i=0;i<res.size();i++){\n    int id = pathID[i];\n    isBridge[id] = res[i];\n  }\n  \n  for(int i=0;i<m;i++){\n    if(isBridge[i]){\n      puts(\"SAD\");\n    }else if(visited[b[i]] && rvisited[a[i]] && cost[b[i]] + rcost[a[i]] + c[i] < cost[1]){\n      puts(\"HAPPY\");\n    }else{\n      puts(\"SOSO\");\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll V,E;\nstruct edge{\n\tll to,cost,id;\n};\nconst ll maxn = 100005;\nconst ll INF = 102120027425345LL;\nvector<edge> G[maxn],rG[maxn],sG[maxn];\nll d[maxn], d2[maxn];\nbool isBridge[maxn];\nvoid dijkstra(ll s, vector<edge> G[maxn], ll d[maxn]) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d+V, INF);\n\td[s] = 0;\n\tque.push(P(0,s));\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tll v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (auto e:G[v]){\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n\tmap<P,ll> M;\nll dfs_clock,pre[maxn],low[maxn];\nll dfs(ll u, ll fa) {\n\tll lowu = pre[u] = ++dfs_clock;\n\tfor (auto e: sG[u]) {\n\t\tll v = e.to;\n\t\tif (!pre[v]) {\n\t\t\tll lowv = dfs(v,u);\n\t\t\tlowu = min(lowu, lowv);\n\t\t\tif (lowv > pre[u]){\n\t\t\t\tif (M[P(u,v)]==1) isBridge[e.id] = true;\n\t\t\t}\n\t\t}\n\t\telse if (pre[v] <pre[u]&&fa!=v) lowu = min(lowu, pre[v]);\n\t}\n\treturn low[u] = lowu;\n}\n\nll ans[maxn];\n\n\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\n\tfor (ll i = 0; i < E; i++) {\n\t\tll x,y,cost;\n\t\tscanf(\"%lld%lld%lld\",&x,&y,&cost);\n\t\t--x,--y;\n\t\t\n\t\tG[x].push_back(edge{y,cost,i});\n\t\trG[y].push_back(edge{x,cost,i});\t\n\t}\n\tdijkstra(0,G,d);\n\tdijkstra(1,rG,d2);\n\tfor(ll i = 0; i < V; i++)\n\tfor (auto e:G[i]) {\n\t\t//cerr << i << \" \"  <<e.to <<\" \" << d[i] << \" \" << e.cost << \" \" << d[e.to] << endl;\n\t\tif (d[i] + e.cost == d[e.to]&&d[e.to]+d2[e.to]==d[1]) \n\t\t{\n\t\t\tsG[i].push_back(e),sG[e.to].push_back(edge{i,e.cost,e.id});//cerr << i << \" \"  <<e.to<<endl; \n\t\t\tM[P(i,e.to)]++;\n\t\t}\n\t}\n\t//cerr << \"------\" << endl;\n\tdfs(0,-1);\n\t//for (ll i = 0; i < E; i++) cerr<< isBridge[i] << \" \" ;\n\t//cerr<<endl;\n\tfor(ll i = 0; i < V; i++)\n\tfor (auto e:G[i]) {\n\t\tif (isBridge[e.id]) ans[e.id] = -1;\n\t\telse {\n\t\t\tif (d[e.to] + e.cost + d2[i] < d[1]) ans[e.id] = 1;\n\t\t\telse ans[e.id] = 0;\n\t\t}\n\t}\n\tfor (ll i = 0; i < E; i++) {\n\t\tif (ans[i] == -1) puts(\"SAD\");\n\t\telse if (ans[i] == 0) puts(\"SOSO\");\n\t\telse puts(\"HAPPY\");\n\t}\n\t\n\t\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n//#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define BIG_NUM 999999999999\n#define NUM 100000\n\n\nstruct Edge{\n\tint from,to;\n\tll cost;\n};\n\nstruct Data{\n\tData(int arg_node_id,ll arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id;\n\tll sum_cost;\n};\n\nstruct Info{\n\tInfo(int arg_to,ll arg_cost,int arg_edge_id){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tedge_id = arg_edge_id;\n\t}\n\tint to,edge_id;\n\tll cost;\n};\n\nmap<string,int> MAP;\n\nint V,E,number;\nint order[NUM],lowlink[NUM];\nll min_cost[NUM],rev_min_cost[NUM];\nbool visited[NUM],in_MIN_PATH[NUM];\nEdge edge[NUM];\nvector<Info> G[NUM],rev_G[NUM],MIN_G[NUM];\n\nvoid recursive(int node_id){\n\n\torder[node_id] = number++;\n\tlowlink[node_id] = order[node_id];\n\n\tint next_node;\n\n\tfor(int i = 0; i < MIN_G[node_id].size(); i++){\n\n\t\tnext_node = MIN_G[node_id][i].to;\n\n\t\tif(order[next_node] == -1){\n\n\t\t\tvisited[MIN_G[node_id][i].edge_id] = true;\n\t\t\trecursive(next_node);\n\t\t\tlowlink[node_id] = min(lowlink[node_id],lowlink[next_node]);\n\n\t\t}else if(visited[MIN_G[node_id][i].edge_id] == false){\n\n\t\t\tlowlink[node_id] = min(lowlink[node_id],order[next_node]);\n\t\t}\n\t}\n}\n\nvoid dijkstra_NORMAL(){\n\tint start = 0,goal = 1;\n\n\tfor(int i = 0; i < V; i++)min_cost[i] = BIG_NUM;\n\tmin_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\n\t\t\t\t//過去最小コストで遷移する場合\n\t\t\t\tif(min_cost[next_node] > Q.top().sum_cost+G[Q.top().node_id][i].cost){\n\n\t\t\t\t\tmin_cost[next_node] = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nvoid dijkstra_REVERSE(){\n\tint start = 1,goal = 0;\n\n\tfor(int i = 0; i < V; i++)rev_min_cost[i] = BIG_NUM;\n\trev_min_cost[start] = 0;\n\n\tpriority_queue<Data> Q;\n\n\tQ.push(Data(start,0));\n\n\tint next_node;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().node_id == goal){\n\t\t\tQ.pop();\n\t\t}else if(Q.top().sum_cost > rev_min_cost[Q.top().node_id]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\n\t\t\t\tif(rev_min_cost[next_node] > Q.top().sum_cost+rev_G[Q.top().node_id][i].cost){\n\n\t\t\t\t\trev_min_cost[next_node] = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\t\t\t\t\tQ.push(Data(next_node,rev_min_cost[next_node]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&V,&E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tscanf(\"%d %d %lld\",&edge[i].from,&edge[i].to,&edge[i].cost);\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\t\tG[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\trev_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\t}\n\n\t//まずは\n\tdijkstra_NORMAL();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"min_cost[%d]:%d\\n\",i,min_cost[i]);\n\t}*/\n\tdijkstra_REVERSE();\n\t/*for(int i = 0; i < V; i++){\n\t\tprintf(\"rev_min_cost[%d]:%d\\n\",i,rev_min_cost[i]);\n\t}*/\n\n\tint goal = 1;\n\n\tfor(int i = 0; i < E; i++)in_MIN_PATH[i] = false;\n\n\n\tstring tmp_str;\n\n\t//★★最小パス経路の求め方★★\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(min_cost[edge[i].from]+edge[i].cost+rev_min_cost[edge[i].to] == min_cost[goal]){\n\t\t\tin_MIN_PATH[i] = true;\n\t\t\tMIN_G[edge[i].from].push_back(Info(edge[i].to,edge[i].cost,i));\n\t\t\tMIN_G[edge[i].to].push_back(Info(edge[i].from,edge[i].cost,i));\n\n\t\t\ttmp_str.clear();\n\t\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\n\t\t\tauto at = MAP.find(tmp_str);\n\n\t\t\tif(at != MAP.end()){\n\t\t\t\tMAP[tmp_str]++;\n\t\t\t}else{\n\t\t\t\tMAP[tmp_str] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnumber = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\torder[i] = -1;\n\t\tlowlink[i] = -1;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\t\tvisited[i] = false;\n\t}\n\trecursive(0);\n\n\n\n\tint from,to;\n\n\n\tfor(int i = 0; i < E; i++){\n\n\t\t//短くなるか判定\n\t\tif((min_cost[edge[i].to] != BIG_NUM) && (rev_min_cost[edge[i].from] != BIG_NUM)\n\t\t\t\t&& (min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from]) <= min_cost[goal]){\n\n\t\t\tif(min_cost[edge[i].to]+edge[i].cost+rev_min_cost[edge[i].from] < min_cost[goal]){\n\t\t\t\tprintf(\"HAPPY\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"SOSO\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(in_MIN_PATH[i] == false){ //最小経路木に含まれていないならSOSO\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//★最短経路木に多重辺がある可能性あり\n\t\ttmp_str.clear();\n\t\ttmp_str = tmp_str.append(to_string(edge[i].from)).append(to_string('@')).append(to_string(edge[i].to));\n\t\tif(MAP[tmp_str] > 1){\n\t\t\tprintf(\"SOSO\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//長くなるか判定\n\t\tfrom = edge[i].from;\n\t\tto = edge[i].to;\n\t\tif(order[to] < order[from]){\n\t\t\tswap(from,to);\n\t\t}\n\t\tif(order[from] < lowlink[to]){ //最短経路上のブリッジである場合\n\t\t\tprintf(\"SAD\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"SOSO\\n\");\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef ll Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\n \nconst ll INF = 1e15;\n \nbool operator < (const Edge &e, const Edge &f){\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n \ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<vector<int> > &prev){\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  prev.assign(n, vector<int>());\n  priority_queue<Edge> Q;\n  for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n    Edge e = Q.top(); Q.pop();\n    for(auto f=g[e.dst].begin();f!=g[e.dst].end();f++){\n      if(dist[f->dst] > e.weight + f->weight){\n    dist[f->dst] = e.weight + f->weight;\n    Q.push(Edge(f->src, f->dst, e.weight + f->weight));\n    prev[f->dst].clear();\n    prev[f->dst].push_back(f->src);\n      }else if(dist[f->dst] == e.weight + f->weight){\n    prev[f->dst].push_back(f->src);\n      }\n    }\n  }\n}\n \npair<Graph, Graph> buildPath(const vector<vector<int> > &prev, int t){\n  ll n = prev.size();\n  Graph g(n);\n  Graph g2(n);\n  stack<int> st;\n  st.push(t);\n  while(!st.empty()){\n    ll now = st.top();\n    st.pop();\n    for(auto&& p : prev[now]){\n      if(p < 0)\n    continue;\n      g[p].push_back(Edge(p, now, 1));\n      g2[p].push_back(Edge(p, now, 1));\n      g[now].push_back(Edge(now, p, 1));\n      st.push(p);\n    }\n  }\n  return pair<Graph, Graph>(g, g2);\n}\n \nint main(){\n  ll n, m;\n  cin >> n >> m;\n  Graph g(n);\n  Graph ginv(n);\n  Edges es;\n  map<P, P> mp;\n  for(int i=0;i<m;i++){\n    ll s, d, w;\n    cin >> s >> d >> w;\n    s--; d--;\n    g[s].push_back(Edge(s, d, w));\n    ginv[d].push_back(Edge(d, s, w));\n    es.push_back(Edge(s, d, w));\n    if(mp.find(P(s, d)) == mp.end())\n      mp[P(s, d)] = P(w*2, 1);\n    else{\n      P befo = mp[P(s, d)];\n      if(w*2 == befo.first)\n    mp[P(s, d)] = P(w*2-1, befo.second + 1);\n      else\n    mp[P(s, d)] = P(min(w*2, befo.first), befo.second + 1);\n    }\n  }\n  vector<Weight> sdist;\n  vector<Weight> gdist;\n  vector<vector<int> > prev;\n  shortestPath(ginv, 1, gdist, prev);\n  shortestPath(g, 0, sdist, prev);\n  Graph tree, tree2;\n  tie(tree, tree2) = buildPath(prev, 1);\n  /*for(int i=0;i<n;i++){\n    cout << i << \": \" << sdist[i] << endl;\n  }\n  for(int i=0;i<n;i++){\n    cout << i << \": \" << gdist[i] << endl;\n    }*/\n \n  vector<int> order(n), low(n);\n  vector<char> reach(n);\n  int cnt=0;\n  function<int(int, int)> dfs=[&](int v, int pv){\n    if(reach[v]) return order[v];\n    reach[v]=true;\n    order[v]=cnt;\n    int mlow=cnt;\n    cnt++;\n    for(auto&& e:tree[v]){\n      if(e.dst==pv) continue;\n      mlow = min(mlow, dfs(e.dst, v));\n    }\n    return low[v] = mlow;\n  };\n  dfs(0, -1);\n \n  /*for(int i=0;i<n;i++)\n    for(int j=0;j<tree[i].size();j++)\n        cout << \"tr: \" << tree[i][j].src << \" \" << tree[i][j].dst << endl;\n  */\n  for(auto &&e : es){\n    ll ans = 0;\n    ll s, d, w;\n    s = e.src; d = e.dst; w = e.weight;\n    ll usedist = sdist[d] + w + gdist[s];\n    //cout << sdist[d] << \" \" << w << \" \" << gdist[s] << endl;\n    //cout << s << \" \" << d << \" \" << w << \" \" << usedist << \" \" << sdist[1] << endl;\n    //for(auto &&e : )\n    if(usedist < sdist[1])\n      ans = max(ans, (ll)2);\n    if(usedist == sdist[1])\n      ans = max(ans, (ll)1);\n     \n    if(mp.find(P(s, d)) != mp.end() && mp[P(s, d)].first < w*2)\n      ans = max(ans, (ll)1);\n    bool ok = false;\n    for(int i=0;i<tree2[s].size();i++){\n      ok |= tree2[s][i].dst == d;\n      //cout << \"tr: \" << tree[s][i].src << \" \" << tree[s][i].dst << endl;\n    }\n    if(!ok)\n      ans = max(ans, (ll)1);\n    if(order[e.src] >= low[e.dst] && order[e.dst] >= low[e.src] && ok)\n      ans = max(ans, (ll)1);\n    if(ans == 2)\n      cout << \"HAPPY\" << endl;\n    else if(ans == 1)\n      cout << \"SOSO\" << endl;\n    else\n      cout << \"SAD\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\nconst ll INF=1e18;\nstruct HeapNode\n{\n    ll d;\n    int u;\n    bool operator<(const HeapNode &rhs)const\n    {\n        return d>rhs.d;\n    }\n};\nstruct Edge\n{\n    int from,to;\n    ll cost;\n};\nstruct Dij\n{\n    int n,m;\n    vector<int>G[maxn];\n    vector<int>G1[maxn];\n    vector<Edge>edges;\n    vector<Edge>edges1;\n    bool done[maxn];\n    ll d[maxn];\n    ll d1[maxn];\n    void init(int n)\n    {\n        this->n=n;\n        for(int i=0; i<=n; i++)\n        {\n            G[i].clear();\n        }\n        edges.clear();\n    }\n    void addedge(int from,int to,int cost)\n    {\n        edges.push_back(Edge{from,to,cost});\n        edges1.push_back((Edge)\n        {\n            to,from,cost\n        });\n        m=edges.size();\n        G[from].push_back(m-1);\n        G1[to].push_back(m-1);\n    }\n    void dij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0; i<=n; i++) d[i]=INF;\n        d[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode)\n        {\n            0,s\n        });\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top();\n            Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0; i<G[u].size(); i++)\n            {\n                Edge &e=edges[G[u][i]];\n                if(d[e.to]>d[u]+e.cost)\n                {\n                    d[e.to]=d[u]+e.cost;\n                    Q.push((HeapNode)\n                    {\n                        d[e.to],e.to\n                    });\n                }\n            }\n        }\n    }\n\n    void redij(int s)\n    {\n        memset(done,0,sizeof(done));\n        for(int i=0; i<=n; i++) d1[i]=INF;\n        d1[s]=0;\n        priority_queue<HeapNode>Q;\n        Q.push((HeapNode)\n        {\n            0,s\n        });\n        while(!Q.empty())\n        {\n            HeapNode now=Q.top();\n            Q.pop();\n            int u=now.u;\n            if(done[u]) continue;\n            done[u]=true;\n            for(int i=0; i<G1[u].size(); i++)\n            {\n                Edge &e=edges1[G1[u][i]];\n                if(d1[e.to]>d1[u]+e.cost)\n                {\n                    d1[e.to]=d1[u]+e.cost;\n                    Q.push((HeapNode)\n                    {\n                        d1[e.to],e.to\n                    });\n                }\n            }\n        }\n    }\n} D;\n\nstruct node\n{\n    int x,y;\n    ll z;\n} s[maxn];\ntypedef pair<int,int>P;\nvector<P>G[maxn];\nint dfs_clock,pre[maxn],low[maxn];\nbool is_bridge[maxn];\nint dfs(int u,int fa)\n{\n    int lowu=pre[u]=++dfs_clock;\n    for(int i=0; i<G[u].size(); i++)\n    {\n        int v=G[u][i].first;\n        if(!pre[v])\n        {\n            int lowv=dfs(v,u);\n            lowu=min(lowu,lowv);\n            if(lowv>pre[u])\n            {\n                is_bridge[G[u][i].second]=true;\n            }\n        }\n        else if(pre[v]<pre[u]&&fa!=v)\n            low[u]=min(low[u],pre[v]);\n    }\n    return low[u]=lowu;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    D.init(n);\n    for(int i=0; i<m; i++)\n    {\n        scanf(\"%d%d%lld\",&s[i].x,&s[i].y,&s[i].z);\n        D.addedge(s[i].x,s[i].y,s[i].z);\n    }\n    D.dij(1);\n    D.redij(2);\n    for(int i=0; i<m; i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(D.d[x]+D.d1[y]+z==D.d[2])\n        {\n            G[x].push_back(make_pair(y,i));\n        }\n    }\n    dfs(1,0);\n    for(int i=0; i<m; i++)\n    {\n        int x=s[i].x,y=s[i].y;\n        ll z=s[i].z;\n        if(is_bridge[i])\n        {\n            printf(\"SAD\\n\");\n        }\n        else if(D.d[y]+D.d1[x]+z<D.d[2])\n        {\n            printf(\"HAPPY\\n\");\n        }\n        else\n        {\n            printf(\"SOSO\\n\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int v, w; };\nconst ll INF = LLONG_MAX / 3;\nconst int MOD = 1e9 + 7;\n \npair<vector<ll>, vector<int>> dijkstra(int N, vector<vector<edge>>& G, int s) {\n    vector<ll> d(N, INF); d[s] = 0;\n    vector<int> way(N); way[s] = 1;\n    priority_queue<ll_i, vector<ll_i>, greater<ll_i>> pq;\n    pq.push(ll_i(0, s));\n    while (pq.size()) {\n        ll_i p = pq.top(); pq.pop();\n        int u = p.second;\n        if (p.first > d[u]) continue;\n        for (edge e: G[u]) {\n            if (d[e.v] > d[u] + e.w) {\n                d[e.v] = d[u] + e.w;\n                way[e.v] = 0;\n                pq.push(ll_i(d[e.v], e.v));\n            }\n            if (d[e.v] == d[u] + e.w)\n                way[e.v] = (way[e.v] + way[u]) % MOD;\n        }\n    }\n    return {d, way};\n}\n \nint main() {\n    int N, M; cin >> N >> M;\n    vector<int> a(M), b(M), c(M);\n    rep(i, M) scanf(\"%d%d%d\", &a[i], &b[i], &c[i]), a[i]--, b[i]--;\n    vector<vector<edge>> G(N), _G(N);\n    rep(i, M) G[a[i]].pb({b[i], c[i]}), _G[b[i]].pb({a[i], c[i]});\n    auto z = dijkstra(N, G, 0), _z = dijkstra(N, _G, 1);\n    vector<ll> d = z.first, _d = _z.first;\n    vector<int> way = z.second, _way = _z.second;\n    ll D = d[1]; int WAY = way[1];\n    rep(i, M) {\n        int u = a[i], v = b[i];\n        if (d[u] + c[i] + _d[v] == D && (ll)way[u] * _way[v] % MOD == WAY)\n            printf(\"SAD\\n\");\n        else if (d[v] + c[i] + _d[u] < D)\n            printf(\"HAPPY\\n\");\n        else\n            printf(\"SOSO\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<pa,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint gcd(int a1,int a2){\n\tif(a1<a2) return gcd(a2,a1);\n\tif(a2==1) return 1;\n\tif(a1%a2==0) return a2;\n\treturn gcd(a2,a1%a2);\n}\n\n\nint rui2(int e,int r){\n\tif(r==0) return 1;\n\tif(r==1) return e%inf;\n\tif(r%2==1) return (e*rui2(e,r-1))%inf;\n\tint w=rui2(e,r/2)%inf;\n\treturn (w*w)%inf;\n}\n\nint inf2=1000000000ll*100000ll;\nint n,m;\nvector<pa>G[100030],G2[100030];\nvector<int> dag[100030],dag2[100030];\nint s1[100030],s2[100030],a[100030],b[100030],c[100030];\nint ans[100030]={0};\nbool sumi[100030]={0};\npriority_queue<pa,vector<pa>,greater<pa>> pq;\nint nyu[100030]={0},shu[100030]={0};\nint ok[100030]={0};\n\n\nvector<int> topo;\nint jisuu[100030]={0};\n\nint hashi[100030]={0};\nint dagk1[100030]={0},dagk2[100030]={0};\n\nvoid dagkosuu(int u){\n\tif(dagk1[u])return;\n\tint ans=0;\n\tfor(auto v:dag2[u])ans+=dagk1[v],ans%=inf;\n\tdagk1[u]=ans%inf;\n}\n\nvoid dagkosuu2(int u){\n\tif(dagk2[u])return;\n\tint ans=0;\n\tfor(auto v:dag[u])ans+=dagk2[v],ans%=inf;\n\tdagk2[u]=ans%inf;\n}\n\n\nvoid toporoji(){\n\t\n\tqueue<int> qu;\n\tqu.push(1);\n\t\n\tfor(int i=1;i<=n;i++)for(auto v:dag[i])jisuu[v]++;\n\t\n\twhile(qu.size()>0){\n\t\tint r=qu.front();\n\t\tqu.pop();\n\t\ttopo.pb(r);\n\t\t\n\t\tfor(auto v:dag[r]){\n\t\t\tjisuu[v]--;\n\t\t\tif(jisuu[v]==0) qu.push(v);\n\t\t}\n\t}\n \t\n}\n\nbool  check(int i){\n\treturn (dagk1[a[i]]*dagk2[b[i]])%inf==dagk1[2]%inf;\n\t\n}\n \n \nint dfsb( vector<pa>& res, int v, int& count, int from, VI& low, VI& pre) {\n  pre[v] = count++;\n  low[v] = pre[v];\n  for (auto it = dag[v].begin(); it != dag[v].end(); it++) {\n    int to = *it;\n  //\tbool b=false;\n    if (pre[to] == -1) {\n      // destination has not been visited\n      // visit destination and update low[v]\n      low[v] = min(low[v], dfsb( res, to, count, v, low, pre));\n      if (low[to] == pre[to]) {\n        // edge is not contained in a closed path -> bridge\n        res.pb(mp(v, to));\n      }\n    } else {\n      if (from == to ) {\n      \n        // ignore a path to parent\n        continue;\n      }\n      low[v] = min(low[v], low[to]);\n    }\n  }\n  return low[v];\n}\n\n\nvector<pa> bridges(int V) {\n  vector<pa> res;\n  if (V > 0) {\n    // assume at least the first vertex exists\n    vector<int> low(V+1, -1);  // lowest reacheable index\n    vector<int> pre(V+1, -1);  // pre-order index\n    int count = 0;  // pre-order index counter\n    dfsb(res, 1, count, -1, low, pre);  // start dfs from vertex 0\n  }\n  return res;\n}\nset<pa> se;\n \n            signed main(){\n   cin>>n>>m;\n            \tfor(int i=0;i<m;i++){\n            \tint y,yy,yyy;\n            \t\tcin>>y>>yy>>yyy;\n            \t\tG[y].pb(mp(yy,yyy));\n            \t\tG2[yy].pb(mp(y,yyy));\n            \t\ta[i]=y;\n            \t\tb[i]=yy;\n            \t\tc[i]=yyy;\n            \t\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s1[i]=inf2;\n            \tpq.push(mp(0,1));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts1[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \tfor(int i=0;i<n+10;i++)sumi[i]=0,s2[i]=inf2;\n            \tpq.push(mp(0,2));\n            \twhile(pq.size()){\n            \t\tpa z=pq.top();\n            \t\tpq.pop();\n            \t\tif(sumi[z.second])continue;\n            \t\ts2[z.second]=z.first;\n            \t\tsumi[z.second]=1;\n            \t\tfor(auto v:G2[z.second])pq.push(mp(z.first+v.second,v.first));\n            \t}\n            \t\n            \tint len=s1[2];\n            \t\n            \tfor(int i=0;i<m;i++){\n            \t\tif(s1[a[i]]+s2[b[i]]+c[i]==len){\n            \t\t\tdag[a[i]].pb(b[i]);\n            \t\t\tdag[b[i]].pb(a[i]);\n            \t\t\t\n            \t//\t\tcout<<\"dag \"<<a[i]<<\" \"<<b[i]<<endl;\n            \t\t\n            \t\t}\n            \t\telse{\n            \t\t\tif(s1[b[i]]+s2[a[i]]+c[i]<len)ans[i]=1;\n            \t\t\telse ans[i]=3;\n            \t\t\t\n            \t\t\t\n            \t\t}\n            \t\t\n            \t}\n            //\tsaiki(1);\n            \tvector<pa> w=bridges(n);\n            \tfor(auto v:w){\n            \t//\tcout<<v.first<<\" \"<<v.second<<endl;\n            \t\tse.insert(v);\n            \t\tswap(v.first,v.second);\n            \t\tse.insert(v);\n            \t}\n            \tfor(int i=0;i<m;i++){\n            \t\tif(ans[i])continue;\n           // \t\tcout<<a[i]<<\" \"<<b[i]<<endl;\n            \t\tif(se.find(mp(a[i],b[i]))!=se.end()) ans[i]=2;\n            \t\telse ans[i]=3;\n            \t\t\n            \t}\n            \t\n            \tfor(int i=0;i<m;i++){\n                    if(ans[i]==1)cout<<\"HAPPY\"<<endl;\n                    if(ans[i]==2)cout<<\"SAD\"<<endl;\n                    if(ans[i]==3)cout<<\"SOSO\"<<endl;\n                }\n            }\n             "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, -1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    (cnt[v] += (p != -1 ? cnt[p] : 1)) %= MOD;\n\n    if(dist[v] <= d) continue;\n\n    dist[v] = d;\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] > d + c) q.push((state) { d + c, u, v });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define SZ 131072\n#define pli pair<long long,int>\nusing namespace std;\nint n, m, Route[101000], PP[101000], ord[101000];\nvector<int>E[101000], L[101000], Num[101000], T[101000];\npriority_queue<pli>PQ;\nstruct Edge {\n\tint a, b, c;\n}Ed[101000];\nint Path[101000], chk[101000];\nlong long D[101000], D2[101000];\nvoid Ins(int a, long long d, int pp) {\n\tif (D[a] <= d)return;\n\tD[a] = d;\n\tPath[a] = pp;\n\tPQ.push(pli{ -d,a });\n}\nvoid Dijk(int st) {\n\tint i, a;\n\tfor (i = 1; i <= n; i++)D[i] = 1e18, Path[i] = -1;\n\tIns(st, 0, 0);\n\twhile (!PQ.empty()) {\n\t\tpli tp = PQ.top();\n\t\tPQ.pop();\n\t\tif (D[tp.second] != -tp.first)continue;\n\t\ta = tp.second;\n\t\tfor (i = 0; i < E[a].size(); i++) {\n\t\t\tIns(E[a][i], D[a] + L[a][i], Num[a][i]);\n\t\t}\n\t}\n}\nvoid DFS(int a, int pp) {\n\tint i;\n\tif (Route[a])pp = a;\n\tPP[a] = pp;\n\tfor (i = 0; i < T[a].size(); i++) {\n\t\tDFS(T[a][i], pp);\n\t}\n}\nint cnt;\nlong long IT[SZ + SZ];\nvoid Put(int b, int e, long long x) {\n\tb += SZ, e += SZ;\n\twhile (b <= e) {\n\t\tIT[b] = min(IT[b], x);\n\t\tIT[e] = min(IT[e], x);\n\t\tb = (b + 1) >> 1, e = (e - 1) >> 1;\n\t}\n}\nvoid Add(int a, int b, int c) {\n\tif (D[a] > 5e17 || D2[b] > 5e17)return;\n\tif (Route[a] > Route[b])Put(Route[b], Route[a] - 1, D[a] + D2[b] + c);\n}\nint main() {\n\tint i, a, b, c;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i < SZ + SZ; i++)IT[i] = 1e18;\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tE[b].push_back(a);\n\t\tL[b].push_back(c);\n\t\tNum[b].push_back(i);\n\t\tEd[i] = { a,b,c };\n\t}\n\tDijk(2);\n\tfor (i = 1; i <= n; i++)D2[i] = D[i], E[i].clear(),L[i].clear(), Num[i].clear();\n\tfor (i = 0; i < m; i++) {\n\t\ta = Ed[i].a, b = Ed[i].b, c = Ed[i].c;\n\t\tE[a].push_back(b);\n\t\tL[a].push_back(c);\n\t\tNum[a].push_back(i);\n\t}\n\tDijk(1);\n\ta = 2;\n\twhile (a != 1) {\n\t\tRoute[a] = ++cnt;\n\t\tchk[Path[a]] = 1;\n\t\tT[Ed[Path[a]].a].push_back(a);\n\t\ta = Ed[Path[a]].a;\n\t}\n\tRoute[a] = ++cnt;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (Path[i] != -1)T[Ed[Path[i]].a].push_back(i);\n\t}\n\tDFS(1, 1);\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i])continue;\n\t\tAdd(Ed[i].a, Ed[i].b, Ed[i].c);\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tif (chk[i]) {\n\t\t\tint t = SZ + min(Route[Ed[i].a], Route[Ed[i].b]);\n\t\t\tlong long rr = 1e18;\n\t\t\twhile (t) {\n\t\t\t\trr = min(rr, IT[t]);\n\t\t\t\tt >>= 1;\n\t\t\t}\n\t\t\tif (rr == D[2])printf(\"SOSO\\n\");\n\t\t\telse printf(\"SAD\\n\");\n\t\t}\n\t\telse {\n\t\t\tif (D[Ed[i].b] + D2[Ed[i].a] + Ed[i].c < D[2])printf(\"HAPPY\\n\");\n\t\t\telse printf(\"SOSO\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\n#define LIM 100005\n#define ll long long int\n#define pii pair<int,int>\n#define ff first\n#define ss second\n\nusing namespace std;\n\nstruct info {\n    int x;\n    ll y;\n    info() {}\n    info(int xx, ll yy) {\n        x = xx; y = yy;\n    }\n    bool operator < (const info &b) const {\n        return y > b.y;\n    }\n};\n\nint n,m, uu[LIM], vv[LIM], ww[LIM];\nvi g[LIM], r[LIM], c[LIM], d[LIM];\nll keys1[LIM], keys2[LIM], par1[LIM], par2[LIM];\nmap<pii,bool>path1,path2;\n\nvoid dij1() {\n    priority_queue<info>pq;\n    for(int i=1; i<=n; i++) keys1[i] = 10000000000LL;\n//    memset(keys1, 127, sizeof keys1);\n    keys1[1] = 0;\n    pq.push(info(1,0));\n\n    while(!pq.empty()) {\n        info U = pq.top(); pq.pop();\n        int u = U.x; ll k = U.y;\n\n//        cout << u << ' ' << k << endl;\n\n        if(k > keys1[u]) continue;\n\n        for(int i=0; i<g[u].size(); i++) {\n            int v = g[u][i], w = c[u][i];\n            if(k+w < keys1[v]) {\n                keys1[v] = k+w;\n//                par1[v] = u;\n                pq.push(info(v, keys1[v]));\n            }\n        }\n    }\n}\n\nvoid dij2() {\n    priority_queue<info>pq;\n    for(int i=1; i<=n; i++) keys2[i] = 10000000000LL;\n//    memset(keys2, 127, sizeof keys2);\n    keys2[2] = 0;\n    pq.push(info(2,0));\n\n    while(!pq.empty()) {\n        info U = pq.top(); pq.pop();\n        int u = U.x; ll k = U.y;\n\n        if(k > keys2[u]) continue;\n\n        for(int i=0; i<r[u].size(); i++) {\n            int v = r[u][i], w = d[u][i];\n            if(k+w < keys2[v]) {\n                keys2[v] = k+w;\n                pq.push(info(v, keys2[v]));\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n,&m);\n    for(int i=0; i<m; i++) {\n        int u,v, w;\n        scanf(\"%d %d %d\", &u,&v, &w);\n        g[u].pb(v); r[v].pb(u);\n        c[u].pb(w); d[v].pb(w);\n        uu[i] = u; vv[i] = v; ww[i] = w;\n    }\n\n    dij1(); //cout << \"BUG\" << endl;\n    dij2();\n\n//    for(int i=1; i<=n; i++) cout << keys1[i] << ' '; cout << endl;\n//    for(int i=1; i<=n; i++) cout << keys2[i] << ' '; cout << endl;\n\n    for(int i=0; i<m; i++) {\n        int u = uu[i], v = vv[i];\n        ll w = ww[i];\n\n        if(keys1[u]+keys2[v]+w > keys1[2]) {\n             if(keys1[v]+keys2[u]+w < keys1[2]) cout << \"HAPPY\" << endl;\n             else cout << \"SOSO\" << endl;\n        }\n        else if(keys1[v]+keys2[u]+w < keys1[2]) cout << \"HAPPY\" << endl;\n        else if(keys1[v]+keys2[u]+w == keys1[2]) cout << \"SOSO\" << endl;\n        else cout << \"SAD\" << endl;\n\n//        if(keys2[u]) {\n//            if(keys1[u]+keys2[v]+w == keys1[2]) {\n//                cout << \"SOSO\" << endl;\n//            }\n//            else if(keys1[u]+keys2[v]+w < keys1[2]) {\n//                cout << \"HAPPY\" << endl;\n//            }\n//            else cout << \"SAD\" << endl;\n//        }\n//        else {\n//            if()\n//        }\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst int maxn=1e5+7;\nconst int mod=1e9+7;\nconst LL INF=1LL<<60;\nint n,m;\nstruct Node{\n    int pos;\n\tLL dis;\n};\nbool operator<(const Node &a, const Node &b){\n    return a.dis > b.dis;\n}\nstruct Edge{\n    int to,val;\n};\nstruct edg{\n    int a,b,c;\n}e[maxn];\n\npriority_queue<Node> q[5];\nLL dis[5][maxn];\nvector<Edge> E[5][maxn];\n    //int fst[maxn],to[maxn],val[maxn],nxt[maxn];\nint cnt[5]={0};\nint fas[5][maxn];\nbool vis[5][maxn];\nint dfs(int x,int p){\n\t\tif(vis[p][x]) return fas[p][x];\n\t\tvis[p][x]=1;\n        int len=E[p][x].size();\n        for(int i=0;i<len;i++){\n            int v=E[p][x][i].to;\n            fas[p][x]=(fas[p][x]+dfs(v,p))%mod;\n           // dfs(E[p][x][i].to,p);\n        }\n        return fas[p][x];\n }\n    void addE(int u,int v,int c,int p){\n        E[p][u].push_back((Edge){v,c});\n    }\n void dijkstra(int s,int p){\n        for(int i=1;i<=n;i++) dis[p][i]=INF;\n        dis[p][s]=0;\n        q[p].push((Node){s,0});\n        while(q[p].size()){\n            Node now=q[p].top();\n            q[p].pop();\n            int len=E[p][now.pos].size();\n            for(int i=0;i<len;i++){\n                int v=E[p][now.pos][i].to;\n                //cout<<v<<\" \"<<E[p][now.pos][i].val<<\" \"<<dis[p][v]<<endl;\n                int u=now.pos;\n                if(dis[p][v]>dis[p][u]+E[p][now.pos][i].val){\n                    dis[p][v]=dis[p][u]+E[p][now.pos][i].val;\n                    q[p].push((Node){v,dis[p][v]});\n                }\n            }\n        }\n }\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++){\n        int a,b,c;\n        scanf(\"%d%d%d\",&e[i].a,&e[i].b,&e[i].c);\n        addE(e[i].a,e[i].b,e[i].c,1);\n        addE(e[i].b,e[i].a,e[i].c,2);\n    }\n    dijkstra(1,1);\n    dijkstra(2,2);\n    LL minn=dis[1][2];\n    for(int i=1;i<=m;i++){\n        int u=e[i].a,v=e[i].b;\n        if(dis[1][u]+dis[2][v]+e[i].c==minn){\n\t\t\t//cout<<\"--\"<<u<<\" \"<<v<<endl;\n            addE(u,v,e[i].c,3);\n            addE(v,u,e[i].c,4);\n        }\n    }\n    memset(vis,0,sizeof(vis));\n    memset(fas,0,sizeof(fas));\n    fas[3][2]=1;vis[3][2]=1;\n    fas[4][1]=1;vis[4][1]=1;\n    for(int i=1;i<=n;i++) dfs(i,3);\n    for(int i=1;i<=n;i++) dfs(i,4);\n    //cout<<fas[4][2]<<endl;\n    for(int i=1;i<=m;i++){\n        int u=e[i].a;\n        int v=e[i].b;\n        //cout<<(1LL*fas[3][u]*fas[4][v])<<endl;\n        if(dis[1][u]+dis[2][v]+e[i].c==minn){\n            if((1LL*fas[4][u]*fas[3][v])%mod==fas[4][2]) puts(\"SAD\");\n            else puts(\"SOSO\");\n        }\n        else{\n            if(dis[1][v]+dis[2][u]+e[i].c<minn) puts(\"HAPPY\");\n            else puts(\"SOSO\");\n        }\n    }\n return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <limits.h>\n#include <string.h>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <map>\n#include <bitset>\n#include <queue>\n#define pb push_back\n#define ll long long\n#define X first\n#define Y second\n#define pi acos(-1.0) \n#define maxn 100005\n#define mod 999999937\n#define inf 9999999999999999\nusing namespace std;\n\ntypedef pair<ll,int> P;\n\nstruct Edge{\n    int from,to;\n    ll cost;\n};\n\nint n,m;\nvector<Edge> edges;\nvector<int> v[maxn],rv[maxn];\nll d1[maxn],d2[maxn];\nbool used[maxn];\n\nvoid addedge(int from,int to,ll cost){\n    edges.push_back(Edge{from,to,cost});\n    edges.push_back(Edge{to,from,cost});\n    v[from].push_back(edges.size()-2);\n    rv[to].push_back(edges.size()-1);\n}\n\nvoid dijs1(int s,ll *dist){\n    fill(dist+1,dist+n+1,inf);\n    memset(used,0,sizeof(used));\n    dist[s]=0;\n    priority_queue<P,vector<P>,greater<P> > pq;\n    pq.push(P(0,s));\n    while(!pq.empty()){\n        int now=pq.top().second; pq.pop();\n        if(used[now]) continue;\n        used[now]=1;\n        for(int i=0;i<v[now].size();i++){\n            Edge e=edges[v[now][i]];\n            if(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n                dist[e.to]=dist[now]+e.cost;\n                pq.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n}\n\nvoid dijs2(int s,ll *dist){\n    fill(dist+1,dist+n+1,inf);\n    memset(used,0,sizeof(used));\n    dist[s]=0;\n    priority_queue<P,vector<P>,greater<P> > pq;\n    pq.push(P(0,s));\n    while(!pq.empty()){\n        int now=pq.top().second; pq.pop();\n        if(used[now]) continue;\n        used[now]=1;\n        for(int i=0;i<rv[now].size();i++){\n            Edge e=edges[rv[now][i]];\n            if(!used[e.to]&&dist[e.to]>dist[now]+e.cost){\n                dist[e.to]=dist[now]+e.cost;\n                pq.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n}\n\nll length;\nvector<int> G[maxn];\n\n//bcc模板 (橋雙連通分量)\nint dfs_clock;\nmap<int,bool> bridge[maxn];//用bridge[i][j]紀錄v[i][j]這條邊是不是橋 //常數有點大，如果需要加快再改 \nint pre[maxn];\n\nint dfs_bcc(int u,int fa){ \n    int lowu=pre[u]=++dfs_clock;\n    for(int i=0;i<G[u].size();i++){\n        int x=G[u][i];\n        if(!pre[x]){\n            int lowx=dfs_bcc(x,u);\n            lowu=min(lowu,lowx);\n            if(lowx>pre[u]) {\n                bridge[u][x]=1;\n            }\n        }\n        else if(pre[x]<pre[u]&&x!=fa) lowu=min(lowu,pre[x]);\n    }\n    return lowu;\n}\n\nvoid find_bcc(int nn){\n    memset(pre,0,sizeof(pre));\n    dfs_clock=0;\n    for(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n        bridge[i].clear();\n    }\n    for(int i=1;i<=nn;i++){ //注意可能要改節點範圍 \n        if(!pre[i]) dfs_bcc(i,-1);\n    }\n}\n//bcc模板結束 \n\n\nint main(){\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        int x,y;\n        ll c;\n        scanf(\"%d%d%lld\",&x,&y,&c);\n        addedge(x,y,c);\n    }\n    dijs1(1,d1);\n    dijs2(2,d2);\n    \n    //for(int i=1;i<=n;i++) printf(\"%d %d %d\\n\",i,d1[i],d2[i]);\n    \n    length=d1[2];\n    \n    for(int i=0;i<edges.size();i+=2){\n        Edge e=edges[i];\n        if(d1[e.from]+d2[e.to]+e.cost==length) G[e.from].push_back(e.to);\n    }\n    \n    find_bcc(n);\n    \n    //for(int i=1;i<=n;i++) for(map<int,bool>::iterator iter=bridge[i].begin();iter!=bridge[i].end();iter++){\n    //      if(iter->second) printf(\"%d %d\\n\",i,iter->first);}\n    \n    for(int i=0;i<edges.size();i+=2){\n        Edge e=edges[i];\n        if(d1[e.from]+d2[e.to]+e.cost==length&&bridge[e.from][e.to]){\n            printf(\"SAD\\n\");\n            continue;\n        }\n        if(d1[e.to]+d2[e.from]+e.cost<length){\n            printf(\"HAPPY\\n\");\n            continue;\n        }\n        printf(\"SOSO\\n\");\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <tuple>\n#include <map>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\n\nstruct CostGraph {\n    using T = ll;\n    CostGraph(const int v) : V{v}\n    {\n        edge.resize(v);\n        rev_edge.resize(v);\n    }\n    struct Edge {\n        Edge() {}\n        Edge(const int from, const int to, const T cost) : from{from}, to{to}, cost{cost} {}\n        int from;\n        int to;\n        T cost;\n        bool operator<(const Edge& e) const\n        {\n            return cost != e.cost ? cost < e.cost : to < e.to;\n        }\n    };\n    void addEdge(const int from, const int to, const T cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        rev_edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n    vector<vector<Edge>> rev_edge;\n    const int V;\n};\n\nostream& operator<<(ostream& os, const CostGraph::Edge& e)\n{\n    os << \"(\" << e.from << \"->\" << e.to << \": \" << e.cost << \")\" << endl;\n    return os;\n}\n\nvoid Dijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\nvoid ReverseDijkstra(const CostGraph& g, const int s, vector<CostGraph::T>& d)\n{\n    using T = CostGraph::T;\n    assert(s < g.V);\n    assert(d.size() == g.V);\n    using P = pair<T, int>;\n    priority_queue<P, vector<P>, greater<P>> q;\n    for (int i = 0; i < g.V; i++) {\n        d[i] = INF<T>;\n    }\n    d[s] = 0;\n    q.push(make_pair(0, s));\n    while (not q.empty()) {\n        const P& p = q.top();\n        const T cost = p.first;\n        const int v = p.second;\n        q.pop();\n        if (d[v] < cost) {\n            continue;\n        }\n        for (const auto& e : g.rev_edge[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                q.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nstruct BiconnectedComponent {\npublic:\n    BiconnectedComponent(const CostGraph& g_) : num{0}, comp_num{0}, size{g_.V}, bridge(0), ord(size, -1), low(size, 0), comp(size, -1)\n    {\n        for (int i = 0; i < size; i++) {\n            bridge_dfs(g_, i);\n        }\n        for (int i = 0; i < size; i++) {\n            if (comp[i] >= 0) {\n                continue;\n            }\n            comp_dfs(g_, i, comp_num);\n            comp_num++;\n        }\n    }\n\n    CostGraph toTree() const\n    {\n        CostGraph tree(comp_num);\n        for (const auto& e : bridge) {\n            tree.addEdge(comp[e.from], comp[e.to], 1);\n            tree.addEdge(comp[e.to], comp[e.from], 1);\n        }\n        return tree;\n    }\n    const vector<CostGraph::Edge>& getEdge() const\n    {\n        return bridge;\n    }\n    bool isBridge(const int i, const int j) const\n    {\n        return (ord[i] < ord[j]) ? ord[i] < low[j] : ord[j] < low[i];\n    }\n    const vector<int>& getComp() const\n    {\n        return comp;\n    }\n\n    void bridge_dfs(const CostGraph& g_, const int s, const int par = -1)\n    {\n        ord[s] = num;\n        low[s] = num;\n        num++;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if (to == par) {\n                continue;\n            }\n            if (ord[to] >= 0) {\n                low[s] = min(low[s], ord[to]);\n            } else {\n                bridge_dfs(g_, to, s);\n                low[s] = min(low[s], low[to]);\n            }\n            if (isBridge(s, to)) {\n                bridge.push_back(e);\n            }\n        }\n    }\n\n    void comp_dfs(const CostGraph& g_, const int s, const int c)\n    {\n        comp[s] = c;\n        for (const auto& e : g_.edge[s]) {\n            const int to = e.to;\n            if ((comp[to] == -1) and (not isBridge(s, to))) {\n                comp_dfs(g_, to, c);\n            }\n        }\n    }\n    int num;\n    int comp_num;\n    const int size;\n    vector<CostGraph::Edge> bridge;\n    vector<int> ord;\n    vector<int> low;\n    vector<int> comp;\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    CostGraph g(n);\n    using E = tuple<int, int, ll>;\n    vector<E> edge(m);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--, b--;\n        g.addEdge(a, b, c);\n        edge[i] = make_tuple(a, b, c);\n    }\n    vector<ll> ds(n, INF<ll>);\n    Dijkstra(g, 0, ds);\n    vector<ll> dt(n, INF<ll>);\n    ReverseDijkstra(g, 1, dt);\n    show(ds);\n    show(dt);\n    const ll D = ds[1];\n    CostGraph undg(n);\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[u] + c + dt[v] == D) {\n            undg.addEdge(u, v, c);\n            undg.addEdge(v, u, c);\n        }\n    }\n\n    using pii = pair<int, int>;\n    BiconnectedComponent bic(undg);\n    show(bic.bridge);\n    set<E> bridge;\n    for (const auto& e : bic.bridge) {\n        const int u = e.from;\n        const int v = e.to;\n        bridge.insert(make_tuple(u, v, e.cost));\n    }\n    for (int i = 0; i < m; i++) {\n        const E e = edge[i];\n        const int u = get<0>(e);\n        const int v = get<1>(e);\n        const ll c = get<2>(e);\n        if (ds[v] + c + dt[u] < D) {\n            cout << \"HAPPY\" << endl;\n        } else {\n            if (not(bridge.find(make_tuple(u, v, c)) == bridge.end() and bridge.find(make_tuple(v, u, c)) == bridge.end())) {\n                cout << \"SAD\" << endl;\n            } else {\n                cout << \"SOSO\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\n#define INF (1LL << 60)\n#define MOD 100000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef pair<vll, vll> pvll;\n\nstruct state {\n  ll d, v, p;\n\npublic:\n  bool operator<(const state s) const { return d > s.d; }\n};\n\nconst ll S = 0, G = 1;\nll N, M, A[100000], B[100000], C[100000];\nvector< vector<pll> > E1(100000), E2(100000);\n\npvll dijkstra(vector< vector<pll> > &E, ll s) {\n  vll dist(N, INF), cnt(N, 0);\n  priority_queue<state> q;\n  q.push((state) { 0, s, 1 });\n\n  while(q.size()) {\n    ll d = q.top().d, v = q.top().v, p = q.top().p;\n    q.pop();\n\n    if(dist[v] < d) continue;\n    dist[v] = d;\n    (cnt[v] += p) %= MOD;\n\n    REP(i, 0, E[v].size()) {\n      ll u = E[v][i].first, c = E[v][i].second;\n      if(dist[u] >= d + c) q.push((state) { d + c, u, cnt[v] });\n    }\n  }\n\n  return pvll(dist, cnt);\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, M) {\n    cin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n    E1[A[i]].push_back(pll(B[i], C[i]));\n    E2[B[i]].push_back(pll(A[i], C[i]));\n  }\n\n  pvll d1 = dijkstra(E1, S), d2 = dijkstra(E2, G);\n  vll dist1 = d1.first, dist2 = d2.first, cnt1 = d1.second, cnt2 = d2.second;\n\n  ll orgd = dist1[G];\n  ll orgc = cnt1[G];\n\n  REP(i, 0, M) {\n    ll u = A[i], v = B[i], cost = C[i];\n    if(dist1[v] + cost + dist2[u] < orgd) cout << \"HAPPY\" << endl;\n    else if(dist1[u] + cost + dist2[v] == orgd && (cnt1[u] * cnt2[v]) % MOD == orgc) cout << \"SAD\" << endl;\n    else cout << \"SOSO\" << endl;\n  }\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\nfun main(args: Array<String>?): Unit {\n    val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n    val edges = Array(m){\n        val (a, b, c) = readLine()!!.trim().split( ' ').map(String::toInt)\n        Edge(it, a - 1, b - 1, c)\n    }\n    solve(n, m, edges)\n}\nfun solve(n: Int, m: Int, edges: Array<Edge>) {\n    val nodes = Array(n){ arrayListOf<Edge>()}\n    for (e in edges){\n        nodes[e.from].add(e)\n    }\n    val minFromStart = LongArray(n){Long.MAX_VALUE shr 2}.also{it[0] = 0}\n    val queue = PriorityQueue<Pair<Int, Long>>(compareBy(Pair<*, Long>::second)).also{it.add(Pair(0, 0))}\n    while (queue.isNotEmpty()) {\n        val (current, cost) = queue.poll()\n        if (minFromStart[current] == cost) {\n            for (e in nodes[current]) if (minFromStart[e.to] > e.cost + cost) {\n                minFromStart[e.to] = e.cost + cost\n                queue.add(Pair(e.to, e.cost + cost))\n            }\n        }\n    }\n    for (i in nodes.indices) nodes[i] = arrayListOf()\n    for (e in edges){\n        nodes[e.to].add(e)\n    }\n    val minToGoal = LongArray(n){Long.MAX_VALUE shr 2}.also{it[1] = 0}\n    queue.add(Pair(1, 0))\n    while(queue.isNotEmpty()) {\n        val (current, cost) = queue.poll()\n        if (minToGoal[current] == cost) {\n            for (e in nodes[current]) if (minToGoal[e.from] > e.cost + cost) {\n                minToGoal[e.from] = e.cost + cost\n                queue.add((Pair(e.from, e.cost + cost)))\n            }\n        }\n    }\n    val isBottleNeck = markBottleNeckEdge(n, m, edges, minFromStart, minToGoal)\n    for (e in edges) {\n        if (isBottleNeck[e.id]) {\n            println(\"SAD\")\n        }else if (minFromStart[e.to] + minToGoal[e.from] + e.cost < minFromStart[1]){\n            println(\"HAPPY\")\n        }else {\n            println(\"SOSO\")\n        }\n    }\n}\nfun markBottleNeckEdge(n: Int, m: Int, edges: Array<Edge>, minCostFromStart: LongArray, minCostToGoal: LongArray): BooleanArray {\n    val nodes = Array(n){arrayListOf<FlowEdge>()}\n    val minCost = minCostFromStart[1]\n    for (e in edges) if (minCostFromStart[e.from] + e.cost + minCostToGoal[e.to] == minCost) {\n        nodes[e.from].add(FlowEdge(e.id, e.to, nodes[e.to].size, true))\n        nodes[e.to].add(FlowEdge(e.id, e.from, nodes[e.from].size - 1, false))\n    }\n    val prevEdge = Array(n){null as FlowEdge?}\n    val queue: Queue<Int> = ArrayDeque()\n    queue.add(0)\n    while(queue.isNotEmpty() && queue.peek() != 1) {\n        for (e in nodes[queue.poll()]) if (e.hasFlow && prevEdge[e.to] == null) {\n            prevEdge[e.to] = e\n            queue.add(e.to)\n        }\n    }\n    var last = 1\n    while (last != 0) {\n        val e = prevEdge[last]!!\n        val r = nodes[e.to][e.pair]\n        e.hasFlow = false\n        r.hasFlow = true\n        last = r.to\n    }\n    queue.clear()\n    queue.add(0)\n    prevEdge.fill(null)\n    prevEdge[0] = nodes.first().first()\n    val visited = ArrayDeque<Int>().also{it.add(0)}\n    while(queue.isNotEmpty() && queue.peek() != 1) {\n        for (e in nodes[queue.poll()]) if (e.hasFlow && prevEdge[e.to] == null) {\n            prevEdge[e.to] = e\n            queue.add(e.to)\n            visited.add(e.to)\n        }\n    }\n    if (queue.isNotEmpty()) {\n        return BooleanArray(m){false}\n    }\n    val result = BooleanArray(m){false}\n    var bottleNeck = -1\n    for (v in visited) {\n        for (e in nodes[v]) {\n            if (!e.hasFlow && prevEdge[e.to] == null) {\n                bottleNeck = e.id\n            }\n        }\n    }\n    while(bottleNeck != -1) {\n        visited.clear()\n        queue.clear()\n        result[bottleNeck] = true\n        prevEdge[edges[bottleNeck].to] = nodes.first().first()\n        queue.add(edges[bottleNeck].to)\n        visited.add(edges[bottleNeck].to)\n        bottleNeck = -1\n        while(queue.isNotEmpty()) {\n            for (e in nodes[queue.poll()]) if (e.hasFlow && prevEdge[e.to] == null) {\n                prevEdge[e.to] = e\n                queue.add(e.to)\n                visited.add(e.to)\n            }\n        }\n        for (v in visited) {\n            for (e in nodes[v]) {\n                if (!e.hasFlow && prevEdge[e.to] == null && edges[e.id].to == e.to) {\n                    bottleNeck = e.id\n                }\n            }\n        }\n    }\n    return result\n}\nclass Edge(val id: Int, val from: Int, val to: Int, val cost: Int)\nclass FlowEdge(val id: Int, val to: Int, val pair: Int, var hasFlow: Boolean)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\ndef bridge(G, N):\n    result = set()\n    label = [None]*N\n    gen = 0\n    cost = [0]*N\n    def dfs(u, p, i):\n        nonlocal gen\n        res = 0\n        p_cnt = 0\n        for v, j in G[u]:\n            if v == p:\n                p_cnt += 1\n                continue\n            if label[v] is not None:\n                if label[v] < label[u]:\n                    cost[v] += 1\n                    res += 1\n            else:\n                label[v] = gen; gen += 1\n                res += dfs(v, u, j)\n        res -= cost[u]\n        if res == 0 and p != -1 and p_cnt == 1:\n            result.add(i)\n        return res\n    dfs(0, -1, None)\n    return result\nPB = bridge(G0, n)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\n*ipts, = map(int, open(0).read().split())\nn, m = ipts[:2]\n#n, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    #a, b, c = map(int, input().split())\n    a, b, c = ipts[2+3*i:5+3*i]\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\ndef bridge(G, N):\n    result = set()\n    label = [None]*N\n    gen = 0\n    cost = [0]*N\n    def dfs(u, p, i):\n        nonlocal gen\n        res = 0\n        p_cnt = 0\n        for v, j in G[u]:\n            if v == p:\n                p_cnt += 1\n                continue\n            if label[v] is not None:\n                if label[v] < label[u]:\n                    cost[v] += 1\n                    res += 1\n            else:\n                label[v] = gen; gen += 1\n                res += dfs(v, u, j)\n        res -= cost[u]\n        if res == 0 and p != -1 and p_cnt == 1:\n            result.add(i)\n        return res\n    dfs(0, -1, None)\n    return result\nPB = bridge(G0, n)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(5*10**5)\nn, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    while 1:\n        try:\n            a, b, c = map(int, input().split())\n            break\n        except: pass\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\ndef bridge(G, N):\n    result = set()\n    label = [None]*N\n    gen = 0\n    cost = [0]*N\n    def dfs(u, p, i):\n        nonlocal gen\n        res = 0\n        p_cnt = 0\n        for v, j in G[u]:\n            if v == p:\n                p_cnt += 1\n                continue\n            if label[v] is not None:\n                if label[v] < label[u]:\n                    cost[v] += 1\n                    res += 1\n            else:\n                label[v] = gen; gen += 1\n                res += dfs(v, u, j)\n        res -= cost[u]\n        if res == 0 and p != -1 and p_cnt == 1:\n            result.add(i)\n        return res\n    dfs(0, -1, None)\n    return result\nPB = bridge(G0, n)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\nPB = set()\nlabel = [None]*n\ngen = 1\ncost = [0]*n\ndef dfs(u, p, i):\n    global gen\n    res = 0\n    p_cnt = 0\n    for v, j in G0[u]:\n        if v == p:\n            p_cnt += 1\n            continue\n        if label[v] is not None:\n            if label[v] < label[u]:\n                cost[v] += 1\n                res += 1\n        else:\n            label[v] = gen; gen += 1\n            res += dfs(v, u, j)\n    res -= cost[u]\n    if res == 0 and p != -1 and p_cnt == 1:\n        PB.add(i)\n    return res\nlabel[0] = 0\ndfs(0, -1, None)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\nPB = set()\nlabel = [None]*n\ngen = 0\ncost = [0]*n\ndef dfs(u, p, i):\n    global gen\n    res = 0\n    p_cnt = 0\n    for v, j in G0[u]:\n        if v == p:\n            p_cnt += 1\n            continue\n        if label[v] is not None:\n            if label[v] < label[u]:\n                cost[v] += 1\n                res += 1\n        else:\n            label[v] = gen; gen += 1\n            res += dfs(v, u, j)\n    res -= cost[u]\n    if res == 0 and p != -1 and p_cnt == 1:\n        PB.add(i)\n    return res\ndfs(0, -1, None)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nexit(0)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\ndef bridge(G, N):\n    result = set()\n    label = [None]*N\n    gen = 0\n    cost = [0]*N\n    def dfs(u, p, i):\n        nonlocal gen\n        res = 0\n        p_cnt = 0\n        for v, j in G[u]:\n            if v == p:\n                p_cnt += 1\n                continue\n            if label[v] is not None:\n                if label[v] < label[u]:\n                    cost[v] += 1\n                    res += 1\n            else:\n                label[v] = gen; gen += 1\n                res += dfs(v, u, j)\n        res -= cost[u]\n        if res == 0 and p != -1 and p_cnt == 1:\n            result.add(i)\n        return res\n    dfs(0, -1, None)\n    return result\nPB = bridge(G0, n)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\ndef bridge(G, N):\n    result = set()\n    label = [None]*N\n    gen = 0\n    cost = [0]*N\n    def dfs(u, p, i):\n        nonlocal gen\n        res = 0\n        p_cnt = 0\n        for v, j in G[u]:\n            if v == p:\n                p_cnt += 1\n                continue\n            if label[v] is not None:\n                if label[v] < label[u]:\n                    cost[v] += 1\n                    res += 1\n            else:\n                label[v] = gen; gen += 1\n                res += dfs(v, u, j)\n        res -= cost[u]\n        if res == 0 and p != -1 and p_cnt == 1:\n            result.add(i)\n        return res\n    dfs(v, -1, None)\n    return result\nPB = bridge(G0, n)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\nprint(*ans, sep='\\n')"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**6)\nn, m = map(int, input().split())\nE = []\nG = [[] for i in range(n)]\nRG = [[] for i in range(n)]\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    E.append((a-1, b-1, c))\n    G[a-1].append((b-1, c, i))\n    RG[b-1].append((a-1, c, i))\ndef dijkstra(G, s):\n    dist = [10**18]*n\n    dist[s] = 0\n    que = [(0, s)]\n    while que:\n        co, v = heappop(que)\n        if dist[v] < co:\n            continue\n        for w, c, i in G[v]:\n            if co + c < dist[w]:\n                dist[w] = co + c\n                heappush(que, (co + c, w))\n    return dist\nD = dijkstra(G, 0)\nRD = dijkstra(RG, 1)\n\nG0 = [[] for i in range(n)]\nused = set([1])\ndeq = deque([1])\nP = set()\nwhile deq:\n    v = deq.popleft()\n    for w, c, i in RG[v]:\n        # w --> v\n        if D[w] + c == D[v]:\n            P.add(i)\n            if w not in used:\n                used.add(w)\n                deq.append(w)\n            G0[v].append((w, i))\n            G0[w].append((v, i))\n\ndef bridge(G, N):\n    result = set()\n    label = [None]*N\n    gen = 0\n    cost = [0]*N\n    def dfs(u, p, i):\n        nonlocal gen\n        res = 0\n        p_cnt = 0\n        for v, j in G[u]:\n            if v == p:\n                p_cnt += 1\n                continue\n            if label[v] is not None:\n                if label[v] < label[u]:\n                    cost[v] += 1\n                    res += 1\n            else:\n                label[v] = gen; gen += 1\n                res += dfs(v, u, j)\n        res -= cost[u]\n        if res == 0 and p != -1 and p_cnt == 1:\n            result.add(i)\n        return res\n    dfs(v, -1, None)\n    return result\nPB = bridge(G0, n)\n\nans = []\nfor i in range(m):\n    if i in P:\n        if i in PB:\n            ans.append(\"SAD\")\n        else:\n            ans.append(\"SOSO\")\n    else:\n        a, b, c = E[i]\n        if D[b] + c + RD[a] < D[1]:\n            ans.append(\"HAPPY\")\n        else:\n            ans.append(\"SOSO\")\n*_,=map(print, ans)"
  }
]