[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF \n#define ll long long\nusing namespace std;\nint n;\ndouble w;\npair<double,double> u[100000];\nint main(){\n    cin>>n>>w;\n    double ans,weight;\n    double ww,vv;\n    rep(i,n){\n        cin>>ww>>vv;\n        u[i]=make_pair(vv/ww,ww);\n    }\n    sort(u,u+n);\n    reverse(u,u+n);\n    rep(i,n){\n        if (u[i].second<0){\n            if (weight+u[i].second<=w){\n                ans+=u[i].first*u[i].second;\n                weight+=u[i].second;\n            }else{\n                ans+=u[i].first*(w-weight);\n                break;\n            }\n        }\n    }\n    rep(i,n){\n        if (u[i].second>=0){\n            if (weight+u[i].second<=w){\n                ans+=u[i].first*u[i].second;\n                weight+=u[i].second;\n            }else{\n                ans+=u[i].first*(w-weight);\n                break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second * q.first != (double)q.second * p.first) return (double)p.second * q.first > (double)q.second * p.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  return !compare(p, q);\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N;\n  ll W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N, 0);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] < 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] > 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0){ assert(v[i] > 0); get.push_back(P(w[i], v[i])); }\n      else { assert(v[i] < 0); reduce.push_back(P(w[i], v[i])); }\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            assert(rest > 0);\n            double use_p = rest/abs(reduce[r_idx].first);\n            assert(abs(W - reduce[r_idx].first * use_p - get[i].first) < 0.001);\n            W = get[i].first;\n            ans += reduce[r_idx].second * use_p;\n            reduce[r_idx].first += rest;\n            reduce[r_idx].second = (reduce[r_idx].second - reduce[r_idx].second * use_p);\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else if(W > 0){\n          double p = (double)W/get[i].first;\n          assert(0 < p && p < 1);\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct item{\n  int value, weight;\n};\n\nint main(){\n\n  int N, W;\n  cin >> N >> W;\n\n  vector<item> plus_item, minus_item;\n\n  int weight_sum = 0, value_sum = 0;\n  \n  for(int i = 0; i < N; i++){\n    int w, v;\n    cin >> w >> v;\n\n    if(w >= 0 && v <= 0)\n      continue;\n\n    if(w <= 0 && v >= 0){\n      weight_sum += w;\n      value_sum += v;\n      continue;\n    }\n\n    if(w >= 0){\n      item itm;\n      itm.weight = w;\n      itm.value = v;\n      plus_item.push_back(itm);\n    }else{\n      item itm;\n      itm.weight = -w;\n      itm.value = -v;\n      minus_item.push_back(itm);\n    }\n  }\n\n  if(plus_item.size() == 0){\n    cout << value_sum << endl;\n    return 0;\n  }\n\n  sort(plus_item.begin(), plus_item.end(), [] (const item &i1, const item &i2) {\n      return i1.value * i2.weight > i1.weight * i2.value;});\n\n  sort(minus_item.begin(), minus_item.end(), [] (const item &i1, const item &i2) {\n      return i1.value * i2.weight < i1.weight * i2.value;});\n  \n  int plus_item_size = plus_item.size();\n  int minus_item_size = minus_item.size();\n  double ans;\n  int i;\n  for(i = 0; i < plus_item_size; i++){\n    \n    if(weight_sum + plus_item[i].weight > W)\n      break;\n    \n    weight_sum += plus_item[i].weight;\n    value_sum += plus_item[i].value;\n    if(i == plus_item_size - 1){\n      cout << weight_sum << endl;\n      return 0;\n    }\n    \n  }\n\n  ans = (double)value_sum + (double)plus_item[i].value * (double)(W - weight_sum) / (double)plus_item[i].weight;\n\n\n  for(int k = 0; k < minus_item_size; k++){\n    value_sum -= minus_item[k].value;\n    weight_sum -= minus_item[k].weight;\n\n    while(i < plus_item_size && weight_sum + plus_item[i].weight <= W){\n      weight_sum += plus_item[i].weight;\n      value_sum += plus_item[i].value;\n      i++;\n    }\n\n    if(i == plus_item_size){\n      ans = max(ans, (double)value_sum);\n      break;\n    }\n\n    ans = max(ans, (double)value_sum + (double)plus_item[i].value * (double)(W - weight_sum) / (double)plus_item[i].weight);\n    \n  }\n\n  cout << ans << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        // w<0,v>0\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            // RXgà¿là¸ç·âÂÍA¦ª¢ÔÉqueueÉËÁñÅ¨­\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        // ®SÉæ¾Â\\Å êÎASÄæ¾\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            // SÄæ¾Å«È¢ê,Ü¸æêé¾¯æé\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                // quanÌª¾¯æé\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                // cèSÄðèÄéÌÉKvÈWÌÊ\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                // decÍ¿lðâ¹È­ÈÁ½çà¤æéÌðâßé\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    // àµ»Ý\n                    if(!EQ(p.first,(1.0/pp.first))&&(p.first<1.0/pp.first)){\n                        break;\n                    }\n                    // ¡ñÌ}CiXªÅAd³SÄðÜ©È¦éæ¤ÉÈÁ½çÎAI¹\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)){\n                        // ¡ñèÉüêçê½d³\n                        curGetW+=xi[pp.second]*wi[pp.second];\n                        // ¿lð¡ñÌª¾¯ÁZ\n                        curGetVal+=xi[pp.second]*vi[pp.second];\n                        xi[pp.second]=0;\n                        break;\n                    }\n                    else if(curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        // KvÈÊ¾¯èÉüêé\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        dec.push(pp);\n                        break;\n                    }\n                    else{\n                        // Ü¾needWæè­È¢öxÌÊµ©È¢\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    // ðð½¹È¢ÈçÎA»êÈãæÁÄà³ÊÈÌÅAI¹\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                // ÅãÜÅæêÈ©Á½êARÜÅÆÁ½ªÅl¦é\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}\n\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N;\ndouble W;\ndouble w[MAXN], v[MAXN];\n\ndouble V;\nvector<pair<double,double> > A;\n\nbool comp(const pair<double,double> &a, const pair<double,double> &b) {\n  return a.second*b.first > b.second*a.first;\n}\n\nint main() {\n  cin >> N >> W;\n  for(int i = 0; i < N; ++i) {\n    cin >> w[i] >> v[i];\n  }\n\n  V = 0;\n\n  A.clear();\n  for(int i = 0; i < N; ++i) {\n    if(w[i] >= 0 && v[i] <= 0) {\n      //\n    } else if(w[i] <= 0 && v[i] >= 0) {\n      W -= w[i];\n      V += v[i];\n    } else if(w[i] >= 0 && v[i] >= 0) {\n      A.push_back(make_pair(w[i],v[i]));\n    } else {\n      W -= w[i];\n      V += v[i];\n      A.push_back(make_pair(-w[i],-v[i]));\n    }\n  }\n\n  sort(A.begin(), A.end(), comp);\n  for(int i = 0; i < A.size(); ++i) {\n    double x = min(1.0, W/A[i].first);\n    W -= A[i].first*x;\n    V += A[i].second*x;\n  }\n  printf(\"%.6f\\n\", V);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first > (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N;\n  ll W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] < 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] > 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0){ assert(v[i] > 0); get.push_back(P(w[i], v[i])); }\n      else { assert(v[i] < 0); reduce.push_back(P(w[i], v[i])); }\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            assert(rest > 0);\n            double p = (abs(reduce[r_idx].first) - rest)/abs(reduce[r_idx].first);\n            assert(0 < p && p < 1);\n            W = get[i].first;\n            ans += reduce[r_idx].second * (1-p);\n            reduce[r_idx].first *= p;\n            reduce[r_idx].second *= p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else{\n          double p = (double)W/get[i].first;\n          assert(0 < p && p < 1);\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    if(!EQ(p.first,(1.0/pp.first))&&(p.first<1.0/pp.first)){\n                        break;\n                    }\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)){\n                        curGetW+=xi[pp.second]*wi[pp.second];\n                        curGetVal+=xi[pp.second]*vi[pp.second];\n                        xi[pp.second]=0;\n                        break;\n                    }\n                    else if(curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        dec.push(pp);\n                        break;\n                    }\n                    else{\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v / w < 1.0*val.v / val.w; };\n};\n\nint main(){\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w * temp.v <= 0){\n\t\t\t\tif (temp.w <= 0){//w- && v+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t}\n\t\t\t\t//w+ && v- -> 必ず不使用(x=0)/無視\n\t\t\t} else{//w,v同符号 -> v/w大の順に使用\n\t\t\t\tif (temp.w <= 0){//w- && v- -> 使用したことにする\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t}\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t////w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b > 0 && c <= 0){\n\t\t\tcontinue;\n\t\t} else if (b < 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tans += ((w - sum) / a[cnt][0] > 1 ? 1 : (w - sum) / a[cnt][0]) * a[cnt][1];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tif (*((float*)a) < 0 && *((float*)b) > 0){\n\t\treturn -1;\n\t} else if (*((float*)a) > 0 && *((float*)b) < 0){\n\t\treturn 1;\n\t}\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2];\n\tdouble ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b >= 0 && c <= 0){\n\t\t\ti--;\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t} else if (b <= 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tif ((w - sum) / a[cnt][0] > 1){\n\t\t\tans += a[cnt][1];\n\t\t} else{\n\t\t\tfloat tmp = (w - sum) * a[cnt][1];\n\t\t\ttmp /= a[cnt][0];\n\t\t\tans += tmp;\n\t\t}\n\t}\n\tprintf(\"%.4f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w < 0){\n\t\t\t\tif (temp.v >= 0){//w- && v0+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t} else{//w- && v- -> 使用したことにして符号合わせ\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t\tM.push_back(temp);\n\t\t\t\t}\n\t\t\t} else if (temp.v > 0){//w0+ && v+ -> v/w大の順に使用\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t\t//w0+ && v0- -> 必ず不使用(x=0)/無視\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t////w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    if(!EQ(p.first,(1.0/pp.first))&&(p.first<1.0/pp.first))break;\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)||curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        if(!EQ(1,xi[pp.second]))dec.push(pp);\n                        break;\n                    }\n                    else{\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w * temp.v <= 0){\n\t\t\t\tif (temp.w <= 0){//w- && v+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t}\n\t\t\t\t//w+ && v- -> 必ず不使用(x=0)/無視\n\t\t\t} else{//w,v同符号 -> v/w大の順に使用\n\t\t\t\tif (temp.w <= 0){//w- && v- -> 使用したことにする\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t}\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t////w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  int w, v;\n  double vdw;\n} Goods;\n\nclass GreaterVDW\n{\npublic:\n  bool operator() (const Goods& lhs, const Goods& rhs)\n  {\n    return lhs.vdw > rhs.vdw;\n  }\n};\n\nint main()\n{\n  int N, W;\n  while (cin >> N >> W) {\n    double ans = 0.0;\n    vector<Goods> goods;\n    goods.reserve(N);\n    for (int i = 0; i < N; ++i) {\n      int w, v;\n      scanf(\"%d %d\", &w, &v);\n      if (w >= 0 && v <= 0) {\n\tcontinue;\n      } else if (w <= 0 && v >= 0) {\n\tW -= w;\n\tans += v;\n      } else {\n\tGoods g;\n\tg.w = w;\n\tg.v = v;\n\tif (g.w < 0 && g.v < 0) {\n\t  g.w = -g.w;\n\t  g.v = -g.v;\n\t  W += g.w;\n\t  ans -= g.v;\n\t}\n\tg.vdw = v / (w * 1.0);\n\tgoods.push_back(g);\n      }\n    }\n    sort(goods.begin(), goods.end(), GreaterVDW());\n\n    for (unsigned int i = 0; i < goods.size(); ++i) {\n      if (W < goods[i].w) {\n\tans += (W / (goods[i].w * 1.0)) * goods[i].v;\n\tbreak;\n      } else {\n\tans += goods[i].v;\n\tW -= goods[i].w;\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,pair<int,int> > p[110000];\npair<double,pair<int,int> > q[110000];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tint sz=0;\n\tint s2=0;\n\tdouble val=0;\n\tfor(int i=0;i<a;i++){\n\t\tint w,v;\n\t\tscanf(\"%d%d\",&w,&v);\n\t\tif(v>=0&&w<=0){\n\t\t\tval+=v;\n\t\t\tb-=w;\n\t\t}else if(v<=0&&w>=0){\n\t\t\tcontinue;\n\t\t}else if(v>0){\n\t\t\tp[sz++]=make_pair((double)w/v,make_pair(w,v));\n\t\t}else{\n\t\t\tq[s2++]=make_pair((double)w/v,make_pair(w,v));\n\t\t}\n\t}\n\tstd::sort(p,p+sz);\n\tstd::sort(q,q+s2);\n\tint lb=b;\n\tdouble tmp=val;\n\tdouble ret=0;\n\tint at=0;\n\tfor(int i=0;i<=s2;i++){\n\t\twhile(at<sz&&b-p[at].second.first>=0){\n\t\t\tb-=p[at].second.first;\n\t\t\tval+=(double)p[at].second.second;\n\t\t\tat++;\n\t\t}\n\t\tif(at<sz)ret=max(ret,val+(double)p[at].second.second*b/p[at].second.first);\n\t\telse ret=max(ret,val);\n\t\tif(i<s2){\n\t\t\tb-=q[i].second.first;\n\t\t\tval+=q[i].second.second;\n\t\t}\n\t}\n\tat=0;\n\tval=tmp;\n\tb=lb;\n\tfor(int i=0;i<sz;i++){\n\t\tval+=p[i].second.second;\n\t\tb-=p[i].second.first;\n\t\twhile(at<s2&&b-q[at].second.first<0){\n\t\t\tb-=q[at].second.first;\n\t\t\tval+=(double)q[at].second.second;\n\t\t\tat++;\n\t\t}\n\t\tif(at>=s2)break;\n\t\tret=max(ret,val+(double)b/q[at].second.first*q[at].second.second);\n\t}\n\tprintf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\t//FILE* fp_in;\n\t//freopen_s(&fp_in, \"stdin.txt\", \"r\", stdin);//\n\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w < 0){\n\t\t\t\tif (temp.v >= 0){//w- && v0+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t} else{//w- && v- -> 使用したことにして符号合わせ\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t\tM.push_back(temp);\n\t\t\t\t}\n\t\t\t} else if (temp.v > 0){//w0+ && v+ -> v/w大の順に使用\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t\t//w0+ && v0- -> 必ず不使用(x=0)/無視\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t//w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\n\t//fclose(fp_in);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct item{\n  int value, weight;\n};\n\nint main(){\n\n  int N, W;\n  cin >> N >> W;\n\n  vector<item> plus_item, minus_item;\n\n  int weight_sum = 0, value_sum = 0;\n  \n  for(int i = 0; i < N; i++){\n    int w, v;\n    cin >> w >> v;\n\n    if(w >= 0 && v <= 0)\n      continue;\n\n    if(w <= 0 && v >= 0){\n      weight_sum += w;\n      value_sum += v;\n      continue;\n    }\n\n    if(w >= 0){\n      item itm;\n      itm.weight = w;\n      itm.value = v;\n      plus_item.push_back(itm);\n    }else{\n      item itm;\n      itm.weight = -w;\n      itm.value = -v;\n      minus_item.push_back(itm);\n    }\n  }\n\n  if(plus_item.size() == 0){\n    cout << value_sum << endl;\n    return 0;\n  }\n\n  sort(plus_item.begin(), plus_item.end(), [] (const item &i1, const item &i2) {\n      return i1.value * i2.weight > i1.weight * i2.value;});\n\n  sort(minus_item.begin(), minus_item.end(), [] (const item &i1, const item &i2) {\n      return i1.value * i2.weight < i1.weight * i2.value;});\n  \n  int plus_item_size = plus_item.size();\n  int minus_item_size = minus_item.size();\n  double ans;\n  int i;\n  for(i = 0; i < plus_item_size; i++){\n    \n    if(weight_sum + plus_item[i].weight > W)\n      break;\n    \n    weight_sum += plus_item[i].weight;\n    value_sum += plus_item[i].value;\n    if(i == plus_item_size - 1){\n      cout << value_sum << endl;\n      return 0;\n    }\n    \n  }\n\n  ans = (double)value_sum + (double)plus_item[i].value * (double)(W - weight_sum) / (double)plus_item[i].weight;\n  //  cout << value_sum << ' '  << plus_item[i].value << ' ' << weight_sum << ' ' << plus_item[i].weight << endl;\n\n  for(int k = 0; k < minus_item_size; k++){\n    value_sum -= minus_item[k].value;\n    weight_sum -= minus_item[k].weight;\n\n    while(i < plus_item_size && weight_sum + plus_item[i].weight <= W){\n      weight_sum += plus_item[i].weight;\n      value_sum += plus_item[i].value;\n      i++;\n    }\n\n    if(i == plus_item_size){\n      ans = max(ans, (double)value_sum);\n      break;\n    }\n\n    ans = max(ans, (double)value_sum + (double)plus_item[i].value * (double)(W - weight_sum) / (double)plus_item[i].weight);\n    \n  }\n\n  cout << ans << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        // w<0,v>0\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            // RXgà¿là¸ç·âÂÍA¦ª¢ÔÉqueueÉËÁñÅ¨­\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        // ®SÉæ¾Â\\Å êÎASÄæ¾\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            // SÄæ¾Å«È¢ê,Ü¸æêé¾¯æé\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                // quanÌª¾¯æé\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                // cèSÄðèÄéÌÉKvÈWÌÊ\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    // ¡ñÌ}CiXªÅAd³SÄðÜ©È¦éæ¤ÉÈÁ½çÎAI¹\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)){\n                        // ¡ñèÉüêçê½d³\n                        curGetW+=xi[pp.second]*wi[pp.second];\n                        // ¿lð¡ñÌª¾¯ÁZ\n                        curGetVal+=xi[pp.second]*vi[pp.second];\n                        xi[pp.second]=0;\n                        break;\n                    }\n                    else if(curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        // KvÈÊ¾¯èÉüêé\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        dec.push(pp);\n                        break;\n                    }\n                    else{\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    // ðð½¹È¢ÈçÎA»êÈãæÁÄà³ÊÈÌÅAI¹\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                // ÅãÜÅæêÈ©Á½êARÜÅÆÁ½ªÅl¦é\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nconst int MAX_N = 100000;\nint N, W;\ndouble V;\nint w[MAX_N], v[MAX_N];\nvector<pair<double, int> > r;\n\nint main() {\n  cin >> N >> W;\n  rep(i, N) {\n    cin >> w[i] >> v[i];\n    if (w[i] >= 0 && v[i] <= 0) {\n      continue;\n    } else if (w[i] <= 0 && v[i] >= 0) {\n      W -= w[i];\n      V += v[i];\n    } else {\n      if (w[i] < 0 && v[i] < 0) {\n        W -= w[i];\n        V += v[i];\n        w[i] = -w[i];\n        v[i] = -v[i];\n        r.push_back(pair<double, int>((double)v[i]/(double)w[i], i));\n      } else {\n        r.push_back(pair<double, int>((double)v[i]/(double)w[i], i));\n      }\n    }\n  }\n  \n  sort(all(r), greater<pair<double, int> >());\n\n  for (int i = 0; i < (int)r.size(); ++i) {\n    int t = r[i].sc;\n    if (W >= w[t]) {\n      W -= w[t]; V += v[t];\n    } else {\n      V += double((double)W/(double)w[t]*(double)v[t]);\n      break;\n    }\n  }\n  \n  cout << V << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tif (*((float*)a) < 0 && *((float*)b) > 0){\n\t\treturn -1;\n\t} else if (*((float*)a) > 0 && *((float*)b) < 0){\n\t\treturn 1;\n\t}\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, cnt;\n\tfloat a[100000][2];\n\tdouble ans = 0, sum = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b >= 0 && c <= 0){\n\t\t\ti--;\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t} else if (b <= 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = (float)b;\n\t\ta[i][1] = (float)c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tif ((w - sum) / a[cnt][0] > 1){\n\t\t\tans += a[cnt][1];\n\t\t} else{\n\t\t\tdouble tmp = (w - sum) * a[cnt][1];\n\t\t\ttmp /= a[cnt][0];\n\t\t\tans += tmp;\n\t\t}\n\t}\n\tprintf(\"%.4f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first > (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N;\n  ll W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] < 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] > 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0){ assert(v[i] > 0); get.push_back(P(w[i], v[i])); }\n      else { assert(v[i] < 0); reduce.push_back(P(w[i], v[i])); }\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            assert(rest > 0);\n            double p = (abs(reduce[r_idx].first) - rest)/abs(reduce[r_idx].first);\n           // assert(0 < p && p < 1);\n            W = get[i].first;\n            ans += reduce[r_idx].second * (1-p);\n            reduce[r_idx].first *= p;\n            reduce[r_idx].second *= p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else{\n          double p = (double)W/get[i].first;\n          //assert(0 < p && p < 1);\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint n;\ndouble W;\n\nbool pred(pair<int,int> a, pair<int,int> b){\n    return a.first * b.second < a.second * a.first;\n}\n\nint main(){\n    cin >> n >> W;\n    vector<pair<int,int> > vp;\n    double ret=0;\n    double w,v;\n    for(int i=0;i<n;i++){\n        cin >> w >> v;\n        if(w <= 0 && v >= 0){\n            W += w;\n            ret += v;\n        }else if(w >=0 && v <= 0){\n            //do nothing\n        }else if(v < 0 && w < 0){\n            W -= w;\n            ret += v;\n            vp.push_back(make_pair(-v,-w));\n        }else{\n            vp.push_back(make_pair(v,w));\n        }\n    }\n    sort(vp.begin(), vp.end(), pred);\n    for(int i=0;i<vp.size();i++){\n        if(W - vp[i].second >= EPS){\n            ret += vp[i].first;\n            W -=vp[i].second;\n        }else{\n            ret += vp[i].first * (W / vp[i].second);\n            break;\n        }\n    }\n    printf(\"%.9f\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,W;\n  cin>>N>>W;\n  double cw=0,cv=0;\n  vector<tuple<double,double,double> > p,n;\n  while(N--){\n    long long w,v;\n    cin>>w>>v;\n    if(w*v>0){\n      ((w>0)?p:n).emplace_back(v*1./w,1.*w,1.);\n    }else if(v>0){\n      cw+=w;\n      cv+=v;\n    }\n  }\n  sort(begin(p),end(p));\n  sort(begin(n),end(n));\n  while(!p.empty()){\n    double vw=get<0>(p.back());\n    double w=get<1>(p.back());\n    double &r=get<2>(p.back());\n    if(cw+w*r<=W){\n      cw+=w*r;\n      cv+=vw*w*r;\n      p.pop_back();\n    }else{\n      double l=(W-cw)/w;\n      cw=W;\n      cv+=vw*w*l;\n      r-=l;\n      break;\n    }\n  }\n  double m=cv;\n  while(!p.empty()&&!n.empty()){\n    auto &pb=p.back();\n    auto &nb=n.back();\n    double l=min(get<2>(pb)*get<1>(pb),-get<2>(nb)*get<1>(nb));\n    cv+=(get<0>(pb)-get<0>(nb))*l;\n    m=max(m,cv);\n    get<2>(pb)-=l/get<1>(pb);\n    get<2>(nb)-=l/-get<1>(nb);\n    ((get<2>(nb)<get<2>(pb))?n:p).pop_back();\n  }\n  cout<<fixed<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b >= 0 && c <= 0){\n\t\t\tcontinue;\n\t\t} else if (b <= 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tans += ((w - sum) / a[cnt][0] > 1 ? 1 : (w - sum) / a[cnt][0]) * a[cnt][1];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\tcout.precision(8);\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w < 0){\n\t\t\t\tif (temp.v >= 0){//w- && v0+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t} else{//w- && v- -> 使用したことにして符号合わせ\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t}\n\t\t\t} else if (temp.v > 0){//w0+ && v+ -> v/w大の順に使用\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t\t//w0+ && v0- -> 必ず不使用(x=0)/無視\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t////w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nbool cmp(const pair<int,int> &a, const pair<int,int> &b) {\n    return (double)a.second / a.first > (double)b.second / b.first;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    int N, W;\n    cin >> N >> W;\n\n    double ans = 0;\n    double rem = W;\n    vector<pair<int,int> > posv, negv;\n    for(int i = 0; i < N; ++i) {\n        int w, vv;\n        cin >> w >> vv;\n        if(w <= 0 && vv >= 0) {\n            ans += vv;\n            rem -= w;\n        }\n        else if(w >= 0 && vv <= 0) {\n            // through\n        }\n        else {\n            if(w > 0) posv.push_back(make_pair(w, vv));\n            else negv.push_back(make_pair(-w, -vv));\n        }\n    }\n    sort(posv.begin(), posv.end(), cmp);\n    sort(negv.begin(), negv.end(), cmp);\n    reverse(negv.begin(), negv.end());\n\n    double pr, nr;\n    vector<pair<int,int> >::iterator pi, ni;\n    pi = posv.begin();\n    ni = negv.begin();\n    pr = 0;\n    if(ni != negv.end()) nr = ni->first;\n\n    while(rem > 0 && pi != posv.end()) {\n        if(rem < pi->first) {\n            ans += pi->second * rem / pi->first;\n            pr = pi->first - rem;\n            rem = 0;\n        }\n        else {\n            ans += pi->second;\n            rem -= pi->first;\n            ++pi;\n        }\n    }\n\n    while(pi != posv.end() && ni != negv.end()) {\n        double amt_w = min(pr, nr);\n\n        double diff = amt_w/pi->first*pi->second - amt_w/ni->first*ni->second;\n        if(diff < 0) break;\n        ans += diff;\n        pr -= amt_w;\n        nr -= amt_w;\n        if(pr < 1e-13) {\n            ++pi;\n            pr = pi->first;\n        }\n        if(nr < 1e-13) {\n            ++ni;\n            nr = ni->first;\n        }\n    }\n\n    cout.precision(4);\n    cout.setf(ios::fixed);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b > 0 && c <= 0){\n\t\t\tcontinue;\n\t\t} else if (b < 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tans += ((w - sum) * a[cnt][1] > 1 ? 1 : (w - sum) * a[cnt][1]) / a[cnt][0];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b > 0 && c <= 0){\n\t\t\tcontinue;\n\t\t} else if (b < 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tans += (w - sum) * a[cnt][1] / a[cnt][0];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans=0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b,c;\n\t\tcin >> b >> c;\n\t\tif (b>0 && c < 0){\n\t\t\tcontinue;\n\t\t} else if (b < 0 && c < 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tans += (w - sum) * a[cnt][1] / a[cnt][0];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nstruct st{\n  double v,w;\n  bool operator<(const st & a)const{\n    return v/w > a.v/a.w;\n  }\n  bool operator>(const st & a)const{\n    return v/w > a.v/a.w;\n  }\n};\n\ndouble solve(double w,vector<st> & pos,vector<st> & neg){\n  double posx=0;/*ppが指しているものweight*/\n  double negx=1;\n  double ret = 0;\n  int pp = 0,np = 0;\n  while(pp < pos.size() && w > 0){\n    double tx = min(1.0,w/pos[pp].w);\n    ret += pos[pp].v * tx;\n    w -= tx * pos[pp].w;\n    if (w < 1e-10){\n      posx = 1-tx;\n      break;\n    }\n    else pp++;\n  }\n  if (posx < 1e-10)pp++,posx = 1;\n  //cout << \"pp : \" << ret <<\" \"<< posx << endl;\n\n  while(pp < pos.size() && np < neg.size()){\n    /*posxを詰め込むために必要なw。*/\n    double pw = posx * pos[pp].w;\n    /*negxによって、開けることができるw。*/\n    double gw = negx * -neg[np].w;\n    double used = min(pw,gw);\n    double px = used/pos[pp].w;\n    double gx = used/-neg[np].w;\n    if (px * pos[pp].v < gx * -neg[np].v)break;/*これ以上は、負/負のものを使っても価値が増えることはない。*/\n    ret += px * pos[pp].v;\n    ret += gx * neg[np].v;\n\n    posx -= px;\n    negx -= gx;\n\n    if (posx < 1e-10)pp++,posx = 1;\n    if (negx < 1e-10)np++,negx = 1;\n\n  }\n  return ret;\n}\n\nmain(){\n  int n,w;\n  while(cin>>n>>w && n){\n    double ans=0,wlim = w;\n    vector<st> pos,neg;\n    rep(i,n){\n      double tw,tv;\n      cin>>tw>>tv;\n      if (tw <= 0 && tv >= 0){//全部使って良い\n\tw -= tw;\n\tans += tv;\n      }else if (0 < tw && tv <= 0){//一つも使わない。\n      }else if (tw >= 0 && tv > 0){//\n\tpos.push_back((st){tv,tw});\n      }else if (tw < 0 && tv <= 0){\n\tneg.push_back((st){tv,tw});\n      }\n    }\n    sort(pos.begin(),pos.end());\n    sort(neg.begin(),neg.end(),greater<st>());\n    //rep(i,pos.size())cout << pos[i].w <<\" \" << pos[i].v << endl;\n    double tmp = solve(w,pos,neg);\n    printf(\"%.10lf\\n\",tmp+ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\tcout.precision(8);\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w * temp.v <= 0){\n\t\t\t\tif (temp.w <= 0){//w- && v+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t}\n\t\t\t\t//w+ && v- -> 必ず不使用(x=0)/無視\n\t\t\t} else{//w,v同符号 -> v/w大の順に使用\n\t\t\t\tif (temp.w <= 0){//w- && v- -> 使用したことにする\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t}\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t////w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first > (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N, W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] <= 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] >= 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0) get.push_back(P(w[i], v[i]));\n      else reduce.push_back(P(w[i], v[i]));\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            double p = (abs(reduce[r_idx].first) - rest)/abs(reduce[r_idx].first);\n            W = get[i].first;\n            ans += reduce[r_idx].second * (1-p);\n            reduce[r_idx].first *= p;\n            reduce[r_idx].second *= p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else{\n          double p = (double)W/get[i].first;\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int n;\n    long long wSum;\n    cin >> n >> wSum;\n\n    double ret = 0.0;\n    multimap<double, pair<int, int> > mm;\n    for(int i=0; i<n; ++i){\n        int w, v;\n        cin >> w >> v;\n        if(w > 0){\n            if(v > 0)\n                mm.insert(make_pair(-v/(double)w, make_pair(w, v)));\n        }else{\n            wSum -= w;\n            ret += v;\n            if(v < 0)\n                mm.insert(make_pair(-v/(double)w, make_pair(-w, -v)));\n        }\n    }\n\n    while(!mm.empty()){\n        int w = mm.begin()->second.first;\n        int v = mm.begin()->second.second;\n        mm.erase(mm.begin());\n\n        if(w <= wSum){\n            wSum -= w;\n            ret += v;\n        }else{\n            ret += (double)v * wSum / w;\n            wSum = 0;\n        }\n    }\n\n    printf(\"%.10f\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, W, w[100009], v[100009], cnt; vector<pair<double, int> > d1, d2;\ndouble solve(double x) {\n\tdouble ret = 0.0, sum1 = 0.0, sum2 = 0.0;\n\tfor (int i = 0; i < d1.size() && d1[i].first > 0.0; i++) {\n\t\tif (sum1 + d1[i].second < W + x) {\n\t\t\tret += d1[i].first * d1[i].second;\n\t\t\tsum1 += d1[i].second;\n\t\t}\n\t\telse {\n\t\t\tret += d1[i].first * (W + x - sum1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < d2.size(); i++) {\n\t\tif (sum2 + d2[i].second < x) {\n\t\t\tret += d2[i].first * d2[i].second;\n\t\t\tsum2 += d2[i].second;\n\t\t}\n\t\telse {\n\t\t\tret += d2[i].first * (x - sum2);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d%d\", &N, &W);\n\tdouble sum = 0.0, sum2 = 0.0;\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &w[i], &v[i]);\n\t\tif (w[i] == 0) sum += max(v[i], 0);\n\t\tif (w[i] > 0) d1.push_back(make_pair(1.0 * v[i] / w[i], w[i]));\n\t\telse d2.push_back(make_pair(-1.0 * v[i] / w[i], -w[i])), sum2 -= w[i];\n\t}\n\tsort(d1.begin(), d1.end(), greater<pair<double, int> >());\n\tsort(d2.begin(), d2.end(), greater<pair<double, int> >());\n\tdouble l = 0.0, r = sum2;\n\tfor (int i = 0; i < 90; i++) {\n\t\tdouble m1 = (l * 2.0 + r) / 3.0;\n\t\tdouble m2 = (l + r * 2.0) / 3.0;\n\t\tif (solve(m1) < solve(m2)) l = m1;\n\t\telse r = m2;\n\t}\n\tprintf(\"%.10lf\\n\", solve(l) + sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Vect {\n  double w;\n  double v;\n  double t;\n  Vect() {;}\n  Vect(double w, double v, double t) : w(w), v(v), t(t) {;}\n  bool operator<(const Vect &rhs) const {\n    return t > rhs.t;\n  }\n};\n\nint N, W;\nint main() {\n  while (scanf(\"%d %d\", &N, &W) > 0) {\n    double ans = 0.0;\n    vector<Vect> plus;\n    vector<Vect> minus;\n    REP(i, N) {\n      double w, v;\n      scanf(\"%lf %lf\", &w, &v);\n      if (w >= 0 && v <= 0) {\n        continue;\n      } else if (w <= 0 && v >= 0) {\n        ans += v;\n        W += w;\n      } else if (w > 0 && v > 0) {\n        plus.push_back(Vect(w, v, v / w));\n      } else if (w < 0 && v < 0) {\n        minus.push_back(Vect(w, v, w / v));\n      } else {\n        assert(false);\n      }\n    }\n    sort(plus.begin(), plus.end());\n    sort(minus.begin(), minus.end());\n    multimap<double, double> event;\n    {\n      double t = 0.0;\n      FORIT(it, plus) {\n        event.insert(make_pair(t, it->v / it->w));\n        t += fabs(it->w);\n      }\n      event.insert(make_pair(t, 1e-30));\n      t = W;\n      FORIT(it, minus) {\n        event.insert(make_pair(t, -it->v / it->w));\n        t += fabs(it->w);\n      }\n      event.insert(make_pair(t, -1e-30));\n    }\n    double pt = 0.0;\n    double pGrad = 0.0;\n    double mGrad = 0.0;\n    double sum = 0.0;\n    double best = 0.0;\n    FORIT(it, event) {\n      double nt = it->first;\n      sum += (pGrad + mGrad) * (nt - pt);\n      best = max(best, sum);\n      if (it->second > 0) { pGrad = it->second; }\n      if (it->second < 0) { mGrad = it->second; }\n      if (mGrad == -1e-30) { break; }\n      pt = nt;\n    }\n    ans += best;\n    printf(\"%.8lf\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nbool cmp(const pi &a,const pi &b){\n\treturn a.second*b.first>a.first*b.second;\n}\nint n; double W;\nvector<pi> p;\n\nint main(){\n\tcin>>n>>W;\n\tdouble ans=0;\n\trep(i,n){\n\t\tint w,v; cin>>w>>v;\n\t\tif(w<=0&&v>=0)ans+=v, W-=w;\n\t\telse if(v<=0&&w>=0)continue;\n\t\telse if(v>0&&w>0)p.pb(mp(w,v));\n\t\telse{\n\t\t\tp.pb(mp(-w,-v));\n\t\t\tans+=v, W-=w;\n\t\t}\n\t}\n\tsort(all(p),cmp);\n\tfor(int i=0;i<p.size();i++){\n\t\tdouble use=min(1.0,W/p[i].first);\n\t\tW-=use*p[i].first;\n\t\tans+=p[i].second*use;\n\t\tif(W<EPS)break;\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Fractional Knapsack - 2\n// Greedy Method\n// given N number of items and a W weight bag .\n// Each item consists a weight w (-10<=w<=10) and it's corresponding value v(-10<=v<=10) .\n// Fill the bag with this item but not overflow and also maximize the profit .\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nstruct ABC\n{\n    double w , v , u ;\n};\nbool cmp(ABC A,ABC B)\n{\n    return A.u > B.u ;\n}\nvector <ABC> list ;\nint main()\n{\n    int N ;\n    double W ;\n    scanf(\"%d%lf\",&N,&W);\n    double profit = 0.0 ;\n    for(int i=0;i<N;i++)\n    {\n        ABC obj ;\n        scanf(\"%lf%lf\",&obj.w,&obj.v);\n        obj.u = obj.v / obj.w ;\n        if(obj.w>=0&&obj.v<=0) continue ; // Not consider the item .\n        if(obj.w<=0&&obj.v>=0)\n        {\n            W-=obj.w;\n            profit+=obj.v;\n            continue;\n        } // Must take item .\n        if(obj.w<=0&&obj.v<=0)\n        {\n            W-=obj.w;\n            profit+=obj.v;\n            obj.w*=-1.0;\n            obj.v*=-1.0;\n        }\n        list.push_back(obj);\n    }\n    sort(list.begin(),list.end(),cmp);\n\n    for(int i=0;i<list.size()&&W!=0.0;i++)\n    {\n        if(list[i].w<=W)\n        {\n            W-=list[i].w;\n            profit+=list[i].v; // Take the item .\n        }\n        else\n        {\n            profit+=list[i].u*W; // take the item .\n            W=0.0;\n        }\n    }\n    printf(\"%.8lf\\n\",profit);\n    return 0;\n}\n/*\n5 10\n4 20\n5 24\n3 25\n1 10\n2 5\n*/\n/*\nMaximize value is : 64.600000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nstruct node\n{\n    double w , v , u ;\n};\nvector <node> list ;\nbool cmp(node A,node B)\n{\n    return A.u > B.u ;\n}\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int N ;\n    double W ;\n    while(scanf(\"%d%lf\",&N,&W)==2)\n    {\n        list.clear();\n        double ans = 0.0 ;\n        for(int i=0;i<N;i++)\n        {\n            node obj ;\n            scanf(\"%lf%lf\",&obj.w,&obj.v);\n            obj.u = obj.v / obj.w ;\n            if(obj.w<=0&&obj.v>=0) { W-=obj.w; ans+=obj.v; continue ; }\n            if(obj.w>=0&&obj.v<=0) continue ;\n            if(obj.w<=0&&obj.v<=0) { W-=obj.w; ans+=obj.v; obj.w*=-1.0; obj.v*=-1.0; }\n            list.push_back(obj);\n        }\n        sort(list.begin(),list.end(),cmp);\n        for(int i=0;i<list.size();i++)\n        {\n            if(list[i].w<=W)\n            {\n                W-=list[i].w;\n                ans+=list[i].v;\n            }\n            else\n            {\n                ans+=list[i].u*W;\n                W=0.0;\n            }\n        }\n        printf(\"%.8lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\tdouble answer=0;\n\tint N,W;\n\tcin >> N >> W;\n\tdouble w[N], v[N];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> w[i] >> v[i];\n\t\tif(w[i]<=0 && v[i]>=0){\n\t\t\tW-=w[i];\n\t\t\tanswer+=v[i];\n\t\t\tw[i]=0;\n\t\t\tv[i]=0;\n\t\t}else if(w[i]>=0 && v[i]<=0){\n\t\t\tw[i]=0;\n\t\t\tv[i]=0;\n\t\t}\n\t}\n\t\n\n\tpair<double,double> plus[N], minus[N];\t\n\tfor(int i=0; i<N; i++){\n\t\tif(w[i]>0){\n\t\t\tplus[i].first=w[i]/v[i];\n\t\t\tplus[i].second=w[i];\n\t\t\tminus[i].first=0;\n\t\t\tminus[i].second=0;\n\t\t}else if(w[i]<0){\n\t\t\tminus[i].first=w[i]/v[i];\n\t\t\tminus[i].second=w[i];\n\t\t\tplus[i].first=0;\n\t\t\tplus[i].second=0;\n\t\t}\n\t}\n\tsort(plus,plus+N);\n\tsort(minus,minus+N);\n\t\n\tint p=0, m=N-1;\t//plus, minus\n\twhile(p<=N-1 && W-plus[p].second>=0){\n\t\tif(plus[p].first==0){\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tW-=plus[p].second;\n\t\tanswer+=plus[p].second/plus[p].first;\n\t\tp++;\n\t}\n\tif(p==N){\n\t\tcout << fixed << setprecision(6) << answer << endl;\n\t\treturn 0;\n\t}\n\t\n\tanswer+=W/plus[p].first;\n\tplus[p].second-=W;\n\tW=0;\n\tif(plus[p].second==0){\n\t\tp++;\n\t}\n\twhile(p<=N-1 && m>=0){\n\t\tif(minus[m].first<=plus[p].first){break;}\n\t\t\n\t\tif(-minus[m].second>plus[p].second){\n\t\t\tanswer+=plus[p].second/plus[p].first;\n\t\t\tanswer-=plus[p].second/minus[m].first;\n\t\t\tminus[m].second+=plus[p].second;\n\t\t\tp++;\n\t\t}else if(-minus[m].second<plus[p].second){\n\t\t\tanswer-=minus[m].second/plus[p].first;\n\t\t\tanswer+=minus[m].second/minus[m].first;\n\t\t\tplus[p].second+=minus[m].second;\n\t\t\tm--;\n\t\t}else if(-minus[m].second==plus[p].second){\n\t\t\tanswer+=plus[p].second/plus[p].first;\n\t\t\tanswer-=plus[p].second/minus[m].first;\n\t\t\tp++;\n\t\t\tm--;\n\t\t}\n\n\t}\n\tcout << fixed << setprecision(6) << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint main() {\n\tint N,W;\n\tcin >> N >> W;\n\tdouble ans=W;\n\t\n\tint w[N], v[N];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> w[i] >> v[i];\n\t}\n\t\n\tpair<int, int> p[N];\t\t//<v-w, w>\n\tfor(int i=0; i<N; i++){\n\t\tp[i].first=v[i]-w[i];\n\t\tp[i].second=w[i];\n\t\tif(p[i].first>=0 && p[i].second<=0){\n\t\t\tans+=p[i].first;\n\t\t\tW-=p[i].second;\n\t\t\tp[i].first=0;\n\t\t\tp[i].second=0;\n\t\t}\n\t}\n\tsort(p,p+N);\n\tint minus=-1;\n\tif(p[0].first<0){minus=0;}\n\tint cnt=1;\n\tfor(int i=1; i<=N; i++){\n\t\tif(p[i].first<0){\n\t\t\tminus=i;\n\t\t}\n\t\t\n\t\tif(i<N && p[i].first==p[i-1].first){cnt++;}\n\t\telse if(cnt>=2){\n\t\t\tsort(p+i-cnt,p+i,greater<pair<int,int>>());\n\t\t\tcnt=1;\n\t\t}\n\t}\n\t\n\t\n//\tcout << p[0].first << \" \" <<p[0].second<<endl;\n\tint i=N-1;\t\t\t//look from largest v-w\n\twhile(W>0){\n\t\tif(i<0){break;}\n\t\t\n\t\tif(W-p[i].second >= 0){\n\t\t\tans+=p[i].first;\n\t\t\tW-=p[i].second;\n\t\t\ti--;\n\t\t}else{\n\t\t\tif(minus>=0 && p[i].first+p[minus].first>0 ){\n\t\t\t\tif(i>0 && p[i-1].first>0){\n\t\t\t\t\tW-=p[minus].second;\n\t\t\t\t\tans+=p[minus].first;\n\t\t\t\t\tminus--;\n\t\t\t\t}else if(W-p[minus].second <= p[i].second){\n\t\t\t\t\tans+=p[minus].first;\n\t\t\t\t\tans+=p[i].first*(W-p[minus].second)/(double)p[i].second;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tans+=p[i].first;\n\t\t\t\t\tans+=p[minus].first*(W-p[i].second)/(double)p[minus].second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\tans+=p[i].first*W/(double)p[i].second;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n\nint main() {\n    int n,W;\n    cin>>n>>W;\n\n    double ans = 0,weight = 0.0;\n    vector<double> w(n), v(n);\n    rep(i,n) cin>>w[i]>>v[i];\n\n    vector<pair<double,int> > pv;\n    rep(i,n) {\n        if(w[i] >= 0 && v[i] <= 0) continue;\n        if(w[i] <= 0 && v[i] >= 0) {\n            ans += v[i], weight += w[i];\n            continue;\n        }\n\n        if(v[i] >= 0) {\n            ans += v[i], weight += w[i];\n            w[i] *= -1, v[i] *= -1;\n        }\n        pv.push_back(make_pair(v[i]/w[i],i));\n    }\n\n    sort(pv.begin(), pv.end());\n    //reverse(pv.begin(), pv.end());\n\n    rep(i,pv.size()) {\n        if(weight <= W) break;\n        int idx = pv[i].second;\n\n        if(weight+w[idx] >= W) {\n            weight += w[idx];\n            ans += v[idx];\n        }else{\n            ans += v[idx]*(W-weight)/w[idx];\n            weight = W;\n        }\n    }\n\n    printf(\"%.12f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nstruct node\n{\n    double w , v , u ;\n};\nvector <node> list ;\nbool cmp(node A,node B)\n{\n    return A.v / A.w > B.v / B.w ;\n}\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int N ;\n    double W ;\n    while(scanf(\"%d%lf\",&N,&W)==2)\n    {\n        list.clear();\n        double ans = 0.0 ;\n        for(int i=0;i<N;i++)\n        {\n            node obj ;\n            scanf(\"%lf%lf\",&obj.w,&obj.v);\n            obj.u = obj.v / obj.w ;\n            if(obj.w<=0&&obj.v>=0) { W-=obj.w; ans+=obj.v; continue ; }\n            if(obj.w>=0&&obj.v<=0) continue ;\n            if(obj.w<=0&&obj.v<=0) { W-=obj.w; ans+=obj.v; obj.w*=-1.0; obj.v*=-1.0; }\n            list.push_back(obj);\n        }\n        sort(list.begin(),list.end(),cmp);\n        for(int i=0;i<list.size();i++)\n        {\n            if(list[i].w<=W)\n            {\n                W-=list[i].w;\n                ans+=list[i].v;\n            }\n            else\n            {\n                ans+=list[i].u*W;\n                W=0.0;\n            }\n        }\n        printf(\"%.8lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,pair<int,int> > p[110000];\npair<double,pair<int,int> > q[110000];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tint sz=0;\n\tint s2=0;\n\tdouble val=0;\n\tfor(int i=0;i<a;i++){\n\t\tint w,v;\n\t\tscanf(\"%d%d\",&w,&v);\n\t\tif(v>=0&&w<=0){\n\t\t\tval+=v;\n\t\t\tb-=w;\n\t\t}else if(v<=0&&w>=0){\n\t\t\tcontinue;\n\t\t}else if(v>0){\n\t\t\tp[sz++]=make_pair((double)w/v,make_pair(w,v));\n\t\t}else{\n\t\t\tq[s2++]=make_pair((double)w/v,make_pair(w,v));\n\t\t}\n\t}\n\tstd::sort(p,p+sz);\n\tstd::sort(q,q+s2);\n\tint lb=b;\n\tdouble tmp=val;\n\tdouble ret=0;\n\tint at=0;\n\tfor(int i=0;i<=s2;i++){\n\t\twhile(at<sz&&b-p[at].second.first>=0){\n\t\t\tb-=p[at].second.first;\n\t\t\tval+=(double)p[at].second.second;\n\t\t\tat++;\n\t\t}\n\t\tif(at<sz)ret=max(ret,val+(double)p[at].second.second*b/p[at].second.first);\n\t\telse ret=max(ret,val);\n\t\tif(i<s2){\n\t\t\tb-=q[i].second.first;\n\t\t\tval+=q[i].second.second;\n\t\t}\n\t}\n\tat=0;\n\tval=tmp;\n\tb=lb;\n\tfor(int i=0;i<sz;i++){\n\t\tval+=p[i].second.second;\n\t\tb-=p[i].second.first;\n\t\twhile(at<s2&&b-q[at].second.first<0){\n\t\t\tb-=q[at].second.first;\n\t\t\tval+=(double)q[at].second.second;\n\t\t\tat++;\n\t\t}\n\t//\tprintf(\"%f %d %d\\n\",val,b,at);\n\t\tif(at>=s2)break;\n\t\tif(b<0)ret=max(ret,val+(double)b/q[at].second.first*q[at].second.second);\n\t\telse ret=max(ret,val);\n\t}\n\tprintf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nbool cmp(const pair<int,int> &a, const pair<int,int> &b) {\n    return (double)a.second / a.first > (double)b.second / b.first;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    int N, W;\n    cin >> N >> W;\n\n    double ans = 0;\n    double rem = W;\n    vector<pair<int,int> > posv, negv;\n    for(int i = 0; i < N; ++i) {\n        int w, vv;\n        cin >> w >> vv;\n        if(w <= 0 && vv >= 0) {\n            ans += vv;\n            rem -= w;\n        }\n        else if(w >= 0 && vv <= 0) {\n            // through\n        }\n        else {\n            if(vv > 0) posv.push_back(make_pair(w, vv));\n            else negv.push_back(make_pair(-w, -vv));\n        }\n    }\n    sort(posv.begin(), posv.end(), cmp);\n    sort(negv.begin(), negv.end(), cmp);\n    reverse(negv.begin(), negv.end());\n\n    double pr, nr;\n    vector<pair<int,int> >::iterator pi, ni;\n    pi = posv.begin();\n    ni = negv.begin();\n    pr = 0;\n    if(ni != negv.begin()) nr = ni->first;\n\n    while(rem > 0 && pi != posv.end()) {\n        if(rem < pi->first) {\n            ans += pi->second * rem / pi->first;\n            pr = pi->first - rem;\n            rem = 0;\n        }\n        else {\n            ans += pi->second;\n            rem -= pi->first;\n            ++pi;\n        }\n    }\n\n    while(pi != posv.end() && ni != negv.end()) {\n        double amt_w = min(pr, nr);\n\n        double diff = amt_w/pi->first*pi->second - amt_w/ni->first*ni->second;\n        if(diff < 0) break;\n        ans += diff;\n        pr -= amt_w;\n        nr -= amt_w;\n        if(pr < 1e-9) {\n            ++pi;\n            pr = pi->first;\n        }\n        if(nr < 1e-9) {\n            ++ni;\n            nr = ni->first;\n        }\n    }\n\n    cout.precision(4);\n    cout.setf(ios::fixed);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint main() {\n\tint N,W;\n\tcin >> N >> W;\n\tdouble ans=W;\n\t\n\tint w[N], v[N];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> w[i] >> v[i];\n\t}\n\t\n\tint sum=0;\n\tfor(int i=0; i<N; i++){\n\t\tif(w[i]>0)sum+=w[i];\n\t}\n\tif(sum<W){\n\t\tans=0;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tif(v[i]>0)ans+=v[i];\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\t\n\tpair<int, int> p[N];\t\t//<v-w, w>\n\tfor(int i=0; i<N; i++){\n\t\tp[i].first=v[i]-w[i];\n\t\tp[i].second=w[i];\n\t\tif(p[i].first>=0 && p[i].second<=0){\n\t\t\tans+=p[i].first;\n\t\t\tW-=p[i].second;\n\t\t\tp[i].first=0;\n\t\t\tp[i].second=0;\n\t\t}\n\t}\n\tsort(p,p+N);\n\tint minus=-1;\n\tif(p[0].first<0){minus=0;}\n\tint cnt=1;\n\tfor(int i=1; i<=N; i++){\n\t\tif(i<N && p[i].first<0){\n\t\t\tminus=i;\n\t\t}\n\t\t\n\t\tif(i<N && p[i].first==p[i-1].first){cnt++;}\n\t\telse if(cnt>=2){\n\t\t\tsort(p+i-cnt,p+i,greater< pair<int,int> >());\n\t\t\tcnt=1;\n\t\t}\n\t}\n\n\tint i=N-1;\t\t\t//look from largest v-w\n\twhile(W>0){\n\t\tif(i<0){break;}\n\t\t\n\t\tif(W-p[i].second >= 0){\n\t\t\tans+=p[i].first;\n\t\t\tW-=p[i].second;\n\t\t\ti--;\n\t\t}else{\n\t\t\tif(minus>=0 && p[i].first+p[minus].first>0 ){\n\t\t\t\tif(i>0 && p[i-1].first>0){\n\t\t\t\t\tW-=p[minus].second;\n\t\t\t\t\tans+=p[minus].first;\n\t\t\t\t\tminus--;\n\t\t\t\t}else if(W-p[minus].second <= p[i].second){\n\t\t\t\t\tans+=p[minus].first;\n\t\t\t\t\tans+=p[i].first*(W-p[minus].second)/(double)p[i].second;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tans+=p[i].first;\n\t\t\t\t\tans+=p[minus].first*(W-p[i].second)/(double)p[minus].second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\tans+=p[i].first*W/(double)p[i].second;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nbool cmp(const pair<int,int> &a, const pair<int,int> &b) {\n    return (double)a.second / a.first > (double)b.second / b.first;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    int N, W;\n    cin >> N >> W;\n\n    double ans = 0;\n    double rem = W;\n    vector<pair<int,int> > posv, negv;\n    for(int i = 0; i < N; ++i) {\n        int w, vv;\n        cin >> w >> vv;\n        if(w <= 0 && vv >= 0) {\n            ans += vv;\n            rem -= w;\n        }\n        else if(w >= 0 && vv <= 0) {\n            // through\n        }\n        else {\n            if(w > 0) posv.push_back(make_pair(w, vv));\n            else negv.push_back(make_pair(-w, -vv));\n        }\n    }\n    sort(posv.begin(), posv.end(), cmp);\n    sort(negv.begin(), negv.end(), cmp);\n    reverse(negv.begin(), negv.end());\n\n    double pr, nr;\n    vector<pair<int,int> >::iterator pi, ni;\n    pi = posv.begin();\n    ni = negv.begin();\n    pr = 0;\n    if(ni != negv.end()) nr = ni->first;\n\n    while(rem > 0 && pi != posv.end()) {\n        if(rem < pi->first) {\n            ans += pi->second * rem / pi->first;\n            pr = pi->first - rem;\n            rem = 0;\n        }\n        else {\n            ans += pi->second;\n            rem -= pi->first;\n            ++pi;\n        }\n    }\n\n    while(pi != posv.end() && ni != negv.end()) {\n        bool pr_is_min = pr < nr;\n        double amt_w = pr_is_min ? pr : nr;\n\n        double diff = amt_w/pi->first*pi->second - amt_w/ni->first*ni->second;\n        if(diff < 0) break;\n        ans += diff;\n        if(pr_is_min) {\n            ++pi;\n            pr = pi->first;\n            nr -= amt_w;\n        }\n        else {\n            ++ni;\n            nr = ni->first;\n            pr -= amt_w;\n        }\n    }\n\n    cout.precision(4);\n    cout.setf(ios::fixed);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\nusing namespace std;\nlong double w[100000], v[100000], W; int n;\nvector<tuple<long double, long double, long double>>p1, p2;\nlong double solve(vector<tuple<long double, long double, long double>>x, long double t) {\n\tlong double vl = 0;\n\tfor (int i = x.size() - 1; i >= 0; i--) {\n\t\tif (t >= get<2>(x[i])) { t -= get<2>(x[i]); vl += get<1>(x[i]); }\n\t\telse { vl += get<1>(x[i])*t / get<2>(x[i]); t = 0; }\n\t}\n\treturn vl;\n}\nint main() {\n\tcin >> n >> W; long double r = 0, f = 0, e = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i] >> v[i];\n\t\tif (fabs(w[i]) < 1e-14) { r += max(0.0l, v[i]); }\n\t\telse if (w[i] > 0) { p1.push_back(make_tuple(v[i] / w[i], v[i], w[i])); }\n\t\telse if (w[i] < 0) { p2.push_back(make_tuple(-v[i] / w[i], v[i], -w[i])); e += -w[i]; }\n\t}\n\tsort(p1.begin(), p1.end()); sort(p2.begin(), p2.end());\n\tlong double L = 0, R = e, c1, c2;\n\tfor (int i = 0; i < 100; i++) {\n\t\tc1 = (L + L + R) / 3.0l; c2 = (L + R + R) / 3.0l;\n\t\tlong double ret1 = solve(p1, c1 + W) + solve(p2, c1);\n\t\tlong double ret2 = solve(p1, c2 + W) + solve(p2, c2);\n\t\tif (ret1 >= ret2)R = c2;\n\t\telse L = c1;\n\t\tf = max(f, max(ret1, ret2));\n\t}\n\tprintf(\"%.12Lf\\n\", r + f);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\tdouble answer=0;\n\tint N,W;\n\tcin >> N >> W;\n\tdouble w[N], v[N];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> w[i] >> v[i];\n\t\tif(w[i]<=0 && v[i]>=0){\n\t\t\tW-=w[i];\n\t\t\tanswer+=v[i];\n\t\t\tw[i]=0;\n\t\t\tv[i]=0;\n\t\t}else if(w[i]>=0 && v[i]<=0){\n\t\t\tw[i]=0;\n\t\t\tv[i]=0;\n\t\t}\n\t}\n\t\n\n\tpair<double,double> plus[N], minus[N];\t\n\tfor(int i=0; i<N; i++){\n\t\tif(w[i]>0){\n\t\t\tplus[i].first=w[i]/v[i];\n\t\t\tplus[i].second=w[i];\n\t\t\tminus[i].first=0;\n\t\t\tminus[i].second=0;\n\t\t}else if(w[i]<0){\n\t\t\tminus[i].first=w[i]/v[i];\n\t\t\tminus[i].second=w[i];\n\t\t\tplus[i].first=0;\n\t\t\tplus[i].second=0;\n\t\t}\n\t}\n\tsort(plus,plus+N);\n\tsort(minus,minus+N);\n\t\n\tint p=0, m=N-1;\t//plus, minus\n\twhile(p<=N-1 && W-plus[p].second>=0){\n\t\tif(plus[p].first==0){\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tW-=plus[p].second;\n\t\tanswer+=plus[p].second/plus[p].first;\n\t\tp++;\n\t}\n\tif(p==N){\n\t\tcout << answer << endl;\n\t\treturn 0;\n\t}\n\t\n\tanswer+=W/plus[p].first;\n\tplus[p].second-=W;\n\tW=0;\n\tif(plus[p].second==0){\n\t\tp++;\n\t}\n\twhile(p<=N-1 && m>=0){\n\t\tif(minus[m].first<=plus[p].first){break;}\n\t\t\n\t\tif(-minus[m].second>plus[p].second){\n\t\t\tanswer+=plus[p].second/plus[p].first;\n\t\t\tanswer-=plus[p].second/minus[m].first;\n\t\t\tminus[m].second+=plus[p].second;\n\t\t\tp++;\n\t\t}else if(-minus[m].second<plus[p].second){\n\t\t\tanswer-=minus[m].second/plus[p].first;\n\t\t\tanswer+=minus[m].second/minus[m].first;\n\t\t\tplus[p].second+=minus[m].second;\n\t\t\tm--;\n\t\t}else if(-minus[m].second==plus[p].second){\n\t\t\tanswer+=plus[p].second/plus[p].first;\n\t\t\tanswer-=plus[p].second/minus[m].first;\n\t\t\tp++;\n\t\t\tm--;\n\t\t}\n\n\t}\n\tcout << fixed << setprecision(8) << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool comp(const pii &a, const pii &b){\n  return b.first*a.second > a.first*b.second;\n}\n\nint main(){\n  int n,w;\n  cin >> n >> w;\n  double res = 0;\n\n  vector<pii> item;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin >> a >> b;\n    if(a<=0 && b>0)w+=-a, res+=b;\n    else if(a<0 && b<0){\n      w+=-a, res+=b;\n      item.push_back(pii(-a,-b));\n    }else if(a>0 && b>0){\n      item.push_back(pii(a,b));\n    }      \n  }\n  \n  sort(item.begin(),item.end(),comp);\n\n  for(pii p : item){\n    if(w>p.first){\n      w -= p.first; res += p.second;\n    }else{\n      res += (double)w/p.first * p.second;\n      break;\n    }\n  }\n  cout << fixed << setprecision(9) << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 10000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,bool> P;\ntypedef pair<P,P> PP;\n\nint N;\ndouble W;\ndouble w[100000], v[100000];\ndouble ans = 0.0, now;\nstruct Q{\n    double r, w, v;\n    bool operator<( const Q& right) const {\n        return r < right.r;\n    }\n    bool operator>( const Q& right) const {\n        return r > right.r;\n    }\n};\nvector<Q> p, m;\nint ip, im;\n\nint main(){\n    cin >> N >> W;\n    rep(i,N){\n        cin >> w[i] >> v[i];\n        if(w[i] <= 0.0){\n            if(v[i] >= 0.0){\n                W -= w[i];\n                ans += v[i];\n            } else{\n                if(w[i] < 0.0){\n                    Q tmp;\n                    tmp.r = -1.0*v[i]/w[i];\n                    tmp.w = -1*w[i]; tmp.v = -1*v[i];\n                    m.push_back(tmp);\n                }\n            }\n        } else{\n            if(v[i] > 0){\n                Q tmp;\n                tmp.r = v[i]/w[i];\n                tmp.w = w[i]; tmp.v = v[i];\n                p.push_back(tmp);\n            }\n        }\n    }\n    sort(m.begin(),m.end(),greater<Q>());\n    sort(p.begin(),p.end(),greater<Q>());\n    while(ip < p.size()){\n        if(p[ip].w >= W){\n            ans += (W/p[ip].w)*p[ip].v;\n            p[ip].v *= (1.0-W/p[ip].w);\n            p[ip].w -= W;\n            break;\n        } else{\n            ans += p[ip].v;\n            W -= p[ip].w;\n            ip++;\n        }\n    }\n    now = ans;\n    while(ip != p.size() && im != m.size()){\n        if(p[ip].w >= m[im].w){\n            now += p[ip].v*(m[im].w/p[ip].w);\n            now -= m[im].v;\n            p[ip].v *= (1.0-m[im].w/p[ip].w);\n            p[ip].w -= m[im].w;\n            im++;\n        } else{\n            now += p[ip].v;\n            now -= m[im].v*(p[ip].w/m[im].w);\n            m[im].v *= (1.0-p[ip].w/m[im].w);\n            m[im].w -= p[ip].w;\n            ip++;\n        }\n        ans = max(ans,now);\n    }\n    printf(\"%.9f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b > 0 && c < 0){\n\t\t\tcontinue;\n\t\t} else if (b < 0 && c < 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tans += (w - sum) * a[cnt][1] / a[cnt][0];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-7);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        // w<0,v>0\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            // RXgà¿là¸ç·âÂÍA¦ª¢ÔÉqueueÉËÁñÅ¨­\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0){\n                grt.push(pdi(vi[i]/wi[i],i));\n            }\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        // ®SÉæ¾Â\\Å êÎASÄæ¾\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            // SÄæ¾Å«È¢ê,Ü¸æêé¾¯æé\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                // quanÌª¾¯æé\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                // cèSÄðèÄéÌÉKvÈWÌÊ\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    // ¡ñÌ}CiXªÅAd³SÄðÜ©È¦éæ¤ÉÈÁ½çÎAI¹\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)){\n                        // ¡ñèÉüêçê½d³\n                        curGetW+=xi[pp.second]*wi[pp.second];\n                        // ¿lð¡ñÌª¾¯ÁZ\n                        curGetVal+=xi[pp.second]*vi[pp.second];\n                        xi[pp.second]=0;\n                        break;\n                    }\n                    else if(curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        // KvÈÊ¾¯èÉüêé\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        dec.push(pp);\n                        break;\n                    }\n                    else{\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    // ðð½¹È¢ÈçÎA»êÈãæÁÄà³ÊÈÌÅAI¹\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                // ÅãÜÅæêÈ©Á½êARÜÅÆÁ½ªÅl¦é\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}\n\n\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nstruct st{\n  double v,w;\n  bool operator<(const st & a)const{\n    return v < a.v;\n  }\n  bool operator>(const st & a)const{\n    return v > a.v;\n  }\n};\n\ndouble solve(double w,vector<st> & pos,vector<st> & neg){\n  double posx=0;/*ppが指しているものweight*/\n  double negx=1;\n  double ret = 0;\n  int pp = 0,np = 0;\n  while(pp < pos.size() && w > 0){\n    double tx = min(1.0,w/pos[pp].w);\n    ret += pos[pp].v * tx;\n    w -= tx * pos[pp].w;\n    if (w < 1e-10){\n      posx = 1-tx;\n      break;\n    }\n    else pp++;\n  }\n  if (posx < 1e-10)pp++,posx = 1;\n  //cout << \"pp : \" << ret <<\" \"<< posx << endl;\n\n  while(pp < pos.size() && np < neg.size()){\n    /*posxを詰め込むために必要なw。*/\n    double pw = posx * pos[pp].w;\n    /*negxによって、開けることができるw。*/\n    double gw = negx * -neg[np].w;\n    double used = min(pw,gw);\n    double px = used/pos[pp].w;\n    double gx = used/-neg[np].w;\n    if (px * pos[pp].v < gx * -neg[np].v)break;/*これ以上は、負/負のものを使っても価値が増えることはない。*/\n    ret += px * pos[pp].v;\n    ret += gx * neg[np].v;\n\n    posx -= px;\n    negx -= gx;\n\n    if (posx < 1e-10)pp++,posx = 1;\n    if (negx < 1e-10)np++,negx = 1;\n\n  }\n  return ret;\n}\n\nmain(){\n  int n,w;\n  while(cin>>n>>w && n){\n    double ans=0,wlim = w;\n    vector<st> pos,neg;\n    rep(i,n){\n      double tw,tv;\n      cin>>tw>>tv;\n      if (tw <= 0 && tv >= 0){//全部使って良い\n\tans += tv;\n\n      }else if (0 < tw && tv <= 0){//一つも使わない。\n      }else if (tw >= 0 && tv > 0){//\n\tpos.push_back((st){tv,tw});\n      }else if (tw < 0 && tv <= 0){\n\tneg.push_back((st){tv,tw});\n      }\n    }\n    sort(pos.begin(),pos.end());\n    sort(neg.begin(),neg.end(),greater<st>());\n    double tmp = solve(w,pos,neg);\n    //cout << ans << \" \" << tmp << endl;\n    printf(\"%.10lf\\n\",tmp+ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first > (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N, W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] <= 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0) get.push_back(P(w[i], v[i]));\n      else reduce.push_back(P(w[i], v[i]));\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            double p = (reduce[r_idx].first - rest)/reduce[r_idx].first;\n            W = get[i].first;\n            ans += reduce[r_idx].second * (1-p);\n            reduce[r_idx].first *= p;\n            reduce[r_idx].second *= p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else{\n          double p = (double)W/get[i].first;\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct State{\n\tint w, v;\n\tdouble cost;\n\tState(int w_, int v_){\n\t\tw = w_; v = v_; cost = (double)v_ / w_;\n\t}\n\tState(){}\n};\nbool operator<(const State& a, const State& b){\n\treturn a.cost < b.cost;\n}\n\nint main(){\n\tint N, W;\n\tscanf(\"%d %d\", &N, &W);\n\t\n\tdouble weight=0, value=0;\n\tvector<State> a;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tint w_, v_;\n\t\tscanf(\"%d %d\", &w_, &v_);\n\t\tif( w_ <= 0 && v_ >= 0 ){\n\t\t\tweight += w_;\n\t\t\tvalue += v_;\n\t\t\tcontinue;\n\t\t}else if( w_ >= 0 && v_ <= 0 ){\n\t\t\tcontinue;\n\t\t}else if( w_ <= 0 && v_ <= 0 ){\n\t\t\tweight += w_;\n\t\t\tvalue += v_;\n\t\t\tw_ *= -1;\n\t\t\tv_ *= -1;\n\t\t}\n\t\ta.push_back( State(w_, v_) );\n\t}\n\tsort(a.rbegin(), a.rend());\n\tN = a.size();\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tif( weight + a[i].w < W ){\n\t\t\tweight += a[i].w;\n\t\t\tvalue += a[i].v;\n\t\t}else{\n\t\t\tdouble x = (double)(W - weight) / a[i].w;\n\t\t\tweight += a[i].w * x;\n\t\t\tvalue += a[i].v * x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%.8f\\n\", value);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nstruct st{\n  double v,w;\n  bool operator<(const st & a)const{\n    return v < a.v;\n  }\n  bool operator>(const st & a)const{\n    return v > a.v;\n  }\n};\n\ndouble solve(double w,vector<st> & pos,vector<st> & neg){\n  double posx=0;/*ppが指しているものweight*/\n  double negx=1;\n  double ret = 0;\n  int pp = 0,np = 0;\n  while(pp < pos.size() && w > 0){\n    double tx = min(1.0,w/pos[pp].w);\n    ret += pos[pp].v * tx;\n    w -= tx * pos[pp].w;\n    if (w < 1e-10){\n      posx = 1-tx;\n      break;\n    }\n    else pp++;\n  }\n  if (posx < 1e-10)pp++,posx = 1;\n  //cout << \"pp : \" << ret <<\" \"<< posx << endl;\n\n  while(pp < pos.size() && np < neg.size()){\n    /*posxを詰め込むために必要なw。*/\n    double pw = posx * pos[pp].w;\n    /*negxによって、開けることができるw。*/\n    double gw = negx * -neg[np].w;\n    double used = min(pw,gw);\n    double px = used/pos[pp].w;\n    double gx = used/-neg[np].w;\n    if (px * pos[pp].v < gx * -neg[np].v)break;/*これ以上は、負/負のものを使っても価値が増えることはない。*/\n    ret += px * pos[pp].v;\n    ret += gx * neg[np].v;\n\n    posx -= px;\n    negx -= gx;\n\n    if (posx < 1e-10)pp++,posx = 1;\n    if (negx < 1e-10)np++,negx = 1;\n\n  }\n  return ret;\n}\n\nmain(){\n  int n,w;\n  while(cin>>n>>w && n){\n    double ans=0,wlim = w;\n    vector<st> pos,neg;\n    rep(i,n){\n      double tw,tv;\n      cin>>tw>>tv;\n      if (tw <= 0 && tv >= 0){//全部使って良い\n\tw -= tw;\n\tans += tv;\n      }else if (0 < tw && tv <= 0){//一つも使わない。\n      }else if (tw >= 0 && tv > 0){//\n\tpos.push_back((st){tv,tw});\n      }else if (tw < 0 && tv <= 0){\n\tneg.push_back((st){tv,tw});\n      }\n    }\n    sort(pos.begin(),pos.end());\n    sort(neg.begin(),neg.end(),greater<st>());\n    double tmp = solve(w,pos,neg);\n    //cout << ans << \" \" << tmp << endl;\n    printf(\"%.10lf\\n\",tmp+ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool comp(const pii &a, const pii &b){\n  return b.first*a.second > a.first*b.second;\n}\n\nint main(){\n  int n,w;\n  scanf(\"%d%d\",&n,&w);\n  double res = 0;\n\n  vector<pii> item;\n  for(int i=0;i<n;i++){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    if(a<=0 && b>=0)w+=-a, res+=b;\n    else if(a<0 && b<0){\n      w+=-a, res+=b;\n      item.push_back(pii(-a,-b));\n    }else if(a>0 && b>0){\n      item.push_back(pii(a,b));\n    }      \n  }\n  \n  sort(item.begin(),item.end(),comp);\n\n  for(pii p : item){\n    if(w>p.first){\n      w -= p.first; res += p.second;\n    }else{\n      res += (double)w/p.first * p.second;\n      break;\n    }\n  }\n  printf(\"%.9lf\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    if(!EQ(p.first,(1.0/pp.first))&&(p.first<1.0/pp.first)){\n                        break;\n                    }\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)){\n                        curGetW+=xi[pp.second]*wi[pp.second];\n                        curGetVal+=xi[pp.second]*vi[pp.second];\n                        xi[pp.second]=0;\n                        break;\n                    }\n                    else if(curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        dec.push(pp);\n                        break;\n                    }\n                    else{\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\tcout.precision(16);\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w < 0){\n\t\t\t\tif (temp.v >= 0){//w- && v0+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t} else{//w- && v- -> 使用したことにして符号合わせ\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t\tM.push_back(temp);\n\t\t\t\t}\n\t\t\t} else if (temp.v > 0){//w0+ && v+ -> v/w大の順に使用\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t\t//w0+ && v0- -> 必ず不使用(x=0)/無視\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t//w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nconst int SIZE=100000;\nint N,W;\nint w[SIZE],v[SIZE];\n\ndouble f(double x){\n    double ret=W*x;\n    rep(i,N)ret+=max(0.0,v[i]-w[i]*x);\n    return ret;\n}\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&W);\n    rep(i,N)scanf(\"%lld%lld\",&w[i],&v[i]);\n\n    double lb=0,ub=100000;\n    rep(i,100){\n        double m1=(lb*2+ub)/3,m2=(lb+ub*2)/3;\n        if(f(m1)<f(m2))ub=m2;\n        else lb=m1;\n    }\n\n    printf(\"%.20f\\n\",f(lb));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        // w<0,v>0\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            // RXgà¿là¸ç·âÂÍA¦ª¢ÔÉqueueÉËÁñÅ¨­\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        // ®SÉæ¾Â\\Å êÎASÄæ¾\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            // SÄæ¾Å«È¢ê,Ü¸æêé¾¯æé\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                // quanÌª¾¯æé\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                // cèSÄðèÄéÌÉKvÈWÌÊ\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                // decÍ¿lðâ¹È­ÈÁ½çà¤æéÌðâßé\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    // àµ»Ý\n                    if(!EQ(p.first,1.0/pp.second)&&p.first>1.0/pp.second){\n                        break;\n                    }\n                    // ¡ñÌ}CiXªÅAd³SÄðÜ©È¦éæ¤ÉÈÁ½çÎAI¹\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)){\n                        // ¡ñèÉüêçê½d³\n                        curGetW+=xi[pp.second]*wi[pp.second];\n                        // ¿lð¡ñÌª¾¯ÁZ\n                        curGetVal+=xi[pp.second]*vi[pp.second];\n                        xi[pp.second]=0;\n                        break;\n                    }\n                    else if(curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        // KvÈÊ¾¯èÉüêé\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        dec.push(pp);\n                        break;\n                    }\n                    else{\n                        // Ü¾needWæè­È¢öxÌÊµ©È¢\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    // ðð½¹È¢ÈçÎA»êÈãæÁÄà³ÊÈÌÅAI¹\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                // ÅãÜÅæêÈ©Á½êARÜÅÆÁ½ªÅl¦é\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}\n\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool comp(const pii &a, const pii &b){\n  return b.first*a.second > a.first*b.second;\n}\n\nint main(){\n  int n,w;\n  cin >> n >> w;\n  double res = 0;\n\n  vector<pii> item;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin >> a >> b;\n    if(a<=0 && b>=0)w+=-a, res+=b;\n    else if(a<0 && b<0){\n      w+=-a, res+=b;\n      item.push_back(pii(-a,-b));\n    }else if(a>0 && b>0){\n      item.push_back(pii(a,b));\n    }      \n  }\n  \n  sort(item.begin(),item.end(),comp);\n\n  for(pii p : item){\n    if(w>p.first){\n      w -= p.first; res += p.second;\n    }else{\n      res += (double)w/p.first * p.second;\n      break;\n    }\n  }\n  cout << fixed << setprecision(9) << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,W;\n  cin>>N>>W;\n  double cw=0,cv=0;\n  vector<tuple<double,double,double> > p,n;\n  while(N--){\n    long long w,v;\n    cin>>w>>v;\n    if(w*v>0){\n      ((w>0)?p:n).emplace_back(v*1./w,1.*w,1.);\n    }else if(v>=0&&w<=0){\n      cw+=w;\n      cv+=v;\n    }\n  }\n  sort(begin(p),end(p));\n  sort(begin(n),end(n));\n  while(!p.empty()){\n    double vw=get<0>(p.back());\n    double w=get<1>(p.back());\n    double &r=get<2>(p.back());\n    if(cw+w*r<=W){\n      cw+=w*r;\n      cv+=vw*w*r;\n      p.pop_back();\n    }else{\n      double l=(W-cw)/w;\n      cv+=vw*w*l;\n      r-=l;\n      break;\n    }\n  }\n  double m=cv;\n  while(!p.empty()&&!n.empty()){\n    auto &pb=p.back();\n    auto &nb=n.back();\n    double l=min(get<2>(pb)*get<1>(pb),-get<2>(nb)*get<1>(nb));\n    cv+=(get<0>(pb)-get<0>(nb))*l;\n    m=max(m,cv);\n    get<2>(pb)-=l/get<1>(pb);\n    get<2>(nb)-=l/-get<1>(nb);\n    ((get<2>(nb)<get<2>(pb))?n:p).pop_back();\n  }\n  cout<<fixed<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\tcout.precision(8);\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w < 0){\n\t\t\t\tif (temp.v >= 0){//w- && v0+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t} else{//w- && v- -> 使用したことにして符号合わせ\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t\tM.push_back(temp);\n\t\t\t\t}\n\t\t\t} else if (temp.v > 0){//w0+ && v+ -> v/w大の順に使用\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t\t//w0+ && v0- -> 必ず不使用(x=0)/無視\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t////w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n \nsigned main() {\n    int N, W; cin >> N >> W;\n    double ans = 0.0, cap = 0.0;\n    vector< pair<int, int> > items;\n    for(int i=0; i<N; i++) {\n        int w, v; cin >> w >> v;\n        if(w >= 0 and v <= 0) continue;\n        else if(w <= 0 and v >= 0) {\n            cap += w;\n            ans += v;\n        }\n        else if(w <= 0 and v <= 0) {\n            cap += w;\n            ans += v;\n            items.emplace_back(-w, -v);\n        }\n        else {\n            items.emplace_back(w, v);\n        }\n    }\n\n    sort(items.begin(), items.end(), [&](pii A, pii B) {\n            return A.first * B.second < A.second * B.first;\n        });\n\n    for(auto e : items) {\n        double rem = W - cap;\n        int w, v; tie(w, v) = e;\n\n        double ratio = min(1.0, rem / w);\n        ans += ratio * v;\n        cap += ratio * w;\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nstruct Data{\n  double w, v;\n  bool operator < (const Data& d) const {\n    if(w > 0) return v/w < d.v/d.w;\n    return v/w > d.v/d.w;\n  }\n};\n\n\nint N,W;\nvector<Data> group[4];\n\nvoid make(const vector<Data>& v){\n\n  for(int i = 0; i < (int)v.size(); i++){\n    if(v[i].w > 0 && v[i].v > 0) group[0].push_back(v[i]);\n    if(v[i].w >= 0 && v[i].v <= 0) group[1].push_back(v[i]);\n    if(v[i].w <=0 && v[i].v > 0) group[2].push_back(v[i]);\n    if(v[i].w < 0 && v[i].v <= 0) group[3].push_back(v[i]);\n  }\n}\n\n\nvoid solve(){\n  priority_queue<Data> Q1,Q2;\n\n  for(int i = 0; i < (int)group[0].size(); i++) Q1.push(group[0][i]);\n  for(int i = 0; i < (int)group[3].size(); i++) Q2.push(group[3][i]);\n\n  double nowW = 0;\n  double nowV = 0;\n\n  for(int i = 0; i < (int)group[2].size(); i++){\n    nowW += group[2][i].w;\n    nowV += group[2][i].v;\n  }\n\n  while(!Q1.empty()){\n    Data now = Q1.top();\n    if(now.w + nowW <= W){\n      Q1.pop();\n      nowW += now.w;\n      nowV += now.v;\n      continue;\n    }\n    break;\n  }\n  \n  while(!Q1.empty() && !Q2.empty()){\n    // cout << nowW << \" \" << nowV << endl;\n    Data q1 = Q1.top();\n    Data q2 = Q2.top();\n\n    double maxV = 0, thenW = 0;\n    bool pop1 = false, pop2 = false;\n\n    double nexW = q1.w + q2.w;\n    double nexV = q1.v + q2.v;\n    double fra1 = q1.v/q1.w;\n    double fra2 = nexV/nexW;\n\n    //   if(fra1 > fra2) break;\n\n    for(int i = 0; i < 2; i++){\n      double xx = max(0.0,min(1.0, (W-nowW-q1.w*i)/q2.w));\n      double ww = q1.w*i + q2.w*xx;\n      double vv = q1.v*i + q2.v*xx;\n\n    \n      if(nowW + ww > W) continue;\n      // cout <<\"vv \" <<  vv << endl;  \n      //     cout << ww << \" \" << vv << endl;\n      if(maxV < vv){\n        maxV = vv;\n        thenW = ww;\n        pop1 = i==1;\n        pop2 = xx!=0.0;\n      }\n    }\n\n    for(int i = 0; i < 2; i++){\n      double xx = min(1.0,max(0.0, (W-nowW-q2.w*i)/q1.w));\n      double ww = q2.w*i + q1.w*xx;\n      double vv = q2.v*i + q1.v*xx;\n   \n      if(nowW + ww > W) continue;\n\n      // cout <<\"vv \" <<  vv << endl;\n      //     cout << ww << \" \" << vv << endl;\n      if(maxV < vv){\n        maxV = vv;\n        thenW = ww;\n        pop1 = true;\n        pop2 = xx!=0;\n      }\n      \n    }\n\n    //   cout << maxV << \" \" << thenW << endl;\n     if(maxV == 0) break;\n    if(nowW + thenW <= W){\n      if(pop1) Q1.pop();\n      if(pop2) Q2.pop();\n      nowW += thenW;\n      nowV += maxV;\n      continue;\n    }\n    break;\n  }\n  \n  if(!Q1.empty() && !Q2.empty()){\n    Data q1 = Q1.top();\n    Data q2 = Q2.top();\n    \n    Data qa = (Data){q1.w+q2.w, q1.v+q2.v};\n    \n    double remain = W-nowW;\n    nowV += max(q1.v/q1.w, qa.v/qa.w) * remain;\n  }else if(!Q1.empty()){\n    Data q1 = Q1.top();\n    double remain = W-nowW;\n    nowV += q1.v/q1.w * remain;\n  }\n  printf(\"%.5f\\n\",nowV);\n}\n\nint main(){\n\n  cin >> N >> W;\n  vector<Data> V(N);\n  for(int i = 0; i < N; i++) cin >> V[i].w >> V[i].v;\n  make(V);\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,pair<int,int> > p[110000];\npair<double,pair<int,int> > q[110000];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tint sz=0;\n\tint s2=0;\n\tdouble val=0;\n\tfor(int i=0;i<a;i++){\n\t\tint w,v;\n\t\tscanf(\"%d%d\",&w,&v);\n\t\tif(v>=0&&w<=0){\n\t\t\tval+=v;\n\t\t\tb-=w;\n\t\t}else if(v<=0&&w>=0){\n\t\t\tcontinue;\n\t\t}else if(v>0){\n\t\t\tp[sz++]=make_pair((double)w/v,make_pair(w,v));\n\t\t}else{\n\t\t\tq[s2++]=make_pair((double)w/v,make_pair(w,v));\n\t\t}\n\t}\n\tstd::sort(p,p+sz);\n\tstd::sort(q,q+s2);\n\tint lb=b;\n\tdouble tmp=val;\n\tdouble ret=0;\n\tint at=0;\n\tfor(int i=0;i<=s2;i++){\n\t\twhile(at<sz&&b-p[at].second.first>=0){\n\t\t\tb-=p[at].second.first;\n\t\t\tval+=(double)p[at].second.second;\n\t\t\tat++;\n\t\t}\n\t\tif(at<sz)ret=max(ret,val+(double)p[at].second.second*b/p[at].second.first);\n\t\telse ret=max(ret,val);\n\t\tif(i<s2){\n\t\t\tb-=q[i].second.first;\n\t\t\tval+=q[i].second.second;\n\t\t}\n\t}\n\tat=0;\n\tval=tmp;\n\tb=lb;\n\tfor(int i=0;i<sz;i++){\n\t\tval+=p[i].second.second;\n\t\tb-=p[i].second.first;\n\t\twhile(at<s2&&b<0){\n\t\t\tb-=q[at].second.first;\n\t\t\tval+=(double)q[at].second.second;\n\t\t\tat++;\n\t\t}\n\t//\tprintf(\"%f %d %d\\n\",val,b,at);\n\t\tif(at>=s2)break;\n\t\tif(b<0)ret=max(ret,val+(double)b/q[at].second.first*q[at].second.second);\n\t\telse ret=max(ret,val);\n\t}\n\tprintf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#include<random>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld= long double;\n\nint main()\n{\n\tint N;\n\tld W;\n\tcin>>N>>W;\n\tvector<pair<ld,ld>>pluss;\n\tld ans=0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld w,v;cin>>w>>v;\n\t\tif (w > 0) {\n\t\t\tif (v > 0) {\n\t\t\t\tpluss.emplace_back(w, v);\n\t\t\t}\n\t\t\telse if (v <= 0) {\n\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (v >= 0) {\n\t\t\t\tans += v;\n\t\t\t\tW -= w;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (w < 0) {\n\t\t\t\t\tans+=v;\n\t\t\t\t\tW-=w;\n\t\t\t\t\tpluss.emplace_back(-w,-v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort(pluss.begin(), pluss.end(), [](const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\t\treturn l.second/l.first>r.second/r.first;\n\t});\n\n\tld rest(W);\n\tint now(0);\n\twhile (rest > 0&&now!=pluss.size()) {\n\t\tld use=min(pluss[now].first,rest);\n\t\tans+=use/pluss[now].first*pluss[now].second;\n\t\trest-=use;\n\t\tnow++;\n\t}\n\tcout<<setprecision(10)<<fixed<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 10000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,bool> P;\ntypedef pair<P,P> PP;\n\nint N;\ndouble W;\ndouble w[100000], v[100000];\ndouble ans = 0.0, now;\nstruct Q{\n    double r, w, v;\n    bool operator<( const Q& right) const {\n        return r < right.r;\n    }\n    bool operator>( const Q& right) const {\n        return r > right.r;\n    }\n};\npriority_queue<Q> que1, que2;\n\nint main(){\n    cin >> N >> W;\n    rep(i,N){\n        cin >> w[i] >> v[i];\n        if(w[i] <= 0.0){\n            if(v[i] >= 0.0){\n                W -= w[i];\n                ans += v[i];\n            } else{\n                if(w[i] < 0.0){\n                    Q tmp;\n                    tmp.r = -1.0*v[i]/w[i];\n                    tmp.w = w[i]; tmp.v = v[i];\n                    que2.push(tmp);\n                }\n            }\n        } else{\n            if(v[i] > 0){\n                Q tmp;\n                tmp.r = v[i]/w[i];\n                tmp.w = w[i]; tmp.v = v[i];\n                que1.push(tmp);\n            }\n        }\n    }\n    while(!que1.empty()){\n        Q q1 = que1.top();\n        que1.pop();\n        if(que2.empty()){\n            if(W >= q1.w){\n                ans += q1.v;\n                W -= q1.w;\n            } else{\n                ans += (W/q1.w)*q1.v;\n                W = 0.0;\n            }\n            continue;\n        }\n        if(W >= q1.w){\n            ans += q1.v;\n            W -= q1.w;\n            continue;\n        } else{\n            ans += (W/q1.w)*q1.v;\n            q1.v *= (1.0-W/q1.w);\n            q1.w -= W;\n            W = 0.0;\n        }\n        while(!que2.empty()){\n            Q q2 = que2.top(); que2.pop();\n            if(q2.r+q1.r <= 0.0) break;\n            if(q2.w+q1.w <= 0.0){\n                ans += q1.v;\n                ans -= (q1.w/q2.w)*q2.v;\n                q2.v *= (1.0+q1.w/q2.w);\n                q2.w += q1.w;\n                que2.push(q2);\n                break;\n            } else{\n                ans -= (q2.w/q1.w)*q1.v;\n                ans += q2.v;\n                q1.v *= (1.0+q2.w/q1.w);\n                q1.v += q2.w;\n            }\n        }\n    }\n    printf(\"%.9f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nstruct Data{\n  double w, v;\n  bool operator < (const Data& d) const {\n    if(w > 0) return v/w < d.v/d.w;\n    return v/w > d.v/d.w;\n  }\n};\n\n\nint N,W;\nvector<Data> group[4];\n\nvoid make(const vector<Data>& v){\n\n  for(int i = 0; i < (int)v.size(); i++){\n    if(v[i].w > 0 && v[i].v > 0) group[0].push_back(v[i]);\n    if(v[i].w >= 0 && v[i].v <= 0) group[1].push_back(v[i]);\n    if(v[i].w <=0 && v[i].v > 0) group[2].push_back(v[i]);\n    if(v[i].w < 0 && v[i].v <= 0) group[3].push_back(v[i]);\n  }\n}\n\n\nvoid solve(){\n  priority_queue<Data> Q1,Q2;\n\n  for(int i = 0; i < (int)group[0].size(); i++) Q1.push(group[0][i]);\n  for(int i = 0; i < (int)group[3].size(); i++) Q2.push(group[3][i]);\n\n  double nowW = 0;\n  double nowV = 0;\n\n  for(int i = 0; i < (int)group[2].size(); i++){\n    nowW += group[2][i].w;\n    nowV += group[2][i].v;\n  }\n\n  while(!Q1.empty()){\n    Data now = Q1.top();\n    if(now.w + nowW <= W){\n      Q1.pop();\n      nowW += now.w;\n      nowV += now.v;\n      continue;\n    }\n    break;\n  }\n  \n  while(!Q1.empty() && !Q2.empty()){\n    // cout << nowW << \" \" << nowV << endl;\n    Data q1 = Q1.top();\n    Data q2 = Q2.top();\n\n    double maxV = 0, thenW = 0;\n    bool pop1 = false, pop2 = false;\n\n    double nexW = q1.w + q2.w;\n    double nexV = q1.v + q2.v;\n    double fra1 = q1.v/q1.w;\n    double fra2 = nexV/nexW;\n\n    if(fra1 > fra2) break;\n\n    for(int i = 0; i < 2; i++){\n      double ww = q1.w*i + q2.w*max(0.0,min(1.0, (W-nowW-q1.w*i)/q2.w));\n      double vv = q1.v*i + q2.v*max(0.0,min(1.0, (W-nowW-q1.w*i)/q2.w));\n\n    \n      if(nowW + ww > W) continue;\n      // cout <<\"vv \" <<  vv << endl;  \n      //     cout << ww << \" \" << vv << endl;\n      if(maxV < vv){\n        maxV = vv;\n        thenW = ww;\n        pop1 = i==1;\n        pop2 = true;\n      }\n    }\n\n    for(int i = 0; i < 2; i++){\n      double ww = q2.w*i + q1.w*max(0.0, (W-nowW-q2.w*i)/q1.w);\n      double vv = q2.v*i + q1.v*max(0.0, (W-nowW-q2.w*i)/q1.w);\n   \n      if(nowW + ww > W) continue;\n\n      // cout <<\"vv \" <<  vv << endl;\n      //     cout << ww << \" \" << vv << endl;\n      if(maxV < vv){\n        maxV = vv;\n        thenW = ww;\n        pop1 = true;\n        pop2 = i==1;\n      }\n      \n    }\n\n    //   cout << maxV << \" \" << thenW << endl;\n     if(maxV == 0) break;\n    if(nowW + thenW <= W){\n      if(pop1) Q1.pop();\n      if(pop2) Q2.pop();\n      nowW += thenW;\n      nowV += maxV;\n      continue;\n    }\n    break;\n  }\n  \n  if(!Q1.empty() && !Q2.empty()){\n    Data q1 = Q1.top();\n    Data q2 = Q2.top();\n    \n    Data qa = (Data){q1.w+q2.w, q1.v+q2.v};\n    \n    double remain = W-nowW;\n    nowV += max(q1.v/q1.w, qa.v/qa.w) * remain;\n  }else if(!Q1.empty()){\n    Data q1 = Q1.top();\n    double remain = W-nowW;\n    nowV += q1.v/q1.w * remain;\n  }\n  printf(\"%.5f\\n\",nowV);\n}\n\nint main(){\n\n  cin >> N >> W;\n  vector<Data> V(N);\n  for(int i = 0; i < N; i++) cin >> V[i].w >> V[i].v;\n  make(V);\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\n\ndouble w[100000];\ndouble v[100000];\ntypedef pair<double,int> pdi;\ndouble a[100000];\nconst double EPS = 1e-8;\n\nint main() {\n  int N;\n  double W;\n  cin >> N >> W;  \n  \n  vector<pdi> vec1, vec2;\n  double ans = 0;\n  REP(i, N) {\n    cin >> w[i] >> v[i];\n    if (w[i]>0 && v[i]>0) {\n      vec1.push_back(pdi((double)v[i]/w[i], i));\n    } else if (w[i]<0 && v[i]<0) {\n      w[i] = abs(w[i]);\n      v[i] = abs(v[i]);\n      vec2.push_back(pdi((double)v[i]/w[i], i));\n    } else if (w[i]>0 && v[i]<=0) {\n    } else if (w[i]<=0 && v[i]>=0) { \n      ans += v[i];\n      W += abs(w[i]);\n    }\n  }\n  sort(ALL(vec1), greater<pdi>());\n  sort(ALL(vec2));\n  memset(a,0,sizeof(a));\n  int j = 0;\n  for (int i=0; i<vec1.size(); ++i) {\n    int idx = vec1[i].second;\n    if (w[idx]<=W) {\t\t// 1 wariate\n      ans += v[idx];\n      W -= w[idx];\n    } else {\n      ans += v[idx] * W/w[idx];\n      a[idx] = W/w[idx];\n      W = 0;\n      while(a[idx] < 1) {\n      //while(w[idx]>W+EPS) {\n\tif (j >= vec2.size() || vec2[j].first >= vec1[i].first) {\n\t  break;\n\t}\n\tint jdx = vec2[j].second;\n\tdouble hoge = min(w[idx]*(1-a[idx])/w[jdx], 1-a[jdx]);\n\ta[jdx] += hoge;\n\tdouble hoge2 = (w[jdx]*hoge)/w[idx];\n\t//cout << \"hoge = \" << hoge << endl;\n\t//cout << \"hoge2 = \" << hoge2 << endl;\n\ta[idx] += hoge2;\n\tans += v[idx] * hoge2;\n\t//cout << \"ans1 = \" << ans  << endl;\n\tans -= v[jdx] * hoge;\n\t//cout << \"ans2 = \" << ans << endl;\n\tif (a[jdx] > 1-EPS) j++;\n      }\n      //cout << \"!!\" << 1-a[idx] << endl;\n    }\n    //cout << W << \":  \" << ans << endl;\n  }\n  printf(\"%.10f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nstruct st{\n  double v,w;\n  bool operator<(const st & a)const{\n    return v/w < a.v/w;\n  }\n  bool operator>(const st & a)const{\n    return v/w > a.v/w;\n  }\n};\n\ndouble solve(double w,vector<st> & pos,vector<st> & neg){\n  double posx=0;/*ppが指しているものweight*/\n  double negx=1;\n  double ret = 0;\n  int pp = 0,np = 0;\n  while(pp < pos.size() && w > 0){\n    double tx = min(1.0,w/pos[pp].w);\n    ret += pos[pp].v * tx;\n    w -= tx * pos[pp].w;\n    if (w < 1e-10){\n      posx = 1-tx;\n      break;\n    }\n    else pp++;\n  }\n  if (posx < 1e-10)pp++,posx = 1;\n  //cout << \"pp : \" << ret <<\" \"<< posx << endl;\n\n  while(pp < pos.size() && np < neg.size()){\n    /*posxを詰め込むために必要なw。*/\n    double pw = posx * pos[pp].w;\n    /*negxによって、開けることができるw。*/\n    double gw = negx * -neg[np].w;\n    double used = min(pw,gw);\n    double px = used/pos[pp].w;\n    double gx = used/-neg[np].w;\n    if (px * pos[pp].v < gx * -neg[np].v)break;/*これ以上は、負/負のものを使っても価値が増えることはない。*/\n    ret += px * pos[pp].v;\n    ret += gx * neg[np].v;\n\n    posx -= px;\n    negx -= gx;\n\n    if (posx < 1e-10)pp++,posx = 1;\n    if (negx < 1e-10)np++,negx = 1;\n\n  }\n  return ret;\n}\n\nmain(){\n  int n,w;\n  while(cin>>n>>w && n){\n    double ans=0,wlim = w;\n    vector<st> pos,neg;\n    rep(i,n){\n      double tw,tv;\n      cin>>tw>>tv;\n      if (tw <= 0 && tv >= 0){//全部使って良い\n\tw -= tw;\n\tans += tv;\n      }else if (0 < tw && tv <= 0){//一つも使わない。\n      }else if (tw >= 0 && tv > 0){//\n\tpos.push_back((st){tv,tw});\n      }else if (tw < 0 && tv <= 0){\n\tneg.push_back((st){tv,tw});\n      }\n    }\n    sort(pos.begin(),pos.end());\n    sort(neg.begin(),neg.end(),greater<st>());\n    double tmp = solve(w,pos,neg);\n    //cout << ans << \" \" << tmp << endl;\n    printf(\"%.10lf\\n\",tmp+ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tif (*((float*)a) < 0 && *((float*)b) > 0){\n\t\treturn -1;\n\t} else if (*((float*)a) > 0 && *((float*)b) < 0){\n\t\treturn 1;\n\t}\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b >= 0 && c <= 0){\n\t\t\ti--;\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t} else if (b <= 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tans += ((w - sum) / a[cnt][0] > 1 ? 1 : (w - sum) / a[cnt][0]) * a[cnt][1];\n\t}\n\tprintf(\"%.4f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,W;\n  cin>>N>>W;\n  double cw=0,cv=0;\n  vector<tuple<double,double,double> > p,n;\n  while(N--){\n    int w,v;\n    cin>>w>>v;\n    if(w*v>0){\n      ((w>0)?p:n).emplace_back(v*1./w,1.*w,1.);\n    }else if(v>0){\n      cw+=w;\n      cv+=v;\n    }\n  }\n  sort(begin(p),end(p));\n  sort(begin(n),end(n));\n  while(!p.empty()){\n    double vw=get<0>(p.back());\n    double w=get<1>(p.back());\n    double &r=get<2>(p.back());\n    if(cw+w*r<=W){\n      cw+=w*r;\n      cv+=vw*w*r;\n      p.pop_back();\n    }else{\n      double l=(W-cw)/w;\n      cw=W;\n      cv+=vw*w*l;\n      r-=l;\n      break;\n    }\n  }\n  double m=cv;\n  while(!p.empty()&&!n.empty()){\n    auto &pb=p.back();\n    auto &nb=n.back();\n    double l=min(get<2>(pb)*get<1>(pb),-get<2>(nb)*get<1>(nb));\n    cv+=(get<0>(pb)-get<0>(nb))*l;\n    m=max(m,cv);\n    get<2>(pb)-=l/get<1>(pb);\n    get<2>(nb)-=l/-get<1>(nb);\n    ((get<2>(nb)<get<2>(pb))?n:p).pop_back();\n  }\n  cout<<fixed<<m<<endl;\n}\n\n    \n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int n;\n    long long wSum;\n    cin >> n >> wSum;\n\n    double ret = 0.0;\n    multimap<double, pair<int, int> > ms;\n    for(int i=0; i<n; ++i){\n        int w, v;\n        cin >> w >> v;\n        if(w > 0){\n            if(v > 0)\n                ms.insert(make_pair(-v/(double)w, make_pair(w, v)));\n        }else{\n            if(v >= 0){\n                wSum -= w;\n                ret += v;\n            }else{\n                wSum -= w;\n                ret += v;\n                ms.insert(make_pair(-v/(double)w, make_pair(-w, -v)));\n            }\n        }\n    }\n\n    while(!ms.empty()){\n        int w = ms.begin()->second.first;\n        int v = ms.begin()->second.second;\n        ms.erase(ms.begin());\n\n        if(w < wSum){\n            wSum -= w;\n            ret += v;\n        }else{\n            ret += (double)v * wSum / w;\n            wSum = 0;\n        }\n    }\n\n    printf(\"%.10f\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <numeric>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second * q.first != (double)q.second * p.first) return (double)p.second * q.first > (double)q.second * p.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  return !compare(p, q);\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N;\n  ll W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N, 0);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] < 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] > 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0){ assert(v[i] > 0); get.push_back(P(w[i], v[i])); }\n      else { assert(v[i] < 0); reduce.push_back(P(w[i], v[i])); }\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            assert(rest > 0);\n            double use_p = rest/abs(reduce[r_idx].first);\n            assert(abs(W - reduce[r_idx].first * use_p - get[i].first) < 0.001);\n            W = get[i].first;\n            ans += reduce[r_idx].second * use_p;\n            reduce[r_idx].first -= reduce[r_idx].first * use_p;\n            reduce[r_idx].second -= reduce[r_idx].second * use_p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else if(W > 0){\n          double p = (double)W/get[i].first;\n          assert(0 < p && p < 1);\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int n;\n    double wSum;\n    cin >> n >> wSum;\n\n    double ret = 0.0;\n    multimap<double, pair<int, int> > mm;\n    for(int i=0; i<n; ++i){\n        int w, v;\n        cin >> w >> v;\n        if(w > 0){\n            if(v > 0)\n                mm.insert(make_pair(-v/(double)w, make_pair(w, v)));\n        }else{\n            wSum -= w;\n            ret += v;\n            if(v < 0)\n                mm.insert(make_pair(-v/(double)w, make_pair(-w, -v)));\n        }\n    }\n\n    while(!mm.empty()){\n        int w = mm.begin()->second.first;\n        int v = mm.begin()->second.second;\n        mm.erase(mm.begin());\n\n        if(w <= wSum){\n            wSum -= w;\n            ret += v;\n        }else{\n            ret += (double)v * wSum / w;\n            wSum = 0;\n        }\n    }\n\n    printf(\"%.10f\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nstruct node\n{\n    double w , v , u ;\n};\nvector <node> list ;\nbool cmp(node A,node B)\n{\n    return A.v / A.w > B.v / B.w ;\n}\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int N ;\n    double W ;\n    while(scanf(\"%d%lf\",&N,&W)==2)\n    {\n        list.clear();\n        double ans = 0.0 ;\n        for(int i=0;i<N;i++)\n        {\n            node obj ;\n            scanf(\"%lf%lf\",&obj.w,&obj.v);\n            obj.u = obj.v / obj.w ;\n            if(obj.w<=0&&obj.v>=0) { W-=obj.w; ans+=obj.v; continue ; }\n            if(obj.w>=0&&obj.v<=0) continue ;\n            if(obj.w<=0&&obj.v<=0) { W-=obj.w; ans+=obj.v; obj.w*=-1.0; obj.v*=-1.0; }\n            list.push_back(obj);\n        }\n        sort(list.begin(),list.end(),cmp);\n        for(int i=0;i<N;i++)\n        {\n            if(list[i].w<=W)\n            {\n                W-=list[i].w;\n                ans+=list[i].v;\n            }\n            else\n            {\n                ans+=list[i].u*W;\n                W=0.0;\n            }\n        }\n        printf(\"%.8lf\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans=0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b,c;\n\t\tcin >> b >> c;\n\t\tif (b>0 && c < 0){\n\t\t\tcontinue;\n\t\t} else if (b < 0 && c < 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tans += (w - sum) * a[cnt][1] / a[cnt][0];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nbool comp(const pii &a, const pii &b){\n  return b.first*a.second > a.first*b.second;\n}\n\nint main(){\n  int n,w;\n  cin >> n >> w;\n  double res = 0;\n\n  vector<pii> item;\n  for(int i=0;i<n;i++){\n    int a,b;\n    cin >> a >> b;\n    if(a<=0 && b>=0)w+=-a, res+=b;\n    else if(a<0 && b<0){\n      w+=-a, res+=b;\n      item.push_back(pii(-a,-b));\n    }else if(a>0 && b>0){\n      item.push_back(pii(a,b));\n    }      \n  }\n  \n  sort(item.begin(),item.end(),comp);\n\n  for(pii p : item){\n    if(w>p.first){\n      w -= p.first; res += p.second;\n    }else{\n      res += (double)w/p.first * p.second;\n      break;\n    }\n  }\n  cout << fixed << setprecision(9) << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,pair<int,int> > p[110000];\npair<double,pair<int,int> > q[110000];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tint sz=0;\n\tint s2=0;\n\tdouble val=0;\n\tfor(int i=0;i<a;i++){\n\t\tint w,v;\n\t\tscanf(\"%d%d\",&w,&v);\n\t\tif(v>=0&&w<=0){\n\t\t\tval+=v;\n\t\t\tb-=w;\n\t\t}else if(v<=0&&w>=0){\n\t\t\tcontinue;\n\t\t}else if(v>0){\n\t\t\tp[sz++]=make_pair((double)w/v,make_pair(w,v));\n\t\t}else{\n\t\t\tb-=w;\n\t\t\tval+=v;\n\t\t\tp[sz++]=make_pair((double)w/v,make_pair(-w,-v));\n\t\t}\n\t}\n\tstd::sort(p,p+sz);\n\tstd::sort(q,q+s2);\n\tint lb=b;\n\tdouble tmp=val;\n\tdouble ret=0;\n\tint at=0;\n\tfor(int i=0;i<=s2;i++){\n\t\twhile(at<sz&&b-p[at].second.first>=0){\n\t\t\tb-=p[at].second.first;\n\t\t\tval+=(double)p[at].second.second;\n\t\t\tat++;\n\t\t}\n\t\tif(at<sz)ret=max(ret,val+(double)p[at].second.second*b/p[at].second.first);\n\t\telse ret=max(ret,val);\n\t\tif(i<s2){\n\t\t\tb-=q[i].second.first;\n\t\t\tval+=q[i].second.second;\n\t\t}\n\t}\n\tat=0;\n\tval=tmp;\n\tb=lb;\n\tfor(int i=0;i<sz;i++){\n\t\tval+=p[i].second.second;\n\t\tb-=p[i].second.first;\n\t\twhile(at<s2&&b-q[at].second.first<0){\n\t\t\tb-=q[at].second.first;\n\t\t\tval+=(double)q[at].second.second;\n\t\t\tat++;\n\t\t}\n\t//\tprintf(\"%f %d %d\\n\",val,b,at);\n\t\tif(at>=s2)break;\n\t\tif(b<0)ret=max(ret,val+(double)b/q[at].second.first*q[at].second.second);\n\t\telse ret=max(ret,val);\n\t}\n\tprintf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first > (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N;\n  ll W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] < 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] > 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0){ assert(v[i] > 0); get.push_back(P(w[i], v[i])); }\n      else { assert(v[i] < 0); reduce.push_back(P(w[i], v[i])); }\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            assert(rest > 0);\n            double p = (abs(reduce[r_idx].first) - rest)/abs(reduce[r_idx].first);\n            assert(0 < p && p < 1);\n            W = get[i].first;\n            ans += reduce[r_idx].second * (1-p);\n            reduce[r_idx].first *= p;\n            reduce[r_idx].second *= p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else if(W > 0){\n          double p = (double)W/get[i].first;\n          assert(0 < p && p < 1);\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nbool cmp(const pair<int,int> &a, const pair<int,int> &b) {\n    return (double)a.second / a.first > (double)b.second / b.first;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    int N, W;\n    cin >> N >> W;\n\n    double ans = 0;\n    int rem = W;\n    vector<pair<int,int> > posv, negv;\n    for(int i = 0; i < N; ++i) {\n        int w, vv;\n        cin >> w >> vv;\n        if(w <= 0 && vv >= 0) {\n            ans += vv;\n            rem -= w;\n        }\n        else if(w >= 0 && vv <= 0) {\n            // through\n        }\n        else {\n            if(w > 0) posv.push_back(make_pair(w, vv));\n            else negv.push_back(make_pair(-w, -vv));\n        }\n    }\n    sort(posv.begin(), posv.end(), cmp);\n    sort(negv.begin(), negv.end(), cmp);\n    reverse(negv.begin(), negv.end());\n\n    double pr, nr;\n    vector<pair<int,int> >::iterator pi, ni;\n    pi = posv.begin();\n    ni = negv.begin();\n    pr = 0;\n    if(ni != negv.end()) nr = ni->first;\n\n    while(pi != posv.end()) {\n        if(rem < pi->first) {\n            ans += (double)pi->second * rem / pi->first;\n            pr = pi->first - rem;\n            rem = 0;\n            break;\n        }\n        else {\n            ans += pi->second;\n            rem -= pi->first;\n            ++pi;\n        }\n    }\n\n    while(pi != posv.end() && ni != negv.end()) {\n        bool pr_is_min = pr < nr;\n        double amt_w = pr_is_min ? pr : nr;\n\n        double diff = amt_w/pi->first*pi->second - amt_w/ni->first*ni->second;\n        if(diff < 0) break;\n        ans += diff;\n        if(pr_is_min) {\n            ++pi;\n            pr = pi->first;\n            nr -= amt_w;\n        }\n        else {\n            ++ni;\n            nr = ni->first;\n            pr -= amt_w;\n        }\n    }\n\n    cout.precision(4);\n    cout.setf(ios::fixed);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Fractional Knapsack\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Material{\n\tint w, v;\n\tbool operator<(const Material& val)const{ return 1.0*v*val.w < 1.0*val.v*w; };\n};\n\nint main(){\n\tcout.precision(8);\n\tint N, W;\n\tvector<Material> M;\n\tM.reserve(100000);\n\tdouble CurW = 0.0;//現在のW値\n\tdouble Max = 0.0;//求める最大値\n\t//入力\n\tcin >> N >> W;\n\t{\n\t\tMaterial temp;\n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tcin >> temp.w >> temp.v;\n\t\t\tif (temp.w * temp.v <= 0){\n\t\t\t\tif (temp.w < 0){//w- && v+ -> 必ず使用(x=1)\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t}\n\t\t\t\t//w+ && v- -> 必ず不使用(x=0)/無視\n\t\t\t} else{//w,v同符号 -> v/w大の順に使用\n\t\t\t\tif (temp.w <= 0){//w- && v- -> 使用したことにする\n\t\t\t\t\tCurW += temp.w;\n\t\t\t\t\tMax += temp.v;\n\t\t\t\t\ttemp.w *= -1; temp.v *= -1;\n\t\t\t\t}\n\t\t\t\tM.push_back(temp);\n\t\t\t}\n\t\t}\n\t}\n\tsort(M.begin(), M.end());\n\t////w,v同符号 -> v/w大の順に使用\n\tfor (vector<Material>::reverse_iterator it = M.rbegin(); it != M.rend(); ++it){\n\t\tif (CurW + it->w <= W){//W超えない -> x=1.\n\t\t\tCurW += it->w;\n\t\t\tMax += it->v;\n\t\t} else{//W超える1つめ -> x=適正値.break.\n\t\t\tMax += double(W - CurW) / it->w * it->v;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//出力\n\tcout << Max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,W;\n  cin>>N>>W;\n  double cw=0,cv=0;\n  vector<tuple<double,double,double> > p,n;\n  while(N--){\n    int w,v;\n    cin>>w>>v;\n    if(w*v>0){\n      ((w>0)?p:n).emplace_back(v*1./w,1.*w,1.);\n    }else if(v>0){\n      cw+=w;\n      cv+=v;\n    }\n  }\n  sort(begin(p),end(p));\n  sort(begin(n),end(n));\n  while(!p.empty()){\n    double vw=get<0>(p.back());\n    double w=get<1>(p.back());\n    double &r=get<2>(p.back());\n    if(cw+w*r<=W){\n      cw+=w*r;\n      cv+=vw*w*r;\n      p.pop_back();\n    }else{\n      double l=(W-cw)/w;\n      cw=W;\n      cv+=vw*w*l;\n      r-=l;\n      break;\n    }\n  }\n  double m=cv;\n  while(!p.empty()&&!n.empty()){\n    auto &pb=p.back();\n    auto &nb=n.back();\n    double l=min(get<2>(pb)*get<1>(pb),-get<2>(nb)*get<1>(nb));\n    cv+=(get<0>(pb)-get<0>(nb))*l;\n    m=max(m,cv);\n    get<2>(pb)-=l/get<1>(pb);\n    get<2>(nb)-=l/get<1>(nb);\n    ((get<2>(nb)<get<2>(pb))?n:p).pop_back();\n  }\n  cout<<fixed<<m<<endl;\n}\n\n    \n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n\nusing namespace std;\n\nstruct Data{\n  double w, v;\n  bool operator < (const Data& d) const {\n    if(w > 0) return v/w < d.v/d.w;\n    return v/w > d.v/d.w;\n  }\n};\n\n\nint N,W;\nvector<Data> group[4];\n\nvoid make(const vector<Data>& v){\n\n  for(int i = 0; i < (int)v.size(); i++){\n    if(v[i].w > 0 && v[i].v > 0) group[0].push_back(v[i]);\n    if(v[i].w >= 0 && v[i].v <= 0) group[1].push_back(v[i]);\n    if(v[i].w <=0 && v[i].v > 0) group[2].push_back(v[i]);\n    if(v[i].w < 0 && v[i].v <= 0) group[3].push_back(v[i]);\n  }\n}\n\n\nvoid solve(){\n  priority_queue<Data> Q1,Q2;\n\n  for(int i = 0; i < (int)group[0].size(); i++) Q1.push(group[0][i]);\n  for(int i = 0; i < (int)group[3].size(); i++) Q2.push(group[3][i]);\n\n  double nowW = 0;\n  double nowV = 0;\n\n  for(int i = 0; i < (int)group[2].size(); i++){\n    nowW += group[2][i].w;\n    nowV += group[2][i].v;\n  }\n\n  while(!Q1.empty()){\n    Data now = Q1.top();\n    if(now.w + nowW <= W){\n      Q1.pop();\n      nowW += now.w;\n      nowV += now.v;\n      continue;\n    }\n    break;\n  }\n  \n  while(!Q1.empty() && !Q2.empty()){\n    // cout << nowW << \" \" << nowV << endl;\n    Data q1 = Q1.top();\n    Data q2 = Q2.top();\n\n    double maxV = 0, thenW = 0;\n    bool pop1 = false, pop2 = false;\n\n    double nexW = q1.w + q2.w;\n    double nexV = q1.v + q2.v;\n    double fra1 = q1.v/q1.w;\n    double fra2 = nexV/nexW;\n\n    if(fra1 > fra2) break;\n\n    for(int i = 0; i < 2; i++){\n      double xx = max(0.0,min(1.0, (W-nowW-q1.w*i)/q2.w));\n      double ww = q1.w*i + q2.w*xx;\n      double vv = q1.v*i + q2.v*xx;\n\n    \n      if(nowW + ww > W) continue;\n      // cout <<\"vv \" <<  vv << endl;  \n      //     cout << ww << \" \" << vv << endl;\n      if(maxV < vv){\n        maxV = vv;\n        thenW = ww;\n        pop1 = i==1;\n        pop2 = xx!=0.0;\n      }\n    }\n\n    for(int i = 0; i < 2; i++){\n      double xx = min(1.0,max(0.0, (W-nowW-q2.w*i)/q1.w));\n      double ww = q2.w*i + q1.w*xx;\n      double vv = q2.v*i + q1.v*xx;\n   \n      if(nowW + ww > W) continue;\n\n      // cout <<\"vv \" <<  vv << endl;\n      //     cout << ww << \" \" << vv << endl;\n      if(maxV < vv){\n        maxV = vv;\n        thenW = ww;\n        pop1 = true;\n        pop2 = xx!=0;\n      }\n      \n    }\n\n    //   cout << maxV << \" \" << thenW << endl;\n     if(maxV == 0) break;\n    if(nowW + thenW <= W){\n      if(pop1) Q1.pop();\n      if(pop2) Q2.pop();\n      nowW += thenW;\n      nowV += maxV;\n      continue;\n    }\n    break;\n  }\n  \n  if(!Q1.empty() && !Q2.empty()){\n    Data q1 = Q1.top();\n    Data q2 = Q2.top();\n    \n    Data qa = (Data){q1.w+q2.w, q1.v+q2.v};\n    \n    double remain = W-nowW;\n    nowV += max(q1.v/q1.w, qa.v/qa.w) * remain;\n  }else if(!Q1.empty()){\n    Data q1 = Q1.top();\n    double remain = W-nowW;\n    nowV += q1.v/q1.w * remain;\n  }\n  printf(\"%.5f\\n\",nowV);\n}\n\nint main(){\n\n  cin >> N >> W;\n  vector<Data> V(N);\n  for(int i = 0; i < N; i++) cin >> V[i].w >> V[i].v;\n  make(V);\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tif (*((float*)a) < 0 && *((float*)b) > 0){\n\t\treturn -1;\n\t} else if (*((float*)a) > 0 && *((float*)b) < 0){\n\t\treturn 1;\n\t}\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, cnt;\n\tfloat a[100000][2];\n\tdouble ans = 0, sum = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b >= 0 && c <= 0){\n\t\t\ti--;\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t} else if (b <= 0 && c >= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\ti--;\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t} else if (b <= 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = (float)b;\n\t\ta[i][1] = (float)c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tif ((w - sum) / a[cnt][0] > 1){\n\t\t\tans += a[cnt][1];\n\t\t} else{\n\t\t\tdouble tmp = (w - sum) * a[cnt][1];\n\t\t\ttmp /= a[cnt][0];\n\t\t\tans += tmp;\n\t\t}\n\t}\n\tprintf(\"%.4f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    if(!EQ(p.first,(1.0/pp.first))&&(p.first<1.0/pp.first)){\n                        break;\n                    }\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)||curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        if(!EQ(1,xi[pp.second]))dec.push(pp);\n                        break;\n                    }\n                    else{\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}\n\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <ctime>\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <utility>\n#include <complex>\n#include <numeric>\n#include <functional>\n#include <random>\n#include <regex>\n\nusing namespace std;\ntypedef long long ll;\n\n#define ALL(c) (c).begin(),(c).end()\n#define FOR(i,l,r) for(int i=(int)l;i<(int)r;++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORr(i,l,r) for(int i=(int)r-1;i>=(int)l;--i)\n#define REPr(i,n) FORr(i,0,n)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end())\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n\nint main(){\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tcout <<fixed <<setprecision(20);\n\n\tint N;double W;cin >> N >> W;\n\tvector<double> ws(N),vs(N);REP(i,N)cin >> ws[i] >> vs[i];\n\n\n\tdouble res=0;\n\tvector<pair<double,int> > val;\n\tREP(i,N){\n\t\tif(vs[i]>=0 && ws[i]<=0){\n\t\t\tres+=vs[i];W-=ws[i];\n\t\t}\n\t\tif(vs[i]<0 && ws[i]<0){\n\t\t\tval.push_back(make_pair(vs[i]/ws[i],i));\n\t\t\tres-=abs(vs[i]);W+=abs(ws[i]);\n\t\t}\n\t\tif(vs[i]>0 && ws[i]>0){\n\t\t\tval.push_back(make_pair(vs[i]/ws[i],i));\n\t\t}\n\t}\n\n\tsort(ALL(val),greater<pair<double,int> >());\n\tREP(i,val.size()){\n\t\tint ind=val[i].second;\n\t\tdouble use=min(1.0,W/abs(ws[ind]));\n\t\tres+=use*abs(vs[ind]);\n\t\tW-=use*abs(ws[ind]);\n\t}\n\tcout << res << endl;\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint n;\ndouble W;\n\nbool pred(pair<int,int> a, pair<int,int> b){\n    return a.first * b.second > a.second * b.first;\n}\n\nint main(){\n    cin >> n >> W;\n    vector<pair<int,int> > vp;\n    double ret=0;\n    double w,v;\n    for(int i=0;i<n;i++){\n        cin >> w >> v;\n        if(w <= 0 && v >= 0){\n            W -= w;\n            ret += v;\n        }else if(w >=0 && v <= 0){\n            //do nothing\n        }else if(v < 0 && w < 0){\n            W -= w;\n            ret += v;\n            vp.push_back(make_pair(-v,-w));\n        }else{\n            vp.push_back(make_pair(v,w));\n        }\n    }\n    sort(vp.begin(), vp.end(), pred);\n    for(int i=0;i<vp.size();i++){\n        double tmp = min(1.0, W/vp[i].second);\n        ret += vp[i].first * tmp;\n        W -= tmp * vp[i].second;\n        if(W < EPS) break;\n    }\n    printf(\"%.9f\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nstruct st{\n  double v,w;\n  bool operator<(const st & a)const{\n    return v < a.v;\n  }\n  bool operator>(const st & a)const{\n    return v > a.v;\n  }\n};\n\ndouble solve(double w,vector<st> & pos,vector<st> & neg){\n  double posx=0;/*ppが指しているものweight*/\n  double negx=1;\n  double ret = 0;\n  int pp = 0,np = 0;\n  while(pp < pos.size() && w > 0){\n    double tx = min(1.0,w/pos[pp].w);\n    ret += pos[pp].v * tx;\n    w -= tx * pos[pp].w;\n    if (w < 1e-10){\n      posx = 1-tx;\n      break;\n    }\n    else pp++;\n  }\n  if (posx < 1e-10)pp++,posx = 1;\n  //cout << \"pp : \" << ret <<\" \"<< posx << endl;\n\n  while(pp < pos.size() && np < neg.size()){\n    if (pos[pp].v < -neg[np].v)break;/*これ以上は、負/負のものを使っても価値が増えることはない。*/\n    /*posxを詰め込むために必要なw。*/\n    double pw = posx * pos[pp].w;\n    /*negxによって、開けることができるw。*/\n    double gw = negx * -neg[np].w;\n    double used = min(pw,gw);\n    double px = used/pos[pp].w;\n    double gx = used/-neg[np].w;\n    //cout << px <<\" \"<< gx << \" \" << endl;\n    ret += px * pos[pp].v;\n    ret += gx * neg[np].v;\n\n    posx -= px;\n    negx -= gx;\n\n    if (posx < 1e-10)pp++,posx = 1;\n    if (negx < 1e-10)np++,negx = 1;\n\n  }\n  return ret;\n}\n\nmain(){\n  int n,w;\n  while(cin>>n>>w && n){\n    double ans=0,wlim = w;\n    vector<st> pos,neg;\n    rep(i,n){\n      double tw,tv;\n      cin>>tw>>tv;\n      if (tw <= 0 && tv >= 0){//全部使って良い\n\tans += tv;\n\n      }else if (0 < tw && tv <= 0){//一つも使わない。\n      }else if (tw >= 0 && tv > 0){//\n\tpos.push_back((st){tv,tw});\n      }else if (tw < 0 && tv <= 0){\n\tneg.push_back((st){tv,tw});\n      }\n    }\n    sort(pos.begin(),pos.end());\n    sort(neg.begin(),neg.end(),greater<st>());\n    double tmp = solve(w,pos,neg);\n    //cout << ans << \" \" << tmp << endl;\n    printf(\"%.10lf\\n\",tmp+ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct item{\n\tdouble v,x; // ¿l, i¨Ìå«³\n\tbool operator<(const item &a)const{ return v<a.v; }\n\tbool operator>(const item &a)const{ return a<*this; }\n};\n\nint main(){\n\tint n;\n\tdouble cap; scanf(\"%d%lf\",&n,&cap);\n\n\tdouble ans=0;\n\tint n_po=0,n_ne=0;\n\tpriority_queue<item> po;\n\tpriority_queue< item,vector<item>,greater<item> > ne;\n\trep(i,n){\n\t\tint cost,val; scanf(\"%d%d\",&cost,&val);\n\n\t\t// ÌRXgÅ³Ì¿lÌi¨ÍK¸g¤\n\t\tif(cost<=0 && val>=0){\n\t\t\tcap-=cost;\n\t\t\tans+=val;\n\t\t}\n\t\t// ³ÌRXgÅÌ¿lÌi¨ÍgíÈ¢\n\t\telse if(cost>=0 && val<=0);\n\t\t// »êÈOÍg¤©Ç¤©í©çÈ¢ ( RXgð 1 É³K»µÄÖ )\n\t\telse if(cost>=0 && val>=0){\n\t\t\tpo.push((item){(double)val/cost,cost});\n\t\t}\n\t\telse{\n\t\t\tne.push((item){(double)val/cost,cost});\n\t\t}\n\t}\n\n\t// ibvUbNª¢ÁÏ¢ÉÈéÜÅ greedy Élßé\n\twhile(cap>0 && !po.empty()){\n\t\titem a=po.top(); po.pop();\n\t\tif(cap>a.x){\n\t\t\tans+=a.v*a.x;\n\t\t\tcap-=a.x;\n\t\t}\n\t\telse{\n\t\t\tans+=a.v*cap;\n\t\t\ta.x-=cap;\n\t\t\tcap=0;\n\t\t\tpo.push(a);\n\t\t}\n\t}\n\n\t// ne Ìi¨ðüê½Ù¤ªæ¢êÍ»êðüêÄAó¢½ª¾¯ po Ìi¨àüêé\n\twhile(!po.empty() && !ne.empty() && po.top().v>ne.top().v){\n\t\titem a=po.top(); po.pop();\n\t\titem b=ne.top(); ne.pop();\n\t\tif(a.x>-b.x){\n\t\t\tans+=(a.v-b.v)*(-b.x);\n\t\t\ta.x-=-b.x;\n\t\t\tpo.push(a);\n\t\t}\n\t\telse{\n\t\t\tans+=(a.v-b.v)*a.x;\n\t\t\tb.x+=a.x;\n\t\t\tne.push(b);\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first > (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N, W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] <= 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] >= 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0) get.push_back(P(w[i], v[i]));\n      else reduce.push_back(P(w[i], v[i]));\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second <= reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            double p = (abs(reduce[r_idx].first) - rest)/abs(reduce[r_idx].first);\n            W = get[i].first;\n            ans += reduce[r_idx].second * (1-p);\n            reduce[r_idx].first *= p;\n            reduce[r_idx].second *= p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else{\n          double p = (double)W/get[i].first;\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tif (*((float*)a) < 0 && *((float*)b) > 0){\n\t\treturn -1;\n\t} else if (*((float*)a) > 0 && *((float*)b) < 0){\n\t\treturn 1;\n\t}\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans = 0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b, c;\n\t\tcin >> b >> c;\n\t\tif (b >= 0 && c <= 0){\n\t\t\ti--;\n\t\t\tn--;\n\t\t\tcontinue;\n\t\t} else if (b <= 0 && c <= 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt < n){\n\t\tans += ((w - sum) / a[cnt][0] > 1 ? 1 : (w - sum) / a[cnt][0]) * a[cnt][1];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Vect {\n  double w;\n  double v;\n  double t;\n  Vect() {;}\n  Vect(double w, double v, double t) : w(w), v(v), t(t) {;}\n  bool operator<(const Vect &rhs) const {\n    return t > rhs.t;\n  }\n};\n\nint N, W;\nint main() {\n  while (scanf(\"%d %d\", &N, &W) > 0) {\n    double ans = 0.0;\n    vector<Vect> plus;\n    vector<Vect> minus;\n    REP(i, N) {\n      double w, v;\n      scanf(\"%lf %lf\", &w, &v);\n      if (w >= 0 && v <= 0) {\n        continue;\n      } else if (w <= 0 && v >= 0) {\n        ans += v;\n        W -= w;\n      } else if (w > 0 && v > 0) {\n        plus.push_back(Vect(w, v, v / w));\n      } else if (w < 0 && v < 0) {\n        minus.push_back(Vect(w, v, w / v));\n      } else {\n        assert(false);\n      }\n    }\n    sort(plus.begin(), plus.end());\n    sort(minus.begin(), minus.end());\n    multimap<double, double> event;\n    {\n      double t = 0.0;\n      FORIT(it, plus) {\n        event.insert(make_pair(t, it->v / it->w));\n        t += fabs(it->w);\n      }\n      event.insert(make_pair(t, 1e-30));\n      t = W;\n      FORIT(it, minus) {\n        event.insert(make_pair(t, -it->v / it->w));\n        t += fabs(it->w);\n      }\n      event.insert(make_pair(t, -1e-30));\n    }\n    double pt = 0.0;\n    double pGrad = 0.0;\n    double mGrad = 0.0;\n    double sum = 0.0;\n    double best = 0.0;\n    FORIT(it, event) {\n      double nt = it->first;\n      sum += (pGrad + mGrad) * (nt - pt);\n      best = max(best, sum);\n      if (it->second > 0) { pGrad = it->second; }\n      if (it->second < 0) { mGrad = it->second; }\n      if (mGrad == -1e-30) { break; }\n      pt = nt;\n    }\n    ans += best;\n    printf(\"%.8lf\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nint N;\ndouble W;\ndouble wi[100001];\ndouble vi[100001];\ndouble xi[100001];\n\ntypedef pair<double,int> pdi;\n\nvoid solve(){\n    cin>>N>>W;\n    for(int i=0;i<N;i++)cin>>wi[i]>>vi[i];\n    for(int i=0;i<N;i++)xi[i]=1;\n    priority_queue<pdi> grt;\n    priority_queue<pdi> dec;\n    double maxVal=0;\n    for(int i=0;i<N;i++){\n        if((wi[i]<0||EQ(wi[i],0))&&(vi[i]>0||EQ(vi[i],0))){\n            xi[i]=0;\n            maxVal+=vi[i];\n            W+=(-wi[i]);\n        }\n        else if((wi[i]>0||EQ(wi[i],0))&&(vi[i]<0||EQ(vi[i],0)))xi[i]=0;\n        else{\n            if(wi[i]<0&&vi[i]<0){\n                wi[i]*=-1;\n                vi[i]*=-1;\n                dec.push(pdi(wi[i]/vi[i],i));\n            }\n            else if(wi[i]>0&&vi[i]>0)grt.push(pdi(vi[i]/wi[i],i));\n        }\n    }\n    while(grt.size()){\n        pdi p=grt.top();grt.pop();\n        if(wi[p.second]*xi[p.second]<W||EQ(wi[p.second]*xi[p.second],W)){\n            W-=wi[p.second]*xi[p.second];\n            maxVal+=vi[p.second]*xi[p.second];\n            xi[p.second]=0;\n        }\n        else{\n            double quan=W/(wi[p.second]);\n            if(!EQ(quan,0)){\n                maxVal+=vi[p.second]*quan;\n                xi[p.second]-=quan;;\n                grt.push(p);\n                W=0;\n            }\n            else{\n                double needW=xi[p.second]*wi[p.second];\n                double curFullVal=xi[p.second]*vi[p.second];\n                double curGetW=0;\n                double curGetVal=0;\n                while(dec.size()){\n                    pdi pp=dec.top();dec.pop();\n                    if(!EQ(p.first,(1.0/pp.first))&&(p.first<1.0/pp.first))break;\n                    if(EQ(curGetW+wi[pp.second]*xi[pp.second],needW)||curGetW+wi[pp.second]*xi[pp.second]>needW){\n                        double curQuan=(needW-curGetW)/wi[pp.second];\n                        curGetW+=curQuan*wi[pp.second];\n                        curGetVal+=curQuan*vi[pp.second];\n                        xi[pp.second]-=curQuan;\n                        if(!EQ(1,xi[pp.second]))dec.push(pp);\n                        break;\n                    }\n                    else{\n                        curGetW+=wi[pp.second]*xi[pp.second];\n                        curGetVal+=vi[pp.second]*xi[pp.second];\n                    }\n                }\n                if(EQ(curGetW,needW)){\n                    if(EQ(curGetVal,curFullVal)||curGetVal<curFullVal)maxVal+=curFullVal-curGetVal;\n                    else break;\n                }\n                else{\n                    if(curGetVal<curFullVal*(curGetW/needW)||EQ(curGetVal,curFullVal*(curGetW/needW)))\n                        maxVal+=(-curGetVal+curFullVal*(curGetW/needW));\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%.10f\\n\",maxVal);\n}\nint main(){\n    solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\nint comp(const void *a, const void *b)\n{\n\tfloat ans = *((float*)b + 1) / *((float*)b) - *((float*)a + 1) / *((float*)a);\n\tif (ans > 0){\n\t\treturn 1;\n\t} else if (ans == 0){\n\t\treturn 0;\n\t} else{\n\t\treturn -1;\n\t}\n}\n\nint main(){\n\tint n, w, sum = 0, cnt;\n\tfloat a[100000][2], ans=0;\n\n\tcin >> n >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tint b,c;\n\t\tcin >> b >> c;\n\t\tif (b>0 && c < 0){\n\t\t\tcontinue;\n\t\t} else if (b < 0 && c < 0){\n\t\t\tsum += b;\n\t\t\tans += c;\n\t\t\tb *= -1;\n\t\t\tc *= -1;\n\t\t}\n\t\ta[i][0] = b;\n\t\ta[i][1] = c;\n\t}\n\tqsort(a, n, sizeof(float) * 2, comp);\n\tfor (cnt = 0; cnt < n; cnt++){\n\t\tsum += a[cnt][0];\n\t\tif (sum > w){\n\t\t\tsum -= a[cnt][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < cnt; i++){\n\t\tans += a[i][1];\n\t}\n\tif (cnt){\n\t\tans += (w - sum) * a[cnt][1] / a[cnt][0];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nstruct node\n{\n    double w , v , u ;\n};\nvector <node> list ;\nbool cmp(node A,node B)\n{\n    if(A.w==B.w) return A.v > B.v ;\n    return A.w < B.w ;\n}\nint main()\n{\n    //freopen(\"input.txt\",\"r\",stdin);\n    int N ;\n    double W ;\n    while(scanf(\"%d%lf\",&N,&W)==2)\n    {\n        list.clear();\n        for(int i=0;i<N;i++)\n        {\n            node obj ;\n            scanf(\"%lf%lf\",&obj.w,&obj.v);\n            obj.u = obj.v / obj.w ;\n            list.push_back(obj);\n        }\n        sort(list.begin(),list.end(),cmp);\n        double ans = 0.0 , mx =0.0 ;\n        for(int i=0;i<N;i++)\n        {\n            if(list[i].w<0&&list[i].v>=0)\n            {\n                W-=list[i].w;\n                ans+=list[i].v;\n            }\n            if(list[i].w<0&&list[i].v<=0)\n            {\n                W-=list[i].w;\n                ans+=list[i].v;\n            }\n            if(list[i].w>0&&list[i].v<0)\n            {\n                // Do Nothing\n            }\n            if(list[i].w>0&&list[i].v>0)\n            {\n                if(list[i].w<=W)\n                {\n                    W-=list[i].w;\n                    ans+=list[i].v;\n                }\n                else\n                {\n                    ans+=list[i].u*W;\n                    W=0.0;\n                }\n            }\n            mx = max(mx,ans);\n        }\n        printf(\"%.6lf\\n\",mx);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_weight,int arg_value){\n\t\tweight = arg_weight;\n\t\tvalue = arg_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn arg.weight*value > arg.value*weight;\n\t}\n\tint weight,value;\n};\n\nint main(){\n\n\tint N;\n\tdouble W,ans = 0;\n\n\tscanf(\"%d %lf\",&N,&W);\n\n\tvector<Info> V;\n\n\tint weight,value;\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%d %d\",&weight,&value);\n\n\t\tif(weight >= 0 && value <= 0)continue;\n\n\t\tif(weight >= 0 && value >= 0){\n\n\t\t\tV.push_back(Info(weight,value));\n\n\t\t}else if(weight <= 0 && value >= 0){\n\n\t\t\tans += value;\n\t\t\tW -= weight;\n\n\t\t}else if(weight < 0 && value < 0){\n\n\t\t\tans += value;\n\t\t\tW -= weight;\n\t\t\tV.push_back(Info(-weight,-value));\n\t\t}\n\t}\n\tsort(V.begin(),V.end());\n\n\tdouble tmp_x;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\ttmp_x = min(1.0,W/V[i].weight);\n\t\tans += tmp_x*V[i].value;\n\t\tW -= tmp_x*V[i].weight;\n\t\tif(W < EPS)break;\n\t}\n\n\tprintf(\"%.10lf\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,W;\n  cin>>N>>W;\n  double cw=0,cv=0;\n  vector<tuple<double,double,double> > p,n;\n  while(N--){\n    long long w,v;\n    cin>>w>>v;\n    if(w*v>0){\n      ((w>0)?p:n).emplace_back(v*1./w,1.*w,1.);\n    }else if(v>=0&&w<=0){\n      cw+=w;\n      cv+=v;\n    }\n  }\n  sort(begin(p),end(p));\n  sort(n.rbegin(),n.rend());\n  while(!p.empty()){\n    double vw=get<0>(p.back());\n    double w=get<1>(p.back());\n    double &r=get<2>(p.back());\n    if(cw+w*r<=W){\n      cw+=w*r;\n      cv+=vw*w*r;\n      p.pop_back();\n    }else{\n      double l=(W-cw)/w;\n      cv+=vw*w*l;\n      r-=l;\n      break;\n    }\n  }\n  double m=cv;\n  while(!p.empty()&&!n.empty()){\n    auto &pb=p.back();\n    auto &nb=n.back();\n    double l=min(get<2>(pb)*get<1>(pb),-get<2>(nb)*get<1>(nb));\n    cv+=(get<0>(pb)-get<0>(nb))*l;\n    m=max(m,cv);\n    get<2>(pb)-=l/get<1>(pb);\n    get<2>(nb)-=l/-get<1>(nb);\n    ((get<2>(nb)<get<2>(pb))?n:p).pop_back();\n  }\n  cout<<fixed<<m<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, double> P;\nbool compare(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first > (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\nbool compare2(P p, P q){\n  if((double)p.second/p.first != (double)q.second/q.first) return (double)p.second/p.first < (double)q.second/q.first; //rev\n  else return p.first < q.first;\n}\n\nint main(){\n  int N, W;\n  while(cin>>N>>W && N){\n    vector<int> w(N), v(N);\n    REP(i, N) cin>>w[i]>>v[i];\n    vector<bool> used(N);\n    vector<P> get;\n    vector<P> reduce;\n    double ans = 0;\n    REP(i, N){\n      if(w[i] == 0){\n        if(v[i] >= 0) ans += v[i];\n        used[i] = true;\n      }else if(w[i] <= 0 && v[i] >= 0){\n        ans += v[i];\n        W -= w[i];\n        used[i] = true;\n      }else if(w[i] >= 0 && v[i] <= 0){\n        used[i] = true;\n      }\n    }\n    REP(i, N)if(!used[i]){\n      if(w[i] > 0) get.push_back(P(w[i], v[i]));\n      else reduce.push_back(P(w[i], v[i]));\n    }\n    sort(get.begin(), get.end(), compare);\n    sort(reduce.begin(), reduce.end(), compare2);\n    int r_idx = 0;\n    REP(i, get.size()){\n      if(get[i].first <= W){\n        W -= get[i].first;\n        ans += get[i].second;\n      }else{\n        while(r_idx < reduce.size() && get[i].first > W && get[i].first/get[i].second < reduce[r_idx].first/reduce[r_idx].second){\n          if(W - reduce[r_idx].first < get[i].first){\n            W -= reduce[r_idx].first;\n            ans += reduce[r_idx].second;\n            r_idx++;\n          }else{\n            double rest = get[i].first - W;\n            double p = (reduce[r_idx].first - rest)/reduce[r_idx].first;\n            W = get[i].first;\n            ans += reduce[r_idx].second * (1-p);\n            reduce[r_idx].first *= p;\n            reduce[r_idx].second *= p;\n          }\n        }\n        if(get[i].first <= W){\n          W -= get[i].first;\n          ans += get[i].second;\n        }else{\n          double p = (double)W/get[i].first;\n          W = 0;\n          ans += get[i].second * p;\n        }\n      }\n    }\n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<sstream>\n#include<climits>\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define fi first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nconst int MAX_N = 100000;\nint N, W;\ndouble V;\nint w[MAX_N], v[MAX_N];\nvector<pair<double, int> > r;\n\nint main() {\n  cin >> N >> W;\n  rep(i, N) {\n    cin >> w[i] >> v[i];\n    if (w[i] >= 0 && v[i] <= 0) {\n      continue;\n    } else if (w[i] <= 0 && v[i] >= 0) {\n      W -= w[i];\n      V += v[i];\n    } else {\n      if (w[i] < 0 && v[i] < 0) {\n        W -= w[i];\n        V += v[i];\n        w[i] = -w[i];\n        v[i] = -v[i];\n        r.push_back(pair<double, int>((double)v[i]/(double)w[i], i));\n      } else {\n        r.push_back(pair<double, int>((double)v[i]/(double)w[i], i));\n      }\n    }\n  }\n  \n  sort(all(r), greater<pair<double, int> >());\n\n  for (int i = 0; i < (int)r.size(); ++i) {\n    int t = r[i].sc;\n    if (W >= w[t]) {\n      W -= w[t]; V += v[t];\n    } else {\n      V += double((double)W/(double)w[t]*(double)v[t]);\n      break;\n    }\n  }\n\n  printf(\"%.6f\\n\", V);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<tuple>\nusing namespace std;\nlong double w[100000], v[100000], W; int n;\nvector<tuple<long double, long double, long double>>p1, p2;\nlong double solve(vector<tuple<long double, long double, long double>>x, long double t, int q) {\n\tlong double vl = 0;\n\tfor (int i = x.size() - 1; i >= 0; i--) {\n\t\tif (q == 0 && get<0>(x[i]) < 0)break;\n\t\tif (t >= get<2>(x[i])) { t -= get<2>(x[i]); vl += get<1>(x[i]); }\n\t\telse { vl += get<1>(x[i])*t / get<2>(x[i]); t = 0; }\n\t}\n\treturn vl;\n}\nint main() {\n\tcin >> n >> W; long double r = 0, f = 0, e = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i] >> v[i];\n\t\tif (fabs(w[i]) < 1e-14) { r += max(0.0l, v[i]); }\n\t\telse if (w[i] > 0) { p1.push_back(make_tuple(v[i] / w[i], v[i], w[i])); }\n\t\telse if (w[i] < 0) { p2.push_back(make_tuple(-v[i] / w[i], v[i], -w[i])); e += -w[i]; }\n\t}\n\tsort(p1.begin(), p1.end()); sort(p2.begin(), p2.end());\n\tlong double L = 0, R = e, c1, c2;\n\tfor (int i = 0; i < 100; i++) {\n\t\tc1 = (L + L + R) / 3.0l; c2 = (L + R + R) / 3.0l;\n\t\tlong double ret1 = solve(p1, c1 + W, 0) + solve(p2, c1, 1);\n\t\tlong double ret2 = solve(p1, c2 + W, 0) + solve(p2, c2, 1);\n\t\tif (ret1 >= ret2)R = c2;\n\t\telse L = c1;\n\t\tf = max(f, max(ret1, ret2));\n\t}\n\tprintf(\"%.12Lf\\n\", r + f);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, W, w[100009], v[100009], cnt; vector<pair<double, int> > d1, d2;\ndouble solve(double x) {\n\tdouble ret = 0.0, sum1 = 0.0, sum2 = 0.0;\n\tfor (int i = 0; i < d1.size() && d1[i].first > 0.0; i++) {\n\t\tif (sum1 + d1[i].second < W + x) {\n\t\t\tret += d1[i].first * d1[i].second;\n\t\t\tsum1 += d1[i].second;\n\t\t}\n\t\telse {\n\t\t\tret += d1[i].first * (W + x - sum1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < d2.size(); i++) {\n\t\tif (sum2 + d2[i].second < x) {\n\t\t\tret += d2[i].first * d2[i].second;\n\t\t\tsum2 += d2[i].second;\n\t\t}\n\t\telse {\n\t\t\tret += d2[i].first * (x - sum2);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d%d\", &N, &W);\n\tdouble sum = 0.0, sum2 = 0.0;\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d\", &w[i], &v[i]);\n\t\tif (w[i] == 0) sum += max(v[i], 0);\n\t\tif (w[i] > 0) d1.push_back(make_pair(1.0 * v[i] / w[i], w[i]));\n\t\tif (w[i] < 0) d2.push_back(make_pair(-1.0 * v[i] / w[i], -w[i])), sum2 -= w[i];\n\t}\n\tsort(d1.begin(), d1.end(), greater<pair<double, int> >());\n\tsort(d2.begin(), d2.end(), greater<pair<double, int> >());\n\tdouble l = 0.0, r = sum2;\n\tfor (int i = 0; i < 90; i++) {\n\t\tdouble m1 = (l * 2.0 + r) / 3.0;\n\t\tdouble m2 = (l + r * 2.0) / 3.0;\n\t\tif (solve(m1) < solve(m2)) l = m1;\n\t\telse r = m2;\n\t}\n\tprintf(\"%.10lf\\n\", solve(l) + sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n\nint main() {\n    int n,W;\n    cin>>n>>W;\n\n    double ans = 0,weight = 0.0;\n    vector<double> w(n), v(n);\n    rep(i,n) cin>>w[i]>>v[i];\n\n    vector<pair<double,int> > pv;\n    rep(i,n) {\n        if(w[i] >= 0 && v[i] <= 0) continue;\n        if(w[i] <= 0 && v[i] >= 0) {\n            ans += v[i], weight += w[i];\n            continue;\n        }\n\n        if(v[i] >= 0) {\n            ans += v[i], weight += w[i];\n            w[i] *= -1, v[i] *= -1;\n        }\n        pv.push_back(make_pair(v[i]/w[i],i));\n    }\n    sort(pv.begin(), pv.end());\n\n    rep(i,pv.size()) {\n        int idx = pv[i].second;\n\n        if(weight+w[idx] >= W) {\n            weight += w[idx];\n            ans += v[idx];\n        }else{\n            ans += v[idx]*(W-weight)/w[idx];\n            weight = W;\n            break;\n        }\n    }\n\n    printf(\"%.12f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint n;\ndouble W;\n\nbool pred(pair<int,int> a, pair<int,int> b){\n    return a.first * b.second < a.second * a.first;\n}\n\nint main(){\n    cin >> n >> W;\n    vector<pair<int,int> > vp;\n    double ret=0;\n    double w,v;\n    for(int i=0;i<n;i++){\n        cin >> w >> v;\n        if(w <= 0 && v >= 0){\n            W -= w;\n            ret += v;\n        }else if(w >=0 && v <= 0){\n            //do nothing\n        }else if(v < 0 && w < 0){\n            W -= w;\n            ret += v;\n            vp.push_back(make_pair(-v,-w));\n        }else{\n            vp.push_back(make_pair(v,w));\n        }\n    }\n    sort(vp.begin(), vp.end(), pred);\n    for(int i=0;i<vp.size();i++){\n        double tmp = min(1.0, W/vp[i].second);\n        ret += vp[i].first * tmp;\n        W -= tmp * vp[i].second;\n        if(W < EPS) break;\n    }\n    printf(\"%.9f\\n\", ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint main() {\n\tint N,W;\n\tcin >> N >> W;\n\tdouble ans=W;\n\t\n\tint w[N], v[N];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> w[i] >> v[i];\n\t}\n\t\n\tpair<int, int> p[N];\t\t//<v-w, w>\n\tfor(int i=0; i<N; i++){\n\t\tp[i].first=v[i]-w[i];\n\t\tp[i].second=w[i];\n\t\tif(p[i].first>=0 && p[i].second<=0){\n\t\t\tans+=p[i].first;\n\t\t\tW-=p[i].second;\n\t\t\tp[i].first=0;\n\t\t\tp[i].second=0;\n\t\t}\n\t}\n\tsort(p,p+N);\n\tint minus=-1;\n\tif(p[0].first<0){minus=0;}\n\tint cnt=1;\n\tfor(int i=1; i<=N; i++){\n\t\tif(i<N && p[i].first<0){\n\t\t\tminus=i;\n\t\t}\n\t\t\n\t\tif(i<N && p[i].first==p[i-1].first){cnt++;}\n\t\telse if(cnt>=2){\n\t\t\tsort(p+i-cnt,p+i,greater< pair<int,int> >());\n\t\t\tcnt=1;\n\t\t}\n\t}\n\n\tint i=N-1;\t\t\t//look from largest v-w\n\twhile(W>0){\n\t\tif(i<0){break;}\n\t\t\n\t\tif(W-p[i].second >= 0){\n\t\t\tans+=p[i].first;\n\t\t\tW-=p[i].second;\n\t\t\ti--;\n\t\t}else{\n\t\t\tif(minus>=0 && p[i].first+p[minus].first>0 ){\n\t\t\t\tif(i>0 && p[i-1].first>0){\n\t\t\t\t\tW-=p[minus].second;\n\t\t\t\t\tans+=p[minus].first;\n\t\t\t\t\tminus--;\n\t\t\t\t}else if(W-p[minus].second <= p[i].second){\n\t\t\t\t\tans+=p[minus].first;\n\t\t\t\t\tans+=p[i].first*(W-p[minus].second)/(double)p[i].second;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tans+=p[i].first;\n\t\t\t\t\tans+=p[minus].first*(W-p[i].second)/(double)p[minus].second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\tans+=p[i].first*W/(double)p[i].second;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int N;\n  double W;\n  cin >> N >> W;\n  double sw = 0, sv = 0;\n  priority_queue<pair<double,pair<double,double>>> pq;\n  for(int i = 0; i < N; ++i){\n    int w, v;\n    cin >> w >> v;\n    if(w < 0){\n      sw += w;\n      sv += v;\n      w *= -1;\n      v *= -1;\n    }\n    if(v > 0){\n      if(w == 0) sv += v;\n      else pq.push({(double)v/w,{w,v}});\n    }\n  }\n  //cerr << sw << \" \" << sv << endl;\n  while(W-sw > 1e-9 and not pq.empty()){\n    auto p = pq.top();\n    double w = p.second.first, v = p.second.second;\n    pq.pop();\n    double x;\n    if(abs(w) > 1e-9) x = min(1.,(W-sw)/w);\n    else x = 1.;\n    sw += x*w;\n    sv += x*v;\n  }\n  printf(\"%.12f\\n\",sv);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int N,W;\n  cin>>N>>W;\n  double cw=0,cv=0;\n  vector<tuple<double,double,double> > p,n;\n  while(N--){\n    int w,v;\n    cin>>w>>v;\n    if(w*v>0){\n      ((w>0)?p:n).emplace_back(v*1./w,1.*w,1.);\n    }else if(v>0){\n      cw+=w;\n      cv+=v;\n    }\n  }\n  sort(begin(p),end(p));\n  sort(begin(n),end(n));\n  while(!p.empty()){\n    double vw=get<0>(p.back());\n    double w=get<1>(p.back());\n    double &r=get<2>(p.back());\n    if(cw+w*r<=W){\n      cw+=w*r;\n      cv+=vw*w*r;\n      p.pop_back();\n    }else{\n      double l=(W-cw)/w;\n      cw=W;\n      cv+=vw*w*l;\n      r-=l;\n      break;\n    }\n  }\n  double m=cv;\n  while(!p.empty()&&!n.empty()){\n    auto &pb=p.back();\n    auto &nb=n.back();\n    double l=min(get<2>(pb)*get<1>(pb),-get<2>(nb)*get<1>(nb));\n    cv+=(get<0>(pb)-get<0>(nb))*l;\n    m=max(m,cv);\n    get<2>(pb)-=l/get<1>(pb);\n    get<2>(nb)-=l/get<1>(nb);\n    ((get<2>(nb)<get<2>(pb))?n:p).pop_back();\n  }\n  cout<<fixed<<m<<endl;\n}\n\n    \n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct item{\n  int value, weight;\n};\n\nint main(){\n\n  int N, W;\n  cin >> N >> W;\n\n  vector<item> plus_item, minus_item;\n\n  int weight_sum = 0, value_sum = 0;\n  \n  for(int i = 0; i < N; i++){\n    int w, v;\n    cin >> w >> v;\n\n    if(w >= 0 && v <= 0)\n      continue;\n\n    if(w <= 0 && v >= 0){\n      weight_sum += w;\n      value_sum += v;\n      continue;\n    }\n\n    if(w >= 0){\n      item itm;\n      itm.weight = w;\n      itm.value = v;\n      plus_item.push_back(itm);\n    }else{\n      item itm;\n      itm.weight = -w;\n      itm.value = -v;\n      minus_item.push_back(itm);\n    }\n  }\n\n  sort(plus_item.begin(), plus_item.end(), [] (const item &i1, const item &i2) {\n      return i1.value * i2.weight > i1.weight * i2.value;});\n\n  sort(minus_item.begin(), minus_item.end(), [] (const item &i1, const item &i2) {\n      return i1.value * i2.weight < i1.weight * i2.value;});\n\n  int plus_item_size = plus_item.size();\n  int minus_item_size = minus_item.size();\n  double ans;\n  int i;\n  for(i = 0; i < plus_item_size; i++){\n    \n    if(weight_sum + plus_item[i].weight > W)\n      break;\n    \n    weight_sum += plus_item[i].weight;\n    value_sum += plus_item[i].value;\n    if(i == plus_item_size - 1){\n      cout << weight_sum << endl;\n      return 0;\n    }\n    \n  }\n\n  ans = (double)value_sum + (double)plus_item[i].value * (double)(W - weight_sum) / (double)plus_item[i].weight;\n\n  \n  for(int k = 0; k < minus_item_size; k++){\n    value_sum -= minus_item[k].value;\n    weight_sum -= minus_item[k].weight;\n\n    while(i < plus_item_size && weight_sum + plus_item[i].weight <= W){\n      weight_sum += plus_item[i].weight;\n      value_sum += plus_item[i].value;\n      i++;\n    }\n\n    if(i == plus_item_size){\n      ans = max(ans, (double)value_sum);\n      break;\n    }\n\n    ans = max(ans, (double)value_sum + (double)plus_item[i].value * (double)(W - weight_sum) / (double)plus_item[i].weight);\n    \n  }\n\n  cout << ans << endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\nusing namespace std;\n\nint main() {\n\tdouble answer=0;\n\tint N,W;\n\tcin >> N >> W;\n\tdouble w[N], v[N];\n\tfor(int i=0; i<N; i++){\n\t\tcin >> w[i] >> v[i];\n\t\tif(w[i]<=0 && v[i]>=0){\n\t\t\tW-=w[i];\n\t\t\tanswer+=v[i];\n\t\t\tw[i]=0;\n\t\t\tv[i]=0;\n\t\t}else if(w[i]>=0 && v[i]<=0){\n\t\t\tw[i]=0;\n\t\t\tv[i]=0;\n\t\t}\n\t}\n\t\n\n\tpair<double,double> plus[N], minus[N];\t\n\tfor(int i=0; i<N; i++){\n\t\tif(w[i]>0){\n\t\t\tplus[i].first=w[i]/v[i];\n\t\t\tplus[i].second=w[i];\n\t\t\tminus[i].first=0;\n\t\t\tminus[i].second=0;\n\t\t}else if(w[i]<0){\n\t\t\tminus[i].first=w[i]/v[i];\n\t\t\tminus[i].second=w[i];\n\t\t\tplus[i].first=0;\n\t\t\tplus[i].second=0;\n\t\t}\n\t}\n\tsort(plus,plus+N);\n\tsort(minus,minus+N);\n\t\n\tint p=0, m=N-1;\t//plus, minus\n\twhile(p<=N-1 && W-plus[p].second>=0){\n\t\tif(plus[p].first==0){\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tW-=plus[p].second;\n\t\tanswer+=plus[p].second/plus[p].first;\n\t\tp++;\n\t}\n\tif(p==N){\n\t\tcout << answer << endl;\n\t\treturn 0;\n\t}\n\t\n\tanswer+=W/plus[p].first;\n\tplus[p].second-=W;\n\tW=0;\n\tif(plus[p].second==0){\n\t\tp++;\n\t}\n\twhile(p<=N-1 && m>=0){\n\t\tif(minus[m].first<=plus[p].first){break;}\n\t\t\n\t\tif(-minus[m].second>plus[p].second){\n\t\t\tanswer+=plus[p].second/plus[p].first;\n\t\t\tanswer-=plus[p].second/minus[m].first;\n\t\t\tminus[m].second+=plus[p].second;\n\t\t\tp++;\n\t\t}else if(-minus[m].second<plus[p].second){\n\t\t\tanswer-=minus[m].second/plus[p].first;\n\t\t\tanswer+=minus[m].second/minus[m].first;\n\t\t\tplus[p].second+=minus[m].second;\n\t\t\tm--;\n\t\t}else if(-minus[m].second==plus[p].second){\n\t\t\tanswer+=plus[p].second/plus[p].first;\n\t\t\tanswer-=plus[p].second/minus[m].first;\n\t\t\tp++;\n\t\t\tm--;\n\t\t}\n\n\t}\n\tcout << fixed << setprecision(6) << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nstruct st{\n  double v,w;\n  bool operator<(const st & a)const{\n    return v/w < a.v/a.w;\n  }\n  bool operator>(const st & a)const{\n    return v/w > a.v/a.w;\n  }\n};\n\ndouble solve(double w,vector<st> & pos,vector<st> & neg){\n  double posx=0;/*ppが指しているものweight*/\n  double negx=1;\n  double ret = 0;\n  int pp = 0,np = 0;\n  while(pp < pos.size() && w > 0){\n    double tx = min(1.0,w/pos[pp].w);\n    ret += pos[pp].v * tx;\n    w -= tx * pos[pp].w;\n    if (w < 1e-10){\n      posx = 1-tx;\n      break;\n    }\n    else pp++;\n  }\n  if (posx < 1e-10)pp++,posx = 1;\n  //cout << \"pp : \" << ret <<\" \"<< posx << endl;\n\n  while(pp < pos.size() && np < neg.size()){\n    /*posxを詰め込むために必要なw。*/\n    double pw = posx * pos[pp].w;\n    /*negxによって、開けることができるw。*/\n    double gw = negx * -neg[np].w;\n    double used = min(pw,gw);\n    double px = used/pos[pp].w;\n    double gx = used/-neg[np].w;\n    if (px * pos[pp].v < gx * -neg[np].v)break;/*これ以上は、負/負のものを使っても価値が増えることはない。*/\n    ret += px * pos[pp].v;\n    ret += gx * neg[np].v;\n\n    posx -= px;\n    negx -= gx;\n\n    if (posx < 1e-10)pp++,posx = 1;\n    if (negx < 1e-10)np++,negx = 1;\n  }\n  return ret;\n}\n\nmain(){\n  int n,w;\n  while(cin>>n>>w && n){\n    double ans=0,wlim = w;\n    vector<st> pos,neg;\n    rep(i,n){\n      double tw,tv;\n      cin>>tw>>tv;\n      if (tw <= 0 && tv >= 0){//全部使って良い\n\tw -= tw;\n\tans += tv;\n      }else if (0 < tw && tv <= 0){//一つも使わない。\n      }else if (tw >= 0 && tv > 0){//\n\tpos.push_back((st){tv,tw});\n      }else if (tw < 0 && tv <= 0){\n\tneg.push_back((st){tv,tw});\n      }\n    }\n    sort(pos.begin(),pos.end(),greater<st>());\n    sort(neg.begin(),neg.end());\n    //rep(i,pos.size())cout << pos[i].w <<\" \" << pos[i].v << endl;\n    double tmp = solve(w,pos,neg);\n    printf(\"%.10lf\\n\",tmp+ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nbool cmp(const pi &a,const pi &b){\n\treturn a.second*b.first>a.first*b.second;\n}\nint n; double W;\nvector<pi> p;\n\nint main(){\n\tcin>>n>>W;\n\tdouble ans=0;\n\trep(i,n){\n\t\tint w,v; cin>>w>>v;\n\t\tif(w<=0&&v>=0)ans+=v, W-=w;\n\t\telse if(v<=0&&w>=0)continue;\n\t\telse if(v>0&&w>0)p.pb(mp(w,v));\n\t\telse{\n\t\t\tp.pb(mp(-w,-v));\n\t\t\tans+=v, W-=w;\n\t\t}\n\t}\n\tsort(all(p),cmp);\n\tfor(int i=0;i<p.size();i++){\n\t\tdouble use=min(1.0,W/p[i].first);\n\t\tW-=use*p[i].first;\n\t\tans+=p[i].second*use;\n\t\tif(W<EPS)break;\n\t}\n\tprintf(\"%.12f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nbool cmp(const pair<int,int> &a, const pair<int,int> &b) {\n    return (double)a.second / a.first > (double)b.second / b.first;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n\n    int N, W;\n    cin >> N >> W;\n\n    double ans = 0;\n    double rem = W;\n    vector<pair<int,int> > posv, negv;\n    for(int i = 0; i < N; ++i) {\n        int w, vv;\n        cin >> w >> vv;\n        if(w <= 0 && vv >= 0) {\n            ans += vv;\n            rem -= w;\n        }\n        else if(w >= 0 && vv <= 0) {\n            // through\n        }\n        else {\n            if(w > 0) posv.push_back(make_pair(w, vv));\n            else negv.push_back(make_pair(-w, -vv));\n        }\n    }\n    sort(posv.begin(), posv.end(), cmp);\n    sort(negv.begin(), negv.end(), cmp);\n    reverse(negv.begin(), negv.end());\n\n    double pr, nr;\n    vector<pair<int,int> >::iterator pi, ni;\n    pi = posv.begin();\n    ni = negv.begin();\n    pr = 0;\n    if(ni != negv.begin()) nr = ni->first;\n\n    while(rem > 0 && pi != posv.end()) {\n        if(rem < pi->first) {\n            ans += pi->second * rem / pi->first;\n            pr = pi->first - rem;\n            rem = 0;\n        }\n        else {\n            ans += pi->second;\n            rem -= pi->first;\n            ++pi;\n        }\n    }\n\n    while(pi != posv.end() && ni != negv.end()) {\n        double amt_w = min(pr, nr);\n\n        double diff = amt_w/pi->first*pi->second - amt_w/ni->first*ni->second;\n        if(diff < 0) break;\n        ans += diff;\n        pr -= amt_w;\n        nr -= amt_w;\n        if(pr < 1e-13) {\n            ++pi;\n            pr = pi->first;\n        }\n        if(nr < 1e-13) {\n            ++ni;\n            nr = ni->first;\n        }\n    }\n\n    cout.precision(4);\n    cout.setf(ios::fixed);\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2354 Fractional Knapsack\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// library\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') {\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n// library\n\n#define ZERO(a)  (fabs(a)<1e-7)\n\ntypedef struct { int w, v; double r; } T;\nT tbl[100002]; int sz;\n\nint cmp(T *a, T *b) { if (fabs(b->r - a->r)<1e-8) return 0; if (a->r <= b->r) return 1; return -1; }\n\nint main()\n{\n\tint N, i, w, v;\n\tdouble W, x, ans;\n\n\tN = in(), W = in();\n\tsz = 0, ans = 0;\n\twhile (N--) {\n\t\tw = in(), v = in();\n\t\tif (w > 0 && v < 0) continue;\n\t\tif (w <= 0 && v >= 0) ans += v, W -= w;\n\t\telse {\n\t\t\tif ( w < 0) w = -w, v = -v, ans -= v, W += w; \n\t\t\ttbl[sz].w = w, tbl[sz].v = v, tbl[sz++].r = (double)v/w;\n\t\t} \n\t}\n\tqsort(tbl, sz, sizeof(T), cmp);\n\n\tfor (i = 0; i < sz && !ZERO(W); i++) {\n\t\tx = W/tbl[i].w;\tif (x > 1) x = 1;\n\t\tW -= x*tbl[i].w, ans += x*tbl[i].v;\n\t}\n\tprintf(\"%lf\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint n;\ndouble W;\n\nbool pred(pair<int,int> a, pair<int,int> b){\n    return a.first * b.second < a.second * a.first;\n}\n\nint main(){\n    cin >> n >> W;\n    vector<pair<int,int> > vp;\n    double ret=0;\n    double w,v;\n    for(int i=0;i<n;i++){\n        cin >> w >> v;\n        if(w <= 0 && v >= 0){\n            W += w;\n            ret += v;\n        }else if(w >=0 && v <= 0){\n            //do nothing\n        }else if(v < 0 && w < 0){\n            W -= w;\n            ret += v;\n            vp.push_back(make_pair(-v,-w));\n        }else{\n            vp.push_back(make_pair(v,w));\n        }\n    }\n    sort(vp.begin(), vp.end(), pred);\n    for(int i=0;i<vp.size();i++){\n        if(W - vp[i].second >= EPS){\n            ret += vp[i].first;\n            W -=vp[i].second;\n        }else{\n            ret += vp[i].first * (W / vp[i].second);\n            break;\n        }\n    }\n    printf(\"%.9f\\n\", ret);\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define EPS 1e-9\n\nusing namespace std;\n\nint n;\ndouble W;\n\nbool pred(pair<int,int> a, pair<int,int> b){\n    return a.first * b.second < a.second * a.first;\n}\n\nint main(){\n    cin >> n >> W;\n    vector<pair<int,int> > vp;\n    double ret=0;\n    double w,v;\n    for(int i=0;i<n;i++){\n        cin >> w >> v;\n        if(w <= 0 && v >= 0){\n            W -= w;\n            ret += v;\n        }else if(w >=0 && v <= 0){\n            //do nothing\n        }else if(v < 0 && w < 0){\n            W -= w;\n            ret += v;\n            vp.push_back(make_pair(-v,-w));\n        }else{\n            vp.push_back(make_pair(v,w));\n        }\n    }\n    sort(vp.begin(), vp.end(), pred);\n    for(int i=0;i<vp.size();i++){\n        double tmp = min(1.0, W/vp[i].second);\n        ret += vp[i].first * tmp;\n        W -= tmp * vp[i].second;\n        if(W < EPS) break;\n    }\n    printf(\"%.9f\\n\", ret);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2354 Fractional Knapsack\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// library\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') {\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n// library\n\n#define ZERO(a)  (fabs(a)<1e-7)\n\ntypedef struct { int w, v; double r; } T;\nT tbl[100002]; int sz;\n\nint cmp(T *a, T *b) { if (fabs(b->r - a->r)<1e-8) return 0; if (a->r <= b->r) return 1; return -1; }\n\nint main()\n{\n\tint N, i, w, v;\n\tdouble W, x, ans;\n\n\tN = in(), W = in();\n\tsz = 0, ans = 0;\n\twhile (N--) {\n\t\tw = in(), v = in();\n\t\tif (w > 0 && v < 0) continue;\n\t\tif (w <= 0 && v >= 0) ans += v, W -= w;\n\t\telse {\n\t\t\tif ( w < 0) w = -w, v = -v, ans -= v, W += w; \n\t\t\ttbl[sz].w = -w, tbl[sz].v = -v, tbl[sz++].r = (double)v/w;\n\t\t} \n\t}\n\tqsort(tbl, sz, sizeof(T), cmp);\n\n\tfor (i = 0; i < sz && !ZERO(W); i++) {\n\t\tx = W/tbl[i].w;\tif (x > 1) x = 1;\n\t\tW -= x*tbl[i].w, ans += x*tbl[i].v;\n\t}\n\tprintf(\"%lf\\n\", ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2354 Fractional Knapsack\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// library\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') {\tc = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n// library\n\n#define ZERO(a)  (fabs(a)<1e-7)\n\ntypedef struct { int w, v; double r; } T;\nT tbl[100002]; int sz;\n\nint cmp(T *a, T *b) { if (fabs(b->r - a->r)<1e-8) return 0; if (a->r <= b->r) return 1; return -1; }\n\nint main()\n{\n\tint N, i, w, v;\n\tdouble W, x, ans;\n\n\tN = in(), W = in();\n\tsz = 0, ans = 0;\n\twhile (N--) {\n\t\tw = in(), v = in();\n\t\tif (w >= 0 && v <= 0) continue;\n\t\tif (w < 0 && v > 0) ans += v, W -= w;\n\t\telse {\n\t\t\tif ( w < 0) w = -w, v = -v, ans -= v, W += w; \n\t\t\ttbl[sz].w = w, tbl[sz].v = v, tbl[sz++].r = (double)v/w;\n\t\t} \n\t}\n\tqsort(tbl, sz, sizeof(T), cmp);\n\n\tfor (i = 0; i < sz && !ZERO(W); i++) {\n\t\tx = W/tbl[i].w;\tif (x > 1) x = 1;\n\t\tW -= x*tbl[i].w, ans += x*tbl[i].v;\n\t}\n\tprintf(\"%lf\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint w, v;\n\t\t\n\t\tpublic Pair(int w, int v) {\n\t\t\tsuper();\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.w * o.v - this.v - o.w;\n\t\t}\n\t}\n\t\n    public static void main(String[] args){\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \tfinal int W = sc.nextInt();\n    \t\n    \tPriorityQueue<Pair> queue = new PriorityQueue<Main.Pair>(); \n    \t\n    \tdouble cur_w = 0, cur_v = 0;\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tint w = sc.nextInt();\n    \t\tint v = sc.nextInt();\n    \t\t\n    \t\tif(w >= 0 && v <= 0){\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v >= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v <= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\t\n    \t\t\tw = -w;\n    \t\t\tv = -v;\n    \t\t}\n    \t\t\n    \t\tqueue.add(new Pair(w, v));\n    \t}\n    \t\n    \t\n    \twhile(!queue.isEmpty()){\n    \t\tPair p = queue.poll();\n    \t\t\n    \t\tfinal double rest = W - cur_w;\n    \t\tfinal double x = Math.max(0, Math.min(1, rest / p.w));\n    \t\t\n    \t\t//System.out.println(cur_w + \" \"+ rest + \" \"+ p.v + \" \" + p.w + \" \" + x);\n    \t\t\n    \t\tcur_w += x * p.w;\n    \t\tcur_v += x * p.v;\n    \t}\n    \t\n    \tSystem.out.printf(\"%f\\n\", cur_v);\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint w, v;\n\t\t\n\t\tpublic Pair(int w, int v) {\n\t\t\tsuper();\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tfinal double this_f = (double)(this.v) / this.w;\n\t\t\tfinal double o_f = (double)(o.v) / o.w;\n\t\t\t\n\t\t\treturn Double.compare(o_f, this_f);\n\t\t}\n\t}\n\t\n    public static void main(String[] args){\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \tfinal int W = sc.nextInt();\n    \t\n    \tPriorityQueue<Pair> queue = new PriorityQueue<Main.Pair>(); \n    \t\n    \tdouble cur_w = 0, cur_v = 0;\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tint w = sc.nextInt();\n    \t\tint v = sc.nextInt();\n    \t\t\n    \t\tif(w >= 0 && v <= 0){\n    \t\t\tcontinue;\n    \t\t}else if(w < 0 && v >= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\tcontinue;\n    \t\t}else if(w < 0 && v < 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\t\n    \t\t\tw = -w;\n    \t\t\tv = -v;\n    \t\t}\n    \t\t\n    \t\tqueue.add(new Pair(w, v));\n    \t}\n    \t\n    \t\n    \twhile(!queue.isEmpty()){\n    \t\tPair p = queue.poll();\n    \t\t\n    \t\tfinal double rest = W - cur_w;\n    \t\tfinal double x = Math.max(0, Math.min(1, rest / p.w));\n    \t\t\n    \t\t//System.out.println(cur_w + \" \"+ rest + \" \"+ p.v + \" \" + p.w + \" \" + x);\n    \t\t\n    \t\tcur_w += x * p.w;\n    \t\tcur_v += x * p.v;\n    \t}\n    \t\n    \tSystem.out.println(cur_v);\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tdouble W = io.nextInt();\n\t\tdouble V = 0;\n\t\tArrayList<Pair> al = new ArrayList<Pair>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint w = io.nextInt();\n\t\t\tint v = io.nextInt();\n\t\t\tif (w <= 0 && v > 0) {\n\t\t\t\tW -= w;\n\t\t\t\tV += v;\n\t\t\t}else if(w < 0 && v < 0) {\n\t\t\t\tW -= w;\n\t\t\t\tV += v;\n\t\t\t\tal.add(new Pair(-w, -v));\n\t\t\t}else if(w > 0 && v > 0) {\n\t\t\t\tal.add(new Pair(w, v));\n\t\t\t}\n\t\t}\n\t\tCollections.sort(al,new Comparator<Pair>() {\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn - Double.compare((double) o1.v / o1.w, (double) o2.v / o2.w) ;\n\t\t\t}\n\t\t});\n\t\tfor(Pair p:al) {\n\t\t\tdouble m = Math.min(1, W / p.w);\n\t\t\tV += m * p.v;\n\t\t\tW -= m * p.w;\n\t\t\tif (W < 1E-10) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(V);\n\t}\n\n\tstatic class Pair {\n\t\tint w,v;\n\t\tpublic Pair(int w,int v) {\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\t}\n\n}\nclass IO {\n\tprivate final InputStream in;\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\tprivate void skipNewLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++;}\n\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\tpublic boolean hasNextLine() { skipNewLine(); return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tchar[] s = new char[len];\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] arrayInt(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] arrayLong(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] arrayDouble(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void arrayInt(int[]... a) {for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] matrixInt(int n,int m) { int[][] a = new int[n][m]; for(int i=0;i<n;i++) a[i] = arrayInt(m); return a;}\n\tpublic char[][] charMap(int n,int m) { char[][] a = new char[n][m]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void println(long x) { out.println(x);}\n\tpublic void println(double x) { out.println(x);}\n\tpublic void println(String s) { out.println(s);}\n\tpublic void println() { out.println(); }\n\tpublic void print(long x) { out.print(x); }\n\tpublic void print(double x) { out.print(x); }\n\tpublic void print(String s) { out.print(s); }\n\tpublic void print(char c) {out.print(c);}\n\tpublic void flush() {out.flush(); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint w, v;\n\t\t\n\t\tpublic Pair(int w, int v) {\n\t\t\tsuper();\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.w * o.v - this.v * o.w;\n\t\t}\n\t}\n\t\n    public static void main(String[] args){\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \tfinal int W = sc.nextInt();\n    \t\n    \tPriorityQueue<Pair> queue = new PriorityQueue<Main.Pair>(); \n    \t\n    \tdouble cur_w = 0, cur_v = 0;\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tint w = sc.nextInt();\n    \t\tint v = sc.nextInt();\n    \t\t\n    \t\tif(w >= 0 && v <= 0){\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v >= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v <= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\t\n    \t\t\tw = -w;\n    \t\t\tv = -v;\n    \t\t}\n    \t\t\n    \t\tqueue.add(new Pair(w, v));\n    \t}\n    \t\n    \t\n    \twhile(!queue.isEmpty()){\n    \t\tPair p = queue.poll();\n    \t\t\n    \t\tfinal double rest = W - cur_w;\n    \t\tfinal double x = Math.max(0, Math.min(1, rest / p.w));\n    \t\t\n    \t\t//System.out.println(cur_w + \" \"+ rest + \" \"+ p.v + \" \" + p.w + \" \" + x);\n    \t\t\n    \t\tcur_w += x * p.w;\n    \t\tcur_v += x * p.v;\n    \t}\n    \t\n    \tSystem.out.printf(\"%f\\n\", cur_v);\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tdouble W = io.nextInt();\n\t\tdouble V = 0;\n\t\tArrayList<Pair> al = new ArrayList<Pair>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint w = io.nextInt();\n\t\t\tint v = io.nextInt();\n\t\t\tif (w <= 0 && v >= 0) {\n\t\t\t\tW -= w;\n\t\t\t\tV += v;\n\t\t\t}else if(w < 0 && v < 0) {\n\t\t\t\tW -= w;\n\t\t\t\tV += v;\n\t\t\t\tal.add(new Pair(-w, -v));\n\t\t\t}else if(w > 0 && v > 0) {\n\t\t\t\tal.add(new Pair(w, v));\n\t\t\t}\n\t\t}\n\t\tCollections.sort(al,new Comparator<Pair>() {\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn - Double.compare((double) o1.v / o1.w, (double) o2.v / o2.w) ;\n\t\t\t}\n\t\t});\n\t\tfor(Pair p:al) {\n\t\t\tdouble m = Math.min(1, W / p.w);\n\t\t\tV += m * p.v;\n\t\t\tW -= m * p.w;\n\t\t\tif (W < 1E-10) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(new DecimalFormat(\"0.00000\").format(V));\n\t}\n\n\tstatic class Pair {\n\t\tint w,v;\n\t\tpublic Pair(int w,int v) {\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\t}\n\n}\nclass IO {\n\tprivate final InputStream in;\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\tprivate void skipNewLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++;}\n\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\tpublic boolean hasNextLine() { skipNewLine(); return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tchar[] s = new char[len];\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] arrayInt(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] arrayLong(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] arrayDouble(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void arrayInt(int[]... a) {for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] matrixInt(int n,int m) { int[][] a = new int[n][m]; for(int i=0;i<n;i++) a[i] = arrayInt(m); return a;}\n\tpublic char[][] charMap(int n,int m) { char[][] a = new char[n][m]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void println(long x) { out.println(x);}\n\tpublic void println(double x) { out.println(x);}\n\tpublic void println(String s) { out.println(s);}\n\tpublic void println() { out.println(); }\n\tpublic void print(long x) { out.print(x); }\n\tpublic void print(double x) { out.print(x); }\n\tpublic void print(String s) { out.print(s); }\n\tpublic void print(char c) {out.print(c);}\n\tpublic void flush() {out.flush(); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint w, v;\n\t\t\n\t\tpublic Pair(int w, int v) {\n\t\t\tsuper();\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tfinal double this_f = (double)(this.v) / this.w;\n\t\t\tfinal double o_f = (double)(o.v) / o.w;\n\t\t\t\n\t\t\treturn Double.compare(o_f, this_f);\n\t\t}\n\t}\n\t\n    public static void main(String[] args){\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \tfinal int W = sc.nextInt();\n    \t\n    \tPriorityQueue<Pair> queue = new PriorityQueue<Main.Pair>(); \n    \t\n    \tdouble cur_w = 0, cur_v = 0;\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tint w = sc.nextInt();\n    \t\tint v = sc.nextInt();\n    \t\t\n    \t\tif(w >= 0 && v <= 0){\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v >= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v <= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\t\n    \t\t\tw = -w;\n    \t\t\tv = -v;\n    \t\t}\n    \t\t\n    \t\tqueue.add(new Pair(w, v));\n    \t}\n    \t\n    \t\n    \twhile(!queue.isEmpty()){\n    \t\tPair p = queue.poll();\n    \t\t\n    \t\tfinal double rest = W - cur_w;\n    \t\tfinal double x = Math.max(0, Math.min(1, rest / p.w));\n    \t\t\n    \t\t//System.out.println(cur_w + \" \"+ rest + \" \"+ p.v + \" \" + p.w + \" \" + x);\n    \t\t\n    \t\tcur_w += x * p.w;\n    \t\tcur_v += x * p.v;\n    \t}\n    \t\n    \tSystem.out.println(cur_v);\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tdouble W = sc.nextInt();\n\t\tint[] w = new int[N];\n\t\tint[] v = new int[N];\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tw[i] = Integer.parseInt(sc.next());\n\t\t\tv[i] = Integer.parseInt(sc.next());\n\t\t\tif (w[i] <= 0 && v[i] >= 0) {\n\t\t\t\tans += v[i];\n\t\t\t\tW -= w[i];\n\t\t\t}\n\t\t}\n\t\tArrayList<Product> add = new ArrayList<Product>();\n\t\tArrayList<Product> sub = new ArrayList<Product>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (w[i] > 0 && v[i] > 0) {\n\t\t\t\tadd.add(new Product(w[i], v[i]));\n\t\t\t} else if (w[i] < 0 && v[i] < 0) {\n\t\t\t\tsub.add(new Product(w[i], v[i]));\n\t\t\t}\n\t\t}\n\t\tCollections.sort(add);\n\t\tCollections.sort(sub);\n\t\tint addI = add.size() - 1;\n\t\tdouble addX = 1.0;\n\t\tint subI = 0;\n\t\tdouble subX = 1.0;\n\t\twhile (addI >= 0) {\n//\t\t\tSystem.out.println(W + \" \" + ans + \" \" + addI + \" \" + addX + \" \" + subI + \" \" + subX);\n\t\t\tdouble needW = add.get(addI).w * addX;\n\t\t\tif (W == 0) {\n\t\t\t\tif (subI >= sub.size() || add.get(addI).e() < sub.get(subI).e()) break;\n\t\t\t\tdouble feedW = Math.abs(sub.get(subI).w) * subX;\n\t\t\t\tif (feedW < needW) {\n\t\t\t\t\tW += feedW;\n\t\t\t\t\tans += sub.get(subI).v * subX;\n\t\t\t\t\t++subI;\n\t\t\t\t\tsubX = 1.0;\n\t\t\t\t} else {\n\t\t\t\t\tdouble difX = needW / Math.abs(sub.get(subI).w);\n\t\t\t\t\tW = needW;\n\t\t\t\t\tans += sub.get(subI).v * difX;\n\t\t\t\t\tsubX -= difX;\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"  \" + W + \" \" + ans + \" \" + addI + \" \" + addX + \" \" + subI + \" \" + subX);\n\t\t\t}\n\t\t\tif (needW > W) {\n\t\t\t\tans += add.get(addI).e() * W;\n\t\t\t\taddX -= W / add.get(addI).w;\n\t\t\t\tW = 0;\n\t\t\t} else {\n\t\t\t\tans += add.get(addI).e() * needW;\n\t\t\t\tW -= needW;\n\t\t\t\t--addI;\n\t\t\t\taddX = 1.0;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(new BigDecimal(ans).toPlainString());\n\t}\n\n\tstatic class Product implements Comparable<Product> {\n\t\tint w, v;\n\n\t\tProduct(int w, int v) {\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tdouble e() {\n\t\t\treturn 1.0 * this.v / this.w;\n\t\t}\n\n\t\tpublic int compareTo(Product o) {\n\t\t\treturn this.v * o.w - this.w * o.v;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n \n \npublic class Main{\n\t\n\tpublic static class Pair implements Comparable<Pair>{\n\t\tint w, v;\n\t\t\n\t\tpublic Pair(int w, int v) {\n\t\t\tsuper();\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tfinal double this_f = (double)(this.v) / this.w;\n\t\t\tfinal double o_f = (double)(o.v) / o.w;\n\t\t\t\n\t\t\tif(this.w < 0 && o.w < 0){\n\t\t\t\treturn -Double.compare(o_f, this_f);\n\t\t\t}else if(this.w < 0){\n\t\t\t\treturn -Double.compare(o_f, this_f);\n\t\t\t}else if(o.w < 0){\n\t\t\t\treturn -Double.compare(o_f, this_f);\n\t\t\t}else{\n\t\t\t\treturn Double.compare(o_f, this_f);\n\t\t\t}\n\t\t}\n\t}\n\t\n    public static void main(String[] args){\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \tfinal int N = sc.nextInt();\n    \tfinal int W = sc.nextInt();\n    \t\n    \tPriorityQueue<Pair> queue = new PriorityQueue<Main.Pair>(); \n    \t\n    \tdouble cur_w = 0, cur_v = 0;\n    \t\n    \tfor(int i = 0; i < N; i++){\n    \t\tint w = sc.nextInt();\n    \t\tint v = sc.nextInt();\n    \t\t\n    \t\tif(w >= 0 && v <= 0){\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v >= 0){\n    \t\t\tcur_w -= w;\n    \t\t\tcur_v += v;\n    \t\t\tcontinue;\n    \t\t}else if(w <= 0 && v <= 0){\n    \t\t\tcur_w += w;\n    \t\t\tcur_v += v;\n    \t\t\t\n    \t\t\tw = -w;\n    \t\t\tv = -v;\n    \t\t}\n    \t\t\n    \t\tqueue.add(new Pair(w, v));\n    \t}\n    \t\n    \t\n    \twhile(!queue.isEmpty()){\n    \t\tPair p = queue.poll();\n    \t\t\n    \t\tfinal double rest = W - cur_w;\n    \t\tfinal double x = Math.max(0, Math.min(1, Math.abs((rest / p.w))));\n    \t\t\n    \t\t//System.out.println(cur_w + \" \"+ rest + \" \"+ p.v + \" \" + p.w + \" \" + x);\n    \t\t\n    \t\tcur_w += x * p.w;\n    \t\tcur_v += x * p.v;\n    \t}\n    \t\n    \tSystem.out.println(cur_v);\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tdouble W = io.nextInt();\n\t\tdouble V = 0;\n\t\tArrayList<Pair> al = new ArrayList<Pair>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint w = io.nextInt();\n\t\t\tint v = io.nextInt();\n\t\t\tif (w <= 0 && v >= 0) {\n\t\t\t\tW -= w;\n\t\t\t\tV += v;\n\t\t\t}else if(w < 0 && v < 0) {\n\t\t\t\tW -= w;\n\t\t\t\tV += v;\n\t\t\t\tal.add(new Pair(-w, -v));\n\t\t\t}else if(w > 0 && v > 0) {\n\t\t\t\tal.add(new Pair(w, v));\n\t\t\t}\n\t\t}\n\t\tCollections.sort(al,new Comparator<Pair>() {\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\treturn - Double.compare((double) o1.v / o1.w, (double) o2.v / o2.w) ;\n\t\t\t}\n\t\t});\n\t\tfor(Pair p:al) {\n\t\t\tdouble m = Math.min(1, W / p.w);\n\t\t\tV += m * p.v;\n\t\t\tW -= m * p.w;\n\t\t\tif (W < 1E-10) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(V);\n\t}\n\n\tstatic class Pair {\n\t\tint w,v;\n\t\tpublic Pair(int w,int v) {\n\t\t\tthis.w = w;\n\t\t\tthis.v = v;\n\t\t}\n\t}\n\n}\nclass IO {\n\tprivate final InputStream in;\n\tprivate final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tprivate void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\tprivate void skipNewLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++;}\n\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\tpublic boolean hasNextLine() { skipNewLine(); return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tchar[] s = new char[len];\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] arrayInt(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] arrayLong(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] arrayDouble(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void arrayInt(int[]... a) {for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] matrixInt(int n,int m) { int[][] a = new int[n][m]; for(int i=0;i<n;i++) a[i] = arrayInt(m); return a;}\n\tpublic char[][] charMap(int n,int m) { char[][] a = new char[n][m]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void println(long x) { out.println(x);}\n\tpublic void println(double x) { out.println(x);}\n\tpublic void println(String s) { out.println(s);}\n\tpublic void println() { out.println(); }\n\tpublic void print(long x) { out.print(x); }\n\tpublic void print(double x) { out.print(x); }\n\tpublic void print(String s) { out.print(s); }\n\tpublic void print(char c) {out.print(c);}\n\tpublic void flush() {out.flush(); }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range;\n\nint N, W;\nint[] ws, vs;\n\nvoid main(){\n\tinit;\n\twritefln(\"%.5f\", solve);\n}\n\nvoid init(){\n\tscanf(\"%d%d\", &N, &W);\n\tforeach(i; 0..N){\n\t\tint w, v;\n\t\tscanf(\"%d%d\", &w, &v);\n\t\tws ~= w;\n\t\tvs ~= v;\n\t}\n}\n\ndouble solve(){\n\tint[] nws, nvs;\n\tdouble V = 0;\n\tforeach(w, v; zip(ws, vs)){\n\t\tif(w <= 0 && v >= 0){\n\t\t\tW -= w;\n\t\t\tV += v;\n\t\t}\n\t\telse if(w > 0 && v > 0){\n\t\t\tnws ~= w;\n\t\t\tnvs ~= v;\n\t\t}\n\t\telse if(w < 0 && v < 0){\n\t\t\tW -= w;\n\t\t\tV += v;\n\t\t\tnws ~= -w;\n\t\t\tnvs ~= -v;\n\t\t}\n\t}\n\tsort!\"a[0]*b[1] > a[1]*b[0]\"(zip(nvs, nws));\n\n\tforeach(w, v; zip(nws, nvs)){\n\t\tif(W >= w){\n\t\t\tW -= w;\n\t\t\tV += v;\n\t\t}\n\t\telse{\n\t\t\tV += cast(double)W / w * v;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn V;\n}"
  },
  {
    "language": "Python",
    "code": "import heapq\nN, W = [int(n) for n in input().split()]\ntmpw = 0\ntmpv = 0\nminheap = []\nfor i in range(N):\n    w, v = [int(n) for n in input().split()]\n    if(w < 0):\n        tmpw += w\n        tmpv += v\n        w *= -1\n        v *= -1\n    if(v > 0):\n        if w == 0:\n            tmpv += v\n        else:\n            heapq.heappush(minheap, (-(v/w), w, v))\nwhile(W-tmpw > 1e-9 and not minheap == []):\n    p = heapq.heappop(minheap)\n    w = p[1]\n    v = p[2]\n    x = min(1, (W-tmpw)/w)\n    tmpw += x*w\n    tmpv += x*v\nprint(tmpv)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nri=(raw_input()).split(\" \")\nn=int(ri[0])\nw=int(ri[1])\nd=[0]*n\ndp=[]\ndm=[]\nrestrict=0.0\nresult=0.0\n\nfor i in range(n):\n    ri=(raw_input()).split(\" \")\n    d[i]=[0]*3\n    d[i][1]=int(ri[0])*1.0 #w\n    d[i][2]=int(ri[1])*1.0 #v\n    if d[i][1]<=0 and d[i][2]>=0:\n        restrict+=d[i][1]\n        result+=d[i][2]\n    elif (d[i][1]>0 and d[i][2]>0):\n        dp+=[[1.0*d[i][1]/d[i][2],d[i][1],d[i][2],0.0]]\n    elif (d[i][1]<0 and d[i][2]<0):\n        dm+=[[-1.0*d[i][1]/d[i][2],d[i][1],d[i][2],0.0]]\n\ndp=sorted(dp)\ndm=sorted(dm)\ndmidx=0\n\nfor i in range(len(dp)):\n    if dp[i][1]+restrict<=w:\n        restrict+=dp[i][1]\n        result+=dp[i][2]\n        dp[i][3]=1.0\n    else:\n        dp[i][3]=1.0*(w-restrict)/dp[i][1]\n        restrict=w\n        result+=dp[i][2]*dp[i][3]\n        cont=True if (len(dm)>0 and (dp[i][0]<(-dm[dmidx][0]))) else False\n        while cont:\n            if (1-dp[i][3])*dp[i][1]/(-dm[dmidx][1])<1-dm[dmidx][3]:\n                dm[dmidx][3]+=(1-dp[i][3])*dp[i][1]/(-dm[dmidx][1])\n                result+=(1-dp[i][3])*(dp[i][2]-dm[dmidx][2]*dp[i][1]/dm[dmidx][1])\n                dp[i][3]=1.0\n                cont=False\n            else:\n                dp[i][3]+=(1-dm[dmidx][3])*(-dm[dmidx][1])/dp[i][1]\n                result+=(1-dm[dmidx][3])*(dm[dmidx][2]+dp[i][2]*(-dm[dmidx][1])/dp[i][1])\n                dm[dmidx][3]=1.0\n                dmidx+=1\n                if dmidx>=len(dm):\n                    cont=False\n                elif dp[i][0]>=(-dm[dmidx][0]):\n                    cont=False\n                \n#print(dp)\n#print(dm)\n#print(restrict)\nprint(result)\n\n"
  }
]