[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 50 *  30;\nconst int IINF = INT_MAX;\n\nstruct Edge { int src,dst; };\nvector<Edge> G[MAX_V];\nvector<int> computer;\nint n,V,mat[61][61];\n\nvoid dfs(int cur,int prev,int depth,vector<int> &mindist){\n\n  rep(i,computer.size()) {\n    if( computer[i] == -1 ) break;\n    assert( i < mindist.size() );\n    if( cur == computer[i] ) { assert( mindist[i] == IINF); mindist[i] = depth; }\n  }\n\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    dfs(next,cur,depth+1,mindist);\n  }\n\n}\n\nvoid compute(){\n  computer.clear();\n  computer.resize(n,-1);\n  computer[0] = 0;\n  V = 1;\n  REP(i,1,n) {\n    bool update = false; // for debug\n    rep(candidate,V) {\n      vector<int> mindist(i,IINF);\n      dfs(candidate,-1,0,mindist);\n      assert( mindist[0] != IINF );\n      int add_length = -1;\n      rep(j,i){\n        int length = mat[i][j] - mindist[j];\n        if( length <= 0 ) { add_length = -1; break; }\n        if( add_length == -1 ) add_length = length;\n        else if( add_length != length ) { add_length = -1; break; }\n      }\n      if( add_length != -1 ) {\n        // add_length ????????????????????????\n        // ????????????????????????????????? i ?????????????????\\??????\n        int prev = candidate;\n        rep(k,add_length){\n          G[prev].push_back((Edge){prev,V});\n          G[V].push_back((Edge){V,prev});\n          prev = V;\n          ++V;\n        }\n        computer[i] = V-1;\n        update = true;\n        break;\n      }\n    }\n    assert( update );\n  }\n  set<int> S;\n  rep(i,n) S.insert(computer[i]);\n  vector<int> answer;\n  rep(i,V) if( !S.count(i) ) answer.push_back(G[i].size());\n  sort(answer.begin(),answer.end());\n  rep(i,answer.size()){\n    if( i ) printf(\" \");\n    printf(\"%d\",answer[i]);\n  } puts(\"\");\n}\n\nint main(){\n  while( scanf(\"%d\",&n), n ){\n    rep(i,MAX_V) G[i].clear();\n    rep(i,n) rep(j,n) scanf(\"%d\",&mat[i][j]);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nint a[55][55];\nint b[11111][11111];\n\nvector<int> sw[1111];\n\nvoid print()\n{\n  for(int i = 0; i < N+M; i++) {\n    for(int j = 0; j < N+M; j++) cout << b[i][j] << \" \";\n    cout << endl;\n  }\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n    for(int i = 0; i < 55; i++) sw[i].clear();\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> a[i][j];\n\tb[i][j] = a[i][j];\n      }\n    }\n    M = 0;\n    sw[0].push_back(0);\n    for(int i = 0; i < a[0][1]-2; i++) {\n      sw[M].push_back(N+M+1);\n      sw[M+1].push_back(N+M);\n      M++;\n    }\n    sw[M].push_back(1);\n    M++;\n    for(int i = 0; i < M; i++) {\n      b[0][N+i] = b[N+i][0] = i+1;\n      b[1][N+i] = b[N+i][1] = a[0][1]-i-1;\n      for(int j = 0; j < M; j++) b[N+i][N+j] = b[N+j][N+i] = abs(i-j);\n    }\n    for(int i = 2; i < N; i++) {\n      bool judge = false;\n      for(int j = 0; j < M; j++) {\n\tbool flag = false;\n\tfor(int k = 0; k < i; k++) {\n\t  if(b[N+j][k] + 1 != b[k][i]) flag = true;\n\t}\n\tif(flag) continue;\n\tsw[j].push_back(i);\n\tfor(int k = 0; k < M; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + 1;\n\tjudge = true;\n\tbreak;\n      }\n      if(!judge) {\n\tfor(int j = 0; j < M; j++) {\n\t  bool check = false;\n\t  for(int k = 0; k < i-1; k++) {\n\t    if(b[i][k] - b[N+j][k] != b[i][k+1] - b[N+j][k+1]) check = true;\n\t  }\n\t  if(check) continue;\n\t  int m = M;\n\t  sw[j].push_back(N+M);\n\t  sw[M].push_back(j);\n\t  for(int k = 0; k < b[i][0]-b[N+j][0]-2; k++) {\n\t    sw[M].push_back(N+M+1);\n\t    sw[M+1].push_back(N+M);\n\t    M++;\n\t  }\n\t  sw[M].push_back(i);\n\t  M++;\n\t  for(int k = m; k < M; k++) {\n\t    for(int l = 0; l < i; l++) b[l][N+k] = b[N+k][l] = b[l][N+j] + k-m+1;\n\t    for(int l = m; l < M; l++) b[N+k][N+l] = b[N+l][N+k] = abs(k-l);\n\t  }\n\t  for(int k = m; k < M; k++) {\n\t    b[N+j][N+k] = b[N+k][N+j] = k-m+1;\n\t    b[i][N+k] = b[N+k][i] = M-k;\n\t    for(int l = 0; l < m; l++) b[N+l][N+k] = b[N+k][N+l] = b[N+j][N+l] + b[N+j][N+k];\n\t  }\n\t  for(int k = 0; k < m; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + b[N+j][N+M-1] + 1;\n\t  break;\n\t}\n      }\n    }\n    vector<int> ans;\n    for(int i = 0; i < M; i++) ans.push_back(sw[i].size());\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < M; i++) cout << ans[i] << (i==M-1 ? '\\n' : ' ');\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nint a[55][55];\nint b[101][101];\n\nvector<int> sw[55];\n\nvoid print()\n{\n  for(int i = 0; i < N+M; i++) {\n    for(int j = 0; j < N+M; j++) cout << b[i][j] << \" \";\n    cout << endl;\n  }\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n    for(int i = 0; i < 55; i++) sw[i].clear();\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> a[i][j];\n\tb[i][j] = a[i][j];\n      }\n    }\n    M = 0;\n    sw[0].push_back(0);\n    for(int i = 0; i < a[0][1]-2; i++) {\n      sw[M].push_back(N+M+1);\n      sw[M+1].push_back(N+M);\n      M++;\n    }\n    sw[M].push_back(1);\n    M++;\n    for(int i = 0; i < M; i++) {\n      b[0][N+i] = b[N+i][0] = i+1;\n      b[1][N+i] = b[N+i][1] = a[0][1]-i-1;\n      for(int j = 0; j < M; j++) b[N+i][N+j] = b[N+j][N+i] = abs(i-j);\n    }\n    //print();\n    for(int i = 2; i < N; i++) {\n      bool judge = false;\n      for(int j = 0; j < M; j++) {\n\tbool flag = false;\n\tfor(int k = 0; k < i; k++) {\n\t  if(b[N+j][k] + 1 != b[k][i]) flag = true;\n\t}\n\tif(flag) continue;\n\tsw[j].push_back(i);\n\tfor(int k = 0; k < M; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + 1;\n\tjudge = true;\n\t//print();\n\tbreak;\n      }\n      if(!judge) {\n\t//cout << i << \" \" << M << endl;\n\t//print();\n\tfor(int j = 0; j < M; j++) {\n\t  bool check = false;\n\t  for(int k = 0; k < i-1; k++) {\n\t    if(b[i][k] - b[N+j][k] != b[i][k+1] - b[N+j][k+1]) check = true;\n\t  }\n\t  if(check) continue;\n\t  //cout << \"OK\" << endl;\n\t  int m = M;\n\t  sw[j].push_back(N+M);\n\t  sw[M].push_back(j);\n\t  for(int k = 0; k < b[i][0]-b[N+j][0]-2; k++) {\n\t    sw[M].push_back(N+M+1);\n\t    sw[M+1].push_back(N+M);\n\t    M++;\n\t  }\n\t  sw[M].push_back(i);\n\t  M++;\n\t  for(int k = 0; k < i; k++) {\n\t    for(int l = m; l < M; l++) b[k][N+l] = b[N+l][k] = b[k][N+j] + l-m+1;\n\t  }\n\t  for(int k = m; k < M; k++) {\n\t    b[N+j][N+k] = b[N+k][N+j] = k-m+1;\n\t    b[i][N+k] = b[N+k][i] = M-k;\n\t    for(int l = 0; l < m; l++) {\n\t      b[N+l][N+k] = b[N+k][N+l] = b[N+j][N+l] + b[N+j][N+k];\n\t      //cout << N+l << \" \" << N+k << \" \" << N+j << endl;\n\t      //cout << b[N+l][N+k] << \" \" << \" \" << b[N+j][N+l] << \" \"<< b[N+j][N+k] << endl;\n\t    }\n\t  }\n\t  for(int k = 0; k < m; k++) {\n\t    b[i][N+k] = b[N+k][i] = b[N+j][N+k] + b[N+j][N+M-1] + 1;\n\t  }\n\t  //print();\n\t  break;\n\t}\n      }\n    }\n    vector<int> ans;\n    for(int i = 0; i < M; i++) ans.push_back(sw[i].size());\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < M; i++) cout << ans[i] << (i==M-1 ? '\\n' : ' ');\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define maxn 2000000\nusing namespace std;\nint n,g[55][55],head[maxn],tot=1,cnt,h[maxn],f[maxn],ans[maxn];\nstruct edge{\n\tint v,next;\n}e[maxn*5];\nbool cmp(int a,int b){return a<b;}\nvoid adde(int a,int b){\n\te[tot].v=b;\n\te[tot].next=head[a];\n\thead[a]=tot++;\n}\nvoid addnew(int a,int b,int k){\n\tint last=a;\n\twhile(k>1){\n\t\tcnt++;k--;\n\t\tadde(last,cnt);adde(cnt,last);\n\t\tlast=cnt;\n\t}\n\tadde(last,b);adde(b,last);\n}\n\nvoid dfs_1(int x,int fa){\n\th[x]=h[fa]+1;\n\tf[x]=fa;\n\tfor(int i=head[x];~i;i=e[i].next ){\n\t\tint v=e[i].v;\n\t\tif(v==fa)continue;\n\t\tdfs_1(v,x);\n\t}\n}\n\nvoid solve(int x){\n\tint m1=0;\n\t\n\tfor(int i=1;i<x;i++){\n\t\tif(g[i][x]<g[m1][x]){\n\t\t\tm1=i;\n\t\t}\n\t}\n\tmemset(f,0,sizeof(f));\n\tmemset(h,0,sizeof(h));\n\th[0]=-1;\n\tdfs_1(m1,0);\n\tint len;\n\tint Min=1e9,m2;\n\tfor(int i=1;i<x;i++){\n\t\tif(i==m1)continue;\n\t\tlen=(g[x][m1]+g[x][i]-g[m1][i])/2;\n\t\tif(len<Min){\n\t\t\tMin=len;\n\t\t\tm2=i;\n\t\t}\n\t}\n\t\n\tint k=g[m1][m2]-g[x][m1]+len;\n\tint ff=m2;\n\twhile(k--){\n\t\tff=f[ff];\n\t}\n\taddnew(ff,x,Min);\n}\n\nint dfs_ans(int u,int fa){\n\tans[u]=1;\n\tfor(int i=head[u];~i;i=e[i].next ){\n\t\tint v=e[i].v;\n\t\tif(v==fa)continue;\n\t\tans[u]++;\n\t\tdfs_ans(v,u);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)!=EOF&&n){\n\t\tmemset(head,-1,sizeof(head));\n\t\tmemset(g,0,sizeof(g));\n\t\tmemset(ans,0,sizeof(ans));\n\t\t//for(int i=1;i<=tot;i++)e[i].v=e[i].next =0;\n\t\tcnt=0;tot=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tscanf(\"%d\",&g[i][j]);\n\t\t\t}\n\t\t\tg[0][i]=g[i][0]=1e9;\n\t\t}\n\t\tcnt=n;\n\t\t\n\t\taddnew(1,2,g[1][2]);\n\t\tfor(int i=3;i<=n;i++){\n\t\t\tsolve(i);\n\t\t}\n\t\t\n\t\tdfs_ans(1,1);\n\t\tsort(ans+1+n,ans+1+cnt,cmp);\n\t\tfor(int i=n+1;i<=cnt;i++)printf(\"%d \",ans[i]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}/*\n4\n  0  2  2  2\n  2  0  2  2\n  2  2  0  2\n  2  2  2  0\n4\n  0  2  4  4\n  2  0  4  4\n  4  4  0  2\n  4  4  2  0\n2\n  0 12\n 12  0\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define MAX 1000\n\nint n, m; //ツノ-ツドツ青? ツδ?ツタツ青?\nint a[52][52];\nint dist[MAX][MAX]; //ツδ?ツタiツつゥツづァツノ-ツドjツづ慊づ?づ個仰猟猟」\nint cnt[MAX]; //ツδ?ツタiツづ個篠淞青?\nint near[MAX]; //ツノ-ツドツづ個暗ェツ氾板凝淞つュツづ可つ?づゥツδ?ツタツづ個氾板債?\nbool used[MAX];\n\nvector<int> t[MAX];\n\nvoid init(){\n  m = 0;\n  memset(dist, -1, sizeof(dist));\n  memset(cnt, 0, sizeof(cnt));\n  memset(near, -1, sizeof(near));\n\n  for(int i = 0; i < 100; i++){\n    t[i].clear();\n  }\n\n  near[0] = 0;\n  near[1] = a[0][1] - 2;\n\n  //1ツ妥、ツ姪堋づ?ツ妥、ツ姪堋づ個甘板つセツつッツ陛環渉按猟?\n  for(int i = 0; i < a[0][1] - 1; i++){\n    cnt[i] = 2;\n    dist[i][0] = i + 1;\n    dist[i][1] = a[0][1] - dist[i][0];\n    m++;\n\n    if(i < a[0][1] - 2){\n      t[i].push_back(i + 1);\n      t[i + 1].push_back(i);\n    }\n  }\n}\n\nvoid show(){\n  cout<<\"---------------------------------------------\\n\";\n  cout<<\"--dist table---------------------------------\\n\";\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++){\n      printf(\"%3d\", dist[i][j]);\n    }\n\n    cout<<\"    \";\n    printf(\"%3d\",cnt[i]);\n    cout<<endl;\n  }\n\n  cout<<\"--near router--------------------------------\\n\";\n  for(int i = 0; i < n; i++){\n    cout << \"node \" << i<<\" : \";\n    cout << near[i] << endl;\n  }\n\n  cout<<\"--router graph-------------------------------\\n\";\n\n  for(int i = 0; i < m; i++){\n    cout<<i<<\" : \";\n    for(int j = 0; j < t[i].size(); j++){\n      cout << t[i][j] << \", \";\n    }\n    cout<<endl;\n  }\n}\n\n//to : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//id : ツδ?ツタツ氾板債?\nbool check(int to, int id){\n  int diff = a[to][0] - dist[id][0];\n\n  for(int i = 1; i < to; i++){\n    if(diff != a[to][i] - dist[id][i]){\n      return false;\n    }\n  }\n\n  return true;\n}\n\n//A : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//B : Aツづーツづつづ按つーツづゥツδ?ツタツ氾板債?\n//return : ツノ-ツドAツづ個づ?づ?づ?づ?凝淞つュツづ可つュツづ?づつつ「ツづ?づゥツδ?ツタツ氾板債?\nint connectAB(int A, int B){\n  int d = a[A][0] - dist[B][0];\n\n  for(int i = 0; i < d - 1; i++){\n    if(i == 0){\n      t[B].push_back(m);\n      t[m].push_back(B);\n      cnt[m]++;\n      cnt[B]++;\n    }\n    else{\n      t[m].push_back(m - 1);\n      t[m - 1].push_back(m);\n      cnt[m]++;\n      cnt[m - 1]++;\n    }\n    m++;\n  }\n  cnt[m - 1]++;\n\n  return m - 1;\n}\n\n//A : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//dist[id][A]ツづ営ostツ渉堕つォツ債楪づ?\nvoid dfs(int A, int id, int cost){\n  dist[id][A] = cost;\n  used[id] = true;\n\n  for(int i = 0; i < t[id].size(); i++){\n    int to = t[id][i];\n    if(!used[to]){\n      dfs(A, to, cost + 1);\n    }\n  }\n}\n\nvoid solve(){\n  for(int i = 2; i < n; i++){\n    int connect = -1;\n\n    for(int j = 0; j < m; j++){\n      if(check(i, j)){\n        connect = j;\n        break;\n      }\n    }\n\n    near[i] = connectAB(i, connect);\n    for(int j = 0; j <= i; j++){\n      memset(used, 0, sizeof(used));\n      dfs(j, near[j], 1);\n    }\n  }\n\n  vector<int> ans;\n  for(int i = 0; i < m; i++){\n    ans.push_back(cnt[i]);\n  }\n  sort(ans.begin(), ans.end());\n\n  for(int i = 0; i < m; i++){\n    if(i != 0) cout << \" \";\n    cout << ans[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        cin >> a[i][j];\n      }\n    }\n\n    init();\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define MAX 50\n#define NMAX 80\n\nclass Node{\n    public:\n    vector<int> adjList;\n    Node(){}\n    void insert( int i ){ adjList.push_back(i);}\n};\n\nclass Network{\n    public:\n    vector<Node> nodes;\n    Network(){}\n\n    int size(){ return nodes.size(); }\n    void addNode(){ nodes.push_back(Node()); }\n\n    void connect( int i, int j ){\n        nodes[i].insert(j); nodes[j].insert(i);\n    }\n\n    void addNewNodes( int target, int diff, int u ){\n        if ( diff == 1 ){\n            connect( target, u );\n        } else {\n            for ( int i = 1; i < diff; i++ ){\n                addNode();\n                if ( i == 1 ) connect( target, size()-1 );\n                else connect( size()-2, size()-1);\n            }\n            connect( size()-1, u );\n        }\n    }\n};\n\nclass State{\n    public:\n    int cur, pre, d;\n    State(){}\n    State(int cur, int pre, int d): cur(cur), pre(pre), d(d){}\n};\n\nint N, M[MAX][MAX];\nNetwork network;\n\nint getDistance(int s, int t){\n    queue<State> Q;\n    Q.push(State(s, -1, 0));\n    State u;\n    while( !Q.empty() ){\n        u = Q.front(); Q.pop();\n        if ( u.cur == t ) return u.d;\n        for ( int i = 0; i < network.nodes[u.cur].adjList.size(); i++ ){\n            int v = network.nodes[u.cur].adjList[i];\n            if ( v != u.pre ){\n                Q.push(State(v, u.cur, u.d + 1));\n           }\n        }\n    }\n}\n\nint parse( int source, int end ){\n    int pre = M[end+1][0] - getDistance( source, 0 );\n    int d;\n    for ( int t = 1; t <= end; t++ ){\n        d = M[end+1][t] - getDistance( source, t );\n        if ( pre != d ) return -1;\n    }\n    return pre;\n}\n\nvoid addNewNode( int u ){\n    for ( int target = N; target < network.size(); target++ ){\n        int diff = parse(target, u - 1);\n        if ( diff > 0 ) {\n            network.addNewNodes(target, diff, u);\n            return;\n        }\n    }\n}\n\nvoid solve(){\n    network = Network();\n    for ( int i = 0; i < N + 1; i++ ) network.addNode();\n    network.connect( 0, network.size()-1);\n\n    for ( int i = 1; i < N; i++ ) addNewNode(i);\n\n    vector<int> degree;\n    for ( int i = N; i < network.size(); i++ ) {\n        degree.push_back(network.nodes[i].adjList.size());\n    }\n    sort(degree.begin(), degree.end());\n    for ( int i = 0; i < degree.size(); i++ ){\n        if ( i ) cout << \" \";\n        cout << degree[i];\n    }\n    cout << endl;\n}\n\nbool input(){\n    cin >> N;\n    if ( N == 0 ) return false;\n    for ( int i = 0; i < N; i++ ){\n        for ( int j = 0; j < N; j++ ) cin >> M[i][j];\n    }\n    return true;\n}\n main(){\n    while ( input() ) solve();\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;};\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;};\n\n\nInt n;\nInt a[55][55];\nsigned main(){\n  while(cin>>n,n){\n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<n;j++)\n\tcin>>a[i][j];\n\n    vector<vector<Int> > G(n+10000);\n    Int x=0,y=0;\n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<n;j++)\n\tif(a[x][y]<a[i][j]) x=i,y=j;\n\n    auto add_edge=[&](Int x,Int y){\n      G[x].emplace_back(y);\n      G[y].emplace_back(x);\n    };\n    \n    Int m=n;\n    {\n      Int lst=x;\n      for(Int k=0;k+1<a[x][y];k++){\n\tadd_edge(lst,m);\n\tlst=m++;\n      }\n      add_edge(lst,y);\n    };\n    vector<Int> dist,dp;\n    auto bfs=[&](Int x){\n      dp.assign(m,-1);\n      queue<Int> q;\n      dp[x]=0;\n      q.emplace(x);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(~dp[u]) continue;\n\t  dp[u]=dp[v]+1;\n\t  q.emplace(u);\n\t}\n      }\n    };\n\n    vector<Int> fin({x,y});\n    for(Int t=0;t<n;t++){\n      if(t==x||t==y) continue;\n      bfs(x);\n      dist=dp;\n      for(Int z:fin){\n\tbfs(z);\n\tfor(Int i=0;i<m;i++){\n\t  if(dist[i]<0) continue;\n\t  if(a[t][x]-dist[i]!=a[t][z]-dp[i]) dist[i]=-2;\n\t}\n      }\n\n      Int lst=-1;\n      for(Int i=0;i<m;i++) if(dist[i]>=0) lst=i;\n      Int di=a[t][x]-dist[lst];\n      for(Int k=0;k+1<di;k++){\n\tadd_edge(lst,m);\n\tlst=m++;\n      }\n      add_edge(lst,t);\n      fin.emplace_back(t);\n    }\n    vector<Int> ans;\n    for(Int i=n;i<m;i++)\n      ans.emplace_back(G[i].size());\n    sort(ans.begin(),ans.end());\n    for(Int i=0;i<(Int)ans.size();i++){\n      if(i) cout<<\" \";\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint d[1500][1500];\n\nint N,deg[1500];\nvoid solve(int root,vector<int> V){\n\tint n=V.size();\n\tif(V.empty()) return;\n\n\t// root と u を両端とする列を作る\n\t// 残りの頂点は root-u 間にある d[root][u]+1 個の頂点のどれかにぶら下がる\n\tint u=V[0];\n\tvector<int> ch[32];\n\tfor(int i=1;i<V.size();i++){\n\t\tint v=V[i];\n\t\tch[(d[root][u]+d[root][v]-d[u][v])/2].push_back(v);\n\t}\n\n\t// 列の各頂点を根にして, 再帰的に木の形を求める\n\tint par;\n\trep(i,d[root][u]+1){\n\t\tint v; // 次の根\n\t\tif(i==0){\n\t\t\tv=root;\n\t\t}\n\t\telse if(i==d[root][u]){\n\t\t\tv=u;\n\t\t}\n\t\telse{\n\t\t\tv=N++;\n\t\t\trep(j,ch[i].size()){\n\t\t\t\tint w=ch[i][j];\n\t\t\t\td[v][w]=d[w][v]=d[root][w]-i;\n\t\t\t}\n\t\t}\n\n\t\tif(i!=0){\n\t\t\tdeg[par]++;\n\t\t\tdeg[ v ]++;\n\t\t}\n\n\t\tsolve(v,ch[i]);\n\n\t\tpar=v;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\trep(u,n) rep(v,n) scanf(\"%d\",d[u]+v);\n\n\t\tvector<int> V;\n\t\trep(i,n-1) V.push_back(i+1);\n\t\tN=n;\n\t\trep(u,1500) deg[u]=0;\n\t\tsolve(0,V);\n\n\t\tvector<int> ans(deg+n,deg+N);\n\t\tsort(ans.begin(),ans.end());\n\t\trep(i,ans.size()) printf(\"%d%c\",ans[i],i+1<ans.size()?' ':'\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint d[300][300];\n\nint N,deg[300];\nvoid solve(int root,vector<int> V){\n\tint n=V.size();\n\tif(V.empty()) return;\n\n\t// root と u を両端とする列を作る\n\t// 残りの頂点は root-u 間にある d[root][u]+1 個の頂点のどれかにぶら下がる\n\tint u=V[0];\n\tvector<int> ch[32];\n\tfor(int i=1;i<V.size();i++){\n\t\tint v=V[i];\n\t\tch[(d[root][u]+d[root][v]-d[u][v])/2].push_back(v);\n\t}\n\n\t// 列の各頂点を根にして, 再帰的に木の形を求める\n\tint par;\n\trep(i,d[root][u]+1){\n\t\tint v; // 次の根\n\t\tif(i==0){\n\t\t\tv=root;\n\t\t}\n\t\telse if(i<d[root][u]){\n\t\t\tv=N++;\n\t\t\trep(j,ch[u].size()){\n\t\t\t\tint w=ch[u][j];\n\t\t\t\td[v][w]=d[w][v]=d[root][w]-i;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tv=u;\n\t\t}\n\n\t\tif(i!=0){\n\t\t\tdeg[par]++;\n\t\t\tdeg[ v ]++;\n\t\t}\n\n\t\tsolve(v,ch[i]);\n\n\t\tpar=v;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\trep(u,n) rep(v,n) scanf(\"%d\",d[u]+v);\n\n\t\tvector<int> V;\n\t\trep(i,n-1) V.push_back(i+1);\n\t\tN=n;\n\t\trep(u,300) deg[u]=0;\n\t\tsolve(0,V);\n\n\t\tvector<int> ans;\n\t\trep(u,N) if(deg[u]>=2) ans.push_back(deg[u]);\n\t\tsort(ans.begin(),ans.end());\n\t\trep(i,ans.size()) printf(\"%d%c\",ans[i],i+1<ans.size()?' ':'\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nint a[55][55];\nint b[101][101];\n\nvector<int> sw[55];\n\nvoid dfs(int now, int idx, int prev, int dist)\n{\n  b[now][idx] = dist;\n  for(int i = 0; i < sw[now].size(); i++) {\n    if(sw[now][i] != prev) dfs(sw[now][i], idx, now, dist+1);\n  }\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(a, -1, sizeof(a));\n    memset(b, -1, sizeof(b));\n    for(int i = 0; i < 55; i++) sw[i].clear();\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> a[i][j];\n\tb[i][j] = a[i][j];\n      }\n    }\n    M = 0;\n    sw[0].push_back(0);\n    for(int i = 0; i < a[0][1]-2; i++) {\n      sw[M].push_back(N+M+1);\n      sw[M+1].push_back(N+M);\n      M++;\n    }\n    sw[M].push_back(1);\n    M++;\n    for(int i = 0; i < M; i++) {\n      b[0][N+i] = b[N+i][0] = i+1;\n      b[1][N+i] = b[N+i][1] = a[0][1]-i-1;\n      for(int j = 0; j < M; j++) b[N+i][N+j] = b[N+j][N+i] = abs(i-j);\n    }\n    for(int i = 0; i < N+M; i++) {\n      for(int j = 0; j < N+M; j++) ;//cout << b[i][j] << \" \";\n      //cout << endl;\n    }\n    //cout << endl;\n    for(int i = 2; i < N; i++) {\n      bool judge = false;\n      for(int j = 0; j < M; j++) {\n\tbool flag = false;\n\tfor(int k = 0; k < i; k++) {\n\t  if(b[N+j][k] + 1 != b[k][i]) flag = true;\n\t}\n\tif(flag) continue;\n\tsw[j].push_back(i);\n\tfor(int k = 0; k < M; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + 1;\n\tjudge = true;\n\tfor(int k = 0; k < N+M; k++) {\n\t  for(int l = 0; l < N+M; l++) ;//cout << b[k][l] << \" \";\n\t  //cout << endl;\n\t}\n\t//cout << endl;\n\tbreak;\n      }\n      if(!judge) {\n\t//cout << i << \" \" << \"HOGE\" << endl;\n\tfor(int j = 0; j < M; j++) {\n\t  bool check = false;\n\t  for(int k = 0; k < i-1; k++) {\n\t    if(b[i][k] - b[N+j][k] != b[i][k+1] - b[N+j][k+1]) check = true;\n\t  }\n\t  if(check) continue;\n\t  int m = M;\n\t  //cout << j << \" \" << N+m << endl;\n\t  //cout << b[i][0] << \" \" << b[N+j][0] << endl;\n\t  sw[j].push_back(N+M);\n\t  sw[M].push_back(j);\n\t  for(int k = 0; k < b[i][0]-b[N+j][0]-2; k++) {\n\t    sw[M].push_back(N+M+1);\n\t    sw[M+1].push_back(N+M);\n\t    M++;\n\t  }\n\t  sw[M].push_back(i);\n\t  M++;\n\t  for(int k = 0; k < i; k++) {\n\t    for(int l = m; l < M; l++) b[k][N+l] = b[N+l][k] = b[k][N+j] + l-m+1;\n\t  }\n\t  for(int k = 0; k < m; k++) {\n\t    b[i][N+k] = b[N+k][i] = b[N+j][N+k] + b[i][0]-b[N+j][0]-1;\n\t  }\n\t  for(int k = m; k < M; k++) {\n\t    b[N+j][N+k] = b[N+k][N+j] = k-m+1;\n\t    b[i][N+k] = b[N+k][i] = b[i][0]-b[N+j][0]-k+m-1;\n\t    for(int l = 0; l < m; l++) b[N+l][N+k] = b[N+k][N+l] = b[N+j][N+l] + b[N+j][N+k];\n\t  }\n\t  for(int k = 0; k < N+M; k++) {\n\t    for(int l = 0; l < N+M; l++) ;//cout << b[k][l] << \" \";\n\t    //cout << endl;\n\t  }\n\t  //cout << endl;\n\t  break;\n\t}\n      }\n    }\n    vector<int> ans;\n    for(int i = 0; i < M; i++) ans.push_back(sw[i].size());\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < M; i++) cout << ans[i] << (i==M-1 ? '\\n' : ' ');\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nint a[55][55];\nint b[1111][1111];\n\nvector<int> sw[1111];\n\nvoid print()\n{\n  for(int i = 0; i < N+M; i++) {\n    for(int j = 0; j < N+M; j++) cout << b[i][j] << \" \";\n    cout << endl;\n  }\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n    for(int i = 0; i < 55; i++) sw[i].clear();\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> a[i][j];\n\tb[i][j] = a[i][j];\n      }\n    }\n    M = 0;\n    sw[0].push_back(0);\n    for(int i = 0; i < a[0][1]-2; i++) {\n      sw[M].push_back(N+M+1);\n      sw[M+1].push_back(N+M);\n      M++;\n    }\n    sw[M].push_back(1);\n    M++;\n    for(int i = 0; i < M; i++) {\n      b[0][N+i] = b[N+i][0] = i+1;\n      b[1][N+i] = b[N+i][1] = a[0][1]-i-1;\n      for(int j = 0; j < M; j++) b[N+i][N+j] = b[N+j][N+i] = abs(i-j);\n    }\n    for(int i = 2; i < N; i++) {\n      bool judge = false;\n      for(int j = 0; j < M; j++) {\n\tbool flag = false;\n\tfor(int k = 0; k < i; k++) {\n\t  if(b[N+j][k] + 1 != b[k][i]) flag = true;\n\t}\n\tif(flag) continue;\n\tsw[j].push_back(i);\n\tfor(int k = 0; k < M; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + 1;\n\tjudge = true;\n\tbreak;\n      }\n      if(!judge) {\n\tfor(int j = 0; j < M; j++) {\n\t  bool check = false;\n\t  for(int k = 0; k < i-1; k++) {\n\t    if(b[i][k] - b[N+j][k] != b[i][k+1] - b[N+j][k+1]) check = true;\n\t  }\n\t  if(check) continue;\n\t  int m = M;\n\t  sw[j].push_back(N+M);\n\t  sw[M].push_back(j);\n\t  for(int k = 0; k < b[i][0]-b[N+j][0]-2; k++) {\n\t    sw[M].push_back(N+M+1);\n\t    sw[M+1].push_back(N+M);\n\t    M++;\n\t  }\n\t  sw[M].push_back(i);\n\t  M++;\n\t  for(int k = m; k < M; k++) {\n\t    for(int l = 0; l < i; l++) b[l][N+k] = b[N+k][l] = b[l][N+j] + k-m+1;\n\t    for(int l = m; l < M; l++) b[N+k][N+l] = b[N+l][N+k] = abs(k-l);\n\t  }\n\t  for(int k = m; k < M; k++) {\n\t    b[N+j][N+k] = b[N+k][N+j] = k-m+1;\n\t    b[i][N+k] = b[N+k][i] = M-k;\n\t    for(int l = 0; l < m; l++) b[N+l][N+k] = b[N+k][N+l] = b[N+j][N+l] + b[N+j][N+k];\n\t  }\n\t  for(int k = 0; k < m; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + b[N+j][N+M-1] + 1;\n\t  break;\n\t}\n      }\n    }\n    vector<int> ans;\n    for(int i = 0; i < M; i++) ans.push_back(sw[i].size());\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < M; i++) cout << ans[i] << (i==M-1 ? '\\n' : ' ');\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint A[55][55];\nvector<vector<int>> G;\nvector<vector<int>> V;\n\nvoid init(){\n  G.clear();\n  V.clear();\n}\n\nvoid add_edge( int a, int b ){\n  G[a].push_back( b );\n  G[b].push_back( a );\n}\nint make_node( int v ){\n  G.push_back( vector<int>() );\n  V.push_back( vector<int>(N) );\n  int nv = G.size()-1;\n  add_edge( v, nv );\n  for(int i=0;i<N;i++)\n    V[nv][i] = V[v][i]+1;\n  return nv;\n}\n\nvoid dfs(int s,int id, int pr,int f){\n  V[id][s] = f;\n  for( int to : G[id] ){\n    if( to == pr ) continue;\n    dfs( s, to, id, f+1 );\n  }\n}\n\nvoid dfs(int s){\n  dfs( s, s, s, 0 );\n}\n\nint check(int v,int t){\n  int r = A[t][0] - V[v][0];\n  if( r < 1 ) return 0;\n  for(int i=1;i<t;i++)\n    if( r != A[t][i] - V[v][i] ) return 0;\n  return r;\n}\n\nint main(){\n  while( cin >> N && N ){\n    init();\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        cin >> A[i][j];\n\n    G = vector<vector<int>>(N);\n    V = vector<vector<int>>(N,vector<int>(N));\n    \n    int pt = 0;\n    for(int i=0;i<A[0][1]-1;i++)\n      pt = make_node( pt );    \n    add_edge( pt, 1 );\n    dfs( 0 );\n    dfs( 1 );\n    for(int i=2;i<N;i++){\n      int n = G.size();\n      for(int j=N;j<n;j++){\n        int r;\n        if( (r = check( j, i )) ){\n          int pt = j;\n          for(int k=0;k<r-1;k++){\n            pt = make_node( pt ); \n          }\n          add_edge( pt, i );\n          dfs( i );\n          break;\n        }\n      }\n    }\n\n    vector<int> res;\n    for(int i=N;i<(int)G.size();i++)\n      res.push_back( G[i].size() );\n    sort( res.begin(), res.end() );\n    for( int i=0;i<(int)res.size();i++) {\n      if( i ) cout << \" \";\n      cout << res[i];\n    }\n    cout << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 200\n#define N 55\nusing namespace std;\ntypedef pair<int,int> P;\nint n,d[N][N],cnt,num;\nvector<int> e[M],ans;\nP a[N];\n\nint main(){\n  while(cin>>n,n){\n    cnt=1;\n    for(int i=0;i<M;i++)e[i].clear();\n    ans.clear();\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tcin>>d[i][j];\n\tif(!i&&j)a[j-1]=P(d[i][j],j);\n      }\n    sort(a,a+n-1);\n    e[0].push_back(n);\n    e[n].push_back(0);\n    num=n;\n    for(int i=0;i<n-1;i++){\n      int cost=a[i].first;\n      int node=a[i].second;\n      if(cnt<cost-1){\n\tint loop=cost-1-cnt;\n\twhile(loop--){\n\t  e[num].push_back(num+1);\n\t  e[num+1].push_back(num);\n\t  num++;\n\t  cnt++;\n\t}\n      }\n      e[num].push_back(node);\n      e[node].push_back(num);\n    }\n    for(int i=n;i<=num;i++)\n      ans.push_back(e[i].size());\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef vector<int> vint;\n#define pb push_back\n#define N 50\n\nint a[N][N];\n//dfr = distance from root,node = group of node ,\nvoid solve(vint dfr,vint node,vint &ans){\n  if (node.size() == 1 && dfr[node[0]] == 0)return;\n  int n = node.size();\n  int gid[n];\n  rep(i,n)gid[i] = node[i];\n\n  int cnt = 0;\n  rep(i,n){\n    if ( gid[i] != node[i])continue;\n    vint nextgroup;\n    nextgroup.pb(node[i]);\n    REP(j,i+1,n){\n      if ( gid[j] == node[j] && dfr[node[i]] + dfr[node[j]] > a[node[i]][node[j]]){\n\tnextgroup.pb(node[j]);\n\tgid[j] = node[i];\n\tdfr[node[j]]--;\n      }\n    }\n    dfr[node[i]]--;\n    solve(dfr,nextgroup,ans);\n    cnt++;\n  }\n  ans.pb(cnt+1);\n}\n\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    vint node,dfr,ans;\n    dfr.push_back(-1);//dummy\n    rep(i,n)rep(j,n)cin>>a[i][j];\n    REP(i,1,n)node.pb(i),dfr.pb(a[0][i]-1);\n    solve(dfr,node,ans);\n    sort(ans.begin(),ans.end());\n    rep(i,ans.size()){\n      if (i)cout << \" \";\n      cout << ans[i];\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint n, m; //ツノ-ツドツ青? ツδ?ツタツ青?\nint a[52][52];\nint dist[100][100]; //ツδ?ツタiツつゥツづァツノ-ツドjツづ慊づ?づ個仰猟猟」\nint cnt[100]; //ツδ?ツタiツづ個篠淞青?\nint near[100]; //ツノ-ツドツづ個暗ェツ氾板凝淞つュツづ可つ?づゥツδ?ツタツづ個氾板債?\nbool used[100];\n\nvector<int> t[100];\n\nvoid init(){\n  m = 0;\n  memset(dist, -1, sizeof(dist));\n  memset(cnt, 0, sizeof(cnt));\n  memset(near, -1, sizeof(near));\n\n  for(int i = 0; i < 100; i++){\n    t[i].clear();\n  }\n\n  near[0] = 0;\n  near[1] = a[0][1] - 2;\n\n  //1ツ妥、ツ姪堋づ?ツ妥、ツ姪堋づ個甘板つセツつッツ陛環渉按猟?\n  for(int i = 0; i < a[0][1] - 1; i++){\n    cnt[i] = 2;\n    dist[i][0] = i + 1;\n    dist[i][1] = a[0][1] - dist[i][0];\n    m++;\n\n    if(i < a[0][1] - 2){\n      t[i].push_back(i + 1);\n      t[i + 1].push_back(i);\n    }\n  }\n}\n\nvoid show(){\n  cout<<\"---------------------------------------------\\n\";\n  cout<<\"--dist table---------------------------------\\n\";\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++){\n      printf(\"%3d\", dist[i][j]);\n    }\n\n    cout<<\"    \";\n    printf(\"%3d\",cnt[i]);\n    cout<<endl;\n  }\n\n  cout<<\"--near router--------------------------------\\n\";\n  for(int i = 0; i < n; i++){\n    cout << \"node \" << i<<\" : \";\n    cout << near[i] << endl;\n  }\n\n  cout<<\"--router graph-------------------------------\\n\";\n\n  for(int i = 0; i < m; i++){\n    cout<<i<<\" : \";\n    for(int j = 0; j < t[i].size(); j++){\n      cout << t[i][j] << \", \";\n    }\n    cout<<endl;\n  }\n}\n\n//to : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//id : ツδ?ツタツ氾板債?\nbool check(int to, int id){\n  int diff = a[to][0] - dist[id][0];\n\n  for(int i = 1; i < to; i++){\n    if(diff != a[to][i] - dist[id][i]){\n      return false;\n    }\n  }\n\n  return true;\n}\n\n//A : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//B : Aツづーツづつづ按つーツづゥツδ?ツタツ氾板債?\n//return : ツノ-ツドAツづ個づ?づ?づ?づ?凝淞つュツづ可つュツづ?づつつ「ツづ?づゥツδ?ツタツ氾板債?\nint connectAB(int A, int B){\n  int d = a[A][0] - dist[B][0];\n\n  for(int i = 0; i < d - 1; i++){\n    if(i == 0){\n      t[B].push_back(m);\n      t[m].push_back(B);\n      cnt[m]++;\n      cnt[B]++;\n    }\n    else{\n      t[m].push_back(m - 1);\n      t[m - 1].push_back(m);\n      cnt[m]++;\n      cnt[m - 1]++;\n    }\n    m++;\n  }\n  cnt[m - 1]++;\n\n  return m - 1;\n}\n\n//A : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//dist[id][A]ツづ営ostツ渉堕つォツ債楪づ?\nvoid dfs(int A, int id, int cost){\n  dist[id][A] = cost;\n  used[id] = true;\n\n  for(int i = 0; i < t[id].size(); i++){\n    int to = t[id][i];\n    if(!used[to]){\n      dfs(A, to, cost + 1);\n    }\n  }\n}\n\nvoid solve(){\n  for(int i = 2; i < n; i++){\n    int connect = -1;\n\n    for(int j = 0; j < m; j++){\n      if(check(i, j)){\n        connect = j;\n        break;\n      }\n    }\n\n    near[i] = connectAB(i, connect);\n    for(int j = 0; j <= i; j++){\n      memset(used, 0, sizeof(used));\n      dfs(j, near[j], 1);\n    }\n  }\n\n  vector<int> ans;\n  for(int i = 0; i < m; i++){\n    ans.push_back(cnt[i]);\n  }\n  sort(ans.begin(), ans.end());\n\n  for(int i = 0; i < m; i++){\n    if(i != 0) cout << \" \";\n    cout << ans[i];\n  }\n  cout<<endl;\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        cin >> a[i][j];\n      }\n    }\n\n    init();\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint d[3000][3000];\n\nint N,deg[3000];\nvoid solve(int root,vector<int> V){\n\tint n=V.size();\n\tif(V.empty()) return;\n\n\t// root と u を両端とする列を作る\n\t// 残りの頂点は root-u 間にある d[root][u]+1 個の頂点のどれかにぶら下がる\n\tint u=V[0];\n\tvector<int> ch[32];\n\tfor(int i=1;i<V.size();i++){\n\t\tint v=V[i];\n\t\tch[(d[root][u]+d[root][v]-d[u][v])/2].push_back(v);\n\t}\n\n\t// 列の各頂点を根にして, 再帰的に木の形を求める\n\tint par;\n\trep(i,d[root][u]+1){\n\t\tint v; // 次の根\n\t\tif(i==0){\n\t\t\tv=root;\n\t\t}\n\t\telse if(i<d[root][u]){\n\t\t\tv=N++;\n\t\t\trep(j,ch[u].size()){\n\t\t\t\tint w=ch[u][j];\n\t\t\t\td[v][w]=d[w][v]=d[root][w]-i;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tv=u;\n\t\t}\n\n\t\tif(i!=0){\n\t\t\tdeg[par]++;\n\t\t\tdeg[ v ]++;\n\t\t}\n\n\t\tsolve(v,ch[i]);\n\n\t\tpar=v;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\trep(u,n) rep(v,n) scanf(\"%d\",d[u]+v);\n\n\t\tvector<int> V;\n\t\trep(i,n-1) V.push_back(i+1);\n\t\tN=n;\n\t\trep(u,3000) deg[u]=0;\n\t\tsolve(0,V);\n\n\t\tvector<int> ans;\n\t\trep(u,N) if(deg[u]>=2) ans.push_back(deg[u]);\n\t\tsort(ans.begin(),ans.end());\n\t\trep(i,ans.size()) printf(\"%d%c\",ans[i],i+1<ans.size()?' ':'\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint d[150][150];\n\nint N,deg[150];\nvoid solve(int root,vector<int> V){\n\tint n=V.size();\n\tif(V.empty()) return;\n\n\t// root と u を両端とする列を作る\n\t// 残りの頂点は root-u 間にある d[root][u]+1 個の頂点のどれかにぶら下がる\n\tint u=V[0];\n\tvector<int> ch[32];\n\tfor(int i=1;i<V.size();i++){\n\t\tint v=V[i];\n\t\tch[(d[root][u]+d[root][v]-d[u][v])/2].push_back(v);\n\t}\n\n\t// 列の各頂点を根にして, 再帰的に木の形を求める\n\tint par;\n\trep(i,d[root][u]+1){\n\t\tint v; // 次の根\n\t\tif(i==0){\n\t\t\tv=root;\n\t\t}\n\t\telse if(i<d[root][u]){\n\t\t\tv=N++;\n\t\t\trep(j,ch[u].size()){\n\t\t\t\tint w=ch[u][j];\n\t\t\t\td[v][w]=d[w][v]=d[root][w]-i;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tv=u;\n\t\t}\n\n\t\tif(i!=0){\n\t\t\tdeg[par]++;\n\t\t\tdeg[ v ]++;\n\t\t}\n\n\t\tsolve(v,ch[i]);\n\n\t\tpar=v;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\trep(u,n) rep(v,n) scanf(\"%d\",d[u]+v);\n\n\t\tvector<int> V;\n\t\trep(i,n-1) V.push_back(i+1);\n\t\tN=n;\n\t\trep(u,150) deg[u]=0;\n\t\tsolve(0,V);\n\n\t\tvector<int> ans;\n\t\trep(u,N) if(deg[u]>=2) ans.push_back(deg[u]);\n\t\tsort(ans.begin(),ans.end());\n\t\trep(i,ans.size()) printf(\"%d%c\",ans[i],i+1<ans.size()?' ':'\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define MAX 1000\n\nint n, m; //ツノ-ツドツ青? ツδ?ツタツ青?\nint a[52][52];\nint dist[MAX][MAX]; //ツδ?ツタiツつゥツづァツノ-ツドjツづ慊づ?づ個仰猟猟」\nint cnt[MAX]; //ツδ?ツタiツづ個篠淞青?\nint near[MAX]; //ツノ-ツドツづ個暗ェツ氾板凝淞つュツづ可つ?づゥツδ?ツタツづ個氾板債?\nbool used[MAX];\n\nvector<int> t[MAX];\n\nvoid init(){\n  m = 0;\n  memset(dist, -1, sizeof(dist));\n  memset(cnt, 0, sizeof(cnt));\n  memset(near, -1, sizeof(near));\n\n  for(int i = 0; i < MAX; i++){\n    t[i].clear();\n  }\n\n  near[0] = 0;\n  near[1] = a[0][1] - 2;\n\n  //1ツ妥、ツ姪堋づ?ツ妥、ツ姪堋づ個甘板つセツつッツ陛環渉按猟?\n  for(int i = 0; i < a[0][1] - 1; i++){\n    cnt[i] = 2;\n    dist[i][0] = i + 1;\n    dist[i][1] = a[0][1] - dist[i][0];\n    m++;\n\n    if(i < a[0][1] - 2){\n      t[i].push_back(i + 1);\n      t[i + 1].push_back(i);\n    }\n  }\n}\n\nvoid show(){\n  cout<<\"---------------------------------------------\\n\";\n  cout<<\"--dist table---------------------------------\\n\";\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++){\n      printf(\"%3d\", dist[i][j]);\n    }\n\n    cout<<\"    \";\n    printf(\"%3d\",cnt[i]);\n    cout<<endl;\n  }\n\n  cout<<\"--near router--------------------------------\\n\";\n  for(int i = 0; i < n; i++){\n    cout << \"node \" << i<<\" : \";\n    cout << near[i] << endl;\n  }\n\n  cout<<\"--router graph-------------------------------\\n\";\n\n  for(int i = 0; i < m; i++){\n    cout<<i<<\" : \";\n    for(int j = 0; j < t[i].size(); j++){\n      cout << t[i][j] << \", \";\n    }\n    cout<<endl;\n  }\n}\n\n//to : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//id : ツδ?ツタツ氾板債?\nbool check(int to, int id){\n  int diff = a[to][0] - dist[id][0];\n\n  for(int i = 1; i < to; i++){\n    if(diff != a[to][i] - dist[id][i]){\n      return false;\n    }\n  }\n\n  return true;\n}\n\n//A : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//B : Aツづーツづつづ按つーツづゥツδ?ツタツ氾板債?\n//return : ツノ-ツドAツづ個づ?づ?づ?づ?凝淞つュツづ可つュツづ?づつつ「ツづ?づゥツδ?ツタツ氾板債?\nint connectAB(int A, int B){\n  int d = a[A][0] - dist[B][0];\n\n  if(d == 1){\n    cnt[B]++;\n    return B;\n  }\n\n  for(int i = 0; i < d - 1; i++){\n    if(i == 0){\n      t[B].push_back(m);\n      t[m].push_back(B);\n      cnt[m]++;\n      cnt[B]++;\n    }\n    else{\n      t[m].push_back(m - 1);\n      t[m - 1].push_back(m);\n      cnt[m]++;\n      cnt[m - 1]++;\n    }\n    m++;\n  }\n  cnt[m - 1]++;\n\n  return m - 1;\n}\n\n//A : ツ新ツつオツつュツ津?嘉?つキツづゥツノ-ツドツ氾板債?\n//dist[id][A]ツづ営ostツ渉堕つォツ債楪づ?\nvoid dfs(int A, int id, int cost){\n  dist[id][A] = cost;\n  used[id] = true;\n\n  for(int i = 0; i < t[id].size(); i++){\n    int to = t[id][i];\n    if(!used[to]){\n      dfs(A, to, cost + 1);\n    }\n  }\n}\n\nvoid solve(){\n  for(int i = 2; i < n; i++){\n    int connect = -1;\n\n    for(int j = 0; j < m; j++){\n      if(check(i, j)){\n        connect = j;\n        break;\n      }\n    }\n\n    //cout<<\"connect : \" << connect<<endl;\n\n    near[i] = connectAB(i, connect);\n    for(int j = 0; j <= i; j++){\n      memset(used, 0, sizeof(used));\n      dfs(j, near[j], 1);\n    }\n  }\n\n  vector<int> ans;\n  for(int i = 0; i < m; i++){\n    ans.push_back(cnt[i]);\n  }\n  sort(ans.begin(), ans.end());\n\n  for(int i = 0; i < m; i++){\n    if(i != 0) cout << \" \";\n    cout << ans[i];\n  }\n  cout<<endl;\n}\n\nint validate_dfs(int from, int to, int cost){\n  used[from] = true;\n  if(from == to){\n    return cost;\n  }\n\n  for(int i = 0; i < t[from].size(); i++){\n    int TO = t[from][i];\n    if(!used[TO]){\n      int tmp = validate_dfs(TO, to, cost + 1);\n      if(tmp != -1) return tmp;\n    }\n  }\n\n  return -1;\n}\n\nbool validate(){\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < i; j++){\n      if(near[i] == -1 || near[j] == -1) return false;\n      memset(used,0,sizeof(used));\n      //printf(\"%d(%d) --> %d(%d)\\n\", near[i], i,near[j], j);\n      if(validate_dfs(near[i], near[j], 2) != a[i][j]){\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        cin >> a[i][j];\n      }\n    }\n\n    init();\n    solve();\n\n    //cout << (validate() ? \"yes\" : \"no\") << endl;\n    //show();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nint a[55][55];\nint b[1111][1111];\n\nvector<int> sw[1111];\n\nvoid print()\n{\n  for(int i = 0; i < N+M; i++) {\n    for(int j = 0; j < N+M; j++) cout << b[i][j] << \" \";\n    cout << endl;\n  }\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(a, 0, sizeof(a));\n    memset(b, 0, sizeof(b));\n    for(int i = 0; i < 55; i++) sw[i].clear();\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> a[i][j];\n\tb[i][j] = a[i][j];\n      }\n    }\n    M = 0;\n    sw[0].push_back(0);\n    for(int i = 0; i < a[0][1]-2; i++) {\n      sw[M].push_back(N+M+1);\n      sw[M+1].push_back(N+M);\n      M++;\n    }\n    sw[M].push_back(1);\n    M++;\n    for(int i = 0; i < M; i++) {\n      b[0][N+i] = b[N+i][0] = i+1;\n      b[1][N+i] = b[N+i][1] = a[0][1]-i-1;\n      for(int j = 0; j < M; j++) b[N+i][N+j] = b[N+j][N+i] = abs(i-j);\n    }\n    for(int i = 2; i < N; i++) {\n      bool judge = false;\n      for(int j = 0; j < M; j++) {\n\tbool flag = false;\n\tfor(int k = 0; k < i; k++) {\n\t  if(b[N+j][k] + 1 != b[k][i]) flag = true;\n\t}\n\tif(flag) continue;\n\tsw[j].push_back(i);\n\tfor(int k = 0; k < M; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + 1;\n\tjudge = true;\n\tbreak;\n      }\n      if(!judge) {\n\tfor(int j = 0; j < M; j++) {\n\t  bool check = false;\n\t  for(int k = 0; k < i-1; k++) {\n\t    if(b[i][k] - b[N+j][k] != b[i][k+1] - b[N+j][k+1]) check = true;\n\t  }\n\t  if(check) continue;\n\t  int m = M;\n\t  sw[j].push_back(N+M);\n\t  sw[M].push_back(j);\n\t  for(int k = 0; k < b[i][0]-b[N+j][0]-2; k++) {\n\t    sw[M].push_back(N+M+1);\n\t    sw[M+1].push_back(N+M);\n\t    M++;\n\t  }\n\t  sw[M].push_back(i);\n\t  M++;\n\t  for(int k = m; k < M; k++) {\n\t    for(int l = 0; l < i; l++) b[l][N+k] = b[N+k][l] = b[l][N+j] + k-m+1;\n\t    for(int l = m; l < M; l++) b[N+k][N+l] = b[N+l][N+k] = abs(k-l);\n\t  }\n\t  for(int k = m; k < M; k++) {\n\t    b[N+j][N+k] = b[N+k][N+j] = k-m+1;\n\t    b[i][N+k] = b[N+k][i] = M-k;\n\t    for(int l = 0; l < m; l++) b[N+l][N+k] = b[N+k][N+l] = b[N+j][N+l] + b[N+j][N+k];\n\t  }\n\t  for(int k = 0; k < m; k++) b[i][N+k] = b[N+k][i] = b[N+j][N+k] + b[N+j][N+M-1] + 1;\n\t  break;\n\t}\n      }\n    }\n    vector<int> ans;\n    for(int i = 0; i < M; i++) ans.push_back(sw[i].size());\n    sort(ans.begin(), ans.end());\n    for(int i = 0; i < M; i++) cout << ans[i] << (i==M-1 ? '\\n' : ' ');\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint d[1500][1500];\n\nint N,deg[1500];\nvoid solve(int root,vector<int> V){\n\tint n=V.size();\n\tif(V.empty()) return;\n\n\t// root と u を両端とする列を作る\n\t// 残りの頂点は root-u 間にある d[root][u]+1 個の頂点のどれかにぶら下がる\n\tint u=V[0];\n\tvector<int> ch[32];\n\tfor(int i=1;i<V.size();i++){\n\t\tint v=V[i];\n\t\tch[(d[root][u]+d[root][v]-d[u][v])/2].push_back(v);\n\t}\n\n\t// 列の各頂点を根にして, 再帰的に木の形を求める\n\tint par;\n\trep(i,d[root][u]+1){\n\t\tint v; // 次の根\n\t\tif(i==0){\n\t\t\tv=root;\n\t\t}\n\t\telse if(i<d[root][u]){\n\t\t\tv=N++;\n\t\t\trep(j,ch[u].size()){\n\t\t\t\tint w=ch[u][j];\n\t\t\t\td[v][w]=d[w][v]=d[root][w]-i;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tv=u;\n\t\t}\n\n\t\tif(i!=0){\n\t\t\tdeg[par]++;\n\t\t\tdeg[ v ]++;\n\t\t}\n\n\t\tsolve(v,ch[i]);\n\n\t\tpar=v;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\trep(u,n) rep(v,n) scanf(\"%d\",d[u]+v);\n\n\t\tvector<int> V;\n\t\trep(i,n-1) V.push_back(i+1);\n\t\tN=n;\n\t\trep(u,1500) deg[u]=0;\n\t\tsolve(0,V);\n\n\t\tvector<int> ans;\n\t\trep(u,N) if(deg[u]>=2) ans.push_back(deg[u]);\n\t\tsort(ans.begin(),ans.end());\n\t\trep(i,ans.size()) printf(\"%d%c\",ans[i],i+1<ans.size()?' ':'\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_N = 50;\n\nint dist[MAX_N][MAX_N];\n\nint base_dist[MAX_N];\nvector<int> ans;\n\nvoid rec(const vector<int> &nodes, bool is_root = true) {\n\tif(nodes.size() == 1) {\n\t\tif(is_root) --base_dist[nodes.front()];\n\t\tfor(int i = 0; i < base_dist[nodes.front()]; ++i) {\n\t\t\tans.emplace_back(2);\n\t\t}\n\t\treturn;\n\t}\n\n\tvector<vector<int>> subtree;\n\tfor(const auto &v : nodes) {\n\t\tfor(auto &vec : subtree) {\n\t\t\tconst int u = vec.front();\n\t\t\tconst int d = dist[v][u] - (base_dist[v] + base_dist[u]);\n\t\t\tif(d < 0) {\n\t\t\t\tvec.emplace_back(v);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\n\t\tsubtree.emplace_back(vector<int>{v});\n\tnext:;\n\t}\n\n\tfor(const auto &v : nodes) {\n\t\t--base_dist[v];\n\t}\n\n\tfor(const auto &e : subtree) {\n\t\trec(e, false);\n\t}\n\n\tif(!is_root) ans.emplace_back(subtree.size() + 1);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tcin >> dist[i][j];\n\t\t\t}\n\t\t}\n\n\t\tconst int base = 0;\n\n\t\tvector<int> nodes;\n\t\tnodes.reserve(n - 1);\n\n\t\tfor(int v = 1; v < n; ++v) {\n\t\t\tbase_dist[v] = dist[base][v];\n\t\t\tnodes.emplace_back(v);\n\t\t}\n\n\t\tans.clear();\n\n\t\trec(nodes);\n\n\t\tsort(ans.begin(), ans.end());\n\t\tfor(unsigned i = 0; i < ans.size(); ++i) {\n\t\t\tcout << ans[i] << (i + 1 == ans.size() ? '\\n' : ' ');\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint cost[2500*30][52];\nint cnt = 0;\nint N;\nint A[52][51];\nvector<int>G[2500*30];\nvoid connect(int x,int y,int num){\n  int p = x;\n  for(int i=0;i<num-1;i++){\n    G[p].push_back( cnt );\n    G[cnt].push_back( p );\n    p = cnt++;\n  }\n  G[p].push_back( y );\n  G[y].push_back( p );\n}\n\nvoid update(int id){\n  queue<int> q;\n  q.push( id );\n  cost[id][id] = 0;\n  while( !q.empty() ){\n    int p = q.front();  q.pop();\n    for(int i=0;i<(int)G[p].size();i++){\n      int to = G[p][i];\n      if( cost[to][id] == -1 ) {\n        cost[to][id] = cost[p][id]+1;\n        //         cout <<\"cost \" <<  to << \" \"<<id<< \" \"<< cost[to][id] << endl;\n        q.push( to );\n      }\n    }\n  }\n}\n\nint check(int x,int y){\n  int c = A[x][0];\n  int pc = cost[y][0];\n  int comp = c - pc;\n  //  cout << \"check \" << x << \" \"<< y << endl;\n  // cout << c << \" \"<< pc << \" \" << comp << endl;\n  if( pc < 0 || comp < 1 ) return 0;\n  for(int i=1;i<x;i++){\n    c = A[x][i];\n    pc = cost[y][i];\n    //cout << i << \" : \" << c << \" \"<< pc << \" \" << c - pc << endl;\n    if( comp != c - pc ) return 0;\n  }\n  return comp;\n}\n\nvoid solve(){\n  connect(0,1,A[0][1]);\n  for(int i=2;i<N;i++){\n    memset(cost,-1,sizeof(cost));\n    for(int j=0;j<i;j++) update(j);\n    for(int j=N;j<cnt;j++){\n      int sc = check(i,j);\n      if( sc ) {\n        connect(i,j,sc);\n        break;\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> N&&N){\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n        cin >> A[i][j];      \n    cnt = N;\n    solve();\n    vector<int> ans;\n\n    /* \n    cout << \"debug \" << endl;\n    for(int i=0;i<cnt;i++){\n      cout << \"node : \" << i << endl;\n      for(int j=0;j<(int)G[i].size();j++){\n        cout << \" - > \" << G[i][j] << endl;\n      }\n    }\n    */\n\n    for(int i=0;i<N;i++) G[i].clear();\n    for(int i=N;i<cnt;i++){\n      ans.push_back(G[i].size());\n      G[i].clear();\n    }\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      if( i ) cout << \" \";\n      cout << ans[i];\n    }\n    cout << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200\nusing namespace std;\nint n,id[N][N],num;\nvector<int> e[N];\nint d[N];\n\nvoid dfs(int pos,int dep,int prev){\n  d[pos]=dep;\n  for(int i=0;i<(int)e[pos].size();i++){\n    int npos=e[pos][i];\n    if(npos!=prev)dfs(npos,dep+1,pos);\n  }\n}\n\nvoid add(int a){\n  for(int i=n;i<=num;i++){\n    dfs(i,0,-1);\n    int f=0;\n    for(int j=0;j<a;j++){\n      if(id[a][0]-d[0]!=id[j][a]-d[j])f=1;\n    }\n    if(f)continue;\n    if(id[a][0]-d[0]==1){\n      e[i].push_back(a);\n      e[a].push_back(i);\n      return;\n    }\n    int cnt=2;\n    e[i].push_back(num+1);\n    e[num+1].push_back(i);\n    num++;\n    while(++cnt<id[a][1]-d[i]){\n      e[num].push_back(num+1);\n      e[num+1].push_back(num);\n      num++;\n    }\n    e[num].push_back(a);\n    e[a].push_back(num);\n    return ;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcin>>id[i][j];\n    int cnt=1;\n    e[0].push_back(n);\n    e[n].push_back(0);\n    num=n;\n    while(++cnt<id[0][1]){\n      e[num].push_back(num+1);\n      e[num+1].push_back(num);\n      num++;\n    }\n    e[num].push_back(1);\n    e[1].push_back(num);\n    for(int i=2;i<n;i++)add(i);\n    vector<int> ans;\n    for(int i=n;i<=num;i++)\n      ans.push_back(e[i].size());\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<(int)ans.size();i++){\n      if(i)cout<<' ';\n      cout<<ans[i];\n    }\n    cout<<endl;\n    ans.clear();\n    for(int i=0;i<=num;i++)e[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_N = 30;\n\nint dist[MAX_N][MAX_N];\n\nint base_dist[MAX_N];\nvector<int> ans;\n\nbool rec(const vector<int> &nodes) {\n\tif(nodes.size() == 1) {\n\t\tfor(int i = 0; i < base_dist[nodes.front()] - 1; ++i) {\n\t\t\tans.emplace_back(2);\n\t\t}\n\t\treturn false;\n\t}\n\n\tint end_point;\n\tint max_base_dist = 0;\n\tfor(const auto &v : nodes) {\n\t\tif(max_base_dist < base_dist[v]) {\n\t\t\tend_point = v;\n\t\t\tmax_base_dist = base_dist[v];\n\t\t}\n\t}\n\n\tint longest_point = -1;\n\tint longest = max_base_dist;\n\tfor(const auto &v : nodes) {\n\t\tconst int d = (dist[v][end_point] + base_dist[end_point] - base_dist[v]) / 2;\n\t\tif(longest < d + 1) {\n\t\t\tlongest = d + 1;\n\t\t\tlongest_point = v;\n\t\t}\n\t}\n\n\tvector<vector<int>> pos(longest - 1);\n\tfor(const auto &v : nodes) {\n\t\tif(v == end_point || v == longest_point) continue;\n\n\t\tconst int d = (dist[v][end_point] + base_dist[end_point] - base_dist[v]) / 2;\n\t\tpos[d - 1].emplace_back(v);\n\t\tbase_dist[v] = dist[v][end_point] - d;\n\t}\n\n\tfor(int i = 0; i < longest - 1; ++i) {\n\t\tif(i + 1 == max_base_dist) continue;\n\n\t\tif(pos[i].empty()) {\n\t\t\tans.emplace_back(2);\n\t\t}\n\t\telse if(rec(pos[i])) {\n\t\t\tans.emplace_back(4);\n\t\t}\n\t\telse {\n\t\t\tans.emplace_back(3);\n\t\t}\n\t}\n\n\treturn max_base_dist < longest;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tcin >> dist[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint base;\n\t\tint max_dist = 0;\n\n\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(max_dist < dist[i][j]) {\n\t\t\t\t\tbase = i;\n\t\t\t\t\tmax_dist = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> nodes;\n\t\tnodes.reserve(n);\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(v == base) continue;\n\n\t\t\tbase_dist[v] = dist[base][v];\n\t\t\tnodes.emplace_back(v);\n\t\t}\n\n\t\tans.clear();\n\n\t\trec(nodes);\n\n\t\tsort(ans.begin(), ans.end());\n\t\tfor(unsigned i = 0; i < ans.size(); ++i) {\n\t\t\tcout << ans[i] << (i + 1 == ans.size() ? '\\n' : ' ');\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;};\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;};\n\n\nInt n;\nInt a[55][55];\nsigned main(){\n  while(cin>>n,n){\n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<n;j++)\n\tcin>>a[i][j];\n\n    vector<vector<Int> > G(n+10000);\n    Int x=0,y=0;\n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<n;j++)\n\tif(a[x][y]<a[i][j]) x=i,y=j;\n\n    auto add_edge=[&](Int x,Int y){\n      G[x].emplace_back(y);\n      G[y].emplace_back(x);\n    };\n    \n    Int m=n;\n    {\n      Int lst=x;\n      for(Int k=0;k+1<a[x][y];k++){\n\tadd_edge(lst,m);\n\tlst=m++;\n      }\n      add_edge(lst,y);\n    };\n    vector<Int> dist,dp;\n    auto bfs=[&](Int x){\n      dp.assign(m,-1);\n      queue<Int> q;\n      dp[x]=0;\n      q.emplace(x);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(~dp[u]) continue;\n\t  dp[u]=dp[v]+1;\n\t  q.emplace(u);\n\t}\n      }\n    };\n\n    vector<Int> fin({x,y});\n    for(Int t=0;t<n;t++){\n      if(t==x||t==y) continue;\n      bfs(x);\n      dist=dp;\n      for(Int z:fin){\n\tbfs(z);\n\tfor(Int i=0;i<m;i++){\n\t  if(dist[i]<0) continue;\n\t  if(a[t][x]-dist[i]!=a[t][z]-dp[i]) dist[i]=-2;\n\t}\n      }\n\n      Int lst=-1;\n      for(Int i=0;i<m;i++) if(dist[i]>=0) lst=i;\n      Int di=a[t][x]-dist[lst];\n      for(Int k=0;k+1<di;k++){\n\tadd_edge(lst,m);\n\tlst=m++;\n      }\n      add_edge(lst,t);\n      fin.emplace_back(t);\n    }\n    vector<Int> ans;\n    for(Int i=n;i<m;i++)\n      ans.emplace_back(G[i].size());\n    sort(ans.begin(),ans.end());\n    for(Int i=0;i<(Int)ans.size();i++){\n      if(i) cout<<\" \";\n      cout<<ans[i];\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\n\nconst int INF = 1000000000;\n\nint add(Graph& G, int u){\n    int v = G.size();\n    G[u].push_back(v);\n    G.push_back(Node());\n    G[v].push_back(u);\n    return v;\n}\nvoid bellman_ford(const Graph& G, int s, int dist[1000]){\n    dist[s] = 0;\n    bool update = true;\n    while(update){\n        update = false;\n        for(int i = 0; i < G.size(); i++){\n            for(int j = 0; j < G[i].size(); j++){\n                int k = G[i][j];\n                if(dist[k] > dist[i] + 1){\n                    dist[k] = dist[i] + 1;\n                    update = true;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin >> N && N){\n        int d[100][100] = {};\n        int dist[100][1000] = {};\n        REP(i, 100) fill(dist[i], dist[i] + 1000, INF);\n        int start[100] = {};\n        REP(i, N) REP(j, N) cin >> d[i][j];\n        REP(i, N) REP(j, N) d[i][j] -= 2;\n\n        Graph G;\n        G.push_back(Node());\n        start[0] = 0;\n        dist[0][0] = 0;\n\n        for(int i = 1; i < N; i++){\n            vector<int> v;\n            for(int j = 0; j < i; j++){\n                v.push_back(d[i][j]);\n            }\n\n            int u = -1;\n            int len = -1;\n            for(int j = 0; j < G.size(); j++){\n                set<int> s;\n                for(int k = 0; k < v.size(); k++){\n                    s.insert(v[k] - dist[k][j]);\n                }\n                if(s.size() == 1){\n                    u = j;\n                    len = *s.begin();\n                }\n            }\n\n            assert(u != -1);\n            assert(len >= 0);\n            while(len--){\n                u = add(G, u);\n            }\n            start[i] = u;\n            //printf(\"start[%d] = %d\\n\", i, u);\n\n            for(int j = 0; j <= i; j++){\n                bellman_ford(G, start[j], dist[j]);\n            }\n        }\n        vector<int> ans;\n        for(int i = 0; i < G.size(); i++){\n            ans.push_back(G[i].size());\n        }\n        for(int i = 0; i < N; i++){\n            ans[ start[i] ]++;\n        }\n        sort(ans.begin(), ans.end());\n        for(int i = 0; i < ans.size(); i++){\n            cout << ans[i];\n            if(i == ans.size() - 1) cout << endl;\n            else cout << \" \";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 1000000000000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 2000\n\nstruct Node{\n\tvoid set(bool arg_is_leaf,int arg_comp_id){\n\t\tis_leaf = arg_is_leaf;\n\t\tcomp_id = arg_comp_id;\n\t}\n\tbool is_leaf;\n\tint comp_id;\n};\n\nint N;\nint table[55][55];\nint dist_table[SIZE][55]; //dist_table[swicthのnodes上のindex][compのid] = compからの距離\nint num_nodes;\nint num_leaf,num_switch;\nint loc[55];\nint num_adj[SIZE],adj_list[SIZE][SIZE];\nint leaf_index[55],switch_index[SIZE];\nbool FLG;\nvector<int> ans;\nNode nodes[SIZE];\n\n\n\nvoid calc_dist(int base_num,int node_id,int pre,int dist){\n\n\tif(!nodes[node_id].is_leaf){\n\n\t\tdist_table[node_id][base_num] = dist; //★★距離テーブルはコンピュータのidそのもの★★\n\t}\n\n\tfor(int i = 0; i < num_adj[node_id]; i++){\n\n\t\tint next = adj_list[node_id][i];\n\t\tif(next == pre)continue;\n\n\t\tcalc_dist(base_num,next,node_id,dist+1);\n\t}\n}\n\nvoid recursive(int num_rest){\n\tif(FLG)return;\n\n\tif(num_rest == 0){\n\t\tFLG = true;\n\t\tfor(int i = 0; i < num_nodes; i++){\n\t\t\tif(!nodes[i].is_leaf){\n\t\t\t\tans.push_back(num_adj[i]);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tint new_node = -1;\n\n\t//新しいノードを1つ選ぶ\n\tfor(int i = 0; i < N; i++){\n\t\tif(loc[i] == -1){\n\n\t\t\tnew_node = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//辻褄の合うswitchを全部試す\n\tfor(int i = 0; i < num_switch; i++){\n\n\t\tint tmp_switch = switch_index[i];\n\t\tbool FLG = true;\n\t\tint tmp = -1;\n\n\t\tfor(int k = 0; k < num_leaf; k++){\n\n\t\t\tint comp_id = nodes[leaf_index[k]].comp_id;\n\t\t\tint diff = table[comp_id][new_node]-dist_table[tmp_switch][comp_id];\n\n\t\t\tif(diff <= 0){\n\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(tmp == -1){\n\n\t\t\t\ttmp = diff;\n\t\t\t}else{\n\t\t\t\tif(tmp != diff){ //追加するべきパスの長さが一意にならないと不可\n\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//continue;\n\n\t\tif(FLG){ //tmp_swichから,tmp-1個のswitchを伸ばし、その先にnew_nodeを張る\n\n\t\t\tint pre_num_nodes = num_nodes;\n\t\t\tint pre_num_switch = num_switch;\n\n\t\t\tif(tmp-1 > 0){\n\n\t\t\t\tint add = 1;\n\n\t\t\t\tadj_list[tmp_switch][num_adj[tmp_switch]++] = num_nodes;\n\t\t\t\tadj_list[num_nodes][num_adj[num_nodes]++] = tmp_switch;\n\n\t\t\t\tnodes[num_nodes].set(false,-1);\n\t\t\t\t//距離表を更新\n\t\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\t\tif(dist_table[tmp_switch][a] == BIG_NUM)continue;\n\t\t\t\t\tdist_table[num_nodes][a] = dist_table[tmp_switch][a]+add;\n\t\t\t\t}\n\t\t\t\tadd++;\n\n\t\t\t\tswitch_index[num_switch++] = num_nodes;\n\t\t\t\tnum_nodes++;\n\n\t\t\t\tfor(int k = 0; k < tmp-2; k++){\n\n\t\t\t\t\tadj_list[num_nodes-1][num_adj[num_nodes-1]++] = num_nodes;\n\t\t\t\t\tadj_list[num_nodes][num_adj[num_nodes]++] = num_nodes-1;\n\n\t\t\t\t\tnodes[num_nodes].set(false,-1);\n\t\t\t\t\t//距離表を更新\n\t\t\t\t\tfor(int a = 0; a < N; a++){\n\t\t\t\t\t\tif(dist_table[tmp_switch][a] == BIG_NUM)continue;\n\t\t\t\t\t\tdist_table[num_nodes][a] = dist_table[tmp_switch][a]+add;\n\t\t\t\t\t}\n\t\t\t\t\tadd++;\n\n\t\t\t\t\tswitch_index[num_switch++] = num_nodes;\n\t\t\t\t\tnum_nodes++;\n\t\t\t\t}\n\n\t\t\t\t//new_nodeへの辺を張る\n\t\t\t\tadj_list[num_nodes-1][num_adj[num_nodes-1]++] = num_nodes;\n\t\t\t\tadj_list[num_nodes][num_adj[num_nodes]++] = num_nodes-1;\n\n\t\t\t\tnodes[num_nodes].set(true,new_node);\n\t\t\t\tleaf_index[num_leaf] = num_nodes;\n\t\t\t\tloc[new_node] = num_nodes;\n\n\t\t\t\tnum_leaf++;\n\t\t\t\tnum_nodes++;\n\n\t\t\t}else{ //tmp-1 == 0\n\n\t\t\t\t//new_nodeへの辺を張る\n\t\t\t\tadj_list[tmp_switch][num_adj[tmp_switch]++] = num_nodes;\n\t\t\t\tadj_list[num_nodes][num_adj[num_nodes]++] = tmp_switch;\n\n\t\t\t\tnodes[num_nodes].set(true,new_node);\n\t\t\t\tleaf_index[num_leaf] = num_nodes;\n\t\t\t\tloc[new_node] = num_nodes;\n\n\t\t\t\tnum_leaf++;\n\t\t\t\tnum_nodes++;\n\t\t\t}\n\n\t\t\tcalc_dist(new_node,loc[new_node],-1,0);\n\t\t\trecursive(num_rest-1);\n\n\t\t\tfor(int i = pre_num_nodes; i < num_nodes; i++){\n\n\t\t\t\tnum_adj[i] = 0;\n\t\t\t}\n\t\t\tnum_adj[tmp_switch]--;\n\n\t\t\tnum_switch = pre_num_switch;\n\t\t\tnum_nodes = pre_num_nodes;\n\n\t\t\tnum_leaf--;\n\t\t\tloc[new_node] = -1;\n\t\t}\n\t}\n}\n\n\nvoid func(){\n\n\tFLG = false;\n\tnum_nodes = 0;\n\tnum_leaf = 0;\n\tnum_switch = 0;\n\tans.clear();\n\n\tfor(int i = 0; i < SIZE; i++){\n\n\t\tnum_adj[i] = 0;\n\t}\n\tfor(int i = 0; i < N; i++){\n\n\t\tloc[i] = -1; //逆引き表\n\t}\n\tfor(int i = 0; i < SIZE; i++){\n\t\tfor(int k = 0; k < N; k++){\n\n\t\t\tdist_table[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\n\tint a,b,max_dist = 0;\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++){\n\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t\tif(max_dist < table[row][col]){\n\t\t\t\tmax_dist = table[row][col];\n\t\t\t\ta = min(row,col);\n\t\t\t\tb = max(row,col);\n\t\t\t}\n\t\t}\n\t}\n\n\t//a-b間にmax_dist-1個のswitchを配置\n\tnodes[0].set(true,a);\n\tleaf_index[0] = 0; //★★nodes上のindex★★\n\tloc[a] = 0;\n\tnum_nodes = 1;\n\n\tfor(int i = 1; i <= max_dist-1; i++){\n\n\t\tadj_list[i-1][num_adj[i-1]++] = i; //左隣の隣接に自分を追加\n\t\tadj_list[i][num_adj[i]++] = i-1; //自分の隣接に左隣を追加\n\n\n\t\tnodes[i].set(false,-1);\n\t\tswitch_index[num_switch++] = i;\n\t\tnum_nodes++;\n\t}\n\tnodes[num_nodes].set(true,b);\n\tloc[b] = num_nodes;\n\tleaf_index[1] = num_nodes;\n\n\tadj_list[num_nodes-1][num_adj[num_nodes-1]++] = num_nodes;\n\tadj_list[num_nodes][num_adj[num_nodes]++] = num_nodes-1;\n\n\tnum_nodes++;\n\n\tnum_leaf = 2;\n\n\tcalc_dist(a,loc[a],-1,0);\n\tcalc_dist(b,loc[b],-1,0);\n\n\trecursive(N-2);\n\n\tsort(ans.begin(),ans.end());\n\tprintf(\"%d\",ans[0]);\n\tfor(int i = 1; i < ans.size(); i++){\n\n\t\tprintf(\" %d\",ans[i]);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 50 * 50 * 30;\nconst int IINF = INT_MAX;\n\nstruct Edge { int src,dst; };\nvector<Edge> G[MAX_V];\nvector<int> computer;\nint n,V,mat[61][61];\n\nvoid dfs(int cur,int prev,int depth,vector<int> &mindist){\n\n  rep(i,computer.size()) {\n    if( computer[i] == -1 ) break;\n    assert( i < mindist.size() );\n    if( cur == computer[i] ) { assert( mindist[i] == IINF); mindist[i] = depth; }\n  }\n\n  rep(i,G[cur].size()){\n    int next = G[cur][i].dst;\n    if( next == prev ) continue;\n    dfs(next,cur,depth+1,mindist);\n  }\n\n}\n\nvoid compute(){\n  computer.clear();\n  computer.resize(n,-1);\n  computer[0] = 0;\n  V = 1;\n  REP(i,1,n) {\n    bool update = false; // for debug\n    rep(candidate,V) {\n      vector<int> mindist(i,IINF);\n      dfs(candidate,-1,0,mindist);\n      assert( mindist[0] != IINF );\n      int add_length = -1;\n      rep(j,i){\n        int length = mat[i][j] - mindist[j];\n        if( length <= 0 ) { add_length = -1; break; }\n        if( add_length == -1 ) add_length = length;\n        else if( add_length != length ) { add_length = -1; break; }\n      }\n      if( add_length != -1 ) {\n        // add_length ????????????????????????\n        // ????????????????????????????????? i ?????????????????\\??????\n        int prev = candidate;\n        rep(k,add_length){\n          G[prev].push_back((Edge){prev,V});\n          G[V].push_back((Edge){V,prev});\n          prev = V;\n          ++V;\n        }\n        computer[i] = V-1;\n        update = true;\n        break;\n      }\n    }\n    assert( update );\n  }\n  set<int> S;\n  rep(i,n) S.insert(computer[i]);\n  vector<int> answer;\n  rep(i,V) if( !S.count(i) ) answer.push_back(G[i].size());\n  sort(answer.begin(),answer.end());\n  rep(i,answer.size()){\n    if( i ) printf(\" \");\n    printf(\"%d\",answer[i]);\n  } puts(\"\");\n}\n\nint main(){\n  while( scanf(\"%d\",&n), n ){\n    rep(i,MAX_V) G[i].clear();\n    rep(i,n) rep(j,n) scanf(\"%d\",&mat[i][j]);\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define INF 105\n\nusing namespace std;\nvector <int> vec[INF*INF];\nint dis[INF][INF],Dif[INF],Dfn,Du[INF*INF],MAXN=5000;\nbool vis[INF*INF];\nvoid Pre_vec(int i,int j)\n{\n    vec[i].push_back(j),vec[j].push_back(i);\n    if (i<MAXN) Du[i]++;\n    if (j<MAXN) Du[j]++;\n}\nvoid Pre_node()\n{\n    int i;\n    for (Dfn=0,i=1;i+1<dis[1][2];i++)\n        Pre_vec(i,i+1); Dfn=i;\n    Pre_vec(1,1+MAXN),Pre_vec(i,2+MAXN);\n}\nvoid dfs(int n,int dis)\n{\n    if (n>MAXN) {\n        Dif[n-MAXN]=dis; return ;\n    }\n    int i,j,siz=vec[n].size();\n    for (i=vis[n]=0;i<siz;i++)\n        if (vis[j=vec[n][i]])\n            dfs(j,dis+1);\n}\nvoid Pre_dfs(int n)\n{\n    memset(vis,true,sizeof(vis));\n    dfs(n,0);\n}\nint Check(int n)\n{\n    int i,dif=dis[n][1]-Dif[1];\n    for (i=2;i<n;i++)\n        if (dif!=dis[n][i]-Dif[i])\n            return 0;\n    return dif;\n}\nvoid Inc_node(int n)\n{\n    int i,j,dif;\n    for (i=1;i<=Dfn;i++)\n        if (Pre_dfs(i),dif=Check(n),dif)\n            break;\n    if (dif==1) {\n        Pre_vec(i,n+MAXN); return ;\n    }\n    Pre_vec(i,++Dfn);\n    for (j=1;j+1<dif;j++)\n        Pre_vec(Dfn,Dfn+1),++Dfn;\n    Pre_vec(Dfn,n+MAXN);\n}\nint main()\n{\n    int i,j,n;\n    while (scanf(\"%d\",&n),n)\n    {\n        memset(Du,0,sizeof(Du));\n        for (i=1;i<=n;i++)\n            for (j=1;j<=n;j++)\n                scanf(\"%d\",&dis[i][j]);\n        Pre_node();\n        for (i=3;i<=n;i++)\n            Inc_node(i);\n        for (sort(Du+1,Du+Dfn+1),i=1;i<=Dfn;i++)\n            printf(\"%d%c\",Du[i],i==Dfn?'\\n':' '),vec[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <numeric>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_N = 30;\n\nint dist[MAX_N][MAX_N];\n\nint base_dist[MAX_N];\nvector<int> ans;\n\nbool rec(const vector<int> &nodes) {\n\tif(nodes.size() == 1) {\n\t\tfor(int i = 0; i < base_dist[nodes.front()] - 1; ++i) {\n\t\t\tans.emplace_back(2);\n\t\t}\n\t\treturn false;\n\t}\n\n\tint end_point;\n\tint max_base_dist = 0;\n\tfor(const auto &v : nodes) {\n\t\tif(max_base_dist < base_dist[v]) {\n\t\t\tend_point = v;\n\t\t\tmax_base_dist = base_dist[v];\n\t\t}\n\t}\n\n\tint longest_point = -1;\n\tint longest = max_base_dist;\n\tfor(const auto &v : nodes) {\n\t\tconst int d = (dist[v][end_point] + base_dist[end_point] - base_dist[v]) / 2;\n\t\tif(longest < d + 1) {\n\t\t\tlongest = d + 1;\n\t\t\tlongest_point = v;\n\t\t}\n\t}\n\n\tvector<vector<int>> pos(longest - 1);\n\tfor(const auto &v : nodes) {\n\t\tif(v == end_point || v == longest_point) continue;\n\n\t\tconst int d = (dist[v][end_point] + base_dist[end_point] - base_dist[v]) / 2;\n\t\tpos[d - 1].emplace_back(v);\n\t\tbase_dist[v] = dist[v][end_point] - d;\n\t}\n\n\tfor(int i = 0; i < longest - 1; ++i) {\n\t\tif(i + 1 == max_base_dist) continue;\n\n\t\tif(pos[i].empty()) {\n\t\t\tans.emplace_back(2);\n\t\t}\n\t\telse if(rec(pos[i])) {\n\t\t\tans.emplace_back(4);\n\t\t}\n\t\telse {\n\t\t\tans.emplace_back(3);\n\t\t}\n\t}\n\n\treturn max_base_dist < longest;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tcin >> dist[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint base;\n\t\tint max_dist = 0;\n\n\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(max_dist < dist[i][j]) {\n\t\t\t\t\tbase = i;\n\t\t\t\t\tmax_dist = dist[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> nodes;\n\t\tnodes.reserve(n);\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\tif(v == base) continue;\n\n\t\t\tbase_dist[v] = dist[base][v];\n\t\t\tnodes.emplace_back(v);\n\t\t}\n\n\t\tans.clear();\n\n\t\trec(nodes);\n\n\t\tsort(ans.begin(), ans.end());\n\t\tfor(unsigned i = 0; i < ans.size(); ++i) {\n\t\t\tcout << ans[i] << (i + 1 == ans.size() ? '\\n' : ' ');\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>  \n#include<vector>  \n#include<string>  \n#include<set>  \n#include<stack>  \n#include<queue>  \n#include<map>  \n#include<algorithm>  \n#include<cmath>  \n#include<iomanip>  \n#include<cstring>  \n#include<sstream>  \n#include<cstdio>  \n#include<deque>  \n#include<functional>  \nusing namespace std;  \n  \nconst int MAX = 2005;  \nint area[55][55];  \nvector<int> R[MAX];  \nint dist[MAX][55];  \nint record[MAX];  \n  \nclass Solve{  \npublic:  \n    int N;  \n  \n    void Init(){  \n        memset(record,0,sizeof(record));  \n        for (int i = 1; i <= N; i++){  \n            for (int j = 1; j <= N; j++)  \n                cin >> area[i][j];  \n        }  \n        for (int i = 0; i < MAX; i++) R[i].clear();  \n        memset(dist, 0, sizeof(dist));  \n    }  \n      \n    void dfs(int i,int pa,int k){  \n        for (int ind = 0; ind < R[i].size(); ind++){  \n            int v = R[i][ind];  \n            if (v == pa) continue;  \n            dist[v][k] = dist[i][k] + 1;  \n            dfs(v, i, k);  \n        }  \n    }  \n  \n    void Deal(){  \n        Init();  \n        int amount = 1;  \n        for (int ind = 2; ind <= N; ind++){  \n            for (int i = 1; i <= amount; i++){  \n                int dis = area[ind][1] - dist[i][1];  \n                int j;  \n                for (j = 1; j < ind; j++){  \n                    if (area[ind][j] - dist[i][j] != dis) break;  \n                }  \n                if (j == ind){  \n                    while (dis > 0){  \n                        amount++;  \n                        R[amount].push_back(i);  \n                        R[i].push_back(amount);  \n                        record[amount]++;  \n                        record[i]++;  \n                        for (int k = 1; k < ind; k++){  \n                            dist[amount][k] = dist[i][k] + 1;  \n                        }  \n                        dis--;  \n                        i = amount;  \n                    }  \n                    dfs(i,0,ind);  \n                    break;  \n                }  \n            }  \n        }  \n        sort(record+1,record+amount+1);  \n        for (int i = 1; i < amount; i++){  \n            if (record[i] > 1) cout << record[i] << \" \";  \n        }  \n        cout << record[amount] << endl;  \n    }  \n};  \n  \nint main(){  \n    Solve a;  \n    while (cin >> a.N){  \n        if (a.N == 0) break;  \n        a.Deal();  \n    }  \n    return 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\nconst double EPS = 1e-10;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nint ccw(P a, P b, P c) {\n  b-=a;c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n  \nbool intersectSS(const L &s, const L &t) {\n  return ccw(s.F,s.S,t.F)*ccw(s.F,s.S,t.S) == -1 &&\n         ccw(t.F,t.S,s.F)*ccw(t.F,t.S,s.S) == -1;\n}\nint contains(vector<P> const& G, P const& p) {\n  bool x=0;\n  for(int i=0; i<(int)G.size(); i++) {\n    P v1=G[i]-p,v2=G[(i+1)%G.size()]-p;\n    if(v1.imag()>v2.imag()) swap(v1,v2);\n    if(v1.imag()<=0&&0<v2.imag()&&cross(v1,v2)>0)x=!x;\n    if(cross(v1,v2)==0&&dot(v1,v2)<=0) return 1;\n  }\n  return x?2:0;\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    P a[n];\n    for(int i=0; i<n; i++) {\n      double x,y;\n      cin >> x >> y;\n      a[i]=P(x,y);\n    }\n    int ans=0;\n    for(int i=0; i<n; i++) {\n      vector<P> v;\n      for(int j=0; j<n; j++) {\n        if(i!=j) v.push_back(a[j]);\n      }\n      if(!contains(v,a[i])) continue;\n      for(int j=0; j<v.size(); j++) {\n        L l=L(a[i],v[j]);\n        for(int k=0; k<v.size(); k++) {\n          L r=L(v[k],v[(k+1)%v.size()]);\n          if(r.F==v[j]||r.S==v[j]) continue;\n          if(intersectSS(l,r)) goto next;\n        }\n      }\n      ans=1;\n    next:;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Network Mess\npublic class Main{\n\n\tclass R{\n\t\tint id, con;\n\t\tint[] dist;\n\t\tSet<Integer> adj;\n\t\tpublic R(int id) {\n\t\t\tcon = 0;\n\t\t\tthis.id = id;\n\t\t\tdist = new int[n];\n\t\t\tArrays.fill(dist, -1);\n\t\t\tadj = new HashSet<Integer>();\n\t\t}\n\t\tvoid add(int k){\n//\t\t\tSystem.out.println(\"Tar:\"+k+\" Here:\"+id);\n\t\t\tR v = new R(ID);\n\t\t\tsw[ID] = v;\n\t\t\tadj.add(ID);\n\t\t\tv.adj.add(id);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(dist[i]==-1)continue;\n\t\t\t\tv.dist[i] = dist[i]+1;\n\t\t\t}\n\t\t\tID++;\n\t\t\tif(a[0][k]-1==v.dist[0]){\n//\t\t\t\tSystem.out.println(\"Assign Start : \"+id);\n\t\t\t\tv.con++;\n\t\t\t\tv.assign(k, 1);\n\t\t\t}\n\t\t\telse v.add(k);\n\t\t}\n\t\tvoid assign(int k, int d){\n\t\t\tif(dist[k]!=-1)return;\n//\t\t\tSystem.out.println(\"Let assign: \"+id);\n\t\t\tdist[k] = d;\n\t\t\tfor(int i:adj)sw[i].assign(k, d+1);\n\t\t}\n\t\tpublic String toString() {\n\t\t\tString res = \"ID: \" + id;\n\t\t\tfor(int i=0;i<n;i++)res+=\" \"+dist[i];\n\t\t\tres += \" ADJ:\";\n\t\t\tfor(int i:adj)res+=\" \"+i;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tint n, ID;\n\tR[] sw;\n\tint[][] a;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ta = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)a[i][j]=sc.nextInt();\n\t\t\tsw = new R[1500];\n\t\t\tID = 0;\n\t\t\tsw[0] = new R(ID++);\n\t\t\tsw[0].con++;\n\t\t\tsw[0].assign(0, 1);\n\t\t\tfor(int k=1;k<n;k++){\n//\t\t\t\tSystem.out.println(\"SIZE:\"+ID);\n//\t\t\t\tfor(int i=0;i<ID;i++)System.out.println(sw[i]);\n\t\t\t\tboolean s = true;\n\t\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\t\tif(sw[i].dist[j]!=a[j][k]-1){\n\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n//\t\t\t\t\t\tSystem.out.println(\"AAA:\"+i+\" Decide:\"+k);\n\t\t\t\t\t\ts = false; sw[i].con++; sw[i].assign(k, 1); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!s)continue;\n//\t\t\t\tSystem.out.println(\"K:\"+k);\n\t\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tint dif = a[0][k]-sw[i].dist[0];\n\t\t\t\t\tfor(int j=1;j<k;j++){\n\t\t\t\t\t\tif(dif!=a[j][k]-sw[i].dist[j])f = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n//\t\t\t\t\t\tSystem.out.println(\"Attach:\"+i+\" Dif:\"+dif + \" Decide:\"+k);\n\t\t\t\t\t\tsw[i].add(k);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\tfor(int i=0;i<ID;i++)q.add(sw[i].adj.size()+sw[i].con);\n\t\t\tSystem.out.print(q.poll());\n\t\t\twhile(!q.isEmpty())System.out.print(\" \"+q.poll());\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tint n;\n\tint [][] g;\n\tArrayList<Node> nlist;\n\t\n\tclass Node implements Comparable<Node>{\n\t\tint [] dis;\n\t\tArrayList<Integer> edge;\n\t\tpublic Node() {\n\t\t\tthis.dis = new int[n];\n\t\t\tArrays.fill(this.dis, -1);\n\t\t\tthis.edge = new ArrayList<Integer>();\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Node [dis=\" + Arrays.toString(dis) + \", edge=\" + edge + \"]\";\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn this.edge.size() - o.edge.size();\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tg = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tg[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnlist = new ArrayList<Node>();\n\t\t\t\n\t\t\tfor(int i = 0; i < g[0][1]-1; i++){\n\t\t\t\tnlist.add(new Node());\n\t\t\t\tnlist.get(i).edge.add(i-1);\n\t\t\t\tif(i != 0){\n\t\t\t\t\tnlist.get(i-1).edge.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnlist.get(nlist.size()-1).edge.add(-2);\n\t\t\tcalcdis(0, 1, 0, -1);\n\t\t\tcalcdis(g[0][1] - 2, 1, 1, -1);\n\t\t\t\n\t\t\tfor(int i = 2; i < n; i++){\n\t\t\t\tfor(int j = 0; j < nlist.size(); j++){\n\t\t\t\t\tint x = g[0][i] - nlist.get(j).dis[0];\n\t\t\t\t\tboolean flg = true;\n\t\t\t\t\tfor(int k = 1; k < i;k++){\n\t\t\t\t\t\tint nowx = g[k][i] - nlist.get(j).dis[k];\n\t\t\t\t\t\tif(nowx != x){\n\t\t\t\t\t\t\tflg =false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flg){\n\t\t\t\t\t\tfor(int k = 0; k < x-1; k++){\n\t\t\t\t\t\t\tnlist.add(new Node());\n\t\t\t\t\t\t\tint ind = nlist.size()-1;\n\t\t\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t\t\tnlist.get(ind).edge.add(j);\n\t\t\t\t\t\t\t\tnlist.get(j).edge.add(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnlist.get(ind).edge.add(ind-1);\n\t\t\t\t\t\t\t\tnlist.get(ind-1).edge.add(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = 0; l < i; l++){\n\t\t\t\t\t\t\t\tnlist.get(ind).dis[l] = nlist.get(j).dis[l] + k + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnlist.get(nlist.size()-1).edge.add(-i-1);\n\t\t\t\t\t\tcalcdis(nlist.size()-1, 1, i, -1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tCollections.sort(nlist);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(Node node: nlist){\n\t\t\t\tsb.append(\" \" + node.edge.size());\n\t\t\t}\n\t\t\tSystem.out.println(sb.substring(1));\n\t\t}\n\t\t\n\t}\n\tprivate void calcdis(int nowpos, int dis, int ind,int prev) {\n\t\tif(nowpos < 0) return;\n\t\tnlist.get(nowpos).dis[ind] = dis;\n\t\t\n\t\tfor(int i = 0; i < nlist.get(nowpos).edge.size(); i++){\n\t\t\tint nextnode = nlist.get(nowpos).edge.get(i);\n\t\t\tif(nextnode == prev) continue;\n\t\t\tcalcdis(nextnode, dis+1, ind, nowpos);\n\t\t}\n\t}\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Network Mess\npublic class Main{\n\n\tclass R{\n\t\tint id, con;\n\t\tint[] dist;\n\t\tSet<Integer> adj;\n\t\tpublic R(int id) {\n\t\t\tcon = 0;\n\t\t\tthis.id = id;\n\t\t\tdist = new int[n];\n\t\t\tArrays.fill(dist, -1);\n\t\t\tadj = new HashSet<Integer>();\n\t\t}\n\t\tvoid add(int k){\n\t\t\tR v = new R(ID);\n\t\t\tsw[ID] = v;\n\t\t\tadj.add(ID);\n\t\t\tv.adj.add(id);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(dist[i]==-1)continue;\n\t\t\t\tv.dist[i] = dist[i]+1;\n\t\t\t}\n\t\t\tID++;\n\t\t\tif(a[0][k]-1==v.dist[0]){\n\t\t\t\tv.con++;\n\t\t\t\tv.assign(k, 1);\n\t\t\t}\n\t\t\telse v.add(k);\n\t\t}\n\t\tvoid assign(int k, int d){\n\t\t\tif(dist[k]!=-1)return;\n\t\t\tdist[k] = d;\n\t\t\tfor(int i:adj)sw[i].assign(k, d+1);\n\t\t}\n\t}\n\t\n\tint n, ID;\n\tR[] sw;\n\tint[][] a;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\ta = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)a[i][j]=sc.nextInt();\n\t\t\tsw = new R[1500];\n\t\t\tID = 0;\n\t\t\tsw[0] = new R(ID++);\n\t\t\tsw[0].con++;\n\t\t\tsw[0].assign(0, 1);\n\t\t\tfor(int k=1;k<n;k++){\n\t\t\t\tboolean s = true;\n\t\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\t\tif(sw[i].dist[j]!=a[j][k]-1){\n\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\ts = false; sw[i].con++; sw[i].assign(k, 1); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!s)continue;\n\t\t\t\tfor(int i=0;i<ID;i++){\n\t\t\t\t\tboolean f = true;\n\t\t\t\t\tint dif = a[0][k]-sw[i].dist[0];\n\t\t\t\t\tfor(int j=1;j<k;j++){\n\t\t\t\t\t\tif(dif!=a[j][k]-sw[i].dist[j])f = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tsw[i].add(k);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>();\n\t\t\tfor(int i=0;i<ID;i++)q.add(sw[i].adj.size()+sw[i].con);\n\t\t\tSystem.out.print(q.poll());\n\t\t\twhile(!q.isEmpty())System.out.print(\" \"+q.poll());\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tint n;\n\tint [][] g;\n\tArrayList<Node> nlist;\n\t\n\tclass Node implements Comparable<Node>{\n\t\tint [] dis;\n\t\tArrayList<Integer> edge;\n\t\tpublic Node() {\n\t\t\tthis.dis = new int[n];\n\t\t\tArrays.fill(this.dis, -1);\n\t\t\tthis.edge = new ArrayList<Integer>();\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Node [dis=\" + Arrays.toString(dis) + \", edge=\" + edge + \"]\";\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn this.edge.size() - o.edge.size();\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tg = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tg[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnlist = new ArrayList<Node>();\n\t\t\t\n\t\t\tfor(int i = 0; i < g[0][1]-1; i++){\n\t\t\t\tnlist.add(new Node());\n\t\t\t\tnlist.get(i).edge.add(i-1);\n\t\t\t\tif(i != 0){\n\t\t\t\t\tnlist.get(i-1).edge.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnlist.get(nlist.size()-1).edge.add(-2);\n\t\t\tcalcdis(0, 1, 0, -1);\n\t\t\tcalcdis(g[0][1] - 2, 1, 1, -1);\n\t\t\t\n\t\t\tfor(int i = 2; i < n; i++){\n\t\t\t\tfor(int j = 0; j < nlist.size(); j++){\n\t\t\t\t\tint x = g[0][i] - nlist.get(j).dis[0];\n\t\t\t\t\tif(x <= 0)continue;\n\t\t\t\t\tboolean flg = true;\n\t\t\t\t\tfor(int k = 1; k < i;k++){\n\t\t\t\t\t\tint nowx = g[k][i] - nlist.get(j).dis[k];\n\t\t\t\t\t\tif(nowx != x){\n\t\t\t\t\t\t\tflg =false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flg){\n\t\t\t\t\t\tfor(int k = 0; k < x-1; k++){\n\t\t\t\t\t\t\tnlist.add(new Node());\n\t\t\t\t\t\t\tint ind = nlist.size()-1;\n\t\t\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t\t\tnlist.get(ind).edge.add(j);\n\t\t\t\t\t\t\t\tnlist.get(j).edge.add(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnlist.get(ind).edge.add(ind-1);\n\t\t\t\t\t\t\t\tnlist.get(ind-1).edge.add(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = 0; l < i; l++){\n\t\t\t\t\t\t\t\tnlist.get(ind).dis[l] = nlist.get(j).dis[l] + k + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x == 1){\n\t\t\t\t\t\t\tnlist.get(j).edge.add(-i-1);\n\t\t\t\t\t\t\tcalcdis(j, 1, i, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnlist.get(nlist.size()-1).edge.add(-i-1);\n\t\t\t\t\t\t\tcalcdis(nlist.size()-1, 1, i, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//print\n\t\t\tCollections.sort(nlist);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(Node node: nlist){\n\t\t\t\tsb.append(\" \" + node.edge.size());\n\t\t\t}\n\t\t\tSystem.out.println(sb.substring(1));\n\t\t}\n\t\t\n\t}\n\tprivate void calcdis(int nowpos, int dis, int ind,int prev) {\n\t\tif(nowpos < 0) return;\n\t\tnlist.get(nowpos).dis[ind] = dis;\n\t\t\n\t\tfor(int i = 0; i < nlist.get(nowpos).edge.size(); i++){\n\t\t\tint nextnode = nlist.get(nowpos).edge.get(i);\n\t\t\tif(nextnode == prev) continue;\n\t\t\tcalcdis(nextnode, dis+1, ind, nowpos);\n\t\t}\n\t}\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tint n;\n\tint [][] g;\n\tArrayList<Node> nlist;\n\t\n\tclass Node implements Comparable<Node>{\n\t\tint [] dis;\n\t\tArrayList<Integer> edge;\n\t\tpublic Node() {\n\t\t\tthis.dis = new int[n];\n\t\t\tArrays.fill(this.dis, -1);\n\t\t\tthis.edge = new ArrayList<Integer>();\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Node [dis=\" + Arrays.toString(dis) + \", edge=\" + edge + \"]\";\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn this.edge.size() - o.edge.size();\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tg = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tg[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnlist = new ArrayList<Node>();\n\t\t\t\n\t\t\tfor(int i = 0; i < g[0][1]-1; i++){\n\t\t\t\tnlist.add(new Node());\n\t\t\t\tnlist.get(i).edge.add(i-1);\n\t\t\t\tif(i != 0){\n\t\t\t\t\tnlist.get(i-1).edge.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnlist.get(nlist.size()-1).edge.add(-2);\n\t\t\tcalcdis(0, 1, 0, -1);\n\t\t\tcalcdis(g[0][1] - 2, 1, 1, -1);\n\t\t\t\n\t\t\tfor(int i = 2; i < n; i++){\n\t\t\t\tfor(int j = 0; j < nlist.size(); j++){\n\t\t\t\t\tint x = g[0][i] - nlist.get(j).dis[0];\n\t\t\t\t\tif(x < 0)continue;\n\t\t\t\t\tboolean flg = true;\n\t\t\t\t\tfor(int k = 1; k < i;k++){\n\t\t\t\t\t\tint nowx = g[k][i] - nlist.get(j).dis[k];\n\t\t\t\t\t\tif(nowx != x){\n\t\t\t\t\t\t\tflg =false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flg){\n\t\t\t\t\t\tfor(int k = 0; k < x-1; k++){\n\t\t\t\t\t\t\tnlist.add(new Node());\n\t\t\t\t\t\t\tint ind = nlist.size()-1;\n\t\t\t\t\t\t\tif(k == 0){\n\t\t\t\t\t\t\t\tnlist.get(ind).edge.add(j);\n\t\t\t\t\t\t\t\tnlist.get(j).edge.add(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tnlist.get(ind).edge.add(ind-1);\n\t\t\t\t\t\t\t\tnlist.get(ind-1).edge.add(ind);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int l = 0; l < i; l++){\n\t\t\t\t\t\t\t\tnlist.get(ind).dis[l] = nlist.get(j).dis[l] + k + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnlist.get(nlist.size()-1).edge.add(-i-1);\n\t\t\t\t\t\tcalcdis(nlist.size()-1, 1, i, -1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//print\n\t\t\tCollections.sort(nlist);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(Node node: nlist){\n\t\t\t\tsb.append(\" \" + node.edge.size());\n\t\t\t}\n\t\t\tSystem.out.println(sb.substring(1));\n\t\t}\n\t\t\n\t}\n\tprivate void calcdis(int nowpos, int dis, int ind,int prev) {\n\t\tif(nowpos < 0) return;\n\t\tnlist.get(nowpos).dis[ind] = dis;\n\t\t\n\t\tfor(int i = 0; i < nlist.get(nowpos).edge.size(); i++){\n\t\t\tint nextnode = nlist.get(nowpos).edge.get(i);\n\t\t\tif(nextnode == prev) continue;\n\t\t\tcalcdis(nextnode, dis+1, ind, nowpos);\n\t\t}\n\t}\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Node\n  attr_accessor :id, :lvds, :nbrs\n\n  $nds = []\n  $nn = 0\n  \n  def initialize(id)\n    @id = id\n    @lvds = []\n    @nbrs = []\n  end\n\n  def self.add\n    this = self.new($nn)\n    $nds << this\n    $nn += 1\n    this\n  end\n\n  def self.clear\n    $nds = []\n    $nn = 0\n  end\nend\n\n### subroutines\n\ndef same_dists(mtx, k)\n  for nd in $nds\n    sdist = mtx[k][0] - nd.lvds[0]\n    ok = true\n    for j in (1...k)\n      d = mtx[k][j] - nd.lvds[j]\n      if sdist != d\n        ok = false\n        break\n      end\n    end\n    return [nd, sdist] if ok\n  end\n  [nil, nil]\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  mtx = n.times.map{gets.split.map(&:to_i)}\n  #p mtx\n\n  Node.clear\n  nd0 = Node.add\n  nd0.lvds << 1\n  \n  for k in (1...n)\n    cnd, sdist = same_dists(mtx, k)\n    if cnd.nil?\n      p \"error\"\n      exit\n    end\n    \n    while sdist > 1\n      nd = Node.add\n      cnd.nbrs << nd\n      nd.nbrs << cnd\n      nd.lvds = cnd.lvds.map{|d| d + 1}\n      sdist -= 1\n      cnd = nd\n    end\n\n    cnd.lvds[k] = 1\n    q = [cnd]\n    while ! q.empty?\n      u = q.shift\n      nvd = u.lvds[k] + 1\n      for v in u.nbrs\n        if v.lvds[k].nil?\n          v.lvds[k] = nvd\n          q << v\n        end\n      end\n    end\n    #p lvs.map{|nd| nd.id}\n    #p $nds.map{|nd| nd.to_s}\n  end\n\n  ndegs = $nds.map{|nd| nd.nbrs.length + nd.lvds.count{|d| d == 1}}\n  puts ndegs.sort.join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Node\n  attr_accessor :id, :lvds, :nbrs\n\n  def initialize\n    @id = $nn\n    $nn += 1\n    @lvds = []\n    @nbrs = []\n    $nds << self\n  end\n\n  def to_s\n    [@id, @lvds, @nbrs.map{|nd| nd.id}]\n  end\nend\n\n### subroutines\n\ndef right_direc(mtx, k, nd0, nd1)\n  for i in (0...k)\n    dki = mtx[k][i] - 1\n    d0 = (dki - nd0.lvds[i]).abs\n    d1 = (dki - nd1.lvds[i]).abs\n    return false if d0 < d1\n  end\n  true\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  mtx = n.times.map{gets.split.map(&:to_i)}\n  #p mtx\n\n  lvs = []\n  $nds = []\n\n  $nn = 0\n  nd0 = Node.new\n  nd0.lvds[0] = 1\n  lvs[0] = nd0\n\n  for i in (1...n)\n    #p [\"i\", i]\n    cnd = lvs[0]\n\n    loop do\n      #p [\"cnd\", cnd.id]\n      nnd = nil\n      for nd in cnd.nbrs\n        if right_direc(mtx, i, cnd, nd)\n          nnd = nd\n          break\n        end\n      end\n      break if nnd.nil?\n\n      cnd = nnd\n    end\n\n    while mtx[i][0] - cnd.lvds[0] > 1\n      nd = Node.new\n      cnd.nbrs << nd\n      nd.nbrs << cnd\n      (0...i).each{|j| nd.lvds[j] = cnd.lvds[j] + 1}\n      cnd = nd\n    end\n\n    lvs[i] = cnd\n    cnd.lvds[i] = 1\n    q = [cnd]\n    while ! q.empty?\n      u = q.shift\n      nvd = u.lvds[i] + 1\n      for v in u.nbrs\n        if v.lvds[i].nil?\n          v.lvds[i] = nvd\n          q << v\n        end\n      end\n    end\n    #p lvs.map{|nd| nd.id}\n    #p $nds.map{|nd| nd.to_s}\n  end\n\n  ndegs = $nds.map{|nd| nd.nbrs.length + nd.lvds.count{|d| d == 1}}\n  puts ndegs.sort.join(' ')\nend"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from sys import stdin\n    f_i = stdin\n    \n    # function to update distance between switch and computer\n    def dfs(sw_id, prev, dist):\n        switch[sw_id].append(dist)\n        for next_sw in adj[sw_id]:\n            if next_sw != prev:\n                dfs(next_sw, sw_id, dist + 1)\n    \n    while True:\n        N = int(f_i.readline())\n        if N == 0:\n            break\n        \n        # distance table of computers\n        dist_tbl = [list(map(int, f_i.readline().split())) for i in range(N)]\n        \n        switch = [[1]] # switch[sw][com]: distance between sw and com\n        degree = [1]\n        adj = [[]] # adjacency list of switches\n        \n        for dt_i in dist_tbl[1:]:\n            # try to connect a computer to an existing switch\n            for m, sw_m in enumerate(switch):\n                for dist_j, dt_ij in zip(sw_m, dt_i):\n                    if dist_j != dt_ij - 1:\n                        break\n                else: # found a switch to connect a computer\n                    degree[m] += 1\n                    dfs(m, m, 1)\n                    break\n                continue\n            else: # no switch to connect\n                # find an existing switch to connect additional switch to\n                for m, sw_m in enumerate(switch):\n                    g = (x - y for x, y in zip(dt_i, sw_m))\n                    diff = next(g)\n                    for d in g:\n                        if d != diff:\n                            break\n                    else:\n                        break\n                \n                # first additional switch\n                sw = len(switch)\n                switch.append([dist + 1 for dist in switch[m]])\n                adj[m].append(sw)\n                adj.append([m])\n                degree[m] += 1\n                degree.append(1)\n                \n                # second and subsequent additional switches\n                for i in range(2, diff):\n                    switch.append([dist + i for dist in switch[m]])\n                    adj[sw].append(sw + 1)\n                    adj.append([sw])\n                    degree[sw] += 1\n                    degree.append(1)\n                    sw += 1\n                \n                # connect a computer to the last added switch\n                degree[sw] += 1\n                dfs(sw, sw, 1)\n                \n        degree.sort()\n        print(' '.join(map(str, degree)))\n\nsolve()\n"
  }
]