[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_COLORS 100\n\ntypedef struct {\n    int color;\n    double density;\n} Layer;\n\nbool can_create_drink(Layer available[], int available_count, Layer request[], int request_count) {\n    bool used[MAX_COLORS] = {false};\n\n    for (int i = 0; i < request_count; i++) {\n        bool found_layer = false;\n        \n        for (int j = 0; j < available_count; j++) {\n            if (!used[j] && \n                available[j].color == request[i].color && \n                (i == 0 || available[j].density < request[i-1].density)) {\n                used[j] = true;\n                found_layer = true;\n                break;\n            }\n        }\n        \n        if (!found_layer) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int available_count, request_count;\n    Layer available[MAX_COLORS], request[MAX_COLORS];\n\n    scanf(\"%d %d\", &available_count, &request_count);\n\n    for (int i = 0; i < available_count; i++) {\n        scanf(\"%d %lf\", &available[i].color, &available[i].density);\n    }\n\n    for (int i = 0; i < request_count; i++) {\n        scanf(\"%d %lf\", &request[i].color, &request[i].density);\n    }\n\n    printf(\"%s\\n\", can_create_drink(available, available_count, request, request_count) ? \"Yes\" : \"No\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    char color[50];\n    int density;\n} Liquid;\n\nbool can_fulfill_request(Liquid liquids[], int n, char request[][50], int m) {\n    for (int i = 0; i < m; i++) {\n        bool color_found = false;\n        for (int j = 0; j < n; j++) {\n            if (strcmp(request[i], liquids[j].color) == 0) {\n                color_found = true;\n                if (i < m - 1) {\n                    bool next_color_found = false;\n                    for (int k = 0; k < n; k++) {\n                        if (strcmp(request[i + 1], liquids[k].color) == 0) {\n                            next_color_found = true;\n                            if (liquids[k].density >= liquids[j].density) {\n                                return false;\n                            }\n                        }\n                    }\n                    if (!next_color_found) {\n                        return false;\n                    }\n                }\n            }\n        }\n        if (!color_found) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d\", &n);\n    Liquid liquids[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %d\", liquids[i].color, &liquids[i].density);\n    }\n    scanf(\"%d\", &m);\n    char request[m][50];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%s\", request[i]);\n    }\n    if (can_fulfill_request(liquids, n, request, m)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nbool canFulfillRequest(const vector<pair<string, int>>& available, const vector<string>& request) {\n    unordered_map<string, int> colorToMaxDensity;\n    for (const auto& p : available) {\n        if (colorToMaxDensity.find(p.first) == colorToMaxDensity.end()) {\n            colorToMaxDensity[p.first] = p.second;\n        } else {\n            if (p.second > colorToMaxDensity[p.first]) {\n                colorToMaxDensity[p.first] = p.second;\n            }\n        }\n    }\n    \n    for (const string& color : request) {\n        if (colorToMaxDensity.find(color) == colorToMaxDensity.end()) {\n            return false;\n        }\n    }\n    \n    vector<int> densities;\n    for (const string& color : request) {\n        densities.push_back(colorToMaxDensity[color]);\n    }\n    \n    for (int i = 1; i < densities.size(); ++i) {\n        if (densities[i] <= densities[i - 1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N;\n    vector<pair<string, int>> available(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> available[i].first >> available[i].second;\n    }\n    \n    cin >> M;\n    vector<string> request(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> request[i];\n    }\n    \n    if (canFulfillRequest(available, request)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:03:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JamboDrink {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        List<List<Integer>> liquids = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int C = scanner.nextInt();\n            List<Integer> densities = new ArrayList<>();\n            for (int j = 0; j < C; j++) {\n                densities.add(scanner.nextInt());\n            }\n            liquids.add(densities);\n        }\n        \n        List<Integer> request = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            request.add(scanner.nextInt());\n        }\n        \n        boolean possible = isPossible(liquids, request);\n        System.out.println(possible ? \"1\" : \"0\");\n    }\n    \n    private static boolean isPossible(List<List<Integer>> liquids, List<Integer> request) {\n        Map<Integer, List<Integer>> colorToDensities = new HashMap<>();\n        for (List<Integer> densities : liquids) {\n            for (int density : densities) {\n                int color = density % 1000;\n                int d = density / 1000;\n                colorToDensities.computeIfAbsent(color, k -> new ArrayList<>()).add(d);\n            }\n        }\n        \n        for (int color : request) {\n            if (!colorToDensities.containsKey(color)) {\n                return false;\n            }\n        }\n        \n        List<Integer> prevDensities = null;\n        for (int i = 0; i < request.size(); i++) {\n            int color = request.get(i);\n            List<Integer> densities = colorToDensities.get(color);\n            Collections.sort(densities);\n            \n            if (i == 0) {\n                prevDensities = densities;\n            } else {\n                int maxPrev = Collections.max(prevDensities);\n                int minCurrent = Collections.min(densities);\n                if (minCurrent <= maxPrev) {\n                    return false;\n                }\n                prevDensities = densities;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 22:04:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ColoredDrinks {\n    public static boolean canCreateDrink(int[] densities, int[] requestedColors) {\n        // Sort densities in descending order\n        Integer[] sortedDensities = Arrays.stream(densities).boxed().toArray(Integer[]::new);\n        Arrays.sort(sortedDensities, Collections.reverseOrder());\n\n        // Sort requested colors by their corresponding densities\n        int[] sortedRequestedColors = new int[requestedColors.length];\n        for (int i = 0; i < requestedColors.length; i++) {\n            sortedRequestedColors[i] = requestedColors[Arrays.binarySearch(sortedDensities, densities[requestedColors[i]])];\n        }\n\n        // Check if layers can be stacked without mixing\n        for (int i = 1; i < sortedRequestedColors.length; i++) {\n            if (densities[sortedRequestedColors[i]] >= densities[sortedRequestedColors[i-1]]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // Number of available colored liquids\n        int[] densities = new int[n];\n        for (int i = 0; i < n; i++) {\n            densities[i] = scanner.nextInt();\n        }\n\n        int m = scanner.nextInt(); // Number of colors in drink request\n        int[] requestedColors = new int[m];\n        for (int i = 0; i < m; i++) {\n            requestedColors[i] = scanner.nextInt() - 1;\n        }\n\n        System.out.println(canCreateDrink(densities, requestedColors) ? \"Yes\" : \"No\");\n    }\n}",
    "timestamp": "2025-08-05 22:04:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool canCreateDrink(vector<int>& colors, vector<double>& densities) {\n    int n = colors.size();\n    vector<pair<double, int>> sortedLiquids;\n    \n    for (int i = 0; i < n; i++) {\n        sortedLiquids.push_back({densities[i], colors[i]});\n    }\n    \n    sort(sortedLiquids.rbegin(), sortedLiquids.rend());\n    \n    vector<int> result;\n    for (auto& liquid : sortedLiquids) {\n        if (result.empty() || liquid.first < densities[result.back()]) {\n            result.push_back(liquid.second);\n        }\n    }\n    \n    return result.size() == n;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> colors(n);\n    vector<double> densities(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> colors[i] >> densities[i];\n    }\n    \n    cout << (canCreateDrink(colors, densities) ? \"Yes\" : \"No\") << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_fulfill_drink_request(liquids, drink_request):\n    available_liquids = {color: density for color, density in liquids}\n    drink_densities = [available_liquids[color] for color in drink_request if color in available_liquids]\n    \n    if len(drink_densities) != len(drink_request):\n        return False\n    \n    for i in range(len(drink_densities) - 1):\n        if drink_densities[i] <= drink_densities[i + 1]:\n            return False\n    \n    return True\n\n# Example usage\nliquids = [(\"red\", 3), (\"blue\", 1), (\"green\", 2), (\"yellow\", 4)]\ndrink_request = [\"blue\", \"green\", \"red\"]\nprint(can_fulfill_drink_request(liquids, drink_request))  # Output should be True\n\ndrink_request_invalid = [\"red\", \"blue\", \"green\"]\nprint(can_fulfill_drink_request(liquids, drink_request_invalid))  # Output should be False",
    "timestamp": "2025-08-13 08:49:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class JamboAmusementGarden {\n    static class Liquid {\n        String color;\n        int density;\n        \n        Liquid(String color, int density) {\n            this.color = color;\n            this.density = density;\n        }\n    }\n\n    public static boolean canFulfillRequest(List<Liquid> availableLiquids, List<String> requestedLayers) {\n        Map<String, Integer> colorToDensityMap = new HashMap<>();\n        for (Liquid liquid : availableLiquids) {\n            colorToDensityMap.put(liquid.color, liquid.density);\n        }\n\n        int previousDensity = Integer.MAX_VALUE;\n        for (String color : requestedLayers) {\n            Integer currentDensity = colorToDensityMap.get(color);\n            if (currentDensity == null || currentDensity >= previousDensity) {\n                return false;\n            }\n            previousDensity = currentDensity;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        List<Liquid> availableLiquids = Arrays.asList(\n            new Liquid(\"red\", 3),\n            new Liquid(\"green\", 1),\n            new Liquid(\"blue\", 2)\n        );\n\n        List<String> requestedLayers1 = Arrays.asList(\"green\", \"blue\", \"red\");\n        System.out.println(canFulfillRequest(availableLiquids, requestedLayers1)); // true\n\n        List<String> requestedLayers2 = Arrays.asList(\"blue\", \"red\");\n        System.out.println(canFulfillRequest(availableLiquids, requestedLayers2)); // true\n\n        List<String> requestedLayers3 = Arrays.asList(\"red\", \"blue\");\n        System.out.println(canFulfillRequest(availableLiquids, requestedLayers3)); // false\n    }\n}",
    "timestamp": "2025-08-13 08:49:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_COLORS 100\n\ntypedef struct {\n    char color[21];\n    double density;\n} Liquid;\n\nbool canFulfillRequest(Liquid liquids[], int nLiquids, char requestColors[][21], int nRequest) {\n    int requestIndex = 0;\n    \n    for (int i = 0; i < nLiquids; ++i) {\n        if (requestIndex < nRequest && strcmp(liquids[i].color, requestColors[requestIndex]) == 0) {\n            // Check if the current color can be part of the drink according to the density\n            if (requestIndex > 0 && liquids[i].density >= liquids[i - 1].density) {\n                return false;\n            }\n            requestIndex++;\n        }\n    }\n\n    return requestIndex == nRequest;\n}\n\nint main() {\n    // Input example:\n    // Number of available liquids\n    // Each line for each liquid: <color> <density>\n    // Number of requested colors\n    // Each line for each requested color: <color>\n    \n    int nLiquids;\n    scanf(\"%d\", &nLiquids);\n    \n    Liquid liquids[MAX_COLORS];\n    for (int i = 0; i < nLiquids; ++i) {\n        scanf(\"%s %lf\", liquids[i].color, &liquids[i].density);\n    }\n    \n    int nRequest;\n    scanf(\"%d\", &nRequest);\n    \n    char requestColors[MAX_COLORS][21];\n    for (int i = 0; i < nRequest; ++i) {\n        scanf(\"%s\", requestColors[i]);\n    }\n    \n    if (canFulfillRequest(liquids, nLiquids, requestColors, nRequest)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 08:49:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_create_drink(colors, densities):\n    n = len(colors)\n    for i in range(n):\n        for j in range(i+1, n):\n            if colors[i] == colors[j] and densities[i] > densities[j]:\n                return False\n    \n    sorted_layers = sorted(zip(densities, colors), reverse=True)\n    used_colors = set()\n    \n    for density, color in sorted_layers:\n        if color not in used_colors:\n            used_colors.add(color)\n    \n    return len(used_colors) == len(set(colors))\n\ndef main():\n    n = int(input())\n    colors = list(input().split())\n    densities = list(map(float, input().split()))\n    \n    result = \"Yes\" if can_create_drink(colors, densities) else \"No\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:49:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_fulfill_request(available_liquids, request):\n    available_colors = {}\n    for color, density in available_liquids:\n        if color not in available_colors:\n            available_colors[color] = []\n        available_colors[color].append(density)\n    \n    for color in available_colors:\n        available_colors[color].sort(reverse=True)\n    \n    prev_density = float('inf')\n    for color in request:\n        if color not in available_colors or not available_colors[color]:\n            return False\n        found = False\n        for i in range(len(available_colors[color])):\n            if available_colors[color][i] < prev_density:\n                prev_density = available_colors[color].pop(i)\n                found = True\n                break\n        if not found:\n            return False\n    return True",
    "timestamp": "2025-08-13 08:49:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool canFulfillDrinkRequest(const vector<pair<string, double>>& availableLiquids,\n                            const vector<string>& requestedColors) {\n    unordered_map<string, double> colorDensityMap;\n    for (const auto& liquid : availableLiquids) {\n        colorDensityMap[liquid.first] = liquid.second;\n    }\n\n    vector<double> requestedDensities;\n    for (const string& color : requestedColors) {\n        if (colorDensityMap.find(color) == colorDensityMap.end())\n            return false; // requested color not available\n        requestedDensities.push_back(colorDensityMap[color]);\n    }\n\n    for (size_t i = 0; i < requestedDensities.size() - 1; i++) {\n        if (requestedDensities[i] <= requestedDensities[i + 1])\n            return false; // density does not decrease strictly\n    }\n\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<string, double>> availableLiquids(n);\n    for (int i = 0; i < n; i++) {\n        cin >> availableLiquids[i].first >> availableLiquids[i].second;\n    }\n    \n    int m;\n    cin >> m;\n    vector<string> requestedColors(m);\n    for (int i = 0; i < m; i++) {\n        cin >> requestedColors[i];\n    }\n    \n    if (canFulfillDrinkRequest(availableLiquids, requestedColors))\n        cout << \"Yes, the drink can be fulfilled.\" << endl;\n    else\n        cout << \"No, the drink cannot be fulfilled.\" << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:54"
  }
]