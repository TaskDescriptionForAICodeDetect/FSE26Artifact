[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=200005;\nvector<int> ea[maxn],eb[maxn];\nint st[maxn],ed[maxn],n,S,rt,ans,vis[maxn],fa[maxn];\nint dep[maxn];\nconst int inf=1e9;\ninline void dfs(int x,int f){\n\tfor(int w:eb[x]){\n\t\tif(w==f)continue;\n\t\tdep[w]=dep[x]+1;\n\t\tfa[w]=x;\n\t\tdfs(w,x);\n\t}\n}\ninline void calc(int x,int f,int cur){\n\tif(ans==inf)return;\n\tif(dep[x]<cur)return;\n\tif(dep[x]==cur){\n\t\tans=max(ans,cur<<1);\n\t\treturn;\n\t}\n\tif(vis[x]){\n\t\tans=inf;return;\n\t}\n\tfor(int w:ea[x]){\n\t\tif(w==f)continue;\n\t\tcalc(w,x,cur+1);\n\t}\n\tans=max(ans,dep[x]<<1);\n}\ninline bool get(int x,int y){\n\tif(dep[x]<dep[y])swap(x,y);\n\tif(fa[x]==y)return 0;\n\tif(fa[fa[x]]==y)return 0;\n\tif(fa[x]==fa[y])return 0;\n\treturn 1;\n}\nint main(){\n\tread(n);read(S);read(rt);\n\trep(i,1,n-1){\n\t\tread(st[i]);read(ed[i]);\n\t\tea[st[i]].pb(ed[i]);\n\t\tea[ed[i]].pb(st[i]);\n\t}\n\trep(i,1,n-1){\n\t\tint x,y;read(x);read(y);\n\t\teb[x].pb(y);eb[y].pb(x);\n\t}\n\tdfs(rt,0);\n\trep(i,1,n-1)if(get(st[i],ed[i]))vis[st[i]]=vis[ed[i]]=1;\n\tcalc(S,0,0);\n\tif(ans==inf)\n\t\tputs(\"-1\");\n\telse\n\t\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n    static const int BITLEN_MAX = 30;\n    vector<int> parent[BITLEN_MAX];\n    vector<int> depth;\n    int bitlen;\n\n    void initialize(int N, const vector<int> edges[]){\n        int root = 0;\n        bitlen = 1;\n        while((1<<bitlen) < N) bitlen += 1;\n        for(int i=0; i<bitlen; i++) parent[i].resize(N);\n        depth.resize(N, -1);\n\n        dfs(root, -1, 0, edges);\n        for(int k=0; k<bitlen-1; k++){\n            for(int v=0; v<N; v++){\n                if(depth[v] == -1) continue;\n                if(parent[k][v] < 0){\n                    parent[k+1][v] = -1;\n                }else{\n                    parent[k+1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n\n    void dfs(int v, int p, int d, const vector<int> edges[]){\n        parent[0][v] = p;\n        depth[v] = d;\n        for(auto u : edges[v]){\n            if(u != p) dfs(u, v, d+1, edges);\n        }\n    }\n\n    int calc_lca(int u, int v){\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int k=0; k<bitlen; k++){\n            if( ((depth[v]-depth[u]) >> k) & 1 ) v = parent[k][v];\n        }\n        if(u == v) return u;\n        for(int k=bitlen-1; k>=0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n    int calc_dist(int u, int v){\n        int l = calc_lca(u, v);\n        return depth[u] + depth[v] - depth[l]*2;\n    }\n};\n\nvector<int> edges[2][200000];\nint dist[2][200000];\nbitset<200000> dead, eternal;\n\nvoid dfs(int i, int p, int d, int k){\n    dist[k][i] = d;\n    for(int j : edges[k][i]) if(j != p) dfs(j, i, d+1, k);\n}\n\nint ans = 0;\nconst int INF = 1e9;\nvoid dfs2(int i, int p){\n    if(dead[i]) return;\n    ans = max(ans, eternal[i] ? INF : dist[1][i] * 2);\n    for(int j : edges[0][i]) if(j != p) dfs2(j, i);\n}\n\nint main(){\n    int N, S[2];\n    cin >> N >> S[0] >> S[1];\n    for(int k=0; k<2; k++){\n        for(int i=0; i<N-1; i++){\n            int a, b;\n            cin >> a >> b;\n            edges[k][a-1].push_back(b-1);\n            edges[k][b-1].push_back(a-1);\n        }\n        S[k]--;\n        dfs(S[k], -1, 0, k);\n    }\n\n    for(int i=0; i<N; i++) if(dist[0][i] >= dist[1][i]) dead[i] = true;\n\n    LCA lca1;\n    lca1.initialize(N, edges[1]);\n    for(int i=0; i<N; i++){\n        if(dead[i]) continue;\n        for(int j : edges[0][i]){\n            if(dead[j]) continue;\n            if(lca1.calc_dist(i, j) > 2) eternal[i] = eternal[j] = true;\n        }\n    }\n\n    dfs2(S[0], -1);\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\n\nint chk[N],u[N],v[N];\nint n,x,y,ans;\n\nstruct Edge{\n\tint y,nxt;\n};\n\nstruct Tree{\n\tEdge E[N*2];\n\tint fa[20][N];\n\tint las[N],dep[N];\n\tint cnt;\n\tTree(){\n\t\tmemset(las,-1,sizeof(las));\n\t}\n\tvoid Link(int x,int y){\n\t\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\t\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n\t}\n\tvoid dfs(int x){\n\t\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\t\tif ((y=E[i].y)!=fa[0][x]){\n\t\t\t\tfa[0][y]=x;\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\tdfs(y);\n\t\t\t}\n\t}\n\tint LCA(int x,int y){\n\t\tif (dep[x]>dep[y]) swap(x,y);\n\t\tfor (int k=dep[y]-dep[x],i=0;k;k>>=1,i++) if (k&1) y=fa[i][y];\n\t\tif (x==y) return x;\n\t\tfor (int i=19;~i;i--) if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];\n\t\treturn fa[0][x];\n\t}\n\tint dis(int x,int y){\n\t\treturn dep[x]+dep[y]-2*dep[LCA(x,y)];\n\t}\n\tvoid Work(int rt){\n\t\tdfs(rt);\n\t\tFor(i,1,20) For(x,1,n+1) fa[i][x]=fa[i-1][fa[i-1][x]];\n\t}\n} R,B;\n\nvoid Dfs(int x){\n\tchk[x]=chk[R.fa[0][x]]&&R.dep[x]<=B.dep[x];\n\tfor (int i=R.las[x],y;~i;i=R.E[i].nxt)\n\t\tif ((y=R.E[i].y)!=R.fa[0][x]){\n\t\t\tDfs(y);\n\t\t}\n}\n\nint main(){\n\tn=IN(),x=IN(),y=IN();\n\tFor(i,1,n){\n\t\tu[i]=IN(),v[i]=IN();\n\t\tR.Link(u[i],v[i]);\n\t}\n\tFor(i,1,n) B.Link(IN(),IN());\n\tR.Work(x);\n\tB.Work(y);\n\tchk[0]=1;\n\tDfs(x);\n\tFor(i,1,n){\n\t\tif (!chk[u[i]]&&!chk[v[i]]) continue;\n\t\tif (B.dis(u[i],v[i])>2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tFor(i,1,n+1) if (chk[i]) ans=max(ans,B.dep[i]);\n\tprintf(\"%d\\n\",2*ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define INF 1000000000\n\nint N, X, Y;\nvector <int> redAdjList[200005], blueAdjList[200005];\n\nint blueDist[200005], p[200005][20];\nvoid root(int u, int prevP, int prevDist)\n{\n\tblueDist[u] = prevDist; p[u][0] = prevP;\n\tfor (int v : blueAdjList[u])\n\t{\n\t\tif (v == prevP) continue;\n\t\troot(v, u, prevDist + 1);\n\t}\n}\n\nint getLca(int a, int b)\n{\n\tif (blueDist[a] < blueDist[b]) swap(a, b);\n\tfor (int k = 19; k >= 0; k--)\n\t{\n\t\tif (p[a][k] == -1) continue;\n\t\tif (blueDist[p[a][k]] >= blueDist[b]) a = p[a][k];\n\t}\n\tif (a == b) return a;\n\tfor (int k = 19; k >= 0; k--)\n\t{\n\t\tif (p[a][k] != p[b][k]) {a = p[a][k]; b = p[b][k];}\n\t}\n\treturn p[a][0];\n}\n\nint getDist(int a, int b)\n{\n\treturn blueDist[a] + blueDist[b] - blueDist[getLca(a, b)] * 2;\n}\n\nint getMaxDist(int u, int prevP, int prevDist)\n{\n\tint cur = blueDist[u] * 2;\n\t//printf(\"Calling getMaxDist(%d, %d, %d); dist: %d\\n\", u, prevP, prevDist, getDist(u, prevP));\n\tif (prevP != -1)\n\t{\n\t\tif (prevDist >= blueDist[u]) return 0;\n\t\tif (getDist(u, prevP) > 2) return INF;\n\t}\n\tfor (int v : redAdjList[u])\n\t{\n\t\tif (u == prevP) continue;\n\t\tcur = max(cur, getMaxDist(v, u, prevDist + 1));\n\t}\n\treturn cur;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tredAdjList[a].push_back(b); redAdjList[b].push_back(a);\n\t}\n\tfor (int i = 0; i < N - 1; i++)\n\t{\n\t\tint c, d; scanf(\"%d%d\", &c, &d);\n\t\tblueAdjList[c].push_back(d); blueAdjList[d].push_back(c);\n\t}\n\troot(Y, -1, 0);\n\tfor (int k = 1; k < 20; k++)\n\t{\n\t\tfor (int i = 1; i <= N; i++)\n\t\t{\n\t\t\tp[i][k] = -1;\n\t\t\tif (p[i][k-1] == -1) continue;\n\t\t\tp[i][k] = p[p[i][k-1]][k-1];\n\t\t}\n\t}\n\tint ans = getMaxDist(X, -1, 0);\n\tif (ans == INF) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2e+5+5;\n\nstruct edge{\n\tint x,nxt;\n}e1[N*2],e2[N*2];\nint h1[N],h2[N],tot1,tot2;\nint n,X,Y;\nint dep2[N],dep1[N];\nbool bz1[N],bz2[N];\nint fa[N][20];\nint ans;\ndb tim;\n\nvoid inse(int x,int y,int *h,edge *e,int &tot){e[++tot].x=y;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid dfs2(int x){\n\tbz2[x]=1;\n\tfo(i,1,tim)fa[x][i]=fa[fa[x][i-1]][i-1];\n\tfor(int p=h2[x];p;p=e2[p].nxt)\n\tif (!bz2[e2[p].x]){\n\t\tdep2[e2[p].x]=dep2[x]+1;\n\t\tfa[e2[p].x][0]=x;\n\t\tdfs2(e2[p].x);\n\t}\n}\n\nint getdis(int x,int y){\n\tint tmp=dep2[x]+dep2[y];\n\tif (dep2[x]<dep2[y])swap(x,y);\n\tfd(i,tim,0)\n\tif (fa[x][i]&&dep2[fa[x][i]]>=dep2[y])x=fa[x][i];\n\tif (x==y)return tmp-2*dep2[x];\n\tfd(i,tim,0)\n\tif (fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n\treturn tmp-2*dep2[x]+2;\n}\n\nvoid dfs1(int x){\n\tbz1[x]=1;\n\tif (dep1[x]>=dep2[x]){ans=max(ans,2*(dep1[x]+1));return;}\n\tans=max(ans,2*max(dep1[x],dep2[x]));\n\tfor(int p=h1[x];p;p=e1[p].nxt)\n\tif (!bz1[e1[p].x]){\n\t\tdep1[e1[p].x]=dep1[x]+1;\n\t\tdfs1(e1[p].x);\n\t\tint d=getdis(x,e1[p].x);\n\t\tif (d>2)ans=1e+9;\n\t}\n}\n\nint main(){\n\tn=get();X=get();Y=get();\n\tfo(i,2,n){int x=get(),y=get();inse(x,y,h1,e1,tot1);}\n\tfo(i,2,n){int x=get(),y=get();inse(x,y,h2,e2,tot2);}\n\ttim=log(n)/log(2);\n\tdfs2(Y);\n\tdfs1(X);\n\tprintf(\"%d\\n\",ans==1e+9?-1:ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 200005, LOG = 20;\nconst int INF = 0x3f3f3f3f;\n\nvector<int> T1[NMAX], T2[NMAX];\nint father[NMAX], level[NMAX];\nint anc[LOG][NMAX];\n\nint dist[NMAX];\n\nvoid dfs(int node, int prev) {\n    father[node] = prev;\n    for (int to: T2[node]) {\n        if (to != prev) {\n            level[to] = level[node] + 1;\n            dfs(to, node);\n        }\n    }\n}\n\nint goUp(int x, int lvl) {\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (lvl & (1 << k)) {\n            x = anc[k][x];\n        }\n    }\n    return x;\n}\n\nint lca(int x, int y) {\n    if (level[y] > level[x]) {\n        y = goUp(y, level[y] - level[x]);\n    } else if (level[x] > level[y]) {\n        x = goUp(x, level[x] - level[y]);\n    }\n    if (x == y) {\n        return x;\n    }\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (anc[k][x] != anc[k][y]) {\n            x = anc[k][x];\n            y = anc[k][y];\n        }\n    }\n    return father[x];\n}\n\nint xdist(int x, int y) {\n    return level[x] + level[y] - 2 * level[lca(x, y)];\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, r1, r2;\n    cin >> n >> r1 >> r2;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T1[x].push_back(y);\n        T1[y].push_back(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T2[x].push_back(y);\n        T2[y].push_back(x);\n    }\n    dfs(r2, -1);\n    father[r2] = r2;\n\n    for (int i = 1; i <= n; ++i) {\n        anc[0][i] = father[i];\n    }\n    for (int k = 1; k < LOG; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            anc[k][i] = anc[k - 1][anc[k - 1][i]];\n        }\n    }\n\n    memset(dist, INF, sizeof dist);\n    queue<int> q;\n    dist[r1] = 0;\n    q.push(r1);\n    int ans = 0;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        ans = max(ans, 2 * level[node]);\n\n        for (int to: T1[node]) {\n            if (xdist(node, to) > 2) {\n                cout << \"-1\\n\";\n                return 0;\n            }\n            if (dist[to] > dist[node] + 1 && dist[node] + 1 < level[to]) {\n                dist[to] = dist[node] + 1;\n                q.push(to);\n            }\n            if (dist[to] > dist[node] + 1 && dist[node] + 1 <= level[to]) {\n                ans = max(ans, 2 * level[to]);\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=400005;\nqueue<int > Q;\nint a[N],b[N],vis[N],dis[N],n,X,Y,c[N],d[N],flag[N];\nstruct Tree{\n\tint ne[N],tot,sd[N],fi[N],zz[N],fa[20][N],out[N],l,in[N];\n\tvoid jb(int x,int y){\n\t\tne[++tot]=fi[x];\n\t\tfi[x]=tot;\n\t\tzz[tot]=y;\n\t}\n\tvoid dfs(int x,int y,int z){\n\t\tfa[0][x]=y;sd[x]=z;in[x]=++l;\n\t\tfor (int i=fi[x];i;i=ne[i])\n\t\t\tif (zz[i]!=y)dfs(zz[i],x,z+1);\n\t\tout[x]=++l;\t\n\t}\n\tint pd(int x,int y){\n\t\tif (!x)return 1;\n\t\treturn in[x]<=in[y]&&out[x]>=out[y];\n\t}\n\tint lca(int x,int y){\n\t\tif (x==y)return x;\n\t\tif (sd[x]<sd[y])swap(x,y);\n\t\tfor (int i=19;i>=0;i--)\n\t\t\tif (!pd(fa[i][x],y))x=fa[i][x];\n\t\treturn fa[0][x];\n\t}\n\tint dis(int x,int y){\n\t\treturn sd[x]+sd[y]-2*sd[lca(x,y)];\n\t}\n\tvoid init(){\n\t\tfor (int i=1;i<=19;i++)\n\t\t\tfor (int j=1;j<=n;j++)fa[i][j]=fa[i-1][fa[i-1][j]];\n\t}\n}G1,G2;\nint main(){\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG1.jb(a[i],b[i]);G1.jb(b[i],a[i]);\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&c[i],&d[i]);\n\t\tG2.jb(c[i],d[i]);G2.jb(d[i],c[i]);\n\t}\n\tG1.dfs(1,0,0);G2.dfs(1,0,0);\n\tG1.init();G2.init();\n\tint ans=0;\n\tfor (int i=1;i<n;i++)\n\t\tif (G2.dis(a[i],b[i])>=3)flag[a[i]]=flag[b[i]]=1;\n\tQ.push(X);vis[X]=1;\n\twhile (!Q.empty()){\n\t\tint k=Q.front();Q.pop();\n\t\tfor (int i=G1.fi[k];i;i=G1.ne[i])\n\t\t\tif (!vis[G1.zz[i]]){\n\t\t\t\tdis[G1.zz[i]]=dis[k]+1;\n\t\t\t\tif (dis[G1.zz[i]]<G2.dis(G1.zz[i],Y))Q.push(G1.zz[i]),vis[G1.zz[i]]=1;\n\t\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (vis[i]){\n\t\t\tif (flag[i])ans=1e9;\n\t\t\telse ans=max(ans,G2.dis(i,Y)*2);\n\t\t}\n\tif (ans==1e9)puts(\"-1\");\n\telse printf(\"%d\\n\",ans);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nvector <int> y[N];\nll h1[N],h2[N];\nll par[N];\nvoid dfsg(ll v,ll p,ll h){\n    h1[v]=h;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfsg(u,v,h+1);\n    }\n}\nvoid dfsy(ll v,ll p,ll h){\n    h2[v]=h;\n    par[v]=p;\n    for (auto u : y[v]){\n        if (u==p) continue;\n        dfsy(u,v,h+1);\n    }\n}\nll check(ll u,ll v){\n    if (par[u]==par[v] || u==par[v] || v==par[u] || v==par[par[u]] || u==par[par[v]]) return 0;\n    return 1;\n}\nll dp[N];\nvoid dfs(ll v,ll p){\n    if (h1[v]>=h2[v]) return ;\n    dp[v]=h2[v]-h1[v];\n    dp[v]*=2;\n    for (auto u : g[v]){\n        if (p==u) continue;\n        dfs(u,v);\n        dp[v]=max(dp[v],dp[u]+2);\n        if (check(u,v)) dp[v]=1e9;\n    }\n}\nint32_t main(){\n    ll n,x,y1;\n    cin >> n >> x >> y1;\n    for (int i=0;i<n-1;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    for (int i=0;i<n-1;i++){\n        ll u,v;\n        cin >> u >> v;\n        y[u].pb(v);\n        y[v].pb(u);\n    }\n    dfsg(x,x,1);\n    dfsy(y1,y1,1);\n    dfs(x,x);\n    if (dp[x]==1e9) kill(-1);\n    kill(dp[x]);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define next nxt\n\nint n,s,t,a[N],b[N],d[N],x[N],y[N],z[N],next[N],p[N],f[N],h[N];\n\nvoid travel(int x){\n\tz[x]=z[f[x]]+1;\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (y[t]!=f[x])\n\t\tf[y[t]]=x,travel(y[t]);\n}\n\nvoid solve(int x){\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (!d[b[t]]&&d[x]+1<z[b[t]])\n\t\td[b[t]]=d[x]+1,solve(b[t]);\n}\n\nvoid build(int x[],int y[]){\n\tfill(p+1,p+n+1,0);\n\tfor (int i=1;i<=n-1;i++){\n\t\tnext[2*i-1]=p[x[2*i-1]];p[x[2*i-1]]=2*i-1;\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t}\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();s=read();t=read();\n\tfor (int i=1;i<=n-1;i++)\n\t\ta[2*i-1]=b[2*i]=read(),\n\t\tb[2*i-1]=a[2*i]=read();\n\tfor (int i=1;i<=n-1;i++)\n\t\tx[2*i-1]=y[2*i]=read(),\n\t\ty[2*i-1]=x[2*i]=read();\n\tbuild(x,y);travel(t);\n\tfor (int i=1;i<=2*n-2;i++)\n\t\tif (f[a[i]]!=b[i]&&f[f[a[i]]]!=b[i]&&\n\t\t\tf[b[i]]!=a[i]&&f[f[b[i]]]!=a[i]&&f[a[i]]!=f[b[i]])\n\t\th[a[i]]=1,h[b[i]]=1;\n\tbuild(a,b);d[s]=1;solve(s);\n\tint ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (d[i]&&h[i]) {printf(\"-1\\n\");return 0;};\n\t\tif (d[i]) ans=max(ans,2*(z[i]-1));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N, X, Y;\n\nvvll g;\nvvll h;\n\nvll par;\nvll ht;\n\nvoid dfsh(ll u, ll v) {\n\tpar[v] = u;\n\tht[v] = ht[u] + 1;\n\t\n\tfor (ll w : h[v]) {\n\t\tif (u == w) { continue; }\n\t\tdfsh(v, w);\n\t}\n\treturn;\n}\n\n\nint main(){\n\tcin >> N >> X >> Y;\n\tg.resize(N + 1);\n\th.resize(N + 1);\n\trepn(i, N - 1) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\trepn(i, N - 1) {\n\t\tll c, d;\n\t\tcin >> c >> d;\n\t\th[c].push_back(d);\n\t\th[d].push_back(c);\n\t}\n\n\tpar.assign(N + 1, 0);\n\tht.assign(N + 1, -1);\n\tdfsh(0, Y);\n\t//repn(v, N)cout << par[v] << ht[v] << endl;\n\n\n\tvll win(N + 1, 0);\n\trepn(v, N) {\n\t\tfor (ll w : g[v]) {\n\t\t\tbool b = 1;\n\t\t\tif (par[w] == v || par[v] == w) { b = 0; }\n\t\t\tif (par[par[w]] == v || par[v] == par[w] || par[par[v]] == w) { b = 0; }\n\t\t\tif (b) { win[v] = 1; break; }\n\t\t}\n\t}\n\n\tset<pair<ll, ll>> st;\n\tvll lis;\n\tvll vis(N + 1, 0);\n\n\tst.insert({ ht[X],X });\n\tvis[X] = 1;\n\tlis.push_back(X);\n\n\n\tll tern = 0;\n\twhile (!st.empty()) {\n\t\tvll nlis;\n\n\t\tfor (ll v : lis) {\n\t\t\tfor (ll w : g[v]) {\n\t\t\t\tif (vis[w] == 1) { continue; }\t\t\t\t\n\t\t\t\tif (ht[w] == tern) { continue; }\n\n\t\t\t\tnlis.push_back(w);\n\t\t\t\tst.insert({ ht[w],w });\n\t\t\t\tvis[w] = 1;\n\n\t\t\t\tif (win[w] == 1) { cout << -1 << endl; return 0; }\n\t\t\t}\n\t\t}\n\n\t\tlis = nlis;\n\t\twhile (!st.empty()&&(*st.begin()).first <= tern + 1) { st.erase(st.begin()); }\n\t\t\n\t\ttern++;\n\t\n\t}\n\n\tcout << tern * 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint n,x,y;\nint xx[N],yy[N];\nint head[N],ver[N*2],nxt[N*2],tot;\nvoid add(int a,int b)\n{\n\ttot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint dis[N];\nint f[N][20];\nvoid dfs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(ver[i]==fa)continue;\n\t\tdis[ver[i]]=dis[x]+1;\n\t\tf[ver[i]][0]=x;\n\t\tdfs(ver[i],x);\n\t}\n\treturn ;\n}\nint ans;\nbool v[N];\nint lca(int a,int b)\n{\n\tif(dis[a]<dis[b])swap(a,b);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dis[f[a][i]]>=dis[b])a=f[a][i];\n\t}\n\tif(a==b)return a;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(f[a][i]!=f[b][i])\n\t\t{\n\t\t\ta=f[a][i];b=f[b][i];\n\t\t}\n\t}\n\treturn f[a][0];\n}\nint calc(int a,int b)\n{\n\treturn dis[a]+dis[b]-2*dis[lca(a,b)];\n}\nvoid dffs(int x,int fa,int now)\n{\n\tif(ans!=-1)ans=max(ans,(dis[x]-1)*2);\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(ver[i]==fa)continue;\n\t\tif(dis[ver[i]]<=now+1)continue;\n\t\tif(calc(x,ver[i])>=3)\n\t\t{\n\t\t\tans=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tdffs(ver[i],x,now+1);\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tint t1,t2;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&xx[i],&yy[i]);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tadd(t1,t2);add(t2,t1);\n\t}\n\tdis[y]=1;dfs(y,-1);\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tf[j][i]=f[f[j][i-1]][i-1];\n\t\t}\n\t}\n\ttot=0;memset(head,0,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(xx[i],yy[i]);add(yy[i],xx[i]);\n\t}\n\tdffs(x,-1,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct Tree\n{\n\tstruct data\n\t{\n\t\tll w;\n\t};\n\t\n\tstruct node\n\t{\n\t\tint p; //parent\n\t\tll w; //modify for different problems\n\t};\n\t\n\tstruct edge\n\t{\n\t\tint v; data dat;\n\t};\n\t\n\tvector<vector<edge> > adj;\n\tint n;\n\tint s;\n\t\n\tTree(int _n, int _s)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n; s = _s;\n\t}\n\t\n\tvi level;\n\tvi depth;\n\tvi h;\n\tvi euler;\n\tvi firstocc;\n\tvector<vi> rmqtable;\n\tvi subsize;\n\tvi start; vi en;\n\tvector<vector<node> > st;\n\t\n\tvoid addedge(int u, int v)\n\t{\n\t\tedge tmp; tmp.v = v;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset(int _n)\n\t{\n\t\tadj.clear();\n\t\tlevel.clear();\n\t\tdepth.clear();\n\t\teuler.clear();\n\t\trmqtable.clear();\n\t\tsubsize.clear();\n\t\tstart.clear();\n\t\ten.clear();\n\t\tst.clear();\n\t\tfirstocc.clear();\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid dfssub(int u, int p)\n\t{\n\t\tsubsize[u] = 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfssub(v, u);\n\t\t\tsubsize[u] += subsize[v];\n\t\t}\n\t}\n\t\n\tvoid calcsub()\n\t{\n\t\tsubsize.resize(n);\n\t\tdfssub(0, -1);\n\t}\n\t\n\tint timer;\n\t\n\tvoid dfsstartend(int u, int p)\n\t{\n\t\tstart[u] = ++timer;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfsstartend(v, u);\n\t\t}\n\t\ten[u] = ++timer;\n\t}\n\t\n\tvoid calcstartend()\n\t{\n\t\ttimer = 0;\n\t\tstart.resize(n); en.resize(n); h.resize(n);\n\t\tdfsstartend(0, -1);\n\t}\n\t\n\tint eulercnt;\n\t\n\tvoid dfseuler(int u, int p)\n\t{\n\t\teuler[eulercnt] = u; eulercnt++;\n\t\tif(p == -1) {depth[u] = 0;}\n\t\telse {depth[u] = depth[p] + 1;}\n\t\tfirstocc[u] = eulercnt-1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue ;\n\t\t\tdfseuler(v, u);\n\t\t\teuler[eulercnt] = u; eulercnt++;\n\t\t}\n\t}\n\t\n\tvoid calceuler()\n\t{\n\t\teulercnt = 0;\n\t\tlevel.assign(2*n+1, 0);\n\t\teuler.assign(2*n+1, 0);\n\t\tdepth.assign(n, 0);\n\t\tfirstocc.resize(n);\n\t\tdfseuler(s, -1);\n\t}\n\n\tvoid filllevel()\n\t{\n\t\tint LG = 0;\n\t\twhile((1<<LG) <= n*2) LG++;\n\t\trmqtable.resize(LG);\n\t\tfor(int i = 0; i < LG; i++) rmqtable[i].resize(eulercnt);\n\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t{\n\t\t\tlevel[i] = depth[euler[i]];\n\t\t}\n\t\tlevel[eulercnt] = 1000000000;\n\t\tfor(int j = 0; j < LG; j++)\n\t\t{\n\t\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t\t{\n\t\t\t\trmqtable[j][i] = eulercnt;\n\t\t\t\tif(i + (1<<j) - 1 < eulercnt)\n\t\t\t\t{\n\t\t\t\t\tif(j == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trmqtable[j][i] = i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(level[rmqtable[j - 1][i]] < level[rmqtable[j-1][i + (1<<(j-1))]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i + (1<<(j-1))];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint rmq(int l, int r)\n\t{\n\t\tint k = 31 - __builtin_clz(r-l);\n\t\t//cout << l << ' ' << r << ' ' << rmqtable[l][k] << ' ' << rmqtable[r - (1<<k) + 1][k] << endl;\n\t\tif(level[rmqtable[k][l]] < level[rmqtable[k][r - (1<<k) + 1]])\n\t\t{\n\t\t\treturn rmqtable[k][l];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn rmqtable[k][r - (1<<k) + 1];\n\t\t}\n\t}\n\n\tint lcaeuler(int u, int v)\n\t{\n\t\tif(firstocc[u] > firstocc[v]) swap(u, v);\n\t\t//cerr << firstocc[u] << ' ' << firstocc[v] << ' ' << rmq(firstocc[u], firstocc[v]) << ' ' << euler[rmq(firstocc[u], firstocc[v])] << endl;\n\t\treturn euler[rmq(firstocc[u], firstocc[v])];\n\t}\n\t\n\tbool insub(int u, int v) //is u in the subtree of v?\n\t{\n\t\tif(start[v] <= start[u] && en[u] <= en[v]) return true;\n\t\treturn false;\n\t}\n\t\n\tvoid dfspar(int u, int p)\n\t{\n\t\t//cerr << u << ' ' << p << '\\n';\n\t\tst[0][u].p = p;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfspar(v, u);\n\t\t}\n\t}\n\t\n\tint LOG;\n\t\n\tvoid calcpar()\n\t{\n\t\th.resize(n);\n\t\tint LG = 0; LOG = 0;\n\t\twhile((1<<LG) <= n) {LG++; LOG++;}\n\t\tst.resize(LG);\n\t\tfor(int i = 0; i < LG; i++)\n\t\t{\n\t\t\tst[i].resize(n);\n\t\t}\n\t\tdfspar(s, -1);\n\t\t//cerr << \"HER\" << ' ' << LG << endl;\n\t\tfor(int i = 1; i < LG; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif(st[i-1][j].p == -1) st[i][j].p = -1;\n\t\t\t\telse st[i][j].p = st[i-1][st[i-1][j].p].p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getpar(int u, ll k)\n\t{\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(k&(1<<i))\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t}\n\t\t}\n\t\treturn u;\n\t}\n\t\n\tint lca(int u, int v)\n\t{\n\t\tif(h[u] > h[v]) swap(u, v);\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && h[st[i][v].p] >= h[u])\n\t\t\t{\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && st[i][v].p != st[i][u].p)\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\treturn st[0][u].p;\n\t}\n\n\tint distance(int u, int v)\n\t{\n\t\tint lc = lca(u, v);\n\t\treturn (h[u]+h[v]-2*h[lc]);\n\t}\n};\n\nint U[211111],V[211111];\nvi adj[211111];\nint dist[211111];\nbool bad[211111];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n; int s,e; cin>>s>>e; s--; e--;\n\tTree T(n,e);\n\tfor(int i=0;i<n-1;i++){cin>>U[i]>>V[i]; U[i]--; V[i]--;}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tT.addedge(u,v);\n\t}\n\tT.calcpar();\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u=U[i]; int v=V[i];\n\t\tif(T.distance(u,v)>=3) bad[u]=bad[v]=1;\n\t\telse {adj[u].pb(v); adj[v].pb(u);}\n\t}\n\tfor(int i=0;i<n;i++) dist[i]=int(1e9);\n\tdist[s]=0;\n\tqueue<int> q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front(); q.pop();\n\t\tfor(int i=0;i<adj[u].size();i++)\n\t\t{\n\t\t\tint v=adj[u][i];\n\t\t\tif(dist[v]>=int(1e9))\n\t\t\t{\n\t\t\t\tif(dist[u]+1<T.h[v])\n\t\t\t\t{\n\t\t\t\t\tdist[v]=dist[u]+1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(dist[i]<int(1e9)&&bad[i])\n\t\t{\n\t\t\tcout<<-1<<'\\n'; return 0;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(dist[i]<int(1e9))\n\t\t{\n\t\t\tans=max(ans,2*T.h[i]);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N, X, Y;\n\nvvll g;\nvvll h;\n\nvll par;\nvll ht;\n\nvoid dfsh(ll u, ll v) {\n\tpar[v] = u;\n\tht[v] = ht[u] + 1;\n\t\n\tfor (ll w : h[v]) {\n\t\tif (u == w) { continue; }\n\t\tdfsh(v, w);\n\t}\n\treturn;\n}\n\n\nint main(){\n\t\n\tcin >> N >> X >> Y;\n\tg.resize(N + 1);\n\th.resize(N + 1);\n\trepn(i, N - 1) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\trepn(i, N - 1) {\n\t\tll c, d;\n\t\tcin >> c >> d;\n\t\th[c].push_back(d);\n\t\th[d].push_back(c);\n\t}\n\n\tpar.assign(N + 1, 0);\n\tht.assign(N + 1, -1);\n\tdfsh(0, Y);\n\t//repn(v, N)cout << par[v] << ht[v] << endl;\n\n\n\tvll win(N + 1, 0);\n\trepn(v, N) {\n\t\tfor (ll w : g[v]) {\n\t\t\tbool b = 1;\n\t\t\tif (par[w] == v || par[v] == w) { b = 0; }\n\t\t\tif (par[par[w]] == v || par[v] == par[w] || par[par[v]] == w) { b = 0; }\n\t\t\tif (b) { win[v] = 1; break; }\n\t\t}\n\n\t\t//cout << v << win[v] << endl;\n\t}\n\n\tset<pair<ll, ll>> st;\n\tvll lis;\n\tvll vis(N + 1, 0);\n\n\tst.insert({ ht[X],X });\n\tvis[X] = 1;\n\tlis.push_back(X);\n\n\n\tll tern = 0;\n\twhile (!st.empty()) {\n\t\tvll nlis;\n\n\t\tvll winlis;\n\n\t\tfor (ll v : lis) {\n\t\t\tif (!st.count({ ht[v],v })) { continue; }\n\n\t\t\tfor (ll w : g[v]) {\n\t\t\t\tif (vis[w] == 1) { continue; }\t\t\t\t\n\t\t\t\tif (ht[w] == tern) { continue; }\n\n\t\t\t\tnlis.push_back(w);\n\t\t\t\tst.insert({ ht[w],w });\n\t\t\t\tvis[w] = 1;\n\n\t\t\t\tif (win[w] == 1) { winlis.push_back(w); }\n\t\t\t}\n\t\t}\n\n\t\tlis = nlis;\n\t\twhile (!st.empty()&&(*st.begin()).first <= tern + 1) {\n\t\t\tst.erase(st.begin());\n\t\t}\n\n\t\tfor (ll w : winlis) {\n\t\t\tif (st.count({ ht[w], w })) { cout << -1 << endl; return 0; }\n\t\t}\n\t\t\n\t\ttern++;\n\t\n\t}\n\n\tcout << tern * 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"ctime\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Lowest_Common_Ancestor {\n\tvector<int>depth;\n\tvector<vector<int>>parent;\n\tvector<vector<int>>edge;\n\tint height = 0;\n\tint node;\npublic:\n\tLowest_Common_Ancestor(int num) {\n\t\tnum++;\n\t\tnode = num;\n\t\twhile (num) {\n\t\t\theight++;\n\t\t\tnum /= 2;\n\t\t}\n\t\tparent.resize(height);\n\t\tedge.resize(node);\n\t\tdepth.resize(node);\n\t\tfor (int i = 0; i < height; i++)parent[i].resize(node);\n\t}\n\tvoid Add_Edge(int a, int b) {\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\treturn;\n\t}\n\tvoid Update(int rtnode) {\n\t\tqueue<int>QQ;\n\t\tfor (int i = 0; i < node; i++) depth[i] = INT_MAX;\n\t\tdepth[rtnode] = 0;\n\t\tQQ.push(rtnode);\n\t\twhile (!QQ.empty()) {\n\t\t\tint c = QQ.front();\n\t\t\tfor (auto i : edge[c]) {\n\t\t\t\tif (depth[i] > depth[c] + 1) {\n\t\t\t\t\tdepth[i] = depth[c] + 1;\n\t\t\t\t\tQQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQQ.pop();\n\t\t}\n\t\tparent[0][rtnode] = -1;\n\t\tfor (int i = 1; i < node; i++) {\n\t\t\tfor (auto j : edge[i]) {\n\t\t\t\tif (depth[i] - 1 == depth[j]) {\n\t\t\t\t\tparent[0][i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < height - 1; i++) {\n\t\t\tfor (int j = 0; j < node; j++) {\n\t\t\t\tif (parent[i][j] < 0)parent[i + 1][j] = -1;\n\t\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint LCA(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tif ((depth[v] - depth[u]) >> i & 1) {\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int i = height - 1; i >= 0; i--) {\n\t\t\tif (parent[i][v] != parent[i][u]) {\n\t\t\t\tu = parent[i][u];\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\tint Dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - depth[LCA(u, v)] * 2;\n\t}\n};\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tvector<vector<int>>edge(N + 1);\n\tLowest_Common_Ancestor lca(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tedge[H].push_back(W);\n\t}\n\tvector<vector<int>>wedge(N + 1);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\twedge[H].push_back(W);\n\t\twedge[W].push_back(H);\n\t\tlca.Add_Edge(H, W);\n\t}\n\tlca.Update(1);\n\tvector<int>safe(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (lca.Dist(i, j) > 2)safe[i] = safe[j] = 1;\n\t\t}\n\t}\n\tvector<int>depth(N + 1, MOD);\n\tCalculate_Depth(wedge, depth, R);\n\tvector<int>dist(N + 1, MOD);\n\tdist[L] = 0;\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>PQ;\n\tPQ.push({ 0,L });\n\twhile (!PQ.empty()) {\n\t\tauto box = PQ.top();\n\t\tPQ.pop();\n\t\tint cn = box.second;\n\t\tint c = box.first;\n\t\tif (safe[cn]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (dist[cn] < c)continue;\n\t\tfor (auto i : edge[cn]) {\n\t\t\tauto dis = lca.Dist(i, cn);\n\t\t\tif (dis > 2)continue;\n\t\t\tif (dist[i] > c + 1 && c + 1 < depth[i]) {\n\t\t\t\tdist[i] = c + 1;\n\t\t\t\tPQ.push({ dist[i],i });\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (dist[i] == MOD)continue;\n\t\tans = max(ans, depth[i]);\n\t}\n\tcout << (ans << 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tdebug(\"%d->%d : %d\\n\",u,v,d);\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(!bad[u])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(ok[i] && (!bad[u1[i]]||!bad[v1[i]])){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\nusing namespace std;\ntypedef long long LL;\nconst int N=4e5+100;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint head[N],nxt[N],to[N],fa[N],dep[N];\nint ans,u[N],v[N];\nvector<int>e[N];\ninline void dfs(int k) {\n\tfor (int i=head[k];i;i=nxt[i])\n\t\tif (to[i]!=fa[k])\n\t\t\tfa[to[i]]=k,dep[to[i]]=dep[k]+1,dfs(to[i]);\n}\nbool win[N];\ninline bool check(int a,int b) {\n\tif (fa[a]==b||fa[b]==a) return false;\n\tif (fa[a]==fa[b]||fa[fa[a]]==b||fa[fa[b]]==a) return false;\n\treturn true;\n}\ninline void dfs(int k,int fa,int t) {\n\tif (win[k]) puts(\"-1\"),exit(0);\n\tans=max(ans,dep[k]);\n\tfor (int y:e[k])\n\t\tif (y!=fa)\n\t\t\tif (dep[y]>t)\n\t\t\t\tdfs(y,k,t+1);\n}\nint main()\n{\n\tint n=gi(),x=gi(),y=gi(),i,a,b,tot=0;\n\tfor (i=1;i<n;i++) u[i]=gi(),v[i]=gi(),e[u[i]].push_back(v[i]),e[v[i]].push_back(u[i]);\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\tto[++tot]=b,nxt[tot]=head[a],head[a]=tot;\n\t\tto[++tot]=a,nxt[tot]=head[b],head[b]=tot;\n\t}\n\tdfs(y);\n\tfor (i=1;i<n;i++) if (check(u[i],v[i])) win[u[i]]=win[v[i]]=true;\n\n\tdfs(x,0,1);\n\tprintf(\"%d\\n\",ans<<1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,y,ans;\n\nvector<int> G[maxn],G2[maxn];\n\nint tim[maxn];\n\nvoid dfs2(int u,int fa){\n\ttim[u]=tim[fa]+1;\n\tfor(auto v:G2[u])if(v!=fa)dfs2(v,u);\n}\n\nvoid dfs1(int u,int fa,int now){\n\tans=max(ans,(tim[u]-1)*2);\n\tfor(auto v:G[u])if(now+1<tim[v]&&v!=fa){\n\t\tdfs1(v,u,now+1);\n\t}\n}\n\nvoid Work(){\n\tif(x==y){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tdfs2(y,0);\n\tdfs1(x,0,1);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,x,y);\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG2[u].PB(v);G2[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define RepG0(i, x) for (int i = head0[x]; i; i = edge0[i].next)\n#define v0 edge0[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 200010;\nstruct Edge{ int to, next;} edge[N * 2], edge0[N * 2];\n\nint head[N], num, head0[N], num0;\n\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\nvoid add_edge0(int a, int b) { edge0[++ num0] = (Edge){b, head0[a]}, head0[a] = num0;}\n\nint f[N], dep[N];\n\nvoid dfs(int x)\n{\n\t//printf(\"_%d %d\\n\", x, f[x]);\n\tRepG0(i, x) if (v0 != f[x]) {\n\t\tdep[v0] = dep[x] + 1, f[v0] = x;\n\t\tdfs(v0);\n\t}\n}\n\nbool jud(int x, int y) { return (f[x] == y || f[f[x]] == y || f[y] == x || f[f[y]] == x || f[x] == f[y]); }\n\nbool flag;\nint ans;\n\nvoid dfs(int x, int fa, int dis)\n{\n\tif (dis >= dep[x]) return;\n\telse ans = max(ans, dep[x]);\n\tRepG(i, x) if (v != fa) {\n\t\tif (jud(x, v)) dfs(v, x, dis + 1); \n\t\telse{\n\t\t\tflag = true;\n\t\t//\tprintf(\"%d %d ???\\n\", x, v);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, x, y;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge(a, b); add_edge(b, a);\n\t}\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge0(a, b); add_edge0(b, a);\n\t}\n\tdfs(y); dfs(x, 0, 0);\n\t\n\tif (flag) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans * 2);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nconst int N=1e5+5;\nint n;\n\ntemplate <class T> inline void apx(T &x,const T y){\n\tif(x<y) x=y;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=getchar())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\treturn x;\n}\n\nnamespace G{\n\tint st_f,st_s,dep[N],xdis;\n\tint fa[N],sz[N],son[N],top[N];\n\tbool entr[N];\n\tstd::vector <int> vf[N],vs[N];\n\n\tinline int get_lca(int x,int y){\n\t\twhile(top[x]!=top[y]){\n\t\t\tdep[top[x]]>dep[top[y]]?x=fa[top[x]]:y=fa[top[y]];\n\t\t}\n\t\treturn dep[x]<dep[y]?x:y;\n\t}\n\n\tinline int get_dis(const int x,const int y){\n\t\treturn dep[x]+dep[y]-(dep[get_lca(x,y)]<<1);\n\t}\n\n\tvoid dfs_sz(const int x){\n\t\tsz[x]=1;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!sz[*it]){\n\t\t\t\tdep[*it]=dep[x]+1;\n\t\t\t\tfa[*it]=x;\n\t\t\t\tdfs_sz(*it);\n\t\t\t\tif(sz[*it]>sz[son[x]]) son[x]=*it;\n\t\t\t\tsz[x]+=sz[*it];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs_top(const int x){\n\t\ttop[x]=son[fa[x]]==x?top[fa[x]]:x;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!top[*it]) dfs_top(*it);\n\t\t}\n\t}\n\n\tbool dfs_free(const int x,const int fa,const int dis){\n\t\tstd::vector <int> ::iterator it;\n\t\tif(dis<dep[x]){\n\t\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\t\tif(get_dis(x,*it)>2) return 1;\n\t\t\t}\n\t\t}\n\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(*it!=fa){\n\t\t\t\tif(dfs_free(*it,x,dis+1)) return 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid dfs_xdis(const int x,const int fa,const int dis){\n\t\tapx(xdis,dep[x]);\n\t\tfor(std::vector <int> ::iterator it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(dis+1==dep[*it]) apx(xdis,dis+1);\n\t\t\tif(dis+1<dep[*it]){\n\t\t\t\tdfs_xdis(*it,x,dis+1);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main(){\n\tn=nxi();\n\tG::st_f=nxi(),G::st_s=nxi();\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vf[x].push_back(y);\n\t\tG::vf[y].push_back(x);\n\t}\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vs[x].push_back(y);\n\t\tG::vs[y].push_back(x);\n\t}\n\tG::dfs_sz(G::st_s);\n\tG::dfs_top(G::st_s);\n\tif(G::dfs_free(G::st_f,0,0)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tG::dfs_xdis(G::st_f,0,0);\n\tprintf(\"%d\\n\",G::xdis<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e5+5;\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<2];\nint ha[N], hb[N], tot;\nvoid _add(int *h, int x, int y) { edge[++tot] = Edge(h[x], y); h[x] = tot; }\nvoid add(int *h, int x, int y) { _add(h, x, y); _add(h, y, x); }\nint fa[N], son[N], size[N], top[N], d[N];\nint ans, cir;\nvoid dfs(int x)\n{\n    size[x] = 1;\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; if(y == fa[x]) continue;\n        d[y] = d[x]+1, fa[y] = x, dfs(y), \n        size[x] += size[y], son[x] = size[son[x]]>size[y]?son[x]:y; \n    }\n}\nint lca(int x, int y)\n{\n    while(top[x] != top[y])\n    {\n        if(d[top[x]] < d[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint dis(int x, int y) { return d[x]+d[y]-2*d[lca(x, y)]; }\nvoid dfs(int x, int topf)\n{\n    top[x] = topf; if(son[x]) dfs(son[x], topf);\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(y != fa[x]&&y != son[x]) dfs(y, y);\n    }\n}\nvoid escape(int x, int fa, int dep)\n{\n    ans = max(ans, d[x]<<1); \n    for(int i = ha[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(dis(x, y) > 2) cir = 1;    \n        if(y == fa||dep >= d[y]) continue;\n        escape(y, x, dep+1);\n    }\n}\nint n, a, b;\nint main()\n{\n    n = read(), a = read(), b = read();\n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(ha, x, y);\n    } \n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(hb, x, y);\n    }\n    dfs(b); dfs(b, b); escape(a, 0, 0);\n    printf(\"%d\\n\", cir?-1:ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"ctime\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Lowest_Common_Ancestor {\n\tvector<int>depth;\n\tvector<vector<int>>parent;\n\tvector<vector<int>>edge;\n\tint height = 0;\n\tint node;\npublic:\n\tLowest_Common_Ancestor(int num) {\n\t\tnum++;\n\t\tnode = num;\n\t\twhile (num) {\n\t\t\theight++;\n\t\t\tnum /= 2;\n\t\t}\n\t\tparent.resize(height);\n\t\tedge.resize(node);\n\t\tdepth.resize(node);\n\t\tfor (int i = 0; i < height; i++)parent[i].resize(node);\n\t}\n\tvoid Add_Edge(int a, int b) {\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\treturn;\n\t}\n\tvoid Update(int rtnode) {\n\t\tqueue<int>QQ;\n\t\tfor (int i = 0; i < node; i++) depth[i] = INT_MAX;\n\t\tdepth[rtnode] = 0;\n\t\tQQ.push(rtnode);\n\t\twhile (!QQ.empty()) {\n\t\t\tint c = QQ.front();\n\t\t\tfor (auto i : edge[c]) {\n\t\t\t\tif (depth[i] > depth[c] + 1) {\n\t\t\t\t\tdepth[i] = depth[c] + 1;\n\t\t\t\t\tQQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQQ.pop();\n\t\t}\n\t\tparent[0][rtnode] = -1;\n\t\tfor (int i = 1; i < node; i++) {\n\t\t\tfor (auto j : edge[i]) {\n\t\t\t\tif (depth[i] - 1 == depth[j]) {\n\t\t\t\t\tparent[0][i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < height - 1; i++) {\n\t\t\tfor (int j = 0; j < node; j++) {\n\t\t\t\tif (parent[i][j] < 0)parent[i + 1][j] = -1;\n\t\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint LCA(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tif ((depth[v] - depth[u]) >> i & 1) {\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int i = height - 1; i >= 0; i--) {\n\t\t\tif (parent[i][v] != parent[i][u]) {\n\t\t\t\tu = parent[i][u];\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\tint Dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - depth[LCA(u, v)] * 2;\n\t}\n};\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tvector<vector<int>>edge(N + 1);\n\tLowest_Common_Ancestor lca(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tedge[H].push_back(W);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tlca.Add_Edge(H, W);\n\t}\n\tlca.Update(1);\n\tvector<int>safe(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (lca.Dist(i, j) > 2)safe[i] = safe[j] = 1;\n\t\t}\n\t}\n\tvector<int>depth(N + 1, MOD);\n\tCalculate_Depth(edge, depth, L);\n\tvector<int>reachable(N + 1);\n\treachable[L] = lca.Dist(R, L);\n\tqueue<int>Q;\n\tQ.push(L);\n\twhile (!Q.empty()){\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (reachable[i])continue;\n\t\t\tif (depth[i] < lca.Dist(R, i)) {\n\t\t\t\treachable[i] = lca.Dist(R, i);\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tans = max(ans, reachable[i]);\n\t}\n\tans <<= 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (reachable[i] && safe[i])ans = -1;\n\t}\n\tassert(ans == -1);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X,Y;\nvector<int> E[202020],E2[202020];\n\nint P[21][200005],D[200005],D2[200005];\n\nvoid dfs(int cur) {\n\tITR(it,E[cur]) if(*it!=P[0][cur]) D[*it]=D[cur]+1, P[0][*it]=cur, dfs(*it);\n}\nint dist(int a,int b) {\n\tint ret=0,i,aa=a,bb=b;\n\tif(D[aa]>D[bb]) swap(aa,bb);\n\tfor(i=19;i>=0;i--) if(D[bb]-D[aa]>=1<<i) bb=P[i][bb];\n\tfor(i=19;i>=0;i--) if(P[i][aa]!=P[i][bb]) aa=P[i][aa], bb=P[i][bb];\n\treturn D[a]+D[b]-2*D[(aa==bb)?aa:P[0][aa]];  // dist\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>X>>Y;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE2[x].push_back(y);\n\t\tE2[y].push_back(x);\n\t}\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\t\n\tdfs(Y);\n\tFOR(i,19) FOR(x,N) P[i+1][x+1]=P[i][P[i][x+1]];\n\tFOR(i,N) D2[i+1]=10101010;\n\t\n\tint ret=0;\n\tqueue<int> Q;\n\tD2[X]=0;\n\tQ.push(X);\n\twhile(Q.size()) {\n\t\tx = Q.front();\n\t\tQ.pop();\n\t\tif(D2[x]>D[x]) continue;\n\t\tFORR(e,E2[x]) if(dist(i+1,e)>=3) return _P(\"-1\\n\");\n\t\tret=max(ret,D[x]);\n\t\t\n\t\tFORR(e,E2[x]) if(D2[e]>D2[x]+1) D2[e]=D2[x]+1, Q.push(e);\n\t}\n\t\n\tcout<<ret*2<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"trapv\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<18;\nint n, pu[maxn], du[maxn], s, u, inf = 0, ans = -(1<<30);\nvector<int> gs[maxn], gu[maxn];\nvoid preu(int v) {\n\tfor(auto i : gu[v]) if(pu[v] != i) du[i] = du[v] + 1, pu[i] = v, preu(i);\n}\nint d1(int u, int v) {\n\treturn pu[u] == v || pu[v] == u;\n}\nint d2(int u, int v) {\n\treturn pu[pu[u]] == v || pu[pu[v]] == u || pu[u] == pu[v];\n}\nint bad(int u, int v) {\n\treturn d1(u, v) + d2(u, v);\n}\nvoid dfs(int v, int p = 0, int d = 0) {\n\tif(d >= du[v]) return;\n\tans = max(ans, max(d, du[v])+du[v]);\n\tint bd = 1;\n\tfor(auto i : gs[v]) bd &= bad(v, i);\n\tif(!bd) inf = 1;\n\tfor(auto i : gs[v]) if(i != p) dfs(i, v, d+1);\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> s >> u;\n\tfor(auto &g : {gs, gu})\n\tfor(int f, t, i = 1; i < n; i++) {\n\t\tcin >> f >> t;\n\t\tg[f].push_back(t);\n\t\tg[t].push_back(f);\n\t}\n\tpreu(u);\n\tdfs(s);\n\tcout << (inf ? -1 : ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ Fast IO\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 200010;\n\nint n;\n\nvector<pair<int, int> >E;\n\nstruct Graph {\n\tint S;\n\tint tot;\n\tint fi[MAXN];\n\tint dep[MAXN];\n\tint fa[MAXN][20];\n\tint ne[MAXN << 1];\n\tint to[MAXN << 1];\n\n\tinline void Link(int u, int v) {\n\t\ttot++;\n\t\tto[tot] = v;\n\t\tne[tot] = fi[u];\n\t\tfi[u] = tot;\n\t}\n\n\tinline void dfs(int x, int la) {\n\t\tfa[x][0] = la, dep[x] = dep[la] + 1;\n\t\tfor(int i = 1; i < 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n\t\tfor(int i = fi[x]; i; i = ne[i]) {\n\t\t\tint u = to[i];\n\t\t\tif(u == la) continue;\n\t\t\tdfs(u, x);\n\t\t}\n\t}\n\n\tinline int LCA(int x, int y) {\n\t\tif(dep[x] < dep[y]) swap(x, y);\n\t\tint k = dep[x] - dep[y];\n\t\tfor(int i = 0; i < 20; i++)\n\t\t \tif(k & (1 << i)) x = fa[x][i];\n\t\tif(x == y) return x;\n\t\tfor(int i = 19; ~i; --i)\n\t\t\tif(fa[x][i] != fa[y][i])\n\t\t\t\tx = fa[x][i], y = fa[y][i];\n\t\treturn fa[x][0];\n\t}\n\n\tinline int dis(int u, int v) { return dep[u] + dep[v] - dep[LCA(u, v)] * 2; }\n\tinline int dis_S(int x) { return dep[x] - 1; }\n\n\tinline void AddEdge(int ty = 0) {\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tint u = ri, v = ri;\n\t\t\tLink(u, v), Link(v, u);\n\t\t\tif(ty) E.push_back(make_pair(u, v));\n\t\t} dfs(S, S);\n\t}\n}A, B;\n\nint vis[MAXN];\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tn = ri, A.S = ri, B.S = ri;\n\tA.AddEdge(1), B.AddEdge();\n\tfor(auto e : E) {\n\t\tint u = e.first, v = e.second;\n\t\tif(B.dis(u, v) > 2) {\n\t\t\tint miA = min(A.dep[u], A.dep[v]) - 1;\n\t\t\tint miB = min(B.dep[u], B.dep[v]) - 1;\n\t\t\tif(miA < miB) return puts(\"-1\"), 0;\n\t\t}\n\t} int res = B.dep[A.S] - 1;\n\tqueue<int>q;\n\tq.push(A.S), vis[A.S] = 1;\n\twhile(!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\tfor(int i = A.fi[x]; i; i = A.ne[i]) {\n\t\t\tint u = A.to[i];\n\t\t\tif(vis[u] || A.dep[u] >= B.dep[u]) continue;\n\t\t\tvis[u] = 1;\n\t\t\tchkmax(res, B.dep[u] - 1);\n\t\t\tq.push(u);\n\t\t}\n\t}\n\tcout << res * 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200000\n#define MD 18\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,X,Y,h1[MN+5],h2[MN+5],cnt=0,d1[MN+5],d2[MN+5],q[MN+5],top;\nint nl[MN+5],nr[MN+5],dn=0,vis[MN+5],dep[MN+5],fa[MD+1][MN+5],flag,ans=0;\nstruct edge{int to,next;}e[MN*4+5];\ninline void ins(int*H,int f,int t)\n{\n\te[++cnt]=(edge){t,H[f]};H[f]=cnt;\n\te[++cnt]=(edge){f,H[t]};H[t]=cnt;\t\n}\nvoid Bfs(int*d,int*head,int s)\n{\n\tmemset(vis,0,sizeof(vis));\n\tvis[q[top=1]=s]=1;\n\tfor(int i=1;i<=top;++i)\n\t\tfor(int j=head[q[i]];j;j=e[j].next)\n\t\t\tif(!vis[e[j].to]) vis[e[j].to]=1,d[q[++top]=e[j].to]=d[q[i]]+1;\t\n}\nvoid Pre(int x,int f)\n{\n\tfa[0][x]=f;nl[x]=++dn;\n\tfor(int i=h2[x];i;i=e[i].next)\n\t\tif(e[i].to!=f) dep[e[i].to]=dep[x]+1,Pre(e[i].to,x);\n\tnr[x]=dn;\n}\ninline int GetUp(int x,int k)\n{\n\tfor(int j=0;k;k>>=1,++j) if(k&1) x=fa[j][x];\n\treturn x;\n}\ninline int lca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tx=GetUp(x,dep[x]-dep[y]);\n\tif(x==y) return x;\n\tfor(int i=MD;~i;--i) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\ninline int dis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\ninline int Move(int x,int y)\n{\n\tif(x==y) return x;\n\tif(nl[y]>=nl[x]&&nl[y]<=nr[x]) return GetUp(y,dep[y]-dep[x]-1);\n\telse return fa[0][x];\n}\nvoid dfs(int x,int fa,int oth)\n{\n\tans=max(ans,d1[x]+dis(x,oth));\n\tif(x==oth) return;\n\tfor(int i=h1[x];i;i=e[i].next)\n\t\tif(dis(e[i].to,x)>2) flag=1;\n\tfor(int i=h1[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa&&e[i].to!=oth) dfs(e[i].to,x,Move(oth,e[i].to));\n}\nint main()\n{\n\tn=read();X=read();Y=read();\n\tfor(int i=1;i<n;++i) ins(h1,read(),read());\n\tfor(int i=1;i<n;++i) ins(h2,read(),read());\n\tBfs(d1,h1,X);Bfs(d2,h2,Y);Pre(Y,0);\n\tfor(int i=1;i<=MD;++i) for(int j=1;j<=n;++j) fa[i][j]=fa[i-1][fa[i-1][j]];\n\tdfs(X,0,Y);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans*2);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb(n) push_back(n)\n#define maxn 200010\n#define inf 1000000000\n\nusing namespace std;\n\nbool czy [maxn], special [maxn];\nint bdistance [maxn], ojciec[maxn], ile[maxn];\nvector<int> red[maxn], blue[maxn];\n\nint Find (int x)\n{\n\tif (ojciec[x]!=x)\n\t\tojciec[x]=Find(ojciec[x]);\n\treturn ojciec[x];\n}\n\nvoid join (int a, int b)\n{\n\ta = Find(a);\n\tb = Find(b);\n\tif (ile[a] > ile[b])\n\t\tswap(a,b);\n\tif (a != b)\n\t{\n\t\tojciec[a]=b;\n\t\tile[b] += ile[a];\n\t}\n}\n\nvoid calculate_blue (int x)\n{\n\tczy[x]=true;\n\tint s = (int)blue[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif(!czy[blue[x][i]])\n\t\t{\n\t\t\tbdistance[blue[x][i]] = bdistance[x] + 1;\n\t\t\tcalculate_blue(blue[x][i]);\n\t\t}\n\t}\n\tczy[x]=false;\n}\n\nvoid calculate_special (int x, int y)\n{\n\tczy[x]=true;\n\tint s = (int)red[x].size();\n\tfor(int i=0; i<s; ++i)\n\t{\n\t\tif (czy[red[x][i]])\n\t\t{\n\t\t\tint odl = bdistance[x] + bdistance[red[x][i]] - 2 * bdistance[Find(red[x][i])];\n\t\t\tif (odl >= 3)\n\t\t\t\tspecial[x] = special[red[x][i]] = true;\n\t\t}\n\t}\n\ts = (int) blue[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif(!czy[blue[x][i]])\n\t\t\tcalculate_special (blue[x][i], x);\n\t}\n\tjoin (x, y);\n\tczy [x] = false;\n}\n\nint answer (int x, int y)\n{\n\tczy [x] = true;\n\tif (special[x] && bdistance [x] > y)\n\t\treturn inf;\n\tif (bdistance [x] <= y)\n\t\treturn y;\n\tint odp = bdistance [x];\n\tint s = (int)red[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif (!czy[red[x][i]])\n\t\t{\n\t\t\todp = max(answer (red[x][i], y + 1), odp);\n\t\t}\n\t}\n\treturn odp;\t\n}\n\n\nint main()\n{\n\tint n, x, y,a,b;\n\tcin >> n >> x >> y;\n\tfor(int i=1; i<n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tred[a].pb(b);\n\t\tred[b].pb(a);\n\t\tojciec[i]=i;\n\t\tile[i]=1;\n\t}\n\tojciec[n]=n;\n\tile[n]=1;\n\tfor(int i=1; i<n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tblue[a].pb(b);\n\t\tblue[b].pb(a);\n\t}\n\tcalculate_blue (y);\n\tcalculate_special (y, y);\n\tint ans = answer (x, 0);\n\tif (ans == inf)\n\t\tputs (\"-1\");\n\telse\n\t\tcout << 2 * ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Graph\n{\n    int N;\n    vector<vector<int>> red_neighbors, blue_neighbors;\n\n    Graph(const int N) : N(N), red_neighbors(N), blue_neighbors(N) {}\n\n    void add_red_edge(const int a, const int b)\n    {\n        red_neighbors[a].push_back(b);\n        red_neighbors[b].push_back(a);\n    }\n\n    void add_blue_edge(const int a, const int b)\n    {\n        blue_neighbors[a].push_back(b);\n        blue_neighbors[b].push_back(a);\n    }\n\n    int solve(const int X, const int Y) const\n    {\n        auto blue_distances = vector<int>(N);\n        auto blue_parents = vector<int>(N);\n        const function<void(int, int)> blue_dfs = [&](const int v, const int parent)\n        {\n            for (const auto w : blue_neighbors[v]) if (w != parent)\n            {\n                blue_distances[w] = blue_distances[v]+1;\n                blue_parents[w] = v;\n                blue_dfs(w, v);\n            }\n        };\n        blue_parents[Y] = Y;\n        blue_dfs(Y, -1);\n\n        auto red_distances = vector<int>(N, -1);\n        auto win = false;\n        const function<void(int, int)> red_dfs = [&](const int v, const int parent)\n        {\n            if (red_distances[v] >= blue_distances[v]) return;\n            for (const auto w : red_neighbors[v]) if (w != parent)\n            {\n                auto close = blue_parents[v] == w || blue_parents[w] == v;\n                close |= blue_parents[blue_parents[v]] == w;\n                close |= blue_parents[blue_parents[w]] == v;\n                close |= blue_parents[v] == blue_parents[w];\n\n                if (!close) win = true;\n                else\n                {\n                    red_distances[w] = red_distances[v]+1;\n                    red_dfs(w, v);\n                }\n            }\n        };\n        red_distances[X] = 0;\n        red_dfs(X, -1);\n\n        if (win) return -1;\n        else\n        {\n            auto result = 0;\n            for (auto v = 0; v < N; v++) if (red_distances[v] != -1)\n                result = max(result, 2*blue_distances[v]);\n            return result;\n        }\n    }\n};\n\nint main()\n{\n    int N, X, Y; cin >> N >> X >> Y;\n    X--; Y--;\n\n    auto graph = Graph(N);\n\n    for (auto i = 0; i < N-1; i++)\n    {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        graph.add_red_edge(a, b);\n    }\n\n    for (auto i = 0; i < N-1; i++)\n    {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        graph.add_blue_edge(a, b);\n    }\n\n    cout << graph.solve(X, Y) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn(2e5 + 5);\n\nint n, x, y, lim[maxn], fa[maxn], ans, dis[maxn];\nqueue <int> q;\nvector <int> edge1[maxn], edge2[maxn];\n\n# define Orzyyb puts(\"-1\"), exit(0)\n\ninline void Add1(int u, int v) {\n\tedge1[u].push_back(v), edge1[v].push_back(u);\n}\n\ninline void Add2(int u, int v) {\n\tedge2[u].push_back(v), edge2[v].push_back(u);\n}\n\ninline int Dis(int x, int y) {\n\tif (fa[x] == y || fa[y] == x) return 1;\n\tif (fa[x] == fa[y] || fa[fa[x]] == y || fa[fa[y]] == x) return 2;\n\treturn 233;\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add1(u, v);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add2(u, v);\n\tlim[y] = 1, q.push(y);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tfor (auto to : edge2[u])\n\t\t\tif (!lim[to]) fa[to] = u, lim[to] = lim[u] + 1, q.push(to);\n\t}\n\tfor (i = 1; i <= n; ++i) --lim[i];\n\tdis[x] = 1, q.push(x);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tif (dis[u] - 1 > lim[u]) continue;\n\t\tans = max(ans, lim[u]);\n\t\tfor (auto to : edge1[u]) if (Dis(u, to) > 2) Orzyyb;\n\t\tfor (auto to : edge1[u])\n\t\t\tif (!dis[to]) dis[to] = dis[u] + 1, q.push(to);\n\t}\n\tprintf(\"%d\\n\", ans * 2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nusing namespace std;\nint n,x,y,f[200010][25],h[200010];\nvector<int> a[200010],b[200010];\nmap<L,bool> g;\ninline void dfs(int i)\n{\n\tint j;\n\tfor(j=1;j<=20;j++)\n\t  f[i][j]=f[f[i][j-1]][j-1];\n\tfor(j=0;j<b[i].size();j++)\n\t  if(b[i][j]!=f[i][0])\n\t    {\n\t\t f[b[i][j]][0]=i;\n\t\t dfs(b[i][j]);\n\t\t}\n}\ninline bool check(int x,int y)\n{\n\treturn x==y || f[x][0]==y || f[y][0]==x;\n}\ninline void lca(int x,int y,int &i,int &j)\n{\n\tint a=x,b=y,k;\n\tif(h[a]>h[b])\n\t  {\n\t   for(k=20;k>=0;k--)\n\t     if(h[a]-(1<<k)>=h[b])\n\t       a=f[a][k];\n\t   if(a==b)\n\t     {\n\t\t  i=f[x][0];\n\t\t  j=h[x]-h[y];\n\t\t  return;\n\t\t }\n\t  }\n\tif(h[a]<h[b])\n\t  {\n\t   for(k=20;k>=0;k--)\n\t     if(h[b]-(1<<k)>h[a])\n\t       b=f[b][k];\n\t   if(f[b][0]==a)\n\t     {\n\t\t  i=b;\n\t\t  j=h[y]-h[x];\n\t\t  return;\n\t\t }\n\t   b=f[b][0];\n\t  }\n\tfor(k=20;k>=0;k--)\n\t  if(f[a][k]!=f[b][k])\n\t    a=f[a][k],b=f[b][k];\n\ti=f[x][0];\n\tj=h[x]+h[y]-h[a]-h[b]+2;\n}\ninline int dfs(int x,int y)\n{\n\tif(g[(L)x*n+y])\n\t  return -1;\n\tg[(L)x*n+y]=1;\n\tif(check(x,y))\n\t  {\n\t   int i,j,k=2;\n\t   for(i=0;i<a[x].size();i++)\n\t     if(!check(a[x][i],y))\n\t       {\n\t\t\tj=dfs(a[x][i],y);\n\t\t\tif(j==-1)\n\t\t\t  return -1;\n\t\t\tk=max(k,j);\n\t\t   }\n\t   return k;\n\t  }\n\telse\n\t  {\n\t   int i,j,k;\n\t   lca(x,y,i,j);\n\t   k=dfs(x,i);\n\t   if(k==-1)\n\t     return -1;\n\t   return k+2*j;\n\t  }\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   a[j].pb(k);\n\t   a[k].pb(j);\n\t  }\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   b[j].pb(k);\n\t   b[k].pb(j);\n\t  }\n\tdfs(1);\n\tprintf(\"%d\\n\",dfs(x,y));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 200005, LOG = 20;\nconst int INF = 0x3f3f3f3f;\n\nvector<int> T1[NMAX], T2[NMAX];\nint father[NMAX], level[NMAX];\nint anc[LOG][NMAX];\n\nint dist[NMAX];\n\nvoid dfs(int node, int prev) {\n    father[node] = prev;\n    for (int to: T2[node]) {\n        if (to != prev) {\n            level[to] = level[node] + 1;\n            dfs(to, node);\n        }\n    }\n}\n\nint goUp(int x, int lvl) {\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (lvl & (1 << k)) {\n            x = anc[k][x];\n        }\n    }\n    return x;\n}\n\nint lca(int x, int y) {\n    if (level[y] > level[x]) {\n        y = goUp(y, level[y] - level[x]);\n    } else if (level[x] > level[y]) {\n        x = goUp(x, level[x] - level[y]);\n    }\n    if (x == y) {\n        return x;\n    }\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (anc[k][x] != anc[k][y]) {\n            x = anc[k][x];\n            y = anc[k][y];\n        }\n    }\n    return father[x];\n}\n\nint xdist(int x, int y) {\n    return level[x] + level[y] - 2 * level[lca(x, y)];\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, r1, r2;\n    cin >> n >> r1 >> r2;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T1[x].push_back(y);\n        T1[y].push_back(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T2[x].push_back(y);\n        T2[y].push_back(x);\n    }\n    dfs(r2, -1);\n    father[r2] = r2;\n\n    for (int i = 1; i <= n; ++i) {\n        anc[0][i] = father[i];\n    }\n    for (int k = 1; k < LOG; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            anc[k][i] = anc[k - 1][anc[k - 1][i]];\n        }\n    }\n\n    memset(dist, INF, sizeof dist);\n    queue<int> q;\n    dist[r1] = 0;\n    q.push(r1);\n    int ans = 0;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        ans = max(ans, 2 * level[node]);\n\n        for (int to: T1[node]) {\n            if (dist[to] > dist[node] + 1 && dist[node] + 1 < level[to]) {\n                dist[to] = dist[node] + 1;\n                q.push(to);\n                if (xdist(node, to) > 2) {\n                    cout << \"-1\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nconst int INF=0x3f3f3f3f;\nstruct edge{\n\tint t,next;\n}e[N*4];int ecnt,head[N*2];//1~n blue n+1~n+n red\nvoid addedge(int f,int t){\n\te[++ecnt]=(edge){t,head[f]};head[f]=ecnt;\n\te[++ecnt]=(edge){f,head[t]};head[t]=ecnt;\n}\nint fa[N],dis[N];\nvoid DFS(int u,int fr){\n\tfa[u]=fr;dis[u]=dis[fr]+1;\n\tfor(int i=head[u];i;i=e[i].next)\n\t\tif(e[i].t!=fr) DFS(e[i].t,u);\n} \nbool judge(int f,int t){//is the distance between f and t is smaller or equal to 2\n\tif(dis[f]==dis[t]) return fa[f]==fa[t];\n\tif(dis[f]>dis[t]) swap(f,t);\n\treturn fa[t]==f||fa[fa[t]]==f;\n}\nint n,x,y,ans;\nvoid DFS2(int u,int fr,int d){\n\tif(dis[u-n]<=d) return;\n\tans=max(ans,dis[u-n]);\n\tfor(int i=head[u];i;i=e[i].next)\n\t\tif(e[i].t!=fr){\n\t\t\tDFS2(e[i].t,u,d+1);\n\t\t\tif(judge(u-n,e[i].t-n)==false)\n\t\t\t\tans=INF;\n\t\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1,f,t;i<n;i++)\n\t\tscanf(\"%d%d\",&f,&t),addedge(f+n,t+n);\n\tfor(int i=1,f,t;i<n;i++)\n\t\tscanf(\"%d%d\",&f,&t),addedge(f,t);\n\tdis[0]=-1;DFS(y,0);\n\tDFS2(x+n,0,0);\n\tif(ans==INF) ans=-1;\n\telse ans*=2;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nP dp[200005];\nint lca[200005][18],dist2[200005];\nint calc(int x,int y){\n\tif(dist2[x] > dist2[y]) swap(x,y);\n\trep(i,18){\n\t\tif((((dist2[y]-dist2[x])>>i)&1)){\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\tfor(int i=17;i>=0;i--){\n\t\tif(lca[x][i] != lca[y][i]){\n\t\t\tx = lca[x][i];\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\treturn (x==y?x:lca[x][0]);\n}\nbool fe;\nint go(int a,int b){\n\tint c = calc(a,b);\n\tif(a == c){\n\t\tfor(int i=0;i<18;i++){\n\t\t\tif((((dist2[b]-dist2[a]-1)>>i)&1)){\n\t\t\t\tb = lca[b][i];\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\telse{\n\t\treturn lca[a][0];\n\t}\n}\nint ret = 0;\nvoid dfs(int v,int u,int d){\n\tif(dp[v].fi >= 0){\n\t\tret = max(ret,2*d+dp[v].fi*2);\n\t}\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint D = dist2[v]+dist2[edge[v][i]]-2*dist2[calc(v,edge[v][i])];\n\t\t//cout << v << \" \" << edge[v][i] << \" \" << \" \" << calc(v,edge[v][i]) << D << endl;\n\t\tif(D>=3 && lca[edge[v][i]][0] != dp[v].sc && lca[dp[v].sc][0] != edge[v][i] && edge[v][i] != dp[v].sc){\n\t\t\t\n\t\t\tfe = 1;\n\t\t}\n\t\telse {\n\t\t\tD = dist2[edge[v][i]]+dist2[dp[v].sc]-2*dist2[calc(edge[v][i],dp[v].sc)];\n\t\t\tif(D<=1){\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(0,edge[v][i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(D-1,go(dp[v].sc,edge[v][i])));\n\t\t\t//\tdfs(edge[v][i],v,d+1);\n\t\t\t}dfs(edge[v][i],v,d+1);\n\t\t}\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d; lca[v][0] = u;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs2(b,-1,0);\n\tdp[a] = mp(dist2[a],b);\n\tfor(int j=0;j<17;j++) for(int i=1;i<=n;i++){\n\t\tif(lca[i][j] == -1) lca[i][j+1] = -1;\n\t\telse lca[i][j+1] = lca[lca[i][j]][j];\n\t}\n\tdfs(a,-1,0);\n\tif(fe) puts(\"-1\");\n\telse cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N=200009;\n\nint n,a,b;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\ninline bool chkmax(int &a,int b){if(a<b){a=b;return 1;}return 0;}\ninline bool chkmin(int &a,int b){if(a>b){a=b;return 1;}return 0;}\n\nstruct tree\n{\n\tint to[N<<1],nxt[N<<1],beg[N],tot;\n\tint dep[N],fa[N];\n\tbool vis[N];\n\ttree()\n\t{\n\t\tmemset(to,0,sizeof(to));\n\t\tmemset(nxt,0,sizeof(nxt));\n\t\tmemset(beg,0,sizeof(beg));\n\t\tmemset(dep,0,sizeof(dep));\n\t\tmemset(vis,0,sizeof(vis));\n\t\ttot=0;\n\t}\n\tinline void add(int u,int v)\n\t{\n\t\tto[++tot]=v;\n\t\tnxt[tot]=beg[u];\n\t\tbeg[u]=tot;\n\t}\n\tinline void dfs(int u)\n\t{\n\t\tvis[u]=1;\n\t\tfor(int i=beg[u],v;i;i=nxt[i])\n\t\t\tif(!vis[(v=to[i])])\n\t\t\t{\n\t\t\t\tfa[v]=u;\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t}\n\tinline void init(int st)\n\t{\n\t\tdep[st]=0;\n\t\tdfs(st);\n\t}\n}sp,sn;\n\nconst int Inf=1e9;\n\nint f[N];\n\ninline bool check(int u,int v)\n{\n\tint d=0;\n\twhile(++d<=2 && u!=v)\n\t\tif(sp.dep[u]<sp.dep[v])\n\t\t\tv=sp.fa[v];\n\t\telse\n\t\t\tu=sp.fa[u];\n\treturn u!=v;\n}\n\ninline int dfs(int u)\n{\n\tif(!f[u])return 0;\n\n\tf[u]=sp.dep[u];\n\tfor(int i=sn.beg[u],v;i;i=sn.nxt[i])\n\t\tif(sn.dep[u]<sn.dep[v=sn.to[i]])\n\t\t{\n\t\t\tif(check(u,v)){puts(\"-1\");exit(0);}\n\t\t\tchkmax(f[u],dfs(v));\n\t\t}\n\treturn f[u];\n}\n\nint main()\n{\n\tn=read();\n\ta=read();\n\tb=read();\n\tif(a==b)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tu=read();\n\t\tv=read();\n\t\tsn.add(u,v);\n\t\tsn.add(v,u);\n\t}\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tu=read();\n\t\tv=read();\n\t\tsp.add(u,v);\n\t\tsp.add(v,u);\n\t}\n\tsn.init(a);\n\tsp.init(b);\n\n\tfor(int i=1;i<=n;i++)\n\t\tif(sp.dep[i]>sn.dep[i])\n\t\t\tf[i]=1;\n\tprintf(\"%d\\n\",dfs(a)<<1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,x,y,ans,dep[200100],fa[200100];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[800100],*tp=pool,*fst1[200100],*fst2[200100];\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nvoid dfs2(int x)\n{\n    dep[x]=dep[fa[x]]+1;\n    for (edge *i=fst2[x]; i; i=i->nxt)\n        if (i->v!=fa[x])\n            fa[i->v]=x,dfs2(i->v);\n}\n\nbool check(int u,int v)\n{\n    for (int i=1; i<=2 && u!=v; u=fa[u],++i)\n        if (dep[u]<dep[v])\n            swap(u,v);\n    return u!=v;\n}\n\nvoid dfs1(int x,int lst,int d)\n{\n    if (dep[x]<=d+1)\n        return;\n    ans=max(ans,(dep[x]-1)*2);\n    for (edge *i=fst1[x]; i; i=i->nxt)\n        if (i->v!=lst)\n        {\n            if (check(x,i->v))\n            {\n                puts(\"-1\");\n                exit(0);\n            }\n            dfs1(i->v,x,d+1);\n        }\n}\n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&x,&y);\n    repu(i,1,n-1)\n    {\n        int u=getint(),v=getint();\n        *tp=(edge){v,fst1[u]},fst1[u]=tp++;\n        *tp=(edge){u,fst1[v]},fst1[v]=tp++;\n    }\n    repu(i,1,n-1)\n    {\n        int u=getint(),v=getint();\n        *tp=(edge){v,fst2[u]},fst2[u]=tp++;\n        *tp=(edge){u,fst2[v]},fst2[v]=tp++;\n    }\n    dfs2(y),dfs1(x,0,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200010;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';x=(x<<1)+(x<<3)+ch-'0',ch=getchar());\n\treturn x*f;\n}\nstruct tree{\n\tint hea[maxn],nxt[maxn<<1],to[maxn<<1],tot;\n\tvoid add(int x,int y)\n\t{\n\t\tnxt[++tot]=hea[x];\n\t\thea[x]=tot;\n\t\tto[tot]=y;\n\t}\n}T[2];\nint dep[maxn][2],jump[maxn][20],maxx;\nvoid dfs(int now,int fa,int opt)\n{\n\tdep[now][opt]=dep[fa][opt]+1;\n\tif(opt==1)jump[now][0]=fa;\n\tfor(int i=T[opt].hea[now];i;i=T[opt].nxt[i])\n\t{\n\t\tint to=T[opt].to[i];\n\t\tif(to==fa)continue;\n\t\tdfs(to,now,opt);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x][1]<dep[y][1])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t\tif(dep[jump[x][i]][1]>=dep[y][1])\n\t\t\tx=jump[x][i];\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t\tif(jump[x][i]!=jump[y][i])\n\t\t\tx=jump[x][i],y=jump[y][i];\n\treturn jump[x][0];\n}\nvoid getans(int now,int fa)\n{\n\tif(dep[now][0]>=dep[now][1])return;\n\tif(fa)\n\t{\n\t\tint p=lca(now,fa);\n\t\tif(dep[now][1]+dep[fa][1]-2*dep[p][1]>2)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tmaxx=max(maxx,dep[now][1]-1);\n\tfor(int i=T[0].hea[now];i;i=T[0].nxt[i])\n\t{\n\t\tint y=T[0].to[i];\n\t\tif(y==fa)continue;\n\t\tgetans(y,now);\n\t}\n}\nint main()\n{\n\tint n=read(),x=read(),y=read(),s,t;\n\tfor(int ii=0;ii<2;ii++)\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\ts=read(),t=read();\n\t\t\tT[ii].add(s,t);\n\t\t\tT[ii].add(t,s);\n\t\t}\n\tdfs(x,0,0),dfs(y,0,1);\n\tfor(int i=1;i<20;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tjump[j][i]=jump[jump[j][i-1]][i-1];\n\tgetans(x,0);\n\tprintf(\"%d\\n\",2*maxx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\ntypedef long long llint;\n\nconst int MAX = 200100;\nconst int LG = 20;\n\nvector<int> E[MAX], F[MAX];\n\nint L[MAX][LG];\nint parent[MAX], d[MAX];\n\nint lca(int u, int v) {\n  if (d[u] < d[v]) swap(u, v);\n  for (int j = LG - 1; j >= 0; --j)\n    if (d[u] - (1 << j) >= d[v]) u = L[u][j];\n  if (u == v) return u;\n  for (int j = LG - 1; j >= 0; --j)\n    if (L[u][j] != L[v][j]) u = L[u][j], v = L[v][j];\n  return L[u][0];\n}\n\nint dist(int x, int y) { return d[x] + d[y] - 2 * d[lca(x, y)]; }\n\nvoid dfs(int x) {\n  for (int y : E[x]) {\n    if (y != parent[x]) {\n      parent[y] = x;\n      d[y] = d[x] + 1;\n      dfs(y);\n    }\n  }\n}\n\nint f[MAX];\n\nvoid dfs2(int x, int dad, int d, int y) {\n  int q = dist(x, y);\n  f[x] = d;\n  if (q <= d) return;\n\n  for (int nx : F[x]) {\n    if (nx != dad) {\n      dfs2(nx, x, d + 1, y);\n    }\n  }\n}\n\nint main(void) {\n  ios_base::sync_with_stdio(false);\n\n  int N, X, Y;\n  cin >> N >> X >> Y;\n  --X, --Y;\n\n  REP(i, N - 1) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    F[a].push_back(b);\n    F[b].push_back(a);\n  }\n\n  REP(i, N - 1) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n\n  parent[0] = 0;\n  dfs(0);\n\n  REP(i, N) L[i][0] = parent[i];\n  FOR(j, 1, LG) REP(i, N) L[i][j] = L[L[i][j - 1]][j - 1];\n\n  REP(i, N) f[i] = -1;\n  dfs2(X, -1, 0, Y);\n\n  int ret = 0;\n  REP(x, N) {\n    if (f[x] != -1) {\n      int q = dist(x, Y);\n      if (f[x] <= q) {\n        ret = max(ret, 2 * q);\n      }\n\n      if (f[x] < q) {\n        for (int y : F[x]) {\n          if (dist(x, y) > 2) {\n            cout << -1 << \"\\n\";\n            return 0;\n          }\n        }\n      }\n    }\n  }\n\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn(2e5 + 5);\n\nint n, x, y, lim[maxn], fa[maxn], ans, dis[maxn];\nqueue <int> q;\nvector <int> edge1[maxn], edge2[maxn];\n\n# define Orzyyb puts(\"-1\"), exit(0)\n\ninline void Add1(int u, int v) {\n\tedge1[u].push_back(v), edge1[v].push_back(u);\n}\n\ninline void Add2(int u, int v) {\n\tedge2[u].push_back(v), edge2[v].push_back(u);\n}\n\ninline int Dis(int x, int y) {\n\tif (fa[x] == y || fa[y] == x) return 1;\n\tif (fa[x] == fa[y] || fa[fa[x]] == y || fa[fa[y]] == x) return 2;\n\treturn 233;\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add1(u, v);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add2(u, v);\n\tlim[y] = 1, q.push(y);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tfor (auto to : edge2[u])\n\t\t\tif (!lim[to]) fa[to] = u, lim[to] = lim[u] + 1, q.push(to);\n\t}\n\tfor (i = 1; i <= n; ++i) --lim[i];\n\tdis[x] = 1, q.push(x);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tif (dis[u] - 1 > lim[u]) continue;\n\t\tans = max(ans, lim[u]);\n\t\tfor (auto to : edge1[u]) if (dis[to] && Dis(u, to) > 2) Orzyyb;\n\t\tfor (auto to : edge1[u])\n\t\t\tif (!dis[to]) dis[to] = dis[u] + 1, q.push(to);\n\t}\n\tprintf(\"%d\\n\", ans << 1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof((x).end())i=(x).begin();i!=(x).end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=200007,inf=1e9;\n\nstd::vector<int>p[N],p2[N];\nint n,X,Y,ans,fa[N][18],dep[N];\nbool tag[N];\n\ninline void dfs(int x)\n{\n\tfoe(i,p[x])if(*i!=fa[x][0])\n\t{\n\t\tdep[*i]=dep[x]+1;\n\t\tfa[*i][0]=x;\n\t\tdfs(*i);\n\t}\n}\n\ninline int lca(int x,int y)\n{\n\tif(dep[x]<dep[y])std::swap(x,y);\n\tif(dep[x]>dep[y])fo0(i,18)if(dep[x]-dep[y]>>i&1)x=fa[x][i];\n\tif(x==y)return x;\n\tfd0(i,18)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n\treturn fa[x][0];\n}\n\ninline int dis(int x,int y)\n{\n\tint z=lca(x,y);\n\treturn dep[x]+dep[y]-dep[z]*2;\n}\n\ninline void dfs2(int x,int l,int fa=0)\n{\n\tif(dis(x,Y)<=l)return;\n\tif(tag[x]){ans=inf;return;}\n\trepr(ans,dis(x,Y)*2);\n\tfoe(i,p2[x])if(*i!=fa)dfs2(*i,l+1,x);\n}\n\nint main()\n{\n\tin,n,X,Y;\n\tfo1(i,n-1)\n\t{\n\t\tint a,b;\n\t\tin,a,b;\n\t\tp2[a].pb(b);\n\t\tp2[b].pb(a);\n\t}\n\tfo1(i,n-1)\n\t{\n\t\tint a,b;\n\t\tin,a,b;\n\t\tp[a].pb(b);\n\t\tp[b].pb(a);\n\t}\n\tdfs(Y);\n\tfo0(i,17)fo1(j,n)fa[j][i+1]=fa[fa[j][i]][i];\n\tfo1(i,n)foe(j,p2[i])if(dis(i,*j)>=3)tag[i]=tag[*j]=1;\n\tdfs2(X,0);\n\tout,ans==inf?-1:ans,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,X,Y,x[100005],y[100005],f[100005][17],d[100005],wi[100005],D[100005],ans;\nvector<int> v[100005];\nvoid dfs(int x,int y){\n    f[x][0]=y,d[x]=d[y]+1;\n    for(int i=0;i<16;++i)f[x][i+1]=f[f[x][i]][i];\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint lca(int x,int y){\n    if(d[x]<d[y])swap(x,y);\n    for(int i=16;i>=0;--i)if(d[f[x][i]]>=d[y])x=f[x][i];\n    if(x==y) return x;\n    for(int i=16;i>=0;--i)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\nvoid dfs2(int x,int y){\n    D[x]=D[y]+1;\n    if(D[x]>d[x]) return;\n    if(wi[x])ans=orz;\n    else ans=max(ans,d[x]*2);\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs2(v[x][i],x);\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&X,&Y);\n    for(int i=1;i<n;++i)scanf(\"%d%d\",x+i,y+i);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    d[0]=-1;\n    dfs(Y,0);\n    for(int i=1;i<=n;++i)v[i].clear();\n    for(int i=1;i<n;++i){\n        int o=d[x[i]]+d[y[i]]-d[lca(x[i],y[i])]*2;\n        if(o>2)wi[x[i]]=wi[y[i]]=1;\n        else v[x[i]].pb(y[i]),v[y[i]].pb(x[i]);\n    }\n    D[0]=-1;\n    dfs2(X,0);\n    if(ans==orz)puts(\"-1\");\n    else printf(\"%d\\n\",ans);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(2e5) + 9;\n\nint n, x, y;\n\nstruct Tree{\n    vector<int> adj[N];\n    int d[N], p[N];\n    \n    void dfs(int u, int p = -1){\n        for (auto v: adj[u]){\n            if (v == p) continue;\n            d[v] = d[u] + 1; this->p[v] = u;\n            dfs(v, u);\n        }\n    }\n    void in(){\n        DO(n-1){\n            int x, y; RD(x, y); --x, --y;\n            adj[x].PB(y);\n            adj[y].PB(x);\n        }\n    }\n} R, B;\n\nint z;\n\nbool dfs(int u, int p = -1){\n    if (B.d[u] <= R.d[u]) return false;\n    for (auto v: R.adj[u]){\n        if (v == p) continue;\n        R.d[v] = R.d[u] + 1;\n        if (!(v == B.p[u] || B.p[v] == u || B.p[B.p[u]] == v || B.p[B.p[v]] == u || B.p[u] == B.p[v])) return true;\n        if (dfs(v, u)) return true;\n        checkMax(z, B.d[u]*2);\n    }\n    return false;\n}\n\nint gao(){\n    RD(n, x, y); R.in(); B.in(); B.dfs(y);\n    z = 0; if (dfs(x)) return -1;\n    return z;\n}\n\nint main(){\n    \n#ifndef ONLINE_JUDGE\n    freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users//desktop/Exercise/out.txt\", \"w\", stdout);\n#endif\n    \n    OT(gao());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nusing namespace std;\nint n,x,y,f[200010][25],h[200010],g[200010];\nvector<int> a[200010],b[200010];\ninline void dfs(int i)\n{\n\tint j;\n\tfor(j=1;j<=20;j++)\n\t  f[i][j]=f[f[i][j-1]][j-1];\n\tfor(j=0;j<b[i].size();j++)\n\t  if(b[i][j]!=f[i][0])\n\t    {\n\t\t f[b[i][j]][0]=i;\n\t\t h[b[i][j]]=h[i]+1;\n\t\t dfs(b[i][j]);\n\t\t}\n}\ninline bool check(int x,int y)\n{\n\treturn x==y || f[x][0]==y || f[y][0]==x;\n}\ninline int dis(int x,int y)\n{\n\tint a=x,b=y,k;\n\tif(h[a]<h[b])\n\t  swap(a,b);\n\tif(h[a]>h[b])\n\t  for(k=20;k>=0;k--)\n\t    if(h[a]-(1<<k)>=h[b])\n\t      a=f[a][k];\n\tif(a==b)\n\t  return abs(h[x]-h[y]);\n\tfor(k=20;k>=0;k--)\n\t  if(f[a][k]!=f[b][k])\n\t    a=f[a][k],b=f[b][k];\n\treturn h[x]+h[y]-h[a]-h[b]+2;\n}\ninline int walk(int y,int x)\n{\n\tint a=x,b=y,k;\n\tif(h[a]<h[b])\n\t  {\n\t   for(k=20;k>=0;k--)\n\t     if(h[b]-(1<<k)>h[a])\n\t       b=f[b][k];\n\t   if(f[b][0]==a)\n\t     return b;\n\t  }\n\treturn f[x][0];\n}\ninline int dfs(int x,int y)\n{\n\tif(g[x])\n\t  return 0;\n\tg[x]=1;\n\tint i,j,k=dis(x,y)*2;\n\tfor(i=0;i<a[x].size();i++)\n\t  {\n\t   if(dis(x,a[x][i])>=3)\n\t     return -1;\n\t   if(!check(a[x][i],y))\n\t     {\n\t      j=dfs(a[x][i],walk(a[x][i],y));\n\t\t  if(j==-1)\n\t\t    return -1;\n\t\t  k=max(k,j+2);\n\t\t }\n\t  }\n\treturn k;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   a[j].pb(k);\n\t   a[k].pb(j);\n\t  }\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   b[j].pb(k);\n\t   b[k].pb(j);\n\t  }\n\tdfs(1);\n\tprintf(\"%d\\n\",dfs(x,y));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define N 200001\n#define LL long long\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\t\n}\nusing namespace std;\nint n,X,Y;\nbool reach[N],ok;\nstruct tree\n{\n\tint dep[N],fa[N];\n\tint cnt,head[N],nxt[N+N],to[N+N];\n\tvoid add_edge(int u,int v)\n\t{\n\t\tnxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v;\n\t}\n\tvoid dfs(int u)\n\t{\n\t\tfor(int i=head[u],v;i;i=nxt[i])\n\t\t\tif((v=to[i]) != fa[u])\n\t\t\t{\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tfa[v]=u;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t}\n}a,b;\nbool check(int u,int v)\n{\n\tif(b.dep[u]<b.dep[v])swap(u,v);\n\tif(b.fa[u]==v)return 0;\n\tif(b.fa[b.fa[u]]==v)return 0;\n\tif(b.fa[u]==b.fa[v])return 0;\n\treturn 1;\n}\nvoid wfs(int u)\n{\n\treach[u]=1;\n\tfor(int i=a.head[u],v;i;i=a.nxt[i])\n\t\tif((v=a.to[i])!=a.fa[u])\n\t\t{\n\t\t\tif(check(u,v))ok=1;\n\t\t\tif(a.dep[v]<b.dep[v])wfs(v);\n\t\t}\n}\nint main()\n{\n\tre(n);re(X);re(Y);\n\tfor(int u,v,i=1;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\ta.add_edge(u,v);\n\t\ta.add_edge(v,u);\n\t}\n\tfor(int u,v,i=1;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tb.add_edge(u,v);\n\t\tb.add_edge(v,u);\n\t}\n\ta.dfs(X);b.dfs(Y);\n\twfs(X);\n\tif(ok)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(reach[i])\n\t\t\tans=max(ans,b.dep[i]);\n\tprintf(\"%d\\n\",2*ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define maxn 400001\nusing namespace std;\nint nt1[maxn], go1[maxn], fi1[maxn], ff[maxn][21];\nint nt2[maxn], go2[maxn], fi2[maxn], cnt;\nint dep[maxn], f[maxn], n, s, t, ans = -1;\nvector <int> Q[maxn];\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nvoid add1(int x, int y){\n    nt1[++cnt] = fi1[x]; fi1[x] = cnt; go1[cnt] = y;\n}\nvoid add2(int x, int y){\n    nt2[++cnt] = fi2[x]; fi2[x] = cnt; go2[cnt] = y;\n}\nvoid DFS2(int x, int fa){\n    dep[x] = dep[fa] + 1; f[x] = fa;\n    ff[x][0] = fa;\n    for(int i = 1; i <= 20; i++)\n        ff[x][i] = ff[ff[x][i - 1]][i - 1];\n    for(int i = fi2[x]; i; i = nt2[i]){\n        int v = go2[i]; if(v == fa) continue;\n        DFS2(v, x); Q[x].push_back(v);\n    }\n    sort(Q[x].begin(), Q[x].end());\n}\nint lca(int u, int v)\n{\n    if(dep[u] < dep[v]) swap(u, v);\n    for(int i = 20; i >= 0; i--)\n        if(dep[ff[u][i]] >= dep[v]) u = ff[u][i];\n    if(u == v) return u;\n    for(int i = 20; i >= 0; i--)\n    {\n        if(ff[u][i] != ff[v][i]) {\n            u = ff[u][i]; v = ff[v][i];\n        }\n    }\n    return ff[u][0];\n}\nint get_dis(int x, int y){\n    return dep[x] + dep[y] - dep[lca(x, y)] * 2;\n}\nvoid DFS1(int x, int fa, int h){\n    bool flag = true, t = false;\n    int siz = Q[h].size();\n    for(int i = fi1[x]; i; i = nt1[i]){\n        int v = go1[i]; if(v == fa) continue;\n        if(get_dis(x, v) >= 3) { flag = false; break;}\n        int now = lower_bound(Q[h].begin(), Q[h].end(), x) - Q[h].begin();\n        if(now < siz && Q[h][now] == v) continue;\n        if(v == f[h] || v == h) continue; \n        t = true; DFS1(v, x, f[v]); \n    }\n    if(!flag) return;\n    if(!t) ans = max(ans, dep[h]); \n}\n\nint main(){\n    n = read(); s = read(); t = read();\n    for(int i = 1; i < n; i++){\n        int x = read(), y = read();\n        add1(x, y); add1(y, x);\n    }\n    for(int i = 1; i < n; i++){\n        int x = read(), y = read();\n        add2(x, y); add2(y, x);\n    }\n    DFS2(t, 0); int u = f[s]; DFS1(s, 0, u);\n    if(ans != -1) ans <<= 1; \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++\nPROG: e.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__) #define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst signed inf=0x3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// print a signed integer\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint n,x,y;\nvector<int> R[200005],B[200005];\nint loop[200005],dfn[200005],low[200005],t,dis[200005],fa[200005],Dis[200005],Fa[200005];\nvoid BlueDFS(int x,int f){\n\tfa[x]=f;\n\tdfn[x]=++t;\t\n\tdis[x]=dis[f]+1;\n\tfor(auto i:B[x])if(i!=f)BlueDFS(i,x);\n\tlow[x]=++t;\n}\nint chk(int x,int y){\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tif(dfn[x]<=dfn[y] && low[y]<=low[x])return dis[x]-dis[y]>2;\n\treturn fa[x]!=fa[y];\t\n}\nint q[200005],*l,*r;\nint RedBFS(int x){\n\t*(l=r=q)=x;\t\n\tint ans=dis[x]<<1;\n\tif(loop[x])return -1;\n\twhile(l<=r){\n\t\tfor(auto i:R[*l])if(i!=Fa[*l]){\n\t\t\tFa[i]=*l;\n\t\t\tDis[i]=Dis[*l]+1;\n\t\t\tif(Dis[i]>dis[*l])continue;\n\t\t\telse chkmax(ans,dis[i]<<1);\n\t\t\tif(Dis[i]<dis[*l]){\n\t\t\t\t*(++r)=i;\n\t\t\t\tif(loop[i])return -1;\n\t\t\t}\n\t\t}\n\t\t++l;\n\t}\n\treturn ans;\n}\nint main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"e.in\",\"r\",stdin);\n\tfreopen(\"e.out\",\"w\",stdout);\n#endif\n\tread(n,x,y);\t\n\tif(x==y){write(\"0\\n\");return 0;}\n\tint u,v;\n\tfor(int i=1;i<n;++i){read(u,v);R[u].push_back(v);R[v].push_back(u);}\n\tfor(int i=1;i<n;++i){read(u,v);B[u].push_back(v);B[v].push_back(u);}\n\tdis[0]=-1;\n\tBlueDFS(y,0);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(auto j:R[i]){\n\t\t\tif(chk(i,j)){loop[i]=1;break;}\n\t\t}\n\t}\n\twrite(RedBFS(x),'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int lg = 20;\nvector<int> red[N];\nvector<int> blue[N];\nint h[N];\nint par[lg + 5][N];\nint n, x, y;\nbool winPos[N];\nint disR[N];\nint disB[N];\n\n\nvoid dfs(int v = 0, int p = -1)\n{\n    for (int u : blue[v])\n    {\n        if (u != p)\n        {\n            par[0][u] = v;\n            h[u] = h[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nvoid pre()\n{\n    for (int k = 1; k < lg; k++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            par[k][i] = par[k - 1][ par[k - 1][i] ];\n        }\n    }\n}\n\nint lca(int v, int u)\n{\n    if(h[v] > h[u])\n    {\n        swap(v, u);\n    }\n    for (int i = 0; i < lg; i++)\n    {\n        if (h[u] - h[v] >> i & 1)\n        {\n            u = par[i][u];\n        }\n    }\n    for (int i = lg - 1; i >= 0; i--)\n    {\n        if(par[i][v] != par[i][u])\n        {\n            v = par[i][v], u = par[i][u];\n        }\n    }\n    return v == u ? v : par[0][v];\n}\n\nvoid dfs1(int v, int par = -1)\n{\n    if (disR[v] >= disB[v])\n    {\n        return;\n    }\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disR[u] = disR[v] + 1;\n            dfs1(u, v);\n        }\n    }\n}\n\nvoid dfs2(int v, int par = -1)\n{\n    for (auto u: blue[v])\n    {\n        if (u != par)\n        {\n            disB[u] = disB[v] + 1;\n            dfs2(u, v);\n        }\n    }\n}\n\n\n\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        red[u - 1].push_back(v - 1);\n        red[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        blue[u - 1].push_back(v - 1);\n        blue[v - 1].push_back(u - 1);\n    }\n    dfs();\n    pre();\n    for (int i = 0; i < n; i++)\n    {\n        for (auto u: red[i])\n        {\n            int tmp = lca(u, i);\n            if (h[u] - h[tmp] + h[i] - h[tmp] > 2)\n            {\n                winPos[i] = true;\n                winPos[u] = true;\n            }\n        }\n    }\n    memset(disR, 127, sizeof disR);\n    disR[x - 1] = 0;\n    dfs2(y - 1);\n    dfs1(x - 1);\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (winPos[i] && disR[i] < disB[i])\n        {\n            cout << -1 << endl;\n            exit(0);\n        }\n        if (disR[i] < N)\n        {\n            //cout << endl;\n            //cout << i << \" \" << disB[i] << endl;\n            ans = max(ans, disB[i] * 2);\n        }\n    }\n    //cout << (1 << 20) << endl;\n    cout << ans << endl;\n\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 21\nvector<int> ex[N], ey[N];\nvoid init(int n, vector<int>* e) {\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n}\nint fx[N], fy[N][M], dx[N], dy[N];\nvoid dfsy(int u) {\n    for (auto v : ey[u]) {\n        if (v == fy[u][0]) continue;\n        fy[v][0] = u, dy[v] = dy[u] + 1;\n        for (int i = 1; i < M; i++) fy[v][i] = fy[fy[v][i - 1]][i - 1];\n        dfsy(v);\n    }\n}\nint lca(int u, int v) {\n    if (dy[u] < dy[v]) swap(u, v);\n    for (int i = M - 1; ~i; i--)\n        if (dy[fy[u][i]] >= dy[v]) u = fy[u][i];\n    if (u == v) return u;\n    for (int i = M - 1; ~i; i--)\n        if (fy[u][i] != fy[v][i]) u = fy[u][i], v = fy[v][i];\n    return fy[u][0];\n}\nint ans;\nvoid dfsx(int u) {\n    if (~ans) ans = max(ans, dy[u] << 1);\n    for (auto v : ex[u]) {\n        if (v == fx[u] || dx[v] >= dy[v]) continue;\n        if (dy[v] + dy[u] - 2 * dy[lca(u, v)] > 2) ans = -1;\n        fx[v] = u, dx[v] = dx[u] + 1;\n        dfsx(v);\n    }\n}\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    init(n, ex);\n    init(n, ey);\n    dfsy(addy);\n    dfsx(addx);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 20\nstruct {\n    vector<int> e[N];\n    int fa[N][M], d[N];\n    void dfs(int u) {\n        for (auto v : e[u]) {\n            if (v == fa[u][0]) continue;\n            fa[v][0] = u, d[v] = d[u] + 1;\n            for (int i = 1; i < M; i++) fa[v][i] = fa[fa[v][i - 1]][i - 1];\n            dfs(v);\n        }\n    }\n    void init(int n) {\n        for (int i = 1, u, v; i < n; i++) {\n            scanf(\"%d%d\", &u, &v);\n            e[u].push_back(v);\n            e[v].push_back(u);\n        }\n    }\n    int lca(int u, int v) {\n        if (d[u] < d[v]) swap(u, v);\n        for (int i = M - 1; ~i; i--)\n            if (d[fa[u][i]] >= d[v]) u = fa[u][i];\n        if (u == v) return u;\n        for (int i = M - 1; ~i; i--)\n            if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];\n        return fa[u][0];\n    }\n} ex, ey;\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    ex.init(n);\n    ey.init(n);\n    ex.dfs(addx);\n    ey.dfs(addy);\n    queue<int> que;\n    que.push(addx);\n    int ans = 0;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        if (ex.d[u] >= ey.d[u]) continue;\n        int f = ex.fa[u][0], tmp = ey.lca(u, f);\n        if (ey.d[u] + ey.d[f] - 2 * ey.d[tmp] > 2) {\n            puts(\"-1\");\n            return 0;\n        }\n        ans = max(ans, ey.d[u] << 1);\n        for (auto v : ex.e[u])\n            if (v != f) que.push(v);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define fr(N,i,x) for (int i=N.lnk[x];i;i=N.nxt[i])\nusing namespace std;\nconst int maxn=200005,maxe=maxn<<1;\nint n,X,Y,dst[maxn],fa[maxn],Dst[maxn],Q[maxn],ans;bool vis[maxn];\nstruct ljb{\n\tint e,lnk[maxn],nxt[maxe],son[maxe];\n\tinline void add_e(int x,int y){son[++e]=y;nxt[e]=lnk[x];lnk[x]=e;}\n}A,B;\ninline char nc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read(){\n\tint ret=0;bool f=0;char ch=nc();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=nc();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=nc();\n\treturn f?-ret:ret;\n}\nvoid DFS(int x){fr(B,i,x) if(B.son[i]^fa[x]) dst[B.son[i]]=dst[x]+1,fa[B.son[i]]=x,DFS(B.son[i]);}\ninline void BFS(){\n\tint hed=0,til=1;Q[vis[X]=1]=X;\n\twhile(hed<til) if(Dst[Q[++hed]]<dst[Q[hed]]) fr(A,i,Q[hed])\n\tif(!vis[A.son[i]]) vis[A.son[i]]=1,Dst[A.son[i]]=Dst[Q[hed]]+1;\n}\ninline bool check(int x,int y){\n\tif(dst[x]>dst[y]){int t=x;x=y;y=t;}\n\tif(dst[y]-dst[x]==2) return fa[fa[y]]==x;\n\tif(dst[y]-dst[x]==1) return fa[y]==x;\n\tif(dst[y]-dst[x]==0) return fa[x]==fa[y];\n\treturn 0;\n}\nint main(){\n\tn=read(),X=read(),Y=read();\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),A.add_e(x,y),A.add_e(y,x);\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),B.add_e(x,y),B.add_e(y,x);\n\tdst[Y]=0;DFS(Y);BFS();\n\tfor (int i=1;i<=n;i++) if(vis[i]){\n\t\tif(Dst[i]<=dst[i]&&dst[i]>ans) ans=dst[i];\n\t\tif(Dst[i]<dst[i]) fr(A,j,i) if(!check(A.son[j],i)) ans=1e9;\n\t}\n\tprintf(\"%d\\n\",ans==1e9?-1:ans<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\nusing namespace std;\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1],e2[MAXN<<1];\n\nint n,x1,x2;\nint g[MAXN],nume;\nint g2[MAXN],nume2;\nint dep[MAXN],size[MAXN],son[MAXN],top[MAXN],pre[MAXN],w[MAXN],pt[MAXN],numw;\nint pre2[MAXN],h[MAXN],dep2[MAXN];\nbool flag;\nint ans;\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid addEdge2(int u,int v){\n\te2[nume2]=edge(v,g2[u]);\n\tg2[u]=nume2++;\n}\n\nvoid dfs(int x,int p){\n\tsize[x]=1; son[x]=0;\n\tpre[x]=p;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdep[e[i].to]=dep[x]+1;\n\t\t\tdfs(e[i].to,x);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t\tif(size[e[i].to]>size[son[x]])\n\t\t\t\tson[x]=e[i].to;\n\t\t}\n}\n\nvoid dfs2(int x,int p){\n\tpt[w[x]=++numw]=x;\n\tif(son[x]){\n\t\ttop[son[x]]=top[x];\n\t\tdfs2(son[x],x);\n\t}\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to!=p && e[i].to!=son[x]){\n\t\t\ttop[e[i].to]=e[i].to;\n\t\t\tdfs2(e[i].to,x);\n\t\t}\n}\n\nint getLCA(int x,int y){\n\twhile(top[x]^top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tx=pre[top[x]];\n\t}\n\treturn dep[x]<dep[y]?x:y;\n}\n\nint getDis(int x,int y){\n\treturn dep[x]+dep[y]-2*dep[getLCA(x,y)];\n}\n\nint goUp(int x,int d){\n\twhile(dep[x]-dep[top[x]]+1<d){\n\t\td-=dep[x]-dep[top[x]]+1;\n\t\tx=pre[top[x]];\n\t}\n\treturn pt[w[x]-d];\n}\n\nint step(int x,int y){\n\tint lca=getLCA(x,y);\n\tif(lca!=x) return pre[x];\n\treturn goUp(y,dep[y]-dep[x]-1);\n}\n\nvoid dfs3(int x,int p){\n\tpre2[x]=p;\n\tfor(int i=g2[x];~i;i=e2[i].next)\n\t\tif(e2[i].to^p){\n\t\t\tint y=e2[i].to;\n\t\t\tint dis=getDis(x,y);\n\t\t\tif(y==h[x] || x==h[x]) continue;\n\t\t\tif(dis>=3 && x!=h[x]) flag=1;\n\t\t\th[y]=step(h[x],y);\n\t\t\tdep2[y]=dep2[x]+1;\n\t\t\tdfs3(y,x);\n\t\t}\n\tint res=getDis(h[x],x)*2+dep2[x]*2;\n\tans=max(ans,res);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tmemset(g2,-1,sizeof g2);\n\tscanf(\"%d%d%d\",&n,&x1,&x2);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t\taddEdge2(v,u);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\ttop[1]=1;\n\tdfs2(1,0);\n\th[x1]=x2;\n\tdfs3(x1,0);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n\tvector<vector<int> > g;\n\tconst int MAX_LOG = 22;\n\tvector<vector<int> > lcc;\n\tvector<int> dep;\n\tvector<int> myr;\nprivate:\n\tvoid init2(){\n\t\tint n = g.size();\n\t\tfor (int i = 0; i + 1 < MAX_LOG; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (lcc[i][j] == -1){\n\t\t\t\t\tlcc[i + 1][j] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlcc[i + 1][j] = lcc[i][lcc[i][j]];\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tint lca(int a, int b){\n\t\tif (dep[a] < dep[b]){\n\t\t\tswap(a, b);\n\t\t}\n\t\tfor (int i = 0; i < MAX_LOG; i++){\n\t\t\tif (((dep[a] - dep[b]) >> i) & 1){\n\t\t\t\ta = lcc[i][a];\n\t\t\t}\n\t\t}\n\t\tif (a == b){\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = MAX_LOG - 1; i >= 0; i--){\n\t\t\tif (lcc[i][a] != lcc[i][b]){\n\t\t\t\ta = lcc[i][a];\n\t\t\t\tb = lcc[i][b];\n\t\t\t}\n\t\t}\n\t\treturn lcc[0][a];\n\t}\nprivate:\n\tint flag_r;\n\tinline void dfs(int b, int pr = -1, int d = 0){\n\t\tfor (auto &i : g[b]){\n\t\t\tif (i == pr)continue;\n\t\t\tdfs(i, b, d + 1);\n\t\t}\n\t\tdep[b] = d;\n\t\tlcc[0][b] = pr;\n\t\tmyr[b] = flag_r;\n\t}\npublic:\n\n\tvoid init(vector<vector<int> > &tree, int root = 0){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tflag_r = root;\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tdfs(root);\n\t\tinit2();\n\t}\n\tvoid init(vector<vector<int> > &tree, vector<int> &root){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tfor (int &i : root){\n\t\t\tif (myr[i] == -1){\n\t\t\t\tflag_r = i;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t}\n\tint dist(int a, int b){ \n\t\tif (myr[a] != myr[b]){\n\t\t\treturn -1;\n\t\t}\n\t\tint lc = lca(a, b);\n\t\treturn dep[a] + dep[b] - 2 * dep[lc];\n\t}\n\tint go(int a, int b){\n\t\tfor (int i = 0; i < MAX_LOG; i++){\n\t\t\tif ((b >> i) & 1){\n\t\t\t\ta = lcc[i][a];\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n};\n\n#define MAX 200002\n\nint n;\n\nint x;\nint y;\n\nvector<vector<int> > sigma;\nvector<vector<int> > sugim;\n\nLCA sigmaL;\nLCA sugimL;\n\nbool win[MAX];\n\nvector<vector<int> > vv;\nqueue<int> q;\nvector<int> ord;\nbool vis[MAX];\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t}\n};\nUF uf;\n\nint main(){\n\tcin >> n;\n\tuf.resize(n);\n\tcin >> x >> y;\n\tsigma.resize(n,vector<int>());\n\tsugim = sigma; \n\tvv = sigma;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsigma[a].push_back(b);\n\t\tsigma[b].push_back(a);\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsugim[a].push_back(b);\n\t\tsugim[b].push_back(a);\n\t}\n\tx--;\n\ty--;\n\tsugimL.init(sugim,y);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int &j : sigma[i]){\n\t\t\tif (i > j)continue;\n\t\t\tint d = sugimL.dist(i, j);\n\t\t\tif (d > 2){\n\t\t\t\twin[i] = true;\n\t\t\t\twin[j] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tuf.merge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tsigmaL.init(sigma, y);\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i]){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (uf.root(a)!=uf.root(b)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim;\n\t\t\tif (uf.root(lc) == uf.root(a)){\n\t\t\t\ttim = sigmaL.dist(a, lc);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttim = sigmaL.dist(a, sigmaL.go(b, sigmaL.dist(b, lc) - 1));\n\t\t\t}\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tif (tim < tim2){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i] == false){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (uf.root(a)!= uf.root(b) ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tint cost = sigmaL.dist(a, b);\n\t\t\tif (tim > tim2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim == tim2){\n\t\t\t\tif (b == lc){\n\t\t\t\t\tans = max(ans, cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tans = max(ans, cost + tim2 - tim);\n\t\t\t}\n\t\t}\n\t}\n\tcout << 2*ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int NN = 2e5 + 5;\nstruct E {\n\tint v, nxt;\n\tE(int _v=0, int _nxt=0) : v(_v), nxt(_nxt) {}\n};\nstruct Graph {\n\tint head[NN], totE;\n\tE edge[NN*2];\n\tvoid AddEdge(int u, int v) {\n\t\tedge[++totE] = E(v, head[u]);\n\t\thead[u] = totE;\n\t}\n} a, b;\nint N, X, Y, da[NN], db[NN], fab[NN];\nbool save[NN];\nvoid Dfs1(int u, int fr) {\n\tfab[u] = fr;\n\tdb[u] = db[fr] + 1;\n\tfor (int p = b.head[u]; p; p = b.edge[p].nxt) {\n\t\tint v = b.edge[p].v; //注意两棵树别用串了 \n\t\tif (v != fr)\n\t\t\tDfs1(v, u);\n\t}\n}\nbool inf, edgetag[NN];\nvoid Dfs2(int u, int fr) {\n\tda[u] = da[fr] + 1;\n\tif (da[u] >= db[u]) ;\n\telse save[u] = 1;\n\tif (fr != 0) {\n\t\tint x = u, y = fr;\n\t\tif (db[x] < db[y]) swap(x, y);\n\t\tif (fab[x] == fab[y] || fab[x] == y || fab[fab[x]] == y) ;\n\t\telse {\n\t\t\tinf = 1;\n\t\t\tedgetag[u] = 1;\n\t\t}\n\t}\n\tfor (int p = a.head[u]; p; p = a.edge[p].nxt) {\n\t\tint v = a.edge[p].v;\n\t\tif (v != fr) {\n\t\t\tDfs2(v, u);\n\t\t\tif (edgetag[v] && (save[u] || save[v]))\n\t\t\t\tinf = 1;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ta.AddEdge(u, v);\n\t\ta.AddEdge(v, u);\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb.AddEdge(u, v);\n\t\tb.AddEdge(v, u);\n\t}\n\tDfs1(Y, 0);\n\tDfs2(X, 0);\n\tif (inf) printf(\"-1\\n\");\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tif (save[i])\n\t\t\t\tans = max(ans, db[i]-1);\n\t\tans *= 2;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\n\nvector<int> g1[202020];\nvector<int> g2[202020];\nint p2[202020][20];\nint d2[202020];\n\nint up2(int x, int k){\n\tfor (int i=19;i>=0;i--){\n\t\tif (k&(1<<i)){\n\t\t\tx=p2[x][i];\n\t\t}\n\t}\n\treturn x;\n}\n\nvoid dfs02(int x, int p){\n\tp2[x][0]=p;\n\tfor (int i=1;i<20;i++){\n\t\tp2[x][i]=p2[p2[x][i-1]][i-1];\n\t}\n\tfor (int nx:g2[x]){\n\t\tif (nx!=p) {\n\t\t\td2[nx]=d2[x]+1;\n\t\t\tdfs02(nx, x);\n\t\t}\n\t}\n}\n\nint lca2(int a, int b){\n\tif (d2[a]<d2[b]) swap(a, b);\n\ta=up2(a, d2[a]-d2[b]);\n\tif (a==b) return a;\n\tfor (int i=19;i>=0;i--){\n\t\tif (p2[a][i]!=p2[b][i]){\n\t\t\ta=p2[a][i];\n\t\t\tb=p2[b][i];\n\t\t}\n\t}\n\treturn p2[a][0];\n}\n\nint dist2(int a, int b){\n\tif (a==0||b==0) return 1e6;\n\treturn d2[a]+d2[b]-2*d2[lca2(a, b)];\n}\n\nint v=2;\n\nvoid dfs(int x, int p, int y, int t){\n\tv=max(v, t-1+2*dist2(y, x));\n\tfor (int nx:g1[x]){\n\t\tif (nx!=p){\n\t\t\tif (dist2(nx, y)==0) continue;\n\t\t\tif (dist2(nx, y)==1){\n\t\t\t\tv=max(v, t+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (dist2(x, nx)>2){\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t\tint dd=dist2(y, nx);\n\t\t\t\tint ny;\n\t\t\t\tif (up2(nx, dd)==y) ny=up2(nx, dd-1);\n\t\t\t\telse ny=up2(y, 1);\n\t\t\t\tdfs(nx, x, ny, t+2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,x,y;\n\tcin>>n>>x>>y;\n\tfor (int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg1[a].push_back(b);\n\t\tg1[b].push_back(a);\n\t}\n\tfor (int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg2[a].push_back(b);\n\t\tg2[b].push_back(a);\n\t}\n\tdfs02(x, 0);\n\tdfs(x, 0, y, 1);\n\tcout<<v<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2e5 + 10;\n\nint ans, n, rr, rb, dr[maxn], db[maxn], q[maxn], par[maxn], fnt, rar;\nbool f[maxn];\nstd::vector<int> gr[maxn], gb[maxn];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &rr, &rb);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tgr[u].push_back(v);\n\t\tgr[v].push_back(u);\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tgb[u].push_back(v);\n\t\tgb[v].push_back(u);\n\t}\n\tmemset(db, -1, sizeof db);\n\tfnt = rar = 0;\n\tdb[q[rar++] = rb] = 0;\n\twhile(fnt != rar) {\n\t\tint u = q[fnt++];\n\t\tfor (int &v: gb[u]) {\n\t\t\tif(!~db[v]) {\n\t\t\t\tpar[v]= u;\n\t\t\t\tdb[q[rar++] = v] = db[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int u = 1; u <= n; ++u) {\n\t\tfor (int i = 0; i < (int) gr[u].size(); ++i) {\n\t\t\tint v = gr[u][i];\n\t\t\tif(v == par[u] || u == par[v] || v == par[par[u]] || u == par[par[v]] || par[u] == par[v]) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[u] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dr, -1, sizeof dr);\n\tfnt = rar = 0;\n\tdr[q[rar++] = rr] = 0;\n\twhile(fnt != rar) {\n\t\tint u = q[fnt++];\n\t\tfor (int &v: gr[u]) {\n\t\t\tif(!~dr[v] && dr[u] + 1 < db[v]) {\n\t\t\t\tdr[q[rar++] = v] = dr[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int u = 1; u <= n; ++u) {\n\t\tif(~dr[u]) {\n\t\t\tif(dr[u] < db[u] && f[u]) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans = std::max(ans, db[u]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans << 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n // ordinary rooted tree with level ancestry and LCA. look elsewhere\nstruct Tree {\n\texplicit Tree(int N=1) : N(N), logN(logceil(N)), _root(0), E(N) {}\n\tvoid addEdge(int u,int v){E[u].push_back(v);E[v].push_back(u);}\n\tint la(int u, int depth){/*calcLA();*/return _la(u,depth);}\n\tinline int lca(int u, int v){/*calcLA();*/return _lca(u,v);}\n\tint parent(int u) { return P[u]; }\n\tvoid setRoot(int r) { _root = r; }\n\tint root() { return _root; }\n\tconst vector<int>& neighbors(int u) const { return E[u]; }\n    int depth(int u) { return D[u]; }\n\tbool isAncestor(int top, int bottom) { return lca(top, bottom) == top; }\n\tbool sameBranch(int top, int bottom) { int l = lca(top, bottom); return l == top || l == bottom; }\n\n\tint _la(int u, int d)const{for(int i=0;i<logN&&u!=-1;++i){if(d&(1<<i))u=PP[i][u];}return u;}\n\tint _lca(int u, int v) { if(D[u]<D[v]){swap(u,v);} u=_la(u,D[u]-D[v]);\n\t\tfor(int i=logN-1;i>=0;--i)if(PP[i][u]!=PP[i][v]){u=PP[i][u];v=PP[i][v];}\n\t\treturn u==v?u:PP[0][v];\n\t}\n\tinline void calcParents(){if(P.size()==0){P.resize(N);D.resize(N);dfs(_root,-1,0);}}\n\tvoid dfs(int u,int v,int d){P[u]=v;D[u]=d;for(int w:E[u])if(v!=w)dfs(w,u,d+1);}\n\tinline void calcLA(){calcParents();if(PP.size()==0){PP=vector2<int>(logN,N,-1);for(int i=0;i<N;++i){PP[0][i]=P[i];}\n\t\t\tfor(int i=1;i<logN;++i)for(int j=0;j<N;++j)if(PP[i-1][j]!=-1)PP[i][j]=PP[i-1][PP[i-1][j]];}}\n\tint N,logN,_root; vector<vector<int>> E;vector<int> P,D;vector2<int>PP;\n};\n\ntemplate <typename EdgeType>\nclass DFSOrder {\npublic:\n    DFSOrder(const vector<vector<EdgeType>> &_E) : T(0), N(_E.size()), E(_E), RevEnter(N), Enter(N), Exit(N) {\n        dfs(0, -1);\n    }\n\n    vector<vector<EdgeType>> linearize() {\n        vector<vector<EdgeType>> F(N);\n        for (int i = 0; i < N; ++i) {\n            for (auto v:E[i]) {\n                F[conv(i)].push_back(conv(v));\n            }\n        }\n        return F;\n    }\n\n    void dfs(int u, int p) {\n        RevEnter[T] = u;\n        Enter[u] = T++;\n        for (auto v:E[u]) if (t(v) != p) dfs(t(v), u);\n        Exit[u] = T;\n    }\n\n    inline int t(const int&e) const { return e; }\n    template <typename U> inline int t(const pair<int, U>&e) const { return e.x; }\n\n    inline int conv(const int&e) const { return Enter[e]; }\n    template <typename U> inline pair<int, U> conv(const pair<int, U>&e) const { return {Enter[e.x], e.y}; }\n\n    const vector<int> &revEnter() const { return RevEnter; }\n    const vector<int> &enter() const { return Enter; }\n    const vector<int> &exit() const { return Exit; }\n\n    int T, N;\n    const vector<vector<EdgeType>> &E;\n    vector<int> Enter, Exit, RevEnter;\n};\n\n/** Centroid decomposition.\n *\n * Input: graph as adjacency list (either int or pair<int,T>)\n * Output: array U of intergers of size |V|\n *\n * Here, U[v] is the bfs order in the centroid tree. For DFS, only process\n * vertices with higher U[w] when processing centroid v, for instance:\n *\n * void dfs(int u, int p, int ctr, ...) {\n *      ....\n *      for (int v:E[u]) {\n *          if (v != p && U[u] > U[ctr]) {\n *              dfs(v, u, ctr, ...);\n *          }\n *      }\n * }\n */\ntemplate <typename EdgeType>\nclass CentroidDecomposition {\npublic:\n    CentroidDecomposition(const vector<vector<EdgeType>> &E) : E(E) {}\n\n    const vector<int>& findCentroids() {\n        N = E.size(); U.assign(N, -1);\n        int L = 0;\n\n        for (int j = 0; j < N; ) {\n            for (int i = N-1; i >= 0; --i) {\n                if (U[i] >= 0) continue;\n\n                U[i] = -1;\n                bool root = true;\n                for (auto v:E[i]) {\n                    if (U[t(v)]<0) {\n                        if (t(v) > i) U[i] += U[t(v)];\n                        else root = false;\n                    }\n                }\n\n                if (root) {\n                    int n = -U[i], u = i, p = -1;\n                    while (true) {\n                        int s = n + U[u];\n                        for (auto v:E[u]) if (t(v)!=p && U[t(v)] < 0) s = max(s, -U[t(v)]);\n                        if (2 * s <= n) { U[u] = j++; break; }\n                        else { for (auto v:E[u]) if (t(v)!=p && -U[t(v)] > n / 2) { p = u;u = t(v);break; } }\n                    }\n                }\n            }\n        }\n        return U;\n    }\n\n    inline int t(const int&e) const { return e; }\n    template <typename U> inline int t(const pair<int, U>&e) const { return e.x; }\n\n    int N;\n    const vector<vector<EdgeType>> &E;\n    vector<int> U;\n};\n\n\n// ordinary bipartite graph, with max. matching, max. indep. set and min. vertex cover. look elsewhere\nstruct Bipartite {\n\texplicit Bipartite(ui A, ui B) : A(A), B(B), N(A+B), ms(-1), H(N,-1), used(A) {}\n\tvoid addEdge(int u,int v){G.push_back(v);P.push_back(H[u]);H[u]=(ui)G.size()-1;}\n\tui matchingSize(){calcMatching();return ms;}\n\tint matched(int v){calcMatching();return M[v];}\n\tvector<int>cover(){calcCover();vector<int>C;for(int i=0;i<N;++i){if(Z[i]!=(i<A))C.push_back(i);}return C;}\n\tvector<int>indep(){calcCover();vector<int>I;for(int i=0;i<N;++i){if(Z[i]==(i<A))I.push_back(i);}return I;}\n//private:\n\tvoid konigDfs(int u){\n        if(Z[u]){return;}\n        Z[u]=true;\n        if(u<A){\n            for (ui p = H[u]; p != -1; p = P[p]) {\n                ui v = G[p];\n                if (v != M[u])konigDfs(v);\n            }\n        }\n        else if(M[u]!=-1)\n            konigDfs(M[u]);\n    }\n    bool matchingDfs(int u) {\n        if (used[u]) return false;\n        used[u] = true;\n\n        for (ui p = H[u]; p != -1; p = P[p]) {\n            ui v = G[p];\n            if (M[v]==-1) { M[u] = v; M[v] = u; ++ms; return true; }\n        }\n\n        for (ui p = H[u]; p != -1; p = P[p]) {\n            ui v = G[p];\n            if (matchingDfs(M[v])) { M[u] = v; M[v] = u; return true; }\n        }\n        return false;\n\n    }\n\tinline void calcMatching(){\n        if(ms!=-1){return;}\n        M = vector<ui>(N,-1);\n        size_t cur; ms = 0;\n        do {\n            cur = ms;\n            for(int i=0;i<A;++i) used[i] = false;\n            for(int i=0;i<A;++i) if(M[i]==-1) matchingDfs(i);\n        } while(cur != ms);\n    }\n\tinline void calcCover(){if(Z.size()==N){return;}calcMatching();Z=vector<bool>(N,false);for(int i=0;i<A;++i)if(M[i]==-1)konigDfs(i);}\n\tui N,A,B,ms;vector<ui>M,H,G,P;vector<bool>Z,used;\n};\n\nstruct DirectedGraph {\n\texplicit DirectedGraph(int N) : N(N), E(N) {}\n\tvoid addEdge(int u,int v){E[u].push_back({v});}\n\tint stronglyConnectedComponent(int v){calcStronglyConnectedComponents();return SCC[v];}\n\tbool stronglyConnected(int u,int v){calcStronglyConnectedComponents();return SCC[u]==SCC[v];}\n\tconst vector<int>& stronglyConnectedPermutation() {calcStronglyConnectedComponents(); return O;}\n//private:\n\tinline void calcReverseEdges(){if(ER.size()==N){return;}ER.resize(N);for(int i=0;i<N;++i)for(int u:E[i])ER[u].push_back(i);}\n\tinline void calcStronglyConnectedComponents(){\n\t\tif(SCC.size()==N){return;}SCC.resize(N);O.resize(N);calcReverseEdges();\n\t\tvector<bool>V(N,false);vector<int>F(N,0);int t=0;for(int i=N-1;i>=0;i--){if(!V[i]){dfsReverse(i,V,F,t);}O[N-1-F[i]] = i;}\n\t\tfill(V.begin(),V.end(),false);for(int i=0;i<N;i++){if(!V[O[i]])dfsForward(O[i],O[i],V);}\n\t}\n\tvoid dfsForward(int i,int p,vector<bool>&V){V[i]=true;SCC[i]=p;for(int v:E[i])if(!V[v])dfsForward(v,p,V);}\n\tvoid dfsReverse(int i,vector<bool>&V,vector<int>&F,int&t){V[i]=true;for(int v:ER[i]){if(!V[v])dfsReverse(v,V,F,t);}F[i] = t++;}\n\tint N; vector<vector<int>>E,ER;vector<int>SCC,O;\n};\n\nstruct TwoSat {\n\texplicit TwoSat(int N=0) : N(N), G(2*N) {}\n\tvoid forbid(int u,bool w){G.addEdge(u+N*(1-w),u+N*w);}\n\tvoid addClause(int u,bool w,int v,bool x){G.addEdge(u+N*w,v+N*(1-x));G.addEdge(v+N*x,u+N*(1-w));}\n\tbool satisfiable() {calculateAssignment();return ok;}\n\tconst vector<int>& assignment() {calculateAssignment();return A;}\n//private:\n\tinline void calculateAssignment(){if(A.size()==N){return;}A.resize(N);ok=true;map<int,bool>Q;\n\t\tfor(int u:G.stronglyConnectedPermutation()){\n\t\t\tint c1=G.stronglyConnectedComponent(u),c2=G.stronglyConnectedComponent((u+N)%(2*N));\n\t\t\tif(c1==c2){ok=false;return;}if(Q.find(c1)==Q.end()){Q[c1]=true;Q[c2]=false;}}\n\t\tfor(int i=0;i<N;++i){A[i]=Q[G.stronglyConnectedComponent(i)];}\n\t}\n\tint N; DirectedGraph G;vector<int>A;bool ok;\n};\n\nclass ESugigmaTheShowdown {\npublic:\n\n    void solve(istream& cin, ostream& cout) {\n        int N, X, Y; cin >> N >> X >> Y;\n        --X; --Y;\n\n        vector<vector<int>> E(N);\n        for (int i = 0; i < N - 1; ++i) {\n            int u, v;\n            cin >> u >> v;\n            --u;\n            --v;\n            E[u].push_back(v);\n            E[v].push_back(u);\n        }\n\n\n        Tree T(N);\n        for (int i = 0; i < N-1; ++i) {\n            int u, v; cin >> u >> v; --u; --v;\n            T.addEdge(u, v);\n        }\n        T.setRoot(Y);\n        T.calcLA();\n\n        vector<bool> Safe(N, false);\n        for (int i = 0; i < N; ++i) {\n            for (int j : E[i]) {\n                int d = T.depth(i) + T.depth(j) - 2 * T.depth(T.lca(i, j));\n                if (d >= 3) Safe[i] = true;\n            }\n        }\n\n        vector<int> Q{X}, D(N, -1);\n        D[X] = 0;\n        int ans = T.depth(X);\n        for (int q = 0; q < Q.size(); ++q) {\n            int i = Q[q], d = D[i];\n            for (int j : E[i]) {\n                if (D[j] == -1 && d + 1 < T.depth(j)) {\n                    if (Safe[j]) {\n                        cout << \"-1\\n\";\n                        return;\n                    } else {\n                        D[j] = d + 1;\n                        ans = max(ans, T.depth(j));\n                        Q.push_back(j);\n                    }\n                }\n            }\n        }\n\n        cout << 2*ans << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tESugigmaTheShowdown solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 200500;\n\nvector<int> E[N];\nvector<int> F[N];\n\nconst int LGN = 18;\nint up[LGN][N];\nint D[N];\n\nvoid DFS(int x, int p = -1) {\n    D[x] = (p == -1) ? 0 : D[p] + 1;\n    up[0][x] = (p == -1) ? x : p;\n    for (int d = 1; d < LGN; d++)\n        up[d][x] = up[d - 1][up[d - 1][x]];\n    for (int y : E[x]) {\n        if (y != p)\n            DFS(y, x);\n    }\n}\n\ninline int lca(int a, int b) {\n    if (D[a] > D[b]) {\n        swap(a, b);\n    }\n    for (int d = LGN - 1; d >= 0; d--)\n        if (D[up[d][b]] >= D[a])\n            b = up[d][b];\n    if (a == b)\n        return a;\n    for (int d = LGN - 1; d >= 0; d--)\n        if (up[d][a] != up[d][b])\n            a = up[d][a], b = up[d][b];\n    return up[0][a];\n}\n\ninline int dist(int a, int b) {\n    int l = lca(a, b);\n    return D[a] + D[b] - 2 * D[l];\n}\n\nbool infinite(int x) {\n    for (int y : F[x]) {\n        if (dist(x, y) >= 3)\n            return true;\n    }\n    return false;\n}\n\nbool isinfinite = false;\nint best = 0;\n\nint s, t;\n\n\nvoid DFS2(int x, int p = -1, int d = 0) {\n    best = max(best, dist(t, x));\n    if (infinite(x)) {\n        isinfinite = true;\n        return;\n    }\n    for (int y : F[x]) {\n        if (y == p)\n            continue;\n        if (d + 1 < dist(t, y)) {\n            DFS2(y, x);\n            if (isinfinite)\n                return;\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d %d %d\", &n, &s, &t);\n    --s, --t;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        --a, --b;\n        F[a].push_back(b);\n        F[b].push_back(a);\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        --a, --b;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    DFS(0);\n    DFS2(s);\n    if (isinfinite) {\n        printf(\"%d\\n\", -1);\n    } else {\n        printf(\"%d\\n\", 2 * best);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define pr pair<ll,ll>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    #define bin(x) (1ll<<(x))\n    #define GG(x) if(x) {puts(\"error\");exit(666);}\n    #define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n    #define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=1e9+7;\n    int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n    ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e<0)while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    vc<int> to[2][N];int dep[N],fs[N][30];\n    void pre1(int x,int fa)\n    {\n        dep[x]=dep[fa]+1;fs[x][0]=fa;fo(i,1,20) fs[x][i]=fs[fs[x][i-1]][i-1];\n        for(auto y:to[1][x]) if(y!=fa) pre1(y,x);\n    }\n    int getlca(int x,int y)\n    {\n        if(dep[x]<dep[y]) swap(x,y);\n        fd(t,20,0) if(bin(t)<=dep[x]-dep[y]) x=fs[x][t];if(x==y) return x;\n        fd(t,20,0) if(fs[x][t]!=fs[y][t]) x=fs[x][t],y=fs[y][t];return fs[x][0];\n    }\n    int getdis(int x,int y){return dep[x]+dep[y]-2*dep[getlca(x,y)];}\n    int ans=0;\n    void solve(int x,int fa,int dis)\n    {\n        if(dis>=dep[x]) return;chmax(ans,dep[x]*2);\n        for(auto y:to[0][x]) if(y!=fa)\n        {\n            if(getdis(x,y)>2) {puts(\"-1\");exit(0);}\n            solve(y,x,dis+1);\n        }\n    }\n\tvoid main()\n\t{\n        int n=qread(),X=qread(),Y=qread();\n        fo(i,1,n-1){int x=qread(),y=qread();to[0][x].PB(y);to[0][y].PB(x);}\n        fo(i,1,n-1){int x=qread(),y=qread();to[1][x].PB(y);to[1][y].PB(x);}\n        dep[0]=-1;pre1(Y,0);solve(X,0,0);write(ans);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <stack>\n#include <tuple>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nvector<int> compute_dist(int root, vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> dist(n, -1);\n    stack<int> stk;\n    dist[root] = 0;\n    stk.push(root);\n    while (not stk.empty()) {\n        int i = stk.top(); stk.pop();\n        for (int j : g[i]) if (dist[j] == -1) {\n            dist[j] = dist[i] + 1;\n            stk.push(j);\n        }\n    }\n    return dist;\n}\nvector<int> compute_parent(int root, vector<vector<int> > const & g) {\n    int n = g.size();\n    vector<int> parent(n, -1);\n    stack<int> stk;\n    stk.push(root);\n    while (not stk.empty()) {\n        int i = stk.top(); stk.pop();\n        for (int j : g[i]) if (parent[j] == -1 and j != root) {\n            parent[j] = i;\n            stk.push(j);\n        }\n    }\n    return parent;\n}\n\nint main() {\n    // input\n    int n, x, y; scanf(\"%d%d%d\", &n, &x, &y); -- x; -- y;\n    vector<vector<int> > g(n);\n    repeat (i, n-1) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    vector<vector<int> > h(n);\n    repeat (i, n-1) {\n        int c, d; scanf(\"%d%d\", &c, &d); -- c; -- d;\n        h[c].push_back(d);\n        h[d].push_back(c);\n    }\n    // solve\n    vector<int> dist_h = compute_dist(y, h);\n    vector<int> parent_h = compute_parent(y, h);\n    vector<bool> escapable(n);\n    repeat (i, n) for (int j : g[i]) {\n        if (parent_h[i] != j\n                and parent_h[j] != i\n                and parent_h[i] != parent_h[j]\n                and (parent_h[i] == -1 or parent_h[parent_h[i]] != j)\n                and (parent_h[j] == -1 or parent_h[parent_h[j]] != i)) { // dist(i, j) >= 3\n            escapable[i] = true;\n            escapable[j] = true;\n        }\n    }\n    int result = 0;\n    vector<bool> used(n);\n    stack<pair<int, int> > que;\n    que.emplace(x, 0);\n    while (not que.empty()) {\n        int i, dist; tie(i, dist) = que.top(); que.pop();\n        setmax(result, dist_h[i] * 2);\n        if (escapable[i]) {\n            result = -1;\n            break;\n        }\n        for (int j : g[i]) if (not used[j]) {\n            used[j] = true;\n            if (dist_h[j] <= dist + 1) continue;\n            que.emplace(j, dist + 1);\n        }\n    }\n    // output\n    printf(\"%d\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 200005\n#define rep(i,j,k) for(i=j;i<=k;++i)\n#define down(i,j,k) for(i=j;i>=k;--i)\nstruct E{\n\tint to,nxt;\n}ed[2][N<<1];\nstruct node{\n\tint u,s;\n}t,nw;\nint x,y,n,i,j,k,top,u,v,s,ans;\nint head[2][N],dep[N],anc[N][20];\nbool vis[N];\nqueue<node> q;\nvoid read(int &p){\n\tp=0; char x=getchar();\n\twhile(x<'0' || x>'9') x=getchar();\n\twhile(x>='0'&&x<='9'){p=p*10+x-'0'; x=getchar();}\n}\nvoid add(int u,int v,int wh){\n\ttop++; ed[wh][top]=(E){v,head[wh][u]}; head[wh][u]=top;\n}\nvoid dfs(int x){\n\tint i,to;\n\trep(i,1,19) anc[x][i]=anc[anc[x][i-1]][i-1];\n\tfor(i=head[1][x];i;i=ed[1][i].nxt)\n\tif((to=ed[1][i].to)!=anc[x][0]){\n\t\tanc[to][0]=x; dep[to]=dep[x]+1;\n\t\tdfs(to);\n\t}\n}\nint dis(int u,int v){\n\tint i,tmp=dep[u]+dep[v];\n\tif(dep[u]<dep[v]) swap(u,v);\n\tdown(i,19,0)\n\tif(dep[anc[u][i]]>=dep[v]) u=anc[u][i];\n\tif(u==v) return tmp-(dep[u]<<1);\n\tdown(i,19,0)\n\tif(anc[u][i]!=anc[v][i]){\n\t\tu=anc[u][i]; v=anc[v][i];\n\t}\n\treturn tmp-(dep[anc[u][0]]<<1);\n}\nint main(){\n\tread(n); read(x); read(y);\n\trep(i,1,n-1){\n\t\tread(u); read(v);\n\t\tadd(u,v,0); add(v,u,0);\n\t}\n\ttop=0;\n\trep(i,1,n-1){\n\t\tread(u); read(v);\n\t\tadd(u,v,1); add(v,u,1);\n\t}\n\tdep[y]=1; dfs(y);\n\tt=(node){x,0}; q.push(t); vis[x]=true;\n\twhile(!q.empty()){\n\t\tt=q.front(); q.pop();\n\t\tu=t.u; s=t.s;\n\t\tfor(i=head[0][u];i;i=ed[0][i].nxt){\n\t\t\tv=ed[0][i].to;\n\t\t\tif(dis(u,v)>2) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif((!vis[v])&&(dep[v]-1>s+1)){\n\t\t\t\tvis[v]=true; nw=(node){v,s+1};\n\t\t\t\tq.push(nw);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n)\n\tif(vis[i]){\n\t\tans=max(ans,dep[i]-1);\n\t}\n\tprintf(\"%d\\n\",ans<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nint n;\nstruct tree1\n{\n\tvector<int> g[200111];\n\tint fa[200111][20],dep[200111];\n\tvoid addedge(int u,int v)\n\t{\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tvoid dfs(int x,int f=0)\n\t{\n\t\tfa[x][0]=f;\n\t\tfor(int i=0;i<(int)g[x].size();i++)\n\t\t\tif(g[x][i]!=f)\n\t\t\t{\n\t\t\t\tdep[g[x][i]]=dep[x]+1;\n\t\t\t\tdfs(g[x][i],x);\n\t\t\t}\n\t}\n\tvoid prework(int s)\n\t{\n\t\tdfs(s);\n\t\tfor(int i=1;i<20;i++)for(int j=1;j<=n;j++)fa[j][i]=fa[fa[j][i-1]][i-1];\n\t}\n\tint getlca(int x,int y)\n\t{\n\t\tif(dep[x]<dep[y])swap(x,y);\n\t\tfor(int i=0;i<20;i++)if((dep[x]-dep[y]>>i)&1)x=fa[x][i];\n\t\tif(x==y)return x;\n\t\tfor(int i=19;i>=0;i--)if(fa[x][i]!=fa[y][i])\n\t\t{\n\t\t\tx=fa[x][i];\n\t\t\ty=fa[y][i];\n\t\t}\n\t\treturn fa[x][0];\n\t}\n\tint dist(int x,int y)\n\t{\n\t\treturn dep[x]+dep[y]-dep[getlca(x,y)]*2;\n\t}\n}m1;\nint sx,sy,ex[200111],ey[200111],ans;\nbool kill[200111];\nvector<int> g[200111];\nint dep[200111];\nvoid dfs(int x,int f=0)\n{\n//\tprintf(\"dfs %d %d d2= %d\\n\",x,f,m1.dep[x]);\n\tif(dep[x]>=m1.dep[x])return;\n\tans=max(ans,m1.dep[x]*2);\n\tif(kill[x])\n\t{\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f)\n\t\t{\n\t\t\tdep[g[x][i]]=dep[x]+1;\n\t\t\tdfs(g[x][i],x);\n\t\t}\n}\nint main()\n{\n\tget3(n,sx,sy);\n\tfor(int i=1,u,v;i<n;i++)get2(ex[i],ey[i]);\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tget2(u,v);\n\t\tm1.addedge(u,v);\n\t}\n\tm1.prework(sy);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(m1.dist(ex[i],ey[i])>=3)kill[ex[i]]=kill[ey[i]]=1;\n\t\telse\n\t\t{\n\t\t\tg[ex[i]].pb(ey[i]);\n\t\t\tg[ey[i]].pb(ex[i]);\n\t\t}\n\t}\n\tdfs(sx);\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: zxy_hhhh\n    date: 2020/03/13\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<iostream>\n#define ll long long\ninline ll rd() {\n    ll _x=0;int _ch=getchar(),_f=1;\n    for(;!isdigit(_ch)&&(_ch!='-')&&(_ch!=EOF);_ch=getchar());\n    if (_ch=='-'){_f=0;_ch=getchar();}\n    for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0';\n    return _f?_x:-_x;\n}\nvoid write(ll _x){if (_x>=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); }\ninline void wrt(ll _x,char _p){if (_x<0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);}\n#define maxn 100005\nint dis[maxn],Fa[maxn];\nstd::vector<int> G1[maxn],G2[maxn];\nint n,A,B;\nvoid dfs(int u,int fa) {\n    Fa[u]=fa;\n    for(auto i:G2[u]) if (i!=fa) {\n        dis[i]=dis[u]+1;\n        dfs(i,u);\n    }\n}\nint ans;\nvoid DFS(int u,int fa,int D) {\n    if (dis[u]<=D) return ;\n    if (fa&&!(Fa[u]==fa||Fa[fa]==u||Fa[u]==Fa[fa]||Fa[Fa[u]]==fa||Fa[Fa[fa]]==u)) ans=1e9;\n    ans=std::max(ans,dis[u]*2);\n    for(auto i:G1[u]) if (i!=fa) {\n        DFS(i,u,D+1);\n    }\n}\nint main() {\n    n=rd();A=rd(),B=rd();\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G1[x].push_back(y);\n        G1[y].push_back(x);\n    }\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G2[x].push_back(y);\n        G2[y].push_back(x);\n    }\n    dfs(B,0);\n    DFS(A,0,0);\n    if (ans>1e8) wrt(-1,'\\n');\n    else wrt(ans,'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N * 2 , inf = 1e9 + 7;\nusing namespace std ;\n\nbool vis[N] ;\nint n, rt, S, e, ter[M], nxt[M], lnk[N], dep[N], fa[N], ans ;\nstruct edge {\n\tint x, y ;\n} ed[N] ;\n\nvoid add(int x, int y) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e ;\n}\n\nvoid dfs(int p, int las) {\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) {\n\t\tdep[ter[i]] = dep[p] + 1 ;\n\t\tfa[ter[i]] = p ;\n\t\tdfs(ter[i], p) ;\n\t}\n}\n\nvoid dfs2(int p, int las, int len) {\n\tif (ans == inf) return ;\n\tif (dep[p] < len) return ;\n\tif (dep[p] == len) {\n\t\tans = max(ans, len * 2) ;\n\t\treturn ;\n\t}\n\tif (vis[p]) {\n\t\tans = inf ;\n\t\treturn ;\n\t}\n\tbool flg = false ;\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) flg = true, dfs2(ter[i], p, len + 1) ;\n\tif (!flg) {\n\t\tans = max(ans, dep[p] * 2) ;\n\t\treturn ;\n\t}\n}\n\nbool chk(int x, int y) {\n\tif (dep[x] < dep[y]) swap(x, y) ;\n\tif (fa[x] == y) return false ;\n\tif (fa[fa[x]] == y) return false ;\n\tif (fa[x] == fa[y]) return false ;\n\treturn true ;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &S, &rt) ;\n\trep(i, 1, n - 1) scanf(\"%d%d\", &ed[i].x, &ed[i].y) ;\n\tint x, y ;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &x, &y) ;\n\t\tadd(x, y), add(y, x) ;\n\t}\n\tdfs(rt, 0) ;\n\trep(i, 1, n - 1) if (chk(ed[i].x, ed[i].y)) vis[ed[i].x] = vis[ed[i].y] = true ;\n\trep(i, 1, n) lnk[i] = 0 ;\n\trep(i, 1, e) nxt[i] = 0 ; e = 0 ;\n\trep(i, 1, n - 1) add(ed[i].x, ed[i].y), add(ed[i].y, ed[i].x) ;\n\tdfs2(S, 0, 0) ;\n\tif (ans == inf) {\n\t\tprintf(\"-1\\n\") ;\n\t} else printf(\"%d\\n\", ans) ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define file(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool chkmin(T &a,T b){return (a>b)?a=b,1:0;}\n\ninline int read() {\n int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\nint n;\nint X,Y;\nint p[200005][2];\nint fa[400005],dfn[400005],low[400005];\nint he[400005],ne[800005],to[800005],cost[800005],e;\nvoid add(int x,int y,int z){\n    to[++e]=y;\n\tne[e]=he[x];\n\the[x]=e;\n\tcost[e]=z;\n}\nint vis[400005];\nint tot;\nint dep[400005];\nvoid dfs(int x,int ff){\n     fa[x]=ff;\n\t dfn[x]=++tot;\n\t for(int i=he[x];i;i=ne[i]){\n\t   int v=to[i];\n\t   if(!cost[i])continue;\n\t   if(v==ff)continue;\n\t   dep[v]=dep[x]+1;\n\t   dfs(v,x);\n\t }\n\t low[x]=++tot;\n}\nbool check(int x,int y){\n    if(dfn[x]>dfn[y])swap(x,y);\n    if(dfn[x]<=dfn[y]&&low[x]>=low[y])return dep[y]-dep[x]>2;\n    if(fa[x]==fa[y])return 0;\n\telse return 1;\n}\nint ans[200005];\nint dis[200005];\nqueue<int>q;\nvoid bfs(){\n     vis[X]=1;\n\t q.push(X);\n\t while(!q.empty()){\n\t    int x=q.front();\n\t\tq.pop();\n\t\tfor(int i=he[x];i;i=ne[i]){\n\t\t\tint v=to[i];\n\t\t   if(!cost[i]&&!vis[v]){\n\t\t      dis[v]=dis[x]+1;\n\t\t\t  if(dis[v]<dep[v]){\n\t\t\t      q.push(v);\n\t\t\t\t  vis[v]=1;\n\t\t\t  }\n\t\t   }\n\t\t}\n\t }\n}\nint main () {\n#ifndef ONLINE_JUDGE\n//file(\"agc005e\");\n#endif\n    n=read();\n\tX=read();\n\tY=read();\n\tF(i,1,n-1){\n\t    p[i][0]=read();\n\t\tp[i][1]=read();\n\t}\n\tF(i,1,n-1){\n\t   int x=read(),y=read();\n\t   add(x,y,1);\n\t   add(y,x,1);\n\t}\n\tdfs(Y,0);\n    F(i,1,n-1){\n\t   int x=p[i][0],y=p[i][1];\n\t   if(check(x,y))ans[x]=ans[y]=1;\n\t   else add(x,y,0),add(y,x,0);\n\t}\n\tbfs();\n\tint Ans=0;\n\tF(i,1,n){\n\t   if(vis[i]&&ans[i]){\n\t       puts(\"-1\");\n\t\t   return 0;\n\t   }\n\t   else if(vis[i])chkmax(Ans,dep[i]*2);\n\t}\n\tprintf(\"%d\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#define N (400000+1000)\nusing namespace std;\n\nstruct edge{int to,next;}edge[N<<1];\nint Father[N],Depth[N],Dfn[N],Low[N];\nint n,x,y,S1,S2,cnt,ans,u[N],v[N];\nint head[N],num_edge;\n\nvoid add(int u,int v)\n{\n\tedge[++num_edge].to=v;\n\tedge[num_edge].next=head[u];\n\thead[u]=num_edge;\n}\n\nbool check(int x,int y)\n{\n\tif (Dfn[x]>Dfn[y]) swap(x,y);\n\tif (Low[x]>=Low[y])\n\t\treturn (Depth[y]-Depth[x])>2;\n\treturn Father[x]!=Father[y];\n}\n\nvoid Dfs1(int x)\n{\n\tDfn[x]=++cnt; Depth[x]=Depth[Father[x]]+1;\n\tfor (int i=head[x]; i; i=edge[i].next)\n\t\tif (edge[i].to!=Father[x])\n\t\t{\n\t\t\tFather[edge[i].to]=x;\n\t\t\tDfs1(edge[i].to);\n\t\t}\n\tLow[x]=++cnt;\n}\n\nvoid Dfs2(int x,int fa,int k)\n{\n\tans=max(ans,Depth[x]-1);\n\tif (Depth[x]<=k) return;\n\tfor (int i=head[x]; i; i=edge[i].next)\n\t\tif (edge[i].to!=fa)\n\t\t{\n\t\t\tif (check(x,edge[i].to)) puts(\"-1\"),exit(0);\n\t\t\tDfs2(edge[i].to,x,k+1);\n\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&S1,&S2);\n\tfor (int i=1; i<=n-1; ++i)\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\tfor (int i=1; i<=n-1; ++i)\n\t\tscanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tDfs1(S2); \n\tmemset(head,0,sizeof(head)); num_edge=0;\n\tfor (int i=1; i<=n-1; ++i) add(u[i],v[i]),add(v[i],u[i]);\n\tDfs2(S1,-1,1);\n\tprintf(\"%d\\n\",ans<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n\tvector<vector<int> > g;\n\tconst int MAX_LOG = 22;\n\tvector<vector<int> > lcc;\n\tvector<int> dep;\n\tvector<int> myr;\nprivate:\n\tvoid init2(){\n\t\tint n = g.size();\n\t\tfor (int i = 0; i + 1 < MAX_LOG; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (lcc[i][j] == -1){\n\t\t\t\t\tlcc[i + 1][j] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlcc[i + 1][j] = lcc[i][lcc[i][j]];\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tint lca(int a, int b){\n\t\tif (dep[a] < dep[b]){\n\t\t\tswap(a, b);\n\t\t}\n\t\tfor (int i = 0; i < MAX_LOG; i++){\n\t\t\tif (((dep[a] - dep[b]) >> i) & 1){\n\t\t\t\ta = lcc[i][a];\n\t\t\t}\n\t\t}\n\t\tif (a == b){\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = MAX_LOG - 1; i >= 0; i--){\n\t\t\tif (lcc[i][a] != lcc[i][b]){\n\t\t\t\ta = lcc[i][a];\n\t\t\t\tb = lcc[i][b];\n\t\t\t}\n\t\t}\n\t\treturn lcc[0][a];\n\t}\nprivate:\n\tint flag_r;\n\tinline void dfs(int b, int pr = -1, int d = 0){\n\t\tfor (auto &i : g[b]){\n\t\t\tif (i == pr)continue;\n\t\t\tdfs(i, b, d + 1);\n\t\t}\n\t\tdep[b] = d;\n\t\tlcc[0][b] = pr;\n\t\tmyr[b] = flag_r;\n\t}\npublic:\n\n\tvoid init(vector<vector<int> > &tree, int root = 0){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tflag_r = root;\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tdfs(root);\n\t\tinit2();\n\t}\n\tvoid init(vector<vector<int> > &tree, vector<int> &root){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tfor (int &i : root){\n\t\t\tif (myr[i] == -1){\n\t\t\t\tflag_r = i;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t}\n\tint dist(int a, int b){ \n\t\tif (myr[a] != myr[b]){\n\t\t\treturn -1;\n\t\t}\n\t\tint lc = lca(a, b);\n\t\treturn dep[a] + dep[b] - 2 * dep[lc];\n\t}\n};\n\n#define MAX 200002\n\nint n;\n\nint x;\nint y;\n\nvector<vector<int> > sigma;\nvector<vector<int> > sugim;\n\nLCA sigmaL;\nLCA sugimL;\nLCA sigmaLL;\n\nbool win[MAX];\n\nvector<vector<int> > vv;\nqueue<int> q;\nvector<int> ord;\nbool vis[MAX];\n\nint main(){\n\tcin >> n;\n\tcin >> x >> y;\n\tsigma.resize(n,vector<int>());\n\tsugim = sigma; \n\tvv = sigma;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsigma[a].push_back(b);\n\t\tsigma[b].push_back(a);\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsugim[a].push_back(b);\n\t\tsugim[b].push_back(a);\n\t}\n\tx--;\n\ty--;\n\tsugimL.init(sugim,y);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int &j : sigma[i]){\n\t\t\tif (i > j)continue;\n\t\t\tint d = sugimL.dist(i, j);\n\t\t\tif (d > 2){\n\t\t\t\twin[i] = true;\n\t\t\t\twin[j] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint ll = sugimL.lca(i, j);\n\t\t\t\tif (ll != i&&ll != j){\n\t\t\t\t\tvv[i].push_back(ll);\n\t\t\t\t\tvv[ll].push_back(i);\n\t\t\t\t\tvv[j].push_back(ll);\n\t\t\t\t\tvv[ll].push_back(j);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i].push_back(j);\n\t\t\t\t\tvv[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvis[y] = true;\n\tq.push(y);\n\twhile (!q.empty()){\n\t\tint b = q.front();\n\t\tq.pop();\n\t\tfor (int &i : sugim[b]){\n\t\t\tif (!vis[i]){\n\t\t\t\tvis[i] = true;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tord.push_back(b);\n\t}\n\tsigmaL.init(vv, ord);\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i]){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (sigmaL.myr[a] != sigmaL.myr[b]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tif (tim == -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tsigmaLL.init(sigma, y);\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i] == false){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (sigmaL.myr[a] != sigmaL.myr[b]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaLL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tint cost = sigmaLL.dist(a, b);\n\t\t\tif (tim > tim2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim == tim2){\n\t\t\t\tif (b == lc){\n\t\t\t\t\tans = max(ans, cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tans = max(ans, cost + tim2 - tim);\n\t\t\t}\n\t\t}\n\t}\n\tcout << 2*ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\n#define N 200100\n\nstruct Graph {\n\tstruct Edge {\n\t\tint v, nxt;\n\t} e[N << 1];\n\tint head[N], cnt;\n\t\n\tinline void addedge(int u, int v) {\n\t\te[++cnt] = (Edge){v, head[u]};\n\t\thead[u] = cnt;\n\t}\n\n\tint fa[N], dep[N];\n\t\n\tinline bool testdis(int u, int v) { // dis(u,v) >= 3 ?\n\t\tif (fa[u] == v || fa[v] == u || fa[fa[v]] == u || fa[fa[u]] == v || fa[u] == fa[v])\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid dfs(int x, int f) {\n\t\tfa[x] = f;\n\t\tdep[x] = dep[f] + 1;\n\t\tfor (int i = head[x]; i; i = e[i].nxt) if (e[i].v != f)\n\t\t\tdfs(e[i].v, x);\n\t}\n} R, B;\n\nint tar[N], safe[N];\nvoid dfs(int x, int f) {\n\tif (R.dep[x] >= B.dep[x])\n\t\treturn;\n\tsafe[x] = true;\n\tfor (int i = R.head[x]; i; i = R.e[i].nxt) if (R.e[i].v != f)\n\t\tdfs(R.e[i].v, x);\n}\n\nint main()\n{\n\t//freopen(\"test.in\", \"r\", stdin);\n\tint n, x, y;\n\tscanf(\"%d %d %d\", &n, &x, &y);\n\tfor (int i = 2, a, b; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tR.addedge(a, b);\n\t\tR.addedge(b, a);\n\t}\n\tfor (int i = 2, a, b; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tB.addedge(a, b);\n\t\tB.addedge(b, a);\n\t}\n\tR.dfs(x, 0);\n\tB.dfs(y, 0);\n\tdfs(x, 0);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = R.head[i]; j; j = R.e[j].nxt)\n\t\t\tif (B.testdis(i, R.e[j].v))\n\t\t\t\ttar[i] = tar[R.e[j].v] = true;\n\t\n\tfor (int i = 1; i <= n; i++)\n\t\tif (safe[i] && tar[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (safe[i])\n\t\t\tans = max(ans, max(R.dep[i], B.dep[i]) - 1);\n\tprintf(\"%d\\n\", ans * 2);\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn(2e5 + 5);\n\nint n, x, y, lim[maxn], fa[maxn], ans, dis[maxn];\nqueue <int> q;\nvector <int> edge1[maxn], edge2[maxn];\n\n# define Orzyyb puts(\"-1\"), exit(0)\n\ninline void Add1(int u, int v) {\n\tedge1[u].push_back(v), edge1[v].push_back(u);\n}\n\ninline void Add2(int u, int v) {\n\tedge2[u].push_back(v), edge2[v].push_back(u);\n}\n\ninline int Dis(int x, int y) {\n\tif (fa[x] == y || fa[y] == x) return 1;\n\tif (fa[x] == fa[y] || fa[fa[x]] == y || fa[fa[y]] == x) return 2;\n\treturn 233;\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add1(u, v);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add2(u, v);\n\tlim[y] = 1, q.push(y);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tfor (auto to : edge2[u])\n\t\t\tif (!lim[to]) fa[to] = u, lim[to] = lim[u] + 1, q.push(to);\n\t}\n\tfor (i = 1; i <= n; ++i) --lim[i];\n\tdis[x] = 1, q.push(x);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tif (dis[u] - 1 > lim[u]) continue;\n\t\tans = max(ans, u == y ? 1 : lim[u]);\n\t\tfor (auto to : edge1[u]) if (Dis(u, to) > 2) Orzyyb;\n\t\tfor (auto to : edge1[u])\n\t\t\tif (!dis[to]) dis[to] = dis[u] + 1, q.push(to);\n\t}\n\tprintf(\"%d\\n\", ans << 1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb(n) push_back(n)\n#define maxn 200010\n#define inf 1000000000\n\nusing namespace std;\n\nbool czy [maxn], special [maxn], czy1[maxn];\nint bdistance [maxn], ojciec[maxn], ile[maxn];\nvector<int> red[maxn], blue[maxn];\n\nint Find (int x)\n{\n\tif (ojciec[x]!=x)\n\t\tojciec[x]=Find(ojciec[x]);\n\treturn ojciec[x];\n}\n\nvoid join (int a, int b)\n{\n\ta = Find(a);\n\tb = Find(b);\n\tif (a != b)\n\t{\n\t\tojciec[a]=b;\n\t\tile[b] += ile[a];\n\t}\n}\n\nvoid calculate_blue (int x)\n{\n\tczy[x]=true;\n\tint s = (int)blue[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif(!czy[blue[x][i]])\n\t\t{\n\t\t\tbdistance[blue[x][i]] = bdistance[x] + 1;\n\t\t\tcalculate_blue(blue[x][i]);\n\t\t}\n\t}\n\tczy[x]=false;\n}\n\nvoid calculate_special (int x, int y)\n{\n\t//cout << \"S\" << x << endl;\n\tczy[x]=true;\n\tint s = (int)red[x].size();\n\tfor(int i=0; i<s; ++i)\n\t{\n\t\tif (czy[red[x][i]])\n\t\t{\n\t\t\tint odl = bdistance[x] + bdistance[red[x][i]] - 2 * bdistance[Find(red[x][i])];\n\t\t\t//cout << Find(red[x][i]) << endl;\n\t\t\t//cout << x << \" \" << red[x][i] << \" \" << odl << endl;\n\t\t\tif (odl >= 3)\n\t\t\t\tspecial[x] = special[red[x][i]] = true;\n\t\t}\n\t}\n\ts = (int) blue[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif(!czy[blue[x][i]])\n\t\t\tcalculate_special (blue[x][i], x);\n\t}\n\tjoin (x, y);\n}\n\nint answer (int x, int y)\n{\n\tczy1 [x] = true;\n\tif (special[x] && bdistance [x] > y)\n\t\treturn inf;\n\tif (bdistance [x] <= y)\n\t\treturn y;\n\tint odp = bdistance [x];\n\tint s = (int)red[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif (!czy1[red[x][i]])\n\t\t{\n\t\t\todp = max(answer (red[x][i], y + 1), odp);\n\t\t}\n\t}\n\treturn odp;\t\n}\n\n\nint main()\n{\n\tint n, x, y,a,b;\n\tcin >> n >> x >> y;\n\tfor(int i=1; i<n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tred[a].pb(b);\n\t\tred[b].pb(a);\n\t\tojciec[i]=i;\n\t\tile[i]=1;\n\t}\n\tojciec[n]=n;\n\tile[n]=1;\n\tfor(int i=1; i<n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tblue[a].pb(b);\n\t\tblue[b].pb(a);\n\t}\n\tcalculate_blue (y);\n\tcalculate_special (y, y);\n\tint ans = answer (x, 0);\n\tif (ans == inf)\n\t\tputs (\"-1\");\n\telse\n\t\tcout << 2 * ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n,S,T;\n\nvector<int> g1[200005],g2[200005];\n\nint dist1[200005],dist2[200005],par[200005];\n\nint getd2(int a,int b){\n  if(dist2[a]>dist2[b]) swap(a,b);\n  if(dist2[a]-dist2[b]>2) return 3;\n  int res=0;\n  while(dist2[b]>dist2[a]) b=par[b],++res;\n  while(res<=2 && a!=b){\n    res+=2;\n    a=par[a];b=par[b];\n  }\n  return res;\n}\n\nvoid dfs(int v,int p){\n  par[v]=p;\n  for(auto to:g2[v]){\n    if(to==p) continue;\n    dist2[to]=dist2[v]+1;\n    dfs(to,v);\n  }\n}\n\nvoid dfs2(int v,int p){\n  if(dist1[v]>dist2[v]){\n    dist1[v]=-1;\n    return;\n  }\n  if(dist1[v]==dist2[v]) return;\n  for(auto to:g1[v]){\n    if(to==p) continue;\n    dist1[to]=dist1[v]+1;\n    dfs2(to,v);\n  }\n}\n\nint main(){\n  cin>>n>>S>>T;\n  --S;--T;\n  REP(i,n-1){\n    int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n    g1[a].pb(b);\n    g1[b].pb(a);\n  }\n  REP(i,n-1){\n    int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n    g2[a].pb(b);\n    g2[b].pb(a);\n  }\n\n  dfs(T,-1);\n\n  memset(dist1,-1,sizeof(dist1));\n  dist1[S]=0;\n  dfs2(S,-1);\n\n  int res=0;\n  REP(i,n) if(~dist1[i] && dist1[i]<dist2[i]){\n    for(auto to:g1[i]){\n      int d=getd2(i,to);\n      if(d>2){\n        puts(\"-1\");\n        return 0;\n      }\n    }\n  }\n  REP(i,n) if(~dist1[i]) chmax(res,dist2[i]*2);\n  cout<<res<<endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=200000;\nint N,A,B;\nvector<int> Ga[MN],Gb[MN];\nbool vis[MN];\t//Ga\ntypedef pair<int,int> P;\n\n\nconst int MAX_V=MN;\nconst int LOGV=18;\nint par[MAX_V][LOGV],depth[MAX_V];\nvoid dfs(int v,int p){\n\tif(p<0) depth[v]=0;\n\telse depth[v]=depth[p]+1;\n\tpar[v][0]=p;\n\tfor(int u:Gb[v]){\n\t\tif(u!=p) dfs(u,v);\n\t}\n}\nvoid genlca(int N){\n\tdfs(0,-1);\n\tfor(int i=1;i<LOGV;i++){\n\t\trep(v,N){\n\t\t\tif(par[v][i-1]==-1) par[v][i]=-1;\n\t\t\telse par[v][i]=par[par[v][i-1]][i-1];\n\t\t}\n\t}\n}\nint lca(int u,int v){\n\tif(depth[u]<depth[v]){\n\t\tswap(u,v);\n\t}\n\tint d=depth[u]-depth[v];\n\trep(i,LOGV){\n\t\tif((d>>i)&1) u=par[u][i];\n\t}\n\tif(u==v) return u;\n\tfor(int i=LOGV-1;i>=0;i--){\n\t\tif(par[u][i]!=par[v][i]){\n\t\t\tu=par[u][i];\n\t\t\tv=par[v][i];\n\t\t}\n\t}\n\treturn par[v][0];\n}\n\n\nint distB(int x,int y){\n\tint w=lca(x,y);\n\treturn depth[x]+depth[y]-2*depth[w];\n}\nint up(int v,int d){\n\trep(i,LOGV) if((d>>i)&1) v=par[v][i];\n\treturn v;\n}\nint toclose(int x,int tar){\n\tassert(x!=tar);\n\tint w=lca(x,tar);\n\tif(w!=x) return par[x][0];\n\tint d=depth[tar]-depth[x];\n\treturn up(tar,d-1);\n}\n\nint solve(){\n\tcin>>N>>A>>B;\n\tA--,B--;\n\trep(i,N-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--,y--;\n\t\tGa[x].pb(y);\n\t\tGa[y].pb(x);\n\t}\n\trep(i,N-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--,y--;\n\t\tGb[x].pb(y);\n\t\tGb[y].pb(x);\n\t}\n\n\tgenlca(N);\n\n\tint d=-1;\n\tqueue<P> que;\n\tque.push(P(-1,-1));\n\tque.push(P(A,B));\n\tvis[A]=1;\n\tint ans=0;\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tif(p.sc==-1){\n\t\t\tif(que.empty()) break;\n\t\t\tque.push(P(d+1,-1));\n\t\t\td++;\n//\t\t\tshow(d);\n\t\t\tcontinue;\n\t\t}\n\t\tint a=p.fs,b=p.sc;\n//\t\tprintf(\"a=%d,b=%d\\n\",a,b);\n\t\tchmax(ans,(d+distB(a,b))*2);\n\t\tfor(int na:Ga[a]) if(!vis[na]){\n\t\t\tif(distB(a,na)>=3){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tvis[na]=1;\n\t\t\tif(b==na) continue;//?\n\t\t\tint nb=toclose(b,na);\n\t\t\tif(nb==na) continue;\n\t\t\tque.push(P(na,nb));\n\t\t}\n\t}\n\treturn max(ans,d*2);\n}\nint main(){\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int Maxn = 200010;\nint sta, stb;\nvector <int> veca[Maxn], vecb[Maxn];\nint n, e[Maxn][2];\nint disa[Maxn], disb[Maxn], size[Maxn], dfn[Maxn], id, fa[Maxn];\nvoid dfs(int x) {\n\tint sz = vecb[x].size();\n\tsize[x] = 1; dfn[x] = ++id;\n\tfor(int i = 0; i < sz; i++){\n\t\tint y = vecb[x][i];\n\t\tif(y == fa[x]) continue;\n\t\tfa[y] = x; disb[y] = disb[x]+1; dfs(y);\n\t\tsize[x] += size[y];\n\t}\n}\nbool v[Maxn], bo[Maxn];\nbool check(int x, int y) {\n\tif(disb[x] < disb[y]) swap(x, y);\n\tif(disb[x]-disb[y] > 2) return true;\n\tif(dfn[y] <= dfn[x] && dfn[x] < dfn[y]+size[y]) return false;\n\tif(fa[x] == fa[y]) return false;\n\treturn true;\n}\nvoid bfs() {\n\tqueue <int> q;\n\tq.push(sta); bo[sta] = true;\n\twhile(!q.empty()){\n\t\tint x = q.front(); q.pop();\n\t\tint sz = veca[x].size();\n\t\tfor(int i = 0; i < sz; i++){\n\t\t\tint y = veca[x][i];\n\t\t\tdisa[y] = disa[x]+1;\n\t\t\tif(disa[y] < disb[y] && !bo[y]) bo[y] = true, q.push(y);\n\t\t}\n\t}\n}\nint _max(int x, int y) { return x > y ? x : y; }\nint main() {\n\tint i, j, k;\n\tscanf(\"%d%d%d\", &n, &sta, &stb);\n\tfor(i = 1; i < n; i++) scanf(\"%d%d\", &e[i][0], &e[i][1]);\n\tfor(i = 1; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tvecb[x].push_back(y); vecb[y].push_back(x);\n\t}\n\tdfs(stb);\n\tfor(i = 1; i < n; i++){\n\t\tif(check(e[i][0], e[i][1])) v[e[i][0]] = v[e[i][1]] = true;\n\t\telse veca[e[i][0]].push_back(e[i][1]), veca[e[i][1]].push_back(e[i][0]);\n\t}\n\tbfs();\n\tint ans = 0;\n\tfor(i = 1; i <= n; i++){\n\t\tif(v[i] && bo[i]){ printf(\"-1\\n\"); return 0; }\n\t\tif(bo[i]) ans = _max(ans, disb[i]*2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(!bad[u])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(h[u1[i]]>h[u2[i]])swap(u1[i],u2[i]);\n\trep(i,1,n)if(ok[i] && (!bad[u1[i]])){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst int N = 2e5 + 10;\nstruct E {int v, nt;} e[N<<1];\nstruct data {int u, v;} a[N<<1];\nint n, ans, tot, h[N], q[N], fa[N], dep[N];\nint num, dfn[N], dis[N], low[N], win[N], vis[N];\n\ninline int max(int a, int b) {return a > b ? a : b;}\ninline int min(int a, int b) {return a < b ? a : b;}\ninline void swap(int &a, int &b) {int t = a; a = b, b = t;}\ninline void add(int u, int v) {\n\te[++tot] = (E){v, h[u]}, h[u] = tot;\n\te[++tot] = (E){u, h[v]}, h[v] = tot;\n}\ntemplate <class T> inline void in(T &x) {\n\tx = 0; int f = 1; char ch = getchar();\n\tfor (; ch<'0' || ch>'9';) {if (ch=='-') f=-1; ch = getchar();}\n\tfor (; ch>='0' && ch<='9';) x = x*10 + ch-'0', ch = getchar();\n\tx *= f;\n}\n\ninline int calc(int a, int b) {\n\tif (dfn[a] > dfn[b]) swap(a, b);\n\tif (dfn[a] < dfn[b] && low[a] >= dfn[b]) return dep[b] - dep[a] > 2;\n\tif (fa[a] == fa[b]) return 0; return 1;\n}\n\ninline void dfs(int x, int f) {\n\tfa[x] = f, dfn[x] = ++num;\n\tfor (int v, i = h[x]; i; i = e[i].nt)\n\t\tif ((v = e[i].v) != f) dep[v] = dep[x] + 1, dfs(v, x);\n\tlow[x] = num;\n}\n\ninline void bfs(int s) {\n\tint u, v, l = 0, r = 0;\n\tfor (q[++r] = s, vis[s] = 1; l < r;)\n\t\tfor (int i = h[u = q[++l]]; i; i = e[i].nt)\n\t\t\tif (!vis[v = e[i].v]) {\n\t\t\t\tdis[v] = dis[u] + 1;\n\t\t\t\tif (dis[v] < dep[v]) vis[v] = 1, q[++r] = v;\n\t\t\t}\n}\n\nint main() {\n\tint u, v, sx, sy; in(n), in(sx), in(sy);\n\tfor (int i = 1; i < n; ++i) in(a[i].u), in(a[i].v);\n\tfor (int i = 1; i < n; ++i) in(u), in(v), add(u, v);\n\tdfs(sy, 0), tot = 0, fill(h, h + N, 0);\n\tfor (int i = 1; i < n; ++i) {\n\t\tif (calc(a[i].u, a[i].v)) win[a[i].u] = win[a[i].v] = 1;\n\t\telse add(a[i].u, a[i].v);\n\t}\n\tbfs(sx);\n\tfor (int i = 1; i <= n; ++i) if (vis[i] && win[i]) {puts(\"-1\"); return 0;}\n\tfor (int i = 1; i <= n; ++i) if (vis[i]) ans = max(ans, dep[i] << 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e5+5;\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<2];\nint ha[N], hb[N], tot;\nvoid _add(int *h, int x, int y) { edge[++tot] = Edge(h[x], y); h[x] = tot; }\nvoid add(int *h, int x, int y) { _add(h, x, y); _add(h, y, x); }\nint fa[N], son[N], size[N], top[N], d[N];\nint ans, cir;\nvoid dfs(int x)\n{\n    size[x] = 1;\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; if(y == fa[x]) continue;\n        d[y] = d[x]+1, fa[y] = x, dfs(y), \n        size[x] += size[y], son[x] = size[son[x]]>size[y]?son[x]:y; \n    }\n}\nint lca(int x, int y)\n{\n    while(top[x] != top[y])\n    {\n        if(d[top[x]] < d[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint dis(int x, int y) { return d[x]+d[y]-2*d[lca(x, y)]; }\nvoid dfs(int x, int topf)\n{\n    top[x] = topf; if(son[x]) dfs(son[x], topf);\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(y != fa[x]&&y != son[x]) dfs(y, y);\n    }\n}\nvoid escape(int x, int fa, int dep)\n{\n    ans = max(ans, d[x]<<1); \n    for(int i = ha[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(dis(x, y) > 2) cir = 1;    \n        if(y == fa||dep >= d[y]) continue;\n        escape(y, x, dep+1);\n    }\n}\nint n, a, b;\nint main()\n{\n    n = read(), a = read(), b = read();\n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(ha, x, y);\n    } \n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(hb, x, y);\n    }\n    dfs(b); dfs(b, b); escape(a, 0, 0);\n    printf(\"%d\\n\", cir?-1:ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e5+10;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nstruct edge { int to,w,nxt; } e[N<<1];\nint tot=0,h[N];\nvoid adde(int u,int v,int w) {\n    e[++tot]=(edge){v,w,h[u]};h[u]=tot;\n    e[++tot]=(edge){u,w,h[v]};h[v]=tot;\n}\nint n,x,y,d[N][2],dis[N];\nint fa[N],son[N],siz[N],dep[N],top[N];\nbool win[N],vis[N];\nvoid dfs(int u) {\n    siz[u]=1;\n    for(int i=h[u];i;i=e[i].nxt) {\n        int v=e[i].to; if(v==fa[u]) continue;\n        fa[v]=u; dep[v]=dep[u]+1; dfs(v);\n        siz[u]+=siz[v]; if(siz[son[u]]<siz[v]) son[u]=v;\n    }\n}\nvoid dfs2(int u,int tp) {\n    top[u]=tp; if(son[u]) dfs2(son[u],tp);\n    for(int i=h[u];i;i=e[i].nxt) {\n        int v=e[i].to; if(v==fa[u]||v==son[u]) continue;\n        dfs2(v,v);\n    }\n}\nint lca(int u,int v) {\n    while(top[u]!=top[v]) {\n        if(dep[top[u]]<dep[top[v]]) swap(u,v);\n        u=fa[top[u]];\n    }\n    return dep[u]<dep[v]?u:v;\n}\nint dist(int u,int v) { return dep[u]+dep[v]-2*dep[lca(u,v)]; }\nvoid bfs() {\n    queue<int> q;\n    q.push(x);vis[x]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=h[u];i;i=e[i].nxt) {\n            if(e[i].w==1||vis[e[i].to]) continue;\n            int v=e[i].to; dis[v]=dis[u]+1;\n            if(dis[v]<dep[v]) vis[v]=1,q.push(v);\n        }\n    }\n}\nint main() {\n    cin>>n>>x>>y;\n    for(int i=1;i<n;i++) d[i][0]=gi(),d[i][1]=gi();\n    for(int i=1,u,v;i<n;i++) u=gi(),v=gi(),adde(u,v,1);\n    dfs(y);dfs2(y,y);\n    for(int i=1;i<n;i++) {\n        int u=d[i][0],v=d[i][1];\n        if(dist(u,v)>2) win[u]=win[v]=1;\n        else adde(u,v,0);\n    }\n    bfs();\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        if(vis[i]) {\n            if(win[i]) return puts(\"-1\"),0;\n            ans=max(ans,dep[i]*2);\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nint dist[200005],dist2[200005];\nvoid dfs(int v,int u,int d){\n\tdist[v] = d;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tdfs(edge[v][i],v,d+1);\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs(a,-1,0); dfs2(b,-1,0);\n\tint lb = 0,ub = n+10;\n\twhile(ub-lb>1){\n\t\tint mid = (lb+ub)/2;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(dist[i] <= mid && dist2[i] > mid) goto ok;\n\t\t}\n\t\tub = mid; continue;\n\t\tok:; lb = mid;\n\t}\n\tcout << ub*2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    vec par, d;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        par.resize(N);\n        d.resize(N);\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1){\n        add_Directed_edge(v1, v2, cost);\n        add_Directed_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int p = -1){\n        par[v] = p;\n        if(p == -1) d[v] = 0;\n        else{\n            par[v] = p;\n            d[v] = d[p] + 1;\n        }\n        for(auto e: G[v]) if(e.to != p) dfs(e.to, v);\n    }\n\n    void calcans(int v, int &ans, vec &D, vec &Par){\n        Max(ans, 2 * D[v]);\n        if(D[v] <= d[v]) return;\n        for(auto e: G[v]) if(e.to != par[v]){\n            if(v != Par[e.to] && e.to != Par[v] && Par[v] != Par[e.to] && !(Par[v] != -1 && Par[Par[v]] == e.to) && !(Par[e.to] != -1 && Par[Par[e.to]] == v)) ans = INF;\n            calcans(e.to, ans, D, Par);\n        } \n    }\n\n};\n\nsigned main(){\n\n    int N, X, Y; cin >> N >> X >> Y;\n    X--; Y--;\n    Graph R(N), B(N);\n    int a, b;\n    REP(i, N - 1){\n        cin >> a >> b;\n        R.add_Undirected_edge(a - 1, b - 1);\n    }\n    REP(i, N - 1){\n        cin >> a >> b;\n        B.add_Undirected_edge(a - 1, b - 1);\n    }\n\n    R.dfs(X);\n    B.dfs(Y);\n    vec D = B.d, Par = B.par;\n    int ans = 0;\n    R.calcans(X, ans, D, Par);\n    Ans(ans < INF, ans, -1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define maxn 200005\nusing namespace std;\nint n,x,y,dep[maxn],fa[maxn],l[maxn],r[maxn],cnt,u1[maxn],v1[maxn],dist[maxn],ans;\nbool vis[maxn],islong[maxn];\nstruct node { int v; node *nxt; } edge[maxn*4],*head[2][maxn],*ncnt;\nqueue<int> q;\nvoid addedge(int x,int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[x][u];\n\thead[x][u]=ncnt;\n}\nvoid dfs(int u)\n{\n\tl[u]=++cnt;\n\tfor(node *p=head[1][u];p;p=p->nxt)\n\t{\n\t\tint v=p->v;\n\t\tif(v==fa[u]) continue;\n\t\tfa[v]=u,dep[v]=dep[u]+1;\n\t\tdfs(v);\n\t}\n\tr[u]=++cnt;\n}\nbool check(int x,int y)\n{\n\tif(l[x]>l[y]) swap(x,y);\n\tif(l[x]<=l[y]&&r[y]<=r[x]) return dep[y]-dep[x]>2;\n\telse return fa[x]!=fa[y];\n}\nvoid bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tvis[x]=true; q.push(x);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front(); q.pop();\n\t\tfor(node *p=head[0][u];p;p=p->nxt)\n\t\t{\n\t\t\tint v=p->v;\n\t\t\tif(vis[v]) continue;\n\t\t\tdist[v]=dist[u]+1;\n\t\t\tif(dist[v]<dep[v]) { vis[v]=true; q.push(v); }\n\t\t}\n\t}\n}\nvoid read(int &x)\n{\n\tchar ch=getchar(); x=0;\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n}\nint main()\n{\n\twhile(~scanf(\"%d%d%d\",&n,&x,&y))\n\t{\n\t\tans=0;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(islong,0,sizeof(islong));\n\t\tmemset(head,0,sizeof(head));\n\t\tncnt=&edge[0];\n\t\tfor(int i=1;i<n;i++) { read(u1[i]); read(v1[i]); }//scanf(\"%d%d\",&u1[i],&v1[i]);\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tread(u); read(v);//scanf(\"%d%d\",&u,&v);\n\t\t\taddedge(1,u,v); addedge(1,v,u);\n\t\t}\n\t\tfa[y]=dep[y]=0; dfs(y);\n\t\tfor(int i=1;i<n;i++)\n\t\t\tif(check(u1[i],v1[i])) islong[u1[i]]=islong[v1[i]]=true;\n\t\t\telse { addedge(0,u1[i],v1[i]); addedge(0,v1[i],u1[i]); }\n\t\tdist[x]=0; bfs();\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n&&ans!=-1;i++)\n\t\t\tif(vis[i]&&islong[i]) ans=-1;\n\t\t\telse if(vis[i]) ans=max(ans,dep[i]*2);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nvector<int> r[200000], b[200000];\nint x, y;\nint dist[200000], can[200000];\nqueue<int> q;\nvector<PII> all;\nset<PII> be;\nset<int> se[200000];\n\nint main() {\n    scanf(\"%d\", &n);\n    scanf(\"%d%d\", &x, &y), --x, --y;\n    forn(i, n - 1) {\n        int from, to;\n        scanf(\"%d%d\", &from, &to), --from, --to;\n        r[from].pb(to);\n        r[to].pb(from);\n    }\n    forn(i, n - 1) {\n        int from, to;\n        scanf(\"%d%d\", &from, &to), --from, --to;\n        b[from].pb(to);\n        b[to].pb(from);\n        be.insert(mp(min(from, to), max(from, to)));\n        se[from].insert(to);\n        se[to].insert(from);\n    }\n    memset(dist, -1, sizeof dist);\n    dist[y] = 0;\n    q.push(y);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int to : b[v]) if (dist[to] == -1) {\n            dist[to] = dist[v] + 1;\n            q.push(to);\n        }\n    }\n    memset(can, -1, sizeof can);\n    can[x] = 0;\n    q.push(x);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int to : r[v]) if (can[to] == -1 && can[v] + 1 < dist[to]) {\n            can[to] = can[v] + 1;\n            q.push(to);\n        }\n    }\n    forn(i, n) if (can[i] != -1) {\n        for (int to : r[i]) {\n            all.pb(mp(min(i, to), max(i, to)));\n        }\n    }\n    sort(all.begin(), all.end());\n    all.erase(unique(all.begin(), all.end()), all.end());\n    for (PII x : all) {\n        if (be.count(x)) {\n            continue;\n        }\n        int mn = x.first;\n        int oth = x.second;\n        if (b[x.second].size() < b[x.first].size()) {\n            swap(mn, oth);\n        }\n        bool ok = true;\n        for (int to : b[mn]) {\n            if (se[to].count(oth)) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    int ans = 0;\n    forn(i, n) if (can[i] != -1) {\n        ans = max(ans, dist[i]);\n        for (int to : r[i]) {\n            ans = max(ans, dist[to]);\n        }\n    }\n    cout << 2 * ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(u!= U && !bad[pre[u]])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(h[u1[i]]>h[u2[i]])swap(u1[i],u2[i]);\n\t/*rep(i,1,n)if(ok[i] && (!bad[u1[i]])){\n\t\tma=-1;\n\t}*/\n\tprintf(\"%d\\n\",-1);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define fr(N,i,x) for (int i=N.lnk[x];i;i=N.nxt[i])\nusing namespace std;\nconst int maxn=200005,maxe=maxn<<1;\nint n,X,Y,dst[maxn],fa[maxn],Dst[maxn],Q[maxn],ans;bool vis[maxn];\nstruct ljb{\n\tint e,lnk[maxn],nxt[maxe],son[maxe];\n\tinline void add_e(int x,int y){son[++e]=y;nxt[e]=lnk[x];lnk[x]=e;}\n}A,B;\ninline char nc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read(){\n\tint ret=0;bool f=0;char ch=nc();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=nc();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=nc();\n\treturn f?-ret:ret;\n}\nvoid DFS(int x){fr(B,i,x) if(B.son[i]^fa[x]) dst[B.son[i]]=dst[x]+1,fa[B.son[i]]=x,DFS(B.son[i]);}\ninline void BFS(){\n\tint hed=0,til=1;Q[vis[X]=1]=X;\n\twhile(hed<til) if(Dst[Q[++hed]]<dst[Q[hed]]) fr(A,i,Q[hed])\n\tif(!vis[A.son[i]]) vis[A.son[i]]=1,Dst[A.son[i]]=Dst[Q[hed]]+1;\n}\ninline bool check(int x,int y){\n\tif(dst[x]>dst[y]){int t=x;x=y;y=t;}\n\tif(dst[y]-dst[x]==2) return fa[fa[y]]==x;\n\tif(dst[y]-dst[x]==1) return fa[y]==x;\n\tif(dst[y]-dst[x]==0) return fa[x]==fa[y];\n\treturn 0;\n}\nint main(){\n\tn=read(),X=read(),Y=read();\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),A.add_e(x,y),A.add_e(y,x);\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),B.add_e(x,y),B.add_e(y,x);\n\tdst[Y]=0;DFS(Y);BFS();\n\tfor (int i=1;i<=n;i++) if(vis[i]){\n\t\tif(dst[i]>ans) ans=dst[i];\n\t\tif(Dst[i]<dst[i]) fr(A,j,i) if(!check(A.son[j],i)) ans=1e9;\n\t}\n\tprintf(\"%d\\n\",ans==1e9?-1:ans<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 200086\n\nusing namespace std;\n\nint n, a, b;\nvector<int> v1[maxn], v2[maxn]; \nint x, y;\nint fa[maxn][25], dep[maxn], lg[maxn];\n\nvoid dfs1(int i){\n\tif(fa[i][0]) dep[i] = dep[fa[i][0]] + 1;\n\tfor(int j = 1;j < 20;j++) fa[i][j] = fa[fa[i][j - 1]][j - 1];\n\tfor(int j = 0;j < v2[i].size();j++){\n\t\tint to = v2[i][j];\n\t\tif(to == fa[i][0]) continue;\n\t\tfa[to][0] = i, dfs1(to);\n\t}\n}\n\ninline int lca(int x, int y){\n\tif(dep[x] < dep[y]) swap(x, y);\n\twhile(dep[x] > dep[y]) x = fa[x][lg[dep[x] - dep[y]]];\n\tif(x == y) return x;\n\tfor(int i = 20;~i;i--) if(fa[x][i] ^ fa[y][i]) x = fa[x][i], y = fa[y][i];\n\treturn fa[x][0];\n}\n\ninline int dist(int x, int y){\n\treturn dep[x] + dep[y] - 2 * dep[lca(x, y)];\n}\n\nint d[maxn], ans;\n\nvoid dfs2(int i, int fa){\n\tif(fa) d[i] = d[fa] + 1;\n\tif(d[i] >= dep[i]) return;\n\tif(fa && dist(i, fa) > 2) printf(\"-1\"), exit(0); \n\tans = max(ans, dep[i]);\n\tfor(int j = 0;j < v1[i].size();j++){\n\t\tint to = v1[i][j];\n\t\tif(to == fa) continue;\n\t\tdfs2(to, i); \n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor(int i = 2;i <= n;i++) lg[i] = lg[i - 1] + (1 << (lg[i - 1] + 1) == i);\n\tfor(int i = 1;i < n;i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv1[x].push_back(y), v1[y].push_back(x);\n\t}\n\tfor(int i = 1;i < n;i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv2[x].push_back(y), v2[y].push_back(x);\n\t}\n\tdfs1(b), dfs2(a, 0);\n\tprintf(\"%d\", ans * 2);\n\t\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0;char ch=' ';\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q;\n}\nconst int N=200005;\nint n,s1,s2,tim,ans;\nint win[N],dep[N],in[N],out[N],fa[N],vis[N],dis[N],que[N];\nstruct edge{int x,y;}e1[N];\nstruct tree{\n\tint h[N],ne[N<<1],to[N<<1],tot;\n\tvoid add(int x,int y) {to[++tot]=y,ne[tot]=h[x],h[x]=tot;}\n}T1,T2;\nvoid dfs(int x,int las) {\n\tdep[x]=dep[las]+1,in[x]=++tim,fa[x]=las;\n\tfor(RI i=T2.h[x];i;i=T2.ne[i])\n\t\tif(T2.to[i]!=las) dfs(T2.to[i],x);\n\tout[x]=tim;\n}\nint check(int x,int y) {\n\tif(in[x]>in[y]) swap(x,y);\n\tif(in[x]<=in[y]&&out[x]>=in[y]) return dep[y]-dep[x]>2;\n\tif(fa[x]==fa[y]) return 0;\n\treturn 1;\n}\nvoid bfs() {\n\tint he=1,ta=1;\n\tvis[s1]=1,dis[s1]=0,que[1]=s1;\n\twhile(he<=ta) {\n\t\tint x=que[he];++he;\n\t\tfor(RI i=T1.h[x];i;i=T1.ne[i])\n\t\t\tif(dis[x]+1<dep[T1.to[i]]&&!vis[T1.to[i]])\n\t\t\t\tvis[T1.to[i]]=1,dis[T1.to[i]]=dis[x]+1,que[++ta]=T1.to[i];\n\t}\n}\nint main()\n{\n\tint x,y;\n\tn=read(),s1=read(),s2=read();\n\tif(s1==s2) {puts(\"0\");return 0;}\n\tfor(RI i=1;i<n;++i) e1[i].x=read(),e1[i].y=read();\n\tfor(RI i=1;i<n;++i) x=read(),y=read(),T2.add(x,y),T2.add(y,x);\n\tdep[0]=-1,dfs(s2,0);\n\tfor(RI i=1;i<n;++i) {\n\t\tif(check(e1[i].x,e1[i].y)) win[e1[i].x]=win[e1[i].y]=1;\n\t\telse T1.add(e1[i].x,e1[i].y),T1.add(e1[i].y,e1[i].x);\n\t}\n\tbfs();\n\tfor(RI i=1;i<=n;++i)\n\t\tif(win[i]&&vis[i]) {puts(\"-1\");return 0;}\n\t\telse if(vis[i]) ans=max(ans,dep[i]+dep[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define per(i, a, b) for(int i=(b)-1; i>=(a); i--)\n#define sz(a) (int)a.size()\n#define de(a) cout << #a << \" = \" << a << endl\n#define dd(a) cout << #a << \" = \" << a << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef double db;\n\nvoid file_put() {\n    freopen(\"filename.in\", \"r\", stdin);\n    freopen(\"filename.out\", \"w\", stdout);\n}\n\nconst int N=2e5+5;\nint n,X,Y,d[N],f[N],ret=0,x,y; vi R[N],B[N];\n\nbool check(int x,int y) {\n\tif (!y) return 1;\n\tif (f[x]==y || f[y]==x) return 1;\n\tif (f[f[x]]==y || f[f[y]]==x) return 1;\n\treturn f[x]==f[y];\n}\n\nvoid dfs(int x,int p) {\n\td[x]=d[p]+1,f[x]=p;\n\tfor (auto y: B[x]) if (y!=p) dfs(y,x);\n}\n\nvoid dfs(int x,int p,int k) {\n\tret=max(ret,d[x]);\n\tfor (auto y: R[x]) if (y!=p) {\n\t\tif (!check(x,p)) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tif (d[y]>k+1) dfs(y,x,k+1);\n\t}\n}\n\nint main() {\n//\tfile_put();\n\t\n\tscanf(\"%d%d%d\",&n,&X,&Y),d[0]=-1;\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),R[x].pb(y),R[y].pb(x);\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),B[x].pb(y),B[y].pb(x);\n\tdfs(Y,0),dfs(X,0,0);\n\tprintf(\"%d\\n\",ret<<1);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 200000\n#define K 18\nstruct edge{int nx,t;}e[MN*4+5];\nint A[MN+5],B[MN+5],en,fa[K][MN+5],d[MN+5],ans;\ninline void ins(int*h,int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nvoid pre(int x)\n{\n\tfor(int i=B[x];i;i=e[i].nx)if(e[i].t!=fa[0][x])\n\t\td[e[i].t]=d[fa[0][e[i].t]=x]+1,pre(e[i].t);\n}\nint lca(int x,int y)\n{\n\tif(d[x]<d[y])swap(x,y); \n\tint k=d[x]-d[y],i;\n\tfor(i=0;k;k>>=1,++i)if(k&1)x=fa[i][x];\n\tif(x==y)return x;\n\tfor(i=K;i--;)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\nvoid solve(int x,int y,int f,int p)\n{\n\tif(x==y)return;\n\tans=max(ans,d[x]+d[y]-d[lca(x,y)]*2+p);\n\tfor(int i=A[x];i;i=e[i].nx)if(e[i].t!=f&&e[i].t!=y)\n\t{\n\t\tif(d[x]+d[e[i].t]-d[lca(x,e[i].t)]*2>2)ans=2e9;\n\t\tif(lca(e[i].t,y)==y)\n\t\t{\n\t\t\tint t=e[i].t,k=d[t]-d[y]-1,j;\n\t\t\tfor(j=0;k;k>>=1,++j)if(k&1)t=fa[j][t];\n\t\t\tsolve(e[i].t,t,x,p+1);\n\t\t}\n\t\telse solve(e[i].t,fa[0][y],x,p+1);\n\t}\n}\nint main()\n{\n\tint n,x,y,i,j;\n\tn=read();x=read();y=read();\n\tfor(i=1;i<n;++i)ins(A,read(),read());\n\tfor(i=1;i<n;++i)ins(B,read(),read());\n\tpre(1);\n\tfor(i=1;i<K;++i)for(j=1;j<=n;++j)fa[i][j]=fa[i-1][fa[i-1][j]];\n\tsolve(x,y,0,0);\n\tprintf(\"%d\",ans>1e9?-1:ans<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 200086\n\nusing namespace std;\n\nint n, a, b;\nvector<int> v1[maxn], v2[maxn]; \nint x, y;\nint fa[maxn][25], dep[maxn], lg[maxn];\n\nvoid dfs1(int i){\n\tif(fa[i][0]) dep[i] = dep[fa[i][0]] + 1;\n\tfor(int j = 1;j <= 20;j++) fa[i][j] = fa[fa[i][j - 1]][j - 1];\n\tfor(int j = 0;j < v2[i].size();j++){\n\t\tint to = v2[i][j];\n\t\tif(to == fa[i][0]) continue;\n\t\tfa[to][0] = i, dfs1(to);\n\t}\n}\n\ninline int lca(int x, int y){\n\tif(dep[x] < dep[y]) swap(x, y);\n\twhile(dep[x] > dep[y]) x = fa[x][lg[dep[x] - dep[y]]];\n\tif(x == y) return x;\n\tfor(int i = 20;~i;i--) if(fa[x][i] ^ fa[y][i]) x = fa[x][i], y = fa[y][i];\n\treturn fa[x][0];\n}\n\ninline int dist(int x, int y){\n\treturn dep[x] + dep[y] - 2 * dep[lca(x, y)];\n}\n\nint d[maxn], ans;\n\nvoid dfs2(int i, int fa){\n\tif(fa) d[i] = d[fa] + 1;\n\tif(d[i] >= dep[i]) return;\n\tans = max(ans, dep[i]);\n\tfor(int j = 0;j < v1[i].size();j++){\n\t\tint to = v1[i][j];\n\t\tif(to == fa) continue;\n\t\tif(dist(i, to) > 2) printf(\"-1\"), exit(0); \n\t\tdfs2(to, i); \n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor(int i = 2;i <= n;i++) lg[i] = lg[i - 1] + (1 << (lg[i - 1] + 1) == i);\n\tfor(int i = 1;i < n;i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv1[x].push_back(y), v1[y].push_back(x);\n\t}\n\tfor(int i = 1;i < n;i++){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv2[x].push_back(y), v2[y].push_back(x);\n\t}\n\tdfs1(b), dfs2(a, 0);\n\tprintf(\"%d\", ans * 2);\n\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> par;\n\nconst int N=200010;\n\nint n,x,y,cnt,a[N],b[N],G[N];\nint fa[N][20];\nstruct edge{\n  int t,nx;\n}E[N<<2];\n\ninline void addedge(int x,int y){\n  E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n  E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n}\n\nint dpt[N];\n\nvoid dfs(int x,int f){\n  if(f) dpt[x]=dpt[f]+1;\n  fa[x][0]=f; for(int i=1;i<=18;i++) fa[x][i]=fa[fa[x][i-1]][i-1];\n  for(int i=G[x];i;i=E[i].nx)\n    if(E[i].t!=f) dfs(E[i].t,x);\n}\n\nnamespace Grp{\n  int cnt,G[N];\n  struct edge{\n    int t,nx;\n  }E[N<<1];\n\n  inline void addedge(int x,int y){\n    E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n    E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n  }\n}\n\nqueue<int> Q;\nint dis[N],mark[N];\n\nconst int inf=1<<29;\n\ninline void bfs(){\n  for(int i=1;i<=n;i++) dis[i]=inf;\n  Q.push(x); dis[x]=0;\n  while(!Q.empty()){\n    int x=Q.front(); Q.pop();\n    for(int i=Grp::G[x];i;i=Grp::E[i].nx){\n      int v=Grp::E[i].t;\n      if(dis[v]!=inf) continue;\n      if(dis[v]+1>dpt[v]) continue;\n      dis[v]=dis[x]+1; Q.push(v);\n    }\n  }\n}\n\ninline int lca(int x,int y){\n  if(dpt[x]<dpt[y]) swap(x,y);\n  for(int i=18;~i;i--)\n    if(dpt[fa[x][i]]>=dpt[y]) x=fa[x][i];\n  if(x==y) return x;\n  for(int i=18;~i;i--)\n    if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n  return fa[x][0];\n}\n\ninline int dist(int x,int y){\n  return dpt[x]+dpt[y]-2*dpt[lca(x,y)];\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d\",&a[i],&b[i]);\n  for(int i=1,u,v;i<n;i++)\n    scanf(\"%d%d\",&u,&v),addedge(u,v);\n  dfs(y,0); dpt[0]=-1;\n  for(int i=1;i<n;i++)\n    if(dist(a[i],b[i])>2) mark[a[i]]=mark[b[i]]=1;\n    else Grp::addedge(a[i],b[i]);\n  bfs(); int ans=0;\n  for(int i=1;i<=n;i++){\n    if(mark[i] && dis[i]<dpt[i]) return puts(\"-1\"),0;\n    if(dis[i]<dpt[i]) ans=max(ans,dpt[i]*2);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nconst int mlog = 17;\nint n,a,b;\nvector<int> way1[maxn], way2[maxn];\nint depA[maxn], depB[maxn];\nint par[maxn][20];\nint good[maxn];\nint loop, ans;\nvoid build(int u, int last) {\n    par[u][0] = last;\n    for(int i=1;i<=mlog;i++) par[u][i] = par[par[u][i-1]][i-1];\n    for(auto v : way2[u]) {\n        if(v==last) continue;\n        depB[v] = depB[u] + 1;\n        build(v, u);\n    }\n}\nvoid dfs(int u, int last) {\n    if(depB[u]<=depA[u]) return ;\n    if(good[u]) loop = 1;\n    else ans = max(ans, depB[u]*2);\n    for(auto v : way1[u]) {\n        if(v==last) continue;\n        depA[v] = depA[u] + 1;\n        dfs(v, u);\n    }\n}\nint lca(int u, int v) {\n    int res = 0;\n    if(depB[u]<depB[v]) swap(u,v);\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i] && depB[par[u][i]]>=depB[v]) {\n            u = par[u][i];\n            res += (1<<i);\n        }\n    }\n    if(u==v) return res;\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i]!=par[v][i]) {\n            u = par[u][i]; v = par[v][i];\n            res += (1<<i)*2;\n        }\n    }\n    return res+2;\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way1[u].push_back(v);\n        way1[v].push_back(u);\n    }\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way2[u].push_back(v);\n        way2[v].push_back(u);\n    }\n    build(b,0);\n    return 0;\n    for(int u=1;u<=n;u++) {\n        for(auto v : way1[u]) {\n            if(lca(u,v)>=3) {\n                good[u] = good[v] = 1;\n            }\n        }\n    }\n//    for(int u=1;u<=n;u++) printf(\"%d : %d\\n\",u,good[u]);\n    dfs(a,0);\n    if(loop) printf(\"-1\");\n    else printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 202000,inf=0x3f3f3f3f;\nint n,x,y,a[N],b[N],dis[N],fa[N][18],dep[N];Vi e[N],red[N];bool win[N];\nvoid dfs1(int u, int Fa, int Dep){\n\tfa[u][0]=Fa;dep[u]=Dep;\n\trep(i,0,SZ(e[u])-1)if(e[u][i]!=Fa)\n\t\tdfs1(e[u][i],u,Dep+1);\n}\nint LCA(int u, int v){\n\tif(dep[u]<dep[v])swap(u,v);int del=dep[u]-dep[v];\n\trep(i,0,17)if(del>>i&1)u=fa[u][i];\n\tif(u==v)return u;\n\tper(i,17,0)if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];\n\treturn fa[u][0];\n}\nint getdis(int u, int v){\n\treturn dep[u]+dep[v]-2*dep[LCA(u,v)];\n}\nint res;\nvoid bfs(){\n\tmemset(dis,inf,sizeof(dis));dis[x]=0;\n\tstatic int q[N];int f=0,r=1;q[f]=x;\n\twhile(f!=r){\n\t\tint u=q[f++];if(!(dis[u]<dep[u]))continue;\n\t\tif(win[u]){puts(\"-1\");exit(0);}umax(res,2*dep[u]);\n\t\trep(i,0,SZ(red[u])-1)if(dis[red[u][i]]>dis[u]+1){\n\t\t\tdis[red[u][i]]=dis[u]+1;q[r++]=red[u][i];\n\t\t}\n\t}\n}\nint main() {\n\tread(n);read(x);read(y);\n\trep(i,1,n-1)read(a[i]),read(b[i]);\n\trep(i,1,n-1){\n\t\tint u,v;read(u),read(v);\n\t\te[u].pb(v);e[v].pb(u);\n\t}\n\tdfs1(y,0,0);\n\trep(j,1,17)rep(i,1,n)fa[i][j]=fa[fa[i][j-1]][j-1];\n\trep(i,1,n-1)if(getdis(a[i],b[i])>=3)win[a[i]]=win[b[i]]=1;\n\telse red[a[i]].pb(b[i]),red[b[i]].pb(a[i]);\n\tbfs();printf(\"%d\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define Rep(i,a) for(int i = 0; i < a; i++)\nusing namespace std;\nconst int N = 1e5 + 10;\n\nstruct edge{ int to, pre; } e[N << 1]; int l = 0, u[N];\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint n, X, Y, a[N], b[N], dep[N], fa[N];\n\nvoid dfs(int x, int f) {\n\treg(i,x) if (v != f) dep[v] = dep[x] + 1, fa[v] = x, dfs(v, x);\n}\n\nbool jump(int a, int b) {\n\tif (dep[a] < dep[b]) swap(a, b);\n\tif (fa[a] == b || fa[fa[a]] == b || fa[a] == fa[b]) return false;\n\telse return true;\n}\n\nvector<int> adj[N];\n#define pb(a) push_back(a)\n\nbool inf = false, win[N];\nint ans = 0;\nvoid chk(int x, int f, int d) {\n\tif (d >= dep[x]) return; else ans = max(ans, dep[x]);\n\tinf |= win[x]; int l = adj[x].size();\n\tRep(j,l) if (adj[x][j] != f) chk(adj[x][j], x, d + 1);\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\trep(i,1,n - 1) scanf(\"%d%d\",a + i,b + i);\n\trep(i,1,n - 1) {\n\t\tint a, b; scanf(\"%d%d\",&a,&b);\n\t\tins(a, b), ins(b, a);\n\t}\n\tdfs(Y, 0);\n\trep(i,1,n - 1) \n\t\tif (!jump(a[i], b[i])) \n\t\t\tadj[a[i]].pb(b[i]), adj[b[i]].pb(a[i]);\n\t\telse win[a[i]] = win[b[i]] = true;\n\tchk(X, 0, 0);\n\tif (inf) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans * 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int N = 2e5 + 5;\ninline int Get() {\n\tchar ch;\n\twhile ((ch = getchar()) < '0' || ch > '9');\n\tint Num = ch - '0';\n\twhile ((ch = getchar()) >= '0' && ch <= '9')\n\t\tNum = (Num << 3) + (Num << 1) + ch - '0';\n\treturn Num;\n}\n\nint n, strA, strB, w[N][2], que[N], qn, vis[N], flag[N], ans;\nstruct Graph{\n\tint tot, first[N], next[N << 1], end[N << 1], dist[N], fa[N], sze[N], dfn[N];\n\tinline void AddEdge(int x, int y) {\n\t\tnext[++tot] = first[x], first[x] = tot, end[tot] = y;\n\t\tnext[++tot] = first[y], first[y] = tot, end[tot] = x;\n\t}\n\tvoid Dfs(int x) {\n\t\tque[qn = 1] = x, fa[x] = 0, dist[x] = 0;\n\t\tfor (int ql = 1, u; u = que[ql], ql <= qn; sze[u] = 1, ++ql)\n\t\t\tfor (int k = first[u], v; v = end[k], k; k = next[k])\n\t\t\t\tif (v != fa[u]) fa[v] = u, dist[v] = dist[u] + 1, que[++qn] = v;\n\t\t\n\t\tfor (int qr = qn, u; u = que[qr], qr > 1; --qr) sze[fa[u]] += sze[u];\n\t\t\n\t\tdfn[x] = 1;\n\t\tfor (int ql = 1, u, cur; u = que[ql], cur = dfn[u], ql <= qn; ++ql) \n\t\t\tfor (int k = first[u], v; v = end[k], k; k = next[k]) \n\t\t\t\tif (v != fa[u]) dfn[v] = cur + 1, cur += sze[v];\n\t}\n\tinline bool check(int x, int y) {\n\t\tif (dist[x] < dist[y]) std :: swap(x, y);\n\t\tif (dist[x] - dist[y] > 2) return true;\n\t\tif (dfn[y] <= dfn[x] && dfn[x] < dfn[y] + sze[y]) return false;\n\t\tif (fa[x] == fa[y]) return false;\n\t\treturn true;\n\t}\n}A, B;\n\nint main() {\n\tn = Get(), strA = Get(), strB = Get();\n\tfor (int i = 1; i < n; ++i) w[i][0] = Get(), w[i][1] = Get();\n\tfor (int i = 1; i < n; ++i) B.AddEdge(Get(), Get());\n\t\n\tB.Dfs(strB);\n\tfor (int k = 1; k <= n; ++k)\n\t\tif (B.check(w[k][0], w[k][1])) flag[w[k][0]] = flag[w[k][1]] = true;\n\t\telse A.AddEdge(w[k][0], w[k][1]);\n\t\t\n\tque[qn = 1] = strA, vis[strA] = true, A.dist[strA] = 0;\n\tfor (int ql = 1, u; u = que[ql], ql <= qn; ++ql) \n\t\tfor (int k = A.first[u], v; v = A.end[k], k; k = A.next[k]) \n\t\t\tif ((A.dist[v] = A.dist[u] + 1) < B.dist[v] && !vis[v]) vis[v] = true, que[++qn] = v;\n\t\n\tfor (int i = 1; i <= n; ++i) \n\t\tif (vis[i]) {\n\t\t\tans = std :: max(ans, B.dist[i] * 2);\n\t\t\tif (flag[i]) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=200000+10;\nint h[maxn],go[maxn*4],nxt[maxn*4],co[maxn*4],e[maxn][2];\nint dfn[maxn],low[maxn],dep[maxn],d[maxn],dl[maxn],fa[maxn];\nbool bz[maxn],pd[maxn];\nint i,j,k,l,t,n,m,x,y,tot,top,ans,head,tail;\nvoid add(int x,int y,int z){\n    go[++tot]=y;\n    co[tot]=z;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nvoid dfs(int x,int y){\n    fa[x]=y;\n    dfn[x]=++top;\n    int t=h[x];\n    while (t){\n        if (co[t]&&go[t]!=y){\n            dep[go[t]]=dep[x]+1;\n            dfs(go[t],x);\n        }\n        t=nxt[t];\n    }\n    low[x]=++top;\n}\nbool check(int x,int y){\n    if (dfn[x]>dfn[y]) swap(x,y);\n    if (dfn[x]<=dfn[y]&&low[x]>=low[y]) return dep[y]-dep[x]>2;\n    if (fa[x]==fa[y]) return 0;else return 1;\n}\nvoid bfs(){\n    int now,t;\n    pd[x]=1;\n    dl[tail=1]=x;\n    while (head<tail){\n        now=dl[++head];\n        t=h[now];\n        while (t){\n            if (!co[t]&&!pd[go[t]]){\n                d[go[t]]=d[now]+1;\n                if (d[go[t]]<dep[go[t]]){\n                    pd[go[t]]=1;\n                    dl[++tail]=go[t];\n                }\n            }\n            t=nxt[t];\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&x,&y);\n    fo(i,1,n-1){\n        scanf(\"%d%d\",&j,&k);\n        //add(j,k,0);add(k,j,0);\n        e[i][0]=j;e[i][1]=k;\n    }\n    fo(i,1,n-1){\n        scanf(\"%d%d\",&j,&k);\n        add(j,k,1);add(k,j,1);\n    }\n    dfs(y,0);\n    fo(i,1,n-1){\n        j=e[i][0];k=e[i][1];\n        if (check(j,k)) bz[j]=bz[k]=1;\n        else{\n            \n        }add(j,k,0);\n            add(k,j,0);\n    }\n    bfs();\n    fo(i,1,n){\n        if (pd[i]&&bz[i]){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        else if (pd[i]) ans=max(ans,dep[i]*2);\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n#define ITER(it,a) for(__typeof(a.begin()) it=a.begin();it!=a.end();++it)\n#define DBG1(a) cerr<<#a<<\"=\"<<(a)<<\"\\n\"\n#define DBG2(a,b) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000*1000*1000 + 7;\nconst LL LINF = 1LL*INF*INF;\n\nconst LL MOD = 1000000007;\n\nconst int MAX = 200005;\n\nVI g[2][MAX];\n\nint d[2][MAX];\n\nint par[MAX];\n\n\nvoid dfs(int v,int ind,int p)\n{\n\tif(ind == 1)par[v] = p;\n\tFOR(i,0,SZ(g[ind][v]))\n\t{\n\t\tint to = g[ind][v][i];\n\t\tif(to == p)continue;\n\n\t\td[ind][to] = d[ind][v]+1;\n\t\tdfs(to,ind,v);\n\t}\n}\n\nint ans = 0;\nvoid getAns(int v,int p)\n{\n\tans = max(ans,d[1][v]);\n\tFOR(i,0,SZ(g[0][v]))\n\t{\n\t\tint to = g[0][v][i];\n\t\tif(to==p)continue;\n\n\t\tif(d[0][to]<d[1][to])getAns(to,v);\n\t}\n}\nset<PII> e2;\n\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//ios::sync_with_stdio(false);cin.tie(0);\n\n\tint n,r1,r2;\n\tcin>>n>>r1>>r2;\n\n\t--r1;--r2;\n\n\tFOR(ind,0,2)\n\tFOR(i,1,n)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tg[ind][a].PB(b);\n\t\tg[ind][b].PB(a);\n\t\tif(ind == 1)e2.insert(MP(min(a,b),max(a,b)));\n\t}\n\n\n\tdfs(r1,0,-1);\n\tdfs(r2,1,-1);\n\n\tFOR(i,0,n)\n\t{\n\t\tint p = par[i];\n\t\tif(p==-1 || par[p] == -1)continue;\n\t\tp = par[p];\n\t\te2.insert(MP(min(p,i),max(p,i)));\n\t}\n\n\tFOR(i,0,n)\n\tFOR(j,0,SZ(g[0][i]))\n\t{\n\t\tint to = g[0][i][j];\n\t\tint v = i;\n\t\tif(d[0][v] > d[0][to])swap(v,to);\n\n\t\tif(d[0][v] < d[1][v] && d[1][v]!=d[1][to] && !e2.count(MP(min(v,to),max(v,to))))\n\t\t{\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgetAns(r1,-1);\n\n\tcout<<ans*2;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7;\nconst int N = 1e6 + 34;\n\nint n, x, y;\nint a[N], b[N], c[N], d[N];\n\nint dist[N], papa[N];\nvector<int> graph[N];\n\nint sp[N];\nvector<int> gr[N];\nint ans;\n\nvoid dfs(int v, int p, int d)\n{\n    papa[v] = p;\n    dist[v] = d;\n    for (auto u : graph[v]) if (u != p)\n    {\n        dfs(u, v, d + 1);\n    }\n}\n\nint dista(int v, int u)\n{\n    if (v == papa[u]) return 1;\n    if (u == papa[v]) return 1;\n    if (papa[v] == papa[u]) return 2;\n    if (papa[papa[v]] == u) return 2;\n    if (papa[papa[u]] == v) return 2;\n    return 3;\n}\n\nvoid dfs2(int v, int p, int d)\n{\n    if (d >= dist[v]) return;\n    if (sp[v])\n    {\n        cout << -1;\n        exit(0);\n    }\n    ans = max(ans, dist[v]);\n    for (auto u : gr[v]) if (u != p)\n    {\n        dfs2(u, v, d + 1);\n    }\n}\n\nint main()\n{\n    cin >> n >> x >> y, x--, y--;\n    for (int i = 0; i < n - 1; i++) cin >> a[i] >> b[i], a[i]--, b[i]--;\n    for (int i = 0; i < n - 1; i++) cin >> c[i] >> d[i], c[i]--, d[i]--;\n    for (int i = 0; i < n - 1; i++)\n    {\n        graph[c[i]].push_back(d[i]);\n        graph[d[i]].push_back(c[i]);\n    }\n    dfs(y, y, 0);\n    for (int i = 0; i < n - 1; i++)\n    {\n        gr[a[i]].push_back(b[i]);\n        gr[b[i]].push_back(a[i]);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        if (dista(a[i], b[i]) == 3)\n        {\n            sp[a[i]] = 1;\n            sp[b[i]] = 1;\n        }\n    }\n    dfs2(x, x, 0);\n    cout << 2 * ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 2e5+5;\n\nint n, da[MAXN], db[MAXN], x, y;\nvector<int> a[MAXN], b[MAXN];\nint ans = 0;\nmap<pii, int> m;\nbool s[MAXN];\n\nvoid compdb(int v, int f = -1) {\n    if (f == -1)\n        db[v] = 0;\n    else\n        db[v] = db[f]+1;\n\n    for (int u : b[v])\n        if (u != f)\n            compdb(u, v);\n}\n\nvoid dfs(int v, int f = -1) {\n    if (f == -1)\n        da[v] = 0;\n    else\n        da[v] = da[f] + 1;\n    if (da[v] > db[v])\n        return;\n    ans = max(ans, db[v]);\n    if (da[v] >= db[v])\n        return;\n\n    if (s[v]) {\n        cout << \"-1\\n\";\n        exit(0);\n    }\n\n    for (int u : a[v])\n        if (u != f)\n            dfs(u, v);\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n >> x >> y;\n    x--; y--;\n    for (int i = 0; i < n-1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n\n    for (int i = 0; i < n-1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        b[u].push_back(v);\n        b[v].push_back(u);\n        m[pii(u, v)] = m[pii(v, u)] = 1;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int v : a[i]) {\n            bool z = 1;\n            if (b[i].size() > b[v].size())\n                continue;\n            if (m.count(pii(i, v)) > 0)\n                z = 0;\n            for (int u : b[i])\n                if (m.count(pii(u, v)) > 0)\n                    z = 0;\n            s[i] |= z;\n            s[v] |= z;\n        }\n    }\n\n    compdb(y);\n    dfs(x);\n\n    cout << 2*ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n*/\n#include<bits/stdc++.h>\n#define MAXN 200005\nusing namespace std;\n\nint n,cnt,last[MAXN];\nint father[MAXN],deep[MAXN],dis[MAXN];\nint q[MAXN],nnn[MAXN],mx[MAXN];\nint tim,a[MAXN][2],xx,yy;\nbool vis[MAXN],win[MAXN];\n\nstruct edge\n{\n    int to,next,h;\n}t[MAXN*4];\n\nvoid add(int u,int v,int h)\n{\n    t[++cnt].to=v;t[cnt].h=h;\n    t[cnt].next=last[u];last[u]=cnt;\n    t[++cnt].to=u;t[cnt].h=h;\n    t[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n    deep[x]=deep[father[x]]+1;nnn[x]=++tim;\n    for (int i=last[x];i;i=t[i].next)\n        if (t[i].to!=father[x]) father[t[i].to]=x,dfs(t[i].to);\n    mx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n    if (nnn[x]>nnn[y]) swap(x,y);\n    if (nnn[x]<nnn[y]&&mx[x]>nnn[y]) return deep[y]-deep[x]>2 ? true : false;\n    if (father[x]==father[y]) return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int h=1,tt=1;q[1]=xx;vis[xx]=1;\n    while (h<=tt)\n    {\n        int x=q[h++];\n        for (int i=last[x];i;i=t[i].next)\n            if (!t[i].h&&!vis[t[i].to])\n            {\n                dis[t[i].to]=dis[x]+1;\n                if (dis[t[i].to]<deep[t[i].to]) vis[t[i].to]=1,q[++tt]=t[i].to;\n            }\n    }\n}\n\n\ntemplate<class T>inline void read(T &res)\n{\n    static char ch;T flag=1;\n    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;\n    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;\n}\n\nint main()\n{\n    int ans=0;\n    read(n);read(xx);read(yy);\n\n    for (int i=1;i<n;i++) {read(a[i][0]);read(a[i][1]);}\n    \n    for (int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x);read(y);\n        add(x,y,1);\n    }\n\n    deep[0]=-1;\n    dfs( yy );\n\n    for (int i=1;i<n;i++)\n    {\n        if (check(a[i][0],a[i][1]))\n            win[a[i][0]]=win[a[i][1]]=1;\n        else add(a[i][0],a[i][1],0);\n    }\n\n    bfs();\n\n    for (int i=1;i<=n;i++)\n        if (win[i]&&vis[i])\n            {putchar('-');putchar('1');return 0;}\n\n    for (int i=1;i<=n;i++)\n    {\n\t\n        if (vis[i])\n            ans=max(ans,deep[i]<<1);\n}\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int \n#define ll long long\n#define mk make_pair\n#define pa pair<int,int>\n#define pb push_back\nusing namespace std;\nstruct node{int to,next;};\nint n,rt1,rt2;\nstruct Tree{\n\tnode e[410100];\n\tint h[210010],tot,dep[201000],fa[200100][21];\n\tinline void add(int from,int to){e[++tot].next=h[from];e[tot].to=to;h[from]=tot;}\n\tinline void Build() {\n\t\tfor(rint i=1;i<n;++i){\n\t\t\tint a,b;cin>>a>>b;\n\t\t\tadd(a,b);add(b,a);\n\t\t}\n\t}\n\tinline void DFS(int now,int ffa) {\n\t\tdep[now]=dep[ffa]+1;fa[now][0]=ffa;\n\t\tfor(rint i=h[now];i;i=e[i].next) {\n\t\t\tint to=e[i].to;if(to==ffa) continue;\n\t\t\tDFS(to,now);\n\t\t}\n\t}\n\tinline void Build_St(){\n\t\tfor(rint i=1;i<=20;++i) for(rint j=1;j<=n;++j) fa[j][i]=fa[fa[j][i-1]][i-1];\n\t}\n\tinline int Lca(int x,int y){\n\t\tif(x==y) return x;\n\t\tif(dep[x]>dep[y]) swap(x,y);\n\t\tfor(rint i=20;i>=0;--i) if(dep[fa[y][i]]>=dep[x]) y=fa[y][i];\n\t\tif(x==y) return x;\n\t\tfor(rint i=20;i>=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n\t\treturn fa[x][0];\n\t}\n\tinline int Get_dis(int x,int y) {\n\t\tint lca=Lca(x,y);\n\t\treturn dep[x]-dep[lca]+dep[y]-dep[lca];\n\t}\n}A,B;\nint ans=0;\ninline void Solve(int now,int ffa){\n\tans=max(ans,B.dep[now]-1);\n\tfor(rint i=A.h[now];i;i=A.e[i].next) {\n\t\tint to=A.e[i].to;if(to==ffa) continue;\n\t\tA.dep[to]=A.dep[now]+1;\n\t\tif(A.dep[to]<B.dep[to]) {\n\t\t\tSolve(to,now);\n\t\t}\n\t\tif(B.Get_dis(to,now)>=3) {\n\t\t\tcout<<\"-1\\n\";exit(0);\n\t\t}\n\t}\n}\nint main() {\n\tcin>>n>>rt1>>rt2;\n\tA.Build();\n\tB.Build();\n\tB.DFS(rt2,0);\n\tB.Build_St();\n\tA.dep[rt1]=1;\n\tSolve(rt1,0);\n\tcout<<ans*2<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#define SIZE 200005\n\nusing namespace std;\n\nvector <int> A[SIZE];\nvector <int> B[SIZE];\nint dep[SIZE],par[SIZE];\nint dp[SIZE];\n\nvoid solve(int v,int p,int d)\n{\n\tpar[v]=p;\n\tdep[v]=d;\n\tfor(int i=0;i<B[v].size();i++)\n\t{\n\t\tint to=B[v][i];\n\t\tif(to!=p) solve(to,v,d+1);\n\t}\n}\nbool good(int s,int t)\n{\n\tif(dep[s]>dep[t]) swap(s,t);//dep[s]<=dep[t]\n\tif(s==t||par[t]==s||par[s]==par[t]) return false;\n\tif(par[t]!=-1&&par[par[t]]==s) return false;\n\treturn true;\n}\nint main()\n{\n\tint n,X,Y;\n\tscanf(\"%d %d %d\",&n,&X,&Y);X--,Y--;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);a--;b--;\n\t\tA[a].push_back(b);\n\t\tA[b].push_back(a);\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);a--;b--;\n\t\tB[a].push_back(b);\n\t\tB[b].push_back(a);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tsolve(Y,-1,0);\n\tdp[X]=0;\n\tqueue <int> que;\n\tque.push(X);\n\tint ret=0;\n\twhile(!que.empty())\n\t{\n\t\tint v=que.front();que.pop();\n\t\tret=max(ret,dep[v]*2);\n\t\tfor(int i=0;i<A[v].size();i++)\n\t\t{\n\t\t\tint to=A[v][i];\n\t\t\tif(dp[to]!=-1) continue;\n\t\t\tif(good(v,to))\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(dp[v]+1<dep[to])\n\t\t\t{\n\t\t\t\tdp[to]=dp[v]+1;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define pb push_back\nint fa[200005], dep[200005], ans;\nstd::vector<int> adj_b[200005], adj_r[200005];\nvoid init(int u, int f = -1)\n{\n\tfa[u] = f;\n\tfor (int v : adj_b[u])\n\t{\n\t\tif (v != f)\n\t\t{\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tinit(v, u);\n\t\t}\n\t}\n}\ninline bool chk(int u, int v)\n{\n\tint rem = 2;\n\twhile (u != v && rem--)\n\t{\n\t\tint &x = dep[u] < dep[v] ? v : u;\n\t\tx = fa[x];\n\t}\n\treturn u == v;\n}\nvoid dfs(int u, int len = 0, int f = -1)\n{\n\tif (dep[u] > ans)\n\t\tans = dep[u];\n\tif (dep[u] <= len)\n\t\treturn;\n\tfor (int v : adj_r[u])\n\t{\n\t\tif (v != f)\n\t\t{\n\t\t\tif (!chk(u, v))\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\tthrow false;\n\t\t\t}\n\t\t\tdfs(v, len + 1, u);\n\t\t}\n\t}\n}\nint main()\ntry\n{\n\t// freopen(\"AGC005-E.in\", \"r\", stdin);\n\tint n, a, b;\n\tscanf(\"%d%d%d\", &n, &a, &b);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadj_r[--u].pb(--v);\n\t\tadj_r[v].pb(u);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadj_b[--u].pb(--v);\n\t\tadj_b[v].pb(u);\n\t}\n\tinit(--b);\n\tdfs(--a);\n\tprintf(\"%d\\n\", ans << 1);\n\treturn 0;\n}\ncatch (...)\n{\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N, X, Y;\nvector<int> adj1[MN], adj2[MN];\nint par[20][MN], dep[MN], tin[MN], tout[MN], timer;\n\nvoid dfs0(int u, int p) {\n    tin[u] = timer++;\n\n    par[0][u] = p;\n    for(int i = 1; i < 20; i++) {\n        int t = par[i - 1][u];\n        if(t == -1) break;\n        par[i][u] = par[i - 1][t];\n    }\n\n    for(int i = 0; i < adj2[u].size(); i++) {\n        int v = adj2[u][i];\n        if(v == p) continue;\n        dep[v] = dep[u] + 1;\n        dfs0(v, u);\n    }\n\n    tout[u] = timer;\n}\n\nint lca(int a, int b) {\n    if(dep[a] < dep[b]) swap(a, b);\n    int diff = dep[a] - dep[b];\n    for(int i = 0; i < 20; i++) {\n        if(diff & (1 << i)) a = par[i][a];\n    }\n    if(a == b) return a;\n    for(int i = 20; i--;) {\n        if(par[i][a] != par[i][b]) {\n            a = par[i][a];\n            b = par[i][b];\n        }\n    }\n    return par[0][a];\n}\n\nint dist(int u, int v) {\n    return dep[u] + dep[v] - 2 * dep[ lca(u, v) ];\n}\n\nint ans;\nvoid dfs1(int u, int p) {\n    ans = max(ans, dep[u]);\n    for(int i = 0; i < adj1[u].size(); i++) {\n        int v = adj1[u][i];\n        if(v == p) continue;\n        if(dist(v, X) >= 3) {\n            printf(\"-1\");\n            exit(0);\n        }\n        if(dep[v] - dep[Y] < 2 && tin[Y] <= tin[v] && tin[v] < tout[Y]) continue;\n        dfs1(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    X--; Y--;\n\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj1[a].push_back(b);\n        adj1[b].push_back(a);\n    }\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj2[a].push_back(b);\n        adj2[b].push_back(a);\n    }\n\n    dfs0(Y, -1);\n\n    while(dep[X] - dep[Y] > 2) {\n        int mn = 1e9, p = -1;\n        for(int i = 0; i < adj1[X].size(); i++) {\n            int v = adj1[X][i];\n\n            if(dist(X, v) >= 3) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            if(mn > dep[v]) {\n                mn = dep[v];\n                p = v;\n            }\n        }\n        if(mn >= dep[X]) break;\n        X = p;\n\n        for(int i = 0; i < adj2[Y].size(); i++) {\n            int v = adj2[Y][i];\n            if(tin[v] <= tin[X] && tin[X] < tout[v]) {\n                Y = v;\n                break;\n            }\n        }\n    }\n\n    dfs1(X, -1);\n\n    printf(\"%d\", 2 * ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=4e5+10;\n\nint n,x,y,fa[maxn],dep[maxn];\n\nstruct Tree{\n\tint tote,FIR[maxn],TO[maxn],NEXT[maxn];\n\tbool free[maxn];\n\n\tvoid addedge(int u,int v)\n\t{\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t}\n\n\tvoid dfs(int u)\n\t{\n//\t\tprintf(\"dfs %d : dep=%d\\n\",u,dep[u]);\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (fa[u]==v) continue;\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs(v);\n\t\t}\n\t}\n\n\tint solve(int u,int f,int dis)\n\t{\n//\t\tprintf(\"u=%d\\n\",u);\n\t\tint Ans=dep[u];\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (v==f) continue;\n\t\t\tif (dis>=dep[v]) continue;\n\t\t\tbool flag=fa[v]==u||fa[u]==v||fa[fa[v]]==u||fa[fa[u]]==v||fa[u]==fa[v];\n\t\t\tif (!flag) return 1e8;\n//\t\t\tprintf(\"solving %d : %d--->%d\\n\",u,u,v);\n\t\t\tAns=max(Ans,solve(v,u,dis+1));\n\t\t}\n\t\treturn Ans;\n\t}\n}red,blue;\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,u,v;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred.addedge(u,v);\n\t\tred.addedge(v,u);\n\t}\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue.addedge(u,v);\n\t\tblue.addedge(v,u);\n\t}\n\tblue.dfs(y);\n\tint Ans=red.solve(x,0,0);\n\tif (Ans>=1e7) puts(\"-1\");\n\telse printf(\"%d\\n\",Ans*2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint n;\nvector<vector<int> > g,h;\nvector<int>  dep;\nvector<vector<int> > p;\nvector<bool> ng;\nvoid dfsinit(int id,int pre){\n    if(id==0){\n        dep[id] = 0;\n        p[id][0] = 0;\n    }else{\n        dep[id] = dep[pre]+1;\n        p[id][0] = pre;\n    }\n    for(auto x:h[id]){\n        if(x!=pre){\n            dfsinit(x,id);\n        }\n    }\n}\nvoid init(){\n    dep.resize(n);\n    p.resize(n);\n    rep(i,n){\n        p[i].resize(20);\n    }\n    dfsinit(0,-1);\n    for(int k=1;k<20;k++){\n        rep(i,n){\n            p[i][k] = p[p[i][k-1]][k-1];\n        }\n    }\n}\nint lca(int a,int b){\n    if(dep[a]>dep[b])swap(a,b);\n    for(int k=0;k<20;k++){\n        if((dep[b]-dep[a])>>k & 1){\n            b = p[b][k];\n        }\n    }\n    if(a==b)return a;\n    for(int k=19;k>=0;k--){\n        if(p[a][k]!=p[b][k]){\n            a = p[a][k];\n            b = p[b][k];\n        }\n    }\n    return p[a][0];\n}\nint dist(int a,int b){\n    int c = lca(a,b);\n    return dep[a] + dep[b] - 2*dep[c];\n}\nint next(int x,int y){\n    int z = lca(x,y);\n    if(x==z){\n        return p[y][0];\n    }else if(y==z){\n        int s = dep[x]-dep[y]-1;\n        for(int k=0;k<20;k++){\n            if((s)>>k & 1){\n                x = p[x][k];\n                s -= (1<<k);\n            }\n        }\n        return x;\n    }else{\n        return p[y][0];\n    }\n}\nbool flag = 0;\nvoid dfs(int x,int y,int pre){\n    if(ng[x]){\n        flag = true;\n        return;\n    }\n    for(auto z:g[x]){\n        if(z==pre)continue;\n        if(dist(y,z)<=1)continue;\n        dfs(z,next(z,y),x);\n    }\n    return ;\n}\nint dfs2(int x,int y,int pre){\n    int mx = 2*(dist(x,y));\n    for(auto z:g[x]){\n        if(z==pre)continue;\n        if(dist(y,z)<=1)continue;\n        mx = max(mx,2+dfs2(z,next(z,y),x));\n    }\n    return mx;\n}\nint main(){\n    cin >> n;\n    g.resize(n);\n    h.resize(n);\n    ng.resize(n);\n    int x,y;\n    cin >> x >> y;\n    x--;y--;\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        h[a].push_back(b);\n        h[b].push_back(a);\n    }\n    init();\n    rep(i,n){\n        for(auto z:g[i]){\n            if(dist(i,z)>=3){\n                ng[i] = true;\n                ng[z] = true;\n            }\n        }\n    }\n    dfs(x,y,-1);\n    if(flag){\n        cout << -1 << endl;\n        return 0;\n    }\n    cout << dfs2(x,y,-1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int N=200005;\n\nstruct node{\n\tint x,y;\n\tnode(){}\n\tnode(int x,int y):x(x),y(y){}\n}a[N];\nint n,x,y,S,T,cnt,rt,ans,z;\nint dep[N],vis[N],dis[N],fa[N],in[N],ot[N],tag[N];\nvector<int> lv1[N],lv2[N];\nqueue<int> q;\n\nvoid dfs2(int k,int pre){\n\tint j,u;\n\tin[k]=++cnt;\n\tfor (j=0;j<lv2[k].size();j++){\n\t\tu=lv2[k][j];\n\t\tif (u==pre) continue;\n\t\tdep[u]=dep[k]+1; fa[u]=k;\n\t\tdfs2(u,k);\n\t}\n\tot[k]=++cnt;\n}\n\nbool check(int x,int y){\n\tif (in[x]>in[y]) swap(x,y);\n\tif (in[x]<in[y]&&ot[x]>in[y]) return (dep[y]-dep[x]>2);\n\tif (fa[x]==fa[y]) return 0;\n\treturn 1;\n}\n\nvoid bfs(){\n\tint j,k,u;\n\tq.push(S); vis[S]=1;\n\twhile (!q.empty()){\n\t\tk=q.front(); q.pop();\n\t\tfor (j=0;j<lv1[k].size();j++){\n\t\t\tu=lv1[k][j];\n\t\t\tif (!vis[u]&&dis[k]+1<dep[u]){\n\t\t\t\tdis[u]=dis[k]+1;\n\t\t\t\tvis[u]=1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d%d%d\",&n,&S,&T);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ta[i]=node(x,y);\n\t}\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlv2[x].push_back(y);\n\t\tlv2[y].push_back(x);\n\t}\n\tdfs2(T,0);\n\tfor (i=1;i<n;i++){\n\t\tif (check(a[i].x,a[i].y)) tag[a[i].x]=tag[a[i].y]=1;\n\t\telse{\n\t\t\tlv1[a[i].x].push_back(a[i].y);\n\t\t\tlv1[a[i].y].push_back(a[i].x);\n\t\t}\n\t}\n\tbfs();\n\tfor (i=1;i<=n;i++)\n\t\tif (tag[i]&&vis[i]){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor (i=1;i<=n;i++)\n\t\tif (vis[i]) ans=max(ans,dep[i]*2);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=4e5+10;\n\nint n,x,y,fa[maxn],dep[maxn],Ans;\n\nstruct Tree{\n\tint tote,FIR[maxn],TO[maxn],NEXT[maxn];\n\n\tvoid addedge(int u,int v)\n\t{\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t}\n\n\tvoid dfs(int u)\n\t{\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (fa[u]==v) continue;\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs(v);\n\t\t}\n\t}\n\n\tvoid solve(int u,int f,int dis)\n\t{\n\t\tAns=max(Ans,dep[u]);\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (v==f) continue;\n\t\t\tbool flag=fa[v]==u||fa[u]==v||fa[fa[v]]==u||fa[fa[u]]==v||fa[u]==fa[v];\n\t\t\tif (!flag) {Ans=1e8; return;}\n\t\t\tif (dis+1>=dep[v]) continue;\n\t\t\tsolve(v,u,dis+1);\n\t\t}\n\t}\n}red,blue;\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,u,v;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred.addedge(u,v);\n\t\tred.addedge(v,u);\n\t}\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue.addedge(u,v);\n\t\tblue.addedge(v,u);\n\t}\n\tblue.dfs(y);\n\tred.solve(x,0,0);\n\tif (Ans>=1e7) puts(\"-1\");\n\telse printf(\"%d\\n\",Ans*2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\nconst int oo=(1<<30)-1;\n\nint chk[N],u[N],v[N];\nint n,x,y,ans;\n\nstruct Edge{\n\tint y,nxt;\n};\n\nstruct Tree{\n\tEdge E[N*2];\n\tint fa[20][N];\n\tint las[N],dep[N];\n\tint cnt;\n\tTree(){\n\t\tmemset(las,-1,sizeof(las));\n\t}\n\tvoid Link(int x,int y){\n\t\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\t\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n\t}\n\tvoid dfs(int x){\n\t\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\t\tif ((y=E[i].y)!=fa[0][x]){\n\t\t\t\tfa[0][y]=x;\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\tdfs(y);\n\t\t\t}\n\t}\n\tint LCA(int x,int y){\n\t\tif (dep[x]>dep[y]) swap(x,y);\n\t\tfor (int k=dep[y]-dep[x],i=0;k;k>>=1,i++) if (k&1) y=fa[i][y];\n\t\tif (x==y) return x;\n\t\tfor (int i=19;~i;i--) if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];\n\t\treturn fa[0][x];\n\t}\n\tint dis(int x,int y){\n\t\treturn dep[x]+dep[y]-2*dep[LCA(x,y)];\n\t}\n\tvoid Work(int rt){\n\t\tdfs(rt);\n\t\tFor(i,1,20) For(x,1,n+1) fa[i][x]=fa[i-1][fa[i-1][x]];\n\t}\n} R,B;\n\nvoid Dfs(int x){\n\tchk[x]=max(chk[R.fa[0][x]],R.dep[x]-B.dep[x]);\n\tfor (int i=R.las[x],y;~i;i=R.E[i].nxt)\n\t\tif ((y=R.E[i].y)!=R.fa[0][x]){\n\t\t\tDfs(y);\n\t\t}\n}\n\nint main(){\n\t//freopen(\"supersmall7.in\",\"r\",stdin);\n\tn=IN(),x=IN(),y=IN();\n\tFor(i,1,n){\n\t\tu[i]=IN(),v[i]=IN();\n\t\tR.Link(u[i],v[i]);\n\t}\n\tFor(i,1,n) B.Link(IN(),IN());\n\tR.Work(x);\n\tB.Work(y);\n\tchk[0]=-oo;\n\tDfs(x);\n\tFor(i,1,n){\n\t\tif (chk[u[i]]>=0&&chk[v[i]]>=0) continue;\n\t\tif (B.dis(u[i],v[i])>2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tFor(i,1,n+1) if (chk[i]<=0) ans=max(ans,B.dep[i]);\n\tprintf(\"%d\\n\",2*ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct LowestCommonAncestor{\n  int n,h;\n  vector<vector<int> > G,par;\n  vector<int> dep;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int n):n(n),G(n),dep(n){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n  }\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    for(int u:G[v])\n      if(u!=p) dfs(u,v,d+1);\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<h;k++){\n      for(int v=0;v<n;v++){\n        if(par[k][v]<0) par[k+1][v]=-1;\n        else par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int k=0;k<h;k++){\n      if((dep[v]-dep[u])>>k&1){\n        v=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=h-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n        u=par[k][u];\n        v=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,x,y;\n  cin>>n>>x>>y;\n  x--;y--;\n  // G: sugim, H: sigma\n  vector<vector<int> > G(n),H(n);\n  for(int t=0;t<2;t++){\n    auto &T=(t==0?H:G);\n    for(int i=1;i<n;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      T[a].emplace_back(b);\n      T[b].emplace_back(a);\n    }\n  }\n  \n  LowestCommonAncestor lca(n);\n  lca.G=G;\n  lca.build(y);\n  \n  vector<int> dist(n,-1);\n  queue<int> q;\n  dist[x]=0;\n  q.emplace(x);\n\n  auto WIN=[](){cout<<-1<<endl;exit(0);};\n  int ans=0;\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    chmax(ans,lca.dep[v]);\n    for(int u:H[v]){\n      if(~dist[u]) continue;\n      dist[u]=dist[v]+1;\n      if(dist[u]>=lca.dep[u]) continue;\n      q.emplace(u);\n            \n      if(lca.distance(u,v)>=3) WIN();\n    }\n  }\n  \n  cout<<ans*2<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <codecvt>\n\nconst int N = 200001;\n\nint n, x, y, a[N], b[N], depth[N], parent[N], escape[N], dist[N];\nstd::vector<int> tree[N], graph[N];\n\nvoid prepare(int p, int u) {\n  depth[u] = depth[p] + 1, parent[u] = p;\n  for (int v : tree[u]) {\n    if (v != p) {\n      prepare(u, v);\n    }\n  }\n}\n\nint treedist(int a, int b) {\n  int d = 0;\n  while (d < 3 && a != b) {\n    int &u = depth[a] > depth[b] ? a : b;\n    d++, u = parent[u];\n  }\n  return d;\n}\n\nint main() {\n  scanf(\"%d%d%d\", &n, &x, &y);\n  for (int i = 0; i < n - 1; ++i) {\n    scanf(\"%d%d\", a + i, b + i);\n  }\n  for (int i = 0, c, d; i < n - 1; ++i) {\n    scanf(\"%d%d\", &c, &d);\n    tree[c].push_back(d);\n    tree[d].push_back(c);\n  }\n  depth[0] = -1;\n  prepare(0, y);\n  for (int i = 0; i < n - 1; ++i) {\n    if (treedist(a[i], b[i]) == 3) {\n      escape[a[i]] = escape[b[i]] = true;\n    } else {\n      graph[a[i]].push_back(b[i]);\n      graph[b[i]].push_back(a[i]);\n    }\n  }\n  std::vector<int> queue;\n  queue.push_back(x);\n  memset(dist, -1, sizeof(dist));\n  dist[x] = 0;\n  for (int head = 0; head < static_cast<int>(queue.size()); ++head) {\n    int u = queue[head];\n    for (int v : graph[u]) {\n      if (dist[v] == -1) {\n        dist[v] = dist[v] + 1;\n        queue.push_back(v);\n      }\n    }\n  }\n  int result = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (~dist[i] && dist[i] < depth[i]) {\n      result = std::max(result, depth[i] * 2);\n    }\n    if (escape[i] && ~dist[i] && dist[i] < depth[i]) {\n      result = -1;\n      break;\n    }\n  }\n  printf(\"%d\\n\", result);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 200005, LOG = 20;\nconst int INF = 0x3f3f3f3f;\n\nvector<int> T1[NMAX], T2[NMAX];\nint father[NMAX], level[NMAX];\nint anc[LOG][NMAX];\n\nint dist[NMAX];\n\nvoid dfs(int node, int prev) {\n    father[node] = prev;\n    for (int to: T2[node]) {\n        if (to != prev) {\n            level[to] = level[node] + 1;\n            dfs(to, node);\n        }\n    }\n}\n\nint goUp(int x, int lvl) {\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (lvl & (1 << k)) {\n            x = anc[k][x];\n        }\n    }\n    return x;\n}\n\nint lca(int x, int y) {\n    if (level[y] > level[x]) {\n        y = goUp(y, level[y] - level[x]);\n    } else if (level[x] > level[y]) {\n        x = goUp(x, level[x] - level[y]);\n    }\n    if (x == y) {\n        return x;\n    }\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (anc[k][x] != anc[k][y]) {\n            x = anc[k][x];\n            y = anc[k][y];\n        }\n    }\n    return father[x];\n}\n\nint xdist(int x, int y) {\n    return level[x] + level[y] - 2 * level[lca(x, y)];\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, r1, r2;\n    cin >> n >> r1 >> r2;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T1[x].push_back(y);\n        T1[y].push_back(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T2[x].push_back(y);\n        T2[y].push_back(x);\n    }\n    dfs(r2, -1);\n    father[r2] = r2;\n\n    for (int i = 1; i <= n; ++i) {\n        anc[0][i] = father[i];\n    }\n    for (int k = 1; k < LOG; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            anc[k][i] = anc[k - 1][anc[k - 1][i]];\n        }\n    }\n\n    memset(dist, INF, sizeof dist);\n    queue<int> q;\n    dist[r1] = 0;\n    q.push(r1);\n    int ans = 0;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        ans = max(ans, 2 * level[node]);\n\n        for (int to: T1[node]) {\n            if (xdist(node, to) > 2) {\n                cout << \"-1\\n\";\n                return 0;\n            }\n            if (dist[to] > dist[node] + 1 && dist[node] + 1 <= level[to]) {\n                dist[to] = dist[node] + 1;\n                q.push(to);\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define LOG 20\n#define SIZE 200000\nvector<int>pat[SIZE];\nint par[LOG][SIZE];\nint dep[SIZE];\nbool flag[SIZE];\nvoid dfs(int node, int d)\n{\n\tif (flag[node])return;\n\tflag[node] = true;\n\tdep[node] = d;\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]])\n\t\t{\n\t\t\tpar[0][pat[node][i]] = node;\n\t\t\tdfs(pat[node][i], d + 1);\n\t\t}\n\t}\n}\nvoid lcainit(int num)\n{\n\tfor (int i = 1; i < LOG; i++)\n\t{\n\t\tfor (int j = 0; j < num; j++)\n\t\t{\n\t\t\tpar[i][j] = par[i - 1][par[i - 1][j]];\n\t\t}\n\t}\n}\nbool isanc(int a, int b)\n{\n\tfor (int i = 19; i >= 0; i--)if (dep[a] >= dep[b] + (1 << i))a = par[i][a];\n\treturn a == b;\n}\nvector<int>np[SIZE];\nbool iswin[SIZE];\nint maxi = 0;\nvoid calc(int node, int t)\n{\n\tif (flag[node])return;\n\tflag[node] = true;\n\tif (t >= dep[node])return;\n\tif (iswin[node])maxi = 1000000000;\n\tmaxi = max(maxi, dep[node]);\n\tfor (int i = 0; i < np[node].size(); i++)calc(np[node][i], t + 1);\n}\nint main()\n{\n\tint num, st, root;\n\tscanf(\"%d%d%d\", &num, &st, &root);\n\tst--, root--;\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tnp[za].push_back(zb);\n\t\tnp[zb].push_back(za);\n\t}\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tdfs(root, 0);\n\tpar[0][root] = root;\n\tlcainit(num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tfor (int j = 0; j < np[i].size(); j++)\n\t\t{\n\t\t\tint y = np[i][j];\n\t\t\tif (!isanc(y, par[0][i]) && par[0][par[0][i]] != y)iswin[i] = true;\n\t\t}\n\t}\n\tfill(flag, flag + num, false);\n\tcalc(st, 0);\n\tif (maxi == 1000000000)printf(\"-1\\n\");\n\telse printf(\"%d\\n\", maxi * 2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200010;\n\ntemplate<typename T> inline T read() {\n\tT x(0), f(1);\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint e, st[MAXN], to[MAXN<<1];\nint nxt[MAXN<<1];\ninline void add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e;\n}\n\nint E, St[MAXN], To[MAXN<<1];\nint Nxt[MAXN<<1];\ninline void Add(int u, int v) {\n\tTo[++E] = v, Nxt[E] = St[u];\n\tSt[u] = E;\n}\n\nint n, dep[MAXN], rx, ry;\nint fa[MAXN][20], ans;\nbool vis[MAXN], flag[MAXN];\n\nvoid dfs(int u) {\n\tfor(int i = st[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif(v == fa[u][0]) continue;\n\t\tdep[v] = dep[u]+1;\n\t\tfa[v][0] = u, dfs(v);\n\t}\n}\n\ninline int LCA(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tfor(int i = 18; i >= 0; i--) \n\t\tif(dep[fa[u][i]] >= dep[v]) \n\t\t\tu = fa[u][i];\n\tif(v == u) return u;\n\tfor(int i = 18; i >= 0; i--) \n\t\tif(fa[u][i] ^ fa[v][i])\n\t\t\tu = fa[u][i], v = fa[v][i];\n\treturn fa[u][0];\n}\n\nvoid Dfs(int u, int d) {\n\tif(flag[u]) {\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t}\n\tvis[u] = true;\n\tans = max(ans, (dep[u]-1)<<1);\n\tfor(int i = St[u]; i; i = Nxt[i]) {\n\t\tint v = To[i];\n\t\tif(vis[v]) continue;\n\t\tif(dep[v] <= d+1) continue;\n\t\tDfs(v, d+1);\n\t}\n}\n\nint main() {\n\tn = read<int>();\n\trx = read<int>(), ry = read<int>();\n\tfor(int i = 1; i < n; i++) {\n\t\tint u = read<int>(), v = read<int>();\n\t\tAdd(u, v), Add(v, u);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint u = read<int>(), v = read<int>();\n\t\tadd(u, v), add(v, u);\n\t}\n\tdep[ry] = 1;\n\tdfs(ry);\n\tfor(int k = 1; k <= 18; k++) \n\t\tfor(int i = 1; i <= n; i++) \n\t\t\tfa[i][k] = fa[fa[i][k-1]][k-1];\n\tfor(int u = 1; u <= n; u++) {\n\t\tfor(int i = St[u]; i; i = Nxt[i]) {\n\t\t\tint v = To[i];\n\t\t\tif(dep[u]+dep[v]-(dep[LCA(u, v)]<<1) > 2) \n\t\t\t\tflag[u] = flag[v] = true;\n\t\t}\n\t}\n\tDfs(rx, 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nconst int MN=200000;\nint N,A,B;\nvector<int> Ga[MN],Gb[MN];\nbool vis[MN];\t//Ga\ntypedef pair<int,int> P;\n\n\nconst int MAX_V=MN;\nconst int LOGV=18;\nint par[MAX_V][LOGV],depth[MAX_V];\nvoid dfs(int v,int p){\n\tif(p<0) depth[v]=0;\n\telse depth[v]=depth[p]+1;\n\tpar[v][0]=p;\n\tfor(int u:Gb[v]){\n\t\tif(u!=p) dfs(u,v);\n\t}\n}\nvoid genlca(int N){\n\tdfs(0,-1);\n\tfor(int i=1;i<LOGV;i++){\n\t\trep(v,N){\n\t\t\tif(par[v][i-1]==-1) par[v][i]=-1;\n\t\t\telse par[v][i]=par[par[v][i-1]][i-1];\n\t\t}\n\t}\n}\nint lca(int u,int v){\n\tif(depth[u]<depth[v]){\n\t\tswap(u,v);\n\t}\n\tint d=depth[u]-depth[v];\n\trep(i,LOGV){\n\t\tif((d>>i)&1) u=par[u][i];\n\t}\n\tif(u==v) return u;\n\tfor(int i=LOGV-1;i>=0;i--){\n\t\tif(par[u][i]!=par[v][i]){\n\t\t\tu=par[u][i];\n\t\t\tv=par[v][i];\n\t\t}\n\t}\n\treturn par[v][0];\n}\n\n\nint distB(int x,int y){\n\tint w=lca(x,y);\n\treturn depth[x]+depth[y]-2*depth[w];\n}\nint up(int v,int d){\n\trep(i,LOGV) if((d>>i)&1) v=par[v][i];\n\treturn v;\n}\nint toclose(int x,int tar){\n\tassert(x!=tar);\n\tint w=lca(x,tar);\n\tif(w!=x) return par[x][0];\n\tint d=depth[tar]-depth[x];\n\treturn up(tar,d-1);\n}\n\nint solve(){\n\tcin>>N>>A>>B;\n\tA--,B--;\n\trep(i,N-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--,y--;\n\t\tGa[x].pb(y);\n\t\tGa[y].pb(x);\n\t}\n\trep(i,N-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--,y--;\n\t\tGb[x].pb(y);\n\t\tGb[y].pb(x);\n\t}\n\n\tgenlca(N);\n\n\tint d=-1;\n\tqueue<P> que;\n\tque.push(P(-1,-1));\n\tque.push(P(A,B));\n\tvis[A]=1;\n\tint ans=0;\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tif(p.sc==-1){\n\t\t\tif(que.empty()) break;\n\t\t\tque.push(P(d+1,-1));\n\t\t\td++;\n//\t\t\tshow(d);\n\t\t\tcontinue;\n\t\t}\n\t\tint a=p.fs,b=p.sc;\n//\t\tprintf(\"a=%d,b=%d\\n\",a,b);\n\t\tchmax(ans,(d+distB(a,b))*2);\n\t\tfor(int na:Ga[a]) if(!vis[na]){\n\t\t\tif(distB(a,na)>=3){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tvis[na]=1;\n\t\t\tif(b==na) continue;//?\n\t\t\tint nb=toclose(b,na);\n\t\t\tif(nb==na) continue;\n\t\t\tque.push(P(na,nb));\n\t\t}\n\t}\n\treturn max(ans,d*2);\n}\nint main(){\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <memory.h>\n#include <vector>\n#include <queue>\n \nusing namespace std;\ntypedef long long LL;\n#define pb push_back\nconst int maxn = 200005;\n\nvector<int> r[maxn],b[maxn];\nint n,X,Y,fa[maxn],dis[maxn],dep[maxn],ans;\nbool vis[maxn],safe[maxn];\nqueue<int> Q;\n\nbool check(int u,int v) {\n\treturn fa[u]==v||fa[u]==fa[v]||u==fa[v]||fa[fa[u]]==v||fa[fa[v]]==u;\n}\nvoid dfs(int u) {\n\tfor (int v,j=0;j<b[u].size();j++)\n\tif ((v=b[u][j])!=fa[u])\n\t\tdep[v]=dep[u]+1,fa[v]=u,dfs(v);\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc005e.in\",\"r\",stdin);\n\t\tfreopen(\"agc005e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d %d\",&n,&X,&Y);\n\tfor (int u,v,i=1;i<n;i++)\n\t\tscanf(\"%d %d\",&u,&v),r[u].pb(v),r[v].pb(u);\n\tfor (int u,v,i=1;i<n;i++)\n\t\tscanf(\"%d %d\",&u,&v),b[u].pb(v),b[v].pb(u);\n\t\n\tdfs(Y);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=0;j<r[i].size();j++)\n\tif (!check(i,r[i][j]))\n\t\tsafe[i]=safe[r[i][j]]=true;\n\t\n\tQ.push(X);dis[X]=0;vis[X]=true;\n\twhile (!Q.empty()) {\n\t\tint u=Q.front();Q.pop();\n\t\tif (safe[u]) {puts(\"-1\");return 0;}\n\t\tans=max(ans,dep[u]*2);\n\t\tfor (int v,j=0;j<r[u].size();j++)\n\t\tif (!vis[v=r[u][j]]&&dis[u]+1<dep[v]) {\n\t\t\tQ.push(v);vis[v]=true;dis[v]=dis[u]+1;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint N, X, Y, answer;\nvector<int> rAdj[MAXN], bAdj[MAXN];\nint fa[MAXN], dep[MAXN];\n\nclass noSolution : std::exception\n{\n\n};\n\nvoid findBlueFa(int cur, int pre) noexcept\n{\n\tfa[cur] = pre;\n\n\tfor (int to : bAdj[cur])\n\t\tif (to != pre)\n\t\t\tdep[to] = dep[cur] + 1, findBlueFa(to, cur);\n}\n\nbool isShortPath(int u, int v) noexcept\n{\n\tif (dep[u] < dep[v])\n\t\tswap(u, v);\n\n\tfor (int len = 0; len < 2; len++)\n\t{\n\t\tif (u == v)\n\t\t\tbreak;\n\n\t\tif (dep[u] < dep[v])\n\t\t\tv = fa[v];\n\t\telse\n\t\t\tu = fa[u];\n\t}\n\treturn (u == v);\n}\n\nvoid DFS(int cur, int pre = -1, int constrain = 0) //throw (solution)\n{\n\tanswer = max(answer, dep[cur]);\n\tif(dep[cur] <= constrain)\n\t\treturn;\n\n\tfor(int to : rAdj[cur])\n\t{\n\t\tif(to == pre)\n\t\t\tcontinue;\n\t\tif(!isShortPath(cur, to))\n\t\t\tthrow noSolution();\n\t\tDFS(to, cur, constrain + 1);\n\t}\n}\n\nint main()\n{\n\tint u, v;\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor(int i = 1; i < N; i++)\n\t\tscanf(\"%d%d\", &u, &v), rAdj[u].push_back(v), rAdj[v].push_back(u);\n\tfor(int i = 1; i < N; i++)\n\t\tscanf(\"%d%d\", &u, &v), bAdj[u].push_back(v), bAdj[v].push_back(u);\n\n\tfindBlueFa(Y, 0);\n\n\ttry\n\t{\n\t\tDFS(X);\n\t\tprintf(\"%d\\n\", answer * 2);\n\t}\n\tcatch (noSolution & x)\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nconst int N=2e5+5;\nint n;\n\ntemplate <class T> inline void apx(T &x,const T y){\n\tif(x<y) x=y;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=getchar())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\treturn x;\n}\n\nnamespace G{\n\tint st_f,st_s,dep[N],xdis;\n\tint fa[N],sz[N],son[N],top[N];\n\tstd::vector <int> vf[N],vs[N];\n\n\tinline int get_lca(int x,int y){\n\t\twhile(top[x]!=top[y]){\n\t\t\tdep[top[x]]>dep[top[y]]?x=fa[top[x]]:y=fa[top[y]];\n\t\t}\n\t\treturn dep[x]<dep[y]?x:y;\n\t}\n\n\tinline int get_dis(const int x,const int y){\n\t\treturn dep[x]+dep[y]-(dep[get_lca(x,y)]<<1);\n\t}\n\n\tvoid dfs_sz(const int x){\n\t\tsz[x]=1;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!sz[*it]){\n\t\t\t\tdep[*it]=dep[x]+1;\n\t\t\t\tfa[*it]=x;\n\t\t\t\tdfs_sz(*it);\n\t\t\t\tif(sz[*it]>sz[son[x]]) son[x]=*it;\n\t\t\t\tsz[x]+=sz[*it];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs_top(const int x){\n\t\ttop[x]=son[fa[x]]==x?top[fa[x]]:x;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!top[*it]) dfs_top(*it);\n\t\t}\n\t}\n\n\tbool dfs_free(const int x,const int fa,const int dis){\n\t\tstd::vector <int> ::iterator it;\n\t\tif(dis<dep[x]){\n\t\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\t\tif(get_dis(x,*it)>2) return 1;\n\t\t\t}\n\t\t}\n\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(*it!=fa&&dis+1<dep[*it]){\n\t\t\t\tif(dfs_free(*it,x,dis+1)) return 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid dfs_xdis(const int x,const int fa,const int dis){\n\t\tapx(xdis,dep[x]);\n\t\tfor(std::vector <int> ::iterator it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(*it==fa) continue;\n\t\t\tif(dis+1==dep[*it]) apx(xdis,dis+1);\n\t\t\tif(dis+1<dep[*it]){\n\t\t\t\tdfs_xdis(*it,x,dis+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tn=nxi();\n\tG::st_f=nxi(),G::st_s=nxi();\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vf[x].push_back(y);\n\t\tG::vf[y].push_back(x);\n\t}\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vs[x].push_back(y);\n\t\tG::vs[y].push_back(x);\n\t}\n\tG::dfs_sz(G::st_s);\n\tG::dfs_top(G::st_s);\n\tif(G::dfs_free(G::st_f,0,0)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tG::dfs_xdis(G::st_f,0,0);\n\tprintf(\"%d\\n\",G::xdis<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nvector<int> v[2][200005];\nint p[20][200005];\nint dis[200005];\nvoid dfs(int x,int f, vector<int> *v){\n    dis[ x ] = dis[ f ] + 1;\n    p[ 0 ][ x ] = f;\n    for(auto it : v[x]){\n        if(it != f){\n            dfs(it, x, v);\n        }\n    }\n}\nvoid build(int n){\n    for(int i = 1 ; i < 20 ; i++){\n        for(int j = 1 ; j <= n ; j++){\n            p[ i ][ j ] = p[ i - 1 ][ p[ i - 1 ][ j ] ];\n        }\n    }\n}\nint lca(int x, int y){\n    if (dis[ x ] > dis[ y ])swap(x, y);\n    int d = dis[ y ] - dis[ x ];\n    for(int i = 0 ; i < 20 ; i++ ){\n        if( d & (1 << i) ){\n            y = p[ i ][ y ];\n        }\n    }\n    if (x == y)\n        return x;\n    for(int i = 19 ; i >= 0 ; i-- ){\n        if( p[ i ][ x ] != p[ i ][ y ] ){\n            x = p[ i ][ x ];\n            y = p[ i ][ y ];\n        }\n    } \n    return p[ 0 ][ x ];\n}\nint getdis(int x, int y){\n    return dis[ x ] + dis[ y ] - dis[ lca(x, y) ];\n}\nint ans;\nvoid dfs2(int x,int f,vector<int> *v,int sum=0){\n    if(dis[x]==sum){\n        ans=max(ans,dis[x]*2);\n    }\n    if(dis[x]<=sum)return;\n    ans=max(ans,dis[x]*2);\n    for(auto it:v[x]){\n        if( it != f){\n            if(getdis(x,it)>=3&&dis[x] > sum){\n              //  printf(\"%d %d %d %d %d\\n\",x,it,dis[x],sum,getdis(x,it));\n                printf(\"-1\\n\");\n                exit(0);\n            }\n            dfs2(it, x, v, sum+1);\n        }\n    }\n}\nint main(){\n    int n, x, y;\n    scanf(\"%d %d %d\", &n, &x, &y);\n    for(int i = 0 ; i < 2 ; i++ ){\n        for(int j = 1 ; j < n ; j++ ){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            v[i][x].pb(y);\n            v[i][y].pb(x);\n        }\n    }\n    dis[0]=-1;\n    dfs(y, 0, v[1]);\n    build(n);\n    dfs2(x, 0, v[0]);\n    printf(\"%d\\n\",ans);\n}\n/*\n\nb[i]*K!/(i)!*(K-i)!\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=200005;\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nint n,fx,fy,dep[MAXN],fa[25][MAXN],bin[25];\nvector<int> nxt[MAXN];\nvoid dfs(int x)\n{\n\tfor(int i=1;bin[i]<=dep[x];i++)fa[i][x]=fa[i-1][fa[i-1][x]];\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y!=fa[0][x])dep[y]=dep[x]+1,fa[0][y]=x,dfs(y);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=18;i>=0;i--)if(bin[i]<=dep[x]&&dep[fa[i][x]]>=dep[y])x=fa[i][x];\n\tif(x==y)return x;\n\tfor(int i=18;i>=0;i--)if(bin[i]<=dep[x]&&fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\nint getdis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\nint mx;\nnamespace S\n{\n\tqueue<pii> li;\n\tint di[MAXN],fa[MAXN];\n\tvector<int> num[MAXN];\n\tvoid init(int x)\n\t{\n\t\tnum[di[x]].push_back(x);\n\t\tfor(int k=0;k<nxt[x].size();k++)\n\t\t{\n\t\t\tint y=nxt[x][k];\n\t\t\tif(y!=fa[x])di[y]=di[x]+1,fa[y]=x,init(y);\n\t\t}\n\t}\n\tbool vis[MAXN];\n\tvoid main()\n\t{\n\t\tinit(fx);vis[0]=1;\n\t\tfor(int i=0;i<=n;i++)for(int j=0;j<num[i].size();j++)\n\t\t{\n\t\t\tbool tf=false;int x=num[i][j];vis[x]=vis[fa[x]]&(i<=dep[x]);\n\t\t\tif(vis[x])\n\t\t\t{\n\t\t\t\tfor(int k=0;k<nxt[x].size();k++)if(getdis(x,nxt[x][k])>2){tf=true;break;}\n\t\t\t\tif(tf&&i<dep[x]){puts(\"-1\");exit(0);}\n\t\t\t\tif(i<=dep[x])mx=max(mx,dep[x]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tbin[0]=1;for(int i=1;i<=20;i++)bin[i]=bin[i-1]<<1;\n\tn=read();fx=read();fy=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tnxt[x].push_back(y);nxt[y].push_back(x);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);ins(y,x);\n\t}dfs(fy);\n\tS::main();\n\tpr2(2*mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nconst int N = (int)2e5 + 9;\nvector<int> B[N];\nvector<int> R[N];\nbool black[N];\nint par[N];\nint lay[N];\n\nvoid dfs1(int u, int pp){ \n  par[u] = pp;\n  for(auto x : B[u]){\n    if(x == pp) continue;\n    lay[x] = lay[u] + 1;\n    dfs1(x,u);\n  }\n}\n\nint dis[N];\n\nvoid dfs2(int u, int pp){\n  if(dis[u] >= lay[u]){\n    dis[u] = (int)1e9;\n  }\n  for(auto x : R[u]){\n    if(x == pp) continue;\n    dis[x] = dis[u] + 1;\n    dfs2(x,u);\n  }\n}\n\nint main(){\n  fastIO;\n  int n, x, y;\n  cin >> n >> x >> y;\n  int u, v;\n  for(int i = 1 ; i < n; i ++ ){\n    cin >> u >> v;\n    R[u].push_back(v);\n    R[v].push_back(u);\n  }\n  for(int i = 1; i < n; i ++ ){\n    cin >> u >> v;\n    B[u].push_back(v);\n    B[v].push_back(u);\n  }\n  dfs1(y,0);\n  dfs2(x,0);\n  bool check;\n  for(int i = 1; i <= n; i ++ ){\n    for(auto j : R[i]){\n      check = true;\n      if(par[j] == i || par[par[j]] == i || par[i] == j || par[par[i]] == j || par[i] == par[j]) check = false;\n      if(check){\n        black[i] = true;\n        black[j] = true;\n      }\n    }\n  }\n  for(int i = 1; i <= n; i ++ ){\n    if(black[i] && dis[i] < (int)1e9){\n      cout << \"-1\\n\";\n      return 0;\n    }\n  }\n  int res = 2;\n  for(int i = 1; i <= n; i ++ ){\n    if(dis[i] >= (int)1e9) continue;\n    res = max(res, lay[i] * 2);\n  }\n  cout << res << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAX_V = 201000;\nclass LCA {\npublic : \nint parent[20][MAX_V];\nvector<int>graph[MAX_V];\nint depth[MAX_V];\nint root;//これを決定しないといけない事に注意。\n\nvoid add_LCA(int u,int v) {\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n\n\nvoid dfsLCA(int v,int p,int d) {\n\tparent[0][v] = p;\n\tdepth[v]=d;\n\tfor(int i=0; i<graph[v].size(); i++) {\n\t\tif(graph[v][i]!=p) dfsLCA(graph[v][i],v,d+1) ;\n\t}\n\t\n}\n\nvoid initLCA(int V) {\n\tdfsLCA(root,-1,0);\n\t\n\tfor(int k=0; k+1<20; k++) {\n\t\tfor(int v=0; v<V; v++) {\n\t\t\tif(parent[k][v]<0) parent[k+1][v]=-1;\n\t\t\telse parent[k+1][v] = parent[k][parent[k][v]];\n\t\t}\n\t}\n\t\n}\n\nint solveLCA(int u,int v) {\n\tint ans = 0;\n\tif(depth[u]>depth[v]) swap(u,v) ;\n\tfor(int k=0; k<20; k++) {\n\t\tif((depth[v]-depth[u])>>k&1) {\n\t\t\tv = parent[k][v];\n\t\t\tans += (1<<k);\n\t\t}\n\t}\n\tif(u==v) {\n\t\treturn ans;\n\t//\treturn u;\n\t}\n\tfor(int k=20-1; k>=0; k--) {\n\t\tif(parent[k][u]!=parent[k][v]) {\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t\tans += (1<<k) * 2;\n\t\t}\n\t}\n\treturn ans + 2;\n//\treturn parent[0][u];\n}\n\n};\n\n\tLCA lca;\nconst int MAXN = 201000;\nvector<int> black[MAXN];\nvector<int> white[MAXN];\nint main() {\n\tint N, X, Y;\n\tcin >> N >> X >> Y;\n\t\n\tX--;Y--;\n\tfor(int i=0; i<N-1; i++) {\n\t\tint p,q;\n\t\tcin >> p >> q;\n\t\tp--;q--;\n\t\tblack[p].push_back(q);\n\t\tblack[q].push_back(p);\n\t}\n\t\n\tfor(int i=0; i<N-1; i++) {\n\t\tint p,q;\n\t\tcin >> p >> q;\n\t\tp--;q--;\n\t\twhite[p].push_back(q);\n\t\twhite[q].push_back(p);\n\t\tlca.add_LCA(p, q);\n\t}\n\tlca.root = 0;\n\tlca.initLCA(N);\n\t\n\tvector<int> used(N, 0);\n\tvector<int> pos(N, -1);\n\tvector<int> dist(N, 0);\n\tused[X] = true;\n\t\n\tstack<int> sta;\n\tsta.push(X);\n\tpos[X] = Y;\n\tdist[X] = lca.solveLCA(X, Y);\n\t\n\tint ans = 0;\n\tans = dist[X];\n\t\n\tbool good = false;\n\twhile(!sta.empty()) {\n\t\tint cur = sta.top(); sta.pop();\n\t\tfor(int i=0; i<black[cur].size(); i++) {\n\t\t\tint u = black[cur][i];\n\t\t\tif(used[u]) continue;\n\t\t\tif(pos[cur] == u) continue;\n\t\t\t\n\t\t\tused[u] = true;\n\t\t\tint prevWhite = pos[cur];\n\t\t\tint nextWhite = -1;\n\t\t\tint minim = N;\n\t\t\tfor(int j=0; j<white[prevWhite].size(); j++) {\n\t\t\t\tint tmpWhite = white[prevWhite][j];\n\t\t\t\tint diff = lca.solveLCA(tmpWhite, u);\n\t\t\t\tif(diff < minim) {\n\t\t\t\t\tminim = diff;\n\t\t\t\t\tnextWhite = tmpWhite;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tpos[u] = nextWhite;\n\t\t\tdist[u] = minim;\n\t\t\t//cout << u << \" \" << dist[u] << endl;\n\t\t\t//if(dist[u] >= dist[cur])\n//\t\t\tcout << u << pos[cur] << endl;\n\t\t\tif(lca.solveLCA(cur, u) >= 3)\n\t\t\t\tgood = true;\n\t\t\t\n//\t\t\tcout << u << \" \" << Y << \" \" << lca.solveLCA(u,Y) << endl;\n\t\t\tif(dist[u] > 0) {\n\t\t\t\tsta.push(u);\n\t\t\t\tans = max(ans, lca.solveLCA(u, Y));\n\t\t\t}\n\t\t\tif(dist[u]==0)\n\t\t\t\tans = max(ans, lca.solveLCA(u, Y));\n\t\t}\n\t}\n\tif(good) {\n\t\tcout << \"-1\" << endl;\n\t}\n\telse {\n\t\tcout << ans * 2 << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N, X, Y;\nvector<int> adj1[MN], adj2[MN];\nint par[20][MN], dep[MN], tin[MN], tout[MN], timer;\n\nvoid dfs0(int u, int p) {\n    tin[u] = timer++;\n\n    par[0][u] = p;\n    for(int i = 1; i < 20; i++) {\n        int t = par[i - 1][u];\n        if(t == -1) break;\n        par[i][u] = par[i - 1][t];\n    }\n\n    for(int i = 0; i < adj2[u].size(); i++) {\n        int v = adj2[u][i];\n        if(v == p) continue;\n        dep[v] = dep[u] + 1;\n        dfs0(v, u);\n    }\n\n    tout[u] = timer;\n}\n\nint lca(int a, int b) {\n    if(dep[a] < dep[b]) swap(a, b);\n    int diff = dep[a] - dep[b];\n    for(int i = 0; i < 20; i++) {\n        if(diff & (1 << i)) a = par[i][a];\n    }\n    if(a == b) return a;\n    for(int i = 20; i--;) {\n        if(par[i][a] != par[i][b]) {\n            a = par[i][a];\n            b = par[i][b];\n        }\n    }\n    return par[0][a];\n}\n\nint dist(int u, int v) {\n    return dep[u] + dep[v] - 2 * dep[ lca(u, v) ];\n}\n\nint ans;\nvoid dfs1(int u, int p) {\n    ans = max(ans, dep[u]);\n    for(int i = 0; i < adj1[u].size(); i++) {\n        int v = adj1[u][i];\n        if(v == p) continue;\n        if(dist(v, u) >= 3) {\n            printf(\"-1\");\n            exit(0);\n        }\n        if(dep[v] - dep[Y] < 2 && tin[Y] <= tin[v] && tin[v] < tout[Y]) continue;\n        dfs1(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    X--; Y--;\n\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj1[a].push_back(b);\n        adj1[b].push_back(a);\n    }\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj2[a].push_back(b);\n        adj2[b].push_back(a);\n    }\n\n    dfs0(Y, -1);\n\n    while(dep[X] - dep[Y] > 2) {\n        int mn = 1e9, p = -1;\n        for(int i = 0; i < adj1[X].size(); i++) {\n            int v = adj1[X][i];\n\n            if(dist(X, v) >= 3) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            if(mn > dep[v]) {\n                mn = dep[v];\n                p = v;\n            }\n        }\n        if(mn >= dep[X]) break;\n        X = p;\n\n        for(int i = 0; i < adj2[Y].size(); i++) {\n            int v = adj2[Y][i];\n            if(tin[v] <= tin[X] && tin[X] < tout[v]) {\n                Y = v;\n                break;\n            }\n        }\n    }\n\n    dfs1(X, -1);\n\n    printf(\"%d\", 2 * ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 200005;\nvector<int> A[MAXN], B[MAXN];\nint da[MAXN], db[MAXN], par[MAXN], lab[MAXN], n, X, Y, ans;\n\nvoid dfs1(int u, int fa) {\n\tfor (int v : A[u]) if (v != fa) {\n\t\tda[v] = da[u] + 1;\n\t\tdfs1(v, u);\n\t}\n}\n\nvoid dfs2(int u, int fa) {\n\tpar[u] = fa;\n\tfor (int v : B[u]) if (v != fa) {\n\t\tdb[v] = db[u] + 1;\n\t\tdfs2(v, u);\n\t}\n}\n\nvoid dfs3(int u, int fa) {\n\tif (da[u] > db[u]) return;\n\tchkmax(ans, db[u]);\n\tif (da[u] == db[u]) return;\n\tif (lab[u]) { puts(\"-1\"); exit(0); }\n\tfor (int v : A[u]) if (v != fa) dfs3(v, u);\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &X, &Y);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tA[u].push_back(v), A[v].push_back(u);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tB[u].push_back(v), B[v].push_back(u);\n\t}\n\tdfs1(X, 0);\n\tdfs2(Y, 0);\n\tfor (int u = 1; u <= n; u++)\n\tfor (int v : A[u]) if (da[v] > da[u]) {\n\t\tint a = u, b = v;\n\t\tif (db[a] == db[b]) {\n\t\t\tif (par[a] != par[b]) lab[a] = lab[b] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (db[a] > db[b]) swap(a, b);\n\t\tif (par[b] != a && par[par[b]] != a) lab[a] = lab[b] = 1;\n\t}\n\tdfs3(X, 0);\n\tprintf(\"%d\\n\", ans * 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <bits/stdc++.h>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=200000+10;\n\nstruct Tree {\n    struct edge { int v,nxt; } e[N<<1];\n    int head[N];\n    inline void addEdge(int u,int v) {\n        static int cnt=0;\n        e[++cnt]=(edge){v,head[u]},head[u]=cnt;\n    }\n\n    int dep[N],sz[N],fa[N],hson[N],top[N];\n    inline void dfs1(int u,int f) {\n        dep[u]=dep[fa[u]=f]+1,sz[u]=1;\n        for (re int i=head[u];i;i=e[i].nxt) {\n            int v=e[i].v; if (v==f) continue;\n            dfs1(v,u),sz[u]+=sz[v];\n            if (sz[v]>sz[hson[u]]) hson[u]=v;\n        }\n    }\n    inline void dfs2(int u,int anc) {\n        top[u]=anc;\n        if (hson[u]) dfs2(hson[u],anc);\n        for (re int i=head[u];i;i=e[i].nxt)\n            if (e[i].v!=fa[u]&&e[i].v!=hson[u]) dfs2(e[i].v,e[i].v);\n    }\n    \n    inline int getlca(int u,int v) {\n        while (top[u]!=top[v]) {\n            if (dep[top[u]]<dep[top[v]]) swap(u,v);\n            u=fa[top[u]];\n        }\n        return dep[u]<dep[v]?u:v;\n    }\n    inline int getdis(int u,int v) {\n        int t=getlca(u,v);\n        return dep[u]+dep[v]-(dep[t]<<1);\n    }\n} A,B;\n\nint n,x,y,vis[N];\n\ninline void bfs() {\n    queue<int> Q; vis[x]=1,Q.push(x);\n    while (!Q.empty()) {\n        int u=Q.front(); Q.pop();\n        for (re int i=A.head[u];i;i=A.e[i].nxt) {\n            int v=A.e[i].v; if (vis[v]) continue;\n            if (A.dep[v]<B.dep[v]) vis[v]=1,Q.push(v);\n        }\n    }\n}\n\nint main() {\n    n=read(),x=read(),y=read();\n    for (re int i=1;i<n;++i) {\n        int u=read(),v=read();\n        A.addEdge(u,v),A.addEdge(v,u);\n    }\n    for (re int i=1;i<n;++i) {\n        int u=read(),v=read();\n        B.addEdge(u,v),B.addEdge(v,u);\n    }\n    A.dfs1(x,0),A.dfs2(x,x); B.dfs1(y,0),B.dfs2(y,y);\n    bfs(); int ans=0;\n    for (re int u=1;u<=n;++u) {\n        if (!vis[u]) continue;\n        for (re int i=A.head[u];i;i=A.e[i].nxt) {\n            int v=A.e[i].v;\n            if (B.getdis(u,v)>2) { puts(\"-1\"); return 0; }\n        }\n        ans=max(ans,B.dep[u]-1);\n    }\n    printf(\"%d\\n\",ans<<1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int inf = (int) 1e9;\nconst int N = 1234567;\n \nint save_x[N], save_y[N];\n \nvector <int> g[N], g_blue[N];\nint d[N], d_blue[N];\nint pr[N], pr_blue[N];\n \nvoid dfs(int v, int pv) {\n  if (d[v] >= d_blue[v]) {\n    return;\n  }\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j];\n    if (u == pv) {\n      continue;\n    }\n    pr[u] = v;\n    d[u] = d[v] + 1;\n    dfs(u, v);\n  }\n}\n \nint n;\n \nvoid get_d(int start) {\n  for (int i = 0; i < n; i++) {\n    d[i] = inf;\n    pr[i] = -1;\n  }\n  d[start] = 0;\n  pr[start] = start;\n  dfs(start, -1);\n}\n \nint main() {\n  int x, y;\n  scanf(\"%d %d %d\", &n, &x, &y);\n  x--; y--;\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d %d\", save_x + i, save_y + i);\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar;\n    scanf(\"%d %d\", &foo, &bar);\n    foo--; bar--;\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  for (int i = 0; i < n; i++) {\n    d_blue[i] = inf;\n  }\n  get_d(y);\n  for (int i = 0; i < n; i++) {\n    d_blue[i] = d[i];\n    g_blue[i] = g[i];\n    pr_blue[i] = pr[i];\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar;\n    foo = save_x[i];\n    bar = save_y[i];\n    foo--; bar--;\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  get_d(x);\n  int mx = 0;\n  for (int i = 0; i < n; i++) {\n    if (d[i] < d_blue[i]) {\n      mx = max(mx, 2 * d_blue[i]);\n      for (int j = 0; j < (int) g[i].size(); j++) {\n        int to = g[i][j];\n        if (pr_blue[to] == i || pr_blue[i] == to || pr_blue[pr_blue[to]] == i || pr_blue[pr_blue[i]] == to || pr_blue[i] == pr_blue[to]) {\n          continue;\n        }\n        cout << -1 << endl;\n        return 0;\n      }\n    }\n  }\n  cout << mx << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X,Y;\nvector<int> E[202020],E2[202020];\n\nint P[21][200005],D[200005],D2[200005];\n\nvoid dfs(int cur) {\n\tITR(it,E[cur]) if(*it!=P[0][cur]) D[*it]=D[cur]+1, P[0][*it]=cur, dfs(*it);\n}\nint dist(int a,int b) {\n\tint ret=0,i,aa=a,bb=b;\n\tif(D[aa]>D[bb]) swap(aa,bb);\n\tfor(i=19;i>=0;i--) if(D[bb]-D[aa]>=1<<i) bb=P[i][bb];\n\tfor(i=19;i>=0;i--) if(P[i][aa]!=P[i][bb]) aa=P[i][aa], bb=P[i][bb];\n\treturn D[a]+D[b]-2*D[(aa==bb)?aa:P[0][aa]];  // dist\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>X>>Y;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE2[x].push_back(y);\n\t\tE2[y].push_back(x);\n\t}\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\t\n\tdfs(Y);\n\tFOR(i,19) FOR(x,N) P[i+1][x+1]=P[i][P[i][x+1]];\n\tFOR(i,N) D2[i+1]=10101010;\n\t\n\tint ret=0;\n\tqueue<int> Q;\n\tD2[X]=0;\n\tQ.push(X);\n\twhile(Q.size()) {\n\t\tx = Q.front();\n\t\tQ.pop();\n\t\tif(D2[x]>D[x]) continue;\n\t\tret=max(ret,D[x]);\n\t\tFORR(e,E2[x]) {\n\t\t\tif(dist(x,e)>=3) return _P(\"-1\\n\");\n\t\t\tif(D2[e]>D2[x]+1) D2[e]=D2[x]+1, Q.push(e);\n\t\t}\n\t}\n\t\n\tcout<<ret*2<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst int N = (int)2e5 + 123, LOG = 20;\n\n\nvector< int > g1[N], g2[N];\nvector< pii > ch[N];\nint n, x, y, dp[N], tin[N], tout[N], timer, up[LOG][N], depth[N];\n\nvoid no(){\n\tprintf(\"-1\");\n\texit(0);\n}\nvoid dfs1(int v, int pr){\n\ttin[v] = ++timer;\n\tdepth[v] = depth[pr] + 1;\n\tup[0][v] = pr;    \n\tfor(int i = 1; i < LOG; i++)\n\t\tup[i][v] = up[i - 1][ up[i - 1][v] ];\n\tfor(auto to : g2[v])\n\t\tif(to != pr){\n\t\t\tdfs1(to, v);\t\n\t\t\tch[v].pb({tout[to], to});\n\t\t}\n\ttout[v] = timer;\n}\nbool upper(int v, int u){\n\treturn tin[v] <= tin[u] && tin[u] <= tout[v];\n}\nint lca(int v, int u){\n\tif(upper(v, u))\n\t\treturn v;\n\tif(upper(u, v))\n\t\treturn u;\n\tfor(int i = LOG - 1; i >= 0; i--)\n\t\tif(!upper(up[i][v], u))\n\t\t\tv = up[i][v];\n\treturn up[0][v];\n}\nint dist(int v, int u){\n\treturn depth[v] + depth[u] - 2 * depth[lca(v, u)];\n}\nvoid dfs2(int v, int u, int pr){\n\tdp[v] = dist(v, u);\n\tif(v == u)\n\t\treturn;\n\tfor(auto to : g1[v]){\n\t\tif(to != pr && to != u){\n\t\t\tint w;\n\t\t\tif(upper(u, to))                                                                         \n\t\t\t\tw = lower_bound(ch[u].begin(), ch[u].end(), mp(tin[to], 0)) -> s;\n\t\t\telse\n\t\t\t\tw = up[0][u];\n\t\t\tif(dist(v, to) > 2)\n\t\t\t\tno();\n\t\t\tdfs2(to, w, v);\n        \tdp[v] = max(dp[v], dp[to] + 1);\n        }\n\t}\n}\nint main()\n{                         \n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tfor(int i = 1; i < n; i++){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tg1[v].pb(u);\n\t\tg1[u].pb(v);\n\t}\n    for(int i = 1; i < n; i++){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tg2[v].pb(u);\n\t\tg2[u].pb(v);\n\t}\n\tdfs1(1, 1);\n\tdfs2(x, y, x);\n\tprintf(\"%d\", dp[x] * 2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int lg = 20;\nvector<int> red[N];\nvector<int> blue[N];\nint h[N];\nint par[lg + 5][N];\nint n, x, y;\nbool winPos[N];\nint disR[N];\nint disB[N];\n\n\nvoid dfs(int v = 0, int p = -1)\n{\n    for (int u : blue[v])\n    {\n        if (u != p)\n        {\n            par[0][u] = v;\n            h[u] = h[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nvoid pre()\n{\n    for (int k = 1; k < lg; k++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            par[k][i] = par[k - 1][ par[k - 1][i] ];\n        }\n    }\n}\n\nint lca(int v, int u)\n{\n    if(h[v] > h[u])\n    {\n        swap(v, u);\n    }\n    for (int i = 0; i < lg; i++)\n    {\n        if (h[u] - h[v] >> i & 1)\n        {\n            u = par[i][u];\n        }\n    }\n    for (int i = lg - 1; i >= 0; i--)\n    {\n        if(par[i][v] != par[i][u])\n        {\n            v = par[i][v], u = par[i][u];\n        }\n    }\n    return v == u ? v : par[0][v];\n}\n\nvoid dfs1(int v, int par = -1)\n{\n    if (disR[v] >= disB[v])\n    {\n        return;\n    }\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disR[u] = disR[v] + 1;\n            dfs1(u, v);\n        }\n    }\n}\n\nvoid dfs2(int v, int par = -1)\n{\n    for (auto u: blue[v])\n    {\n        if (u != par)\n        {\n            disB[u] = disB[v] + 1;\n            dfs2(u, v);\n        }\n    }\n}\n\n\n\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        red[u - 1].push_back(v - 1);\n        red[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        blue[u - 1].push_back(v - 1);\n        blue[v - 1].push_back(u - 1);\n    }\n    dfs();\n    pre();\n    for (int i = 0; i < n; i++)\n    {\n        for (auto u: red[i])\n        {\n            int tmp = lca(u, i);\n            if (h[u] - h[tmp] + h[i] - h[tmp] > 2)\n            {\n                winPos[i] = true;\n                winPos[u] = true;\n            }\n        }\n    }\n    memset(disR, 127, sizeof disR);\n    disR[x - 1] = 0;\n    dfs2(y - 1);\n    dfs1(x - 1);\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (winPos[i] && disR[i] <= disB[i])\n        {\n            assert(1 != 1);\n            cout << -1 << endl;\n            exit(0);\n        }\n        if (disR[i] < N)\n        {\n            //cout << endl;\n            //cout << i << \" \" << disB[i] << endl;\n            ans = max(ans, disB[i] * 2);\n        }\n    }\n    //cout << (1 << 20) << endl;\n    cout << ans << endl;\n\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 200005;\nstruct Edge{\n\tint to,next;\n}e[MAXN<<1];\nbool safe[MAXN];\nint dep[MAXN],n,x,y,cnt,head[MAXN];\ninline void insert(int u,int v)\n{\n\te[++cnt].to=v,e[cnt].next=head[u],head[u]=cnt;\n\te[++cnt].to=u,e[cnt].next=head[v],head[v]=cnt;\n}\nint u[MAXN],v[MAXN],pos[MAXN],out[MAXN],sz,fa[MAXN];\nvoid dfs(int x)\n{\n\tpos[x]=++sz;\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[x])continue;\n\t\tdep[v]=dep[x]+1;\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t}\n\tout[x]=sz;\n}\ninline bool judge(int x,int y)\n{\n\tif(pos[x]>pos[y])swap(x,y);\n\tif(pos[y]>=pos[x] && pos[y]<=out[x])return dep[y]-dep[x]>2;\n\treturn fa[x]!=fa[y];\n}\nnamespace Sigma{\n\tstruct Edge{\n\t\tint to,next;\n\t}e[MAXN<<1];\n\tint head[MAXN],cnt,ans;\n\tinline void insert(int u,int v)\n\t{\n\t\te[++cnt].to=v,e[cnt].next=head[u],head[u]=cnt;\n\t\te[++cnt].to=u,e[cnt].next=head[v],head[v]=cnt;\n\t}\n\tint getans(int x,int fa,int step)\n\t{\n\t\tif(safe[x])return -1;\n\t\tint ret=dep[x];\n\t\tfor(int i=head[x];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa)continue;\n\t\t\tif(dep[x]==1 && dep[v]<=1)continue;\n\t\t\tif(step+1>=dep[v])continue;\n\t\t\tint val=getans(v,x,step+1);\n\t\t\tif(v==-1)return -1;\n\t\t\telse ret=max(ret,val);\n\t\t}\n\t\treturn ret;\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",u+i,v+i);\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tinsert(u,v);\n\t}\n\tdfs(y);\n\tfor(int i=1;i<n;++i){\n\t\tif(judge(u[i],v[i]))safe[u[i]]=safe[v[i]]=1;\n\t\telse Sigma::insert(u[i],v[i]);\n\t}\n\tint ans=Sigma::getans(x,0,0);\n\tcout<<(ans==-1?-1:ans*2)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nstruct HeavyLightDecomposition{\n  int root;\n  // tree representation\n  int N;              // size\n  vi parent;          // parent[p] := parent of node p\n  vi depth;           // depth[p] := depth of node p\n  vi subtreesize;     // subtreesize[p] := size of subtree rooted at node p\n\n  // heavy light decomposition\n  vector<vi> paths;   // paths[i] := heavy edge path (id=i)\n  vi belongs;         // belongs[p] := id of path that node p belongs to\n  vi pathpos;         // pathpos[p] := index of node p in paths[belongs[p]] (paths[belongs[p]][pathpos[p]] == p) (for segment tree)\n  vi heavyedge;       // heavyedge[p] := edge (p,heavyedge[p]) is heavy edge\n\n  // tree construct dfs\n  int treedfs(int p,int d,int bef,vi g[]){\n    parent[p] = bef;\n    depth[p] = d;\n    subtreesize[p] = 1;\n    int maxchild = -1;\n    REP(i,g[p].size()){\n      int to = g[p][i];\n      if(to==bef)continue;\n      subtreesize[p] += treedfs(to,d+1,p,g);\n      if(maxchild == -1 || subtreesize[maxchild] < subtreesize[to]){\n        maxchild = to;\n      }\n    }\n    if(maxchild != -1 && subtreesize[maxchild]*2 >= subtreesize[p]){\n      heavyedge[p] = maxchild;\n    }\n    return subtreesize[p];\n  }\n\n  // heavy light decomposition dfs\n  void decompositiondfs(int pathid,int head,int bef,vi g[]){\n    paths.push_back(vi());\n    int cur = head;\n    while(true){\n      belongs[cur] = pathid;\n      pathpos[cur] = paths[pathid].size();\n      paths[pathid].push_back(cur);\n      int nxt = heavyedge[cur];\n      REP(i,g[cur].size()){\n        int to = g[cur][i];\n        if(to==bef)continue;\n        if(to==nxt)continue;\n        decompositiondfs(paths.size(),to,cur,g);\n      }\n      if(nxt==-1)break;\n      bef = cur;\n      cur = nxt;\n    }\n  }\n\n  HeavyLightDecomposition(int n,vi g[],int _root){\n    N = n;\n    root = _root;\n    parent.assign(n,-1);\n    depth.assign(n,-1);\n    subtreesize.assign(n,-1);\n    belongs.assign(n,-1);\n    pathpos.assign(n,-1);\n    heavyedge.assign(n,-1);\n    \n    treedfs(root,0,-1,g);\n    decompositiondfs(0,root,-1,g);\n  }\n\n  int lca(int a,int b){\n    int ato = paths[belongs[a]][0];\n    int bto = paths[belongs[b]][0];\n    while(belongs[a]!=belongs[b]){\n      if(depth[ato] > depth[bto]){\n        a = ato;\n        if(a!=root){\n          a = parent[a];\n          ato = paths[belongs[a]][0];\n        }\n      }else{\n        b = bto;\n        if(b!=root){\n          b = parent[b];\n          bto = paths[belongs[b]][0];\n        }\n      }\n    }\n    if(depth[a]<=depth[b]){\n      return a;\n    }else{\n      return b;\n    }\n  }\n\n  int length(int a,int b){\n    return depth[a]+depth[b]-2*depth[lca(a,b)];\n  }\n};\n\nint n,x,y;\nvi red[252521];\nvi blue[252521];\nbool win[252521];\nint reddepth[252521];\n// sigma is red in x\n// sugim is blue in y\n// sugim chases sigma\n// sigma first\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  --x;--y;\n  REP(i,n-1){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    red[a].push_back(b);\n    red[b].push_back(a);\n  }\n  REP(i,n-1){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    blue[a].push_back(b);\n    blue[b].push_back(a);\n  }\n  // search win point\n  HeavyLightDecomposition hld(n,blue,y);\n  REP(i,n){\n    REP(j,red[i].size()){\n      int to = red[i][j];\n      // avoid duplication\n      if(i<to){\n        if(hld.length(i,to)>=3){\n          win[i] = true;\n          win[to] = true;\n        }\n      }\n    }\n  }\n  // flee\n  REP(i,n)reddepth[i] = 252521;\n  reddepth[x] = 0;\n  stack<int> S;\n  S.push(x);\n  while(!S.empty()){\n    int p = S.top();S.pop();\n    int d = reddepth[p]+1;\n    REP(i,red[p].size()){\n      int to = red[p][i];\n      if(reddepth[to] < d)continue;\n      if(hld.depth[to] <= d)continue;\n      reddepth[to] = d;\n      S.push(to);\n    }\n  }\n  // check\n  int ans = -1;\n  REP(i,n){\n    if(reddepth[i]!=252521){\n      if(win[i]){\n        ans = -2;\n        break;\n      }else{\n        CHMAX(ans,hld.depth[i]);\n      }\n    }\n  }\n  if(ans==-2){\n    puts(\"-1\");\n  }else{\n    printf(\"%d\\n\",ans*2);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+10;\nint n,x,y,ans,vis[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nstruct Heavy_Light_Decomposition{\n    struct edge{int to,nxt;}e[maxn<<1];int tot,head[maxn];\n    int idx,fa[maxn],dfn[maxn],dep[maxn],son[maxn],top[maxn],size[maxn];\n    void add(int u,int v){e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;}\n    void insert(int u,int v){add(u,v);add(v,u);}\n    void build(int x){\n        dep[x]=dep[fa[x]]+1;size[x]=1;int mx=0;\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to){\n            if(v==fa[x])continue;\n            fa[v]=x;build(v);size[x]+=size[v];\n            if(size[v]>mx)mx=size[v],son[x]=v;\n        }\n    }\n    void dfs(int x){\n        if(!x)return ;dfn[x]=++idx;\n        top[x]=son[fa[x]]==x?top[fa[x]]:x;\n        dfs(son[x]);\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)\n            if(v!=fa[x]&&v!=son[x])dfs(v);\n    }\n    int query(int u,int v){\n        while(top[u]!=top[v]){\n            if(dep[top[u]]<dep[top[v]])swap(u,v);\n            u=fa[top[u]];\n        }if(dep[u]>dep[v])swap(u,v);\n        return u;\n    }\n    int get_dis(int u,int v){return dep[u]+dep[v]-2*dep[query(u,v)];}\n}HLD[2];\nvoid init(int S){\n    queue<int >q;\n    q.push(S);vis[S]=1;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(!vis[v]&&HLD[0].dep[v]<HLD[1].dep[v])vis[v]=1,q.push(v);\n    }\n}\nvoid solve(){\n    for(int x=1;x<=n;x++){\n        if(!vis[x])continue;\n        ans=max(ans,HLD[1].dep[x]-1);\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(HLD[1].get_dis(v,x)>2){puts(\"-1\");return ;}\n    }write(ans<<1);\n}\nint main(){\n    n=read();x=read();y=read();\n    if(x==y){puts(\"0\");return 0;}\n    for(int i=1;i<n;i++)HLD[0].insert(read(),read());\n    for(int i=1;i<n;i++)HLD[1].insert(read(),read());\n    HLD[0].build(x);HLD[0].dfs(x);HLD[1].build(y);HLD[1].dfs(y);\n    init(x);solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200009\n#define M 800009\nusing namespace std;\n\nint n,rt,sta,tot,pnt[M],nxt[M]; bool bo[N];\nint h[N],fa[N],dep[N],sz[N],son[N],anc[N],d[N];\nstruct graph{\n\tint fst[N];\n\tvoid add(int x,int y){\n\t\tpnt[++tot]=y; nxt[tot]=fst[x]; fst[x]=tot;\n\t}\n}gr,gb;\nvoid dfs(int x){\n\tint i,y; sz[x]=1;\n\tfor (i=gb.fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x]){\n\t\t\tfa[y]=x; dep[y]=dep[x]+1;\n\t\t\tdfs(y); sz[x]+=sz[y];\n\t\t\tif (sz[y]>sz[son[x]]) son[x]=y;\n\t\t}\n\t}\n}\nvoid dvd(int x,int tp){\n\tint i,y; anc[x]=tp;\n\tif (son[x]) dvd(son[x],tp);\n\tfor (i=gb.fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x] && y!=son[x]) dvd(y,y);\n\t}\n}\nint lca(int x,int y){\n\tfor (; anc[x]!=anc[y]; x=fa[anc[x]])\n\t\tif (dep[anc[x]]<dep[anc[y]]) swap(x,y);\n\treturn dep[x]<dep[y]?x:y;\n}\nint dist(int x,int y){\n\treturn dep[x]+dep[y]-(dep[lca(x,y)]<<1);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&sta,&rt);\n\tint i,j,x,y;\n\tfor (i=1; i<n; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tgr.add(x,y); gr.add(y,x);\n\t}\n\tfor (i=1; i<n; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tgb.add(x,y); gb.add(y,x);\n\t}\n\tdfs(rt); dvd(rt,rt);\n\tfor (i=1; i<=n; i++)\n\t\tfor (j=gr.fst[i]; j; j=nxt[j])\n\t\t\tif (dist(i,pnt[j])>2) bo[i]=1;\n\tint head=0,tail=1,ans=0; h[1]=sta;\n\tmemset(d,-1,sizeof(d)); d[sta]=0;\n\twhile (head<tail){\n\t\tx=h[++head];\n\t\tif (bo[x]){ puts(\"-1\"); return 0; }\n\t\tans=max(ans,dep[x]<<1);\n\t\tfor (i=gr.fst[x]; i; i=nxt[i]){\n\t\t\ty=pnt[i];\n\t\t\tif (d[y]==-1 && d[x]+1<dep[y]){\n\t\t\t\td[y]=d[x]+1; h[++tail]=y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 21\nvector<int> ex[N], ey[N];\nvoid init(int n, vector<int>* e) {\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n}\nint fx[N], fy[N][M], dx[N], dy[N];\nvoid dfsy(int u) {\n    for (auto v : ey[u]) {\n        if (v == fy[u][0]) continue;\n        fy[v][0] = u, dy[v] = dy[u] + 1;\n        for (int i = 1; i < M; i++) fy[v][i] = fy[fy[v][i - 1]][i - 1];\n        dfsy(v);\n    }\n}\nint lca(int u, int v) {\n    if (dy[u] < dy[v]) swap(u, v);\n    for (int i = M - 1; ~i; i--)\n        if (dy[fy[u][i]] >= dy[v]) u = fy[u][i];\n    if (u == v) return u;\n    for (int i = M - 1; ~i; i--)\n        if (fy[u][i] != fy[v][i]) u = fy[u][i], v = fy[v][i];\n    return fy[u][0];\n}\nint ans;\nvoid dfsx(int u) {\n    if (~ans) ans = max(ans, dy[u] << 1);\n    for (auto v : ex[u]) {\n        if (v == fx[u] || dx[v] >= dy[v]) continue;\n        fx[v] = u, dx[v] = dx[u] + 1;\n        if (dy[v] + dy[u] - 2 * dy[lca(u, v)] > 2) ans = -1;\n        dfsx(v);\n    }\n}\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    init(n, ex);\n    init(n, ey);\n    dfsy(addy);\n    dfsx(addx);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAXN 200010\n\nint n,x,y,dep[MAXN],fa[MAXN],ans;\nvector<int> edger[MAXN],edgeb[MAXN];\n\nvoid dfs(int u,int father)\n{\n\tfa[u]=father;\n\tfor(auto v : edgeb[u])\n\t{\n\t\tif(v==father)continue;\n\t\tdep[v]=dep[u]+1;\n\t\tdfs(v,u);\n\t}\n}\n\nbool go(int u,int v)\n{\n\tfor(int cnt=0;u!=v && ++cnt<=2;dep[u]<dep[v]?v=fa[v]:u=fa[u]);\n\treturn u==v;\n}\n\nvoid solve(int u,int father,int dis)\n{\n\tans=max(ans,dep[u]);\n\tif(dep[u]<=dis)return;\n\tfor(auto v : edger[u])\n\t{\n\t\tif(v==father)continue;\n\t\tif(go(u,v))solve(v,u,dis+1);\n\t\telse\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedger[u].push_back(v);\n\t\tedger[v].push_back(u);\n\t}\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedgeb[u].push_back(v);\n\t\tedgeb[v].push_back(u);\n\t}\n\tdfs(y,0);\n\tsolve(x,0,0);\n\tprintf(\"%d\\n\",ans*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 200005\n#define rep(i,j,k) for(i=j;i<=k;++i)\n#define down(i,j,k) for(i=j;i>=k;--i)\nstruct E{\n\tint to,nxt;\n}ed[2][N<<1];\nint x,y,n,i,j,k,top,u,v,l,r,s,t;\nint head[2][N],dep[N],anc[N][20],q[N][2];\nvoid read(int &p){\n\tp=0; char x=getchar();\n\twhile(x<'0' || x>'9') x=getchar();\n\twhile(x>='0'&&x<='9'){p=p*10+x-'0'; x=getchar();}\n}\nvoid add(int u,int v,int wh){\n\ttop++; ed[wh][top]=(E){v,head[wh][u]}; head[wh][u]=top;\n}\nvoid dfs(int x){\n\tint i,to;\n\trep(i,1,19) anc[x][i]=anc[anc[x][i-1]][i-1];\n\tfor(i=head[1][x];i;i=ed[1][i].nxt)\n\tif((to=ed[1][i].to)!=anc[x][0]){\n\t\tanc[to][0]=x; dep[to]=dep[x]+1;\n\t\tdfs(to);\n\t}\n}\nint dis(int u,int v){\n\tint i,tmp=dep[u]+dep[v];\n\tif(dep[u]<dep[v]) swap(u,v);\n\tdown(i,19,0)\n\tif(dep[anc[u][i]]>=dep[v]) u=anc[u][i];\n\tif(u==v) return tmp-(dep[u]<<1);\n\tdown(i,19,0)\n\tif(anc[u][i]!=anc[v][i]){\n\t\tu=anc[u][i]; v=anc[v][i];\n\t}\n\treturn tmp-(dep[anc[u][0]]<<1);\n}\nint main(){\n\tread(n); read(x); read(y);\n\trep(i,1,n-1){\n\t\tread(u); read(v);\n\t\tadd(u,v,0); add(v,u,0);\n\t}\n\ttop=0;\n\trep(i,1,n-1){\n\t\tread(u); read(v);\n\t\tadd(u,v,1); add(v,u,1);\n\t}\n\tdep[y]=1; dfs(y);\n\tl=r=0; q[0][0]=x; q[0][1]=0;\n\twhile(l<=r){\n\t\tu=q[l][0]; s=q[l][1]; l++;\n\t\tfor(i=head[0][u];i;i=ed[0][i].nxt){\n\t\t\tv=ed[0][i].to;\n\t\t\tif(dis(u,v)>2) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(dep[v]-1>s+1){\n\t\t\t\tr++; q[r][0]=v; q[r][1]=s+1;\n\t\t\t}\n\t\t}\n\t\tif(dep[u]-1>s+1){\n\t\t\tr++; q[r][0]=u; q[r][1]=s+1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(q[r][1]+1)<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bis/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+10;\nint n,x,y,ans,vis[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nstruct Heavy_Light_Decomposition{\n    struct edge{int to,nxt;}e[maxn<<1];int tot,head[maxn];\n    int idx,fa[maxn],dfn[maxn],dep[maxn],son[maxn],top[maxn],size[maxn];\n    void add(int u,int v){e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;}\n    void insert(int u,int v){add(u,v);add(v,u);}\n    void build(int x){\n        dep[x]=dep[fa[x]]+1;size[x]=1;int mx=0;\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to){\n            if(v==fa[x])continue;\n            fa[v]=x;build(v);size[x]+=size[v];\n            if(size[v]>mx)mx=size[v],son[x]=v;\n        }\n    }\n    void dfs(int x){\n        if(!x)return ;dfn[x]=++idx;\n        top[x]=son[fa[x]]==x?top[fa[x]]:x;\n        dfs(son[x]);\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)\n            if(v!=fa[x]&&v!=son[x])dfs(v);\n    }\n    int query(int u,int v){\n        while(top[u]!=top[v]){\n            if(dep[top[u]]<dep[top[v]])swap(u,v);\n            u=fa[top[u]];\n        }if(dep[u]>dep[v])swap(u,v);\n        return u;\n    }\n    int get_dis(int u,int v){return dep[u]+dep[v]-2*dep[query(u,v)];}\n}HLD[2];\nvoid init(int S){\n    queue<int >q;\n    q.push(S);vis[S]=1;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(!vis[v]&&HLD[0].dep[v]<HLD[1].dep[v])vis[v]=1,q.push(v);\n    }\n}\nvoid solve(){\n    for(int x=1;x<=n;x++){\n        if(!vis[x])continue;\n        ans=max(ans,HLD[1].dep[x]-1);\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(HLD[1].get_dis(v,x)>2){puts(\"-1\");return ;}\n    }write(ans<<1);\n}\nint main(){\n    n=read();x=read();y=read();\n    if(x==y){puts(\"0\");return 0;}\n    for(int i=1;i<n;i++)HLD[0].insert(read(),read());\n    for(int i=1;i<n;i++)HLD[1].insert(read(),read());\n    HLD[0].build(x);HLD[0].dfs(x);HLD[1].build(y);HLD[1].dfs(y);\n    init(x);solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 200005;\n\nint n, x, y, ans, dep[MAXN], par[MAXN];\nvector <int> adj[MAXN], adv[MAXN];\nbool f[MAXN];\n\ninline void Dfs(int x)\n{\n\tfor (auto y : adv[x])\n\t\tif (y ^ par[x])\n\t\t\tpar[y] = x, dep[y] = dep[x] + 1, Dfs(y);\n}\n\ninline int Dis(int x, int y)\n{\n\tint ret = 0;\n\tif (dep[x] < dep[y])\n\t\tswap(x, y);\n\twhile (ret < 3 && dep[x] > dep[y])\n\t\tret ++, x = par[x];\n\twhile (ret < 3 && (x ^ y))\n\t\tret += 2, x = par[x], y = par[y];\n\treturn min(ret, 3);\n}\n\ninline void Dfs(int x, int p)\n{\n\tfor (auto y : adj[x])\n\t\tif (y ^ p)\n\t\t\tf[x] |=\tDis(x, y) == 3, f[y] |= Dis(x, y) == 3, Dfs(y, x);\n}\n\ninline void Dfs(int x, int p, int t)\n{\n\tif (dep[x] <= t)\n\t\treturn ;\n\tans = max(ans, dep[x]);\n\tif (f[x])\n\t\tputs(\"-1\"), exit(0);\n\tfor (auto y : adj[x])\n\t\tif (y ^ p)\n\t\t\tDfs(y, x, t + 1);\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), x = Read(), y = Read();\n\tfor (int i = 1, u, v; i < n; i ++)\n\t\tu = Read(), v = Read(), adj[u].pb(v), adj[v].pb(u);\n\tfor (int i = 1, u, v; i < n; i ++)\n\t\tu = Read(), v = Read(), adv[u].pb(v), adv[v].pb(u);\n\tDfs(y);\n\tDfs(x, 0);\n\tDfs(x, 0, 0);\n\treturn printf(\"%d\\n\", ans << 1), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(u!= U && !bad[pre[u]])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(ok[i] && (!bad[u1[i]] || !bad[u2[i]]) ){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define MAXN 200010\n#define INF 0x3f3f3f3f\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint Bdj[MAXN],Vb[MAXN*2],nxtb[MAXN*2],cb;\nvoid Add(int u,int v)\n{\n\tcb++;Vb[cb]=v,nxtb[cb]=Bdj[u];Bdj[u]=cb;\n}\nint n,rt,s,ans;\nint dep[MAXN],fa[MAXN],e[MAXN][2],lon[MAXN],vis[MAXN];\nvoid dfs(int u)\n{\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=fa[u])\n\t\t{\n\t\t\tdep[V[i]]=dep[u]+1;\n\t\t\tfa[V[i]]=u;\n\t\t\tdfs(V[i]);\n\t\t}\n}\nint dis[MAXN];\nqueue<int>Q;\nvoid bfs()\n{\n\tdis[s]=0;\n\tvis[s]=1;\n\tQ.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=Bdj[u];i;i=nxtb[i])\n\t\t\tif(!vis[Vb[i]])\n\t\t\t{\n\t\t\t\tdis[Vb[i]]=dis[u]+1;\n\t\t\t\tif(dis[Vb[i]]<dep[Vb[i]])\n\t\t\t\t{\n\t\t\t\t\tvis[Vb[i]]=1;\n\t\t\t\t\tQ.push(Vb[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\nint check(int u,int v)\n{\n\tif(dep[u]<dep[v]) swap(u,v);\n\tint k=dep[u]-dep[v];\n\tif(k==0) return fa[u]!=fa[v];\n\tif(k==1) return fa[u]!=v;\n\tif(k==2) return fa[fa[u]]!=v;\n\treturn 1;\n}\nvoid Clear()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tAdj[i]=Bdj[i]=vis[i]=lon[i]=0;\n\tc=cb=0;\n\tans=0;\n}\nvoid Read(int &x)\n{\n\tx=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n}\nint main()\n{\n//\tfreopen(\"coalesce.in\",\"r\",stdin);\n//\tfreopen(\"coalesce.out\",\"w\",stdout);\n\tscanf(\"%d%d%d\",&n,&s,&rt);\n\tint u,v,flag=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tRead(e[i][0]);\n\t\tRead(e[i][1]);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tRead(u);Read(v);\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tdfs(rt);\n\tfor(int i=1;i<n;i++)\n\t\tif(check(e[i][0],e[i][1]))\n\t\t\tlon[e[i][0]]=lon[e[i][1]]=1;\n\t\telse Add(e[i][0],e[i][1]),Add(e[i][1],e[i][0]);\n\tbfs();\n\tfor(int i=1;i<=n;i++)\n\t\tif(vis[i]&&lon[i])\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\telse if(vis[i])\n\t\t\tans=max(ans,dep[i]);\n\tif(flag) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\nconst int Maxn = 200005;\nconst int Maxm = 20;\n\nint n, x, y;\nvector <int> neigh1[Maxn], neigh2[Maxn];\nint L[Maxn], P[Maxn][Maxm];\nint L2[Maxn];\n\nvoid Traverse(int v)\n{\n    for (int i = 0; i < neigh2[v].size(); i++) {\n        int u = neigh2[v][i];\n        if (u == P[v][0]) continue;\n        P[u][0] = v; L[u] = L[v] + 1;\n        Traverse(u);\n    }\n}\n\nvoid Traverse2(int v, int p = 0)\n{\n    for (int i = 0; i < neigh1[v].size(); i++) {\n        int u = neigh1[v][i];\n        if (u == p) continue;\n        if (L2[v] + 1 < L[u]) {\n            L2[u] = L2[v] + 1;\n            Traverse2(u, v);\n        }\n    }\n}\n\nint getLCA(int a, int b)\n{\n    if (L[a] < L[b]) swap(a, b);\n    for (int i = Maxm - 1; i >= 0; i--)\n        if (L[a] - (1 << i) >= L[b])\n            a = P[a][i];\n    if (a == b) return a;\n    for (int i = Maxm - 1; i >= 0; i--)\n        if (P[a][i] != P[b][i])\n            a = P[a][i], b = P[b][i];\n    return P[a][0];\n}\n\nint getDist(int a, int b) { return L[a] + L[b] - 2 * L[getLCA(a, b)]; }\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &x, &y);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        neigh1[a].push_back(b);\n        neigh1[b].push_back(a);\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        neigh2[a].push_back(b);\n        neigh2[b].push_back(a);\n    }\n    Traverse(y);\n    for (int j = 1; j < Maxm; j++)\n        for (int i = 1; i <= n; i++)\n            P[i][j] = P[P[i][j - 1]][j - 1];\n    fill(L2, L2 + Maxn, Maxn);\n    L2[x] = 0;\n    Traverse2(x);\n    int res = 0;\n    for (int i = 1; i <= n; i++)\n        if (L2[i] < L[i]) {\n            res = max(res, 2 * L[i]);\n            for (int j = 0; j < neigh1[i].size(); j++) {\n                int u = neigh1[i][j];\n                if (getDist(i, u) > 2) { printf(\"-1\\n\"); return 0; }\n            }\n        }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 400004\nint a[2][N],b[2][N],c[2][N],e[N],f[N],h[N],i,l,n,q[N],r,s[N],t,x,y;bool d[N][2],g[N];\ninline bool cmp(int u,int v){return f[u]!=v&&u!=f[v]&&f[u]!=f[v]&&f[f[u]]!=v&&u!=f[f[v]];}\nint u,v;\nint main()\n{\n\tfor(scanf(\"%d%d%d\",&n,&x,&y),i=t=1;i<n;i++)scanf(\"%d%d\",&u,&v),b[0][++t]=a[0][u],c[0][a[0][u]=t]=v,b[0][++t]=a[0][v],c[0][a[0][v]=t]=u;\n\tfor(i=t=1,e[n]=-1;i<n;e[i++]=-1)scanf(\"%d%d\",&u,&v),b[1][++t]=a[1][u],c[1][a[1][u]=t]=v,b[1][++t]=a[1][v],c[1][a[1][v]=t]=u;\n\tfor(d[q[r++]=y][e[y]=1]=true,d[q[r++]=x][e[x]=0]=true,e[y]=1;l<r;)for(v=e[u=q[l++]],i=a[v][u];i;i=b[v][i])if(e[c[v][i]]<e[u])d[q[r++]=c[v][i]][e[c[v][i]]=e[u]]=true,f[c[v][i]]=u,g[c[v][i]]=h[c[v][i]]==h[u]+1,h[c[v][i]]=h[u]+1;\n\tfor(i=1;i<n;i++)if(cmp(c[0][i<<1],c[0][i<<1|1])&&(!g[c[0][i<<1]]&&*d[c[0][i<<1]]||!g[c[0][i<<1|1]]&&*d[c[0][i<<1|1]]))return 0&puts(\"-1\");\n\tfor(i=1,v=0;i<=n;i++)if(*d[i]&&v<h[i])v=h[i];\n\treturn 0&printf(\"%d\\n\",v<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nstruct edge{\n\tint to,next;\n};\nint n,res;\nstruct Tree{\n\tint fa[N],dep[N];\n\tedge e[N*2];\n\tint head[N],tot,rt;\n\tvoid add(int x,int y){\n\t\te[++tot]=(edge){y,head[x]};\n\t\thead[x]=tot;\n\t}\n\tvoid dfs(int x){\n\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\tif (e[i].to!=fa[x]){\n\t\t\t\tfa[e[i].to]=x;\n\t\t\t\tdep[e[i].to]=dep[x]+1;\n\t\t\t\tdfs(e[i].to);\n\t\t\t}\n\t}\n\tvoid init(int n){\n\t\tmemset(head,0,sizeof(head));\n\t\ttot=dep[rt]=fa[rt]=0;\n\t\tfor (int i=1;i<n;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tadd(x,y); add(y,x);\n\t\t}\n\t\tdfs(rt);\n\t}\n\tint dis(int x,int y){\n\t\tint ans=0;\n\t\tfor (;x!=y&&ans<3;ans++)\n\t\t\tif (dep[x]>dep[y])\n\t\t\t\tx=fa[x];\n\t\t\telse y=fa[y];\n\t\treturn ans==3;\n\t}\n}A,B;\nint dfs(int x){\n\tint ans=B.dep[x];\n\tfor (int i=A.head[x];i;i=A.e[i].next){\n\t\tint to=A.e[i].to;\n\t\tif (to==A.fa[x]) continue;\n\t\tif (B.dis(x,to)) return 2e9;\n\t\tif (A.dep[to]<B.dep[to])\n\t\t\tans=max(ans,dfs(to));\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&A.rt,&B.rt);\n\tA.init(n); B.init(n);\n\tint ans=dfs(A.rt);\n\tprintf(\"%d\\n\",ans>1e9?-1:ans*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 200000;\n\nint n, p, q;\nint eu[MaxN], ev[MaxN];\n\nstruct halfEdge\n{\n\tint v;\n\thalfEdge *next;\n};\nhalfEdge adj_pool[MaxN * 2], *adj_tail = adj_pool;\nhalfEdge *adj[MaxN + 1];\n\ninline void addEdge(const int &u, const int &v)\n{\n\tadj_tail->v = v, adj_tail->next = adj[u];\n\tadj[u] = adj_tail++;\n}\n\ninline void adj_init()\n{\n\tadj_tail = adj_pool;\n\tfor (int u = 1; u <= n; ++u)\n\t\tadj[u] = NULL;\n}\n\nint dfs_clock = 0;\nint dfn_l[MaxN + 1], dfn_r[MaxN + 1];\n\nint dep[MaxN + 1];\n\nint fa[MaxN + 1];\n\nvoid dfs1(int u)\n{\n\tdfn_l[u] = ++dfs_clock;\n\n\tfor (halfEdge *e = adj[u]; e; e = e->next)\n\t\tif (e->v != fa[u])\n\t\t{\n\t\t\tfa[e->v] = u;\n\t\t\tdep[e->v] = dep[u] + 1;\n\t\t\tdfs1(e->v);\n\t\t}\n\n\tdfn_r[u] = dfs_clock;\n}\n\ninline bool valid(int u, int v)\n{\n\tif (dfn_l[u] > dfn_l[v])\n\t\tswap(u, v);\n\tif (dfn_l[v] <= dfn_r[u])\n\t\treturn dep[v] - dep[u] <= 2;\n\treturn fa[u] == fa[v];\n}\n\nbool inv[MaxN + 1];\n\nint dist[MaxN + 1];\nbool vis[MaxN + 1];\n\nvoid dfs2(int u)\n{\n\tvis[u] = true;\n\n\tfor (halfEdge *e = adj[u]; e; e = e->next)\n\t\tif (!vis[e->v])\n\t\t{\n\t\t\tdist[e->v] = dist[u] + 1;\n\t\t\tif (dist[e->v] < dep[e->v])\n\t\t\t\tdfs2(e->v);\n\t\t}\n}\n\ninline int query()\n{\n\tint res = 0;\n\tfor (int u = 1; u <= n; ++u)\n\t\tif (vis[u])\n\t\t{\n\t\t\tres = max(res, dep[u]);\n\t\t\tif (inv[u])\n\t\t\t\treturn -1;\n\t\t}\n\treturn res * 2;\n}\n\nint main()\n{\n\tcin >> n >> p >> q;\n\tfor (int i = 1; i < n; ++i)\n\t\teu[i] = getint(), ev[i] = getint();\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = getint(), v = getint();\n\t\taddEdge(u, v);\n\t\taddEdge(v, u);\n\t}\n\n\tdfs1(q);\n\n\tadj_init();\n\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = eu[i], v = ev[i];\n\t\tif (!valid(u, v))\n\t\t\tinv[u] = inv[v] = true;\n\t\telse\n\t\t{\n\t\t\taddEdge(u, v);\n\t\t\taddEdge(v, u);\n\t\t}\n\t}\n\n\tdfs2(p);\n\n\tcout << query() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define SZ(x) ((int) (x).size())\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <typename T, typename TT> ostream & operator << (ostream &out, pair<T, TT> t) { return out << \"(\" << t.X << \",\" << t.Y << \")\";}\ntemplate <typename T> ostream & operator << (ostream &out,vector<T> t) { out << \"[\"; for (auto x:t) out << x << \" \"; out << \"]\"; return out;}\ntemplate <typename T> inline bool cmin(T & a, const T & b) { return a > b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool cmax(T & a, const T & b) { return a < b ? a = b, 1 : 0;}\ntemplate <typename T> void read(T & x) \n{\n\tint f = 1; char ch; x = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n\twhile(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); x *= f;\n}\n\nconst int NX = 101234;\n\nint n, s_a, s_b, k, dep[NX], par[NX], l[NX], r[NX];\nvector<int> e_a[NX], e_b[NX];\n\nvoid dfs(int x, int fa)\n{\n\tl[x] = ++k;\n\tfor (int y : e_b[x])\n\t{\n\t\tif(y != fa)\n\t\t{\n\t\t\tdep[y] = dep[x] + 1;\n\t\t\tpar[y] = x;\n\t\t\tdfs(y, x);\n\t\t}\n\t}\n\tr[x] = k;\n}\n\nbool cho[NX], good[NX]; int ans = 0;\nvoid dfs2(int x, int fa, int d)\n{\n\tif(d < dep[x])\n\t{\n\t\tcmax(ans, dep[x] << 1);\n\t\tif(good[x])\n\t\t\tputs(\"-1\"), exit(0);\n\t} else\n\t\treturn;\n\t\n\tfor (int y : e_a[x])\n\t{\n\t\tif(y != fa)\n\t\t\tdfs2(y, x, d + 1);\n\t}\n}\n\nint main() \n{\n\tread(n); read(s_a); read(s_b);\n\tvector<pair<int, int> > buf;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v; read(u); read(v);\n\t\tbuf.pb(mp(u, v));\n\t}\n\t\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v; read(u); read(v);\n\t\te_b[u].pb(v);\n\t\te_b[v].pb(u);\n\t}\n\t\n\tdfs(s_b, 0);\n\tfor (int k = 0; k < SZ(buf); k++)\n\t{\n\t\tint i = buf[k].first;\n\t\tint j = buf[k].second;\n\t\t\n\t\tif(l[i] > l[j]) swap(i, j);\n\t\tbool t = r[j] <= r[i] && dep[j] > dep[i] + 2;\n\t\t\n\t\tif(t || (r[j] > r[i] && par[i] != par[j]))\n\t\t{\n\t\t\tgood[i] = true;\n\t\t\tgood[j] = true;\n\t\t}else {\n\t\t\te_a[i].pb(j);\n\t\t\te_a[j].pb(i);\n\t\t}\n\t}\n\t\n\tdfs2(s_a, 0, 0);\t\n\t\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,X,Y;\nvint G[222222];\nint par[222222];\nint dep[222222];\nvoid dfs(int v,int p,int d){\n    dep[v]=d;\n    par[v]=p;\n    for(auto u:G[v]){\n        if(u==p)continue;\n        dfs(u,v,d+1);\n    }\n}\nvint G2[222222];\nbool win[222222];\n\nint ans;\nvoid dfs2(int v,int p,int d){\n    if(dep[v]<d)return;\n    chmax(ans,dep[v]*2);\n    if(dep[v]==d)return;\n\n    if(win[v])ans=INT_MAX;\n    for(auto u:G2[v]){\n        if(u!=p)dfs2(u,v,d+1);\n    }\n}\nsigned main(){\n    cin>>N>>X>>Y;X--;Y--;\n    vint A(N-1),B(N-1);\n    rep(i,N-1)cin>>A[i]>>B[i],A[i]--,B[i]--;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n    rep(i,N)sort(all(G[i]));\n\n    dfs(Y,-1,0);\n\n    rep(i,N-1){\n        int a=A[i],b=B[i];\n        bool ok=false;\n        if(binary_search(all(G[a]),b))ok=true;\n        if(par[a]!=-1&&binary_search(all(G[par[a]]),b))ok=true;\n        if(par[b]!=-1&&binary_search(all(G[par[b]]),a))ok=true;\n        if(ok){\n            G2[a].pb(b);G2[b].pb(a);\n        }\n        else{\n            win[a]=win[b]=true;\n        }\n    }\n\n    dfs2(X,-1,0);\n\n    if(ans==INT_MAX)cout<<-1<<endl;\n    else cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define ll long long\n#define MOD 924844033\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n,k;\nll dp[4010][2010][2],border[4010],f[2010],fac[2010];\nint main(){\n\tn=read();k=read();int i,j,re=n%k;ll tmp=0,ans=0;\n\tfac[0]=fac[1]=1;\n\tfor(i=2;i<=n;i++) fac[i]=fac[i-1]*i%MOD;\n\tfor(i=1;i<=re;i++){\n\t\ttmp+=(n/k+1);border[tmp]=1;\n\t\ttmp+=(n/k+1);border[tmp]=1;\n\t}\n\tfor(i=re+1;i<=k;i++){\n\t\ttmp+=n/k;border[tmp]=1;\n\t\ttmp+=n/k;border[tmp]=1;\n\t}\n\tdp[1][0][0]=1;\n\tfor(i=2;i<=(n<<1);i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\tdp[i][j][0]=(dp[i-1][j][0]+dp[i-1][j][1])%MOD;\n\t\t\tif(!border[i-1]) dp[i][j][1]=dp[i-1][j-1][0];\n\t\t}\n\t}\n\tfor(i=0;i<=n;i++) f[i]=(dp[n<<1][i][0]+dp[n<<1][i][1])%MOD;\n\ttmp=1;\n\tfor(i=0;i<=n;i++){\n\t\tans+=tmp*f[i]*fac[n-i]%MOD;ans=(ans+MOD)%MOD;\n\t\ttmp=-tmp;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: zxy_hhhh\n    date: 2020/03/13\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<iostream>\n#define ll long long\ninline ll rd() {\n    ll _x=0;int _ch=getchar(),_f=1;\n    for(;!isdigit(_ch)&&(_ch!='-')&&(_ch!=EOF);_ch=getchar());\n    if (_ch=='-'){_f=0;_ch=getchar();}\n    for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0';\n    return _f?_x:-_x;\n}\nvoid write(ll _x){if (_x>=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); }\ninline void wrt(ll _x,char _p){if (_x<0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);}\n#define maxn 200005\nint dis[maxn],Fa[maxn];\nstd::vector<int> G1[maxn],G2[maxn];\nint n,A,B;\nvoid dfs(int u,int fa) {\n    Fa[u]=fa;\n    for(auto i:G2[u]) if (i!=fa) {\n        dis[i]=dis[u]+1;\n        dfs(i,u);\n    }\n}\nint ans;\nvoid DFS(int u,int fa,int D) {\n    if (dis[u]<=D) return ;\n    ans=std::max(ans,dis[u]*2);\n    for(auto i:G1[u]) if (i!=fa) {\n        if (!(Fa[u]==i||Fa[i]==u||Fa[u]==Fa[i]||Fa[Fa[i]]==u||Fa[Fa[u]]==i)) \n            ans=1e9;\n        DFS(i,u,D+1);\n    }\n}\nint main() {\n    n=rd();A=rd(),B=rd();\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G1[x].push_back(y);\n        G1[y].push_back(x);\n    }\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G2[x].push_back(y);\n        G2[y].push_back(x);\n    }\n    dfs(B,0);\n    DFS(A,0,0);\n    if (ans>1e8) wrt(-1,'\\n');\n    else wrt(ans,'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=0;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(!bad[u])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(ok[i] && !bad[u1[i]]){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"ctime\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Lowest_Common_Ancestor {\n\tvector<int>depth;\n\tvector<vector<int>>parent;\n\tvector<vector<int>>edge;\n\tint height = 0;\n\tint node;\npublic:\n\tLowest_Common_Ancestor(int num) {\n\t\tnum++;\n\t\tnode = num;\n\t\twhile (num) {\n\t\t\theight++;\n\t\t\tnum /= 2;\n\t\t}\n\t\tparent.resize(height);\n\t\tedge.resize(node);\n\t\tdepth.resize(node);\n\t\tfor (int i = 0; i < height; i++)parent[i].resize(node);\n\t}\n\tvoid Add_Edge(int a, int b) {\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\treturn;\n\t}\n\tvoid Update(int rtnode) {\n\t\tqueue<int>QQ;\n\t\tfor (int i = 0; i < node; i++) depth[i] = INT_MAX;\n\t\tdepth[rtnode] = 0;\n\t\tQQ.push(rtnode);\n\t\twhile (!QQ.empty()) {\n\t\t\tint c = QQ.front();\n\t\t\tfor (auto i : edge[c]) {\n\t\t\t\tif (depth[i] > depth[c] + 1) {\n\t\t\t\t\tdepth[i] = depth[c] + 1;\n\t\t\t\t\tQQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQQ.pop();\n\t\t}\n\t\tparent[0][rtnode] = -1;\n\t\tfor (int i = 1; i < node; i++) {\n\t\t\tfor (auto j : edge[i]) {\n\t\t\t\tif (depth[i] - 1 == depth[j]) {\n\t\t\t\t\tparent[0][i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < height - 1; i++) {\n\t\t\tfor (int j = 0; j < node; j++) {\n\t\t\t\tif (parent[i][j] < 0)parent[i + 1][j] = -1;\n\t\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint LCA(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tif ((depth[v] - depth[u]) >> i & 1) {\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int i = height - 1; i >= 0; i--) {\n\t\t\tif (parent[i][v] != parent[i][u]) {\n\t\t\t\tu = parent[i][u];\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\tint Dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - depth[LCA(u, v)] * 2;\n\t}\n};\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tvector<vector<int>>edge(N + 1);\n\tLowest_Common_Ancestor lca(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tedge[H].push_back(W);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tlca.Add_Edge(H, W);\n\t}\n\tlca.Update(1);\n\tvector<int>safe(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (lca.Dist(i, j) > 2)safe[i] = safe[j] = 1;\n\t\t}\n\t}\n\tvector<int>depth(N + 1, MOD);\n\tCalculate_Depth(edge, depth, L);\n\tvector<int>reachable(N + 1);\n\treachable[L] = lca.Dist(R, L);\n\tqueue<int>Q;\n\tQ.push(L);\n\twhile (!Q.empty()){\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (reachable[i])continue;\n\t\t\tif (depth[i] < lca.Dist(R, i)) {\n\t\t\t\treachable[i] = lca.Dist(R, i);\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tans = max(ans, reachable[i]);\n\t}\n\tans <<= 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (reachable[i] && safe[i])ans = -1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmin(T&x,const T &y)\n{\n\tif(x>y)x=y;\n}\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int,int> pii;\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\n#define rep0(i,l,r) for(int i=l;i<r;++i)\n#define gc (c=getchar())\nint read()\n{\n\tchar c;\n\twhile(gc<'-');\n\tif(c=='-')\n\t{\n\t\tint x=gc-'0';\n\t\twhile(gc>='0')x=x*10+c-'0';\n\t\treturn -x;\n\t}\n\tint x=c-'0';\n\twhile(gc>='0')x=x*10+c-'0';\n\treturn x;\n}\n#undef gc\n\nconst int N=2e5+5;\nint n;\nvector<int>lk1[N],lk2[N];\nint deep[N],fa[N];\n\nvoid dfs2(int x)\n{\n\tfor(auto y:lk2[x])\n\tif(y!=fa[x])\n\t{\n\t\tfa[y]=x;deep[y]=deep[x]+1;\n\t\tdfs2(y);\n\t}\n}\nvoid check(int x,int y)\n{\n\tif(deep[x]<deep[y])swap(x,y);\n\tif(fa[x]==fa[y]||fa[x]==y||fa[fa[x]]==y)return ;\n\t//cerr<<x<<\" \"<<y<<endl;\n\tputs(\"-1\");\n\texit(0);\n}\nint ans;\nvoid dfs1(int x,int fr,int dep)\n{\n\tif(dep>=deep[x])return ;\n\tchmax(ans,deep[x]);\n\tfor(auto y:lk1[x])\n\tif(y!=fr)\n\t{\n\t\tcheck(x,y);\n\t\tdfs1(y,x,dep+1);\n\t}\n}\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);//freopen(\"1.out\",\"w\",stdout);\n#endif\n\tint x1,x2;\n\tcin>>n>>x1>>x2;\n\trep(i,1,n-1)\n\t{\n\t\tint x=read(),y=read();\n\t\tlk1[x].push_back(y);\n\t\tlk1[y].push_back(x);\n\t}\n\trep(i,1,n-1)\n\t{\n\t\tint x=read(),y=read();\n\t\tlk2[x].push_back(y);\n\t\tlk2[y].push_back(x);\n\t}\n\tdfs2(x2);\n//\trep(i,1,n)cerr<<deep[i]<<\" \";cerr<<endl;\n\tdfs1(x1,0,0);\n\tcout<<ans*2;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\n//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\nconst int MAX_V = 200011;\nconst int LOG_V = 19;\nint depth[MAX_V];\nint parent[LOG_V][MAX_V];\n\nvoid build_lca(VI G[], int N, const int root=0) {\n    depth[root] = 0;\n    parent[0][root] = root;\n    VI ord; ord.reserve(N);\n    ord.push_back(root);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != parent[0][v]) {\n\t    ord.push_back(*e);\n\t    depth[*e] = depth[v] + 1;\n\t    parent[0][*e] = v;\n\t    // G[*e].erase(remove(G[*e].begin(), G[*e].end(), v), G[*e].end()); // remove parent edge\n\t}\n    }\n    REP (t, LOG_V-1) REP (v, N) parent[t+1][v] = parent[t][parent[t][v]];\n}\n\nint lca(int x, int y) {\n    if (depth[x] < depth[y]) swap(x, y);\n    REP (t, LOG_V) if ((depth[x] - depth[y]) & (1 << t)) x = parent[t][x];\n    if (x == y) return x;\n    for (int t=LOG_V; t--;) {\n\tif (parent[t][x] != parent[t][y]) {\n\t    x = parent[t][x];\n\t    y = parent[t][y];\n\t}\n    }\n    return parent[0][x];\n}\n\nint distance(int x, int y, int z=-1) { // number of edges\n    if (z == -1) z = lca(x, y);\n    return depth[x] + depth[y] - 2 * depth[z];\n}\n\nint N;\nvoid read_graph(VI G[]) {\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n}\n\nint Lstart, Sstart;\nVI L[200011], S[200011];\n\nbool inf[200011];\nbool use[200011];\nint dist[200011];\n\nvoid bfs0() {\n    memset(use, 0, sizeof use);\n    VI ord; ord.reserve(N);\n    ord.push_back(Lstart);\n    use[Lstart] = true;\n    dist[Lstart] = 0;\n    for (int i=0; i<(int)ord.size(); i++) {\n\tint v = ord[i];\n\tEACH (e, L[v]) if (!use[*e] && depth[*e] > dist[v]+1) {\n\t    ord.push_back(*e);\n\t    use[*e] = true;\n\t    dist[*e] = dist[v] + 1;\n\t}\n    }\n}\n\nvoid MAIN() {\n    scanf(\"%d%d%d\", &N, &Lstart, &Sstart);\n    Lstart--;\n    Sstart--;\n    read_graph(L);\n    read_graph(S);\n    build_lca(S, N, Sstart);\n\n    REP (v, N) {\n\tEACH (e, L[v]) if (distance(v, *e) >= 3) {\n\t    inf[v] = true;\n\t}\n    }\n\n    bfs0();\n\n    REP (v, N) {\n\tif (use[v] && inf[v]) {\n\t    puts(\"-1\");\n\t    return;\n\t}\n    }\n\n    int ans = 0;\n    REP (v, N) if (use[v]) {\n\tamax(ans, depth[v]*2);\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n    static char ibuf[RLEN],*ib,*ob;\n    (ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n    return (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n    char ch=nc(); int i=0,f=1;\n    while(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n    while(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n    return i*f;\n}\n\nconst int N=1e5+50;\nint n,col[N];\nstruct Tree {\n    int stx,fa[N],dep[N];\n    vector <int> edge[N];\n    inline void dfs(int x,int f,int d=0) {\n        fa[x]=f; dep[x]=d;\n        for(auto v:edge[x]) if(v!=f) dfs(v,x,d+1);\n    }\n    inline void init() {\n        for(int i=1;i<n;i++) {\n            int x=rd(), y=rd();\n            edge[x].push_back(y);\n            edge[y].push_back(x);\n        } dfs(stx,0);\n    }\n    inline bool valid(int x,int y,int rs=0) {\n        while(dep[x]>dep[y]) if((x=fa[x],++rs)>=3) return false;\n        while(dep[x]<dep[y]) if((y=fa[y],++rs)>=3) return false;\n        while(x!=y) if((y=fa[y],x=fa[x],rs+=2)>=3) return false;\n        return true;\n    }\n} A,B;\ninline void dfs(int x) {\n    if(A.dep[x]>=B.dep[x]) return;\n    col[x]=1;\n    for(auto v:A.edge[x]) if(v!=A.fa[x]) dfs(v);\n}\nint main() {\n    n=rd(); A.stx=rd(); B.stx=rd();\n    if(A.stx==B.stx) {puts(\"0\"); return 0;}\n    A.init(); B.init();\n    dfs(A.stx);\n    for(int i=1;i<=n;i++) \n        for(auto v:A.edge[i])\n            if(col[i] && !B.valid(i,v)) {puts(\"-1\"); return 0;}\n    int ans=0;\n    for(int i=1;i<=n;i++) \n        if(col[i]) ans=max(ans,B.dep[i]);\n    cout<<(ans<<1)<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2000005;\n\nint N,X,Y;\nvector<int> red[MAXN],blue[MAXN];\nint dep[MAXN],fa[MAXN];\n\nbool isTable(int u,int v)\n{\n\tif(dep[u]>dep[v])\n\t\tswap(u,v);\n\tif(fa[v]==u||fa[fa[v]]==u||fa[u]==fa[v])\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs1(int u)\n{\n\tfor(auto v:blue[u])\n\t\tif(v!=fa[u])\n\t\t{\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs1(v);\n\t\t}\n}\nint dfs2(int u,int f=0,int step=0)\n{\n\tstep++;\n\tint res=dep[u];\n\tfor(auto v:red[u])\n\t{\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tif(isTable(u,v))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tres=max(res,dep[v]);\n\t\tif(dep[v]>step)\n\t\t\tres=max(res,dfs2(v,u,step));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&X,&Y);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred[u].push_back(v);\n\t\tred[v].push_back(u);\n\t}\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue[u].push_back(v);\n\t\tblue[v].push_back(u);\n\t}\n\tdfs1(Y);\n\tint ans=dfs2(X)*2;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=200005;\n\nint n,X,Y,ncnt;\nint dfn[MAXN],efn[MAXN],fa[MAXN],dep[MAXN];\nstruct node{\n    int v,nex;\n}E[MAXN*2],G[MAXN*2];\nint Ehead[MAXN],Ghead[MAXN],dcnt[2];\nbool tag[MAXN];\npair<int,int> a[MAXN];\n\nvoid addedge(node edge[],int head[],int &cnt,int u,int v){\n    node &p=edge[++cnt];\n    p.v=v;\n    p.nex=head[u];\n    head[u]=cnt;\n}\n\nvoid dfs(int u,int fa=0){\n    ::fa[u]=fa;\n    dep[u]=dep[fa]+1;\n    dfn[u]=++ncnt;\n    for(int i=Ghead[u];i;i=G[i].nex){\n        int v=G[i].v;\n        if(v==fa) continue;\n        dfs(v,u);\n    }\n    efn[u]=++ncnt;\n}\n\nbool check(int u,int v){\n    if(dfn[u]>dfn[v]) swap(u,v);\n    if(dfn[u]<dfn[v]&&efn[v]<efn[u])\n        return dep[v]-dep[u]>=3;\n    return fa[u]!=fa[v];\n}\n\nint vis[MAXN],dis[MAXN],deq[MAXN],l,r;\nvoid bfs(){\n    for(int i=1;i<=n;i++) vis[i]=dis[i]=0;\n    l=r=1;\n    vis[X]=1;\n    deq[r++]=X;\n    while(l<r){\n        int u=deq[l++];\n        for(int i=Ehead[u];i;i=E[i].nex){\n            int v=E[i].v;\n            if(vis[v]) continue;\n            vis[v]=1;\n            dis[v]=dis[u]+1;\n            if(dis[v]<dep[v])\n                deq[r++]=v;\n        }\n    }\n}\n\nint main(){\n\n    dep[0]=-1;\n    while(~scanf(\"%d%d%d\",&n,&X,&Y)){\n        for(int i=1;i<=n;i++) Ehead[i]=Ghead[i]=0;\n        dcnt[0]=dcnt[1]=ncnt=0;\n        for(int i=1;i<=n;i++) tag[i]=0;\n        for(int i=1;i<n;i++) scanf(\"%d%d\",&a[i].first,&a[i].second);\n        for(int i=1;i<n;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            addedge(G,Ghead,dcnt[1],u,v);\n            addedge(G,Ghead,dcnt[1],v,u);\n        }\n        dfs(Y);\n        for(int i=1;i<n;i++)\n            if(check(a[i].first,a[i].second)) tag[a[i].first]=tag[a[i].second]=1;\n            else addedge(E,Ehead,dcnt[0],a[i].first,a[i].second),addedge(E,Ehead,dcnt[0],a[i].second,a[i].first);\n        bfs();\n        int ans=0;\n        bool flag=1;\n        for(int i=1;i<=n&&flag;i++){\n            if(!vis[i]) continue;\n            if(tag[i]) flag=0;\n            else ans=max(ans,2*dep[i]);\n        }\n        printf(\"%d\\n\",flag?ans:-1);\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\n#define oo (1<<30)\nusing namespace std;\nvector<int> G[N],V[N];\nint n,f[20][N],d[N],X,Y,ans,tag[N];\nstruct edge{ int x,y;}E[N];\nvoid dfs(int t,int fa)\n{\n\tint i; f[0][t]=fa;\n\td[t]=d[fa]+1;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(G[t][i]!=fa) dfs(G[t][i],t);\n}\nint lca(int x,int y)\n{\n\tint i; if(x==y) return x;\n\tif(d[x]<d[y]) swap(x,y);\n\tfor(i=19;i>=0;i--)\n\t\tif(d[f[i][x]]>=d[y])\n\t\t\tx=f[i][x];\n\tif(x==y) return x;\n\tfor(i=19;i>=0;i--)\n\t\tif(f[i][x]!=f[i][y])\n\t\t\tx=f[i][x],y=f[i][y];\n\treturn f[0][x];\n}\nint dis(int x,int y){ return d[x]+d[y]-2*d[lca(x,y)];}\nvoid DFS(int t,int fa,int ds)\n{\n\tint i; ans=max(ans,d[t]-1);\n\tif(tag[t]){ ans=oo; return ;}\n\tfor(i=0;i<V[t].size();i++)\n\t\tif(V[t][i]!=fa&&d[V[t][i]]-1>ds)\n\t\t\tDFS(V[t][i],t,ds+1);\n}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d %d %d\",&n,&X,&Y);\n\tfor(i=1;i<n;i++)\n\t\tscanf(\"%d %d\",&E[i].x,&E[i].y);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t  }\n\tdfs(Y,0);\n\tfor(i=1;i<20;i++)\n\t\tfor(x=1;x<=n;x++)\n\t\t\tf[i][x]=f[i-1][f[i-1][x]];\n\tfor(i=1;i<n;i++){\n\t\tx=dis(E[i].x,E[i].y);\n\t\tif(x>=3) tag[E[i].x]=tag[E[i].y]=1;\n\t\tV[E[i].x].push_back(E[i].y);\n\t\tV[E[i].y].push_back(E[i].x);\n\t  }\n\tDFS(X,0,1);\n\tprintf(\"%d\",ans==oo ? -1 : ans*2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define MAXN 200000\nusing namespace std;\nstruct node\n{\n\tint to;\n\tnode *nxt;\n}edges[MAXN*4+5];\nnode *ncnt=&edges[0],*AdjR[MAXN+5],*AdjB[MAXN+5];\nint fro[MAXN+5],to[MAXN+5];\nint N,X,Y,dfn[MAXN+5],efn[MAXN+5],tmn;\nint dep[MAXN+5],fa[MAXN+5];\nint dist[MAXN+5];\nbool sppoint[MAXN+5];\nbool vis[MAXN+5];\nqueue<int> que;\nvoid Init()\n{\n\tncnt=&edges[0];\n\tmemset(AdjR,0,sizeof(AdjR));\n\tmemset(AdjB,0,sizeof(AdjB));\n\ttmn=0;\n\tmemset(sppoint,0,sizeof(sppoint));\n\tmemset(vis,0,sizeof(vis));\n\twhile(que.empty()==false)\n\t\tque.pop();\n}\nvoid AddEdgeR(int u,int v)\n{\n\tnode *p=++ncnt;\n\tp->to=v;\n\tp->nxt=AdjR[u];\n\tAdjR[u]=p;\n\t\n\tnode *q=++ncnt;\n\tq->to=u;\n\tq->nxt=AdjR[v];\n\tAdjR[v]=q;\n}\nvoid AddEdgeB(int u,int v)\n{\n\tnode *p=++ncnt;\n\tp->to=v;\n\tp->nxt=AdjB[u];\n\tAdjB[u]=p;\n\t\n\tnode *q=++ncnt;\n\tq->to=u;\n\tq->nxt=AdjB[v];\n\tAdjB[v]=q;\n}\nvoid DFS1(int u,int f)\n{\n\tfa[u]=f;\n\tdfn[u]=++tmn;\n\tfor(node *p=AdjB[u];p!=NULL;p=p->nxt)\n\t{\n\t\tint v=p->to;\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tdep[v]=dep[u]+1;\n\t\tDFS1(v,u);\n\t}\n\tefn[u]=++tmn;\n}\nvoid BFS()\n{\n\tvis[X]=true;\n\tdist[X]=0;\n\tque.push(X);\n\twhile(que.empty()==false)\n\t{\n\t\tint u=que.front();\n\t\tque.pop();\n\t\tfor(node *p=AdjR[u];p!=NULL;p=p->nxt)\n\t\t{\n\t\t\tint v=p->to;\n\t\t\tif(vis[v]==false)\n\t\t\t{\n\t\t\t\tdist[v]=dist[u]+1;\n\t\t\t\tif(dist[v]<dep[v])\n\t\t\t\t{\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool Check(int x,int y)\n{\n\tif(dfn[x]>dfn[y])\n\t\tswap(x,y);\n\tif(dfn[x]<dfn[y]&&efn[x]>efn[y])\n\t{\n\t\tif(dep[y]-dep[x]>=3)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif(fa[x]!=fa[y])\n\t\treturn true;\n\treturn false;\n}\nint read()\n{\n\tint ret=0;\n\tchar c=0;\n\twhile(c<'0'||c>'9')\tc=getchar();\n\tret=10*ret+c-'0';\n\twhile(true)\n\t{\n\t\tc=getchar();\n\t\tif(c<'0'||c>'9')\n\t\t\tbreak;\n\t\tret=10*ret+c-'0';\n\t}\n\treturn ret;\n}\nint main()\n{\n//\tfreopen(\"coalesce.in\",\"r\",stdin);\n//\tfreopen(\"coalesce.out\",\"w\",stdout);\n\twhile(scanf(\"%d %d %d\",&N,&X,&Y)==3)\n\t{\n\t\tInit();\n\t\tint u,v;\n\t\tfor(int i=1;i<N;i++)\n\t\t\tfro[i]=read(),to[i]=read();\n\t\tfor(int i=1;i<N;i++)\n\t\t{\n\t\t\tu=read(),v=read();\n\t\t\tAddEdgeB(u,v);\n\t\t}\n\t\tdep[Y]=0;\n\t\tDFS1(Y,-1);\n\t\tfor(int i=1;i<N;i++)\n\t\t\tif(Check(fro[i],to[i])==true)\n\t\t\t\tsppoint[fro[i]]=sppoint[to[i]]=true;\n\t\t\telse\n\t\t\t\tAddEdgeR(fro[i],to[i]);\n\t\tBFS();\n\t\tint maxdep=-1;\n\t\tbool Find=false;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tif(vis[i]==true)\n\t\t\t{\n\t\t\t\tif(sppoint[i]==true)\n\t\t\t\t{\n\t\t\t\t\tFind=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmaxdep=max(maxdep,dep[i]);\n\t\t\t}\n\t\tif(Find==true)\n\t\t\tprintf(\"-1\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",maxdep*2);\n\t}\n\treturn 0;\n}\n/*\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 400004\nint a[2][N],b[2][N],c[2][N],e[N],f[N],h[N],i,l,n,q[N],r,s[N],t,x,y;bool d[N][2];\ninline bool cmp(int u,int v){return f[u]!=v&&u!=f[v]&&f[u]!=f[v]&&f[f[u]]!=v&&u!=f[f[v]];}\nint u,v;\nint main()\n{\n\tfor(scanf(\"%d%d%d\",&n,&x,&y),i=t=1;i<n;i++)scanf(\"%d%d\",&u,&v),b[0][++t]=a[0][u],c[0][a[0][u]=t]=v,b[0][++t]=a[0][v],c[0][a[0][v]=t]=u;\n\tfor(i=t=1,e[n]=-1;i<n;e[i++]=-1)scanf(\"%d%d\",&u,&v),b[1][++t]=a[1][u],c[1][a[1][u]=t]=v,b[1][++t]=a[1][v],c[1][a[1][v]=t]=u;\n\tfor(d[q[r++]=x][e[x]=0]=true,d[q[r++]=y][e[y]=1]=true;l<r;)for(v=e[u=q[l++]],i=a[v][u];i;i=b[v][i])if(e[c[v][i]]<e[u])d[q[r++]=c[v][i]][e[c[v][i]]=e[u]]=true,f[c[v][i]]=u,h[c[v][i]]=h[u]+1;\n\tfor(i=1;i<n;i++)if(cmp(c[0][i<<1],c[0][i<<1|1])&&*d[c[0][i<<1]]&&*d[c[0][i<<1|1]])return 0&puts(\"-1\");\n\tfor(i=1,v=0;i<=n;i++)if(*d[i]&&v<h[i])v=h[i];\n\treturn 0&printf(\"%d\\n\",v<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\n#define lc (v * 2)\n#define rc (v * 2 + 1)\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n\nconst int N = 2e5 + 7;\n\nvector <int> rd[N], bd[N];\nint n, x, y;\nint h[N], dp[N][20];\n\nvoid dfs(int v, int p) {\n\tfor (auto u: bd[v])\n\t\tif (u != p) {\n\t\t\tdp[u][0] = v;\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u, v);\n\t\t}\n}\n\nint lca(int v, int u) {\n\tif (h[v] < h[u])\n\t\tswap(v, u);\n\tfor (int i = 19; i >= 0; i--)\n\t\tif (h[v] - (1 << i) >= h[u])\n\t\t\tv = dp[v][i];\n\tif (v == u)\n\t\treturn v;\n\tfor (int i = 19; i >= 0; i--)\n\t\tif (dp[v][i] != dp[u][i]) {\n\t\t\tv = dp[v][i];\n\t\t\tu = dp[u][i];\n\t\t}\n\treturn dp[v][0];\n}\n\nint dis(int v, int u) {\n\treturn h[v] + h[u] - 2 * h[lca(v, u)];\n}\nbool inf[N];\nint res = 0;\n\nvoid get(int v, int t, int p = 0) {\n//\tcout << \"get : \" << v << \" \" << t << endl;\n\tres = max(res, h[v] * 2);\n\tif (inf[v]) {\n\t\tcout << -1;\n\t\texit(0);\t\n\t}\n\tfor (auto u: rd[v])\n\t\tif (h[u] > t + 1 && u != p)\n\t\t\tget(u, t + 1, v);\n}\n\nint main() {\n\tmakefast;\n\tcin >> n >> x >> y;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\trd[v].push_back(u);\n\t\trd[u].push_back(v);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tbd[v].push_back(u);\n\t\tbd[u].push_back(v);\n\t}\n\tdfs(y, 0);\n\tfor (int j = 1; j < 20; j++)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tdp[i][j] = dp[dp[i][j - 1]][j - 1];\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (auto u: rd[v]) {\n\t\t\tif (dis(u, v) > 2) {\n\t\t\t\tinf[v] = inf[u] = 1;\n\t\t\t}\t\n\t\t}\n/*\tfor (int i = 1; i <= n; i++)\n\t\tif (inf[i])\n\t\t\tcout << \"inf : \" << i << endl;*/\n\tget(x, 0);\n\tcout << res;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> par;\n\nconst int N=200010;\n\nint n,x,y,cnt,a[N],b[N],G[N];\nint fa[N][20];\nstruct edge{\n  int t,nx;\n}E[N<<2];\n\ninline void addedge(int x,int y){\n  E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n  E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n}\n\nint dpt[N];\n\nvoid dfs(int x,int f){\n  if(f) dpt[x]=dpt[f]+1;\n  fa[x][0]=f; for(int i=1;i<=18;i++) fa[x][i]=fa[fa[x][i-1]][i-1];\n  for(int i=G[x];i;i=E[i].nx)\n    if(E[i].t!=f) dfs(E[i].t,x);\n}\n\nnamespace Grp{\n  int cnt,G[N];\n  struct edge{\n    int t,nx;\n  }E[N<<1];\n\n  inline void addedge(int x,int y){\n    E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n    E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n  }\n}\n\nqueue<int> Q;\nint dis[N],mark[N];\n\nconst int inf=1<<29;\n\ninline void bfs(){\n  for(int i=1;i<=n;i++) dis[i]=inf;\n  Q.push(x); dis[x]=0;\n  while(!Q.empty()){\n    int x=Q.front(); Q.pop();\n    for(int i=Grp::G[x];i;i=Grp::E[i].nx){\n      int v=Grp::E[i].t;\n      if(dis[v]!=inf) continue;\n      if(dis[x]+1>dpt[v]) continue;\n      dis[v]=dis[x]+1; Q.push(v);\n    }\n  }\n}\n\ninline int lca(int x,int y){\n  if(dpt[x]<dpt[y]) swap(x,y);\n  for(int i=18;~i;i--)\n    if(dpt[fa[x][i]]>=dpt[y]) x=fa[x][i];\n  if(x==y) return x;\n  for(int i=18;~i;i--)\n    if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n  return fa[x][0];\n}\n\ninline int dist(int x,int y){\n  return dpt[x]+dpt[y]-2*dpt[lca(x,y)];\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d\",&a[i],&b[i]);\n  for(int i=1,u,v;i<n;i++)\n    scanf(\"%d%d\",&u,&v),addedge(u,v);\n  dfs(y,0); dpt[0]=-1;\n  for(int i=1;i<n;i++)\n    if(dist(a[i],b[i])>2) mark[a[i]]=mark[b[i]]=1;\n    else Grp::addedge(a[i],b[i]);\n  bfs(); int ans=0;\n  if(mark[x]) return puts(\"-1\"),0;\n  for(int i=1;i<=n;i++){\n    if(mark[i] && dis[i]<dpt[i]) return puts(\"-1\"),0;\n    if(dis[i]<dpt[i]) ans=max(ans,dpt[i]*2);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 0x3f3f3f3f;\n\nint n, E, Ex, X, Y;\nint a[N], b[N], c[N], d[N];\nint fir[N], nex[N << 1], arr[N << 1], dep[N], fa[N];\nint firx[N], nexx[N << 1], arrx[N << 1], tim[N], tag[N];\nqueue<int> Q;\n\ninline void Add_Edge(int x, int y) {\n\tnex[++E] = fir[x];\n\tfir[x] = E; arr[E] = y;\n}\n\ninline void Add_Edge2(int x, int y) {\n\tnexx[++Ex] = firx[x];\n\tfirx[x] = Ex; arrx[Ex] = y;\n}\n\nvoid dfs(int x) {\n\tfor (int i = fir[x]; i; i = nex[i]) {\n\t\tif (arr[i] == fa[x]) continue;\n\t\tfa[arr[i]] = x;\n\t\tdep[arr[i]] = dep[x] + 1;\n\t\tdfs(arr[i]);\n\t}\n}\n\nint dis(int x, int y) {\n\tif (fa[x] == y || fa[y] == x) return 1;\n\tif (fa[fa[x]] == y || fa[fa[y]] == x || fa[x] == fa[y]) return 2;\n\telse return 3;\n}\n\nvoid bfs() {\n\ttim[X] = 0;\n\tQ.push(X);\n\twhile (!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tfor (int i = firx[x]; i; i = nexx[i]) {\n\t\t\tif (tim[arrx[i]] < inf) continue;\n\t\t\tif (tim[x] + 1 < dep[arrx[i]] && tim[x] + 1 < tim[arrx[i]]) {\n\t\t\t\ttim[arrx[i]] = tim[x] + 1;\n\t\t\t\tQ.push(arrx[i]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (tim[i] < inf) {\n\t\t\tif (tag[i]) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\telse ans = max(ans, dep[i] * 2);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &X, &Y);\n\tfor (int i = 1; i < n; ++i) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tscanf(\"%d%d\", &c[i], &d[i]);\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tAdd_Edge(c[i], d[i]);\n\t\tAdd_Edge(d[i], c[i]);\n\t}\n\tdfs(Y);\n\tfor (int i = 1; i < n; ++i) {\n\t\tAdd_Edge2(a[i], b[i]);\n\t\tAdd_Edge2(b[i], a[i]);\n\t\tif (dis(a[i], b[i]) == 3) tag[a[i]] = tag[b[i]] = 1;\n\t}\n\tmemset(tim, 0x3f, sizeof tim);\n\tbfs();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N], dfn;\nint dp[N][20], lg2[N], dph[N];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x])\n        if (y != fx) dfsb(y, x);\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] >= db[x]) return;\n    if (~ans) ans = max((db[x] - 1) << 1, ans);\n    for (int y : a[x]) {\n        if (db[x] + db[y] - 2 * db[LCA(x, y)] > 2) ans = -1;\n        if (y != fx) dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2000005;\n\nint N,X,Y;\nvector<int> red[MAXN],blue[MAXN];\nint dep[MAXN],fa[MAXN];\n\nbool isTable(int u,int v)\n{\n\tif(dep[u]>dep[v])\n\t\tswap(u,v);\n\tif(fa[v]==u||fa[fa[v]]==u||fa[u]==fa[v])\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs1(int u)\n{\n\tfor(auto v:blue[u])\n\t\tif(v!=fa[u])\n\t\t{\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs1(v);\n\t\t}\n}\nint dfs2(int u,int f=0,int step=0)\n{\n\tstep++;\n\tint res=dep[u];\n\tfor(auto v:red[u])\n\t{\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tif(isTable(u,v))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tres=max(res,dep[v]);\n\t\tif(dep[v]>step)\n\t\t\tres=max(res,dfs2(v,u,step));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&X,&Y);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred[u].push_back(v);\n\t\tred[v].push_back(u);\n\t}\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue[u].push_back(v);\n\t\tblue[v].push_back(u);\n\t}\n\tdfs1(Y);\n\tint ans=dfs2(X)*2;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005;\nint n,x,y;\nstruct node{\n    int u,v,nxt;\n}B[N*2],R[N*2];\nint hB[N];\nint hR[N];\nint Bcnt,Rcnt;\nint eu[N],ev[N];\nvoid add_B(int u,int v){\n    Bcnt++;\n    B[Bcnt].u=u;\n    B[Bcnt].v=v;\n    B[Bcnt].nxt=hB[u];\n    hB[u]=Bcnt;\n}\nvoid add_R(int u,int v){\n    Rcnt++;\n    R[Rcnt].u=u;\n    R[Rcnt].v=v;\n    R[Rcnt].nxt=hR[u];\n    hR[u]=Rcnt;\n}\nint deep[N],fa[N];\nint dfn[N],efn[N],tot;\nvoid dfs(int u,int dep){\n    deep[u]=dep;\n    dfn[u]=++tot;\n    for(int i=hB[u];i;i=B[i].nxt){\n        int v=B[i].v;\n        if(v==fa[u])\n            continue;\n        fa[v]=u;\n        dfs(v,dep+1);\n    }\n    efn[u]=++tot;\n}\nbool check(int x,int y){//Islongedge?\n    if(dfn[x]>dfn[y])\n        swap(x,y);\n    if(dfn[x]<=dfn[y]&&efn[y]<=efn[x])\n        return deep[y]-deep[x]>2;\n    return fa[x]!=fa[y];\n}\nbool Longedge[N];\nqueue<int>q;\nbool vis[N];\nint dist[N];\nvoid bfs(){\n    while(!q.empty())\n        q.pop();\n    vis[x]=1;\n    q.push(x);\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(int i=hR[u];i;i=R[i].nxt){\n            int v=R[i].v;\n            if(!vis[v]){\n                dist[v]=dist[u]+1;\n                if(dist[v]<deep[v]){\n                    vis[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    //freopen(\"coalesce.in\",\"r\",stdin);\n    //freopen(\"coalesce.out\",\"w\",stdout);\n    while(~scanf(\"%d%d%d\",&n,&x,&y)){\n        memset(hB,0,sizeof hB);\n        memset(hR,0,sizeof hR);\n        Bcnt=Rcnt=0;\n        memset(fa,0,sizeof fa);\n        tot=0;\n        memset(Longedge,0,sizeof Longedge);\n        memset(vis,0,sizeof vis);\n        memset(dist,0,sizeof dist);\n        for(int i=1;i<n;i++){\n            scanf(\"%d%d\",&eu[i],&ev[i]);\n        }\n        for(int i=1;i<n;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            add_B(u,v);\n            add_B(v,u);\n        }\n        dfs(y,0);\n        for(int i=1;i<n;i++){\n            int u=eu[i],v=ev[i];\n            if(check(u,v))\n                Longedge[u]=Longedge[v]=1;\n            else\n                add_R(u,v),add_R(v,u);\n        }\n        bfs();\n        int ans=0;\n        bool f=true;\n        for(int i=1;i<=n&&f;i++)\n            if(vis[i]&&Longedge[i]){\n                puts(\"-1\");\n                f=false;\n            }\n            else\n                if(vis[i])\n                    ans=max(ans,deep[i]*2);\n        if(f)\n            printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint main()\n{\n    puts(\"-1\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\nusing namespace std;\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1],e2[MAXN<<1];\n\nint n,x1,x2;\nint g[MAXN],nume;\nint g2[MAXN],nume2;\nint dep[MAXN],size[MAXN],son[MAXN],top[MAXN],pre[MAXN],w[MAXN],pt[MAXN],numw;\nint pre2[MAXN],h[MAXN],dep2[MAXN];\nbool flag;\nint ans;\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid addEdge2(int u,int v){\n\te2[nume2]=edge(v,g2[u]);\n\tg2[u]=nume2++;\n}\n\nvoid dfs(int x,int p){\n\tsize[x]=1; son[x]=0;\n\tpre[x]=p;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdep[e[i].to]=dep[x]+1;\n\t\t\tdfs(e[i].to,x);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t\tif(size[e[i].to]>size[son[x]])\n\t\t\t\tson[x]=e[i].to;\n\t\t}\n}\n\nvoid dfs2(int x,int p){\n\tpt[w[x]=++numw]=x;\n\tif(son[x]){\n\t\ttop[son[x]]=top[x];\n\t\tdfs2(son[x],x);\n\t}\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to!=p && e[i].to!=son[x]){\n\t\t\ttop[e[i].to]=e[i].to;\n\t\t\tdfs2(e[i].to,x);\n\t\t}\n}\n\nint getLCA(int x,int y){\n\twhile(top[x]^top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tx=pre[top[x]];\n\t}\n\treturn dep[x]<dep[y]?x:y;\n}\n\nint getDis(int x,int y){\n\treturn dep[x]+dep[y]-2*dep[getLCA(x,y)];\n}\n\nint goUp(int x,int d){\n\twhile(dep[x]-dep[top[x]]+1<=d){\n\t\td-=dep[x]-dep[top[x]]+1;\n\t\tx=pre[top[x]];\n\t}\n\treturn pt[w[x]-d];\n}\n\nint step(int x,int y){\n\tint lca=getLCA(x,y);\n\tif(lca!=x) return pre[x];\n\treturn goUp(y,dep[y]-dep[x]-1);\n}\n\nvoid dfs3(int x,int p){\n\tpre2[x]=p;\n\tfor(int i=g2[x];~i;i=e2[i].next)\n\t\tif(e2[i].to^p){\n\t\t\tint y=e2[i].to;\n\t\t\tint dis=getDis(x,y);\n\t\t\tif(dis>=3 && x!=h[x]) flag=1;\n\t\t\tif(y==h[x] || x==h[x]) continue;\n\t\t\th[y]=step(h[x],y);\n\t\t\tdep2[y]=dep2[x]+1;\n\t\t\tdfs3(y,x);\n\t\t}\n\tint res=getDis(h[x],x)*2+dep2[x]*2;\n\tans=max(ans,res);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tmemset(g2,-1,sizeof g2);\n\tscanf(\"%d%d%d\",&n,&x1,&x2);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t\taddEdge2(v,u);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\ttop[1]=1;\n\tdfs2(1,0);\n\th[x1]=x2;\n\tdfs3(x1,0);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5+7, K = 18;\n\nstruct Tree{\n    vector<int> adj[N];\n\n    int anc[N][K];\n    int level[N];\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    void setup(int u, int par) {\n        level[u] = level[par]+1;\n        anc[u][0] = par;\n        for (int k=1; k<K; k++)     anc[u][k] = anc[anc[u][k-1]][k-1];\n\n        for (int v: adj[u]) {\n            if (v == par)   continue;\n            setup(v, u);\n        }\n    }\n\n    int lca(int u, int v) {\n        if (level[u] > level[v])    swap(u, v);\n        for (int k=K-1; k>=0; k--)\n            if (level[u] + (1<<k) <= level[v])  v = anc[v][k];\n\n        if (u == v) return u;\n        for (int k=K-1; k>=0; k--)\n            if (anc[u][k] != anc[v][k])\n                u = anc[u][k], v = anc[v][k];\n        return anc[u][0];\n    }\n\n    int getanc(int u, int d) {\n        for (int k=0; k<K; k++)\n            if (d & (1<<k))\n                u = anc[u][k];\n        return u;\n    }\n\n    int dist(int u, int v) {\n        int g = lca(u, v);\n        return level[u] + level[v] - 2*level[g];\n    }\n};\n\n\n///Given u, v, d per query find dth node (0 indexed) on path from u to v.\n///https://codeforces.com/gym/102694/problem/C\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin>>n;\n\n    int x, y;\n    cin>>x>>y;\n\n    Tree red, blue;\n\n    for (int i=1; i<n; i++) {\n        int u, v;\n        cin>>u>>v;\n        red.addEdge(u, v);\n    }\n\n    for (int i=1; i<n; i++) {\n        int u, v;\n        cin>>u>>v;\n        blue.addEdge(u, v);\n    }\n\n    red.setup(1, 0);\n    blue.setup(1, 0);\n\n    int ans = 0;\n    for (int i=1; i<=n; i++) {\n        if (red.dist(x, i) >= blue.dist(y, i))  continue;\n        for (int v: red.adj[i]) {\n            if (blue.dist(i, v) >= 3) {\n                cout<<-1<<endl;\n                return 0;\n            }\n        }\n        ans = max(ans, blue.dist(y, i));\n    }\n    cout<<2*ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define per(i, a, b) for(int i = a; i >= b; i--)\ntypedef long long LL;\nconst int maxn = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\nint n, x, y, first[maxn], dep[maxn], s[maxn][2], f[maxn][27], g[maxn], dis[maxn], cnt;\nbool vis[maxn];\nstruct Edge {\n\tint to, next, ser;\n} e[maxn<<2];\n\nvoid Dfs(int u, int fa) {\n\tdep[u] = dep[fa] + 1;\n\tf[u][0] = fa;\n\tg[u] = dep[u];\n\tfor(int i = first[u]; i; i = e[i].next) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || e[i].ser) continue;\n\t\tDfs(v, u);\n\t\tg[u] = max(g[v], g[u]);\n\t}\n}\n\nvoid add(int u, int v, int ser) {\n\te[++cnt] = (Edge) {v, first[u], ser};\n\tfirst[u] = cnt;\n}\n\nint Lca(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tint dif = dep[u] - dep[v];\n\tper(i, 25, 0)\n\t    if(dif >= (1<<i)) {\n\t    \tdif -= 1<<i;\n\t    \tu = f[u][i];\n\t    }\n\tif(u == v) return u;\n\tper(i, 25, 0)\n\t    if(f[u][i] != f[v][i]) {\n\t    \tu = f[u][i];\n\t    \tv = f[v][i];\n\t    }\n\treturn f[u][0];\n}\n\n\nbool Bfs(int s) {\n\tmemset(dis, 0x7f, sizeof(dis));\n\tqueue <int> q;\n\tdis[s] = 0;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = first[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\tif(!e[i].ser || dis[u] + 1 >= dep[v] || dis[v] != 0x7f7f7f7f) continue;\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\trep(i, 1, n)\n\t    if(dis[i] < dep[i] && vis[i])\n\t    \treturn 1;\n\treturn 0;\n}\n\nint main() {\n\tcin>>n>>x>>y;\n\tint u, v;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ts[i][0] = u, s[i][1] = v;\n\t}\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 0);\n\t\tadd(v, u, 0);\n\t}\n\tdep[0] = -1;\n\tDfs(y, 0);\n\trep(k, 1, 25)\n\t    rep(i, 1, n) \n\t        f[i][k] = f[f[i][k - 1]][k - 1];\n\trep(i, 1, n - 1) {\n\t\tint d = Lca(s[i][0], s[i][1]);\n\t\tif(dep[s[i][0]] + dep[s[i][1]] - 2*dep[d] > 2) vis[s[i][0]] = vis[s[i][1]] = 1;\n\t\telse {\n\t\t\tadd(s[i][0], s[i][1], 1);\n\t\t\tadd(s[i][1], s[i][0], 1);\n\t\t}\n\t} \n\tif(Bfs(x)) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\telse {\n\t\tint ans = 0;\n\t\trep(i, 1, n)\n\t\t    if(dis[i] < dep[i]) ans = max(ans, dep[i]);\n\t\tcout<<ans*2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn(2e5 + 5);\n\nint n, x, y, lim[maxn], fa[maxn], ans, dis[maxn];\nqueue <int> q;\nvector <int> edge1[maxn], edge2[maxn];\n\n# define Orzyyb puts(\"-1\"), exit(0)\n\ninline void Add1(int u, int v) {\n\tedge1[u].push_back(v), edge1[v].push_back(u);\n}\n\ninline void Add2(int u, int v) {\n\tedge2[u].push_back(v), edge2[v].push_back(u);\n}\n\ninline int Dis(int x, int y) {\n\tif (fa[x] == y || fa[y] == x) return 1;\n\tif (fa[x] == fa[y] || fa[fa[x]] == y || fa[fa[y]] == x) return 2;\n\treturn 233;\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add1(u, v);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add2(u, v);\n\tlim[y] = 1, q.push(y);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tfor (auto to : edge2[u])\n\t\t\tif (!lim[to]) fa[to] = u, lim[to] = lim[u] + 1, q.push(to);\n\t}\n\tfor (i = 1; i <= n; ++i) --lim[i];\n\tdis[x] = 1, q.push(x);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tif (dis[u] - 1 > lim[u]) continue;\n\t\tans = max(ans, u == y ? 1 : lim[u]);\n\t\tfor (auto to : edge1[u]) if (Dis(u, to) > 2) exit(1), Orzyyb;\n\t\tfor (auto to : edge1[u])\n\t\t\tif (!dis[to]) dis[to] = dis[u] + 1, q.push(to);\n\t}\n\tprintf(\"%d\\n\", ans << 1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\nstruct Edge{\n    int from,to;\n    Edge(int from,int to)\n        : from(from),to(to){};\n    Edge(){Edge(0,0);}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct HeavyLightDecomposition{\n    vector<int> index, htop, hchild, par, dep, idtov, topo,sub,heads;\n    Graph T;\n    HeavyLightDecomposition(int n) :index(n,-1),htop(n),hchild(n,-1),par(n),dep(n),idtov(n),sub(n),T(n){}\n\n    void calc(int root){\n        queue<int> Q({root});\n        par[root]=-1;\n        while(!Q.empty()){\n            int curr=Q.front(); Q.pop(); topo.push_back(curr);\n            for(auto &x: T[curr]){\n                if(x.to!=par[curr]){\n                    par[x.to]=curr;\n                    Q.push(x.to);\n                    dep[x.to]=dep[curr]+1;\n                }\n            }\n        }\n        for(int i=par.size()-1,max_sub=0; i>=0; --i){\n            ++sub[topo[i]];\n            if(i>0)sub[par[topo[i]]]+=sub[topo[i]];\n            if(i>0 and i<par.size()-1)if(par[topo[i+1]]!=par[topo[i]])max_sub=0;\n            if(i>0 and sub[topo[i]]>max_sub) hchild[par[topo[i]]]=topo[i];\n            for(auto &x : T[topo[i]])if(x.to!=par[topo[i]] and x.to!=hchild[topo[i]]) heads.push_back(x.to);\n        }\n        heads.push_back(root);\n        reverse(heads.begin(),heads.end());\n        int id=0;\n        for(int x : heads) {\n            for(int i=x; i!=-1; i=hchild[i]){\n                index[i]=id++;\n                idtov[index[i]]=i;\n                htop[i]=x;\n            }\n        }\n    }\n    inline bool same(int a,int b){return htop[a]==htop[b];}\n\n    int lca(int a, int b){\n        if(index[a]>index[b])swap(a,b);\n        if(same(a,b)) return a;\n        return lca(a,par[htop[b]]);\n    }\n    int dist(int a, int b){\n        return dep[a]+dep[b]-2*dep[lca(a,b)];\n    }\n};\n\nstruct Problem{\n    int size,x,y;\n    HeavyLightDecomposition sigma,sugim;\n    Problem(int n):size(n),sigma(n),sugim(n){};\n\n    int dfs(int par, int cur, int d){\n        int d2=sugim.dist(cur,y);\n        if(d>=d2) return -INF;\n        if(sigma.T[cur].size()==1 and sigma.T[cur][0].to==par){\n            return d2;\n        }\n        int ret=d2;\n        for(auto e: sigma.T[cur]){\n            if(e.to!=par){\n                if(sugim.dist(cur,e.to)>=3) return INF;\n                ret=max(ret,dfs(cur,e.to,d+1));\n            }\n        }\n        return ret;\n    }\n\n    void solve(){\n        cin >> x >> y;\n        --x;--y;\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            sigma.T[a].push_back(Edge(a,b));\n            sigma.T[b].push_back(Edge(b,a));\n        }\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            sugim.T[a].push_back(Edge(a,b));\n            sugim.T[b].push_back(Edge(b,a));\n        }\n        //sigma.calc(x);\n        sugim.calc(y);\n        int ans=dfs(-1,x,0);\n        if(ans==INF)cout << -1 <<\"\\n\";\n        else cout << ans*2<<\"\\n\";\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    Problem e(n);\n    e.solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mxN=2e5;\nint n, r[2], d[2][mxN], p[mxN], ans;\nvector<int> adj[2][mxN];\n\nvoid dfs(int u, int k, int pu=-1) {\n\tif(k)\n\t\tp[u]=pu;\n\tif(!k&&d[0][u]>=d[1][u])\n\t\treturn;\n\tfor(int v : adj[k][u]) {\n\t\tif(v^pu) {\n\t\t\td[k][v]=d[k][u]+1;\n\t\t\tdfs(v, k, u);\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n >> r[0] >> r[1], --r[0], --r[1];\n\tfor(int k : {0, 1}) {\n\t\tfor(int i=1, a, b; i<n; ++i) {\n\t\t\tcin >> a >> b, --a, --b;\n\t\t\tadj[k][a].push_back(b);\n\t\t\tadj[k][b].push_back(a);\n\t\t}\n\t}\n\tmemset(d, 0x3f, 4*n);\n\td[0][r[0]]=0;\n\tfor(int k : {1, 0})\n\t\tdfs(r[k], k);\n\tfor(int i=0; i<n; ++i) {\n\t\tif(d[0][i]<=d[1][i])\n\t\t\tans=max(2*d[1][i], ans);\n\t\tif(d[0][i]>=d[1][i])\n\t\t\tcontinue;\n\t\tfor(int j : adj[0][i]) {\n\t\t\tif(p[i]^j&&p[j]^i&&p[i]^p[j]&&(p[i]<0||p[p[i]]^j)&&(p[j]<0||p[p[j]]^i)) {\n\t\t\t\tcout << -1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300000;\nint n, x, y;\nvector <int> bi[N], ci[N];\nint dep[N], fa[N], A[N], B[N], GG[N];\nvoid dfs1(int t, int f = 0, int d = 0)\n{\n    dep[t] = d; fa[t] = f;\n    for (int i = 0; i < ci[t].size(); ++ i)\n        if (ci[t][i] != f) dfs1(ci[t][i], t, d + 1);\n}\nint ans, loop;\nvoid dfs2(int t, int f = 0, int d = 0)\n{\n    if (GG[t]) loop = 1; ans = max(ans, dep[t]);\n    for (int i = 0; i < bi[t].size(); ++ i)\n        if (bi[t][i] != f && dep[bi[t][i]] > d + 1) dfs2(bi[t][i], t, d + 1);\n}\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 1; i < n; ++ i)\n    {\n        int a, b;\n        cin >> a >> b;\n        bi[a].push_back(b);\n        bi[b].push_back(a);\n        A[i] = a; B[i] = b;\n    }\n    for (int i = 1; i < n; ++ i)\n    {\n        int a, b;\n        cin >> a >> b;\n        ci[a].push_back(b);\n        ci[b].push_back(a);\n    }\n    dfs1(y);\n    for (int i = 1; i < n; ++ i)\n    {\n        if (fa[fa[A[i]]] == B[i] || fa[A[i]] == fa[B[i]] || A[i] == fa[fa[B[i]]] || fa[A[i]] == B[i] || A[i] == fa[B[i]]);\n        else GG[A[i]] = GG[B[i]] = 1;\n    }\n    dfs2(x);\n    if (loop) cout << -1 << endl; else cout << ans * 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct edges\n{\n\tint to,next;\n}edge[808080];\nint firstr[202020],firstb[202020],now;\nvoid adde(int *first,int x,int y)\n{\n\tnow++;\n\tedge[now].to=y;\n\tedge[now].next=first[x];\n\tfirst[x]=now;\n}\nint dep[202020],fa[202020];\nint dis[202020],mi[202020];\nbool mk[202020];\nvoid work(int p)\n{\n\tfor(int e=firstb[p];e;e=edge[e].next)\n\t\tif(edge[e].to!=fa[p])\n\t\t{\n\t\t\tdep[edge[e].to]=dep[p]+1;\n\t\t\tfa[edge[e].to]=p;\n\t\t\twork(edge[e].to);\n\t\t}\n}\nvoid finddis(int p,int fa1)\n{\n\tfor(int e=firstr[p];e;e=edge[e].next)\n\t\tif(edge[e].to!=fa1)\n\t\t{\n\t\t\tdis[edge[e].to]=dis[p]+1;\n\t\t\tmi[edge[e].to]=mi[p];\n\t\t\tif(dep[edge[e].to]<dep[mi[p]])\n\t\t\t\tmi[edge[e].to]=edge[e].to;\n\t\t\tfinddis(edge[e].to,p);\n\t\t}\n}\nint getdis(int x,int y)\n{\n\tint ret=0;\n\twhile(ret<3&&x!=y)\n\t{\n\t\tif(dep[x]>=dep[y])\n\t\t{\n\t\t\tx=fa[x];\n\t\t\tret++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty=fa[y];\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n,a,b,x,y;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tmemset(mk,0,sizeof(mk));\n\tmemset(firstr,0,sizeof(firstr));\n\tmemset(firstb,0,sizeof(firstb));\n\tnow=0;\n\tdep[0]=n+1;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(firstr,a,b);\n\t\tadde(firstr,b,a);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(firstb,a,b);\n\t\tadde(firstb,b,a);\n\t}\n\tdep[y]=fa[y]=0;\n\twork(y);\n\tdis[x]=0;\n\tmemset(mi,0,sizeof(mi));\n\tfinddis(x,0);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int e=firstr[i];e;e=edge[e].next)\n\t\t\tif(getdis(i,edge[e].to)>=3)\n\t\t\t\tmk[i]=mk[edge[e].to]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(mk[i]&&dis[mi[i]]<dep[mi[i]])\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(dis[mi[i]]<dep[mi[i]])\n\t\t\tans=max(ans,dep[i]);\n\tprintf(\"%d\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\nusing namespace std;\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1],e2[MAXN<<1];\n\nint n,x1,x2;\nint g[MAXN],nume;\nint g2[MAXN],nume2;\nint dep[MAXN],size[MAXN],son[MAXN],top[MAXN],pre[MAXN],w[MAXN],pt[MAXN],numw;\nint pre2[MAXN],h[MAXN],dep2[MAXN];\nbool flag;\nint ans;\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid addEdge2(int u,int v){\n\te2[nume2]=edge(v,g2[u]);\n\tg2[u]=nume2++;\n}\n\nvoid dfs(int x,int p){\n\tsize[x]=1; son[x]=0;\n\tpre[x]=p;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdep[e[i].to]=dep[x]+1;\n\t\t\tdfs(e[i].to,x);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t\tif(size[e[i].to]>size[son[x]])\n\t\t\t\tson[x]=e[i].to;\n\t\t}\n}\n\nvoid dfs2(int x,int p){\n\tpt[w[x]=++numw]=x;\n\tif(son[x]){\n\t\ttop[son[x]]=top[x];\n\t\tdfs2(son[x],x);\n\t}\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to!=p && e[i].to!=son[x]){\n\t\t\ttop[e[i].to]=e[i].to;\n\t\t\tdfs2(e[i].to,x);\n\t\t}\n}\n\nint getLCA(int x,int y){\n\twhile(top[x]^top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tx=pre[top[x]];\n\t}\n\treturn dep[x]<dep[y]?x:y;\n}\n\nint getDis(int x,int y){\n\treturn dep[x]+dep[y]-2*dep[getLCA(x,y)];\n}\n\nint goUp(int x,int d){\n\twhile(dep[x]-dep[top[x]]+1<d){\n\t\td-=dep[x]-dep[top[x]]+1;\n\t\tx=pre[top[x]];\n\t}\n\treturn pt[w[x]-d];\n}\n\nint step(int x,int y){\n\tint lca=getLCA(x,y);\n\tif(lca!=x) return pre[x];\n\treturn goUp(y,dep[y]-dep[x]-1);\n}\n\nvoid dfs3(int x,int p){\n\tpre2[x]=p;\n\tfor(int i=g2[x];~i;i=e2[i].next)\n\t\tif(e2[i].to^p){\n\t\t\tint y=e2[i].to;\n\t\t\tint dis=getDis(x,y);\n\t\t\tif(dis>=3 && x!=h[x]) flag=1;\n\t\t\tif(y==h[x] || x==h[x]) continue;\n\t\t\th[y]=step(h[x],y);\n\t\t\tdep2[y]=dep2[x]+1;\n\t\t\tdfs3(y,x);\n\t\t}\n\tint res=getDis(h[x],x)*2+dep2[x]*2;\n\tans=max(ans,res);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tmemset(g2,-1,sizeof g2);\n\tscanf(\"%d%d%d\",&n,&x1,&x2);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t\taddEdge2(v,u);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\ttop[1]=1;\n\tdfs2(1,0);\n\th[x1]=x2;\n\tdfs3(x1,0);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// thank you, 19-minute version of \"lady madonna\" by the rose hill junior high school jazz ensemble, for giving me something to listen to a few times while i wrote this here internet code\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(n);i++)\n#define per(i,a,n) for (int i=(n)-1;i>=(a);i--)\ntypedef long long ll;\nconst int N = 2e5 + 10;\nconst int LOG = 20;\nvector<int> f[N], g[N];\nint n, X, Y;\nint dist[N];\nint dist2[N];\nint pred[LOG][N];\nbool saved[N];\nint ans = 0;\n\nvoid dfs0(int a, int from) {\n    for (auto b : g[a]) {\n        if (b == from) continue;\n        dist[b] = dist[a] + 1;\n        pred[0][b] = a;\n        dfs0(b, a);\n    }\n}\n\nint getDistance(int a, int b) {\n    //cout << a << \"/\" << b << endl;\n    int res = dist[a] + dist[b];\n    if (dist[a] < dist[b]) swap(a, b);\n    int log = LOG - 1;\n    while (log >= 0) {\n        if (pred[log][a] == -1 || dist[pred[log][a]] < dist[b]) {\n            log--;\n        } else {\n            a = pred[log][a];\n        }\n    }\n    //cout << \"-> \" << a << \" \" << b << endl;\n    if (a == b) {\n        res -= 2 * dist[a];\n        return res;\n    }\n    log = LOG - 1;\n    while (log >= 0) {\n        assert(a != b);\n        if (pred[log][a] == pred[log][b]) {\n            log--;\n        } else {\n            a = pred[log][a];\n            b = pred[log][b];\n        }\n    }\n    res -= 2 * dist[pred[0][a]];\n    return res;\n}\n\nvoid dfs1(int a, int from) {\n    for (auto b : f[a]) {\n        if (b == from) continue;\n        dist2[b] = dist2[a] + 1;\n        dfs1(b, a);\n    }\n}\n\nvoid dfs2(int a, int from, int t) {\n    if (dist[a] <= t) return;\n    if (saved[a]) {\n        cout << -1 << endl;\n        exit(0);\n    }\n    ans = max(ans, dist[a]);\n    for (auto b : f[a]) {\n        if (b == from) continue;\n        dfs2(b, a, t + 1);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> X >> Y;\n    X--, Y--;\n    vector<pair<int, int>> ev;\n    rep(i, 0, n - 1) {\n        int x, y;\n        cin >> x >> y;\n        f[x - 1].push_back(y - 1);\n        f[y - 1].push_back(x - 1);\n        ev.push_back({x - 1, y - 1});\n    }\n    \n    rep(i, 0, n - 1) {\n        int x, y;\n        cin >> x >> y;\n        g[x - 1].push_back(y - 1);\n        g[y - 1].push_back(x - 1);\n        \n    }\n    dist[Y] = 0;\n    pred[0][Y] = -1;\n    dfs0(Y, -1);\n    \n    dist2[X] = 0;\n    dfs1(X, -1);\n    \n    rep(l, 1, LOG) {\n        rep(i, 0, N) {\n            if (pred[l - 1][i] == -1) pred[l][i] = -1;\n            else pred[l][i] = pred[l - 1][pred[l - 1][i]];\n        }\n    }\n    \n    //rep(i, 0, n) cout << pred[0][i] << \" / \" << dist2[i] << endl;\n    \n    for (auto e : ev) {\n        //cout << e.first << \"/\" << e.second << \": \" << getDistance(e.first, e.second) << endl;\n        if (getDistance(e.first, e.second) > 2) {\n            for (auto x : {e.first, e.second}) {\n                /*if (dist2[x] < dist[x]) {\n                    cout << -1 << endl;\n                    exit(0);\n                }*/\n                saved[x] = true;\n            }\n        }\n    }\n    \n    dfs2(X, -1, 0);\n    cout << (ans) * 2 << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\n\nconst int N=200005;\nint n,U,R,dep[N],fa[N],m;\nvector<int>er[N],eb[N];\n\nvoid dfs(int x){for(int v:eb[x])if(v!=fa[x])fa[v]=x,dep[v]=dep[x]+1,dfs(v);}\ninline bool check(int u,int v){\n\tif(dep[u]<dep[v]) swap(u,v);\n\tint d=0;\n\twhile(++d<=2&&u!=v)if(dep[u]<dep[v])v=fa[v];else u=fa[u];\n\treturn u==v;\n}\nvoid dfs(int x,int fa,int k){\n\tm=max(m,dep[x]);\n\tif(dep[x]<=k)return;\n\tfor(int v:er[x])if(v!=fa){\n\t\tif(!check(x,v))puts(\"-1\"),exit(0);\n\t\tdfs(v,x,k+1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&U,&R);\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),er[u].pb(v),er[v].pb(u);\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),eb[u].pb(v),eb[v].pb(u);\n\tdfs(R),dfs(U,0,0);\n\tprintf(\"%d\\n\",m<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxn = 2e6 + 5;\nvector<int> blue[maxn], red[maxn];\nint dep[maxn], fa[maxn], dp[maxn];\nbool safe[maxn], vis[maxn];\nvoid dfs(int v, int p) {\n    fa[v] = p;\n    for (int i=0; i<blue[v].size(); i++) if(blue[v][i] != p) {\n        dep[blue[v][i]] = dep[v] + 1;\n        dfs(blue[v][i], v);\n    }\n}\nbool atMost2(int x, int y) {\n    return (fa[x] == fa[y]) || (fa[x] == y) || (x == fa[y]) || (fa[fa[x]] == y) || (x == fa[fa[y]]);\n}\nint main() {\n    int n, X, Y, x, y;\n    scanf(\"%d %d %d\", &n, &X, &Y);\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        red[x].push_back(y), red[y].push_back(x);\n    }\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        blue[x].push_back(y), blue[y].push_back(x);\n    }\n    dfs(Y, -1);\n    for (int i=1; i<=n; i++)\n        for (int j=0; j<red[i].size(); j++)\n            if (!atMost2(i, red[i][j]))\n                safe[i] = safe[red[i][j]] = 1;\n    if (safe[X]) {puts(\"-1\"); return 0;}\n    memset(dp, -1, sizeof(dp));\n    queue<int> q;\n    q.push(X); dp[X] = 0; vis[X] = 0;\n    int ans = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (dp[u] >= dep[u]) continue;\n        if (safe[u]) {puts(\"-1\"); return 0;}\n        ans = max(ans, dep[u] * 2);\n        for (int i=0; i<red[u].size(); i++) {\n            int v = red[u][i];\n            if (!vis[v] && dp[u] + 1 < dep[v] && atMost2(u, v)) {\n                dp[v] = dp[u] + 1;\n                vis[v] = 1;\n                q.push(v);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int,int> ii;\ntypedef pair<ii,int> iii;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define RST(i,n) memset(i,n,sizeof i)\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(),a.end()\n#define X first\n#define Y second\n#define eb emplace_back\n#ifdef cold66\n#define debug(...) do{\\\n    fprintf(stderr,\"LINE %d: (%s) = \",__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#endif // cold66\n//}\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\n\nconst ll MAXn=2e5+5,MAXlg=__lg(MAXn)+2;\nconst ll MOD=1000000007;\nconst ll INF=0x3f3f3f3f;\n\nint n,X,Y;\nint ans = 0;\nvector<int> r[MAXn],b[MAXn];\nint ancb[MAXlg][MAXn],depb[MAXn];\nvoid dfsb(int x,int p){\n    if (x != p) depb[x] = depb[p] + 1;\n    debug(x,depb[x]);\n    ancb[0][x] = p;\n    for (int i=1;1<<i < MAXn;++i) {\n        ancb[i][x] = ancb[i-1][ancb[i-1][x]];\n    }\n    for (auto i:b[x]) {\n        if (i == p) continue;\n        dfsb(i,x);\n    }\n}\nint LCA(int x,int y){\n    if (depb[x] < depb[y]) {\n        swap(x,y);\n    }\n    for (int i=MAXlg-1;i>=0;--i) {\n        if (((depb[x] - depb[y])>>i)&1) {\n            x = ancb[i][x];\n        }\n    }\n    if (x == y) return x;\n    for (int i=MAXlg-1;i>=0;--i) {\n        if (ancb[i][x] != ancb[i][y]) {\n            x = ancb[i][x];\n            y = ancb[i][y];\n        }\n    }\n    return ancb[0][x];\n}\nint dis(int x,int y){\n    int lca = LCA(x,y);\n    debug(x,y,lca);\n    return depb[x] + depb[y] - 2 * depb[lca];\n}\nvoid dfsr(int x,int p,int d){\n    debug(x,p,d,depb[x]);\n    ans = max(ans,depb[x] * 2);\n    for (auto i:r[x]) {\n        if (i == p) continue;\n        if (dis(x,i) >= 3) {\n            debug(x,i);\n            ans = INF;\n            break;\n        }\n        if (d + 1 < depb[i]) dfsr(i,x,d+1);\n        else if (d + 1 == depb[i]) ans = max(ans,depb[i] * 2);\n    }\n}\nint main(){\n    IOS();\n    cin >> n >> X >> Y;\n    for (int i=0;i<n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        r[u].eb(v);\n        r[v].eb(u);\n    }\n    for (int i=0;i<n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        b[u].eb(v);\n        b[v].eb(u);\n    }\n    dfsb(Y,Y);\n    dfsr(X,X,0);\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"ctime\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Lowest_Common_Ancestor {\n\tvector<int>depth;\n\tvector<vector<int>>parent;\n\tvector<vector<int>>edge;\n\tint height = 0;\n\tint node;\npublic:\n\tLowest_Common_Ancestor(int num) {\n\t\tnum++;\n\t\tnode = num;\n\t\twhile (num) {\n\t\t\theight++;\n\t\t\tnum /= 2;\n\t\t}\n\t\tparent.resize(height);\n\t\tedge.resize(node);\n\t\tdepth.resize(node);\n\t\tfor (int i = 0; i < height; i++)parent[i].resize(node);\n\t}\n\tvoid Add_Edge(int a, int b) {\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\treturn;\n\t}\n\tvoid Update(int rtnode) {\n\t\tqueue<int>QQ;\n\t\tfor (int i = 0; i < node; i++) depth[i] = INT_MAX;\n\t\tdepth[rtnode] = 0;\n\t\tQQ.push(rtnode);\n\t\twhile (!QQ.empty()) {\n\t\t\tint c = QQ.front();\n\t\t\tfor (auto i : edge[c]) {\n\t\t\t\tif (depth[i] > depth[c] + 1) {\n\t\t\t\t\tdepth[i] = depth[c] + 1;\n\t\t\t\t\tQQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQQ.pop();\n\t\t}\n\t\tparent[0][rtnode] = -1;\n\t\tfor (int i = 1; i < node; i++) {\n\t\t\tfor (auto j : edge[i]) {\n\t\t\t\tif (depth[i] - 1 == depth[j]) {\n\t\t\t\t\tparent[0][i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < height - 1; i++) {\n\t\t\tfor (int j = 0; j < node; j++) {\n\t\t\t\tif (parent[i][j] < 0)parent[i + 1][j] = -1;\n\t\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint LCA(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tif ((depth[v] - depth[u]) >> i & 1) {\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int i = height - 1; i >= 0; i--) {\n\t\t\tif (parent[i][v] != parent[i][u]) {\n\t\t\t\tu = parent[i][u];\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\tint Dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - depth[LCA(u, v)] * 2;\n\t}\n};\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tvector<vector<int>>edge(N + 1);\n\tLowest_Common_Ancestor lca(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tedge[H].push_back(W);\n\t\tedge[W].push_back(H);\n\t}\n\tvector<vector<int>>wedge(N + 1);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\twedge[H].push_back(W);\n\t\twedge[W].push_back(H);\n\t\tlca.Add_Edge(H, W);\n\t}\n\tlca.Update(R);\n\tvector<int>safe(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (lca.Dist(i, j) > 2)safe[i] = safe[j] = 1;\n\t\t}\n\t}\n\tvector<int>depth(N + 1, MOD);\n\tCalculate_Depth(wedge, depth, R);\n\tvector<int>dist(N + 1, MOD);\n\tdist[L] = 0;\n\tqueue<int>Q;\n\tQ.push(L);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tif (safe[cn]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (auto i : edge[cn]) {\n\t\t\tauto dis = lca.Dist(i, cn);\n\t\t\tif (dis > 2)continue;\n\t\t\tif (dist[i] > dist[cn] + 1 ) {\n\t\t\t\tif (dist[cn] + 1 < depth[i]) {\n\t\t\t\t\tdist[i] = dist[cn] + 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\telse if (dist[cn] + 1 == depth[i]) {\n\t\t\t\t\tdist[i] = dist[cn] + 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (dist[i] == MOD)continue;\n\t\tans = max(ans, depth[i]);\n\t}\n\tcout << (ans << 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nconst int N=5e5;\nint fa[N],dep2[N],dep1[N],n,ans;\nstruct TREE\n{\n    int fst[N],nxt[N],to[N],mm;\n    void ade(int u,int v){to[++mm]=v,nxt[mm]=fst[u],fst[u]=mm;}\n}e1,e2;\nvoid dfs2(int u,int Fa)\n{\n    fa[u]=Fa;\n    for(int i=e2.fst[u];i;i=e2.nxt[i])\n    {\n        int v=e2.to[i];if(v==Fa)continue;\n        dep2[v]=dep2[u]+1;dfs2(v,u);\n    }\n}\nint check(int u,int v)\n{\n    if(dep2[u]==dep2[v])return fa[u]!=fa[v];\n    if(dep2[u]>dep2[v])swap(u,v);\n    return fa[v]!=u&&fa[fa[v]]!=u;\n}\nvoid dfs1(int u,int Fa)\n{\n    ans=max(ans,dep2[u]);\n    for(int i=e1.fst[u];i;i=e1.nxt[i])\n    {\n        int v=e1.to[i];if(v==Fa)continue;\n        dep1[v]=dep1[u]+1;if(dep2[v]<=dep1[v])continue;\n        if(check(u,v)){puts(\"-1\");exit(0);}\n        dfs1(v,u);\n    }\n}\nint main()\n{\n    int X,Y;\n    scanf(\"%d%d%d\",&n,&X,&Y);\n    for(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),e1.ade(u,v),e1.ade(v,u);\n    for(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),e2.ade(u,v),e2.ade(v,u);\n    dfs2(Y,0),dfs1(X,0);\n    cout<<ans*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX_LG = 20;\nconst int MAX_N = 2e5 + 5;\nconst int INF = 1e9 + 5;\n\nnamespace Ender {\n  vector<int> adj [MAX_N];\n  int par [MAX_N];\n  int lvl [MAX_N];\n  int lend [MAX_N], rend [MAX_N];\n  int jmp [MAX_N][MAX_LG];\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  int lca (int u, int v) {\n    if (lvl[u] < lvl[v]) swap(u, v);\n\n    int diff = lvl[u] - lvl[v];\n    for (int i = 0; i < MAX_LG; i++) {\n      if (diff & 1 << i) {\n        u = jmp[u][i];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int i = MAX_LG - 1; i >= 0; i--) {\n      if (jmp[u][i] != jmp[v][i]) {\n        u = jmp[u][i];\n        v = jmp[u][i];\n      }\n    }\n    return jmp[u][1];\n  }\n\n  int dist (int u, int v) {\n    return lvl[u] + lvl[v] - 2 * lvl[lca(u, v)];\n  }\n  \n  void dfs (int u, int p, int &cur) {\n    jmp[u][0] = p;\n    for (int i = 1; i < MAX_LG; i++) {\n      jmp[u][i] = jmp[jmp[u][i - 1]][i - 1];\n    }\n    \n    cur++;\n    lend[u] = cur;\n    lvl[u] = lvl[p] + 1;\n    par[u] = p;\n\n    for (int nxt : adj[u]) {\n      if (nxt != p) {\n        dfs(nxt, u, cur);\n      }\n    }\n    \n    rend[u] = cur;\n  }\n  \n  void build () {\n    int cur = 0;\n    dfs(1, 0, cur);\n  }\n  \n  bool islong (int u, int v) {\n    if (u == v) return false; // dist 0\n    if (par[u] == v || par[v] == u) return false; // dist 1\n    if (par[par[u]] == v || par[par[v]] == u) return false; // dist 2, grandparent\n    if (par[u] == par[v]) return false; // dist 2, cousin\n    return true;\n  }\n\n  int towards (int cur, int tar) {\n    if (cur == tar) return cur;\n    if (lend[tar] < lend[cur] || rend[cur] < lend[tar]) return par[cur];\n    for (int nxt : adj[cur]) {\n      if (nxt != par[cur]) {\n        if (lend[nxt] <= lend[tar] && rend[tar] <= rend[nxt]) {\n          return nxt;\n        }\n      }\n    }\n    assert(false);\n  }\n}\n\nnamespace Delayer {\n  vector<int> adj [MAX_N];\n  int special [MAX_N];\n  \n  vector<pair<int, int>> edges;\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    edges.push_back(make_pair(u, v));\n  }\n\n  void build () {\n    for (auto pr : edges) {\n      if (Ender::islong(pr.first, pr.second)) {\n        special[pr.first] = 1;\n        special[pr.second] = 1;\n      }\n    }\n  }\n}\n\nint play (int d, int dl, int e) {\n  /*\n  for (int i = 0; i < 2 * dpt; i++) {\n    cout << \" \";\n  }\n  cout << d << \" \" << e << endl;\n  */  \n\n  if (e == d) return 0;\n  if (Delayer::special[d]) return INF;\n  \n  int ans = 2 * Ender::dist(d, e);\n  for (int nxt : Delayer::adj[d]) {\n    if (nxt != dl) {\n      ans = max(ans, 2 + play(nxt, d, Ender::towards(e, nxt)));\n    }\n  }\n  return ans;\n}\n\nint main () {\n  int n, x, y;\n  cin >> n >> x >> y;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Delayer::add_edge(u, v);\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Ender::add_edge(u, v);\n  }\n\n  Ender::build();\n  Delayer::build();\n\n  int ans = play(x, -1, y);\n  if (ans >= INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 200010;\n\nvi g[2][maxn];\nint dep[maxn], par[maxn]; //sugim\n\nvoid dfs(int v, int p, int d) { //on sugim\n\tdep[v] = d;\n\tpar[v] = p;\n\tfor (int to : g[1][v]) if (to != p) {\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nbool far(int a, int b) { //on sugim, 3\n\tif (dep[a] > dep[b]) swap(a, b);\n\tif (a == b || par[b] == a || par[a] == par[b] || (par[b] != -1 && par[par[b]] == a)) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\nconst int INF = 1e8;\n\nint DFS(int v, int p, int d) { //on sigma\n\tint res = (dep[v] - d) * 2;\n\tfor (int to : g[0][v]) if (to != p) {\n\t\tif (dep[to] > d+1) {\n\t\t\tres = max(res, DFS(to, v, d + 1) + 2);\n\t\t}\n\t\tif (far(v, to)) {\n\t\t\tres = max(res, INF);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, X, Y;\n\tcin >> N >> X >> Y; --X; --Y;\n\n\trep(t, 2) {\n\t\trep(i, N-1) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tg[t][a].pb(b); g[t][b].pb(a);\n\t\t}\n\t}\n\n\tdfs(Y, -1, 0);\n\tint ans = DFS(X, -1, 0);\n\tif (ans >= INF) ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define per(i, a, b) for(int i=(b)-1; i>=(a); i--)\n#define sz(a) (int)a.size()\n#define de(a) cout << #a << \" = \" << a << endl\n#define dd(a) cout << #a << \" = \" << a << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef double db;\n\nvoid file_put() {\n    freopen(\"filename.in\", \"r\", stdin);\n    freopen(\"filename.out\", \"w\", stdout);\n}\n\nconst int N=2e5+5;\nint n,X,Y,d[N],f[N],ret=0,x,y; vi R[N],B[N];\n\nbool check(int x,int y) {\n\tif (!y) return 1;\n\tif (f[x]==y || f[y]==x) return 1;\n\tif (f[f[x]]==y || f[f[y]]==x) return 1;\n\treturn f[x]==f[y];\n}\n\nvoid dfs(int x,int p) {\n\td[x]=d[p]+1,f[x]=p;\n\tfor (auto y: B[x]) if (y!=p) dfs(y,x);\n}\n\nvoid dfs(int x,int p,int k) {\n\tif (!check(x,p)) {\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t}\n\tret=max(ret,d[x]);\n\tfor (auto y: R[x]) if (y!=p && d[y]>k+1) dfs(y,x,k+1);\n}\n\nint main() {\n//\tfile_put();\n\t\n\tscanf(\"%d%d%d\",&n,&X,&Y),d[0]=-1;\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),R[x].pb(y),R[y].pb(x);\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),B[x].pb(y),B[y].pb(x);\n\tdfs(Y,0),dfs(X,0,0);\n\tprintf(\"%d\\n\",ret<<1);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=200005;\n\nint n,X,Y,ncnt;\nint dfn[MAXN],efn[MAXN],fa[MAXN],dep[MAXN];\nstruct node{\n    int v,nex;\n}E[MAXN],G[MAXN];\nint Ehead[MAXN],Ghead[MAXN],dcnt[2];\nbool tag[MAXN];\npair<int,int> a[MAXN];\n\nvoid addedge(node edge[],int head[],int &cnt,int u,int v){\n    node &p=edge[++cnt];\n    p.v=v;\n    p.nex=head[u];\n    head[u]=cnt;\n}\n\nvoid dfs(int u,int fa=0){\n    ::fa[u]=fa;\n    dep[u]=dep[fa]+1;\n    dfn[u]=++ncnt;\n    for(int i=Ghead[u];i;i=G[i].nex){\n        int v=G[i].v;\n        if(v==fa) continue;\n        dfs(v,u);\n    }\n    efn[u]=++ncnt;\n}\n\nbool check(int u,int v){\n    if(dfn[u]>dfn[v]) swap(u,v);\n    if(dfn[u]<dfn[v]&&efn[v]<efn[u])\n        return dep[v]-dep[u]>=3;\n    return fa[u]!=fa[v];\n}\n\nint vis[MAXN],dis[MAXN],deq[MAXN],l,r;\nvoid bfs(){\n    for(int i=1;i<=n;i++) vis[i]=dis[i]=0;\n    l=r=1;\n    vis[X]=1;\n    deq[r++]=X;\n    while(l<r){\n        int u=deq[l++];\n        for(int i=Ehead[u];i;i=E[i].nex){\n            int v=E[i].v;\n            if(vis[v]) continue;\n            vis[v]=1;\n            dis[v]=dis[u]+1;\n            if(dis[v]<dep[v])\n                deq[r++]=v;\n        }\n    }\n}\n\nint main(){\n\n    dep[0]=-1;\n    while(~scanf(\"%d%d%d\",&n,&X,&Y)){\n        for(int i=1;i<=n;i++) Ehead[i]=Ghead[i]=0;\n        dcnt[0]=dcnt[1]=ncnt=0;\n        for(int i=1;i<=n;i++) tag[i]=0;\n        for(int i=1;i<n;i++) scanf(\"%d%d\",&a[i].first,&a[i].second);\n        for(int i=1;i<n;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            addedge(G,Ghead,dcnt[1],u,v);\n            addedge(G,Ghead,dcnt[1],v,u);\n        }\n        puts(\"check\");\n        dfs(Y);\n        for(int i=1;i<n;i++)\n            if(check(a[i].first,a[i].second)) tag[a[i].first]=tag[a[i].second]=1;\n            else addedge(E,Ehead,dcnt[0],a[i].first,a[i].second),addedge(E,Ehead,dcnt[0],a[i].second,a[i].first);\n        bfs();\n        int ans=0;\n        bool flag=1;\n        for(int i=1;i<=n&&flag;i++){\n            if(!vis[i]) continue;\n            if(tag[i]) flag=0;\n            else ans=max(ans,2*dep[i]);\n        }\n        printf(\"%d\\n\",flag?ans:-1);\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200010;\n\ntemplate<typename T> inline T read() {\n\tT x(0), f(1);\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint e, st[MAXN], to[MAXN<<1];\nint nxt[MAXN<<1];\ninline void add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e;\n}\n\nint E, St[MAXN], To[MAXN<<1];\nint Nxt[MAXN<<1];\ninline void Add(int u, int v) {\n\tTo[++E] = v, Nxt[E] = St[u];\n\tSt[u] = E;\n}\n\nint n, dep[MAXN], rx, ry;\nint fa[MAXN][20], ans;\nbool vis[MAXN], flag;\n\nvoid dfs(int u) {\n\tfor(int i = st[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif(v == fa[u][0]) continue;\n\t\tdep[v] = dep[u]+1;\n\t\tfa[v][0] = u, dfs(v);\n\t}\n}\n\ninline int LCA(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tfor(int i = 18; i >= 0; i--) \n\t\tif(dep[fa[u][i]] >= dep[v]) \n\t\t\tu = fa[u][i];\n\tif(v == u) return u;\n\tfor(int i = 18; i >= 0; i--) \n\t\tif(fa[u][i] ^ fa[v][i])\n\t\t\tu = fa[u][i], v = fa[v][i];\n\treturn fa[u][0];\n}\n\nvoid Dfs(int u, int d) {\n\tvis[u] = true;\n\t//printf(\"%d %d\\n\", u, dep[u]);\n\tans = max(ans, (dep[u]-1)<<1);\n\tfor(int i = St[u]; i; i = Nxt[i]) {\n\t\tint v = To[i];\n\t\tif(vis[v]) continue;\n\t\tif(dep[v] <= d+1) continue;\n\t\tint lca = LCA(u, v);\n\t\tif(dep[u]+dep[v]-(dep[lca]<<1) > 2) flag = true;\n\t\tDfs(v, d+1);\n\t}\n}\n\nint main() {\n\tn = read<int>();\n\trx = read<int>(), ry = read<int>();\n\tfor(int i = 1; i < n; i++) {\n\t\tint u = read<int>(), v = read<int>();\n\t\tAdd(u, v), Add(v, u);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint u = read<int>(), v = read<int>();\n\t\tadd(u, v), add(v, u);\n\t}\n\tdep[ry] = 1;\n\tdfs(ry);\n\tfor(int k = 1; k <= 18; k++) \n\t\tfor(int i = 1; i <= n; i++) \n\t\t\tfa[i][k] = fa[fa[i][k-1]][k-1];\n\tDfs(rx, 1);\n\tif(flag) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define char ll\n//#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n#ifdef HK_CUP\n    freopen(\"finput.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n#ifndef HK_CUP\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n#endif\n    return 0;\n}\n\nconst int N = 2e5 + 10;\nconst int LOG = 20;\n\nstruct Tree {\n    vvi g;\n    vi parent;\n    int timer = 1;\n    vi tin, tout;\n    vi dip;\n\n    vvi dp;\n\n    Tree(int n) {\n        g.resize(n + 1);\n        parent.resize(n + 1, -1);\n        tin.resize(n + 1);\n        tout.resize(n + 1);\n        dip.resize(n + 1, 0);\n        dp.resize(n + 1, vi(LOG));\n    }\n\n    void add_edge(int v, int u) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    void dfs(int v, int par = -1) {\n        tin[v] = timer++;\n        if (par == -1)\n            par = v;\n        parent[v] = par;\n        dp[v][0] = par;\n        for (int i = 1; i < LOG; ++i) {\n            dp[v][i] = dp[dp[v][i - 1]][i - 1];\n        }\n        for (int to : g[v]) {\n            if (to == par)\n                continue;\n            dip[to] = dip[v] + 1;\n            dfs(to, v);\n        }\n        tout[v] = timer++;\n    }\n\n    int dist(int u, int v) {\n        if (!is_par(u, v))\n            swap(u, v);\n        return dip[v] - dip[u];\n    }\n\n    int jump(int v, int dst) {\n        if (!dst)\n            return v;\n        for (int i = LOG - 1; i >= 0; --i) {\n            if ((1 << i) < dst) {\n                v = dp[v][i];\n                dst -= 1 << i;\n            }\n        }\n        return dp[v][0];\n    }\n\n    bool is_par(int u, int v) {\n        return tin[u] <= tin[v] && tin[v] <= tout[u];\n    }\n};\n\nint n, x, y;\n\nTree input_tree(int n, int root) {\n    Tree ret(n);\n    fori (_, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        ret.add_edge(u, v);\n    }\n    ret.dfs(root);\n    return ret;\n}\n\nconst int oo = 1e9 + 10;\nint dp[N];\nTree red(N), blue(N);\n\nint find_to(int root, int to) {\n    if (!blue.is_par(root, to))\n        return oo;\n    return blue.jump(to, blue.dist(root, to) - 1);\n}\n\nvoid dfs(int v) {\n//    cerr << \"dp[\" << v << \"] = \" << dp[v] << endl;\n    for (int to : red.g[v]) {\n        if (to == red.parent[v])\n            continue;\n        if (blue.parent[to] == dp[v] ||\n            blue.parent[dp[v]] == to ||\n            to == dp[v]) {\n            continue;\n        }\n        dp[to] = find_to(dp[v], to);\n        if (dp[to] != oo) {\n            dfs(to);\n        }\n    }\n}\n\nvoid smain() {\n    cin >> n >> x >> y;\n    red = input_tree(n, x);\n    blue = input_tree(n, y);\n    fill(dp, dp + n + 1, oo);\n    dp[x] = y;\n    dfs(x);\n\n    for (int v = 1; v <= n; ++v) {\n        if (dp[v] == oo)\n            continue;\n        int subt = blue.parent[v];\n        for (int to : red.g[v]) {\n            if (blue.is_par(subt, to) ||\n                to == subt ||\n                blue.parent[to] == subt ||\n                blue.parent[subt] == to)\n                continue;\n            cout << \"-1\\n\";\n            exit(0);\n        }\n    }\n\n    int ans = 0;\n    for (int v = 1; v <= n; ++v) {\n        if (dp[v] != oo) {\n            inmax(ans, blue.dip[v]);\n        }\n    }\n    cout << ans * 2;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> par;\n\nconst int N=200010;\n\nint n,x,y,cnt,a[N],b[N],G[N];\nint fa[N][20];\nstruct edge{\n  int t,nx;\n}E[N<<2];\n\ninline void addedge(int x,int y){\n  E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n  E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n}\n\nint dpt[N];\n\nvoid dfs(int x,int f){\n  if(f) dpt[x]=dpt[f]+1;\n  fa[x][0]=f; for(int i=1;i<=18;i++) fa[x][i]=fa[fa[x][i-1]][i-1];\n  for(int i=G[x];i;i=E[i].nx)\n    if(E[i].t!=f) dfs(E[i].t,x);\n}\n\nnamespace Grp{\n  int cnt,G[N];\n  struct edge{\n    int t,nx;\n  }E[N<<1];\n\n  inline void addedge(int x,int y){\n    E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n    E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n  }\n}\n\nqueue<int> Q;\nint dis[N],mark[N];\n\nconst int inf=1<<29;\n\ninline void bfs(){\n  for(int i=1;i<=n;i++) dis[i]=inf;\n  Q.push(x); dis[x]=0;\n  while(!Q.empty()){\n    int x=Q.front(); Q.pop();\n    for(int i=Grp::G[x];i;i=Grp::E[i].nx){\n      int v=Grp::E[i].t;\n      if(dis[v]!=inf) continue;\n      if(dis[x]+1>dpt[v]) continue;\n      dis[v]=dis[x]+1; Q.push(v);\n    }\n  }\n}\n\ninline int lca(int x,int y){\n  if(dpt[x]<dpt[y]) swap(x,y);\n  for(int i=18;~i;i--)\n    if(dpt[fa[x][i]]>=dpt[y]) x=fa[x][i];\n  if(x==y) return x;\n  for(int i=18;~i;i--)\n    if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n  return fa[x][0];\n}\n\ninline int dist(int x,int y){\n  return dpt[x]+dpt[y]-2*dpt[lca(x,y)];\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d\",&a[i],&b[i]);\n  for(int i=1,u,v;i<n;i++)\n    scanf(\"%d%d\",&u,&v),addedge(u,v);\n  dfs(y,0); dpt[0]=-1;\n  for(int i=1;i<n;i++)\n    if(dist(a[i],b[i])>2) mark[a[i]]=mark[b[i]]=1;\n    else Grp::addedge(a[i],b[i]);\n  bfs(); int ans=0;\n  for(int i=1;i<=n;i++){\n    if(mark[i] && dis[i]<dpt[i]) return puts(\"-1\"),0;\n    if(dis[i]<dpt[i]) ans=max(ans,dpt[i]*2);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 200000 + 1000;\n\nint n, X, Y;\nvector<int> bedg[MAXN], redg[MAXN];\nint ru[MAXN], rv[MAXN];\n\nint dep[MAXN], fa[MAXN];\nbool sp[MAXN];\n\nbool check_long(int x, int y)\n{\n\tif(fa[x] == y || x == fa[y])\n\t\treturn false;\n\tif(fa[fa[x]] == y || x == fa[fa[y]])\n\t\treturn false;\n\tif(fa[x] == fa[y])\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs1(int x, int father, int depth)\n{\n\tfa[x] = father;\n\tdep[x] = depth;\n\tfor(int i = 0; i < bedg[x].size(); i++)\n\t\tif(bedg[x][i] != father)\n\t\t\tdfs1(bedg[x][i], x, depth + 1);\n}\n\nint ans = 0;\nbool dfs2(int x, int father, int depth)\n{\n\tif(dep[x] <= depth)\n\t\treturn false;\n\t// cerr << x << endl;\n\tans = max(ans, dep[x]);\n\tif(sp[x])\n\t\treturn true;\n\tfor(int i = 0; i < redg[x].size(); i++)\n\t\tif(redg[x][i] != father)\n\t\t\tif(dfs2(redg[x][i], x, depth + 1))\n\t\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> X >> Y;\n\tfor(int i = 1; i <= n - 1; i++)\n\t\tcin >> ru[i] >> rv[i];\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tbedg[x].push_back(y), bedg[y].push_back(x);\n\t}\n\tdfs1(Y, 0, 0);\n\tfor(int i = 1; i <= n - 1; i++)\n\t\tif(check_long(ru[i], rv[i]))\n\t\t\tsp[ru[i]] = sp[rv[i]] = true;\n\t\telse\n\t\t\tredg[ru[i]].push_back(rv[i]), redg[rv[i]].push_back(ru[i]);\n\tif(dfs2(X, 0, 0))\n\t\tcout << -1 << endl;\n\telse\n\t\tcout << 2 * ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 200100\nvector<int> g[N], g2[N];\nint n, x, y, a[N], b[N], c[N], d[N];\nint d2[N], w[N], used[N], p[N];\n\nint dfs2(int u){\n\tfor(auto v: g2[u]){\n\t\tif(d2[v]<0){\n\t\t\td2[v] = d2[u]+1;\n\t\t\tdfs2(v);\n\t\t\tp[v] = u;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n>>x>>y; x--; y--;\n\trep(i, n-1) cin>>a[i]>>b[i];\n\trep(i, n-1) cin>>c[i]>>d[i];\n\trep(i, n-1){\n\t\ta[i]--; b[i]--;\n\t\tg[a[i]].pb(b[i]);\n\t\tg[b[i]].pb(a[i]);\n\t}\n\trep(i, n-1){\n\t\tc[i]--; d[i]--;\n\t\tg2[c[i]].pb(d[i]);\n\t\tg2[d[i]].pb(c[i]);\n\t}\n\tmset(d2, -1);\n\td2[y] = 0;\n\tdfs2(y);\n\tp[y] = -1;\n\trep(i, n-1){\n\t\tint t = d2[a[i]]-d2[b[i]];\n\t\tif(abs(t)>2){\n\t\t\tw[a[i]] = 1;\n\t\t\tw[b[i]] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tint a2 = a[i], b2 = b[i];\n\t\tif(t==0){\n\t\t\ta2 = p[a2];\n\t\t\tb2 = p[b2];\n\t\t}\n\t\twhile(t>0){\n\t\t\ta2 = p[a2];\n\t\t\tt--;\n\t\t}\n\t\twhile(t<0){\n\t\t\tb2 = p[b2];\n\t\t\tt++;\n\t\t}\n\t\tif(a2!=b2){\n\t\t\tw[a[i]] = 1;\n\t\t\tw[b[i]] = 1;\n\t\t}\n\t}\n\tqueue<int> q, q2;\n\tq.push(x); q2.push(y);\n\tw[y] = -1;\n\tif(w[x]==1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tw[x] = 2;\n\tint cnt = 1;\n\tfor(int i = 2; ; i+=2){\n\t\tqueue<int> q3, q4;\n\t\twhile(!q2.empty()){\n\t\t\tint u = q2.front(); q2.pop();\n\t\t\tfor(auto v: g2[u]){\n\t\t\t\tif(w[v]<0) continue;\n\t\t\t\tif(w[v]==2) cnt--;\n\t\t\t\tw[v] = -1;\n\t\t\t\tq4.push(v);\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(auto v: g[u]){\n\t\t\t\tif(w[v]<0||w[v]==2) continue;\n\t\t\t\tif(w[v]==1){\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tw[v] = 2;\n\t\t\t\tcnt++;\n\t\t\t\tq3.push(v);\n\t\t\t}\n\t\t}\n\t\tif(cnt==0){\n\t\t\tcout<<i<<endl;\n\t\t\tbreak;\n\t\t}\n\t\tq.swap(q3);\n\t\tq2.swap(q4);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200005;\n\nint h[maxn],mem;\nstruct\n{\n    int v,next;\n}e[maxn<<1];\nvector<int> g[maxn];\nint fa[maxn],deep[maxn],dis[maxn];\nbool vis[maxn],check[maxn];\nvoid add(int u,int v)\n{\n    e[mem].v=v;\n    e[mem].next=h[u];\n    h[u]=mem++;\n}\nint findfa(int x)\n{\n    if(x==fa[x]) return fa[x];\n    return fa[x]=findfa(fa[x]);\n}\nvoid init()\n{\n    memset(h,-1,sizeof(h));\n    memset(vis,0,sizeof(vis));\n    memset(dis,127,sizeof(dis));\n    memset(check,0,sizeof(check));\n    mem=0;\n}\n\nvoid dfs(int u,int f)\n{\n    fa[u]=u;deep[u]=deep[f]+1;\n    for(int i=h[u];i+1;i=e[i].next)\n    {\n        int v=e[i].v;\n        if(v==f) continue;\n        dfs(v,u);\n    }\n    for(int i=0;i<g[u].size();i++)\n    {\n        int v=g[u][i];\n        if(vis[v]){\n            int t=findfa(v);\n            int len=deep[v]+deep[u]-deep[t]*2;\n            if(len>2){\n                check[u]=check[v]=1;\n               // printf(\"%d k %dsss\\n\",u,v);\n            }\n        }\n\n    }\n    fa[u]=f;\n    vis[u]=1;\n}\nint q[maxn];\nint bfs(int x)\n{\n    dis[x]=0;\n    int head,tail;\n    head=tail=0;\n    q[tail++]=x;\n    int ans=2*deep[x];\n    while(head<tail)\n    {\n        int u=q[head++];\n        if(check[u]) {\n            //printf(\"%dss %d %d\\n\",u,head,tail);\n            return -1;\n        }\n        for(int i=0;i<g[u].size();i++)\n        {\n            int v=g[u][i];\n            if(dis[v]>dis[u]+1){\n                if(deep[v]>dis[u]+1){\n                    dis[v]=dis[u]+1;\n                    q[tail++]=v;\n                    ans=max(ans,2*deep[v]);\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main()\n{\n    int y,x,n;\n    scanf(\"%d%d%d\",&n,&x,&y);\n    for(int i=1;i<n;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    init();\n    for(int i=1;i<n;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add(u,v);\n        add(v,u);\n    }\n    deep[y]=-1;\n    dfs(y,y);\n    printf(\"%d\\n\",bfs(x));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"ctime\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Lowest_Common_Ancestor {\n\tvector<int>depth;\n\tvector<vector<int>>parent;\n\tvector<vector<int>>edge;\n\tint height = 0;\n\tint node;\npublic:\n\tLowest_Common_Ancestor(int num) {\n\t\tnum++;\n\t\tnode = num;\n\t\twhile (num) {\n\t\t\theight++;\n\t\t\tnum /= 2;\n\t\t}\n\t\tparent.resize(height);\n\t\tedge.resize(node);\n\t\tdepth.resize(node);\n\t\tfor (int i = 0; i < height; i++)parent[i].resize(node);\n\t}\n\tvoid Add_Edge(int a, int b) {\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\treturn;\n\t}\n\tvoid Update(int rtnode) {\n\t\tqueue<int>QQ;\n\t\tfor (int i = 0; i < node; i++) depth[i] = INT_MAX;\n\t\tdepth[rtnode] = 0;\n\t\tQQ.push(rtnode);\n\t\twhile (!QQ.empty()) {\n\t\t\tint c = QQ.front();\n\t\t\tfor (auto i : edge[c]) {\n\t\t\t\tif (depth[i] > depth[c] + 1) {\n\t\t\t\t\tdepth[i] = depth[c] + 1;\n\t\t\t\t\tQQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQQ.pop();\n\t\t}\n\t\tparent[0][rtnode] = -1;\n\t\tfor (int i = 1; i < node; i++) {\n\t\t\tfor (auto j : edge[i]) {\n\t\t\t\tif (depth[i] - 1 == depth[j]) {\n\t\t\t\t\tparent[0][i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < height - 1; i++) {\n\t\t\tfor (int j = 0; j < node; j++) {\n\t\t\t\tif (parent[i][j] < 0)parent[i + 1][j] = -1;\n\t\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint LCA(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tif ((depth[v] - depth[u]) >> i & 1) {\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int i = height - 1; i >= 0; i--) {\n\t\t\tif (parent[i][v] != parent[i][u]) {\n\t\t\t\tu = parent[i][u];\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\tint Dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - depth[LCA(u, v)] * 2;\n\t}\n};\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tvector<vector<int>>edge(N + 1);\n\tLowest_Common_Ancestor lca(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tedge[H].push_back(W);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tlca.Add_Edge(H, W);\n\t}\n\tlca.Update(1);\n\tvector<int>safe(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (lca.Dist(i, j) > 2)safe[i] = safe[j] = 1;\n\t\t}\n\t}\n\tvector<int>depth(N + 1, MOD);\n\tCalculate_Depth(edge, depth, L);\n\tvector<int>reachable(N + 1);\n\treachable[L] = lca.Dist(R, L);\n\tqueue<int>Q;\n\tQ.push(L);\n\twhile (!Q.empty()){\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (reachable[i])continue;\n\t\t\tif (depth[i] < lca.Dist(R, i)) {\n\t\t\t\treachable[i] = lca.Dist(R, i);\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tans = max(ans, reachable[i]);\n\t}\n\tans <<= 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (reachable[i] && safe[i])ans = -1;\n\t}\n\tassert(ans != -1);\n\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Program from Luvwgyx*/\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e5+10;\nint n,x,y,ans,vis[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nstruct Heavy_Light_Decomposition{\n    struct edge{int to,nxt;}e[maxn<<1];int tot,head[maxn];\n    int idx,fa[maxn],dfn[maxn],dep[maxn],son[maxn],top[maxn],size[maxn];\n    void add(int u,int v){e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;}\n    void insert(int u,int v){add(u,v);add(v,u);}\n    void build(int x){\n        dep[x]=dep[fa[x]]+1;size[x]=1;int mx=0;\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to){\n            if(v==fa[x])continue;\n            fa[v]=x;build(v);size[x]+=size[v];\n            if(size[v]>mx)mx=size[v],son[x]=v;\n        }\n    }\n    void dfs(int x){\n        if(!x)return ;dfn[x]=++idx;\n        top[x]=son[fa[x]]==x?top[fa[x]]:x;\n        dfs(son[x]);\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)\n            if(v!=fa[x]&&v!=son[x])dfs(v);\n    }\n    int query(int u,int v){\n        while(top[u]!=top[v]){\n            if(dep[top[u]]<dep[top[v]])swap(u,v);\n            u=fa[top[u]];\n        }if(dep[u]>dep[v])swap(u,v);\n        return u;\n    }\n    int get_dis(int u,int v){return dep[u]+dep[v]-2*dep[query(u,v)];}\n}HLD[2];\nvoid init(int S){\n    queue<int >q;\n    q.push(S);vis[S]=1;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(!vis[v]&&HLD[0].dep[v]<HLD[1].dep[v])vis[v]=1,q.push(v);\n    }\n}\nvoid solve(){\n    for(int x=1;x<=n;x++){\n        if(!vis[x])continue;\n        ans=max(ans,HLD[1].dep[x]-1);\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(HLD[1].get_dis(v,x)>2){puts(\"-1\");return ;}\n    }write(ans<<1);\n}\nint main(){\n    n=read();x=read();y=read();\n    if(x==y){puts(\"0\");return 0;}\n    for(int i=1;i<n;i++)HLD[0].insert(read(),read());\n    for(int i=1;i<n;i++)HLD[1].insert(read(),read());\n    HLD[0].build(x);HLD[0].dfs(x);HLD[1].build(y);HLD[1].dfs(y);\n    init(x);solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\t   c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nvector<int> to[2][MAXN];\nint fa[MAXN][20],dep[MAXN];\nint N,X,Y,ans;\nbool flag = 0;\nint lca(int u,int v) {\n    if(dep[u] < dep[v]) swap(u,v);\n    int l = 18;\n    while(dep[u] > dep[v]) {\n        if(dep[fa[u][l]] >= dep[v]) {\n            u = fa[u][l];\n        }\n        --l;\n    }\n    if(u == v) return u;\n    l = 18;\n    while(fa[u][0] != fa[v][0]) {\n        if(fa[u][l] != fa[v][l]) {\n            u = fa[u][l];\n            v = fa[v][l];\n        }\n        --l;\n    }\n    return fa[u][0];\n}\nint dist(int u,int v) {\n    return dep[u] + dep[v] - 2 * dep[lca(u,v)];\n}\nvoid dfs(int u) {\n    for(auto t : to[1][u]) {\n        if(t != fa[u][0]) {\n            dep[t] = dep[u] + 1;\n            fa[t][0] = u;\n            dfs(t);\n        }\n    }\n}\nvoid dfs1(int u,int f,int d) {\n    if(u == Y) return;\n    ans = max(ans,dep[u] - 1);\n    for(auto t : to[0][u]) {\n        if(t == f) continue;\n        if(dist(u,t) > 2) flag = 1;\n        if(d + 1 < dep[t]) dfs1(t,u,d + 1);\n    }\n}\nvoid Solve() {\n    read(N);read(X);read(Y);\n    int a,b;\n    for(int i = 1 ; i < N ; ++i) {\n        read(a);read(b);\n        to[0][a].pb(b);to[0][b].pb(a);\n    }\n    for(int i = 1 ; i < N ; ++i) {\n        read(a);read(b);\n        to[1][a].pb(b);to[1][b].pb(a);\n    }\n    dep[Y] = 1;\n    dfs(Y);\n    for(int j = 1 ; j <= 19 ; ++j) {\n        for(int i = 1 ; i <= N ; ++i) {\n            fa[i][j] = fa[fa[i][j - 1]][j - 1];\n        }\n    }\n    dfs1(X,0,0);\n    if(flag) {puts(\"-1\");}\n    else {out(2 * ans);enter;}\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> PII;\ntypedef pair <int, int> PLL;\ntypedef pair <PLL, int> PLLI;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <ll, int> PLI;\ntypedef pair <ld, ld> PLD;\ntypedef pair <PLD, ld> PLDD;\ntypedef pair <PLL, ll> PLLL;\ntypedef unsigned int ui;\nconst int inf = 1e9+9;\nconst int mod = 1e9+7;\nconst ll MOD = 1e9+696969;\nconst long long INF = (ll)1e18+3;\nint n, m, k, a, b, c, DL = 0, CC = 0, T;\n#define maxn 200100\nvector <int> v[2][maxn];\nint d[maxn][2];\nint X, Y;\n\nvoid BFS(int graf, int start) {\n\tbool sp = 0;\n\tif (graf == 2) graf = 0, sp = 1;\n\tqueue <int> q;\n\twhile (!q.empty()) q.pop();\n\tFOR(i, 1, n) d[i][graf] = inf;\n\td[start][graf] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tif (sp && d[x][graf] >= d[x][1]) continue;\n\t\tfor (auto u : v[graf][x])\n\t\t  if (d[u][graf] == inf) {\n\t\t\t  d[u][graf] = d[x][graf] + 1;\n\t\t\t  q.push(u);\n\t\t  }\n\t}\n}\n\nmap <PII, bool> mapa;\n\nconst int D = 1000;\nint BIG[maxn];\n\nint main() {\n\tboost;\n\tOUT(-1);\n\tcin >> n >> X >> Y;\n\tFOR(i, 2, n) {\n\t\tcin >> a >> b;\n\t\tv[0][a].pb(b);\n\t\tv[0][b].pb(a);\n\t}\n\t\n\tFOR(i, 2, n) {\n\t\tcin >> a >> b;\n\t\tmapa[{a, b}] = 1;\n\t\tv[1][a].pb(b);\n\t\tv[1][b].pb(a);\n\t}\n\t\n\tFOR(i, 1, n) sort(v[1][i].begin(), v[1][i].end());\n\t\n\tint ILE = 0;\n\tFOR(i, 1, n)\n\t  if (v[1][i].size() < 400) {\n\t\t  for (auto u : v[1][i])\n\t\t    for (auto p : v[1][i])\n\t\t      if (u != p) mapa[{u, p}] = 1;\n\t  }\n\t  else BIG[++ILE] = i;\n\t  \n\tFOR(i, 1, n)\n\t  for (auto u : v[0][i]) {\n\t\t  //to sumarycznie robi obrot N petli\n\t\t  FOR(cnt, 1, ILE) {\n\t\t\t  int kt = BIG[cnt];\n\t\t\t  if (binary_search(v[1][kt].begin(), v[1][kt].end(), i) &&\n\t\t\t\t  binary_search(v[1][kt].begin(), v[1][kt].end(), u)) mapa[{i,u}] = 1;\n\t\t}\n  }\n\t\n\tBFS(0, X);\n\tBFS(1, Y);\n\n\tFOR(i, 1, n)\n\t  for (auto u : v[0][i]) {\n\t\t  if (!mapa[{i,u}] && !mapa[{u,i}]) {\n\t\t\t  //jest potencjalnie dobra para\n\t\t\t  if (d[i][0] < d[u][0]) {\n\t\t\t\tif (d[i][0] < d[i][1]) OUT(-1);\n\t\t\t}\n\t\t\t  else {\n\t\t\t\t  if (d[u][0] < d[u][1]) OUT(-1);\n\t\t\t  }\n\t\t  }\n\t  }\n\t \n\tBFS(2, X);\n\tint wynik = 0;\n\tFOR(i, 1, n)\n\t  if (d[i][0] < d[i][1]) wynik = max(wynik, 2 * d[i][1]);\n\t  \n\tcout << wynik << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e5 + 5, LOGN = 19;\n\nint N, X, Y;\nvector<int> GX[MAXN], GY[MAXN];\n\nvoid input()\n{\n    read(N); read(X); read(Y);\n    for (int i = 1; i < N; ++i) {\n        int u, v;\n        read(u); read(v);\n        GX[u].push_back(v);\n        GX[v].push_back(u);\n    }\n    for (int i = 1; i < N; ++i) {\n        int u, v;\n        read(u); read(v);\n        GY[u].push_back(v);\n        GY[v].push_back(u);\n    }\n}\n\nint dep[MAXN], jmp[MAXN][LOGN];\nint ans;\n\nvoid dfsY(int u)\n{\n    dep[u] = dep[jmp[u][0]] + 1;\n    for (int i = 0; i < SZ(GY[u]); ++i) {\n        int v = GY[u][i];\n        if (v == jmp[u][0])\n            continue;\n        jmp[v][0] = u;\n        for (int j = 1; j < LOGN; ++j) {\n            jmp[v][j] = jmp[jmp[v][j - 1]][j - 1];\n        }\n        dfsY(v);\n    }\n}\n\nint getnextY(int x, int y)\n{\n    assert(x != y);\n    for (int i = LOGN - 1; i >= 0; --i) {\n        if (dep[jmp[x][i]] > dep[y])\n            x = jmp[x][i];\n    }\n    return jmp[x][0] == y ? x : jmp[y][0];\n}\n\nint getlcaY(int u, int v)\n{\n    if (dep[u] < dep[v])\n        std::swap(u, v);\n    for (int i = LOGN - 1; i >= 0; --i) {\n        if (dep[jmp[u][i]] >= dep[v])\n            u = jmp[u][i];\n    }\n    if (u == v)\n        return u;\n    for (int i = LOGN - 1; i >= 0; --i) {\n        if (jmp[u][i] != jmp[v][i]) {\n            u = jmp[u][i];\n            v = jmp[v][i];\n        }\n    }\n    return jmp[u][0];\n}\n\nint getdisY(int u, int v)\n{\n    return dep[u] + dep[v] - dep[getlcaY(u, v)] * 2;\n}\n\nvoid dfsX(int x, int y, int fa, int cur)\n{\n    chkmax(ans, cur + getdisY(x, y) * 2);\n    if (x == y)\n        return;\n    for (int i = 0; i < SZ(GX[x]); ++i) {\n        int v = GX[x][i];\n        if (v == fa)\n            continue;\n        if (v == y) {\n            chkmax(ans, cur + 1);\n            continue;\n        }\n        if (getdisY(x, v) > 2) {\n            puts(\"-1\");\n            exit(0);\n        }\n        dfsX(v, getnextY(v, y), x, cur + 2);\n    }\n}\n\nvoid solve()\n{\n    dfsY(Y);\n    dfsX(X, Y, 0, 0);\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 芙蓉如面柳如眉，对此如何不泪垂。\n//     -- 白居易《长恨歌》\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"cycle\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e5 + 5;\n\nvi g1[MAXN], g2[MAXN];\n\nint used1[MAXN], used2[MAXN];\n\nint dis1[MAXN], dis2[MAXN];\n\nint tin2[MAXN], tout2[MAXN], _t, prv2[MAXN];\n\nbool is_prv(int a, int b){\n\treturn tin2[a] <= tin2[b] && tout2[b] <= tout2[a];\n}\n\nbool check_dis_le_2(int a, int b){\n\tif (abs(dis2[a] - dis2[b]) > 2){\n\t\treturn false;\n\t}\n\tif (is_prv(a, b) || is_prv(b, a)){\n\t\treturn true;\n\t}\n\tif (prv2[a] == prv2[b]){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint ans;\nint ans1;\n\nvoid dfs1(int s){\n\tused1[s] = 1;\n\tans = max(ans, 2 * dis2[s]);\n\tREP(i, 0, SZ(g1[s])){\n\t\tint to = g1[s][i];\n\t\tif (!used1[to]){\n\t\t\tdis1[to] = dis1[s] + 1;\n\t\t\tif (!check_dis_le_2(s, to)){\n\t\t\t\tans1 = 1;\n\t\t\t}\n\t\t\tif (dis1[to] < dis2[to]){\n\t\t\t\tdfs1(to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs2(int s){\n\tused2[s] = 1;\n\ttin2[s] = tout2[s] = _t++;\n\tREP(i, 0, SZ(g2[s])){\n\t\tint to = g2[s][i];\n\t\tif (!used2[to]){\n\t\t\tprv2[to] = s;\n\t\t\tdis2[to] = dis2[s] + 1;\n\t\t\tdfs2(to);\n\t\t\ttout2[s] = tout2[to];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint n, a, b, s1, s2;\n\tscanf(\"%d%d%d\", &n, &s1, &s2);\n\tREP(i, 1, n){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg1[a].pb(b);\n\t\tg1[b].pb(a);\n\t}\n\tREP(i, 1, n){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg2[a].pb(b);\n\t\tg2[b].pb(a);\n\t}\n\tdfs2(s2);\n\tdfs1(s1);\n\tif (ans1 == 1){\n\t\tans = -1;\n\t}\n\tprintf(\"%d\\n\", ans);\n}\t\n\nint main(){\n\n\t//freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n\tint t = 1;\n\t//cin >> t;\n\twhile(t--){\n\t\tsolve();\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005;\nint n, x, y;\n\nint a[N], b[N], c[N], d[N];\nstruct tree {\n\tint head[N], tot;\n\tstruct edge { int to, nxt; } e[N << 1];\n\tvoid link(int x, int y) {\n\t\te[++tot] = (edge) {y, head[x]}, head[x] = tot;\n\t\te[++tot] = (edge) {x, head[y]}, head[y] = tot;\n\t}\n} R, B;\nbool mark[N];\n\nint depB[N], fB[N];\nvoid dfs0(int x) {\n\tstatic auto head = B.head;\n\tstatic auto e = B.e;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (e[i].to != fB[x])\n\t\t\tfB[e[i].to] = x, depB[e[i].to] = depB[x] + 1, dfs0(e[i].to);\n}\nint ans = 0;\nvoid dfs1(int x, int f = 0, int dep = 0) {\n\tif (dep >= depB[x]) return;\n\tif (mark[x]) std::cout << -1 << '\\n', std::exit(0);\n\tans = std::max(ans, depB[x]);\n\tstatic auto head = R.head;\n\tstatic auto e = R.e;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (depB[e[i].to] > dep && e[i].to != f) dfs1(e[i].to, x, dep + 1);\n}\n\nbool qaq(int x, int y) {\n\tif (depB[x] > depB[y]) std::swap(x, y);\n\tauto f = fB;\n\treturn f[y] == f[x] || f[y] == x || f[f[y]] == x;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> x >> y;\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cin >> a[i] >> b[i], R.link(a[i], b[i]);\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cin >> c[i] >> d[i], B.link(c[i], d[i]);\n\tdfs0(y);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!qaq(a[i], b[i])) mark[a[i]] = mark[b[i]] = 1;\n\tdfs1(x), std::cout << ans * 2 << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\n\nint chk[N],u[N],v[N];\nint n,x,y,ans;\n\nstruct Edge{\n\tint y,nxt;\n};\n\nstruct Tree{\n\tEdge E[N];\n\tint fa[20][N];\n\tint las[N],dep[N];\n\tint cnt;\n\tTree(){\n\t\tmemset(las,-1,sizeof(las));\n\t}\n\tvoid Link(int x,int y){\n\t\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\t\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n\t}\n\tvoid dfs(int x){\n\t\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\t\tif ((y=E[i].y)!=fa[0][x]){\n\t\t\t\tfa[0][y]=x;\n\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\tdfs(y);\n\t\t\t}\n\t}\n\tint LCA(int x,int y){\n\t\tif (dep[x]>dep[y]) swap(x,y);\n\t\tfor (int k=dep[y]-dep[x],i=0;k;k>>=1,i++) if (k&1) y=fa[i][y];\n\t\tif (x==y) return x;\n\t\tfor (int i=19;~i;i--) if (fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];\n\t\treturn fa[0][x];\n\t}\n\tint dis(int x,int y){\n\t\treturn dep[x]+dep[y]-2*dep[LCA(x,y)];\n\t}\n\tvoid Work(int rt){\n\t\tdfs(rt);\n\t\tFor(i,1,20) For(x,1,n+1) fa[i][x]=fa[i-1][fa[i-1][x]];\n\t}\n} R,B;\n\nvoid Dfs(int x){\n\tchk[x]=chk[R.fa[0][x]]&&R.dep[x]<=B.dep[x];\n\tfor (int i=R.las[x],y;~i;i=R.E[i].nxt)\n\t\tif ((y=R.E[i].y)!=R.fa[0][x]){\n\t\t\tDfs(y);\n\t\t}\n}\n\nint main(){\n\tn=IN(),x=IN(),y=IN();\n\tFor(i,1,n){\n\t\tu[i]=IN(),v[i]=IN();\n\t\tR.Link(u[i],v[i]);\n\t}\n\tFor(i,1,n) B.Link(IN(),IN());\n\tR.Work(x);\n\tB.Work(y);\n\tchk[0]=1;\n\tDfs(x);\n\tFor(i,1,n){\n\t\tif (!chk[u[i]]&&!chk[v[i]]) continue;\n\t\tif (B.dis(u[i],v[i])>2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tFor(i,1,n+1) if (chk[i]) ans=max(ans,B.dep[i]);\n\tprintf(\"%d\\n\",2*ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 200005\nusing namespace std;\n\nint n,cnt,last[MAXN];\nint father[MAXN],deep[MAXN],dis[MAXN];\nint q[MAXN],nnn[MAXN],mx[MAXN];\nint tim,a[MAXN][2],xx,yy;\nbool vis[MAXN],win[MAXN];\n\nstruct edge\n{\n    int to,next,h;\n}t[MAXN*4];\n\nvoid add(int u,int v,int h)\n{\n    t[++cnt].to=v;t[cnt].h=h;\n    t[cnt].next=last[u];last[u]=cnt;\n    t[++cnt].to=u;t[cnt].h=h;\n    t[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n    deep[x]=deep[father[x]]+1;nnn[x]=++tim;\n    for (int i=last[x];i;i=t[i].next)\n        if (t[i].to!=father[x]) father[t[i].to]=x,dfs(t[i].to);\n    mx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n    if (nnn[x]>nnn[y]) swap(x,y);\n    if (nnn[x]<nnn[y]&&mx[x]>nnn[y]) return deep[y]-deep[x]>2 ? true : false;\n    if (father[x]==father[y]) return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int h=1,tt=1;q[1]=xx;vis[xx]=1;\n    while (h<=tt)\n    {\n        int x=q[h++];\n        for (int i=last[x];i;i=t[i].next)\n            if (!t[i].h&&!vis[t[i].to])\n            {\n                dis[t[i].to]=dis[x]+1;\n                if (dis[t[i].to]<deep[t[i].to]) vis[t[i].to]=1,q[++tt]=t[i].to;\n            }\n    }\n}\n\nint max(int a,int b){return a<b?a:b;}//\n\ntemplate<class T>inline void read(T &res)\n{\n    static char ch;T flag=1;\n    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;\n    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;\n}\n\nint main()\n{\n    int ans=0;\n    read(n);read(xx);read(yy);\n\n    for (int i=1;i<n;i++) {read(a[i][0]);read(a[i][1]);}\n\n    for (int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x);read(y);\n        add(x,y,1);\n    }\n\n    deep[0]=-1;\n    dfs( yy );\n\n    for (int i=1;i<n;i++)\n    {\n        if (check(a[i][0],a[i][1]))\n            win[a[i][0]]=win[a[i][1]]=1;\n        else add(a[i][0],a[i][1],0);\n    }\n\n    bfs();\n\n    for (int i=1;i<=n;i++)\n        if (win[i]&&vis[i])\n            {putchar('-');putchar('1');return 0;}\n\n    for (int i=1;i<=n;i++)\n        if (vis[i])\n            ans=max(ans,deep[i]<<1);\n\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\nconst int MAX_V = 201000;\nclass LCA {\npublic : \nint parent[20][MAX_V];\nvector<int>graph[MAX_V];\nint depth[MAX_V];\nint root;//これを決定しないといけない事に注意。\n\nvoid add_LCA(int u,int v) {\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n\n\nvoid dfsLCA(int v,int p,int d) {\n\tparent[0][v] = p;\n\tdepth[v]=d;\n\tfor(int i=0; i<graph[v].size(); i++) {\n\t\tif(graph[v][i]!=p) dfsLCA(graph[v][i],v,d+1) ;\n\t}\n\t\n}\n\nvoid initLCA(int V) {\n\tdfsLCA(root,-1,0);\n\t\n\tfor(int k=0; k+1<20; k++) {\n\t\tfor(int v=0; v<V; v++) {\n\t\t\tif(parent[k][v]<0) parent[k+1][v]=-1;\n\t\t\telse parent[k+1][v] = parent[k][parent[k][v]];\n\t\t}\n\t}\n\t\n}\n\nint solveLCA(int u,int v) {\n\tint ans = 0;\n\tif(depth[u]>depth[v]) swap(u,v) ;\n\tfor(int k=0; k<20; k++) {\n\t\tif((depth[v]-depth[u])>>k&1) {\n\t\t\tv = parent[k][v];\n\t\t\tans += (1<<k);\n\t\t}\n\t}\n\tif(u==v) {\n\t\treturn ans;\n\t//\treturn u;\n\t}\n\tfor(int k=20-1; k>=0; k--) {\n\t\tif(parent[k][u]!=parent[k][v]) {\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t\tans += (1<<k) * 2;\n\t\t}\n\t}\n\treturn ans + 2;\n//\treturn parent[0][u];\n}\n\n};\n\n\tLCA lca;\nconst int MAXN = 201000;\nvector<int> black[MAXN];\nvector<int> white[MAXN];\nint main() {\n\tint N, X, Y;\n\tcin >> N >> X >> Y;\n\t\n\tX--;Y--;\n\tfor(int i=0; i<N-1; i++) {\n\t\tint p,q;\n\t\tcin >> p >> q;\n\t\tp--;q--;\n\t\tblack[p].push_back(q);\n\t\tblack[q].push_back(p);\n\t}\n\t\n\tfor(int i=0; i<N-1; i++) {\n\t\tint p,q;\n\t\tcin >> p >> q;\n\t\tp--;q--;\n\t\twhite[p].push_back(q);\n\t\twhite[q].push_back(p);\n\t\tlca.add_LCA(p, q);\n\t}\n\tlca.root = 0;\n\tlca.initLCA(N);\n\t\n\tvector<int> used(N, 0);\n\tvector<int> pos(N, -1);\n\tvector<int> distB(N, 0);\n\tvector<int> distA(N, 0);\n\tused[X] = true;\n\t\n\tstack<int> sta;\n\tsta.push(X);\n\tpos[X] = Y;\n\tdistB[X] = lca.solveLCA(X, Y);\n\t\n\tint ans = 0;\n\tans = distB[X];\n\t\n\tbool good = false;\n\tdistA[X] = 0;\n\twhile(!sta.empty()) {\n\t\tint cur = sta.top(); sta.pop();\n\t\tfor(int i=0; i<black[cur].size(); i++) {\n\t\t\tint u = black[cur][i];\n\t\t\tif(used[u]) continue;\n\t\t\tif(pos[cur] == u) continue;\n\t\t\t\n\t\t\tused[u] = true;\n\t\t\tint prevWhite = pos[cur];\n\t\t\tint nextWhite = -1;\n\t\t\tint minim = N;\n\t\t\t/*\n\t\t\tfor(int j=0; j<white[prevWhite].size(); j++) {\n\t\t\t\tint tmpWhite = white[prevWhite][j];\n\t\t\t\tint diff = lca.solveLCA(tmpWhite, u);\n\t\t\t\tif(diff < minim) {\n\t\t\t\t\tminim = diff;\n\t\t\t\t\tnextWhite = tmpWhite;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}*/\n\t\t\t/*\n\t\t\tpos[u] = nextWhite;\n\t\t\tdist[u] = minim;\n\t\t\t*/\n\t\t\t//cout << u << \" \" << dist[u] << endl;\n\t\t\t//if(dist[u] >= dist[cur])\n//\t\t\tcout << u << pos[cur] << endl;\n\t\t\tif(lca.solveLCA(cur, u) >= 3)\n\t\t\t\tgood = true;\n\t\t\t\n//\t\t\tcout << u << \" \" << Y << \" \" << lca.solveLCA(u,Y) << endl;\n\n\t\t\tdistA[u] = distA[cur] + 1;\n\t\t\tdistB[u] = lca.solveLCA(u, Y) - distA[u];\n\t\t\tif(distB[u] > 0) {\n\t\t\t\tsta.push(u);\n\t\t\t\tans = max(ans, lca.solveLCA(u, Y));\n\t\t\t}\n\t\t\tif(distB[u]==0)\n\t\t\t\tans = max(ans, lca.solveLCA(u, Y));\n\t\t}\n\t}\n\tif(good) {\n\t\tcout << \"-1\" << endl;\n\t}\n\telse {\n\t\tcout << ans * 2 << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int NN = 2e5 + 5;\nstruct E {\n\tint v, nxt;\n\tE(int _v=0, int _nxt=0) : v(_v), nxt(_nxt) {}\n};\nstruct Graph {\n\tint head[NN], totE;\n\tE edge[NN*2];\n\tvoid AddEdge(int u, int v) {\n\t\tedge[++totE] = E(v, head[u]);\n\t\thead[u] = totE;\n\t}\n} a, b;\nint N, X, Y, da[NN], db[NN], fab[NN];\nbool save[NN];\nvoid Dfs1(int u, int fr) {\n\tfab[u] = fr;\n\tdb[u] = db[fr] + 1;\n\tfor (int p = b.head[u]; p; p = b.edge[p].nxt) {\n\t\tint v = b.edge[p].v; //注意两棵树别用串了 \n\t\tif (v != fr)\n\t\t\tDfs1(v, u);\n\t}\n}\nbool inf, edgetag[NN];\nvoid Dfs2(int u, int fr, int is) {\n\tda[u] = da[fr] + 1;\n\tif (da[u] >= db[u]) is = 0;\n\telse if (is) save[u] = 1;\n\tif (fr != 0) {\n\t\tint x = u, y = fr;\n\t\tif (db[x] < db[y]) swap(x, y);\n\t\tif (fab[x] == fab[y] || fab[x] == y || fab[fab[x]] == y) ;\n\t\telse {\n\t\t\tinf = 1;\n\t\t\tedgetag[u] = 1;\n\t\t}\n\t}\n\tfor (int p = a.head[u]; p; p = a.edge[p].nxt) {\n\t\tint v = a.edge[p].v;\n\t\tif (v != fr) {\n\t\t\tDfs2(v, u, is);\n\t\t\tif (edgetag[v] && (save[u] || save[v]))\n\t\t\t\tinf = 1;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ta.AddEdge(u, v);\n\t\ta.AddEdge(v, u);\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb.AddEdge(u, v);\n\t\tb.AddEdge(v, u);\n\t}\n\tDfs1(Y, 0);\n\tDfs2(X, 0, 1);\n\tif (inf) printf(\"-1\\n\");\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tif (save[i])\n\t\t\t\tans = max(ans, db[i]-1);\n\t\tans *= 2;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int lg = 20;\nvector<int> red[N];\nvector<int> blue[N];\nint h[N];\nint par[lg + 5][N];\nint n, x, y;\nbool winPos[N];\nint disR[N];\nint disB[N];\n\n\nvoid dfs(int v = 0, int p = -1)\n{\n    for (int u : blue[v])\n    {\n        if (u != p)\n        {\n            par[0][u] = v;\n            h[u] = h[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nvoid pre()\n{\n    for (int k = 1; k < lg; k++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            par[k][i] = par[k - 1][ par[k - 1][i] ];\n        }\n    }\n}\n\nint lca(int v, int u)\n{\n    if(h[v] > h[u])\n    {\n        swap(v, u);\n    }\n    for (int i = 0; i < lg; i++)\n    {\n        if (h[u] - h[v] >> i & 1)\n        {\n            u = par[i][u];\n        }\n    }\n    for (int i = lg - 1; i >= 0; i--)\n    {\n        if(par[i][v] != par[i][u])\n        {\n            v = par[i][v], u = par[i][u];\n        }\n    }\n    return v == u ? v : par[0][v];\n}\n\nvoid dfs1(int v, int par = -1)\n{\n    if (disR[v] > disB[v])\n    {\n        return;\n    }\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disR[u] = disR[v] + 1;\n            dfs1(u, v);\n        }\n    }\n}\n\nvoid dfs2(int v, int par = -1)\n{\n    for (auto u: blue[v])\n    {\n        if (u != par)\n        {\n            disB[u] = disB[v] + 1;\n            dfs2(u, v);\n        }\n    }\n}\n\n\n\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        red[u - 1].push_back(v - 1);\n        red[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        blue[u - 1].push_back(v - 1);\n        blue[v - 1].push_back(u - 1);\n    }\n    dfs();\n    pre();\n    for (int i = 0; i < n; i++)\n    {\n        for (auto u: red[i])\n        {\n            int tmp = lca(u, i);\n            if (h[u] - h[tmp] + h[i] - h[tmp] > 2)\n            {\n                winPos[i] = true;\n                winPos[u] = true;\n            }\n        }\n    }\n    memset(disR, 127, sizeof disR);\n    disR[x - 1] = 0;\n    dfs2(y - 1);\n    dfs1(x - 1);\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (winPos[i] && disR[i] <= disB[i])\n        {\n            cout << -1 << endl;\n            exit(0);\n        }\n        if (disR[i] < N)\n        {\n            //cout << endl;\n            //cout << i << \" \" << disB[i] << endl;\n            ans = max(ans, disB[i] * 2);\n        }\n    }\n    cout << (1 << 20) << endl;\n    cout << ans << endl;\n\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nP dp[200005];\nint lca[200005][18],dist2[200005];\nint calc(int x,int y){\n\tif(dist2[x] > dist2[y]) swap(x,y);\n\trep(i,18){\n\t\tif((((dist2[y]-dist2[x])>>i)&1)){\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\tfor(int i=17;i>=0;i--){\n\t\tif(lca[x][i] != lca[y][i]){\n\t\t\tx = lca[x][i];\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\treturn (x==y?x:lca[x][0]);\n}\nbool fe;\nint go(int a,int b){\n\tint c = calc(a,b);\n\tif(a == c){\n\t\tfor(int i=0;i<18;i++){\n\t\t\tif((((dist2[b]-dist2[a]-1)>>i)&1)){\n\t\t\t\tb = lca[b][i];\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\telse{\n\t\treturn lca[a][0];\n\t}\n}\nint ret = 0;\nvoid dfs(int v,int u,int d){\n\tif(dp[v].fi >= 0){\n\t\tret = max(ret,2*d+dp[v].fi*2);\n\t}\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint D = dist2[v]+dist2[edge[v][i]]-2*dist2[calc(v,edge[v][i])];\n\t\t//cout << v << \" \" << edge[v][i] << \" \" << \" \" << calc(v,edge[v][i]) << D << endl;\n\t\tif(D>=3 && lca[edge[v][i]][0] != dp[v].sc && lca[dp[v].sc][0] != edge[v][i]){\n\t\t\tfe = 1;\n\t\t}\n\t\telse {\n\t\t\tD = dist2[edge[v][i]]+dist2[dp[v].sc]-2*dist2[calc(edge[v][i],dp[v].sc)];\n\t\t\tif(D<=1){\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(0,edge[v][i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(D-1,go(dp[v].sc,edge[v][i])));\n\t\t\t}\n\t\t}\n\t\tdfs(edge[v][i],v,d+1);\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d; lca[v][0] = u;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs2(b,-1,0);\n\tdp[a] = mp(dist2[a],b);\n\tfor(int j=0;j<17;j++) for(int i=1;i<=n;i++){\n\t\tif(lca[i][j] == -1) lca[i][j+1] = -1;\n\t\telse lca[i][j+1] = lca[lca[i][j]][j];\n\t}\n\tdfs(a,-1,0);\n\tif(fe) puts(\"-1\");\n\telse cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=200005;\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nint n,fx,fy,dep[MAXN],fa[25][MAXN],bin[25];\nvector<int> nxt[MAXN];\nvoid dfs(int x)\n{\n\tfor(int i=1;bin[i]<=dep[x];i++)fa[i][x]=fa[i-1][fa[i-1][x]];\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y!=fa[0][x])dep[y]=dep[x]+1,fa[0][y]=x,dfs(y);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=18;i>=0;i--)if(bin[i]<=dep[x]&&dep[fa[i][x]]>=dep[y])x=fa[i][x];\n\tif(x==y)return x;\n\tfor(int i=18;i>=0;i--)if(bin[i]<=dep[x]&&fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\nint getdis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\nint mx;\nnamespace S\n{\n\tqueue<pii> li;\n\tint di[MAXN],fa[MAXN];\n\tvector<int> num[MAXN];\n\tvoid init(int x)\n\t{\n\t\tnum[di[x]].push_back(x);\n\t\tfor(int k=0;k<nxt[x].size();k++)\n\t\t{\n\t\t\tint y=nxt[x][k];\n\t\t\tif(y!=fa[x])di[y]=di[x]+1,fa[y]=x,init(y);\n\t\t}\n\t}\n\tbool vis[MAXN];\n\tvoid main()\n\t{\n\t\tinit(fx);vis[0]=1;\n\t\tfor(int i=0;i<=n;i++)for(int j=0;j<num[i].size();j++)\n\t\t{\n\t\t\tbool tf=false;int x=num[i][j];vis[x]=vis[fa[x]]&(i<dep[x]);\n\t\t\tif(vis[x])\n\t\t\t{\n\t\t\t\tfor(int k=0;k<nxt[x].size();k++)if(getdis(x,nxt[x][k])>2){tf=true;break;}\n\t\t\t\tif(tf&&i<dep[x]){puts(\"-1\");exit(0);}\n\t\t\t\tif(i<=dep[x])mx=max(mx,dep[x]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n//\tfreopen(\"a.in\",\"r\",stdin);\n\tbin[0]=1;for(int i=1;i<=20;i++)bin[i]=bin[i-1]<<1;\n\tn=read();fx=read();fy=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tnxt[x].push_back(y);nxt[y].push_back(x);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);ins(y,x);\n\t}dfs(fy);\n\tS::main();\n\tpr2(2*mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N], dfn;\nint dp[N << 1][20], lg2[N], dph[N];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x])\n        if (y != fx) dfsb(y, x);\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] > db[x]) return;\n    if (~ans) ans = max((db[x] - 1)<<1, ans);\n    for (int y : a[x]) {\n        if (dph[id[x]] + dph[id[y]] - 2 * dph[LCA(x, y)] > 2) ans = -1;\n        if (y != fx) dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 400004\nint a[2][N],b[2][N],c[2][N],e[N],f[N],h[N],i,l,n,q[N],r,s[N],t,x,y;bool d[N][2];\ninline bool cmp(int u,int v){return f[u]!=v&&u!=f[v]&&f[u]!=f[v]&&f[f[u]]!=v&&u!=f[f[v]];}\nint u,v;\nint main()\n{\n\tfor(scanf(\"%d%d%d\",&n,&x,&y),i=t=1;i<n;i++)scanf(\"%d%d\",&u,&v),b[0][++t]=a[0][u],c[0][a[0][u]=t]=v,b[0][++t]=a[0][v],c[0][a[0][v]=t]=u;\n\tfor(i=t=1,e[n]=-1;i<n;e[i++]=-1)scanf(\"%d%d\",&u,&v),b[1][++t]=a[1][u],c[1][a[1][u]=t]=v,b[1][++t]=a[1][v],c[1][a[1][v]=t]=u;\n\tfor(d[q[r++]=y][e[y]=1]=true,d[q[r++]=x][e[x]=0]=true,e[y]=1;l<r;)for(v=e[u=q[l++]],i=a[v][u];i;i=b[v][i])if(e[c[v][i]]<e[u])d[q[r++]=c[v][i]][e[c[v][i]]=e[u]]=true,f[c[v][i]]=u,h[c[v][i]]=h[u]+1;\n\tfor(i=1;i<n;i++)if(cmp(c[0][i<<1],c[0][i<<1|1])&&*d[c[0][i<<1]]&&*d[c[0][i<<1|1]])return 0&puts(\"-1\");\n\tfor(i=1,l=r=0;i<=n;e[i++]=-1)d[i][0]=d[i][1]=false;\n\tfor(d[q[r++]=x][e[x]=0]=true,d[q[r++]=y][e[y]=1]=true;l<r;)for(v=e[u=q[l++]],i=a[v][u];i;i=b[v][i])if(e[c[v][i]]<e[u])d[q[r++]=c[v][i]][e[c[v][i]]=e[u]]=true,f[c[v][i]]=u,h[c[v][i]]=h[u]+1;\n\tfor(i=1,v=0;i<=n;i++)if(*d[i]&&v<h[i])v=h[i];\n\treturn 0&printf(\"%d\\n\",v<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 200005\n#define M 200005\n#define K 17\n#define seed 23333\n#define Mo 998244353\n\nusing namespace std;\nint i,j,m,n,p,k,big[N],T[N],lim[N],X,Y,ans=1,Q[N];\nstruct Tre{\n\t\tvector<int>v[N];\n\t\tint fa[N][K+1],deep[N];\n\t\tvoid dfs(int x)\n\t\t{\n\t\t\t\tint i;\n\t\t\t\tfor (i=1;i<=K;++i) fa[x][i]=fa[fa[x][i-1]][i-1];\n\t\t\t\tfor (i=0;i<(int)v[x].size();++i)\n\t\t\t\t{\n\t\t\t\t\t\t\tint p=v[x][i];\n\t\t\t\t\t\t\tif (fa[x][0]==p) continue;\n\t\t\t\t\t\t\tfa[p][0]=x;\n\t\t\t\t\t\t\tdeep[p]=deep[x]+1;\n\t\t\t\t\t\t\tdfs(p);\n\t\t\t\t}\n\t\t}\n\t\tvoid read()\n\t\t{\n\t\t\t\tfor (i=1;i<n;++i)\n\t\t\t\t{\n\t\t\t\t\t\tint x,y;\n\t\t\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\t\t\tv[x].pb(y); v[y].pb(x);\n\t\t\t\t}\n\t\t\t\tdfs(1);\n\t\t} \n\t\tint getfa(int x,int y)\n\t\t{\n\t\t\t  int i,k;\n\t\t\t  if (deep[x]<deep[y]) swap(x,y);\n\t\t\t  for (i=K,k=deep[x]-deep[y];i>=0;--i)\n\t\t\t  \tif (k&(1<<i)) x=fa[x][i];\n\t\t\t  if (x==y) return x;\n\t\t\t  for (i=K;i>=0;--i)\n\t\t\t  \tif (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n\t\t\t  return fa[x][0];\n\t\t}\n\t\tvoid bfs_first()\n\t\t{\n\t\t\t\tmemset(lim,-1,sizeof(lim));\n\t\t\t\tlim[Y]=0;\n\t\t\t\tQ[Q[0]=1]=Y;\n\t\t\t\tint l,i;\n\t\t\t\tfor (l=1;l<=Q[0];++l)\n\t\t\t\t{\n\t\t\t\t\t\tint p=Q[l];\n\t\t\t\t\t\tfor (i=0;i<(int)v[p].size();++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint k=v[p][i];\n\t\t\t\t\t\t\t\tif (lim[k]!=-1) continue;\n\t\t\t\t\t\t\t\tlim[k]=lim[p]+1;\n\t\t\t\t\t\t\t\tQ[++Q[0]]=k;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tvoid bfs_second()\n\t\t{\n\t\t\t\tmemset(T,60,sizeof(T));\n\t\t\t\tT[X]=0;\n\t\t\t\tQ[Q[0]=1]=X;\n\t\t\t\tint l,i;\n\t\t\t\tfor (l=1;l<=Q[0];++l)\n\t\t\t\t{\n\t\t\t\t\t\tint p=Q[l];\n\t\t\t\t\t\tif (T[p]<=lim[p]) ans=max(ans,lim[p]);\n\t\t\t\t\t\tif (T[p]>=lim[p]) continue; \n\t\t\t\t\t\tfor (i=0;i<(int)v[p].size();++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint k=v[p][i];\n\t\t\t\t\t\t\t\tif (T[k]<(int)1e9)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (lim[k]<=T[p]+1) ans=max(ans,T[p]+1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tT[k]=min(T[k],T[p]+1);\n\t\t\t\t\t\t\t\t\tQ[++Q[0]]=k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n}r,b;\nint main()\n{\n\t\tscanf(\"%d%d%d\",&n,&X,&Y);\n\t\tr.read(); b.read(); \n\t\tfor (i=1;i<n;++i)\n\t\t\tfor (j=0;j<(int)r.v[i].size();++j)\n\t\t\t{\n\t\t\t\t\tint x=r.v[i][j];\n\t\t\t\t\tint lca=b.getfa(i,x);\n\t\t\t\t\tif (b.deep[i]+b.deep[x]-2*b.deep[lca]>=3) big[i]=big[x]=1;\n\t\t\t}\n\t\tb.bfs_first();\n\t\tr.bfs_second();\n\t\tfor (i=1;i<=n;++i) \n\t\tif (big[i]&&T[i]<lim[i]) \n\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0; \n\t\t}\n\t\tprintf(\"%d\\n\",ans*2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int N=200005;\nint n,x,y,i,j,k,head[N],adj[N*2],nxt[N*2],Head[N],Adj[N*2],Nxt[N*2],dis[N],Dis[N],Fa[N],ans;\nbool ok[N];\nvoid dfs(int x,int dad)\n{\n\tfor(int y=head[x];y;y=nxt[y])\n\t\tif(adj[y]!=dad)\n\t\t{\n\t\t\tdis[adj[y]]=dis[x]+1;\n\t\t\tdfs(adj[y],x);\n\t\t}\n}\nvoid Dfs(int x,int dad)\n{\n\tfor(int y=Head[x];y;y=Nxt[y])\n\t\tif(Adj[y]!=dad)\n\t\t{\n\t\t\tDis[Adj[y]]=Dis[x]+1;\n\t\t\tFa[Adj[y]]=x;\n\t\t\tDfs(Adj[y],x);\n\t\t}\n}\nint dist(int a,int b)\n{\n\tint rtn=0;\n\twhile(a!=b)\n\t{\n\t\tif(Dis[a]<Dis[b])\n\t\t\tswap(a,b);\n\t\ta=Fa[a];\n\t\t++rtn;\n\t\tif(rtn>2)\n\t\t\treturn rtn;\n\t}\n\treturn rtn;\n}\nvoid work(int x,int dad)\n{\n\tfor(int y=head[x];y;y=nxt[y])\n\t\tif(dist(x,adj[y])>2)\n\t\t\tans=1<<30;\n\tans=max(ans,Dis[x]);\n\tfor(int y=head[x];y;y=nxt[y])\n\t\tif(adj[y]!=dad&&ok[adj[y]])\n\t\t\twork(adj[y],x);\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tadj[i*2-1]=k;\n\t\tnxt[i*2-1]=head[j];\n\t\thead[j]=i*2-1;\n\t\tadj[i*2]=j;\n\t\tnxt[i*2]=head[k];\n\t\thead[k]=i*2;\n\t}\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tAdj[i*2-1]=k;\n\t\tNxt[i*2-1]=Head[j];\n\t\tHead[j]=i*2-1;\n\t\tAdj[i*2]=j;\n\t\tNxt[i*2]=Head[k];\n\t\tHead[k]=i*2;\n\t}\n\tdfs(x,-1);\n\tDfs(y,-1);\n\tfor(i=1;i<=n;++i)\n\t\tif(dis[i]<Dis[i])\n\t\t\tok[i]=true;\n\twork(x,-1);\n\tif(ans==(1<<30))\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d\",2*ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <class Type>\nclass LCA {\n    public:\n    LCA(int n);\n    ~LCA();\n    void add_edge(int from, int to, Type cost = 1);\n    void add_undirected_edge(int from, int to, Type cost = 1);\n    void init(int root = 0);\n    int up(int x, int c);\n    int lca(int x, int y);\n    Type dist(int x, int y);\n    \n    private:\n    struct edge {\n        int to;\n        Type cost;\n        edge(int to, Type cost) : to(to), cost(cost) {}\n    };\n    vector <vector <edge> > graph;\n    int size;\n    int high;\n    int *parent;\n    int *depth;\n    Type *distance;\n    int dfs(int now, int par, int dep, Type dist);\n};\n\ntemplate <class Type> LCA<Type>::LCA(int n) : size(n), high(32 - __builtin_clz(n)), graph(n) {\n    parent = (int *)malloc(sizeof(int) * size * high);\n    depth = (int *)malloc(sizeof(int) * size);\n    distance = (Type *)malloc(sizeof(Type) * size);\n}\n\ntemplate <class Type> LCA<Type>::~LCA() {\n    free(parent);\n    free(depth);\n    free(distance);\n}\n\ntemplate <class Type> void LCA<Type>::add_edge(int from, int to, Type cost) {\n    graph[from].push_back(edge(to, cost));\n}\n\ntemplate <class Type> void LCA<Type>::add_undirected_edge(int from, int to, Type cost) {\n    graph[from].push_back(edge(to, cost));\n    graph[to].push_back(edge(from, cost));\n}\n\ntemplate <class Type> void LCA<Type>::init(int root) {\n    dfs(root, -1, 0, 0);\n    for (int i = 0; i + 1 < high; i++) {\n        for (int j = 0; j < size; j++) {\n            if (parent[j * high + i] == -1) {\n                parent[j * high + i + 1] = -1;\n            } else {\n                parent[j * high + i + 1] = parent[parent[j * high + i] * high + i];\n            }\n        }\n    }\n}\n\ntemplate <class Type> int LCA<Type>::up(int x, int c) {\n    while (c > 0) {\n        int right = __builtin_ctz(c);\n        x = parent[x * high + right];\n        c ^= 1 << right;\n    }\n    return x;\n}\n\ntemplate <class Type> int LCA<Type>::lca(int x, int y) {\n    if (depth[x] > depth[y]) swap(x, y);\n    y = up(y, depth[y] - depth[x]);\n    if (x == y) return x;\n    for (int i = 31 - __builtin_clz(depth[x]); i >= 0; i--) {\n        if (parent[x * high + i] != parent[y * high + i]) {\n            x = parent[x * high + i];\n            y = parent[y * high + i];\n        }\n    }\n    return parent[x * high];\n}\n\ntemplate <class Type> Type LCA<Type>::dist(int x, int y) {\n    return distance[x] + distance[y] - distance[lca(x, y)] * 2;\n}\n\ntemplate <class Type> int LCA<Type>::dfs(int now, int par, int dep, Type dist) {\n    int val = 1e9;\n    for (int i = 0; i < graph[now].size(); i++) {\n        if (graph[now][i].to != par) val = min(val, dfs(graph[now][i].to, now, dep + 1, dist + graph[now][i].cost) + 1);\n    }\n    parent[now * high] = par;\n    depth[now] = dep;\n    distance[now] = dist;\n    return val;\n}\n\nint d[200000];\nvector <int> v[200000];\n\nint main() {\n    int n, x, y, ans = 0, i;\n    queue <int> q;\n    \n    scanf(\"%d %d %d\", &n, &x, &y);\n    \n    x--;\n    y--;\n    \n    LCA <int> l(n);\n    \n    for (i = 0; i < n - 1; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        a--;\n        b--;\n        \n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    \n    for (i = 0; i < n - 1; i++) {\n        int a, b;\n        \n        scanf(\"%d %d\", &a, &b);\n        \n        l.add_undirected_edge(a - 1, b - 1);\n    }\n    \n    l.init();\n    \n    for (i = 0; i < n; i++) d[i] = -1;\n    \n    d[x] = 0;\n    q.push(x);\n    \n    while (!q.empty()) {\n        int x = q.front();\n        \n        q.pop();\n        \n        for (i = 0; i < v[x].size(); i++) {\n            int nx = v[x][i];\n            \n            if (l.dist(x, nx) >= 3) {\n                puts(\"-1\");\n                \n                return 0;\n            }\n            \n            if (d[nx] == -1 && l.dist(y, nx) > d[x] + 1) {\n                d[nx] = d[x] + 1;\n                q.push(nx);\n            }\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (d[i] >= 0) ans = max(ans, l.dist(y, i) * 2);\n    }\n    \n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nvector<int> v[2][200005];\nint p[20][200005];\nint dis[200005];\nvoid dfs(int x,int f, vector<int> *v){\n    dis[ x ] = dis[ f ] + 1;\n    p[ 0 ][ x ] = f;\n    for(auto it : v[x]){\n        if(it != f){\n            dfs(it, x, v);\n        }\n    }\n}\nvoid build(int n){\n    for(int i = 1 ; i < 20 ; i++){\n        for(int j = 1 ; j <= n ; j++){\n            p[ i ][ j ] = p[ i - 1 ][ p[ i - 1 ][ j ] ];\n        }\n    }\n}\nint lca(int x, int y){\n    if (dis[ x ] > dis[ y ])swap(x, y);\n    int d = dis[ y ] - dis[ x ];\n    for(int i = 0 ; i < 20 ; i++ ){\n        if( d & (1 << i) ){\n            y = p[ i ][ y ];\n        }\n    }\n    if (x == y)\n        return x;\n    for(int i = 19 ; i >= 0 ; i-- ){\n        if( p[ i ][ x ] != p[ i ][ y ] ){\n            x = p[ i ][ x ];\n            y = p[ i ][ y ];\n        }\n    } \n    return p[ 0 ][ x ];\n}\nint getdis(int x, int y){\n    return dis[ x ] + dis[ y ] - 2*dis[ lca(x, y) ];\n}\nint ans;\nvoid dfs2(int x,int f,vector<int> *v,int sum=0){\n    if(dis[x]==sum){\n        ans=max(ans,dis[x]*2);\n    }\n    if(dis[x]<=sum)return;\n    ans=max(ans,dis[x]*2);\n    for(auto it:v[x]){\n        if( it != f){\n            if(getdis(x,it)>=3&&dis[x] > sum){\n                //printf(\"%d %d %d %d %d\\n\",x,it,dis[x],sum,getdis(x,it));\n                printf(\"-1\\n\");\n                exit(0);\n            }\n            dfs2(it, x, v, sum+1);\n        }\n    }\n}\nint main(){\n    int n, x, y;\n    scanf(\"%d %d %d\", &n, &x, &y);\n    for(int i = 0 ; i < 2 ; i++ ){\n        for(int j = 1 ; j < n ; j++ ){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            v[i][x].pb(y);\n            v[i][y].pb(x);\n        }\n    }\n    dis[0]=-1;\n    dfs(y, 0, v[1]);\n    build(n);\n    dfs2(x, 0, v[0]);\n    printf(\"%d\\n\",ans);\n}\n/*\n\nb[i]*K!/(i)!*(K-i)!\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=200010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN], B[MAXN];\nint h[MAXN], par[MAXN];\nint dp[MAXN];\nbool good[MAXN];\nqueue<int> Q;\nvector<int> G[MAXN], adj[MAXN];\n\nvoid dfs(int node){\n\th[node]=h[par[node]]+1;\n\tfor (int v:G[node]) if (v!=par[node]){\n\t\tpar[v]=node;\n\t\tdfs(v);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n>>x>>y;\n\tfor (int i=1; i<n; i++) cin>>A[i]>>B[i];\n\tfor (int i=1; i<n; i++){\n\t\tcin>>u>>v;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\th[0]=-1;\n\tdfs(y);\n\tfor (int i=1; i<n; i++){\n\t\tint u=A[i], v=B[i], d=0;\n\t\twhile (u!=v && d<=2){\n\t\t\tif (h[u]>h[v]) swap(u, v);\n\t\t\tv=par[v];\n\t\t\td++;\n\t\t}\n\t\tif (d==3) good[A[i]]=good[B[i]]=1;\n\t\telse{\n\t\t\tadj[A[i]].pb(B[i]);\n\t\t\tadj[B[i]].pb(A[i]);\n\t\t}\n\t}\n\tmemset(dp, 63, sizeof(dp));\n\tdp[x]=0;\n\tQ.push(x);\n\twhile (Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tif (h[v]<dp[v]) continue ;\n//\t\tdebug2(v, dp[v])\n\t\tans=max(ans, 2*h[v]);\n\t\tif (h[v]==dp[v]) continue ;\n\t\tif (good[v]) kill(-1)\n\t\tfor (int u:adj[v]) if (dp[u]>dp[v]+1){\n\t\t\tdp[u]=dp[v]+1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200010;\n\nint n, X, Y;\nint tag[maxn], vis[maxn];\n\nstruct Tree {\n\tint l[maxn], dep[maxn], fa[maxn][20], e, r;\n\n\tTree() {memset(l, -1, sizeof(l));}\n\n\tstruct Edge {\n\t\tint v, x;\n\t} E[maxn<<1];\n\n\tinline void addEdge(int u, int v) {\n\t\tE[e].v = v, E[e].x = l[u], l[u] = e++;\n\t\tE[e].v = u, E[e].x = l[v], l[v] = e++;\n\t}\n\n\tvoid dfs(int u, int f) {\n\t\tfa[u][0] = f;\n\t\tfor (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\tif (v != f) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tdfs(v, u);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init(int rt) {\n\t\tr = rt;\n\t\tdfs(r, 0);\n\t}\n\n\tint lca(int u, int v) {\n\t\tif (dep[u] < dep[v]) swap(u, v);\n\t\tif (dep[u] > dep[v]) {\n\t\t\tint c = dep[u] - dep[v];\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tif (c & (1 << i)) {\n\t\t\t\t\tu = fa[u][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int i = 19; i >= 0; i--) {\n\t\t\tif (fa[u][i] != fa[v][i]) {\n\t\t\t\tu = fa[u][i], v = fa[v][i];\n\t\t\t}\n\t\t}\n\t\treturn fa[u][0];\n\t}\n\n\tint dis(int u, int v) {\n\t\treturn dep[u] + dep[v] - 2 * dep[lca(u, v)];\n\t}\n} T1, T2;\n\nvoid dfs_vis(int u, int f) {\n\tvis[u] = 1;\n\tfor (int p = T1.l[u]; p >= 0; p = T1.E[p].x) {\n\t\tint v = T1.E[p].v;\n\t\tif (v != f) {\n\t\t\t// 此时 Y 的深度为 T1.dep[u]\n\t\t\tif (T2.dep[v] > T1.dep[u] + 1) {\n\t\t\t\tdfs_vis(v, u);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &X, &Y);\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT1.addEdge(a, b);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tint c, d; \n\t\tscanf(\"%d%d\", &c, &d);\n\t\tT2.addEdge(c, d);\n\t}\n\tT1.init(X), T2.init(Y);\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int p = T1.l[u]; p >= 0; p = T1.E[p].x) {\n\t\t\tint v = T1.E[p].v;\n\t\t\tif (T2.dis(u, v) > 2) {\n\t\t\t\ttag[u] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tdfs_vis(X, 0);\n\tint ans = 0;\n\tfor (int u = 1; u <= n; u++) {\n\t\tif (vis[u]) {\n\t\t\tif (tag[u]) ans = 0x3f3f3f3f;\n\t\t\telse ans = max(ans, T2.dep[u]);\n\t\t}\n\t}\n\tif (ans < 0x3f3f3f3f) printf(\"%d\\n\", ans << 1);\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX_LG = 20;\nconst int MAX_N = 2e5 + 5;\nconst int INF = 1e9 + 5;\n\nnamespace Ender {\n  vector<int> adj [MAX_N];\n  int par [MAX_N];\n  int lvl [MAX_N];\n  int lend [MAX_N], rend [MAX_N];\n  int jmp [MAX_N][MAX_LG];\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  int lca (int u, int v) {\n    if (lvl[u] < lvl[v]) swap(u, v);\n\n    int diff = lvl[u] - lvl[v];\n    for (int i = 0; i < MAX_LG; i++) {\n      if (diff & 1 << i) {\n        u = jmp[u][i];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int i = MAX_LG - 1; i >= 0; i--) {\n      if (jmp[u][i] != jmp[v][i]) {\n        u = jmp[u][i];\n        v = jmp[v][i];\n      }\n    }\n    return jmp[u][0];\n  }\n\n  int dist (int u, int v) {\n    return lvl[u] + lvl[v] - 2 * lvl[lca(u, v)];\n  }\n\n  int anc_at (int u, int l) {\n    int diff = lvl[u] - l;\n\n    for (int i = 0; i < MAX_LG; i++) {\n      if (diff & 1 << i) {\n        u = jmp[u][i];\n      }\n    }\n    return u;\n  }\n  \n  void dfs (int u, int p, int &cur) {\n    jmp[u][0] = p;\n    for (int i = 1; i < MAX_LG; i++) {\n      jmp[u][i] = jmp[jmp[u][i - 1]][i - 1];\n    }\n    \n    cur++;\n    lend[u] = cur;\n    lvl[u] = lvl[p] + 1;\n    par[u] = p;\n\n    for (int nxt : adj[u]) {\n      if (nxt != p) {\n        dfs(nxt, u, cur);\n      }\n    }\n    \n    rend[u] = cur;\n  }\n  \n  void build () {\n    int cur = 0;\n    dfs(1, 0, cur);\n  }\n  \n  bool islong (int u, int v) {\n    if (u == v) return false; // dist 0\n    if (par[u] == v || par[v] == u) return false; // dist 1\n    if (par[par[u]] == v || par[par[v]] == u) return false; // dist 2, grandparent\n    if (par[u] == par[v]) return false; // dist 2, cousin\n    return true;\n  }\n\n  int towards (int cur, int tar) {\n    if (cur == tar) return cur;\n    if (lend[tar] < lend[cur] || rend[cur] < lend[tar]) return par[cur];\n    return anc_at(tar, lvl[cur] + 1);\n  }\n}\n\nnamespace Delayer {\n  vector<int> adj [MAX_N];\n  int special [MAX_N];\n  \n  vector<pair<int, int>> edges;\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    edges.push_back(make_pair(u, v));\n  }\n\n  void build () {\n    for (auto pr : edges) {\n      if (Ender::islong(pr.first, pr.second)) {\n        special[pr.first] = 1;\n        special[pr.second] = 1;\n      }\n    }\n  }\n}\n\nint dpt = 0;\nint play (int d, int dl, int e) {\n  /*\n  for (int i = 0; i < 2 * dpt; i++) {\n    cout << \" \";\n  }\n  cout << d << \" \" << e << endl;\n  */\n  //  cerr << d << \" \" << dl << \" \" << e << endl;\n  \n  if (e == d) return 0;\n  if (Delayer::special[d]) return INF;\n  \n  int ans = 2 * Ender::dist(d, e);\n  for (int nxt : Delayer::adj[d]) {\n    if (nxt != dl) {\n      dpt += 2;\n      ans = max(ans, 2 + play(nxt, d, Ender::towards(e, nxt)));\n      dpt -= 2;\n    }\n  }\n  return ans;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n  \n  int n, x, y;\n  cin >> n >> x >> y;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Delayer::add_edge(u, v);\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Ender::add_edge(u, v);\n  }\n\n  Ender::build();\n  Delayer::build();\n  \n  int ans = play(x, -1, y);\n  if (ans >= INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2e5+5;\nvector<int> t[N],t2[N];\nint dep[N],dep2[N];\nint fa[N],fa2[N];\nint n,A,B;\ntypedef pair<int,int> edge;\nedge e[N];\ninline void dfs2(int x,int pre){\n\tfa2[x]=pre;\n\tfor(size_t i=0;i<t2[x].size();i++){\n\t\tint v=t2[x][i];if(v==pre)continue;\n\t\tdep2[v]=dep2[x]+1;\n\t\tdfs2(v,x);\n\t}\n}\n\nbool mark[N];\nbool endless;\nint ans=0;\ninline void dfs(int x,int pre){\n\tif(dep[x]<dep2[x]){\n\t\tif(mark[x]) endless=1;\n\t\tans=max(ans,2*dep2[x]);\n\t}\n\telse return;\n\tfor(size_t i=0;i< t[x].size();i++){\n\t\tint v=t[x][i];if(v==pre)continue;\n\t\tdep[v]=dep[x]+1;\n\t\tdfs(v,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tt[u].push_back(v),t[v].push_back(u);\n\t\te[i]=edge(u,v);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tt2[u].push_back(v),t2[v].push_back(u);\n\t}\n\tdfs2(B,0);\n\tfor(int i=1;i<n;i++){\n\t\tint u=e[i].first,v=e[i].second;\n//\t\tcout<<u<<' '<<v<<\" \"<<dep2[u]<<\" \"<<dep2[v]<<\" \"<<fa2[u]<<endl;\n\t\tif((fa2[fa2[u]]==v)||(fa2[fa2[v]]==u)||(fa2[u]==fa2[v]&&fa2[u]!=0)||fa2[u]==v||fa2[v]==u){\n\t\t\tcontinue;\n\t\t}else{\n//\t\t\tcout<<\"why\"<<endl;\n\t\t\tmark[u]=mark[v]=1;\n\t\t}\n\t}\n\tdfs(A,0);\n\tprintf(\"%d\\n\",endless?-1:ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N=200005;\n\nint fst[N],dep[N],d[N],a[N],b[N],fa[N],tot=0,ans=0;\nbool u[N];\nstruct Edge{\n\tint to,nxt;\n}e[N*2];\n\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\n\nvoid dfs(int x){\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y!=fa[x]){\n\t\t\tfa[y]=x;\n\t\t\tdep[y]=dep[x]+1;\n\t\t\tdfs(y);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x,int v){\n\tif (ans==-1 || d[x]>=dep[x]) return;\n\tif (u[x]) ans=-1;\n\t\telse if (dep[x]*2>ans) ans=dep[x]*2;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y!=v){\n\t\t\td[y]=d[x]+1;\n\t\t\tdfs2(y,x);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,X,Y;\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor (int i=1;i<n;i++) scanf(\"%d%d\\n\",&a[i],&b[i]);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y);\n\t\taddedge(y,x);\n\t}\n\tdfs(Y);\n\tfor (int i=1;i<=n;i++) fst[i]=0;\n\ttot=0;\n\tfor (int i=1;i<n;i++){\n\t\tint x=a[i],y=b[i],fx=fa[x],fy=fa[y];\n\t\tif (fx==y||fy==x||fa[fx]==y||fa[fy]==x||fx==fy) addedge(x,y);\n\t\t\telse u[x]=u[y]=1;\n\t}\n\tdfs2(X,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int maxn=2e5+10;\nint n,x,y,u[maxn],v[maxn],dep[maxn],fa[maxn][19],len[maxn],ans;\nvector<int> G[maxn],H[maxn];bool vis[maxn],hry[maxn];\nvoid dfs(int u){for(int v:G[u]) if(v^fa[u][0]) dep[v]=dep[u]+1,fa[v][0]=u,dfs(v);}\nint lca(int u,int v){\n\tif(dep[u]<dep[v]) swap(u,v);\n\tif(dep[u]^dep[v]){int t=dep[u]-dep[v];rep(i,0,18) if(t&(1<<i)) u=fa[u][i];}\n\tif(u==v) return u;\n\tper(i,18,0) if(fa[u][i]^fa[v][i]) u=fa[u][i],v=fa[v][i];\n\treturn fa[u][0];\n}\nint dis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\nvoid dfs2(int u){\n\tvis[u]=1;\n\tfor(int v:H[u]) if(!vis[v]&&(dep[v]>len[u]+1)) len[v]=len[u]+1,dfs2(v);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\trep(i,1,n-1) scanf(\"%d%d\",&u[i],&v[i]);\n\trep(i,1,n-1){int u,v;scanf(\"%d%d\",&u,&v);G[u].pb(v);G[v].pb(u);}\n\tdfs(y);rep(i,1,18) rep(j,1,n) if(fa[j][i-1]) fa[j][i]=fa[fa[j][i-1]][i-1];\n\trep(i,1,n-1) \n\t\tif(dis(u[i],v[i])<=2) H[u[i]].pb(v[i]),H[v[i]].pb(u[i]);\n\t\telse hry[u[i]]=hry[v[i]]=1;\n\tdfs2(x);\n\trep(i,1,n)\n\t\tif(vis[i]&&hry[i]) return puts(\"-1\"),0;\n\t\telse if(vis[i]) ans=max(ans,dep[i]<<1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,X,Y,par[MX], dist[2][MX];\nvi adj[2][MX];\nbool spec[MX];\nvpi ed;\n\nvoid dfs(int x) {\n\ttrav(t,adj[1][x]) if (t != par[x]) {\n\t\tpar[t] = x; dist[1][t] = dist[1][x]+1;\n\t\tdfs(t);\n\t}\n}\n\nbool far(int a, int b) {\n\tint d = 0;\n\twhile (a != b) {\n\t\tif (dist[1][a] < dist[1][b]) swap(a,b);\n\t\ta = par[a]; d ++; if (d > 2) return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n    setIO(); re(N,X,Y);\n    F0R(i,N-1) {\n    \tint a,b; re(a,b);\n    \ted.pb({a,b});\n    }\n    F0R(i,N-1) {\n    \tint c,d; re(c,d);\n    \tadj[1][c].pb(d), adj[1][d].pb(c);\n    }\n    dfs(Y);\n    trav(t,ed) {\n    \tif (far(t.f,t.s)) spec[t.f] = spec[t.s] = 1;\n    \telse adj[0][t.f].pb(t.s), adj[0][t.s].pb(t.f);\n    }\n    FOR(i,1,N+1) dist[0][i] = MOD;\n    queue<int> q; q.push(X); dist[0][X] = 0;\n    int ret = 0;\n    while (sz(q)) {\n    \tint x = q.front(); q.pop();\n    \tif (dist[0][x] > dist[1][x]) continue;\n    \tckmax(ret,2*dist[1][x]);\n        if (dist[0][x] == dist[1][x]) continue;\n    \tif (spec[x]) {\n    \t\tps(-1);\n    \t\texit(0);\n    \t}\n    \ttrav(t,adj[0][x]) if (dist[0][t] == MOD) {\n    \t\tdist[0][t] = dist[0][x]+1;\n    \t\tq.push(t);\n    \t}\n    }\n    ps(ret);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = (a + (b)) % MOD\n#define Mul(a, b) a = (a * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 200010;\nconst ll maxnlg = 19;\n\nll n, X, Y;\npii es_a[maxn];\nvi g[2][maxn];\nll st[maxn], ft[maxn], pars[maxnlg][maxn], ht[maxn];\nll q[maxn * 2], col[maxn];\nbool vis[maxn], vis2[maxn];\n\nll tim = 0;\nvoid dfs_lca(ll x, ll par) {\n    st[x] = tim++;\n    pars[0][x] = par;\n    fori (i, maxnlg - 1) pars[i + 1][x] = pars[i][pars[i][x]];\n    for (auto y : g[1][x]) {\n        if (y != par) {\n            ht[y] = ht[x] + 1;\n            dfs_lca(y, x);\n        }\n    }\n    ft[x] = tim;\n}\n\nll LCA(ll a, ll b) {\n    if (st[a] > st[b]) swap(a, b);\n    if (ft[a] >= ft[b]) return a;\n    forir (i, maxnlg) {\n        if (ft[pars[i][a]] < ft[b]) a = pars[i][a];\n    }\n    return pars[0][a];\n}\n\nvoid MAIN() {\n\n    cin >> n >> X >> Y; --X, --Y;\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        es_a[i] = {a, b};\n        g[0][a].eb(b), g[0][b].eb(a);\n    }\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        g[1][a].eb(b), g[1][b].eb(a);\n    }\n    dfs_lca(Y, Y);\n\n    // memset(col, -1, sizeof col);\n    // ll l = 0, r = 0;\n    // q[r++] = Y;\n    // q[r++] = X;\n    // vis[X] = true;\n    // col[X] = 0;\n    // col[Y] = 1;\n    // while (r != l) {\n    //     ll x = q[l++];\n    //     for (auto y : g[col[x]][x]) {\n    //         if (col[y] == -1 || col[x] == 1 && col[y] != 1) {\n    //             if (col[x] == 0) vis[y] = true;\n    //             col[y] = col[x];\n    //             q[r++] = y;\n    //         }\n    //     }\n    // }\n\n    memset(col, -1, sizeof col);\n    ll l = 0, r = 0;\n    q[r++] = X;\n    q[r++] = Y;\n    vis2[X] = true;\n    col[X] = 0;\n    col[Y] = 1;\n    while (r != l) {\n        ll x = q[l++];\n        if (col[x] == 0) vis[x] = true;\n        for (auto y : g[col[x]][x]) {\n            if (col[y] == -1 || col[x] == 1 && col[y] != 1) {\n                if (col[x] == 0) vis2[y] = true;\n                col[y] = col[x];\n                q[r++] = y;\n            }\n        }\n    }\n\n    fori (i, n - 1) {\n        ll a, b; tie(a, b) = es_a[i];\n        if ((vis[a] || vis[b]) && ht[a] + ht[b] - ht[LCA(a, b)] * 2 > 2) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    ll ans = 0;\n    fori (i, n) {\n        if (vis2[i]) smax(ans, ht[i]);\n    }\n    cout << ans * 2 << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n5 2 1\n1 5\n1 4\n4 3\n3 2\n1 5\n5 3\n1 4\n2 3\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=200005;\nint deep[N],dfn[N],ed[N],fa[N],dis[N],Time,ans;\nstruct Tree{\n\tint Head[N],Next[N<<1],Adj[N<<1],tot;\n\tinline void addedge(int u,int v){\n\t\tNext[++tot]=Head[u],Head[u]=tot,Adj[tot]=v;\n\t\tNext[++tot]=Head[v],Head[v]=tot,Adj[tot]=u;\n\t}\n\tinline void dfs(int x,int f){\n\t\tdfn[x]=++Time,fa[x]=f;\n\t\tfor (int e=Head[x];e;e=Next[e])\n\t\t\tif (Adj[e]!=f){\n\t\t\t\tdis[Adj[e]]=dis[x]+1;\n\t\t\t\tdfs(Adj[e],x);\n\t\t\t}\n\t\ted[x]=Time;\n\t}\n\tinline bool check(int x,int y){\n\t\tif (dfn[x]>dfn[y]) swap(x,y);\n\t\tif (dfn[y]>=dfn[x]&&dfn[y]<=ed[x]) return dis[y]-dis[x]>2;\n\t\treturn fa[x]!=fa[y];\n\t}\n\tinline void dfs2(int x,int f){\n\t\tif (deep[x]>=dis[x]) return;\n\t\tans=max(ans,dis[x]*2);\n\t\tfor (int e=Head[x];e;e=Next[e])\n\t\t\tif (Adj[e]!=f){\n\t\t\t\tdeep[Adj[e]]=deep[x]+1;\n\t\t\t\tdfs2(Adj[e],x);\n\t\t\t\tif (check(x,Adj[e])) {puts(\"-1\");exit(0);}\n\t\t\t}\n\t}\n}T1,T2;\nint main(){\n\tint n,x,y;scanf (\"%d%d%d\",&n,&x,&y);\n\tif (x==y){puts(\"0\");return 0;}\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;scanf (\"%d%d\",&u,&v);\n\t\tT1.addedge(u,v);\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;scanf (\"%d%d\",&u,&v);\n\t\tT2.addedge(u,v);\n\t}\n\tT2.dfs(y,0);\n\tT1.dfs2(x,0);\n\tprintf (\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<tuple>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<ctype.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<double, double> pdd;\ntypedef tuple<int,int,int> t3;\n\nconst int MX = 200005;\nconst int MM = 924844033;\n\nvector<int> R[MX], B[MX];\n\nint dR[MX], dB[MX], P[MX][20];\n\nint dfsB(int x, int p = -1){\n\tfor(int c : B[x]){\n\t\tif( c == p ) continue;\n\t\tdB[c] = dB[x] + 1;\n\t\tdfsB(c, x);\n\t}\n}\n\nint dfs(int x, int p = -1){\n\tfor(int c : R[x]){\n\t\tif( c == p ) continue;\n\t\tdR[c] = dR[x] + 1;\n\t\tP[c][0] = x;\n\t\tfor(int t = 1; t < 20; t++) P[c][t] = P[P[c][t-1]][t-1];\n\t\tdfs(c, x);\n\t}\n}\n\nint dist(int a, int b){\n\tint ans = 0;\n\tif( dR[a] < dR[b] ) swap(a, b);\n\tfor(int i = 0; i < 20; i++){\n\t\tif( (dR[a] - dR[b])&1<<i ) ans += 1<<i, a = P[a][i];\n\t}\n\tfor(int i = 19; i >= 0; i--){\n\t\tif( P[a][i] != P[b][i] ) ans += 1<<i+1, a = P[a][i], b = P[b][i];\n\t}\n\treturn ans + (a==b ? 0 : 2);\n}\n\nint win[MX];\nint ans = 0;\n\nvoid solve(int x, int p = -1){\n\tans = max(ans, dR[x] * 2);\n\tif( win[x] ) ans = 1e9;\n\tfor(int c : B[x]){\n\t\tif( c == p ) continue;\n\t\tif( dB[c] >= dR[c] ){\n\t\t\tans = max(ans, dR[c] * 2);\n\t\t\tcontinue;\n\t\t}\n\t\tsolve(c, x);\n\t}\n}\n\nint main()\n{\n\tint N, X, Y;\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tB[a].push_back(b);\n\t\tB[b].push_back(a);\n\t}\n\n\tfor(int i = 1; i < N; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tR[a].push_back(b);\n\t\tR[b].push_back(a);\n\t}\n\tdfs(Y);\n\tdfsB(X);\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int c : B[i]){\n\t\t\tif( dist(i, c) >= 3 ) win[i] = win[c] = 1;\n\t\t}\n\t}\n\tans = dR[X] * 2;\n\tsolve(X);\n\tif( ans == 1e9 ) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> PII;\ntypedef pair <int, int> PLL;\ntypedef pair <PLL, int> PLLI;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <ll, int> PLI;\ntypedef pair <ld, ld> PLD;\ntypedef pair <PLD, ld> PLDD;\ntypedef pair <PLL, ll> PLLL;\ntypedef unsigned int ui;\nconst int inf = 1e9+9;\nconst int mod = 1e9+7;\nconst ll MOD = 1e9+696969;\nconst long long INF = (ll)1e18+3;\nint n, m, k, a, b, c, DL = 0, CC = 0, T;\n#define maxn 200100\nvector <int> v[2][maxn];\nint d[maxn][2];\nint X, Y;\n\nvoid BFS(int graf, int start) {\n\tbool sp = 0;\n\tif (graf == 2) graf = 0, sp = 1;\n\tqueue <int> q;\n\twhile (!q.empty()) q.pop();\n\tFOR(i, 1, n) d[i][graf] = inf;\n\td[start][graf] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tif (sp && d[x][graf] >= d[x][1]) continue;\n\t\tfor (auto u : v[graf][x])\n\t\t  if (d[u][graf] == inf) {\n\t\t\t  d[u][graf] = d[x][graf] + 1;\n\t\t\t  q.push(u);\n\t\t  }\n\t}\n}\n\nmap <PII, bool> mapa;\n\nconst int D = 1000;\nint BIG[maxn];\n\nint main() {\n\tboost;\n\tcin >> n >> X >> Y;\n\tFOR(i, 2, n) {\n\t\tcin >> a >> b;\n\t\tv[0][a].pb(b);\n\t\tv[0][b].pb(a);\n\t}\n\t\n\tFOR(i, 2, n) {\n\t\tcin >> a >> b;\n\t\tmapa[{a, b}] = 1;\n\t\tv[1][a].pb(b);\n\t\tv[1][b].pb(a);\n\t}\n\t\n\tFOR(i, 1, n) sort(v[1][i].begin(), v[1][i].end());\n\t\n\tint ILE = 0;\n\tFOR(i, 1, n)\n\t  if (v[1][i].size() < 400) {\n\t\t  for (auto u : v[1][i])\n\t\t    for (auto p : v[1][i])\n\t\t      if (u != p) mapa[{u, p}] = 1;\n\t  }\n\t  else BIG[++ILE] = i;\n\t  \n\tFOR(i, 1, n)\n\t  for (auto u : v[0][i]) {\n\t\t  //to sumarycznie robi obrot N petli\n\t\t  FOR(cnt, 1, ILE) {\n\t\t\t  int kt = BIG[cnt];\n\t\t\t  if (binary_search(v[1][kt].begin(), v[1][kt].end(), i) &&\n\t\t\t\t  binary_search(v[1][kt].begin(), v[1][kt].end(), u)) mapa[{i,u}] = 1;\n\t\t}\n  }\n\t\n\tBFS(0, X);\n\tBFS(1, Y);\n\n\tFOR(i, 1, n)\n\t  for (auto u : v[0][i]) {\n\t\t  if (!mapa[{i,u}] && !mapa[{u,i}]) {\n\t\t\t  //jest potencjalnie dobra para\n\t\t\t  if (d[i][0] < d[u][0]) {\n\t\t\t\tif (d[i][0] < d[i][1]) OUT(-1);\n\t\t\t}\n\t\t\t  else {\n\t\t\t\t  if (d[u][0] < d[u][1]) OUT(-1);\n\t\t\t  }\n\t\t  }\n\t  }\n\t \n\tBFS(2, X);\n\tint wynik = 0;\n\tFOR(i, 1, n)\n\t  if (d[i][0] < d[i][1]) wynik = max(wynik, 2 * d[i][1]);\n\t  \n\tcout << wynik << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200010;\n\nint n, X, Y;\nint tag[maxn], vis[maxn];\n\nstruct Tree {\n\tint l[maxn], dep[maxn], fa[maxn][20], e, r;\n\n\tTree() {memset(l, -1, sizeof(l));}\n\n\tstruct Edge {\n\t\tint v, x;\n\t} E[maxn<<1];\n\n\tinline void addEdge(int u, int v) {\n\t\tE[e].v = v, E[e].x = l[u], l[u] = e++;\n\t\tE[e].v = u, E[e].x = l[v], l[v] = e++;\n\t}\n\n\tvoid dfs(int u, int f) {\n\t\tfa[u][0] = f;\n\t\tfor (int i = 1; i < 20; i++) fa[u][i] = fa[fa[u][i-1]][i-1];\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\tif (v != f) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tdfs(v, u);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid init(int rt) {\n\t\tr = rt;\n\t\tdfs(r, 0);\n\t}\n\n\tint lca(int u, int v) {\n\t\tif (dep[u] < dep[v]) swap(u, v);\n\t\tif (dep[u] > dep[v]) {\n\t\t\tint c = dep[u] - dep[v];\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tif (c & (1 << i)) {\n\t\t\t\t\tu = fa[u][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int i = 19; i >= 0; i--) {\n\t\t\tif (fa[u][i] != fa[v][i]) {\n\t\t\t\tu = fa[u][i], v = fa[v][i];\n\t\t\t}\n\t\t}\n\t\treturn fa[u][0];\n\t}\n\n\tint dis(int u, int v) {\n\t\treturn dep[u] + dep[v] - 2 * dep[lca(u, v)];\n\t}\n} T1, T2;\n\nvoid dfs_vis(int u, int f) {\n\tvis[u] = 1;\n\tfor (int p = T1.l[u]; p >= 0; p = T1.E[p].x) {\n\t\tint v = T1.E[p].v;\n\t\tif (v != f) {\n\t\t\t// 此时 Y 的深度为 T1.dep[u]\n\t\t\tif (T2.dep[v] > T1.dep[u]) {\n\t\t\t\tdfs_vis(v, u);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &X, &Y);\n\tfor (int i = 1; i < n; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tT1.addEdge(a, b);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tint c, d; \n\t\tscanf(\"%d%d\", &c, &d);\n\t\tT2.addEdge(c, d);\n\t}\n\tT1.init(X), T2.init(Y);\n\tfor (int u = 1; u <= n; u++) {\n\t\tfor (int p = T1.l[u]; p >= 0; p = T1.E[p].x) {\n\t\t\tint v = T1.E[p].v;\n\t\t\tif (T2.dis(u, v) > 2) {\n\t\t\t\ttag[u] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tdfs_vis(X, 0);\n\tint ans = 0;\n\tfor (int u = 1; u <= n; u++) {\n\t\tif (vis[u]) {\n\t\t\tif (tag[u]) ans = 0x3f3f3f3f;\n\t\t\telse ans = max(ans, T2.dep[u]);\n\t\t}\n\t}\n\tif (ans < 0x3f3f3f3f) printf(\"%d\\n\", ans << 1);\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef pair<ii, int> ri3;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n#define SZ(x) (int)(x).size()\n#define ALL(x) begin(x), end(x) \n#define REP(i, n) for (int i = 0; i < n; ++i) \n#define FOR(i, a, b) for (int i = a; i <= b; ++i)\n#define RFOR(i, a, b) for (int i = a; i >= b; --i)\n\nconst int MX_N = 2e5+5;\n\nint N,X,Y;\nvector<int> c1[MX_N], c2[MX_N];\n\nqueue<int> q;\nint d1[MX_N], d2[MX_N], p2[MX_N];\nbool inf[MX_N];\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> X >> Y;\n    FOR(i,1,N-1){\n        int a,b; cin>>a>>b;\n        c1[a].push_back(b);\n        c1[b].push_back(a);\n    }\n    FOR(i,1,N-1){\n        int a,b; cin>>a>>b;\n        c2[a].push_back(b);\n        c2[b].push_back(a);\n    }\n\n    memset(d2,-1,sizeof d2);\n    memset(p2,-1,sizeof p2);\n    d2[Y]=0; p2[Y]=0; q.push(Y);\n    while(!q.empty()){\n        int u=q.front(); q.pop();\n        for(int v:c2[u])if(d2[v]==-1)d2[v]=d2[u]+1,p2[v]=u,q.push(v);\n    }\n\n    FOR(i,1,N) for(int v:c1[i]){\n        int a=i,b=v; if(d2[a]<d2[b]) swap(a,b);\n        if(p2[a]==b||p2[p2[a]]==b||p2[a]==p2[b]) continue;\n        inf[i]=inf[v]=1;\n    }\n\n    int ans=d2[X]*2;\n    memset(d1,-1,sizeof d1);\n    d1[X]=0; q.push(X);\n    while(!q.empty()){\n        int u=q.front(); q.pop();\n        if(inf[u]){ans=-1; break;}\n        for(int v:c1[u])if(d1[v]==-1){d1[v]=d1[u]+1;ans=max(ans,d2[v]*2);if(d1[v]<d2[v])q.push(v);}\n    }\n    cout<<ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\nconst int N=5e5;\nint fa[N],dep2[N],dep1[N],n,ans;\nstruct TREE\n{\n    int fst[N],nxt[N],to[N],mm;\n    void ade(int u,int v){to[++mm]=v,nxt[mm]=fst[u],fst[u]=mm;}\n}e1,e2;\nvoid dfs2(int u,int Fa)\n{\n    fa[u]=Fa;\n    for(int i=e2.fst[u];i;i=e2.nxt[i])\n    {\n        int v=e2.to[i];if(v==Fa)continue;\n        dep2[v]=dep2[u]+1;dfs2(v,u);\n    }\n}\nint check(int u,int v)\n{\n    if(dep2[u]==dep2[v])return fa[u]!=fa[v];\n    if(dep2[u]>dep2[v])swap(u,v);\n    return fa[v]!=u&&fa[fa[v]]!=u;\n}\nvoid dfs1(int u,int Fa)\n{\n    ans=max(ans,dep2[u]);\n    for(int i=e1.fst[u];i;i=e1.nxt[i])\n    {\n        int v=e1.to[i];if(v==Fa)continue;\n        dep1[v]=dep1[u]+1;\n        if(check(u,v)){puts(\"-1\");exit(0);}\n        if(dep2[v]<=dep1[v])continue;\n        dfs1(v,u);\n    }\n}\nint main()\n{\n    int X,Y;\n    scanf(\"%d%d%d\",&n,&X,&Y);\n    for(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),e1.ade(u,v),e1.ade(v,u);\n    for(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),e2.ade(u,v),e2.ade(v,u);\n    dfs2(Y,0),dfs1(X,0);\n    cout<<ans*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,x,y;\nbool sp[SZ];\nnamespace T2\n{\nEdg\nint fa[SZ],dep[SZ];\nint sd(int a,int b)\n{\n\tif(a==b) return 0;\n\tif(a==fa[b]||b==fa[a]) return 1;\n\tif(fa[fa[a]]==b||a==fa[fa[b]]||fa[a]==fa[b])\n\t\treturn 2;\n\treturn 3;\n}\nvoid dfs(int x,int f=0,int d=0)\n{\n\tfa[x]=f; dep[x]=d;\n\tfor esb(x,e,b) if(b!=f) dfs(b,x,d+1);\n}\n}\nnamespace T1\n{\nEdg\nint mx;\nvoid dfs(int x,int f=0,int d=0)\n{\n\tif(d>T2::dep[x]) return;\n\tmx=max(mx,d); if(sp[x]) {mx=1e9; return;}\n\tfor esb(x,e,b) if(b!=f) dfs(b,x,d+1);\n}\n}\nint A[SZ],B[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;++i)\n\t\tscanf(\"%d%d\",A+i,B+i),T1::adde(A[i],B[i]);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tT2::adde(p,q);\n\t}\n\tT2::dfs(y);\n\tfor(int i=1;i<n;++i)\n\t\tif(T2::sd(A[i],B[i])==3)\n\t\t\tsp[A[i]]=sp[B[i]]=1;\n\tT1::dfs(x);\n\tif(T1::mx>1e8)\n\t\tputs(\"-1\");\n\telse printf(\"%d\\n\",T1::mx*2+2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2000005;\n\nint N,X,Y;\nvector<int> red[MAXN],blue[MAXN];\nint dep[MAXN],fa[MAXN];\n\nbool isTable(int u,int v)\n{\n\tif(dep[u]>dep[v])\n\t\tswap(u,v);\n\tif(fa[v]==u||fa[fa[v]]==u||fa[u]==fa[v])\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs1(int u)\n{\n\tfor(auto v:blue[u])\n\t\tif(v!=fa[u])\n\t\t{\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs1(v);\n\t\t}\n}\nint dfs2(int u,int f=0,int step=0)\n{\n\tstep++;\n\tint res=dep[u];\n\tfor(auto v:red[u])\n\t{\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tif(isTable(u,v))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tif(dep[v]>step)\n\t\t\tres=max(res,dfs2(v,u,step+1));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&X,&Y);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred[u].push_back(v);\n\t\tred[v].push_back(u);\n\t}\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue[u].push_back(v);\n\t\tblue[v].push_back(u);\n\t}\n\tdfs1(Y);\n\tint ans=dfs2(X)*2;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int NN = 2e5 + 5;\nstruct E {\n\tint v, nxt;\n\tE(int _v=0, int _nxt=0) : v(_v), nxt(_nxt) {}\n};\nstruct Graph {\n\tint head[NN], totE;\n\tE edge[NN*2];\n\tvoid AddEdge(int u, int v) {\n\t\tedge[++totE] = E(v, head[u]);\n\t\thead[u] = totE;\n\t}\n} a, b;\nint N, X, Y, da[NN], db[NN], fab[NN];\nbool save[NN];\nvoid Dfs1(int u, int fr) {\n\tfab[u] = fr;\n\tdb[u] = db[fr] + 1;\n\tfor (int p = b.head[u]; p; p = b.edge[p].nxt) {\n\t\tint v = b.edge[p].v; //注意两棵树别用串了 \n\t\tif (v != fr)\n\t\t\tDfs1(v, u);\n\t}\n}\nbool inf, edgetag[NN];\nvoid Dfs2(int u, int fr) {\n\tda[u] = da[fr] + 1;\n\tif (da[u] >= db[u]) return ;\n\tsave[u] = 1;\n\tif (fr != 0) {\n\t\tint x = u, y = fr;\n\t\tif (db[x] < db[y])\n\t\t\tswap(x, y);\n\t\tif (fab[x] == fab[y] || fab[x] == y || fab[fab[x]] == y) ;\n\t\telse {\n\t\t\tinf = 1;\n\t\t\tedgetag[u] = 1;\n\t\t}\n\t}\n\tfor (int p = a.head[u]; p; p = a.edge[p].nxt) {\n\t\tint v = a.edge[p].v;\n\t\tif (v != fr) {\n\t\t\tDfs2(v, u);\n\t\t\tif (edgetag[v])\n\t\t\t\tinf = 1;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ta.AddEdge(u, v);\n\t\ta.AddEdge(v, u);\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb.AddEdge(u, v);\n\t\tb.AddEdge(v, u);\n\t}\n\tDfs1(Y, 0);\n\tDfs2(X, 0);\n\tif (inf) printf(\"-1\\n\");\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tif (save[i])\n\t\t\t\tans = max(ans, db[i]-1);\n\t\tans *= 2;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0;char ch=' ';\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q;\n}\nconst int N=200005;\nint n,s1,s2,tim,ans;\nint win[N],dep[N],in[N],out[N],fa[N],vis[N],dis[N],que[N];\nstruct edge{int x,y;}e1[N];\nstruct tree{\n\tint h[N],ne[N<<1],to[N<<1],tot;\n\tvoid add(int x,int y) {to[++tot]=y,ne[tot]=h[x],h[x]=tot;}\n}T1,T2;\nvoid dfs(int x,int las) {\n\tdep[x]=dep[las]+1,in[x]=++tim,fa[x]=las;\n\tfor(RI i=T2.h[x];i;i=T2.ne[i])\n\t\tif(T2.to[i]!=las) dfs(T2.to[i],x);\n\tout[x]=tim;\n}\nint check(int x,int y) {\n\tif(in[x]>in[y]) swap(x,y);\n\tif(in[x]<=in[y]&&out[x]>=in[y]) return dep[y]-dep[x]>2;\n\tif(fa[x]==fa[y]) return 0;\n\treturn 1;\n}\nvoid bfs() {\n\tint he=1,ta=1;\n\tvis[s1]=1,dis[s1]=0,que[1]=s1;\n\twhile(he<=ta) {\n\t\tint x=que[he];++he;\n\t\tfor(RI i=T1.h[x];i;i=T1.ne[i])\n\t\t\tif(dis[x]+1<dep[T1.to[i]]&&!vis[T1.to[i]])\n\t\t\t\tvis[T1.to[i]]=1,que[++ta]=T1.to[i];\n\t}\n}\nint main()\n{\n\tint x,y;\n\tn=read(),s1=read(),s2=read();\n\tfor(RI i=1;i<n;++i) e1[i].x=read(),e1[i].y=read();\n\tfor(RI i=1;i<n;++i) x=read(),y=read(),T2.add(x,y),T2.add(y,x);\n\tdep[0]=-1,dfs(s2,0);\n\tfor(RI i=1;i<n;++i) {\n\t\tif(check(e1[i].x,e1[i].y)) win[e1[i].x]=win[e1[i].y]=1;\n\t\telse T1.add(e1[i].x,e1[i].y);\n\t}\n\tbfs();\n\tfor(RI i=1;i<=n;++i)\n\t\tif(win[i]&&vis[i]) {puts(\"-1\");return 0;}\n\t\telse if(vis[i]) ans=max(ans,dep[i]+dep[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200020\n#define ll long long\nusing namespace std;\ninline int read(){\n  int x=0,f=1;char ch=getchar();\n  while(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());\n  while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n  return f?x:-x;\n}\n\nstruct Tree {\n\n  int to[N<<1], nxt[N<<1], head[N], cnt;\n\n  Tree() {\n    cnt = 0;\n    memset(to, 0, sizeof to);\n    memset(nxt, 0, sizeof nxt);\n    memset(head, 0, sizeof head);\n  }\n\n  void insert(int x, int y) {\n    to[++ cnt] = y; nxt[cnt] = head[x]; head[x] = cnt;\n    to[++ cnt] = x; nxt[cnt] = head[y]; head[y] = cnt;\n  }\n\n} red, blue;\n\nint dep[N], fa[N];\n\nvoid dfs(int x, int f) {\n  fa[x] = f;\n  dep[x] = dep[f] + 1;\n  for (int i = blue.head[x]; i; i = blue.nxt[i]) {\n    if (blue.to[i] == f) continue;\n    dfs(blue.to[i], x);\n  }\n}\n\nint rx[N], ry[N];\nbool nige[N];\n\n// check if distance btw x and y <= 2\nbool check(int x, int y) {\n  if (dep[x] > dep[y]) {\n    swap(x, y);\n  }\n  if (dep[y] == dep[x]) {\n    return fa[y] == fa[x];\n  }\n  if (dep[y] - dep[x] == 1) {\n    return fa[y] == x;\n  }\n  if (dep[y] - dep[x] == 2) {\n    return fa[fa[y]] == x;\n  }\n  return false;\n}\n\nbool vis[N];\n\nvoid escape(int x, int f, int d) {\n\n  if (dep[x] <= d) return;\n  vis[x] = 1;\n  for (int i = red.head[x]; i; i = red.nxt[i]) {\n    if (red.to[i] == f) continue;\n    escape(red.to[i], x, d + 1);\n  }\n}\n\nint main(int argc, char const *argv[]) {\n  // freopen(\"../../temp/.in\", \"r\", stdin);\n\n  int n = read(), x = read(), y = read();\n  \n  for (int i = 1; i < n; ++ i) {\n    rx[i] = read();\n    ry[i] = read();\n    red.insert(rx[i], ry[i]);\n  }\n  \n  for (int i = 1; i < n; ++ i) {\n    blue.insert(read(), read());\n  }\n\n  dfs(y, 0);\n  \n  for (int i = 1; i < n; ++ i) {\n    if (!check(rx[i], ry[i])) {\n      nige[rx[i]] = nige[ry[i]] = true;\n    }\n  }\n\n  escape(x, 0, 1);\n\n  int ans = 0;\n\n  for (int i = 1; i <= n; ++ i) {\n    if (vis[i] && nige[i]) {\n      return puts(\"-1\"), 0;\n    }\n    if (vis[i]) {\n      ans = max(ans, dep[i] - 1);\n    }\n  }\n\n  printf(\"%d\\n\", ans << 1);\n\n  return 0;\n}\n/*\n\n当 A 到达一条红树上的边 (x, y) 的端点时（这条边满足 x 和 y 在蓝树的距离大于 2），B 还没抓到 A，显然就 -1 了。\n\n除了这种情况 A 都会被抓到。\n\n以 B 的初始点为根，发现 A 每次就是往子树逃，或往兄弟逃，或往父亲逃。\n只要 B 步步下潜，就能抓到 A。\n\n删除红树上满足 A 一旦到达就会 -1 的那些边，然后做 bfs 求出 A 能能跑到的点（即到达该点前不会被 B 抓），\nA 一定会选择在蓝树中深度最大的，然后待在那弃疗。\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tg[v].erase(remove(all(g[v]),p),g[v].ed);\n\t\tfor(auto&e:g[v]){\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,x,y;cin>>n>>x>>y;\n\tx--;y--;\n\tvvc<int> g(n);\n\trep(_,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tvvc<int> t(n);\n\trep(_,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt[a].pb(b);\n\t\tt[b].pb(a);\n\t}\n\t\n\tauto h=HLD<int>(t,y);\n\t\n\tvi dist(n,-1);\n\tqueue<int> q;\n\tauto rc=[&](int v,int d){\n\t\tif(dist[v]!=-1)return;\n\t\tif(d>=h.dep[v])return;\n\t\tdist[v]=d;\n\t\tq.push(v);\n\t};\n\t\n\trc(x,0);\n\twhile(q.size()){\n\t\tint v=q.front();q.pop();\n\t\tfor(auto to:g[v])\n\t\t\trc(to,dist[v]+1);\n\t}\n\t\n\tint mx=0;\n\trep(i,n)if(dist[i]!=-1){\n\t\tfor(auto j:g[i])\n\t\t\tif(h.len(i,j)>=3){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tchmax(mx,h.dep[i]);\n\t}\n\t\n\tcout<<mx*2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 200200;\n\nint N, X, Y;\nvector<int> adjr[MX];\nvector<int> adjb[MX];\nint distr[MX];\nint distb[MX];\nint anc[18][MX];\n\nvoid dfs(int v, int p) {\n   for (int z = 1; z < 18; ++z) anc[z][v] = anc[z-1][anc[z-1][v]];\n   for (int u : adjb[v]) if (u != p) {\n      distb[u] = distb[v]+1;\n      anc[0][u] = v;\n      dfs(u, v);\n   }\n}\n\nint lca(int v, int u) {\n   if (distb[v] > distb[u]) swap(v, u);\n   for (int z = 17; z >= 0; --z) if (distb[anc[z][u]] >= distb[v]) u = anc[z][u];\n   if (v == u) return v;\n   for (int z = 17; z >= 0; --z) if (anc[z][v] != anc[z][u]) {\n      v = anc[z][v];\n      u = anc[z][u];\n   }\n   return anc[0][v];\n}\n\nint get_dist(int v, int u) {\n   return distb[v] + distb[u] - 2 * distb[lca(v, u)];\n}\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   cin >> N >> X >> Y;\n   for (int i = 0; i < N-1;++i) {\n      int v, u; cin >> v >> u;\n      adjr[v].emplace_back(u);\n      adjr[u].emplace_back(v);\n   }\n   for (int i = 0; i < N-1; ++i) {\n      int v, u; cin >> v >> u;\n      adjb[v].emplace_back(u);\n      adjb[u].emplace_back(v);\n   }\n   anc[0][Y] = Y;\n   dfs(Y, 0);\n   queue<int> bfs;\n   for (int i = 1; i <= N; ++i) distr[i] = -1;\n   distr[X] = 0;\n   bfs.emplace(X);\n   int ans = 0;\n   while (!bfs.empty()) {\n      int v = bfs.front(); bfs.pop();\n      ans = max(ans, 2 * distb[v]);\n      for (int u : adjr[v]) if (distr[u] == -1) {\n         if (get_dist(v, u) >= 3) {\n            cout << \"-1\\n\";\n            return 0;\n         }\n         if (distr[v] + 1 > distb[u]) continue;\n         if (distr[v] + 1 == distb[u]) {\n            ans = max(ans, 2 * distb[u]);\n         } else {\n            distr[u] = distr[v]+1;\n            bfs.emplace(u);\n         }\n      }\n   }\n   cout << ans << '\\n';\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxn = 2e6 + 5;\nvector<int> blue[maxn], red[maxn];\nint dep[maxn], fa[maxn], dp[maxn];\nbool safe[maxn];\nvoid dfs(int v, int p) {\n    fa[v] = p;\n    for (int i=0; i<blue[v].size(); i++) if(blue[v][i] != p) {\n        dep[blue[v][i]] = dep[v] + 1;\n        dfs(blue[v][i], v);\n    }\n}\nbool atMost2(int x, int y) {\n    return (fa[x] == fa[y]) || (fa[x] == y) || (x == fa[y]) || (fa[fa[x]] == y) || (x == fa[fa[y]]);\n}\nint main() {\n    int n, X, Y, x, y;\n    scanf(\"%d %d %d\", &n, &X, &Y);\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        red[x].push_back(y), red[y].push_back(x);\n    }\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        blue[x].push_back(y), blue[y].push_back(x);\n    }\n    dfs(Y, -1);\n    for (int i=1; i<=n; i++)\n        for (int j=0; j<red[i].size(); j++)\n            if (!atMost2(i, red[i][j]))\n                safe[i] = safe[red[i][j]] = 1;\n    if (safe[X]) {puts(\"-1\"); return 0;}\n    memset(dp, -1, sizeof(dp));\n    queue<int> q;\n    q.push(X); dp[X] = 0;\n    int ans = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (dp[u] >= dep[u]) continue;\n        if (safe[u]) {puts(\"-1\"); return 0;}\n        ans = max(ans, dep[u] * 2);\n        for (int i=0; i<red[u].size(); i++) {\n            int v = red[u][i];\n            if (dp[u] + 1 < dep[v]) {\n                dp[v] = dp[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 21\nvector<int> ex[N], ey[N];\nint fx[N], fy[N][M], dx[N], dy[N];\nvoid dfsx(int u) {\n    for (auto v : ex[u]) {\n        if (v == fx[u]) continue;\n        fx[v] = u, dx[v] = dx[u] + 1;\n        dfsx(v);\n    }\n}\nvoid dfsy(int u) {\n    for (auto v : ey[u]) {\n        if (v == fy[u][0]) continue;\n        fy[v][0] = u, dy[v] = dy[u] + 1;\n        for (int i = 1; i < M; i++) fy[v][i] = fy[fy[v][i - 1]][i - 1];\n        dfsy(v);\n    }\n}\nint lca(int u) {\n    int v = fx[u];\n    if (dy[u] < dy[v]) swap(u, v);\n    for (int i = M - 1; ~i; i--)\n        if (dy[fy[u][i]] >= dy[v]) u = fy[u][i];\n    if (u == v) return u;\n    for (int i = M - 1; ~i; i--)\n        if (fy[u][i] != fy[v][i]) u = fy[u][i], v = fy[v][i];\n    return fy[u][0];\n}\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        ex[u].push_back(v);\n        ex[v].push_back(u);\n    }\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        ey[u].push_back(v);\n        ey[v].push_back(u);\n    }\n    dfsx(addx);\n    dfsy(addy);\n    queue<int> que;\n    que.push(addx);\n    int ans = 0;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        if (dx[u] >= dy[u]) continue;\n        if (dy[u] + dy[fx[u]] - 2 * dy[lca(u)] > 2) {\n            puts(\"-1\");\n            return 0;\n        }\n        ans = max(ans, dy[u] << 1);\n        for (auto v : ex[u])\n            if (v != fx[u]) que.push(v);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(a) ((int)a.size())\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\n#define DB(a,s,e) {for(int _i=s;_i<e;++_i) cerr << a[_i] << \" \";cerr << \"\\n\";}\ntemplate<typename T>void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&x,S &&...t){cerr<<x<<\", \";_do(t...);}\ntemplate<typename a,typename b> ostream& operator << (ostream &s,const pair<a,b> &p){return s<<\"(\"<<p.X<<\",\"<<p.Y<<\")\";}\n#else\n#define debug(...)\n#define DB(a,s,e)\n#endif\n\nvector<int> G[200005],G2[200005];\nint dis[200005],in[200005],fa[200005],out[200005],dft,ans,flag;\n\nvoid dfs2(int u,int d,int f)\n{\n\tfa[u]=f,dis[u]=d,in[u]=++dft;\n\tfor(int i:G2[u])\n\t\tif(i!=f)\n\t\t\tdfs2(i,d+1,u);\n\tout[u]=dft;\t\n}\n\nbool ancestor(int u,int v)\n{\n\treturn in[u]<=in[v]&&out[u]>=out[v];\n}\n\nvoid dfs(int u,int d,int f)\n{\n\tfor(int i:G[u])\n\t{\n\t\tif(i!=f&&dis[i]>d+1)\n\t\t\tdfs(i,d+1,u);\n\t\tif(!ancestor(fa[u],i)&&i!=fa[fa[u]])\n\t\t\tflag=1;\n\t}\n\tans=max(ans,dis[u]*2);\n}\n\nint main()\n{\n    IOS();\n    int n,x,y,a,b;\n    cin >> n >> x >> y;\n    for(int i=1;i<n;++i)\t\n    \tcin >> a >> b,G[a].pb(b),G[b].pb(a);\n    for(int i=1;i<n;++i)\n    \tcin >> a >> b,G2[a].pb(b),G2[b].pb(a);\n    dfs2(y,0,y),dfs(x,0,x);\n    if(flag)\n    \tcout << \"-1\\n\";\n    else\n    \tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 200005;\nstruct Edge{\n\tint to,next;\n}e[MAXN<<1];\nbool safe[MAXN];\nint dep[MAXN],n,x,y,cnt,head[MAXN];\ninline void insert(int u,int v)\n{\n\te[++cnt].to=v,e[cnt].next=head[u],head[u]=cnt;\n\te[++cnt].to=u,e[cnt].next=head[v],head[v]=cnt;\n}\nint u[MAXN],v[MAXN],pos[MAXN],out[MAXN],sz,fa[MAXN];\nvoid dfs(int x)\n{\n\tpos[x]=++sz;\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[x])continue;\n\t\tdep[v]=dep[x]+1;\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t}\n\tout[x]=sz;\n}\ninline bool judge(int x,int y)\n{\n\tif(pos[x]>pos[y])swap(x,y);\n\tif(pos[y]>=pos[x] && pos[y]<=out[x])return dep[y]-dep[x]>2;\n\treturn fa[x]!=fa[y];\n}\nnamespace Sigma{\n\tstruct Edge{\n\t\tint to,next;\n\t}e[MAXN<<1];\n\tint head[MAXN],cnt,ans;\n\tbool reach[MAXN];\n\tinline void insert(int u,int v)\n\t{\n\t\te[++cnt].to=v,e[cnt].next=head[u],head[u]=cnt;\n\t\te[++cnt].to=u,e[cnt].next=head[v],head[v]=cnt;\n\t}\n\tvoid getans(int x,int fa,int step)\n\t{\n\t\treach[x]=1;\n\t\tfor(int i=head[x];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa)continue;\n\t\t\tif(step+1>=dep[v])continue;\n\t\t\tgetans(v,x,step+1);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",u+i,v+i);\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tinsert(u,v);\n\t}\n\tdfs(y);\n\tfor(int i=1;i<n;++i){\n\t\tif(judge(u[i],v[i]))safe[u[i]]=safe[v[i]]=1;\n\t\telse Sigma::insert(u[i],v[i]);\n\t}\n\tSigma::getans(x,0,0);\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(Sigma::reach[i]&&safe[i]){puts(\"-1\");return 0;}\n\t\telse if(Sigma::reach[i])ans=max(ans,dep[i]);\n\tcout<<ans*2<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint n, stx, sty;\nstruct Edge {\n\tint to, next;\n} edge[(N << 1) + 1];\nint start[N + 1], tot;\nint depa[N + 1], depb[N + 1], up[21][N + 1];\nint xx[N + 1], yy[N + 1];\nint ans;\n\ninline void addedge(int u, int v)\n{\n\tedge[++tot] = Edge{ v, start[u] };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v] };\n\tstart[v] = tot;\n\treturn;\n}\ninline void dfs1(int u, int fa)\n{\n\tdepa[u] = depa[fa] + 1;\n\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (v != fa && depb[v] > depa[u] + 1)\n\t\t\tdfs1(v, u);\n\t}\n\treturn;\n}\ninline void dfs2(int u, int fa)\n{\n\tdepb[u] = depb[fa] + 1;\n\tfor (int i = 1; i <= 20; i++)\n\t\tup[i][u] = up[i - 1][up[i - 1][u]];\n\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (v != fa) {\n\t\t\tup[0][v] = u;\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\ninline int lca(int x, int y)\n{\n\tif (depb[x] > depb[y])\n\t\tswap(x, y);\n\tfor (int i = 20; i >= 0; i--) {\n\t\tif (up[i][y] && depb[up[i][y]] >= depb[x])\n\t\t\ty = up[i][y];\n\t\tif (x == y)\n\t\t\treturn x;\n\t}\n\tfor (int i = 20; i >= 0; i--) {\n\t\tif (up[i][x] && up[i][x] != up[i][y]) {\n\t\t\tx = up[i][x];\n\t\t\ty = up[i][y];\n\t\t}\n\t}\n\treturn up[0][x];\n}\ninline int dis(int x, int y)\n{\n\tint llca = lca(x, y);\n\n\treturn depb[x] + depb[y] - (depb[llca] << 1);\n}\nint main()\n{\n\tn = read();\n\tstx = read();\n\tsty = read();\n\tfor (int i = 1; i < n; i++) {\n\t\txx[i] = read();\n\t\tyy[i] = read();\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint a = read(), b = read();\n\t\taddedge(a, b);\n\t}\n\tdfs2(sty, 0);\n\ttot = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tstart[i] = 0;\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(xx[i], yy[i]);\n\tdfs1(stx, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tif (dis(xx[i], yy[i]) > 2 && ((depa[xx[i]] < depb[xx[i]] && depa[xx[i]]) || (depa[yy[i]] < depb[yy[i]] && depa[yy[i]]))) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (depa[i] < depb[i] && depa[i])\n\t\t\tans = max(ans, depb[i] - 1);\n\tprintf(\"%d\\n\", ans << 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n#define N 200050\nint n,m,X,Y,dfn[N],enp[N],dis[N],is[N],dep[N],ans,fa[N];\nstruct Tree {\n\tint head[N],to[N<<1],nxt[N<<1],cnt;\n\tinline void add(int u,int v) {\n\t\tto[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;\n\t}\n\tvoid dfs(int x,int y) {\n\t\tdfn[x]=++dfn[0];int i; fa[x]=y;\n\t\tfor(i=head[x];i;i=nxt[i]) if(to[i]!=y) {\n\t\t\tdis[to[i]]=dis[x]+1;\n\t\t\tdfs(to[i],x);\n\t\t}enp[x]=dfn[0];\n\t}\n\tbool jdg(int x,int y) {\n\t\tif(dfn[x]>dfn[y]) swap(x,y);\n\t\tif(dfn[y]>=dfn[x]&&dfn[y]<=enp[x]) return dis[y]-dis[x]>2;\n\t\treturn fa[x]!=fa[y];\n\t}\n\tvoid dfs2(int x,int y) {\n\t\tint i;\n\t\tif(dep[x]>=dis[x]) return ;\n\t\tis[x]=1;ans=max(ans,dis[x]<<1);\n\t\tfor(i=head[x];i;i=nxt[i]) if(to[i]!=y) {\n\t\t\tdep[to[i]]=dep[x]+1;\n\t\t\tdfs2(to[i],x);\n\t\t\tif(jdg(x,to[i])) {puts(\"-1\");exit(0);}\n\t\t}\n\t}\n}t1,t2;\nint main() {\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tif(X==Y) {puts(\"0\"); return 0;}\n\tint i,x,y;\n\tfor(i=1;i<n;i++) scanf(\"%d%d\",&x,&y),t1.add(x,y),t1.add(y,x);\n\tfor(i=1;i<n;i++) scanf(\"%d%d\",&x,&y),t2.add(x,y),t2.add(y,x);\n\tt2.dfs(Y,0);\n\tt1.dfs2(X,0);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> ea[200001],eb[200001];\nconst int MAXN = 200000,MAXLOG = 18;\nint p[MAXLOG+1][MAXN+1],dep[MAXN+1];\nvector<int> e[MAXN+1];\nvoid dfs(int x,int fa){\n\tp[0][x]=fa;\n\tfor(int i=0;i+1<=MAXLOG;i++)\n\t\tp[i+1][x]=p[i][p[i][x]];\n\tfor(int it:eb[x])\n\t\tif(it!=fa){\n\t\t\tdep[it]=dep[x]+1;\n\t\t\tdfs(it,x);\n\t\t}\n}\nint LCA(int a,int b){\n   if(dep[a]>dep[b])   swap(a,b);\n   int k=0;\n   for(int i=dep[b]-dep[a];i;i/=2){\n      if(i%2)  b=p[k][b];\n      k++;\n   }\n   if(a==b) return a;\n   for(int i=MAXLOG;i>=0;i--)\n      if(p[i][a]!=p[i][b]){\n         a=p[i][a];\n         b=p[i][b];\n      }\n      return p[0][a];\n}\n\nint dist(int x,int y){\n\tint l=LCA(x,y);\n\treturn dep[x]+dep[y]-2*dep[l];\n}\n\nint d[MAXN+1];\nbool ok[MAXN+1];\nint ans=0;\nvoid dfs2(int x,int fa){\n\tif(d[x]>=dep[x])\treturn;\n\tif(ok[x]){\n\t\tcout<<-1<<endl;\n\t\texit(0);\n\t}\n\tans=max(ans,dep[x]);\n\tfor(int it:ea[x])\n\t\tif(it!=fa){\n\t\t\td[it]=d[x]+1;\n\t\t\tdfs2(it,x);\n\t\t}\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,x,y;\n\tcin>>n>>x>>y;\n\tfor(int i=1,u,v;i<n;i++){\n\t\tcin>>u>>v;\n\t\tea[u].emplace_back(v);\n\t\tea[v].emplace_back(u);\n\t}\n\tfor(int i=1,u,v;i<n;i++){\n\t\tcin>>u>>v;\n\t\teb[u].emplace_back(v);\n\t\teb[v].emplace_back(u);\n\t}\n\tdfs(y,0);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int it:ea[i])\n\t\t\tif(dist(i,it)>2)\n\t\t\t\tok[i]=ok[it]=true;\n\tdfs2(x,0);\n\tcout<<ans*2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 200000 + 5;\n\nint N;\nvector <int> tomTree[NMAX];\nvector <int> jerryTree[NMAX];\n\nint tomCnt;\nint tomH[NMAX];\nint tomFathers[19][NMAX];\nint tomFirst[NMAX];\nint tomLast[NMAX];\n\nvoid dfsPrepareTomTree(int node) {\n    tomFirst[node] = ++tomCnt;\n    if (tomFathers[0][node])\n        tomTree[node].erase(find(tomTree[node].begin(), tomTree[node].end(), tomFathers[0][node]));\n    \n    for (int i = 1; i < 19; ++ i)\n        tomFathers[i][node] = tomFathers[i - 1][tomFathers[i - 1][node]];\n    \n    for (auto it: tomTree[node]) {\n        tomH[it] = 1 + tomH[node];\n        tomFathers[0][it] = node;\n        dfsPrepareTomTree(it);  \n    }\n    tomLast[node] = tomCnt;\n}\n\nint moveCloser(int t, int j) {\n    if (t == j) // No need to move\n        return t;\n    else if (tomFirst[t] <= tomFirst[j] && tomFirst[j] <= tomLast[t]) { // Move in a son\n        int st = 1, dr = tomTree[t].size() - 1;\n        int ans = 0;\n        while (st <= dr) {\n            int mid = (st + dr) >> 1;\n            if (tomFirst[tomTree[t][mid]] <= tomFirst[j])\n                ans = mid, st = mid + 1;\n            else\n                dr = mid - 1;\n        }\n        return tomTree[t][ans];\n    }\n    else // Move in the father\n        return tomFathers[0][t];\n}\n\ninline int lca(int a, int b) {\n    if (tomH[a] > tomH[b])\n        swap(a, b);\n    for (int i = 18; i >= 0; -- i)\n        if ((1 << i) <= tomH[b] - tomH[a])\n            b = tomFathers[i][b];\n    if (a == b)\n        return a; \n    for (int i = 18; i >= 0; -- i)\n        if (tomFathers[i][a] != tomFathers[i][b])\n            a = tomFathers[i][a], b = tomFathers[i][b];\n    return tomFathers[0][a];\n}\n\ninline int getDist(int a, int b) {\n    return tomH[a] + tomH[b] - 2 * tomH[lca(a, b)];\n}\n\nconst int INF = 2E9 + 256;\nbool easyWinJerry[NMAX];\n\nbool jerryVis[NMAX];\nint play(int t, int j) { // Jerry moves\n    if (t == j)\n        return 0;\n    if (easyWinJerry[j])\n        return INF;\n    jerryVis[j] = true;\n\n    int longest = 2 * getDist(t, j);\n    for (auto it: jerryTree[j])\n        if (!jerryVis[it])\n            longest = max(longest, 2 + play(moveCloser(t, it), it));\n    jerryVis[j] = false;\n    return longest;\n}\n\nint main() {\n    //freopen(\"data.in\", \"r\", stdin);\n    ios_base :: sync_with_stdio(false);\n\n    int t, j;\n    cin >> N >> j >> t;\n    for (int i = 1; i < N; ++ i) {\n        int a, b;\n        cin >> a >> b;\n        jerryTree[a].push_back(b);\n        jerryTree[b].push_back(a);\n    }\n    for (int i = 1; i < N; ++ i) {\n        int a, b;\n        cin >> a >> b;\n        tomTree[a].push_back(b);\n        tomTree[b].push_back(a);\n    }\n    dfsPrepareTomTree(t);\n\n    for (int i = 1; i <= N; ++ i)\n        for (auto it: jerryTree[i]) {\n            int d = getDist(i, it);\n            if (d >= 3)\n                easyWinJerry[i] = easyWinJerry[it] = true;\n        }\n\n    int ans = play(t, j);\n    if (ans >= INF)\n        cout << \"-1\\n\";\n    else\n        cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define PB push_back\n#define SZ(c) int((c).size())\n#define ALL(c) (c).begin(), (c).end()\n#define CONTAINS(c, x) ((c).find(x) != (c).end())\n#define REP(i, n) for(int i=1; i<=n; i++)\n#define WAIT cout<<flush, system(\"PAUSE\");\nusing namespace std;\nconst int MAX = 100100;\n\nint N, A, B, u, v;\nset<int> E[MAX], F[MAX];\nint D[MAX], P[MAX], sol;\nbool ok[MAX], used[MAX], escape;\n\nvoid DFS(int n){\n\tfor(auto x: F[n]) if (x!=P[n]){\n\t\tP[x] = n;\n\t\tD[x] = D[n] + 1;\n\t\tDFS(x);\n\t}\n}\n\nvoid DFS2(int n, int d){\n\tif (D[n] <= d) return;\n\tused[n] = true;\n\tsol = max(sol, D[n]);\n\tif (ok[n]) escape = true;\n\t\n\tfor(auto x: E[n]) if (!used[x]){\n\t\tDFS2(x, d+1);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> N >> A >> B;\n\tREP(I, N-1){\n\t\tcin >> u >> v;\n\t\tE[u].insert(v);\n\t\tE[v].insert(u);\n\t}\n\t\n\tREP(I, N-1){\n\t\tcin >> u >> v;\n\t\tF[u].insert(v);\n\t\tF[v].insert(u);\n\t}\n\t\n\tP[B] = D[B] = 0;\n\tDFS(B);\n\t\n\tREP(u, N) for(auto v: E[u])\n\tif (CONTAINS(F[u], v) || CONTAINS(F[v], u) || CONTAINS(F[ P[u] ], v) || CONTAINS(F[ P[v] ], u))\n\t\t;\n\telse ok[u] = ok[v] = true;\n\t\n\t//REP(I, N) if (ok[I]) cout << I << \" \";\n\t//cout << endl;\n\t//REP(I, N) cout << D[I] << \" \";\n\t//cout << endl;\n\t\n\tDFS2(A, 0);\n\tif (escape) sol = -1;\n\telse        sol *= 2;\n\tcout << sol << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N=200005;\nstruct qq\n{\n\tint x,y,last;\n}e[N*2];int num,last[N];\nint X[N],Y[N];\nvoid init (int x,int y)\n{\n\tnum++;\n\te[num].x=x;e[num].y=y;\n\te[num].last=last[x];\n\tlast[x]=num;\n}\nint n,xx,yy;\nint L[N],R[N],dep[N],fa[N];\nvoid dfs (int x)\n{\n\tL[x]=++num;\n\tfor (int u=last[x];u!=-1;u=e[u].last)\n\t{\n\t\tint y=e[u].y;\n\t\tif (y==fa[x]) continue;\n\t\tfa[y]=x;dep[y]=dep[x]+1;\n\t\tdfs(y);\n\t}\n\tR[x]=num;\n}\nbool ok[N];\nvector<int> vec[N];\nbool vis[N];\nint d[N];\nvoid bfs ()\n{\n\tmemset(d,127,sizeof(d));\n\tmemset(vis,false,sizeof(vis));\n\tvis[xx]=true;d[xx]=0;\n\tqueue<int> q;q.push(xx);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t//\tprintf(\"%d\\n\",x);\n\t\tint siz=vec[x].size();\n\t\tfor (int i=0;i<siz;i++)\n\t\t{\n\t\t\tint y=vec[x][i];\n\t\t\tif (vis[y]) continue;\n\t\t\tif (d[y]>d[x]+1)\n\t\t\t{\n\t\t\t\td[y]=d[x]+1;\n\t\t\t\tif (d[y]<dep[y]) \n\t\t\t\t{\n\t\t\t\t\tvis[y]=true;\n\t\t\t\t\tq.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool check (int x,int y)//这两个点是否可以由同一个点到达 \n{\n\tif (dep[x]>dep[y]) swap(x,y);\n\tif (L[x]<=L[y]&&L[y]<=R[x])//在他子树里面\n\t\treturn dep[y]-dep[x]>2;\n\tif (fa[x]==fa[y]) return false;\n\treturn true;\n}\nint main()\n{\n\tnum=0;memset(last,-1,sizeof(last));\n\tscanf(\"%d%d%d\",&n,&xx,&yy);\n\tfor (int u=1;u<n;u++) scanf(\"%d%d\",&X[u],&Y[u]);\n\tfor (int u=1;u<n;u++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tinit(x,y);init(y,x);\n\t}\n\tnum=0;dfs(yy);\n\t/*for (int u=1;u<=n;u++) printf(\"%d \",dep[u]);\n\tprintf(\"\\n\");*/\n\tmemset(ok,false,sizeof(ok));\n\tfor (int u=1;u<n;u++)\n\t{\n\t\tif (check(X[u],Y[u]))\t{ok[X[u]]=true;ok[Y[u]]=true;}\n\t\telse vec[X[u]].push_back(Y[u]),vec[Y[u]].push_back(X[u]);\n\t}\n\tbfs();\n\tint ans=0;\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tif (ok[u]&&vis[u])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (vis[u])\tans=max(ans,dep[u]*2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int N = 200200;\nconst int LOG = 18;\nint n;\nvector<int> g[N], g2[N];\nint X, Y;\nint h[N];\nint dist[N];\nint par[N][LOG];\nint q[N];\nint topQ;\n\nvoid read()\n{\n\tscanf(\"%d%d%d\", &n, &X, &Y);\n\tX--;Y--;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg2[v].push_back(u);\n\t\tg2[u].push_back(v);\n\t}\n\treturn;\n}\n\nvoid dfs(int v)\n{\n\tfor (int u : g2[v])\n\t{\n\t\tif (h[u] != -1) continue;\n\t\th[u] = h[v] + 1;\n\t\tpar[u][0] = v;\n\t\tfor (int k = 1; k < LOG; k++)\n\t\t{\n\t\t\tint w = par[u][k - 1];\n\t\t\tif (w == -1)\n\t\t\t{\n\t\t\t\tpar[u][k] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpar[u][k] = par[w][k - 1];\n\t\t}\n\t\tdfs(u);\n\t}\n\treturn;\n}\n\nint up(int v, int dh)\n{\n\tfor (int k = LOG - 1; k >= 0; k--)\n\t{\n\t\tif (dh >= (1 << k))\n\t\t{\n\t\t\tdh -= 1 << k;\n\t\t\tv = par[v][k];\n\t\t}\n\t}\n\treturn v;\n}\nint LCA(int v, int u)\n{\n\tif (h[v] > h[u]) swap(v, u);\n\tu = up(u, h[u] - h[v]);\n\tif (v == u) return v;\n\tfor (int k = LOG - 1; k >= 0; k--)\n\t{\n\t\tif (par[v][k] != par[u][k])\n\t\t{\n\t\t\tv = par[v][k];\n\t\t\tu = par[u][k];\n\t\t}\n\t}\n\treturn par[v][0];\n}\n\nvoid precalc()\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\th[i] = -1;\n\t\tfor (int j = 0; j < LOG; j++)\n\t\t\tpar[i][j] = -1;\n\t}\n\th[Y] = 0;\n\tdfs(Y);\n\treturn;\n}\n\nvoid solve()\n{\n\tfor (int i = 0; i < n; i++)\n\t\tdist[i] = N;\n\ttopQ = 1;\n\tq[0] = X;\n\tdist[X] = 0;\n\tint ans = 0;\n\tfor (int k = 0; k < topQ; k++)\n\t{\n\t\tint v = q[k];\n\t\tans = max(ans, 2 * h[v]);\n\t\tfor (int u : g[v])\n\t\t{\n\t\t\tint w = LCA(v, u);\n\t\t\tif (h[v] + h[u] - 2 * h[w] >= 3)\n\t\t\t{\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (dist[u] <= dist[v] + 1) continue;\n\t\t\tif (h[u] < dist[v] + 1) continue;\n\t\t\tif (h[u] == dist[v] + 1)\n\t\t\t{\n\t\t\t\tans = max(ans, 2 * h[u]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdist[u] = dist[v] + 1;\n\t\t\tq[topQ++] = u;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tread();\n\tprecalc();\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int INF=1e9;\nstruct node{\n\tint s,t;\n}w1[200100],w2[200100];\nint beg[200100],nex[400100],tto[400100],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint n;\nvoid clear(){\n\te=1;\n\tfor(int i=0;i<=n;i++)\n\t\tbeg[i]=0;\n}\nbool vis[200100];\nint f[200100];\nint dis[200100];\nvoid getfa(int u){\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==f[u]) continue;\n\t\tf[tto[i]]=u;\n\t\tdis[tto[i]]=dis[u]+1;\n\t\tgetfa(tto[i]);\n\t}\n}\nint ans;\nvoid dfs(int u,int fa,int dep){\n\tif(dis[u]>ans) ans=dis[u];\n\tif(dep>=dis[u]) return;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tif(vis[i>>1]){\n\t\t\tans=INF;\n\t\t\treturn;\n\t\t}\n\t\tdfs(tto[i],u,dep+1);\n\t}\n}\nint main(){\n//\tfreopen(\"b.in\",\"r\",stdin);\n//\tfreopen(\"b.out\",\"w\",stdout);\n\tint A,B;\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif(A==B){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tclear();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&w2[i].s,&w2[i].t);\n\t\tputin(w2[i].s,w2[i].t);\n\t\tputin(w2[i].t,w2[i].s);\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tscanf(\"%d%d\",&w1[i].s,&w1[i].t);\n\tgetfa(B);\n\tclear();\n\tfor(int i=1;i<n;i++){\n\t\tif(f[w1[i].s]!=f[w1[i].t]&&f[f[w1[i].s]]!=w1[i].t&&\n\t\t\t\tw1[i].s!=f[f[w1[i].t]]&&f[w1[i].s]!=w1[i].t&&f[w1[i].t]!=w1[i].s)\n\t\t\tvis[i]=1;\n\t\telse\n\t\t\tvis[i]=0;\n\t\tputin(w1[i].s,w1[i].t);\n\t\tputin(w1[i].t,w1[i].s);\n\t}\n\tdfs(A,-1,0);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nP dp[200005];\nint lca[200005][18],dist2[200005];\nint calc(int x,int y){\n\tif(dist2[x] > dist2[y]) swap(x,y);\n\trep(i,18){\n\t\tif((((dist2[y]-dist2[x])>>i)&1)){\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\tfor(int i=17;i>=0;i--){\n\t\tif(lca[x][i] != lca[y][i]){\n\t\t\tx = lca[x][i];\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\treturn (x==y?x:lca[x][0]);\n}\nbool fe;\nint go(int a,int b){\n\tint c = calc(a,b);\n\tif(a == c){\n\t\tfor(int i=0;i<18;i++){\n\t\t\tif((((dist2[b]-dist2[a]-1)>>i)&1)){\n\t\t\t\tb = lca[b][i];\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\telse{\n\t\treturn lca[a][0];\n\t}\n}\nint ret = 0;\nvoid dfs(int v,int u,int d){\n\tif(dp[v].fi >= 0){\n\t\tret = max(ret,2*d+dp[v].fi*2);\n\t}\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint D = dist2[v]+dist2[edge[v][i]]-2*dist2[calc(v,edge[v][i])];\n\t\t//cout << v << \" \" << edge[v][i] << \" \" << \" \" << calc(v,edge[v][i]) << D << endl;\n\t\tif(D>=3 && lca[edge[v][i]][0] != dp[v].sc && lca[dp[v].sc][0] != edge[v][i] && edge[v][i] != dp[v].sc){\n\t\t\tcout << v << edge[v][i] << dp[v].sc << endl; fe = 1;\n\t\t}\n\t\telse {\n\t\t\tD = dist2[edge[v][i]]+dist2[dp[v].sc]-2*dist2[calc(edge[v][i],dp[v].sc)];\n\t\t\tif(D<=1){\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(0,edge[v][i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(D-1,go(dp[v].sc,edge[v][i])));\n\t\t\t\tdfs(edge[v][i],v,d+1);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d; lca[v][0] = u;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs2(b,-1,0);\n\tdp[a] = mp(dist2[a],b);\n\tfor(int j=0;j<17;j++) for(int i=1;i<=n;i++){\n\t\tif(lca[i][j] == -1) lca[i][j+1] = -1;\n\t\telse lca[i][j+1] = lca[lca[i][j]][j];\n\t}\n\tdfs(a,-1,0);\n\tif(fe) puts(\"-1\");\n\telse cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N, X, Y;\nvector<int> adj1[MN], adj2[MN];\nint par[20][MN], dep[MN], tin[MN], tout[MN], timer;\n\nvoid dfs0(int u, int p) {\n    tin[u] = timer++;\n\n    par[0][u] = p;\n    for(int i = 1; i < 20; i++) {\n        int t = par[i - 1][u];\n        if(t == -1) break;\n        par[i][u] = par[i - 1][t];\n    }\n\n    for(int i = 0; i < adj2[u].size(); i++) {\n        int v = adj2[u][i];\n        if(v == p) continue;\n        dep[v] = dep[u] + 1;\n        dfs0(v, u);\n    }\n\n    tout[u] = timer;\n}\n\nint lca(int a, int b) {\n    if(dep[a] < dep[b]) swap(a, b);\n    int diff = dep[a] - dep[b];\n    for(int i = 0; i < 20; i++) {\n        if(diff & (1 << i)) a = par[i][a];\n    }\n    if(a == b) return a;\n    for(int i = 20; i--;) {\n        if(par[i][a] != par[i][b]) {\n            a = par[i][a];\n            b = par[i][b];\n        }\n    }\n    return par[0][a];\n}\n\nint dist(int u, int v) {\n    return dep[u] + dep[v] - 2 * dep[ lca(u, v) ];\n}\n\nint dep2[MN], mn, mnp;\n\nint ans;\nvoid dfs1(int u, int p) {\n    if(dep[u] <= dep2[u]) return;\n    ans = max(ans, dep[u]);\n\n    for(int i = 0; i < adj1[u].size(); i++) {\n        int v = adj1[u][i];\n        if(v == p) continue;\n        if(dist(u, v) >= 3) {\n            printf(\"-1\");\n            exit(0);\n        }\n        dep2[v] = dep2[u] + 1;\n        dfs1(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    X--; Y--;\n\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj1[a].push_back(b);\n        adj1[b].push_back(a);\n    }\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj2[a].push_back(b);\n        adj2[b].push_back(a);\n    }\n\n    dfs0(Y, -1);\n    dfs1(X, -1);\n    printf(\"%d\", 2 * ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <codecvt>\n\nconst int N = 200001;\n\nint n, x, y, a[N], b[N], depth[N], parent[N], escape[N], dist[N];\nstd::vector<int> tree[N], graph[N];\n\nvoid prepare(int p, int u) {\n  depth[u] = depth[p] + 1, parent[u] = p;\n  for (int v : tree[u]) {\n    if (v != p) {\n      prepare(u, v);\n    }\n  }\n}\n\nint treedist(int a, int b) {\n  int d = 0;\n  while (d < 3 && a != b) {\n    int &u = depth[a] > depth[b] ? a : b;\n    d++, u = parent[u];\n  }\n  return d;\n}\n\nint main() {\n  scanf(\"%d%d%d\", &n, &x, &y);\n  for (int i = 0; i < n - 1; ++i) {\n    scanf(\"%d%d\", a + i, b + i);\n  }\n  for (int i = 0, c, d; i < n - 1; ++i) {\n    scanf(\"%d%d\", &c, &d);\n    tree[c].push_back(d);\n    tree[d].push_back(c);\n  }\n  depth[0] = -1;\n  prepare(0, y);\n  for (int i = 0; i < n - 1; ++i) {\n    if (treedist(a[i], b[i]) == 3) {\n      escape[a[i]] = escape[b[i]] = true;\n    } else {\n      graph[a[i]].push_back(b[i]);\n      graph[b[i]].push_back(a[i]);\n    }\n  }\n  std::vector<int> queue;\n  queue.push_back(x);\n  memset(dist, -1, sizeof(dist));\n  dist[x] = 0;\n  int result = 0;\n  for (int head = 0; head < static_cast<int>(queue.size()); ++head) {\n    int u = queue[head];\n    if (dist[u] >= depth[u]) {\n      continue;\n    }\n    if (escape[u]) {\n      result = -1;\n      break;\n    }\n    result = std::max(result, depth[u] << 1);\n    for (int v : graph[u]) {\n      if (dist[v] == -1) {\n        dist[v] = dist[u] + 1;\n        queue.push_back(v);\n      }\n    }\n  }\n  printf(\"%d\\n\", result);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(2e5) + 9;\n\nint n, x, y;\n\nstruct Tree{\n    vector<int> adj[N];\n    int d[N], p[N];\n    \n    void dfs(int u, int p = -1){\n        for (auto v: adj[u]){\n            if (v == p) continue;\n            d[v] = d[u] + 1; this->p[v] = u;\n            dfs(v, u);\n        }\n    }\n    void in(){\n        DO(n-1){\n            int x, y; RD(x, y); --x, --y;\n            adj[x].PB(y);\n            adj[y].PB(x);\n        }\n    }\n} R, B;\n\nint z;\n\nbool dfs(int u, int p = -1){\n    if (B.d[u] <= R.d[u]) return false;\n    for (auto v: R.adj[u]){\n        if (v == p) continue;\n        R.d[v] = R.d[u] + 1;\n        if (!(v == B.p[u] || B.p[v] == u || B.p[B.p[u]] == v || B.p[B.p[v]] == u || B.p[u] == B.p[v])) return true;\n        if (dfs(v, u)) return true;\n        checkMax(z, B.d[u]*2);\n    }\n    return false;\n}\n\nint gao(){\n    RD(n, x, y); R.in(); B.in(); B.dfs(y);\n    z = 0; if (dfs(x)) return -1;\n    return z;\n}\n\nint main(){\n        \n    OT(gao());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\ntypedef int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\nconst ll maxn=2e5+10, maxm=5e3+10, lg=20, mod=998244353, inf=1e18;\n\nll n,X,Y,par[maxn],h[maxn],ans=0;\nvector<ll> g[maxn],ex[maxn];\nbool bad[maxn],mk[maxn];\nvoid dfs(ll v){for(auto u:g[v])if(u!=par[v])par[u]=v,h[u]=h[v]+1,dfs(u);}\nvoid df2(ll v,ll d=0){\n\tmk[v]=1;\n\tif(bad[v] && h[v]-d>0){cout<<-1;exit(0);}\n\tans=max(ans,2*h[v]);\n\tfor(auto u:ex[v]) df2(u,d+1);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>X>>Y;\n\tvector<pll> E;\n\tfor(int i=1;i<n;i++){\n\t\tll v,u; cin>>v>>u;\n\t\tE.pb({v,u});\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tll v,u; cin>>v>>u;\n\t\tg[v].pb(u), g[u].pb(v);\n\t}\n\tdfs(Y);\n\tfor(auto e:E){\n\t\tll v=e.F, u=e.S;\n\t\tif(par[v]==par[u]) continue;\n\t\tif(par[par[v]]==u || par[v]==u) ex[u].pb(v);\n\t\telse if(par[par[u]]==v || par[u]==v) ex[v].pb(u);\n\t\telse bad[v]=bad[u]=1;\n\t}\n\tdf2(X);\n\tcout<<ans;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++\nPROG: e.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__) #define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst signed inf=0x3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// print a signed integer\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint n,x,y;\nvector<int> R[200005],B[200005];\nint loop[200005],dfn[200005],low[200005],t,dis[200005],fa[200005],Dis[200005],Fa[200005];\nvoid BlueDFS(int x,int f){\n\tfa[x]=f;\n\tdfn[x]=++t;\t\n\tdis[x]=dis[f]+1;\n\tfor(auto i:B[x])if(i!=f)BlueDFS(i,x);\n\tlow[x]=++t;\n}\nint chk(int x,int y){\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tif(dfn[x]<=dfn[y] && low[y]<=low[x])return dis[x]-dis[y]>2;\n\treturn fa[x]!=fa[y];\t\n}\nint q[200005],*l,*r;\nint RedBFS(int x){\n\t*(l=r=q)=x;\t\n\tint ans=dis[x]<<1;\n\tif(loop[x])return -1;\n\twhile(l<=r){\n\t\tfor(auto i:R[*l])if(i!=Fa[*l]){\n\t\t\tFa[i]=*l;\n\t\t\tDis[i]=Dis[*l]+1;\n\t\t\tif(Dis[i]>dis[i])continue;\n\t\t\telse chkmax(ans,dis[i]<<1);\n\t\t\tif(Dis[i]<dis[i]){\n\t\t\t\t*(++r)=i;\n\t\t\t\tif(loop[i])return -1;\n\t\t\t}\n\t\t}\n\t\t++l;\n\t}\n\treturn ans;\n}\nint main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"e.in\",\"r\",stdin);\n\tfreopen(\"e.out\",\"w\",stdout);\n#endif\n\tread(n,x,y);\t\n\tif(x==y){write(\"0\\n\");return 0;}\n\tint u,v;\n\tfor(int i=1;i<n;++i){read(u,v);R[u].push_back(v);R[v].push_back(u);}\n\tfor(int i=1;i<n;++i){read(u,v);B[u].push_back(v);B[v].push_back(u);}\n\tdis[0]=-1;\n\tBlueDFS(y,0);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(auto j:R[i]){\n\t\t\tif(chk(i,j)){loop[i]=1;break;}\n\t\t}\n\t}\n\twrite(RedBFS(x),'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Graph\n{\n    int N;\n    vector<vector<int>> red_neighbors, blue_neighbors;\n\n    Graph(const int N) : N(N), red_neighbors(N), blue_neighbors(N) {}\n\n    void add_red_edge(const int a, const int b)\n    {\n        red_neighbors[a].push_back(b);\n        red_neighbors[b].push_back(a);\n    }\n\n    void add_blue_edge(const int a, const int b)\n    {\n        blue_neighbors[a].push_back(b);\n        blue_neighbors[b].push_back(a);\n    }\n\n    int solve(const int X, const int Y) const\n    {\n        auto blue_depths = vector<int>(N);\n        auto blue_parents = vector<int>(N);\n        const function<void(int, int)> blue_dfs = [&](const int v, const int parent)\n        {\n            for (const auto w : blue_neighbors[v]) if (w != parent)\n            {\n                blue_depths[w] = blue_depths[v]+1;\n                blue_parents[w] = v;\n                blue_dfs(w, v);\n            }\n        };\n        blue_parents[Y] = Y;\n        blue_dfs(Y, -1);\n\n        const auto blue_distance_1 = [&](const int v, const int w)\n        {\n            return blue_parents[v] == w || blue_parents[w] == v;\n        };\n\n        const auto blue_distance_2 = [&](const int v, const int w)\n        {\n            return blue_parents[blue_parents[v]] == w ||\n                   blue_parents[blue_parents[w]] == v ||\n                   blue_parents[v] == blue_parents[w];\n        };\n\n        auto red_distances = vector<int>(N, -1);\n        auto win = false;\n        const function<void(int, int)> red_dfs = [&](const int v, const int parent)\n        {\n            if (red_distances[v] >= blue_depths[v]) return;\n\n            for (const auto w : red_neighbors[v]) if (w != parent)\n            {\n                if (!(blue_distance_1(v, w) || blue_distance_2(v, w)))\n                    win = true;\n                else\n                {\n                    red_distances[w] = red_distances[v]+1;\n                    red_dfs(w, v);\n                }\n            }\n        };\n        red_distances[X] = 0;\n        red_dfs(X, -1);\n\n        if (win) return -1;\n        else\n        {\n            auto result = 0;\n            for (auto v = 0; v < N; v++)\n                if (red_distances[v] != -1)\n                    result = max(result, 2*blue_depths[v]);\n            return result;\n        }\n    }\n};\n\nint main()\n{\n    int N, X, Y; cin >> N >> X >> Y;\n    X--; Y--;\n\n    auto graph = Graph(N);\n\n    for (auto i = 0; i < N-1; i++)\n    {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        graph.add_red_edge(a, b);\n    }\n\n    for (auto i = 0; i < N-1; i++)\n    {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        graph.add_blue_edge(a, b);\n    }\n\n    cout << graph.solve(X, Y) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\nconst int N=2e5+3,K=18;\nstd::vector<int>g1[N],g2[N];\nint n,rt1,rt2,d1[N],d2[N],fa[N][K],ans;\ninline int Lca(int u,int v){\n\tif(d2[u]<d2[v])std::swap(u,v);\n\tfor(int j=K-1;~j;j--)if(d2[fa[u][j]]>=d2[v])\n\t  u=fa[u][j];\n\tif(u==v)return u;\n\tfor(int j=K-1;~j;j--)if(fa[u][j]!=fa[v][j])\n\t  u=fa[u][j],v=fa[v][j];\n\treturn fa[u][0];\n}\nvoid Dfs2(int u){\n\tint v;\n\tfor(int j=1;j<K;j++)fa[u][j]=fa[fa[u][j-1]][j-1];\n\tfor(int i=0;i<g2[u].size();i++)if((v=g2[u][i])!=fa[u][0])\n\t  d2[v]=d2[u]+1,fa[v][0]=u,Dfs2(v);\n}\nvoid Dfs1(int u,int fa){\n\tint v;\n\tif(d1[u]>=d2[u])return;\n\tfor(int i=0;i<g1[u].size();i++){\n\t  v=g1[u][i];\n\t  if(d2[u]+d2[v]-2*d2[Lca(u,v)]>2)exit(0*puts(\"-1\"));\n\t}\n\tans=std::max(ans,d2[u]);\n\tfor(int i=0;i<g1[u].size();i++)if((v=g1[u][i])!=fa)\n\t  d1[v]=d1[u]+1,Dfs1(v,u);\n}\nint main(){\n\tint u,v;\n\tscanf(\"%d%d%d\",&n,&rt1,&rt2);\n\tfor(int i=1;i<n;i++)\n\t  scanf(\"%d%d\",&u,&v),g1[u].push_back(v),g1[v].push_back(u);\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&u,&v),g2[u].push_back(v),g2[v].push_back(u);\n\tDfs2(rt2);\n\tDfs1(rt1,0);\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define Rep(i,a) for(int i = 0; i < a; i++)\nusing namespace std;\nconst int N = 2e5 + 10;\n\nstruct edge{ int to, pre; } e[N << 1]; int l = 0, u[N];\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint n, X, Y, a[N], b[N], dep[N], fa[N];\n\nvoid dfs(int x, int f) {\n\treg(i,x) if (v != f) dep[v] = dep[x] + 1, fa[v] = x, dfs(v, x);\n}\n\nbool jump(int a, int b) {\n\tif (dep[a] < dep[b]) swap(a, b);\n\tif (fa[a] == b || fa[fa[a]] == b || fa[a] == fa[b]) return false;\n\telse return true;\n}\n\nvector<int> adj[N];\n#define pb(a) push_back(a)\n\nbool inf = false, win[N];\nint ans = 0;\nvoid chk(int x, int f, int d) {\n\tif (d >= dep[x]) return; else ans = max(ans, dep[x]);\n\tinf |= win[x]; int l = adj[x].size();\n\tRep(j,l) if (adj[x][j] != f) chk(adj[x][j], x, d + 1);\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\trep(i,1,n - 1) scanf(\"%d%d\",a + i,b + i);\n\trep(i,1,n - 1) {\n\t\tint a, b; scanf(\"%d%d\",&a,&b);\n\t\tins(a, b), ins(b, a);\n\t}\n\tdfs(Y, 0);\n\trep(i,1,n - 1) \n\t\tif (!jump(a[i], b[i])) \n\t\t\tadj[a[i]].pb(b[i]), adj[b[i]].pb(a[i]);\n\t\telse win[a[i]] = win[b[i]] = true;\n\tchk(X, 0, 0);\n\tif (inf) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans * 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int maxn=2e5;\nint n,x,y,tot;\nint pre[maxn*4+8],son[maxn*4+8];\nbool can[maxn+8];\nqueue<int>st;\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nstruct Tree\n{\n    int now[maxn+8],dep[maxn+8],f[maxn+8][20];\n    void add(int u,int v)\n    {\n    pre[++tot]=now[u];\n    now[u]=tot;\n    son[tot]=v;\n    }\n    void build(int x)\n    {\n    dep[x]=dep[f[x][0]]+1;\n    for (int i=1;i<=log(dep[x])/log(2);i++) f[x][i]=f[f[x][i-1]][i-1];\n    for (int p=now[x];p;p=pre[p])\n        {\n        int child=son[p];\n        if (f[x][0]==child) continue;\n        f[child][0]=x;\n        build(child);\n        }\n    }\n    int Get_Lca(int x,int y)\n    {\n    if (dep[x]<dep[y]) swap(x,y);\n    for (int i=log(dep[x])/log(2);~i;i--)\n        if (dep[f[x][i]]>=dep[y]) x=f[x][i];\n    if (x==y) return x;\n    for (int i=log(dep[x])/log(2);~i;i--)\n        if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n    return f[x][0];\n    }\n    int Get_Dis(int x,int y){return dep[x]+dep[y]-dep[Get_Lca(x,y)]*2;}\n}T1,T2;\n \nvoid solve()\n{\n    //for (int i=1;i<=n;i++) printf(\"%d \",can[i]);puts(\"\");\n    int ans=0;\n    for (int i=1;i<=n;i++)\n    if (can[i])\n        {\n        ans=max(ans,T2.dep[i]-1);\n        for (int p=T1.now[i];p;p=pre[p])\n            {\n            int child=son[p];\n            if (T2.Get_Dis(child,i)>2)\n                {\n                puts(\"-1\");\n                exit(0);\n                }\n            }\n        }\n    printf(\"%d\\n\",ans*2);\n}\n \nvoid prepare()\n{\n    can[x]=1;\n    st.push(x);\n    while(!st.empty())\n    {\n        int x=st.front();st.pop();\n        for (int p=T1.now[x];p;p=pre[p])\n        {\n            int child=son[p];\n            if (can[child]) continue;\n            if (T1.dep[child]<T2.dep[child]) can[child]=1,st.push(child);\n        }\n    }\n}\n \nint main()\n{\n    n=read(),x=read(),y=read();\n    if (x==y)\n    {\n        puts(\"0\");\n        return 0;\n    }\n    for (int i=1;i<n;i++)\n    {\n        int u=read(),v=read();\n        T1.add(u,v),T1.add(v,u);\n    }\n    for (int i=1;i<n;i++)\n    {\n        int u=read(),v=read();\n        T2.add(u,v),T2.add(v,u);\n    }\n    T1.build(x),T2.build(y);\n    prepare();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200010;\n\ntemplate<typename T> inline T read() {\n\tT x(0), f(1);\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint e, st[MAXN], to[MAXN<<1];\nint nxt[MAXN<<1];\ninline void add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e;\n}\n\nint E, St[MAXN], To[MAXN<<1];\nint Nxt[MAXN<<1];\ninline void Add(int u, int v) {\n\tTo[++E] = v, Nxt[E] = St[u];\n\tSt[u] = E;\n}\n\nint n, dep[MAXN], rx, ry;\nint fa[MAXN][20], ans;\nbool vis[MAXN];\n\nvoid dfs(int u) {\n\tfor(int i = st[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif(v == fa[u][0]) continue;\n\t\tdep[v] = dep[u]+1;\n\t\tfa[v][0] = u, dfs(v);\n\t}\n}\n\ninline int LCA(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tfor(int i = 18; i >= 0; i--) \n\t\tif(dep[fa[u][i]] >= dep[v]) \n\t\t\tu = fa[u][i];\n\tif(v == u) return u;\n\tfor(int i = 18; i >= 0; i--) \n\t\tif(fa[u][i] ^ fa[v][i])\n\t\t\tu = fa[u][i], v = fa[v][i];\n\treturn fa[u][0];\n}\n\nvoid Dfs(int u, int d) {\n\tvis[u] = true;\n\t//printf(\"%d %d\\n\", u, dep[u]);\n\tans = max(ans, (dep[u]-1)<<1);\n\tfor(int i = St[u]; i; i = Nxt[i]) {\n\t\tint v = To[i];\n\t\tif(vis[v]) continue;\n\t\tif(dep[v] <= d+1) continue;\n\t\tint lca = LCA(u, v);\n\t\tif(dep[u]+dep[v]-(dep[lca]<<1) > 2) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tDfs(v, d+1);\n\t}\n}\n\nint main() {\n\tn = read<int>();\n\trx = read<int>(), ry = read<int>();\n\tfor(int i = 1; i < n; i++) {\n\t\tint u = read<int>(), v = read<int>();\n\t\tAdd(u, v), Add(v, u);\n\t}\n\tfor(int i = 1; i < n; i++) {\n\t\tint u = read<int>(), v = read<int>();\n\t\tadd(u, v), add(v, u);\n\t}\n\tdep[ry] = 1;\n\tdfs(ry);\n\tfor(int k = 1; k <= 18; k++) \n\t\tfor(int i = 1; i <= n; i++) \n\t\t\tfa[i][k] = fa[fa[i][k-1]][k-1];\n\tDfs(rx, 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define char ll\n//#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n#ifdef HK_CUP\n    freopen(\"finput.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n#ifndef HK_CUP\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n#endif\n    return 0;\n}\n\nconst int N = 2e5 + 10;\n\nstruct Tree {\n    vvi g;\n    vi parent;\n    int timer = 1;\n    vi tin, tout;\n    vi dip;\n    Tree(int n) {\n        g.resize(n + 1);\n        parent.resize(n + 1, -1);\n        tin.resize(n + 1);\n        tout.resize(n + 1);\n        dip.resize(n + 1, 0);\n    }\n\n    void add_edge(int v, int u) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    void dfs(int v, int par = -1) {\n        tin[v] = timer++;\n        if (par == -1)\n            par = v;\n        parent[v] = par;\n        for (int to : g[v]) {\n            if (to == par)\n                continue;\n            dip[to] = dip[v] + 1;\n            dfs(to, v);\n        }\n        tout[v] = timer++;\n    }\n\n    bool is_par(int u, int v) {\n        return tin[u] <= tin[v] && tin[v] <= tout[u];\n    }\n};\n\nint n, x, y;\n\nTree input_tree(int n, int root) {\n    Tree ret(n);\n    fori (_, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        ret.add_edge(u, v);\n    }\n    ret.dfs(root);\n    return ret;\n}\n\nconst int oo = 1e9 + 10;\nint dp[N];\nTree red(N), blue(N);\n\nvoid dfs(int v) {\n//    cerr << \"dp[\" << v << \"] = \" << dp[v] << endl;\n    for (int to : red.g[v]) {\n        if (to == red.parent[v])\n            continue;\n        if (blue.parent[to] == dp[v] ||\n            blue.parent[dp[v]] == to ||\n            to == dp[v]) {\n            continue;\n        }\n        for (int to2 :  blue.g[dp[v]]) {\n            if (to2 == blue.parent[dp[v]])\n                continue;\n            if (blue.is_par(to2, to))\n                dp[to] = to2;\n        }\n        if (dp[to] != oo) {\n            dfs(to);\n        }\n    }\n}\n\nvoid smain() {\n    cin >> n >> x >> y;\n    red = input_tree(n, x);\n    blue = input_tree(n, y);\n    fill(dp, dp + n + 1, oo);\n    dp[x] = y;\n    dfs(x);\n\n    for (int v = 1; v <= n; ++v) {\n        if (dp[v] == oo)\n            continue;\n        int subt = blue.parent[v];\n        for (int to : red.g[v]) {\n            if (blue.is_par(subt, to) ||\n                to == subt ||\n                blue.parent[to] == subt ||\n                blue.parent[subt] == to)\n                continue;\n            cout << \"-1\\n\";\n            exit(0);\n        }\n    }\n\n    int ans = 0;\n    for (int v = 1; v <= n; ++v) {\n        if (dp[v] != oo) {\n            inmax(ans, blue.dip[v]);\n        }\n    }\n    cout << ans * 2;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint n,x,y;\nint xx[N],yy[N];\nint head[N],ver[N*2],nxt[N*2],tot;\nvoid add(int a,int b)\n{\n\ttot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint dis[N];\nint f[N][20];\nvoid dfs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(ver[i]==fa)continue;\n\t\tdis[ver[i]]=dis[x]+1;\n\t\tf[ver[i]][0]=x;\n\t\tdfs(ver[i],x);\n\t}\n\treturn 0;\n}\nvoid dffs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\t\n\t}\n\treturn ;\n}\nint lca(int a,int b)\n{\n\tif(dis[a]<dis[b])swap(a,b);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dis[f[a][i]]>=dis[b])a=f[a][i];\n\t}\n\tif(a==b)return a;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t}\n\treturn f[a][0];\n}\nint calc(int a,int b)\n{\n\treturn dis[a]+dis[b]-2*dis[lca(a,b)];\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tint t1,t2;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&xx[i],&yy[i]);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tadd(t1,t2);add(t2,t1);\n\t}\n\tdis[y]=1;dfs(y);\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tf[j][i]=f[f[j][i-1]][i-1];\n\t\t}\n\t}\n\ttot=0;memset(head,0,sizeof(head));\n\tdffs(x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n\tvector<vector<int> > g;\n\tconst int MAX_LOG = 22;\n\tvector<vector<int> > lcc;\n\tvector<int> dep;\n\tvector<int> myr;\nprivate:\n\tvoid init2(){\n\t\tint n = g.size();\n\t\tfor (int i = 0; i + 1 < MAX_LOG; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (lcc[i][j] == -1){\n\t\t\t\t\tlcc[i + 1][j] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlcc[i + 1][j] = lcc[i][lcc[i][j]];\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tint lca(int a, int b){\n\t\tif (dep[a] < dep[b]){\n\t\t\tswap(a, b);\n\t\t}\n\t\tfor (int i = 0; i < MAX_LOG; i++){\n\t\t\tif (((dep[a] - dep[b]) >> i) & 1){\n\t\t\t\ta = lcc[i][a];\n\t\t\t}\n\t\t}\n\t\tif (a == b){\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = MAX_LOG - 1; i >= 0; i--){\n\t\t\tif (lcc[i][a] != lcc[i][b]){\n\t\t\t\ta = lcc[i][a];\n\t\t\t\tb = lcc[i][b];\n\t\t\t}\n\t\t}\n\t\treturn lcc[0][a];\n\t}\nprivate:\n\tint flag_r;\n\tinline void dfs(int b, int pr = -1, int d = 0){\n\t\tfor (auto &i : g[b]){\n\t\t\tif (i == pr)continue;\n\t\t\tdfs(i, b, d + 1);\n\t\t}\n\t\tdep[b] = d;\n\t\tlcc[0][b] = pr;\n\t\tmyr[b] = flag_r;\n\t}\npublic:\n\n\tvoid init(vector<vector<int> > &tree, int root = 0){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tflag_r = root;\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tdfs(root);\n\t\tinit2();\n\t}\n\tvoid init(vector<vector<int> > &tree, vector<int> &root){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tfor (int &i : root){\n\t\t\tif (myr[i] == -1){\n\t\t\t\tflag_r = i;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t}\n\tint dist(int a, int b){ \n\t\tif (myr[a] != myr[b]){\n\t\t\treturn -1;\n\t\t}\n\t\tint lc = lca(a, b);\n\t\treturn dep[a] + dep[b] - 2 * dep[lc];\n\t}\n\tint go(int a, int b){\n\t\tfor (int i = 0; i < MAX_LOG; i++){\n\t\t\tif ((b >> i) & 1){\n\t\t\t\ta = lcc[i][a];\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n};\n\n#define MAX 200002\n\nint n;\n\nint x;\nint y;\n\nvector<vector<int> > sigma;\nvector<vector<int> > sugim;\n\nLCA sigmaL;\nLCA sugimL;\n\nbool win[MAX];\n\nvector<vector<int> > vv;\nqueue<int> q;\nvector<int> ord;\nbool vis[MAX];\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t}\n};\nUF uf;\n\nint main(){\n\tcin >> n;\n\tuf.resize(n);\n\tcin >> x >> y;\n\tsigma.resize(n,vector<int>());\n\tsugim = sigma; \n\tvv = sigma;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsigma[a].push_back(b);\n\t\tsigma[b].push_back(a);\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsugim[a].push_back(b);\n\t\tsugim[b].push_back(a);\n\t}\n\tx--;\n\ty--;\n\tsugimL.init(sugim,y);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int &j : sigma[i]){\n\t\t\tif (i > j)continue;\n\t\t\tint d = sugimL.dist(i, j);\n\t\t\tif (d > 2){\n\t\t\t\twin[i] = true;\n\t\t\t\twin[j] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tuf.merge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tsigmaL.init(sigma, y);\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i]){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (uf.root(a)!=uf.root(b)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim;\n\t\t\tif (uf.root(lc) == uf.root(a)){\n\t\t\t\ttim = sigmaL.dist(a, lc);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttim = sigmaL.dist(a, sugimL.go(b, sugimL.dist(b, lc) - 1));\n\t\t\t}\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tif (tim < tim2){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i] == false){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (uf.root(a)!= uf.root(b) ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tint cost = sigmaL.dist(a, b);\n\t\t\tif (tim > tim2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim == tim2){\n\t\t\t\tif (b == lc){\n\t\t\t\t\tans = max(ans, cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tans = max(ans, cost + tim2 - tim);\n\t\t\t}\n\t\t}\n\t}\n\tcout << 2*ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define per(i, a, b) for(int i = a; i >= b; i--)\ntypedef long long LL;\nconst int maxn = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\nint n, x, y, first[maxn], dep[maxn], s[maxn][2], f[maxn][27], g[maxn], dis[maxn], cnt;\nbool vis[maxn];\nstruct Edge {\n\tint to, next, ser;\n} e[maxn<<2];\n\nvoid Dfs(int u, int fa) {\n\tdep[u] = dep[fa] + 1;\n\tf[u][0] = fa;\n\tg[u] = dep[u];\n\tfor(int i = first[u]; i; i = e[i].next) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || e[i].ser) continue;\n\t\tDfs(v, u);\n\t\tg[u] = max(g[v], g[u]);\n\t}\n}\n\nvoid add(int u, int v, int ser) {\n\te[++cnt] = (Edge) {v, first[u], ser};\n\tfirst[u] = cnt;\n}\n\nint Lca(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tint dif = dep[u] - dep[v];\n\trep(i, 25, 0)\n\t    if(dif >= (1<<i)) {\n\t    \tdif -= 1<<i;\n\t    \tu = f[u][i];\n\t    }\n\trep(i, 25, 0)\n\t    if(f[u][i] != f[v][i]) {\n\t    \tu = f[u][i];\n\t    \tv = f[v][i];\n\t    }\n\treturn f[u][0];\n}\n\n\nbool Bfs(int s) {\n\tmemset(dis, 0x7f, sizeof(dis));\n\tqueue <int> q;\n\tdis[s] = 0;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = first[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\tif(!e[i].ser || dis[u] + 1 >= dep[v] || dis[u] + 1 >= dis[v]) continue;\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\trep(i, 1, n)\n\t    if(dis[i] < dep[i] && vis[i]) return 1;\n\treturn 0;\n}\n\nint main() {\n\tcin>>n>>x>>y;\n\tint u, v;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 1);\n\t\tadd(v, u, 1);\n\t\ts[i][0] = u, s[i][1] = v;\n\t}\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 0);\n\t\tadd(v, u, 0);\n\t}\n\tdep[0] = -1;\n\tDfs(y, 0);\n\trep(k, 1, 25)\n\t    rep(i, 1, n) \n\t        f[i][k] = f[f[i][k - 1]][k - 1];\n\trep(i, 1, n - 1) {\n\t\tint d = Lca(s[i][0], s[i][1]);\n\t\tif(dep[s[i][0]] + dep[s[i][1]] - 2*dep[d] > 2) vis[s[i][0]] = vis[s[i][1]] = 1;\n\t} \n\tif(Bfs(x)) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\telse {\n\t\tint ans = 0;\n\t\trep(i, 1, n)\n\t\t    if(dis[i] < dep[i]) ans = max(ans, dep[i]);\n\t\tcout<<ans*2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define MAXN 200000\nusing namespace std;\nstruct node\n{\n\tint to;\n\tnode *nxt;\n}edges[MAXN*4+5];\nnode *ncnt=&edges[0],*AdjR[MAXN+5],*AdjB[MAXN+5];\nint fro[MAXN+5],to[MAXN+5];\nint N,X,Y,dfn[MAXN+5],efn[MAXN+5],tmn;\nint dep[MAXN+5],fa[MAXN+5];\nint dist[MAXN+5];\nbool sppoint[MAXN+5];\nbool vis[MAXN+5];\nqueue<int> que;\nvoid Init()\n{\n\tncnt=&edges[0];\n\tmemset(AdjR,0,sizeof(AdjR));\n\tmemset(AdjB,0,sizeof(AdjB));\n\ttmn=0;\n\tmemset(sppoint,0,sizeof(sppoint));\n\tmemset(vis,0,sizeof(vis));\n\twhile(que.empty()==false)\n\t\tque.pop();\n}\nvoid AddEdgeR(int u,int v)\n{\n\tnode *p=++ncnt;\n\tp->to=v;\n\tp->nxt=AdjR[u];\n\tAdjR[u]=p;\n\t\n\tnode *q=++ncnt;\n\tq->to=u;\n\tq->nxt=AdjR[v];\n\tAdjR[v]=q;\n}\nvoid AddEdgeB(int u,int v)\n{\n\tnode *p=++ncnt;\n\tp->to=v;\n\tp->nxt=AdjB[u];\n\tAdjB[u]=p;\n\t\n\tnode *q=++ncnt;\n\tq->to=u;\n\tq->nxt=AdjB[v];\n\tAdjB[v]=q;\n}\nvoid DFS1(int u,int f)\n{\n\tfa[u]=f;\n\tdfn[u]=++tmn;\n\tfor(node *p=AdjB[u];p!=NULL;p=p->nxt)\n\t{\n\t\tint v=p->to;\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tdep[v]=dep[u]+1;\n\t\tDFS1(v,u);\n\t}\n\tefn[u]=++tmn;\n}\nvoid BFS()\n{\n\tvis[X]=true;\n\tdist[X]=0;\n\tque.push(X);\n\twhile(que.empty()==false)\n\t{\n\t\tint u=que.front();\n\t\tque.pop();\n\t\tfor(node *p=AdjR[u];p!=NULL;p=p->nxt)\n\t\t{\n\t\t\tint v=p->to;\n\t\t\tif(vis[v]==false)\n\t\t\t{\n\t\t\t\tdist[v]=dist[u]+1;\n\t\t\t\tif(dist[v]<dep[v])\n\t\t\t\t{\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool Check(int x,int y)\n{\n\tif(dfn[x]>dfn[y])\n\t\tswap(x,y);\n\tif(dfn[x]<dfn[y]&&efn[x]>efn[y])\n\t{\n\t\tif(dep[y]-dep[x]>=3)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tif(fa[x]!=fa[y])\n\t\treturn true;\n\treturn false;\n}\nint read()\n{\n\tint ret=0;\n\tchar c=0;\n\twhile(c<'0'||c>'9')\tc=getchar();\n\tret=10*ret+c-'0';\n\twhile(true)\n\t{\n\t\tc=getchar();\n\t\tif(c<'0'||c>'9')\n\t\t\tbreak;\n\t\tret=10*ret+c-'0';\n\t}\n\treturn ret;\n}\nint main()\n{\n//\tfreopen(\"coalesce.in\",\"r\",stdin);\n//\tfreopen(\"coalesce.out\",\"w\",stdout);\n\twhile(scanf(\"%d %d %d\",&N,&X,&Y)==3)\n\t{\n\t\tInit();\n\t\tint u,v;\n\t\tfor(int i=1;i<N;i++)\n\t\t\tfro[i]=read(),to[i]=read();\n\t\tfor(int i=1;i<N;i++)\n\t\t{\n\t\t\tu=read(),v=read();\n\t\t\tAddEdgeB(u,v);\n\t\t}\n\t\tdep[Y]=0;\n\t\tDFS1(Y,-1);\n\t\tfor(int i=1;i<N;i++)\n\t\t\tif(Check(fro[i],to[i])==true)\n\t\t\t\tsppoint[fro[i]]=sppoint[to[i]]=true;\n\t\t\telse\n\t\t\t\tAddEdgeR(fro[i],to[i]);\n\t\tBFS();\n\t\tint maxdep=-1;\n\t\tbool Find=false;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tif(vis[i]==true)\n\t\t\t{\n\t\t\t\tif(sppoint[i]==true)\n\t\t\t\t{\n\t\t\t\t\tFind=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tmaxdep=max(maxdep,dep[i]);\n\t\t\t}\n\t\tif(Find==true)\n\t\t\tprintf(\"-1\\n\");\n\t\telse\n\t\t\tprintf(\"%d\\n\",maxdep*2);\n\t}\n\treturn 0;\n}\n/*\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<bits/stdc++.h>\n#define MAXN 200005\nusing namespace std;\n\nint n,cnt,last[MAXN];\nint father[MAXN],deep[MAXN],dis[MAXN];\nint q[MAXN],nnn[MAXN],mx[MAXN];\nint tim,a[MAXN][2],xx,yy;\nbool vis[MAXN],win[MAXN];\n\nstruct edge\n{\n    int to,next,h;\n}t[MAXN*4];\n\nvoid add(int u,int v,int h)\n{\n    t[++cnt].to=v;t[cnt].h=h;\n    t[cnt].next=last[u];last[u]=cnt;\n    t[++cnt].to=u;t[cnt].h=h;\n    t[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n    deep[x]=deep[father[x]]+1;nnn[x]=++tim;\n    for (int i=last[x];i;i=t[i].next)\n        if (t[i].to!=father[x]) father[t[i].to]=x,dfs(t[i].to);\n    mx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n    if (nnn[x]>nnn[y]) swap(x,y);\n    if (nnn[x]<nnn[y]&&mx[x]>nnn[y]) return deep[y]-deep[x]>2 ? true : false;\n    if (father[x]==father[y]) return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int h=1,tt=1;q[1]=xx;vis[xx]=1;\n    while (h<=tt)\n    {\n        int x=q[h++];\n        for (int i=last[x];i;i=t[i].next)\n            if (!t[i].h&&!vis[t[i].to])\n            {\n                dis[t[i].to]=dis[x]+1;\n                if (dis[t[i].to]<deep[t[i].to]) vis[t[i].to]=1,q[++tt]=t[i].to;\n            }\n    }\n}\n\nint max(int a,int b){return a>b?a:b;}\n\ntemplate<class T>inline void read(T &res)\n{\n    static char ch;T flag=1;\n    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;\n    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;\n}\n\nint main()\n{\n    int ans=0;\n    read(n);read(xx);read(yy);\n\n    for (int i=1;i<n;i++) {read(a[i][0]);read(a[i][1]);}\n    for (int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x);read(y);\n        add(x,y,1);\n    }\n\n    deep[0]=-1;\n    dfs( yy );\n\n    for (int i=1;i<n;i++)\n    {\n        if (check(a[i][0],a[i][1]))\n            win[a[i][0]]=win[a[i][1]]=1;\n        else add(a[i][0],a[i][1],0);\n    }\n\n    bfs();\n\n    for (int i=1;i<=n;i++)\n        if (win[i]&&vis[i])\n            {putchar('-');putchar('1');return 0;}\n\n    for (int i=1;i<=n;i++)\n        if (vis[i])\n            ans=max(ans,deep[i]<<1);\n\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++\nPROG: e.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__) #define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst signed inf=0x3f3f3f3f;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\tinline void read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\n\tinline void read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t}\n\tinline void read (char &x) {\n\t\tx=gc();\n\t}\n\tinline void read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void read(A &x,B &...y){\n\t\tread(x);read(y...);\n\t}\n\t// print a signed integer\n\tinline void write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\n\tinline void write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\tinline void write (char x) {\n\t\tputc(x);\n\t}\n\tinline void write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\tinline void write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline void write(A x,B ...y){\n\t\twrite(x);write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint n,x,y;\nvector<int> R[200005],B[200005];\nint loop[200005],dfn[200005],low[200005],t,dis[200005],fa[200005],Dis[200005],Fa[200005];\nvoid BlueDFS(int x,int f){\n\tfa[x]=f;\n\tdfn[x]=++t;\t\n\tdis[x]=dis[f]+1;\n\tfor(auto i:B[x])if(i!=f)BlueDFS(i,x);\n\tlow[x]=++t;\n}\nint chk(int x,int y){\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tif(dfn[x]<=dfn[y] && low[y]<=low[x])return dis[y]-dis[x]>2;\n\treturn fa[x]!=fa[y];\t\n}\nint q[200005],*l,*r;\nint RedBFS(int x){\n\t*(l=r=q)=x;\t\n\tint ans=dis[x]<<1;\n\tif(loop[x])return -1;\n\twhile(l<=r){\n\t\tfor(auto i:R[*l])if(i!=Fa[*l]){\n\t\t\tFa[i]=*l;\n\t\t\tDis[i]=Dis[*l]+1;\n\t\t\tif(Dis[i]>dis[i])continue;\n\t\t\telse chkmax(ans,dis[i]<<1);\n\t\t\tif(Dis[i]<dis[i]){\n\t\t\t\t*(++r)=i;\n\t\t\t\tif(loop[i])return -1;\n\t\t\t}\n\t\t}\n\t\t++l;\n\t}\n\treturn ans;\n}\nint main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"e.in\",\"r\",stdin);\n\tfreopen(\"e.out\",\"w\",stdout);\n#endif\n\tread(n,x,y);\t\n\tif(x==y){write(\"0\\n\");return 0;}\n\tint u,v;\n\tfor(int i=1;i<n;++i){read(u,v);R[u].push_back(v);R[v].push_back(u);}\n\tfor(int i=1;i<n;++i){read(u,v);B[u].push_back(v);B[v].push_back(u);}\n\tdis[0]=-1;\n\tBlueDFS(y,0);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(auto j:R[i]){\n\t\t\tif(chk(i,j)){loop[i]=1;break;}\n\t\t}\n\t}\n\twrite(RedBFS(x),'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst int INF = 1000000000;\n\nint N,X,Y;\nstruct Tree{\n\tint dep[MAXN+1],fa[20][MAXN+1];\n\tint Node[MAXN<<1],Next[MAXN<<1],Root[MAXN<<1],cnt;\n\tinline void insert(int u,int v){\n\t\tNode[++cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt; return ;\n\t}\n\tinline void dfs(int k,int Fa){\n\t\tif(Fa) dep[k]=dep[Fa]+1; fa[0][k]=Fa;\n\t\tfor(int j=1;j<=19;j++) fa[j][k]=fa[j-1][fa[j-1][k]];\n\t\tfor(int x=Root[k];x;x=Next[x]){\n\t\t\tint v=Node[x]; if(v==Fa) continue; dfs(v,k);\n\t\t} return ;\n\t}\n\tinline int LCA(int u,int v){\n\t\tif(dep[u]<dep[v]) swap(u,v);\n\t\tfor(int i=19;i>=0;i--) if(dep[u]-dep[v]>=(1<<i)) u=fa[i][u];\n\t\tfor(int i=19;i>=0;i--) if(fa[i][u]!=fa[i][v]) u=fa[i][u],v=fa[i][v];\n\t\tif(u!=v) return fa[0][u]; return u;\n\t}\n\tinline int dist(int u,int v){ return dep[u]+dep[v]-2*dep[LCA(u,v)]; }\n}T[2];\nint ans=0; bool use[MAXN+1];\ninline void getans(int k,int Fa){\n\tif(!use[k]) return ;\n\tans=max(ans,T[1].dep[k]);\n\tfor(int x=T[0].Root[k];x;x=T[0].Next[x]){\n\t\tint v=T[0].Node[x]; if(v==Fa) continue;\n\t\tif(T[1].dist(k,v)>2) { puts(\"-1\"); exit(0); }\n\t\tgetans(v,k);\n\t}\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(),X=read(),Y=read();\n\tif(X==Y){ puts(\"0\"); return 0; }\n\tfor(int i=2;i<=N;i++){\n\t\tint u=read(),v=read(); \n\t\tT[0].insert(u,v); T[0].insert(v,u);\n\t} for(int i=2;i<=N;i++){\n\t\tint u=read(),v=read();\n\t\tT[1].insert(u,v); T[1].insert(v,u);\n\t} T[0].dfs(X,0); T[1].dfs(Y,0);\n\tfor(int i=1;i<=N;i++){\n\t\tif(T[0].dep[i]<T[1].dep[i]) use[i]=1;\n\t} getans(X,0);\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int MAXN = 200005;\nstruct Edge{\n\tint to,next;\n}e[MAXN<<1];\nbool safe[MAXN];\nint dep[MAXN],n,x,y,cnt,head[MAXN];\ninline void insert(int u,int v)\n{\n\te[++cnt].to=v,e[cnt].next=head[u],head[u]=cnt;\n\te[++cnt].to=u,e[cnt].next=head[v],head[v]=cnt;\n}\nint u[MAXN],v[MAXN],pos[MAXN],out[MAXN],sz,fa[MAXN];\nvoid dfs(int x)\n{\n\tpos[x]=++sz;\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[x])continue;\n\t\tdep[v]=dep[x]+1;\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t}\n\tout[x]=sz;\n}\ninline bool judge(int x,int y)\n{\n\tif(pos[x]>pos[y])swap(x,y);\n\tif(pos[y]>=pos[x] && pos[y]<=out[x])return dep[y]-dep[x]>2;\n\treturn fa[x]!=fa[y];\n}\nnamespace Sigma{\n\tstruct Edge{\n\t\tint to,next;\n\t}e[MAXN<<1];\n\tint head[MAXN],cnt,ans;\n\tinline void insert(int u,int v)\n\t{\n\t\te[++cnt].to=v,e[cnt].next=head[u],head[u]=cnt;\n\t\te[++cnt].to=u,e[cnt].next=head[v],head[v]=cnt;\n\t}\n\tint getans(int x,int fa,int step)\n\t{\n\t\tif(safe[x])return -1;\n\t\tint ret=dep[x];\n\t\tfor(int i=head[x];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa)continue;\n\t\t\tif(dep[x]==1 && dep[v]<=1)continue;\n\t\t\tif(step+1>=dep[v])continue;\n\t\t\tint val=getans(v,x,step+1);\n\t\t\tif(val==-1)return -1;\n\t\t\telse ret=max(ret,val);\n\t\t}\n\t\treturn ret;\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",u+i,v+i);\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tinsert(u,v);\n\t}\n\tdfs(y);\n\tfor(int i=1;i<n;++i){\n\t\tif(judge(u[i],v[i]))safe[u[i]]=safe[v[i]]=1;\n\t\telse Sigma::insert(u[i],v[i]);\n\t}\n\tint ans=Sigma::getans(x,0,0);\n\tcout<<(ans==-1?-1:ans*2)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n    static const int BITLEN_MAX = 30;\n    vector<int> parent[BITLEN_MAX];\n    vector<int> depth;\n    int bitlen;\n\n    void initialize(int N, const vector<int> edges[]){\n        int root = 0;\n        bitlen = 1;\n        while((1<<bitlen) < N) bitlen += 1;\n        for(int i=0; i<bitlen; i++) parent[i].resize(N);\n        depth.resize(N, -1);\n\n        dfs(root, -1, 0, edges);\n        for(int k=0; k<bitlen-1; k++){\n            for(int v=0; v<N; v++){\n                if(depth[v] == -1) continue;\n                if(parent[k][v] < 0){\n                    parent[k+1][v] = -1;\n                }else{\n                    parent[k+1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n\n    void dfs(int v, int p, int d, const vector<int> edges[]){\n        parent[0][v] = p;\n        depth[v] = d;\n        for(auto u : edges[v]){\n            if(u != p) dfs(u, v, d+1, edges);\n        }\n    }\n\n    int calc_lca(int u, int v){\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int k=0; k<bitlen; k++){\n            if( ((depth[v]-depth[u]) >> k) & 1 ) v = parent[k][v];\n        }\n        if(u == v) return u;\n        for(int k=bitlen-1; k>=0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n    int calc_dist(int u, int v){\n        int l = calc_lca(u, v);\n        return depth[u] + depth[v] - depth[l]*2;\n    }\n};\n\nvector<int> edges[2][200000];\nint dist[2][200000];\nbitset<200000> dead, eternal;\n\nvoid dfs(int i, int p, int d, int k){\n    dist[k][i] = d;\n    for(int j : edges[k][i]) if(j != p) dfs(j, i, d+1, k);\n}\n\nint ans = 0;\nconst int INF = 1e9;\nvoid dfs2(int i, int p){\n    ans = max(ans, eternal[i] ? INF : dist[1][i] * 2);\n    for(int j : edges[0][i]) if(j != p && !dead[j]) dfs2(j, i);\n}\n\nint main(){\n    int N, S[2];\n    cin >> N >> S[0] >> S[1];\n    for(int k=0; k<2; k++){\n        for(int i=0; i<N-1; i++){\n            int a, b;\n            cin >> a >> b;\n            edges[k][a-1].push_back(b-1);\n            edges[k][b-1].push_back(a-1);\n        }\n        S[k]--;\n        dfs(S[k], -1, 0, k);\n    }\n\n    for(int i=0; i<N; i++) if(dist[0][i] >= dist[1][i]) dead[i] = true;\n\n    LCA lca1;\n    lca1.initialize(N, edges[1]);\n    for(int i=0; i<N; i++){\n        for(int j : edges[0][i]){\n            if(lca1.calc_dist(i, j) > 2) eternal[i] = eternal[j] = true;\n        }\n    }\n\n    dfs2(S[0], -1);\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N << 1], dph[N << 1], dfn = 0;\nint dp[N << 1][20], lg2[N << 1];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x]) {\n        if (y != fx) dfsb(y, x);\n        q[++dfn] = x;\n        dph[dfn] = db[x];\n    }\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] >= db[x]) return;\n    if (~ans) ans = max((db[x] - 1) << 1, ans);\n    for (int y : a[x]) {\n        if (y == fx) continue;\n        if (db[x] + db[y] - 2 * db[LCA(x, y)] > 2) ans = -1;\n        dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1e9;\nint n, x, y, rp[200010], rd[200010], bp[200010], bd[200010], ans;\nvector<int> re[200010], be[200010];\n\nvoid T_T(){ puts(\"-1\"); exit(0); }\n\nvoid f(int t, int x, int pr, int de, int *p, int *d){\n\td[x] = de;\n\tp[x] = pr;\n\tif(t){\n\t\tfor(auto &i : be[x]){\n\t\t\tif(i != pr) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n\telse{\n\t\tfor(auto &i : re[x]){\n\t\t\tif(i != pr && i != y) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tauto in = [](int t){\n\t\tfor(int i = 0, x, y; i < n - 1; i++){\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t(t ? be[x] : re[x]).push_back(y);\n\t\t\t(t ? be[y] : re[y]).push_back(x);\n\t\t}\n\t};\n\tin(0); in(1);\n\tf(1, y, 0, 0, bp, bd);\n\tfill(rd + 1, rd + n + 1, inf);\n\tf(0, x, 0, 0, rp, rd);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(auto &j : re[i]){\n\t\t\tint a = i, b = j;\n\t\t\tif(bd[a] > bd[b]) swap(a, b);\n\t\t\tif(bp[b] == a || bp[bp[b]] == a || bp[a] == bp[b]) continue;\n\t\t\tif(bd[a] >= rd[a] || bd[b] >= rd[b]) T_T();\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) if(rd[i] < inf) ans = max(ans, 2 * bd[i]);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chkmax(T& a,T b){return a<b?a=b,1:0;}\ntemplate<class T> inline bool chkmin(T& a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T& read(T& x){\n    static char c; bool flag=0;\n    while(!isdigit(c=getchar())) if(c=='-') flag=1;\n    for(x=c-'0';isdigit(c=getchar());(x*=10)+=c-'0');\n    if(flag) x=-x;\n    return x;\n}\nconst int maxn=200010;\nint n,A,B;\nint head[maxn],nxt[maxn<<1],to[maxn<<1],e;\nint head2[maxn],nxt2[maxn<<1],to2[maxn<<1],e2;\nstruct Edge{\n\tint u,v;\n} E[maxn];\nvoid ae(int x,int y){\n    to[++e]=y; nxt[e]=head[x]; head[x]=e;\n}\nvoid ae2(int x,int y){\n    to2[++e2]=y; nxt2[e2]=head2[x]; head2[x]=e2;\n}\nint fa[maxn][20],dep[maxn];\nvoid dfs(int u){\n    for(int i=1;i<20;i++) fa[u][i]=fa[fa[u][i-1]][i-1];\n    for(int i=head[u];i;i=nxt[i]){\n        int v=to[i];\n        if(v!=fa[u][0]){\n            fa[v][0]=u; dep[v]=dep[u]+1; dfs(v);\n        }\n    }\n}\nint lca(int u,int v){\n    if(dep[u]<dep[v]) swap(u,v);\n    for(int i=19;i>=0;i--) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];\n    if(u==v) return u;\n    for(int i=19;i>=0;i--) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];\n    return fa[u][0];\n}\nbool p[maxn];\nint ans;\nvoid dfs2(int u,int d,int f){\n    if(d>=dep[u]) return;\n    chkmax(ans,dep[u]<<1);\n    if(p[u]) cout<<-1<<endl,exit(0);\n    for(int i=head2[u];i;i=nxt2[i]){\n        int v=to2[i];\n        if(v!=f) dfs2(v,d+1,u);\n    }\n}\nint main(){\n    read(n); read(A); read(B);\n    for(int i=1;i<n;i++){\n        int u,v;\n        read(u); read(v);\n        ae2(u,v); ae2(v,u);\n\t\tE[i].u=u; E[i].v=v;\n    }\n    for(int i=1;i<n;i++){\n        int u,v;\n        read(u); read(v);\n        ae(u,v); ae(v,u);\n    }\n    dfs(B);\n\tfor(int i=1;i<n;i++) if(dep[E[i].u]+dep[E[i].v]-2*dep[lca(E[i].u,E[i].v)]>=3) p[E[i].u]=p[E[i].v]=1;\n    dfs2(A,0,0);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 20\nstruct {\n    vector<int> e[N];\n    int fa[N][M], d[N];\n    void dfs(int u) {\n        for (auto v : e[u]) {\n            if (v == fa[u][0]) continue;\n            fa[v][0] = u, d[v] = d[u] + 1;\n            for (int i = 1; i < M; i++) fa[v][i] = fa[fa[v][i - 1]][i - 1];\n            dfs(v);\n        }\n    }\n    void init(int n) {\n        for (int i = 1, u, v; i < n; i++) {\n            scanf(\"%d%d\", &u, &v);\n            e[u].push_back(v);\n            e[v].push_back(u);\n        }\n    }\n    int lca(int u, int v) {\n        if (d[u] < d[v]) swap(u, v);\n        for (int i = M - 1; ~i; i--)\n            if (d[fa[u][i]] >= d[v]) u = fa[u][i];\n        if (u == v) return u;\n        for (int i = M - 1; ~i; i--)\n            if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];\n        return fa[u][0];\n    }\n} ex, ey;\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    ex.init(n);\n    ey.init(n);\n    ex.dfs(addx);\n    ey.dfs(addy);\n    queue<int> que;\n    que.push(addx);\n    int ans = 0;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        if (ex.d[u] > ey.d[u]) continue;\n        int f = ex.fa[u][0], tmp = ey.lca(u, f);\n        if (ey.d[u] + ey.d[f] - 2 * ey.d[tmp] > 2) {\n            puts(\"-1\");\n            return 0;\n        }\n        ans = max(ans, ey.d[u] << 1);\n        for (auto v : ex.e[u])\n            if (v != f) que.push(v);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=200010,inf=1<<30;\nint N;\nstruct Edge{int to;Edge*next;};\nstruct Tree{\n\tint X,fa[MaxN],D[MaxN];\n\tEdge E[MaxN*2],*ne,*fir[MaxN];\n\tvoid link(int u,int v){*ne=(Edge){v,fir[u]};fir[u]=ne++;}\n\tvoid dfs(int i){\n\t\tfor(Edge*e=fir[i];e;e=e->next)if(e->to!=fa[i]){\n\t\t\tfa[e->to]=i;\n\t\t\tD[e->to]=D[i]+1;\n\t\t\tdfs(e->to);\n\t\t}\n\t}\n\tvoid read(){\n\t\tne=E;\n\t\tfor(int i=1;i<=N;i++)fir[i]=0;\n\t\tfor(int i=1,u,v;i<N;i++)scanf(\"%d%d\",&u,&v),link(u,v),link(v,u);\n\t\tdfs(X);\n\t}\n\tbool dis3(int x,int y){\n\t\tint d=0;\n\t\twhile(x!=y&&d<3)D[x]>D[y]?x=fa[x]:y=fa[y],d++;\n\t\treturn d==3;\n\t} \n}A,B;\nint dfs(int i){\n\tint res=B.D[i];\n\tfor(Edge*e=A.fir[i];e;e=e->next)if(e->to!=A.fa[i]){\n\t\tif(B.dis3(i,e->to))return inf;\n\t\tif(A.D[e->to]<B.D[e->to]){\n\t\t\tint tmp=dfs(e->to);\n\t\t\tif(tmp>res)res=tmp;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&A.X,&B.X);\n\tA.read();B.read();\n\tint ans=dfs(A.X);\n\tprintf(\"%d\\n\",ans==inf?-1:ans*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define endl '\\n'\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int INF = 1e9;\n\nint n, X, Y;\nvector <int> red_nb[N], blue_nb[N];\n\nint low[N], high[N], timer;\nint depth[N], par[N];\nvoid DFS_blue(int v)\n{\n    low[v] = high[v] = ++timer;\n    for(int u: blue_nb[v])\n    {\n        if(u != par[v])\n        {\n            depth[u] = depth[v] + 1;\n            par[u] = v;\n            DFS_blue(u);\n            high[v] = max(high[v], high[u]);\n        }\n    }\n}\n\nbool in_subtree(int u, int v)\n{\n    if(u == 0)\n        return false;\n    return (low[u] <= low[v] && high[u] >= low[v]);\n}\n\nbool far_blue(int u, int v)\n{\n    if(depth[u] > depth[v])\n        swap(u, v);\n    if(u == v || u == par[v] || u == par[par[v]])\n        return false;\n    if(depth[v] <= depth[u] + 2)\n        if(in_subtree(u, v))\n            return false;\n    if(depth[v] <= depth[u])\n        if(in_subtree(par[u], v))\n            return false;\n\n    return true;\n}\n\nbool special[N];\nint ans = 2, red_dist[N];\nvoid DFS_red(int v, int parent = -1)\n{\n    if(red_dist[v] > depth[v])\n        return;\n    ans = max(ans, depth[v] * 2);\n\n    if(red_dist[v] == depth[v])\n        return;\n    if(special[v])\n        ans = INF;\n\n    for(int u: red_nb[v])\n    {\n            if(u != parent)\n            {\n                red_dist[u] = red_dist[v] + 1;\n                DFS_red(u, v);\n            }\n    }\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n\n    int u, v;\n\n    cin >> n >> X >> Y;\n    for(int i = 1; i < n; i++)\n    {\n        cin >> u >> v;\n        red_nb[u].pb(v);\n        red_nb[v].pb(u);\n    }\n\n    for(int i = 1; i < n; i++)\n    {\n        cin >> u >> v;\n        blue_nb[u].pb(v);\n        blue_nb[v].pb(u);\n    }\n\n    DFS_blue(Y);\n\n    for(int i = 1; i <= n; i++)\n        for(int u: red_nb[i])\n            if(far_blue(u, i))\n                special[u] = special[i] = true;\n\n    DFS_red(X);\n\n\n    if(ans == INF)\n        cout << -1 << endl;\n    else\n        cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t200005\n#define MAXLOG\t20\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, x, y, u[MAXN], v[MAXN];\nint depth[MAXN], father[MAXN][MAXLOG];\nvector <int> a[MAXN], b[MAXN];\nbool mark[MAXN], visited[MAXN];\nvoid work(int pos, int fa) {\n\tdepth[pos] = depth[fa] + 1;\n\tfather[pos][0] = fa;\n\tfor (int i = 1; i < MAXLOG; i++)\n\t\tfather[pos][i] = father[father[pos][i - 1]][i - 1];\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (a[pos][i] != fa) work(a[pos][i], pos);\n}\nint lca(int x, int y) {\n\tif (depth[x] < depth[y]) swap(x, y);\n\tfor (int i = MAXLOG - 1; i >= 0; i--)\n\t\tif (depth[father[x][i]] >= depth[y]) x = father[x][i];\n\tif (x == y) return x;\n\tfor (int i = MAXLOG - 1; i >= 0; i--)\n\t\tif (father[x][i] != father[y][i]) {\n\t\t\tx = father[x][i];\n\t\t\ty = father[y][i];\n\t\t}\n\treturn father[x][0];\n}\nint dist(int x, int y) {\n\treturn depth[x] + depth[y] - 2 * depth[lca(x, y)];\n}\nvoid work(int pos, int fa, int step) {\n\tif (step >= depth[pos]) return;\n\tvisited[pos] = true;\n\tfor (unsigned i = 0; i < b[pos].size(); i++)\n\t\tif (b[pos][i] != fa) work(b[pos][i], pos, step + 1);\n}\nint main() {\n\tread(n), read(x), read(y);\n\tfor (int i = 1; i < n; i++)\n\t\tread(u[i]), read(v[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tdepth[0] = -1;\n\twork(y, 0);\n\tfor (int i = 1; i < n; i++)\n\t\tif (dist(u[i], v[i]) >= 3) mark[u[i]] = mark[v[i]] = true;\n\t\telse {\n\t\t\tb[u[i]].push_back(v[i]);\n\t\t\tb[v[i]].push_back(u[i]);\n\t\t}\n\twork(x, 0, 0);\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (visited[i]) if (mark[i]) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t} else ans = max(ans, depth[i] * 2);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=200005;\n\nint n,cnt,last[N],fa[N],dep[N],dis[N],q[N],dfn[N],mx[N],tim,a[N][2],sx,sy;\nbool vis[N],win[N];\nstruct edge{int to,next,col;}e[N*4];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid addedge(int u,int v,int col)\n{\n\te[++cnt].to=v;e[cnt].col=col;e[cnt].next=last[u];last[u]=cnt;\n\te[++cnt].to=u;e[cnt].col=col;e[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n\tdep[x]=dep[fa[x]]+1;dfn[x]=++tim;\n\tfor (int i=last[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa[x]) fa[e[i].to]=x,dfs(e[i].to);\n\tmx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n\tif (dfn[x]>dfn[y]) swap(x,y);\n\tif (dfn[x]<dfn[y]&&mx[x]>mx[y]) return dep[y]-dep[x]>2;\n\tif (fa[x]==fa[y]) return 0;\n\treturn 1;\n}\n\nvoid bfs()\n{\n\tint h=1,t=1;q[1]=sx;vis[sx]=1;\n\twhile (h<=t)\n\t{\n\t\tint x=q[h++];\n\t\tfor (int i=last[x];i;i=e[i].next)\n\t\t\tif (!e[i].col&&!vis[e[i].to])\n\t\t\t{\n\t\t\t\tdis[e[i].to]=dis[x]+1;\n\t\t\t\tif (dis[e[i].to]<dep[e[i].to]) vis[e[i].to]=1,q[++t]=e[i].to;\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();sx=read();sy=read();\n\tfor (int i=1;i<n;i++) a[i][0]=read(),a[i][1]=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\taddedge(x,y,1);\n\t}\n\tdfs(sy);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tif (check(a[i][0],a[i][1])) win[a[i][0]]=win[a[i][1]]=1;\n\t\telse addedge(a[i][0],a[i][1],0);\n\t}\n\tbfs();\n\tfor (int i=1;i<=n;i++) if (win[i]&&vis[i]) {puts(\"-1\");return 0;}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) if (vis[i]) ans=max(ans,dep[i]*2-2);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nint n,X,Y,f[N][20],dep[N],vis[N],ans;\n\nstruct graph{\n\tstruct edge{int s,t,n;}e[4*N];\n\tint h[N];\n\n\tvoid init()\n\t{\n\t\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t\t}\n\t}\t\n\n\tint dis(int x,int y)\n\t{\n\t\tint s=0;\n\t\tif (dep[x]>dep[y])  swap(x,y);\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (dep[f[y][i]]>=dep[x])\n\t\t\t\ty=f[y][i],s+=1<<i;\n\t\tif (x==y)  return s;\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (f[x][i]!=f[y][i])\n\t\t\t\tx=f[x][i],y=f[y][i],s+=2<<i;\n\t\treturn s+2;\n\t}\n\n\tbool dfs(int x,int fa)\n\t{\n\t\tint _=(x==X);\n\t\tf[x][0]=fa,dep[x]=dep[fa]+1,vis[x]=vis[0];\n\t\tfor (int i=1; i<20; i++)  f[x][i]=f[f[x][i-1]][i-1];\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((y!=fa)&&(dfs(y,x)))  _=1;\n\t\treturn _;\n\t}\n\n\tvoid mark()\n\t{\n\t\tfor (int i=h[Y],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif (vis[0]++,dfs(y,Y))  return;\n\t}\n\n\tvoid dfs2(int x,int tim)\n\t{\n\t\tans=max(ans,dep[x]),vis[x]++;\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((vis[y]==vis[0])&&(dep[y]>tim))\n\t\t\t\tdfs2(y,tim+1);\n\t}\n}A,B;\n\nvoid work()\n{\n\tscanf(\"%d %d %d\",&n,&X,&Y);\n\tA.init(),B.init(),B.mark(),A.dfs2(X,1);\n\tfor (int i=2; i<2*n; i+=2)\n\t\tif ((vis[A.e[i].s]>vis[0])||(vis[A.e[i].t]>vis[0]))\n\t\t\tif (B.dis(A.e[i].s,A.e[i].t)>2)\n\t\t\t\tputs(\"-1\"),exit(0);\n\tprintf(\"%d\",2*ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005;\nint n,x,y;\nstruct node{\n    int u,v,nxt;\n}B[N*2],R[N*2];\nint hB[N];\nint hR[N];\nint Bcnt,Rcnt;\nint eu[N],ev[N];\nvoid add_B(int u,int v){\n    Bcnt++;\n    B[Bcnt].u=u;\n    B[Bcnt].v=v;\n    B[Bcnt].nxt=hB[u];\n    hB[u]=Bcnt;\n}\nvoid add_R(int u,int v){\n    Rcnt++;\n    R[Rcnt].u=u;\n    R[Rcnt].v=v;\n    R[Rcnt].nxt=hR[u];\n    hR[u]=Rcnt;\n}\nint deep[N],fa[N];\nint dfn[N],efn[N],tot;\nvoid dfs(int u,int dep){\n    deep[u]=dep;\n    dfn[u]=++tot;\n    for(int i=hB[u];i;i=B[i].nxt){\n        int v=B[i].v;\n        if(v==fa[u])\n            continue;\n        fa[v]=u;\n        dfs(v,dep+1);\n    }\n    efn[u]=++tot;\n}\nbool check(int x,int y){//是否是长边\n    if(dfn[x]>dfn[y])\n        swap(x,y);\n    if(dfn[x]<=dfn[y]&&efn[y]<=efn[x])\n        return deep[y]-deep[x]>2;\n    return fa[x]!=fa[y];\n}\nbool Longedge[N];\nqueue<int>q;\nbool vis[N];\nint dist[N];\nvoid bfs(){\n    while(!q.empty())\n        q.pop();\n    vis[x]=1;\n    q.push(x);\n    while(!q.empty()){\n        int u=q.front();\n        q.pop();\n        for(int i=hR[u];i;i=R[i].nxt){\n            int v=R[i].v;\n            if(!vis[v]){\n                dist[v]=dist[u]+1;\n                if(dist[v]<deep[v]){\n                    vis[v]=1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    //freopen(\"captain.in\",\"r\",stdin);\n    //freopen(\"captain.out\",\"w\",stdout);\n    memset(hB,0,sizeof hB);\n    memset(hR,0,sizeof hR);\n    Bcnt=Rcnt=0;\n    memset(fa,0,sizeof fa);\n    tot=0;\n    memset(Longedge,0,sizeof Longedge);\n    memset(vis,0,sizeof vis);\n    memset(dist,0,sizeof dist);\n    scanf(\"%d%d%d\",&n,&x,&y);\n    for(int i=1;i<n;i++){\n        scanf(\"%d%d\",&eu[i],&ev[i]);\n    }\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add_B(u,v);\n        add_B(v,u);\n    }\n    dfs(y,0);\n    for(int i=1;i<n;i++){\n        int u=eu[i],v=ev[i];\n        if(check(u,v))\n            Longedge[u]=Longedge[v]=1;\n        else\n            add_R(u,v),add_R(v,u);\n    }\n    bfs();\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        if(vis[i]&&Longedge[i]){\n            puts(\"-1\");\n            return 0;\n        }\n        else\n            if(vis[i])\n                ans=max(ans,deep[i]*2);\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define per(i, a, b) for(int i = a; i >= b; i--)\ntypedef long long LL;\nconst int maxn = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\nint n, x, y, first[maxn], dep[maxn], s[maxn][2], f[maxn][27], g[maxn], dis[maxn], cnt;\nbool vis[maxn];\nstruct Edge {\n\tint to, next, ser;\n} e[maxn<<2];\n\nvoid Dfs(int u, int fa) {\n\tdep[u] = dep[fa] + 1;\n\tf[u][0] = fa;\n\tg[u] = dep[u];\n\tfor(int i = first[u]; i; i = e[i].next) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || e[i].ser) continue;\n\t\tDfs(v, u);\n\t\tg[u] = max(g[v], g[u]);\n\t}\n}\n\nvoid add(int u, int v, int ser) {\n\te[++cnt] = (Edge) {v, first[u], ser};\n\tfirst[u] = cnt;\n}\n\nint Lca(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tint dif = dep[u] - dep[v];\n\tper(i, 25, 0)\n\t    if(dif >= (1<<i)) {\n\t    \tdif -= 1<<i;\n\t    \tu = f[u][i];\n\t    }\n\tper(i, 25, 0)\n\t    if(f[u][i] != f[v][i]) {\n\t    \tu = f[u][i];\n\t    \tv = f[v][i];\n\t    }\n\treturn f[u][0];\n}\n\n\nbool Bfs(int s) {\n\tmemset(dis, 0x7f, sizeof(dis));\n\tqueue <int> q;\n\tdis[s] = 0;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = first[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\tif(!e[i].ser || dis[u] + 1 >= dep[v] || dis[u] + 1 >= dis[v]) continue;\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\trep(i, 1, n)\n\t    if(dis[i] < dep[i] && vis[i]) return 1;\n\treturn 0;\n}\n\nint main() {\n\tcin>>n>>x>>y;\n\tint u, v;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ts[i][0] = u, s[i][1] = v;\n\t}\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 0);\n\t\tadd(v, u, 0);\n\t}\n\tdep[0] = -1;\n\tDfs(y, 0);\n\trep(k, 1, 25)\n\t    rep(i, 1, n) \n\t        f[i][k] = f[f[i][k - 1]][k - 1];\n\trep(i, 1, n - 1) {\n\t\tint d = Lca(s[i][0], s[i][1]);\n\t\tif(dep[s[i][0]] + dep[s[i][1]] - 2*dep[d] > 2) vis[s[i][0]] = vis[s[i][1]] = 1;\n\t\telse {\n\t\t\tadd(s[i][0], s[i][1], 1);\n\t\t\tadd(s[i][1], s[i][0], 1);\n\t\t}\n\t} \n\tif(Bfs(x)) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\telse {\n\t\tint ans = 0;\n\t\trep(i, 1, n)\n\t\t    if(dis[i] < dep[i]) ans = max(ans, dep[i]);\n\t\tcout<<ans*2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nvector<int>A[210000];\nvector<int>B[210000];\nint num;\nint sz;\nint segtree[1048576];\nint conv[210000];\nint eu[420000];\nint ord[210000];\nint vis[210000];\nint dep[210000];\nvoid dfs(int a,int b){\n\tord[a]=num;\n\teu[sz++]=num;\n\tconv[num]=a;\n\tnum++;\n\tfor(int i=0;i<A[a].size();i++){\n\t\tif(A[a][i]==b)continue;\n\t\tdep[A[a][i]]=dep[a]+1;\n\t\tdfs(A[a][i],a);\n\t\teu[sz++]=ord[a];\n\t}\n}\nint query(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return 1000000007;\n\tif(c<=a&&b<=d)return segtree[e];\n\treturn min(query(a,(a+b)/2,c,d,e*2),query((a+b)/2+1,b,c,d,e*2+1));\n}\nvoid update(int a,int b){\n\ta+=524288;\n\twhile(a){\n\t\tsegtree[a]=min(segtree[a],b);\n\t\ta/=2;\n\t}\n}\nint ap[210000];\nint goal[210000];\n\nint da[210000];\nint db[210000];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);b--;c--;\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tB[p].push_back(q);\n\t\tB[q].push_back(p);\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tA[p].push_back(q);\n\t\tA[q].push_back(p);\n\t}\n\tdfs(0,-1);\n\tfor(int i=0;i<1048576;i++)segtree[i]=1000000007;\n\t//for(int i=0;i<sz;i++)printf(\"%d\\n\",eu[i]);\n\tfor(int i=0;i<sz;i++)update(i,eu[i]);\n\tfor(int i=0;i<sz;i++)ap[eu[i]]=i;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<B[i].size();i++){\n\t\t\tint lca=conv[query(0,524287,min(ap[ord[i]],ap[ord[B[i][j]]]),max(ap[ord[i]],ap[ord[B[i][j]]]),1)];\n\t\t\tint dist=dep[i]+dep[B[i][j]]-dep[lca]*2;\n\t\t//\tprintf(\"%d %d %d %d\\n\",i,B[i][j],query(0,524287,min(ord[i],ord[B[i][j]]),max(ord[i],ord[B[i][j]]),1),lca);\n\t\t\tif(dist>2)goal[i]=goal[B[i][j]]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)da[i]=db[i]=-1;\n\tda[c]=0;\n\tdb[b]=0;\n\tqueue<int>Q;\n\tQ.push(c);\n\twhile(Q.size()){\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<A[at].size();i++){\n\t\t\tif(!~da[A[at][i]]){\n\t\t\t\tda[A[at][i]]=da[at]+1;\n\t\t\t\tQ.push((A[at][i]));\n\t\t\t}\n\t\t}\n\t}\n\tQ.push(b);\n\twhile(Q.size()){\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<B[at].size();i++){\n\t\t\tif(!~db[B[at][i]]){\n\t\t\t\tdb[B[at][i]]=db[at]+1;\n\t\t\t\tQ.push((B[at][i]));\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<a;i++)printf(\"%d %d\\n\",da[i],db[i]);\n\tint ret=da[b]*2;\n\tQ.push(b);\n\tvis[b]=1;\n\twhile(Q.size()){\n\t\tint at=Q.front();Q.pop();\n\t\tfor(int i=0;i<B[at].size();i++){\n\t\t\tif(vis[B[at][i]])continue;\n\t\t\tint to=B[at][i];\n\t\t\tif(da[to]==db[to])ret=max(ret,da[to]*2);\n\t\t\tif(da[to]>db[to]){\n\t\t\t\tvis[to]=1;\n\t\t\t\tret=max(ret,da[to]*2);\n\t\t\t\tif(goal[to])ret=999999999;\n\t\t\t\tQ.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tif(ret>9999999)ret=-1;\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e5+10;\nint n,x,y,ans,vis[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nstruct Heavy_Light_Decomposition{\n    struct edge{int to,nxt;}e[maxn<<1];int tot,head[maxn];\n    int idx,fa[maxn],dfn[maxn],dep[maxn],son[maxn],top[maxn],size[maxn];\n    void add(int u,int v){e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;}\n    void insert(int u,int v){add(u,v);add(v,u);}\n    void build(int x){\n        dep[x]=dep[fa[x]]+1;size[x]=1;int mx=0;\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to){\n            if(v==fa[x])continue;\n            fa[v]=x;build(v);size[x]+=size[v];\n            if(size[v]>mx)mx=size[v],son[x]=v;\n        }\n    }\n    void dfs(int x){\n        if(!x)return ;dfn[x]=++idx;\n        top[x]=son[fa[x]]==x?top[fa[x]]:x;\n        dfs(son[x]);\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)\n            if(v!=fa[x]&&v!=son[x])dfs(v);\n    }\n    int query(int u,int v){\n        while(top[u]!=top[v]){\n            if(dep[top[u]]<dep[top[v]])swap(u,v);\n            u=fa[top[u]];\n        }if(dep[u]>dep[v])swap(u,v);\n        return u;\n    }\n    int get_dis(int u,int v){return dep[u]+dep[v]-2*dep[query(u,v)];}\n}HLD[2];\nvoid init(int S){\n    queue<int >q;\n    q.push(S);vis[S]=1;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(!vis[v]&&HLD[0].dep[v]<HLD[1].dep[v])vis[v]=1,q.push(v);\n    }\n}\nvoid solve(){\n    for(int x=1;x<=n;x++){\n        if(!vis[x])continue;\n        ans=max(ans,HLD[1].dep[x]-1);\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(HLD[1].get_dis(v,x)>2){puts(\"-1\");return ;}\n    }write(ans<<1);\n}\nint main(){\n    n=read();x=read();y=read();\n    if(x==y){puts(\"0\");return 0;}\n    for(int i=1;i<n;i++)HLD[0].insert(read(),read());\n    for(int i=1;i<n;i++)HLD[1].insert(read(),read());\n    HLD[0].build(x);HLD[0].dfs(x);HLD[1].build(y);HLD[1].dfs(y);\n    init(x);solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\nusing namespace std;\n\nconst int N=2e5+100;\nint n,x,y;\n\nstruct Tree{\n\tint n,cnt,head[N],clk,dep[N],in[N],out[N],lg[N<<1],q[N<<1],st[N<<1][22];\n\tstruct edge{int to,nxt;}e[N<<1];\n\tvoid adde(int x,int y){\n\t\te[++cnt].to=y; e[cnt].nxt=head[x]; head[x]=cnt;\n\t}\n\tvoid dfs(int u,int par){\n\t\tin[u]=++clk; q[clk]=u;\n\t\tfor (int i=head[u],v;i;i=e[i].nxt)\n\t\t\tif (v=e[i].to,v!=par)\n\t\t\t\tdep[v]=dep[u]+1,dfs(v,u),q[++clk]=u;\n\t\tout[u]=clk;\n\t}\n\tinline bool isanc(int x,int y){return in[x]<=in[y]&&out[y]<=out[x];}\n\tinline int Min(int x,int y){return dep[x]<dep[y]?x:y;}\n\tvoid st_init(){\n\t\trep (i,1,clk) st[i][0]=q[i],lg[i]=i==1?0:lg[i>>1]+1;\n\t\trep (j,1,20)\n\t\t\tfor (int i=1;i+(1<<j-1)<=clk;i++)\n\t\t\t\tst[i][j]=Min(st[i][j-1],st[i+(1<<j-1)][j-1]);\n\t}\n\tvoid init(int _n){\n\t\tn=_n; cnt=clk=0; memset(head,0,n+1<<2);\n\t\trep (i,1,n-1){\n\t\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t\tadde(x,y); adde(y,x);\n\t\t}\n\t\tdfs(1,0),st_init();\n\t}\n\tinline int lca(int x,int y){\n\t\tif (in[x]>in[y]) swap(x,y);\n\t\tif (isanc(x,y)) return x;\n\t\tx=out[x],y=in[y]; int t=lg[y-x+1];\n\t\treturn Min(st[x][t],st[y-(1<<t)+1][t]);\n\t}\n\tinline int dis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\n}T1,T2;\n\nbool vis[N];\n\nvoid bfs(int s){ //bfs出x能先到达的点\n\tqueue<int> q; q.push(s),vis[s]=1; int ans=0;\n\twhile (!q.empty()){\n\t\tint u=q.front(); q.pop();\n\t\tans=max(ans,T2.dis(u,y));\n\t\tfor (int i=T1.head[u],v;i;i=T1.e[i].nxt){\n\t\t\tv=T1.e[i].to;\n\t\t\tif (T2.dis(u,v)>2){puts(\"-1\"); exit(0);}\n\t\t\tif (!vis[v]&&T1.dis(x,v)<T2.dis(y,v))\n\t\t\t\tvis[v]=1,q.push(v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans<<1);\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tT1.init(n),T2.init(n);\n\tbfs(x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nvector <int> y[N];\nll h1[N],h2[N];\nll par[N];\nvoid dfsg(ll v,ll p,ll h){\n    h1[v]=h;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfsg(u,v,h+1);\n    }\n}\nvoid dfsy(ll v,ll p,ll h){\n    h2[v]=h;\n    par[v]=p;\n    for (auto u : y[v]){\n        if (u==p) continue;\n        dfsy(u,v,h+1);\n    }\n}\nll check(ll u,ll v){\n    if (par[u]==par[v] || u==par[v] || v==par[u] || v==par[par[u]] || u==par[par[v]]) return 0;\n    return 1;\n}\nll dp[N];\nvoid dfs(ll v,ll p){\n    if (h1[v]>=h2[v]) return ;\n    dp[v]=h2[v]-h1[v];\n    dp[v]*=2;\n    for (auto u : g[v]){\n        if (p==u) continue;\n        dfs(u,v);\n        dp[v]=max(dp[v],dp[u]+2);\n        if (check(u,v)) dp[v]=1e9;\n    }\n}\nint32_t main(){\n    ll n,x,y1;\n    cin >> n >> x >> y1;\n    for (int i=0;i<n-1;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    for (int i=0;i<n-1;i++){\n        ll u,v;\n        cin >> u >> v;\n        y[u].pb(v);\n        y[v].pb(u);\n    }\n    dfsg(x,x,1);\n    dfsy(y1,y1,1);\n    dfs(x,x);\n    if (dp[x]>=1e9) kill(-1);\n    kill(dp[x]);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N, X, Y;\n\nvvll g;\nvvll h;\n\nvll par;\nvll ht;\n\nvoid dfsh(ll u, ll v) {\n\tpar[v] = u;\n\tht[v] = ht[u] + 1;\n\t\n\tfor (ll w : h[v]) {\n\t\tif (u == w) { continue; }\n\t\tdfsh(v, w);\n\t}\n\treturn;\n}\n\n\nint main(){\n\t\n\tcin >> N >> X >> Y;\n\tg.resize(N + 1);\n\th.resize(N + 1);\n\trepn(i, N - 1) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\trepn(i, N - 1) {\n\t\tll c, d;\n\t\tcin >> c >> d;\n\t\th[c].push_back(d);\n\t\th[d].push_back(c);\n\t}\n\n\tpar.assign(N + 1, 0);\n\tht.assign(N + 1, -1);\n\tdfsh(0, Y);\n\t//repn(v, N)cout << par[v] << ht[v] << endl;\n\n\n\tvll win(N + 1, 0);\n\trepn(v, N) {\n\t\tfor (ll w : g[v]) {\n\t\t\tbool b = 1;\n\t\t\tif (par[w] == v || par[v] == w) { b = 0; }\n\t\t\tif (par[par[w]] == v || par[v] == par[w] || par[par[v]] == w) { b = 0; }\n\t\t\tif (b) { win[v] = 1; break; }\n\t\t}\n\n\t\t//cout << v << win[v] << endl;\n\t}\n\n\tset<pair<ll, ll>> st;\n\tvll lis;\n\tvll vis(N + 1, 0);\n\n\tst.insert({ ht[X],X });\n\tvis[X] = 1;\n\tlis.push_back(X);\n\n\n\tll tern = 0;\n\twhile (!st.empty()) {\n\t\tvll nlis;\n\n\t\tfor (ll v : lis) {\n\t\t\tif (!st.count({ ht[v],v })) { continue; }\n\n\t\t\tfor (ll w : g[v]) {\n\t\t\t\tif (vis[w] == 1) { continue; }\t\t\t\t\n\t\t\t\tif (ht[w] == tern) { continue; }\n\n\t\t\t\tnlis.push_back(w);\n\t\t\t\tst.insert({ ht[w],w });\n\t\t\t\tvis[w] = 1;\n\n\t\t\t\tif (win[w] == 1) { cout << -1 << endl; return 0; }\n\t\t\t}\n\t\t}\n\n\t\tlis = nlis;\n\t\twhile (!st.empty()&&(*st.begin()).first <= tern + 1) {\n\t\t\tst.erase(st.begin());\n\t\t}\n\t\t\n\t\ttern++;\n\t\n\t}\n\n\tcout << tern * 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nint _max(int x, int y) {return x > y ? x : y;}\nconst int N = 200001;\nconst int mod = 924844033;\nint read() {\n\tint s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\nvoid put(int x) {\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint x, y, next;\n} e[2 * N]; int len, last[N];\nint id, ll[N], rr[N], dep[N];\nint xx[N], yy[N], fa[N];\nbool v1[N], v2[N];\n\nvoid ins(int x, int y) {\n\te[++len].x = x, e[len].y = y;\n\te[len].next = last[x], last[x] = len;\n}\n\nvoid dfs1(int x) {\n\tll[x] = ++id;\n\tfor(int k = last[x]; k; k = e[k].next) {\n\t\tint y = e[k].y;\n\t\tif(y != fa[x]) fa[y] = x, dep[y] = dep[x] + 1, dfs1(y);\n\t} rr[x] = ++id;\n}\n\nvoid dfs2(int x, int fa, int d) {\n\tif(d >= dep[x]) return ;\n\tv2[x] = 1;\n\tfor(int k = last[x]; k; k = e[k].next) {\n\t\tint y = e[k].y;\n\t\tif(y != fa) {\n\t\t\tdfs2(y, x, d + 1);\n\t\t}\n\t}\n}\n\nbool check(int x, int y) {\n\tif(ll[x] > ll[y]) swap(x, y);\n\tif(ll[x] < ll[y] && rr[y] < rr[x]) return dep[y]- dep[x] > 2;\n\treturn fa[x] != fa[y];\n}\n\nint main() {\n\tint n = read(), x = read(), y = read();\n\tfor(int i = 1; i < n; i++) xx[i] = read(), yy[i] = read();\n\tfor(int i = 1; i < n; i++) {\n\t\tint x = read(), y = read();\n\t\tins(x, y), ins(y, x);\n\t} dfs1(y);\n\tlen = 0; memset(last, 0, sizeof(last));\n\tfor(int i = 1; i < n; i++) {\n\t\tif(check(xx[i], yy[i])) v1[xx[i]] = v1[yy[i]] = 1;\n\t\tins(xx[i], yy[i]), ins(yy[i], xx[i]);\n\t} dfs2(x, 0, 0);\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(v1[i] && v2[i]) {puts(\"-1\"); return 0;}\n\t\tif(v2[i]) ans = _max(ans, dep[i] * 2);\n\t} put(ans), puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010, MP = 20;\nint n,stx,sty;\nstruct edge {\n  int la,b;\n};\nstruct tree {\n  edge con[N << 1];\n  int tot,fir[N];\n  void add(int from,int to) {\n    con[++tot] = (edge) {fir[from],to};\n    fir[from] = tot;\n  }\n  int dep[N],anc[N][MP];\n  void dfs(int pos,int fa) {\n    dep[pos] = dep[fa] + 1;\n    anc[pos][0] = fa;\n    for (int i = 1 ; i < MP ; ++ i) {\n      anc[pos][i] = anc[anc[pos][i-1]][i-1];\n      if (!anc[pos][i]) break;\n    }\n    for (int i = fir[pos] ; i ; i = con[i].la) {\n      if (con[i].b == fa) continue;\n      dfs(con[i].b,pos);\n    }\n  }\n  int lca(int x,int y) {\n    if (dep[x] < dep[y]) swap(x,y);\n    for (int i = MP - 1 ; i >= 0 ; -- i)\n      if (dep[anc[x][i]] >= dep[y])\n\tx = anc[x][i];\n    if (x == y) return x;\n    for (int i = MP - 1 ; i >= 0 ; -- i)\n      if (anc[x][i] != anc[y][i])\n\tx = anc[x][i], y = anc[y][i];\n    return anc[x][0];\n  }\n  int askdis(int x,int y) {\n    int z = lca(x,y);\n    return dep[x] + dep[y] - 2 * dep[z];\n  }\n  void fsd(int pos,int fa,int dep);\n} rd,blu;\nint ans;\nvoid tree::fsd(int pos,int fa,int dep) {\n  if (ans != -1) ans = max(ans,blu.askdis(pos,sty) * 2);\n  if (dep >= blu.askdis(pos,sty))\n    return;\n  for (int i = fir[pos] ; i ; i = con[i].la) {\n    if (con[i].b == fa) continue;\n    if (blu.askdis(pos,con[i].b) >= 3) {\n      ans = -1;\n      return;\n    }\n    fsd(con[i].b,pos,dep+1);\n  }\n}\nint main() {\n  int x,y;\n  scanf(\"%d%d%d\",&n,&stx,&sty);\n  for (int i = 1 ; i < n ; ++ i) {\n    scanf(\"%d%d\",&x,&y);\n    rd.add(x,y);\n    rd.add(y,x);\n  }\n  for (int i = 1 ; i < n ; ++ i) {\n    scanf(\"%d%d\",&x,&y);\n    blu.add(x,y);\n    blu.add(y,x);\n  }\n  blu.dfs(1,0);\n  rd.fsd(stx,0,0);\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 21\nvector<int> ex[N], ey[N];\nvoid init(int n, vector<int>* e) {\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n}\nint fx[N], fy[N][M], dx[N], dy[N];\nvoid dfsy(int u) {\n    for (auto v : ey[u]) {\n        if (v == fy[u][0]) continue;\n        fy[v][0] = u, dy[v] = dy[u] + 1;\n        for (int i = 1; i < M; i++) fy[v][i] = fy[fy[v][i - 1]][i - 1];\n        dfsy(v);\n    }\n}\nint lca(int u, int v) {\n    if (dy[u] < dy[v]) swap(u, v);\n    for (int i = M - 1; ~i; i--)\n        if (dy[fy[u][i]] >= dy[v]) u = fy[u][i];\n    if (u == v) return u;\n    for (int i = M - 1; ~i; i--)\n        if (fy[u][i] != fy[v][i]) u = fy[u][i], v = fy[v][i];\n    return fy[u][0];\n}\nint ans;\nvoid dfsx(int u) {\n    if (~ans) ans = max(ans, dy[u] << 1);\n    for (auto v : ex[u]) {\n        if (v == fx[u]) continue;\n        fx[v] = u, dx[v] = dx[u] + 1;\n        if (dx[v] >= dy[v]) continue;\n        if (dy[v] + dy[u] - 2 * dy[lca(u, v)] > 2) ans = -1;\n        dfsx(v);\n    }\n}\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    init(n, ex);\n    init(n, ey);\n    dfsy(addy);\n    dfsx(addx);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int maxn=2e5;\nint n,x,y,tot;\nint pre[maxn*4+8],son[maxn*4+8];\nbool can[maxn+8];\nqueue<int>st;\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nstruct Tree\n{\n    int now[maxn+8],dep[maxn+8],f[maxn+8][20];\n    void add(int u,int v)\n    {\n    pre[++tot]=now[u];\n    now[u]=tot;\n    son[tot]=v;\n    }\n    void build(int x)\n    {\n    dep[x]=dep[f[x][0]]+1;\n    for (int i=1;i<=log(dep[x])/log(2);i++) f[x][i]=f[f[x][i-1]][i-1];\n    for (int p=now[x];p;p=pre[p])\n        {\n        int child=son[p];\n        if (f[x][0]==child) continue;\n        f[child][0]=x;\n        build(child);\n        }\n    }\n    int Get_Lca(int x,int y)\n    {\n    if (dep[x]<dep[y]) swap(x,y);\n    for (int i=log(dep[x])/log(2);~i;i--)\n        if (dep[f[x][i]]>=dep[y]) x=f[x][i];\n    if (x==y) return x;\n    for (int i=log(dep[x])/log(2);~i;i--)\n        if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n    return f[x][0];\n    }\n    int Get_Dis(int x,int y){return dep[x]+dep[y]-dep[Get_Lca(x,y)]*2;}\n}T1,T2;\n \nvoid solve()\n{\n    //for (int i=1;i<=n;i++) printf(\"%d \",can[i]);puts(\"\");\n    int ans=0;\n    for (int i=1;i<=n;i++)\n    if (can[i])\n        {\n        ans=max(ans,T2.dep[i]-1);\n        for (int p=T1.now[i];p;p=pre[p])\n            {\n            int child=son[p];\n            if (T2.Get_Dis(child,i)>2)\n                {\n                puts(\"-1\");\n                exit(0);\n                }\n            }\n        }\n    printf(\"%d\\n\",ans*2);\n}\n \nvoid prepare()\n{\n    can[x]=1;\n    st.push(x);\n    while(!st.empty())\n    {\n        int x=st.front();st.pop();\n        for (int p=T1.now[x];p;p=pre[p])\n        {\n            int child=son[p];\n            if (can[child]) continue;\n            if (T1.dep[child]<T2.dep[child]) can[child]=1,st.push(child);\n        }\n    }\n}\n \nint main()\n{\n    n=read(),x=read(),y=read();\n    if (x==y)\n    {\n        puts(\"0\");\n        return 0;\n    }\n    for (int i=1;i<n;i++)\n    {\n        int u=read(),v=read();\n        T1.add(u,v),T1.add(v,u);\n    }\n    for (int i=1;i<n;i++)\n    {\n        int u=read(),v=read();\n        T2.add(u,v),T2.add(v,u);\n    }\n    T1.build(x),T2.build(y);\n    prepare();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=1e6+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint fa[N],dep[N],X,Y,res,n;\nvector<int>er[N],eb[N];\nvoid dfsb(int x){\n\tre(i,0,eb[x].size())if(eb[x][i]!=fa[x]){\n\t\tfa[eb[x][i]]=x,dep[eb[x][i]]=dep[x]+1;\n\t\tdfsb(eb[x][i]);\n\t}\n}\nint ok(int x,int y){\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=1;i<=2&&x!=y;i++)\n\t\tif(dep[x]<dep[y])y=fa[y];else x=fa[x];\n\treturn x==y;\n}\nvoid dfsr(int x,int f,int dis){\n\tgmax(res,dep[x]);\n\tif(dep[x]<=dis)return;\n\tre(i,0,er[x].size())if(er[x][i]!=f){\n\t\tif(!ok(x,er[x][i])){puts(\"-1\");exit(0);}\n\t\tdfsr(er[x][i],x,dis+1);\n\t}\n}\nint main(){\n\tread(n,X,Y);\n\tre(i,1,n){int x,y;read(x,y);er[x].pb(y);er[y].pb(x);}\n\tre(i,1,n){int x,y;read(x,y);eb[x].pb(y);eb[y].pb(x);}\n\tdfsb(Y);\n\tdfsr(X,0,0);\n\tcout<<res*2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=2e5+10;\n\nstruct Edge{ int to,next; }way[N<<1];\n\nint n,X,Y,a[N],b[N],tot,num[N],dep[N],dis[N],f[N];\nbool t[N],vis[N];\n\nvoid Build(int a,int b) { way[++tot]=(Edge){b,num[a]}; num[a]=tot; }\n\nvoid EdgeClear()\n{\n\ttot=0;\n\tfor (int i=1;i<=n;++i) num[i]=0;\n}\n\nvoid Init()\n{\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor (int i=2;i<=n;++i)\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\tint x,y;\n\tfor (int i=2;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tBuild(x,y); Build(y,x);\n\t}\n}\n\nvoid Dfs(int x,int fa)\n{\n\tdep[x]=dep[fa]+1; f[x]=fa;\n\tfor (int i=num[x];i;i=way[i].next)\n\t{\n\t\tint v=way[i].to;\n\t\tif (v==fa) continue;\n\t\tDfs(v,x);\n\t}\n}\n\nqueue<int>Q;\nvoid Bfs(int s)\n{\n\tdis[s]=0; Q.push(s); vis[s]=1;\n\twhile (!Q.empty())\n\t{\n\t\tint u=Q.front(); Q.pop();\t\n\t\tfor (int i=num[u];i;i=way[i].next)\n\t\t{\n\t\t\tint v=way[i].to;\n\t\t\tif (vis[v]) continue;\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tif (dis[v]<dep[v]) { vis[v]=1; Q.push(v); }\n\t\t}\n\t}\n}\n\nvoid Solve()\n{\n\tdep[0]=-1; Dfs(Y,0);\n\t\n\tEdgeClear();\n\tfor (int i=2;i<=n;++i)\n\t{\n\t\tint x=a[i],y=b[i];\n\t\tif (dep[x]>dep[y]) swap(x,y);\n\t\t\n\t\tbool fl=1;\n\t\tif (f[y]==x || f[f[y]]==x || f[x]==f[y]) fl=0;else fl=1;\n\t\t\n\t\tif (fl) t[x]=t[y]=1;\n\t\telse Build(x,y),Build(y,x);\n\t}\n\t\n\tBfs(X);\n\t\n\tint ans=0;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tif (t[i] && vis[i]) { printf(\"-1\\n\"); return ; }\n\t\tif (vis[i]) ans=max(ans,dep[i]);\n\t}\n\tprintf(\"%d\\n\",ans<<1);\n}\n\nint main()\n{\n\tInit();\n\tSolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200100\nusing namespace std;\nvector<int>R[maxn],B[maxn];\nint ans,fa[maxn],dep[maxn],n,x,y,s[maxn];\nvoid dfs(int u,int f){\n\tdep[u]=dep[fa[u]=f]+1;\n\tfor(int i=0;i<B[u].size();++i)if(B[u][i]!=f)\n\t\tdfs(B[u][i],u);\n}\nint gd(int u,int v){\n\tif(dep[u]<dep[v])swap(u,v);\n\tint d=dep[u]-dep[v];\n\twhile(dep[u]>dep[v]&&d<=2)u=fa[u];\n\twhile(u!=v&&d<=2)u=fa[u],v=fa[v],d+=2;\n\treturn min(d,3);\n}\nvoid dfs2(int u,int f){\n\tif(f&&gd(u,f)>=3)s[u]=s[f]=1;\n\tfor(int i=0;i<R[u].size();++i)if(R[u][i]!=f)\n\t\tdfs2(R[u][i],u);\n}\nvoid sol(int u,int f,int len){\n\tif(dep[u]<=len)return ;\n\tans=max(ans,len);\n\tif(s[u])printf(\"-1\"),exit(0);\n\tsol(u,u,len+1);\n\tfor(int i=0;i<R[u].size();++i)//if(R[u][i]!=f)\n\t\tsol(R[u][i],u,len+1);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tR[u].push_back(v),\n\t\tR[v].push_back(u);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tB[u].push_back(v),\n\t\tB[v].push_back(u);\n\tdfs(y,0),dfs2(x,0),sol(x,0,0);\n\tprintf(\"%d\",ans<<1);\n\n}"
  },
  {
    "language": "C++",
    "code": "//BadWaper gg\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<set>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define N 200010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint n,A,B;\nint p[N],q[N];\nint fa[N][21],dist[N],deep[N];\nstruct edge\n{\n\tint next,to,p;\n}e[N<<1];\nint head[N],cnt,win[N],vis[N];\nqueue<int>Q;\ninline void add_edge(int from,int to,int p){e[++cnt]=(edge){head[from],to,p};head[from]=cnt;}\nvoid dfs(int now,int father)\n{\n\tdeep[now]=deep[father]+1;fa[now][0]=father;\n\tfor(register int i=1;i<=20;i++)fa[now][i]=fa[fa[now][i-1]][i-1];\n\tfor(register int i=head[now];i;i=e[i].next)\n\t{\n\t\tif(e[i].to==father)continue;\n\t\tdfs(e[i].to,now);\n\t}\n}\nvoid bfs()\n{\n\tQ.push(A);vis[A]=1;dist[A]=1;vis[B]=1;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(register int i=head[x];i;i=e[i].next)\n\t\t{\n\t\t\tif(e[i].p&&!vis[e[i].to])\n\t\t\t{\n\t\t\t\tdist[e[i].to]=dist[x]+1;//cout<<\"WTF:\"<<e[i].to<<\" \"<<deep[e[i].to]<<\" \"<<dist[e[i].to]<<endl;\n\t\t\t\tif(dist[e[i].to]<deep[e[i].to]){vis[e[i].to]=1;Q.push(e[i].to);}\n\t\t\t}\n\t\t}\n\t}\n}\ninline int lca(int u,int v)\n{\n\tif(deep[u]<deep[v])swap(u,v);\n\tfor(register int i=20;i>=0;i--)if(deep[fa[u][i]]>=deep[v])u=fa[u][i];\n\tif(u==v)return u;\n\tfor(register int i=20;i>=0;i--)\n\t{\n\t\tif(fa[u][i]!=fa[v][i])\n\t\t{\n\t\t\tu=fa[u][i],v=fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\ninline int Dist(int x,int y){return deep[x]+deep[y]-2*deep[lca(x,y)];}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),A=read(),B=read();\n\tfor(register int i=1;i<n;i++)p[i]=read(),q[i]=read();\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y,0);add_edge(y,x,0);\n\t}\n\tdfs(B,0);\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tif(Dist(p[i],q[i])>=3)win[p[i]]=win[q[i]]=1;\n\t\telse add_edge(p[i],q[i],1),add_edge(q[i],p[i],1);\n\t}\n\tbfs();\n\tint ans=0;\n\tfor(register int i=1;i<=n;i++)if(win[i]&&vis[i]&&i!=B){puts(\"-1\");return 0;}\n\tfor(register int i=1;i<=n;i++)ans=max(ans,dist[i]<<1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=200010;\nvector<int> G1[maxn],G2[maxn];\nint n,x,y,st[maxn],en[maxn],cnt;\nint anc[maxn][20],dep[maxn],yes[maxn];\nint swim(int x,int k) {dwn(i,19,0) if(k>>i&1) x=anc[x][i];return x;}\nint move(int x,int y) {\n\tif(x==y) return x;\n\tif(st[y]>=st[x]&&st[y]<=en[x]) return swim(y,dep[y]-dep[x]-1);\n\treturn anc[x][0];\n}\nint dist(int x,int y) {\n\tint ans=dep[x]+dep[y];\n\tif(dep[x]<dep[y]) swap(x,y);\n\tdwn(i,19,0) if((1<<i)<=dep[x]-dep[y]) x=anc[x][i];\n\tdwn(i,19,0) if(anc[x][i]!=anc[y][i]) x=anc[x][i],y=anc[y][i];\n\treturn ans-2*dep[x==y?x:anc[x][0]];\n}\nvoid dfs(int x,int fa) {\n\tst[x]=++cnt;dep[x]=dep[anc[x][0]=fa]+1;\n\trep(i,1,19) anc[x][i]=anc[anc[x][i-1]][i-1];\n\trep(i,0,G2[x].size()-1) {\n\t\tint v=G2[x][i];\n\t\tif(v==fa) continue;\n\t\tdfs(v,x);\n\t}\n\ten[x]=cnt;\n}\npii Q[maxn];\nint d[maxn],vis[maxn],l,r;\nint solve(int x,int y) {\n\tif(x==y) return 0;\n\tQ[l=r=1]=mp(x,y);\n\tint mx=0;vis[x]=1;\n\twhile(l<=r) {\n\t\tpii c=Q[l++];mx=max(mx,d[c.xx]+dist(c.xx,c.yy));\n\t\tif(yes[c.xx]) return -1;\n\t\trep(i,0,G1[c.xx].size()-1) {\n\t\t\tint v=G1[c.xx][i],u=move(c.yy,v);\n\t\t\tif(!vis[v]&&u!=v) {\n\t\t\t\tvis[v]=1;d[v]=d[c.xx]+1;\n\t\t\t\tQ[++r]=mp(v,u);\n\t\t\t}\n\t\t}\n\t}\n\treturn mx*2;\n}\nint main() {\n\tn=read();x=read();y=read();\n\trep(i,2,n) {\n\t\tint a=read(),b=read();\n\t\tG1[a].pb(b);G1[b].pb(a);\n\t}\n\trep(i,2,n) {\n\t\tint a=read(),b=read();\n\t\tG2[a].pb(b);G2[b].pb(a);\n\t}\n\tdfs(1,0);\n\trep(x,1,n) rep(i,0,G1[x].size()-1) if(dist(x,G1[x][i])>=3) {yes[x]=1;break;}\n\tprintf(\"%d\\n\",solve(x,y));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\t   c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nvector<int> to[2][MAXN];\nint fa[MAXN][20],dep[MAXN];\nint N,X,Y,ans;\nbool flag = 0;\nint lca(int u,int v) {\n    if(dep[u] < dep[v]) swap(u,v);\n    int l = 18;\n    while(dep[u] > dep[v]) {\n        if(dep[fa[u][l]] >= dep[v]) {\n            u = fa[u][l];\n        }\n        --l;\n    }\n    if(u == v) return u;\n    l = 18;\n    while(fa[u][0] != fa[v][0]) {\n        if(fa[u][l] != fa[v][l]) {\n            u = fa[u][l];\n            v = fa[v][l];\n        }\n        --l;\n    }\n    return fa[u][0];\n}\nint dist(int u,int v) {\n    return dep[u] + dep[v] - 2 * dep[lca(u,v)];\n}\nvoid dfs(int u) {\n    for(auto t : to[1][u]) {\n        if(t != fa[u][0]) {\n            dep[t] = dep[u] + 1;\n            fa[t][0] = u;\n            dfs(t);\n        }\n    }\n}\nvoid dfs1(int u,int f,int d) {\n    if(u == Y) return;\n    ans = max(ans,dep[u] - 1);\n    for(auto t : to[0][u]) {\n        if(t == f) continue;\n        if(dist(u,t) > 2) flag = 1;\n        if(d + 1 < dep[t] - 1) dfs1(t,u,d + 1);\n    }\n}\nvoid Solve() {\n    read(N);read(X);read(Y);\n    int a,b;\n    for(int i = 1 ; i < N ; ++i) {\n        read(a);read(b);\n        to[0][a].pb(b);to[0][b].pb(a);\n    }\n    for(int i = 1 ; i < N ; ++i) {\n        read(a);read(b);\n        to[1][a].pb(b);to[1][b].pb(a);\n    }\n    dep[Y] = 1;\n    dfs(Y);\n    for(int j = 1 ; j <= 19 ; ++j) {\n        for(int i = 1 ; i <= N ; ++i) {\n            fa[i][j] = fa[fa[i][j - 1]][j - 1];\n        }\n    }\n    dfs1(X,0,0);\n    if(flag) {puts(\"-1\");}\n    else {out(2 * ans);enter;}\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n \nstruct node { int t,next; }a[400010],a1[400010];\n \nint fa[200010],son[200010],top[200010],dep[200010],dfn[200010],pid[200010],size[200010];\nint head[200010],head1[200010],dep1[200010],f[200010],n,s1,s2,cl,ans,tot,tot1;\nbool flag;\n \ninline int rd()\n{\n    int x=0;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar());\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x;\n}\n \ninline void add(int x,int y) { a[++tot].t=y;a[tot].next=head[x];head[x]=tot; }\n \ninline void add1(int x,int y) { a1[++tot1].t=y;a1[tot1].next=head1[x];head1[x]=tot1; }\n \ninline int lca(int x,int y)\n{\n    for (;top[x]!=top[y];x=fa[top[x]]) if (dep[top[x]]<dep[top[y]]) swap(x,y);\n    if (dep[x]>dep[y]) swap(x,y);\n    return x;\n}\n \ninline int get_dis(int x,int y) { return dep[x]+dep[y]-dep[lca(x,y)]*2; }\n \ninline int up(int x,int y)\n{\n    for (;dep[x]-dep[top[x]]+1<=y;x=fa[top[x]]) y-=dep[x]-dep[top[x]]+1;\n    return pid[dfn[x]-y];\n}\n \ninline int work(int x,int y)\n{\n    int hh=lca(x,y);\n    if (hh!=x) return fa[x];\n    return up(y,dep[y]-dep[x]-1);\n}\n \ninline void dfs1(int x)\n{\n    size[x]=1;\n    for (int i=head[x];i;i=a[i].next)\n    {\n        int t=a[i].t;\n        if (t==fa[x]) continue;\n        dep[t]=dep[x]+1;\n        fa[t]=x;dfs1(t);\n        size[x]+=size[t];\n        if (size[t]>size[son[x]]) son[x]=t;\n    }\n}\n \ninline void dfs2(int x,int tp)\n{\n    dfn[x]=++cl;pid[cl]=x;top[x]=tp;\n    if (son[x]) dfs2(son[x],tp);\n    for (int i=head[x];i;i=a[i].next)\n    {\n        int t=a[i].t;\n        if (t==fa[x]||t==son[x]) continue;\n        dfs2(t,t);\n    }\n}\n \ninline void dfs(int x,int y)\n{\n    for (int i=head1[x];i;i=a1[i].next)\n    {\n        int t=a1[i].t;\n        if (t==y) continue;\n        int hh=get_dis(x,t);\n        if (hh>2&&x!=f[x]) { flag=true;return; }\n        if (t==f[x]|x==f[x]) continue;\n        f[t]=work(f[x],t);\n        dep1[t]=dep1[x]+1;\n        dfs(t,x);\n        if (flag) return;\n    }\n    ans=max(ans,(get_dis(f[x],x)+dep1[x])<<1);\n}\n \nint main()\n{\n    n=rd();s1=rd();s2=rd();\n    if (s1==s2) { puts(\"0\");return 0; }\n    tot=tot1=0;\n    for (int i=1;i<n;i++) { int x=rd(),y=rd();add1(x,y);add1(y,x); }\n    for (int i=1;i<n;i++) { int x=rd(),y=rd();add(x,y);add(y,x); }\n    cl=0;dfs1(s2);dfs2(s2,s2);\n    f[s1]=s2;ans=0;flag=false;dfs(s1,0);\n    if (!flag) printf(\"%d\\n\",ans);\n    else puts(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nP dp[200005];\nint lca[200005][18],dist2[200005];\nint calc(int x,int y){\n\tif(dist2[x] > dist2[y]) swap(x,y);\n\trep(i,18){\n\t\tif((((dist2[y]-dist2[x])>>i)&1)){\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\tfor(int i=17;i>=0;i--){\n\t\tif(lca[x][i] != lca[y][i]){\n\t\t\tx = lca[x][i];\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\treturn lca[x][0];\n}\nbool fe;\nint go(int a,int b){\n\tint c = calc(a,b);\n\tif(a == c){\n\t\tfor(int i=0;i<18;i++){\n\t\t\tif((((dist2[b]-dist2[a]-1)>>i)&1)){\n\t\t\t\tb = lca[b][i];\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\telse{\n\t\treturn lca[a][0];\n\t}\n}\nint ret = 0;\nvoid dfs(int v,int u,int d){\n\tif(dp[v].fi > 0){\n\t\tret = max(ret,2*d);\n\t}\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint D = dist2[v]+dist2[edge[v][i]]-2*dist2[calc(v,edge[v][i])];\n\t\tif(D>=3 && lca[edge[v][i]][0] != dp[v].sc && lca[dp[v].sc][0] != edge[v][i]){\n\t\t\tfe = 1;\n\t\t}\n\t\telse {\n\t\t\tD = dist2[edge[v][i]]+dist2[dp[v].sc]-2*dist2[calc(edge[v][i],dp[v].sc)];\n\t\t\tif(D<=1){\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(0,edge[v][i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(D-1,go(dp[v].sc,edge[v][i])));\n\t\t\t}\n\t\t}\n\t\tdfs(edge[v][i],v,d+1);\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d; lca[v][0] = u;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs2(b,-1,0);\n\tdp[a] = mp(dist2[a],b);\n\tfor(int j=0;j<17;j++) for(int i=1;i<=n;i++){\n\t\tif(lca[i][j] == -1) lca[i][j+1] = -1;\n\t\telse lca[i][j+1] = lca[lca[i][j]][j];\n\t}\n\tdfs(a,-1,0);\n\tif(fe) puts(\"-1\");\n\telse cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int,int> ii;\ntypedef pair<ii,int> iii;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define RST(i,n) memset(i,n,sizeof i)\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(),a.end()\n#define X first\n#define Y second\n#define eb emplace_back\n#ifdef cold66\n#define debug(...) do{\\\n    fprintf(stderr,\"LINE %d: (%s) = \",__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#endif // cold66\n//}\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\n\nconst ll MAXn=2e5+5,MAXlg=__lg(MAXn)+2;\nconst ll MOD=1000000007;\nconst ll INF=0x3f3f3f3f;\n\nint n,X,Y;\nint ans = 0;\nvector<int> r[MAXn],b[MAXn];\nint ancb[MAXlg][MAXn],depb[MAXn];\nvoid dfsb(int x,int p){\n    if (x != p) depb[x] = depb[p] + 1;\n    ancb[x][0] = p;\n    for (int i=1;1<<i < MAXn;++i) {\n        ancb[x][i] = ancb[ancb[x][i-1]][i-1];\n    }\n    for (auto i:b[x]) {\n        if (i == p) continue;\n        dfsb(i,x);\n    }\n}\nint LCA(int x,int y){\n    if (depb[x] < depb[y]) {\n        swap(x,y);\n    }\n    for (int i=MAXlg;i>=0;--i) {\n        if (((depb[x] - depb[y])>>i)&1) {\n            x = ancb[x][i];\n        }\n    }\n    if (x == y) return x;\n    for (int i=MAXlg;i>=0;--i) {\n        if (ancb[x][i] != ancb[y][i]) {\n            x = ancb[x][i];\n            y = ancb[y][i];\n        }\n    }\n    return ancb[x][0];\n}\nint dis(int x,int y){\n    int lca = LCA(x,y);\n    return depb[x] + depb[y] - 2 * depb[lca];\n}\nvoid dfsr(int x,int p,int d){\n    debug(x,p,d,depb[x]);\n    ans = max(ans,depb[x]*2);\n    for (auto i:r[x]) {\n        if (i == p) continue;\n        if (dis(x,i) >= 3) {\n            ans = INF;\n            break;\n        }\n        if (d + 1 < depb[i]) {\n            dfsr(i,x,d+1);\n        }\n    }\n}\nint main(){\n    IOS();\n    cin >> n >> X >> Y;\n    for (int i=0;i<n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        r[u].eb(v);\n        r[v].eb(u);\n    }\n    for (int i=0;i<n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        b[u].eb(v);\n        b[v].eb(u);\n    }\n    dfsb(Y,Y);\n    dfsr(X,X,0);\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N], dfn;\nint dp[N << 1][20], lg2[N], dph[N];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x])\n        if (y != fx) dfsb(y, x);\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] >= db[x]) return;\n    if (~ans) ans = max((db[x] - 1) << 1, ans);\n    for (int y : a[x]) {\n        if (db[x] + db[y] - 2 * db[LCA(x, y)] > 2) ans = -1;\n        if (y != fx) dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define PB push_back\n#define SZ(c) int((c).size())\n#define ALL(c) (c).begin(), (c).end()\n#define CONTAINS(c, x) ((c).find(x) != (c).end())\n#define REP(i, n) for(int i=1; i<=n; i++)\n#define WAIT cout<<flush, system(\"PAUSE\");\nusing namespace std;\nconst int MAX = 200100;\n\nint N, A, B, u, v;\nset<int> E[MAX], F[MAX];\nint D[MAX], P[MAX], sol;\nbool ok[MAX], used[MAX], escape;\n\nvoid DFS(int n){\n\tfor(auto x: F[n]) if (x!=P[n]){\n\t\tP[x] = n;\n\t\tD[x] = D[n] + 1;\n\t\tDFS(x);\n\t}\n}\n\nvoid DFS2(int n, int d){\n\tif (D[n] <= d) return;\n\tused[n] = true;\n\tsol = max(sol, D[n]);\n\tif (ok[n]) escape = true;\n\t\n\tfor(auto x: E[n]) if (!used[x]){\n\t\tDFS2(x, d+1);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> N >> A >> B;\n\tREP(I, N-1){\n\t\tcin >> u >> v;\n\t\tE[u].insert(v);\n\t\tE[v].insert(u);\n\t}\n\t\n\tREP(I, N-1){\n\t\tcin >> u >> v;\n\t\tF[u].insert(v);\n\t\tF[v].insert(u);\n\t}\n\t\n\tP[B] = D[B] = 0;\n\tDFS(B);\n\t\n\tREP(u, N) for(auto v: E[u])\n\tif (CONTAINS(F[u], v) || CONTAINS(F[v], u) || CONTAINS(F[ P[u] ], v) || CONTAINS(F[ P[v] ], u))\n\t\t;\n\telse ok[u] = ok[v] = true;\n\t\n\t//REP(I, N) if (ok[I]) cout << I << \" \";\n\t//cout << endl;\n\t//REP(I, N) cout << D[I] << \" \";\n\t//cout << endl;\n\t\n\tDFS2(A, 0);\n\tif (escape) sol = -1;\n\telse        sol *= 2;\n\tcout << sol << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//BadWaper gg\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<set>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define N 500010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint n,A,B;\nint p[N],q[N];\nint fa[N][21],dist[N],deep[N];\nstruct edge\n{\n\tint next,to,p;\n}e[N<<1];\nint head[N],cnt,win[N],vis[N];\nqueue<int>Q;\ninline void add_edge(int from,int to,int p){e[++cnt]=(edge){head[from],to,p};head[from]=cnt;}\nvoid dfs(int now,int father)\n{\n\tdeep[now]=deep[father]+1;fa[now][0]=father;\n\tfor(register int i=1;i<=20;i++)fa[now][i]=fa[fa[now][i-1]][i-1];\n\tfor(register int i=head[now];i;i=e[i].next)\n\t{\n\t\tif(e[i].to==father)continue;\n\t\tdfs(e[i].to,now);\n\t}\n}\nvoid bfs()\n{\n\tQ.push(A);vis[A]=1;dist[A]=1;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(register int i=head[x];i;i=e[i].next)\n\t\t{\n\t\t\tif(e[i].p&&!vis[e[i].to])\n\t\t\t{\n\t\t\t\tdist[e[i].to]=dist[x]+1;\n\t\t\t\tif(dist[e[i].to]<deep[e[i].to]){vis[e[i].to]=1;Q.push(e[i].to);}\n\t\t\t}\n\t\t}\n\t}\n}\ninline int lca(int u,int v)\n{\n\tif(deep[u]<deep[v])swap(u,v);\n\tfor(register int i=20;i>=0;i--)if(deep[fa[u][i]]>=deep[v])u=fa[u][i];\n\tif(u==v)return u;\n\tfor(register int i=20;i>=0;i--)\n\t{\n\t\tif(fa[u][i]!=fa[v][i])\n\t\t{\n\t\t\tu=fa[u][i],v=fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\ninline int Dist(int x,int y){return deep[x]+deep[y]-2*deep[lca(x,y)];}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),A=read(),B=read();\n\tfor(register int i=1;i<n;i++)p[i]=read(),q[i]=read();\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y,0);add_edge(y,x,0);\n\t}\n\tdfs(B,0);\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tif(Dist(p[i],q[i])>=3)win[p[i]]=win[q[i]]=1;\n\t\telse add_edge(p[i],q[i],1),add_edge(q[i],p[i],1);\n\t}\n\tbfs();\n\tint ans=0;\n\tfor(register int i=1;i<=n;i++)if(win[i]&&vis[i]){puts(\"-1\");return 0;}\n\tfor(register int i=1;i<=n;i++)if(vis[i])ans=max(ans,(deep[i]-1)<<1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define AL(n) new int [(n) + 1]\n#define FR(x) if (x) delete [] x;\n\nstruct tree {\n\tint V, E, root;\n\tint *to, *first, *next, *p, *dep;\n\n\ttree () : V(0), E(0), root(0), to(NULL), first(NULL), next(NULL), p(NULL), dep(NULL) {}\n\t~tree () {FR(to) FR(first) FR(next) FR(p) FR(dep)}\n\n\tinline int dmin(const int x, const int y) {return dep[x] < dep[y] ? x : y;}\n\n\tinline void addedge(int u, int v) {\n\t\tto[++E] = v, next[E] = first[u], first[u] = E;\n\t\tto[++E] = u, next[E] = first[v], first[v] = E;\n\t}\n\n\tvoid dfs(int x) {\n\t\tint i, y;\n\t\tfor (i = first[x]; i; i = next[i])\n\t\t\tif ((y = to[i]) != p[x]) p[y] = x, dep[y] = dep[x] + 1, dfs(y);\n\t}\n\n\tinline bool check_two(int x, int y) {return p[x] == y || p[y] == x || p[p[x]] == y || p[p[y]] == x || p[x] == p[y];}\n\n\tvoid init(int V_, int root_) {\n\t\tint i, u, v; V = V_, E = 0, root = root_;\n\t\tto = AL(2 * (V - 1)), first = AL(V), next = AL(2 * (V - 1));\n\t\tmemset(first, 0, (V + 1) << 2);\n\t\tfor (i = 1; i < V; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v);\n\t\tp = AL(V), dep = AL(V), p[root] = dep[root] = 0, dfs(root);\n\t\tfor (i = 1; i <= V; ++i)\n\t\t\tfor (to[ u = first[i] ] == p[i] && (u = first[i] = next[u]); u; u = next[u])\n\t\t\t\tif (to[ next[u] ] == p[i]) next[u] = next[ next[u] ];\n\t}\n} R, B;\n\nconst int N = 200054;\n\nint n, X, Y, ans = 0;\nbool key[N];\n\ninline void up(int &x, const int y) {x < y ? x = y : 0;}\n\nvoid play(int x, int lim) {\n\tif (B.dep[x] <= lim) return;\n\tup(ans, key[x] ? INT_MAX : B.dep[x]);\n\tfor (int i = R.first[x]; i; i = R.next[i])\n\t\tplay(R.to[i], lim + 1);\n}\n\nint main() {\n\tint i;\n\tscanf(\"%d%d%d\", &n, &X, &Y);\n\tR.init(n, X), B.init(n, Y);\n\tfor (i = 1; i <= n; ++i)\n\t\tif (!(i == X || B.check_two(i, R.p[i]))) key[i] = key[R.p[i]] = true;\n\tplay(X, 0);\n\tprintf(\"%d\\n\", ans < INT_MAX ? ans * 2 : -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e5;\nint n,x,y,tot;\nint pre[maxn*4+8],son[maxn*4+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nstruct Tree\n{\n    int now[maxn+8],dep[maxn+8],f[maxn+8][20];\n    void add(int u,int v)\n    {\n\tpre[++tot]=now[u];\n\tnow[u]=tot;\n\tson[tot]=v;\n    }\n    void build(int x)\n    {\n\tdep[x]=dep[f[x][0]]+1;\n\tfor (int i=1;i<=log(dep[x])/log(2);i++) f[x][i]=f[f[x][i-1]][i-1];\n\tfor (int p=now[x];p;p=pre[p])\n\t    {\n\t\tint child=son[p];\n\t\tif (f[x][0]==child) continue;\n\t\tf[child][0]=x;\n\t\tbuild(child);\n\t    }\n    }\n    int Get_Lca(int x,int y)\n    {\n\tif (dep[x]<dep[y]) swap(x,y);\n\tfor (int i=log(dep[x])/log(2);~i;i--)\n\t    if (dep[f[x][i]]>=dep[y]) x=f[x][i];\n\tif (x==y) return x;\n\tfor (int i=log(dep[x])/log(2);~i;i--)\n\t    if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n\treturn f[x][1];\n    }\n    int Get_Dis(int x,int y){return dep[x]+dep[y]-dep[Get_Lca(x,y)]*2-1;}\n}T1,T2;\n\nvoid check()\n{\n    for (int i=1;i<=n;i++)\n\tif (T1.Get_Dis(i,x)<T2.Get_Dis(i,y))\n\t    for (int p=T1.now[i];p;p=pre[p])\n\t\t{\n\t\t    int child=son[p];\n\t\t    if (T2.Get_Dis(child,i)>2)\n\t\t\t{\n\t\t\t    puts(\"-1\");\n\t\t\t    exit(0);\n\t\t\t}\n\t\t}\n}\n\nint main()\n{\n    n=read(),x=read(),y=read();\n    for (int i=1;i<n;i++)\n\t{\n\t    int u=read(),v=read();\n\t    T1.add(u,v),T1.add(v,u);\n\t}\n    for (int i=1;i<n;i++)\n\t{\n\t    int u=read(),v=read();\n\t    T2.add(u,v),T2.add(v,u);\n\t}\n    T1.build(x),T2.build(y);\n    check();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\nusing namespace std;\n\nconst int N=2e5+100;\nint n,x,y;\n\nstruct Tree{\n\tint n,cnt,head[N],clk,dep[N],in[N],out[N],lg[N<<1],q[N<<1],st[N<<1][22];\n\tstruct edge{int to,nxt;}e[N<<1];\n\tvoid adde(int x,int y){\n\t\te[++cnt].to=y; e[cnt].nxt=head[x]; head[x]=cnt;\n\t}\n\tvoid dfs(int u,int par){\n\t\tin[u]=++clk; q[clk]=u;\n\t\tfor (int i=head[u],v;i;i=e[i].nxt)\n\t\t\tif (v=e[i].to,v!=par)\n\t\t\t\tdep[v]=dep[u]+1,dfs(v,u),q[++clk]=u;\n\t\tout[u]=clk;\n\t}\n\tinline bool isanc(int x,int y){return in[x]<=in[y]&&out[y]<=out[x];}\n\tinline int Min(int x,int y){return dep[x]<dep[y]?x:y;}\n\tvoid st_init(){\n\t\trep (i,1,clk) st[i][0]=q[i],lg[i]=i==1?0:lg[i>>1]+1;\n\t\trep (j,1,18)\n\t\t\tfor (int i=1;i+(1<<j-1)<=clk;i++)\n\t\t\t\tst[i][j]=Min(st[i][j-1],st[i+(1<<j-1)][j-1]);\n\t}\n\tvoid init(int _n){\n\t\tn=_n; cnt=clk=0; memset(head,0,n+1<<2);\n\t\trep (i,1,n-1){\n\t\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t\tadde(x,y); adde(y,x);\n\t\t}\n\t\tdfs(1,0),st_init();\n\t}\n\tinline int lca(int x,int y){\n\t\tif (in[x]>in[y]) swap(x,y);\n\t\tif (isanc(x,y)) return x;\n\t\tx=out[x],y=in[y]; int t=lg[y-x+1];\n\t\treturn Min(st[x][t],st[y-(1<<t)+1][t]);\n\t}\n\tinline int dis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\n}T1,T2;\n\nbool vis[N];\n\nvoid bfs(int s){ //bfs出x能先到达的点\n\tqueue<int> q; q.push(s),vis[s]=1; int ans=0;\n\twhile (!q.empty()){\n\t\tint u=q.front(); q.pop();\n\t\tans=max(ans,T2.dis(u,y));\n\t\tfor (int i=T1.head[u],v;i;i=T1.e[i].nxt){\n\t\t\tv=T1.e[i].to;\n\t\t\tif (!vis[v]&&T1.dis(x,v)<T2.dis(y,v)){\n\t\t\t\tif (T2.dis(u,v)>2){puts(\"-1\"); exit(0);}\n\t\t\t\tvis[v]=1,q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans<<1);\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tT1.init(n),T2.init(n);\n\tbfs(x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n\tvector<vector<int> > g;\n\tconst int MAX_LOG = 22;\n\tvector<vector<int> > lcc;\n\tvector<int> dep;\n\tvector<int> myr;\nprivate:\n\tvoid init2(){\n\t\tint n = g.size();\n\t\tfor (int i = 0; i + 1 < MAX_LOG; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (lcc[i][j] == -1){\n\t\t\t\t\tlcc[i + 1][j] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlcc[i + 1][j] = lcc[i][lcc[i][j]];\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tint lca(int a, int b){\n\t\tif (dep[a] < dep[b]){\n\t\t\tswap(a, b);\n\t\t}\n\t\tfor (int i = 0; i < MAX_LOG; i++){\n\t\t\tif (((dep[a] - dep[b]) >> i) & 1){\n\t\t\t\ta = lcc[i][a];\n\t\t\t}\n\t\t}\n\t\tif (a == b){\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = MAX_LOG - 1; i >= 0; i--){\n\t\t\tif (lcc[i][a] != lcc[i][b]){\n\t\t\t\ta = lcc[i][a];\n\t\t\t\tb = lcc[i][b];\n\t\t\t}\n\t\t}\n\t\treturn lcc[0][a];\n\t}\nprivate:\n\tint flag_r;\n\tinline void dfs(int b, int pr = -1, int d = 0){\n\t\tfor (auto &i : g[b]){\n\t\t\tif (i == pr)continue;\n\t\t\tdfs(i, b, d + 1);\n\t\t}\n\t\tdep[b] = d;\n\t\tlcc[0][b] = pr;\n\t\tmyr[b] = flag_r;\n\t}\npublic:\n\n\tvoid init(vector<vector<int> > &tree, int root = 0){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tflag_r = root;\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tdfs(root);\n\t\tinit2();\n\t}\n\tvoid init(vector<vector<int> > &tree, vector<int> &root){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tfor (int &i : root){\n\t\t\tif (myr[i] == -1){\n\t\t\t\tflag_r = i;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t}\n\tint dist(int a, int b){ \n\t\tif (myr[a] != myr[b]){\n\t\t\treturn -1;\n\t\t}\n\t\tint lc = lca(a, b);\n\t\treturn dep[a] + dep[b] - 2 * dep[lc];\n\t}\n};\n\n#define MAX 200002\n\nint n;\n\nint x;\nint y;\n\nvector<vector<int> > sigma;\nvector<vector<int> > sugim;\n\nLCA sigmaL;\nLCA sugimL;\nLCA sigmaLL;\n\nbool win[MAX];\n\nvector<vector<int> > vv;\nqueue<int> q;\nvector<int> ord;\nbool vis[MAX];\n\nint main(){\n\tcin >> n;\n\tcin >> x >> y;\n\tsigma.resize(n,vector<int>());\n\tsugim = sigma; \n\tvv = sigma;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsigma[a].push_back(b);\n\t\tsigma[b].push_back(a);\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsugim[a].push_back(b);\n\t\tsugim[b].push_back(a);\n\t}\n\tx--;\n\ty--;\n\tsugimL.init(sugim,y);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int &j : sigma[i]){\n\t\t\tif (i > j)continue;\n\t\t\tint d = sugimL.dist(i, j);\n\t\t\tif (d > 2){\n\t\t\t\twin[i] = true;\n\t\t\t\twin[j] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint ll = sugimL.lca(i, j);\n\t\t\t\tif (ll != i&&ll != j){\n\t\t\t\t\tvv[i].push_back(ll);\n\t\t\t\t\tvv[ll].push_back(i);\n\t\t\t\t\tvv[j].push_back(ll);\n\t\t\t\t\tvv[ll].push_back(j);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i].push_back(j);\n\t\t\t\t\tvv[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvis[y] = true;\n\tq.push(y);\n\twhile (!q.empty()){\n\t\tint b = q.front();\n\t\tq.pop();\n\t\tfor (int &i : sugim[b]){\n\t\t\tif (!vis[i]){\n\t\t\t\tvis[i] = true;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tord.push_back(b);\n\t}\n\tsigmaL.init(vv, ord);\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i]){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (sigmaL.myr[a] != sigmaL.myr[b]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tif (tim == -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\tsigmaLL.init(sigma, y);\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i] == false){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (sigmaL.myr[a] != sigmaL.myr[b]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaLL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tint cost = sigmaLL.dist(a, b);\n\t\t\tif (tim > tim2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim == tim2){\n\t\t\t\tif (b == lc){\n\t\t\t\t\tans = max(ans, cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tans = max(ans, cost + tim2 - tim);\n\t\t\t}\n\t\t}\n\t}\n\tcout << 2*ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#define N (400000+1000)\nusing namespace std;\n\nstruct edge{int to,next;}edge[N<<1];\nint Father[N],Depth[N],Dfn[N],Low[N];\nint n,x,y,S1,S2,cnt,ans,u[N],v[N];\nint head[N],num_edge;\n\nvoid add(int u,int v)\n{\n\tedge[++num_edge].to=v;\n\tedge[num_edge].next=head[u];\n\thead[u]=num_edge;\n}\n\nbool check(int x,int y)\n{\n\tif (Dfn[x]>Dfn[y]) swap(x,y);\n\tif (Low[x]>=Low[y])\n\t\treturn (Depth[y]-Depth[x])>2;\n\treturn Father[x]!=Father[y];\n}\n\nvoid Dfs1(int x)\n{\n\tDfn[x]=++cnt; Depth[x]=Depth[Father[x]]+1;\n\tfor (int i=head[x]; i; i=edge[i].next)\n\t\tif (edge[i].to!=Father[x])\n\t\t{\n\t\t\tFather[edge[i].to]=x;\n\t\t\tDfs1(edge[i].to);\n\t\t}\n\tLow[x]=++cnt;\n}\n\nvoid Dfs2(int x,int fa,int k)\n{\n\tans=max(ans,Depth[x]-1);\n\tif (Depth[x]<=k) return;\n\tfor (int i=head[x]; i; i=edge[i].next)\n\t{\n\t\tif (check(x,edge[i].to)) puts(\"-1\"),exit(0);\n\t\tDfs2(edge[i].to,x,k+1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&S1,&S2);\n\tfor (int i=1; i<=n-1; ++i)\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\tfor (int i=1; i<=n-1; ++i)\n\t\tscanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tDfs1(S2); \n\tmemset(head,0,sizeof(head)); num_edge=0;\n\tfor (int i=1; i<=n-1; ++i) add(u[i],v[i]),add(v[i],u[i]);\n\tDfs2(S1,-1,1);\n\tprintf(\"%d\\n\",ans<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 入力\nint N, P, Q;\nint A[1 << 18], B[1 << 18];\nint C[1 << 18], D[1 << 18];\nvector<int> X[1 << 18];\nvector<int> Y[1 << 18];\n\n// LCA\nint par[1 << 18][22];\n\n// その他\nint dist1[1 << 18];\nint dist2[1 << 18];\nbool rakuen[1 << 18];\nbool used[1 << 18];\n\nvoid dfs1(int pos, int dep) {\n\tdist1[pos] = dep;\n\tfor (int i : X[pos]) {\n\t\tif (dist1[i] != -1) continue;\n\t\tdfs1(i, dep + 1);\n\t}\n}\n\nvoid dfs2(int pos, int dep) {\n\tdist2[pos] = dep;\n\tfor (int i : Y[pos]) {\n\t\tif (dist2[i] != -1) continue;\n\t\tdfs2(i, dep + 1);\n\t\tpar[i][0] = pos;\n\t}\n}\n\nvoid dfs3(int pos, int pre) {\n\tused[pos] = true;\n\tfor (int i : X[pos]) {\n\t\tif (i == pre) continue;\n\t\tif (dist1[i] >= dist2[i]) continue;\n\t\tdfs3(i, pos);\n\t}\n}\n\nint prevs(int u, int x) {\n\tfor (int i = 21; i >= 0; i--) {\n\t\tif (x >= (1 << i)) { x -= (1 << i); u = par[u][i]; }\n\t}\n\treturn u;\n}\n\nint lca(int u, int v) {\n\tif (dist2[u] > dist2[v]) swap(u, v);\n\tv = prevs(v, dist2[v] - dist2[u]);\n\tif (u == v) return u;\n\n\tfor (int i = 21; i >= 0; i--) {\n\t\tif (par[u][i] != par[v][i]) { u = par[u][i]; v = par[v][i]; }\n\t}\n\treturn par[u][0];\n}\n\nint getdst(int u, int v) {\n\tint w = lca(u, v);\n\treturn dist2[u] + dist2[v] - 2 * dist2[w];\n}\n\nint main() {\n\tcin >> N >> P >> Q;\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tX[A[i]].push_back(B[i]);\n\t\tX[B[i]].push_back(A[i]);\n\t}\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> C[i] >> D[i];\n\t\tY[C[i]].push_back(D[i]);\n\t\tY[D[i]].push_back(C[i]);\n\t}\n\tfor (int i = 1; i <= N; i++) dist1[i] = -1;\n\tfor (int i = 1; i <= N; i++) dist2[i] = -1;\n\tdfs1(P, 0);\n\tdfs2(Q, 0);\n\tdfs3(P, -1);\n\n\tfor (int i = 1; i <= 21; i++) {\n\t\tfor (int j = 1; j <= N; j++) par[j][i] = par[par[j][i - 1]][i - 1];\n\t}\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tif (getdst(A[i], B[i]) <= 2) continue;\n\t\trakuen[A[i]] = true;\n\t\trakuen[B[i]] = true;\n\t}\n\n\tint Answer = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (used[i] == true && rakuen[i] == true) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (used[i] == true) Answer = max(Answer, dist2[i] * 2);\n\t}\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define MAXN 200010\n#define INF 0x3f3f3f3f\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint Bdj[MAXN],Vb[MAXN*2],nxtb[MAXN*2],cb;\nvoid Add(int u,int v)\n{\n\tcb++;Vb[cb]=v,nxtb[cb]=Bdj[u];Bdj[u]=cb;\n}\nint n,rt,s,ans;\nint dep[MAXN],fa[MAXN],e[MAXN][2],lon[MAXN],vis[MAXN];\nvoid dfs(int u)\n{\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=fa[u])\n\t\t{\n\t\t\tdep[V[i]]=dep[u]+1;\n\t\t\tfa[V[i]]=u;\n\t\t\tdfs(V[i]);\n\t\t}\n}\nint dis[MAXN];\nqueue<int>Q;\nvoid bfs()\n{\n\tdis[s]=0;\n\tvis[s]=1;\n\tQ.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=Bdj[u];i;i=nxtb[i])\n\t\t\tif(!vis[Vb[i]])\n\t\t\t{\n\t\t\t\tdis[Vb[i]]=dis[u]+1;\n\t\t\t\tif(dis[Vb[i]]<dep[Vb[i]])\n\t\t\t\t{\n\t\t\t\t\tvis[Vb[i]]=1;\n\t\t\t\t\tQ.push(Vb[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\nint check(int u,int v)\n{\n\tif(dep[u]<dep[v]) swap(u,v);\n\tint k=dep[u]-dep[v];\n\tif(k==0) return fa[u]!=fa[v];\n\tif(k==1) return fa[u]!=v;\n\tif(k==2) return fa[fa[u]]!=v;\n\treturn 1;\n}\nvoid Clear()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tAdj[i]=Bdj[i]=vis[i]=lon[i]=0;\n\tc=cb=0;\n\tans=0;\n}\nvoid Read(int &x)\n{\n\tx=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n}\nint main()\n{\n//\tfreopen(\"coalesce.in\",\"r\",stdin);\n//\tfreopen(\"coalesce.out\",\"w\",stdout);\n\tscanf(\"%d%d%d\",&n,&s,&rt);\n\tint u,v,flag=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tRead(e[i][0]);\n\t\tRead(e[i][1]);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tRead(u);Read(v);\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tdfs(rt);\n\tfor(int i=1;i<n;i++)\n\t\tif(check(e[i][0],e[i][1]))\n\t\t\tlon[e[i][0]]=lon[e[i][1]]=1;\n\t\telse Add(e[i][0],e[i][1]),Add(e[i][1],e[i][0]);\n\tbfs();\n\tfor(int i=1;i<=n;i++)\n\t\tif(vis[i]&&lon[i])\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\telse if(vis[i])\n\t\t\tans=max(ans,dep[i]);\n\tif(flag) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define MAXN 200010\n#define INF 0x3f3f3f3f\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint Bdj[MAXN],Vb[MAXN*2],nxtb[MAXN*2],cb;\nvoid Add(int u,int v)\n{\n\tcb++;Vb[cb]=v,nxtb[cb]=Bdj[u];Bdj[u]=cb;\n}\nint n,rt,s,ans;\nint dep[MAXN],fa[MAXN],e[MAXN][2],lon[MAXN],vis[MAXN];\nvoid dfs(int u)\n{\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=fa[u])\n\t\t{\n\t\t\tdep[V[i]]=dep[u]+1;\n\t\t\tfa[V[i]]=u;\n\t\t\tdfs(V[i]);\n\t\t}\n}\nint dis[MAXN];\nqueue<int>Q;\nvoid bfs()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tdis[i]=-1;\n\tdis[s]=0;\n\tQ.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tif(dis[u]<dep[u])\n\t\t\tvis[u]=1;\n\t\tfor(int i=Bdj[u];i;i=nxtb[i])\n\t\t\tif(dis[Vb[i]]==-1)\n\t\t\t{\n\t\t\t\tdis[Vb[i]]=dis[u]+1;\n\t\t\t\tQ.push(Vb[i]);\n\t\t\t}\n\t}\n}\nint check(int u,int v)\n{\n\tif(dep[u]<dep[v]) swap(u,v);\n\tint k=dep[u]-dep[v];\n\tif(k==0) return fa[u]!=fa[v];\n\tif(k==1) return fa[u]!=v;\n\tif(k==2) return fa[fa[u]]!=v;\n\treturn 1;\n}\nvoid Clear()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tAdj[i]=Bdj[i]=vis[i]=lon[i]=0;\n\tc=cb=0;\n\tans=0;\n}\nvoid Read(int &x)\n{\n\tx=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n}\nint main()\n{\n//\tfreopen(\"coalesce.in\",\"r\",stdin);\n//\tfreopen(\"coalesce.out\",\"w\",stdout);\n\twhile((scanf(\"%d%d%d\",&n,&s,&rt))==3)\n\t{\n\t\tClear();\n\t\tint u,v,flag=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tRead(e[i][0]);\n\t\t\tRead(e[i][1]);\n\t\t}\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tRead(u);Read(v);\n\t\t\tAddEdge(u,v);\n\t\t\tAddEdge(v,u);\n\t\t}\n\t\tfa[rt]=0,dep[rt]=0;\n\t\tdfs(rt);\n\t\tfor(int i=1;i<n;i++)\n\t\t\tif(check(e[i][0],e[i][1]))\n\t\t\t\tlon[e[i][0]]=lon[e[i][1]]=1;\n\t\t\telse Add(e[i][0],e[i][1]),Add(e[i][1],e[i][0]);\n\t\tbfs();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(vis[i]&&lon[i])\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(vis[i])\n\t\t\t\tans=max(ans,dep[i]);\n\t\tif(flag) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans*2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e5+10;\nint n,x,y,ans,vis[maxn];\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvoid print(int x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\nvoid write(int x){print(x);puts(\"\");}\nstruct Heavy_Light_Decomposition{\n    struct edge{int to,nxt;}e[maxn<<1];int tot,head[maxn];\n    int idx,fa[maxn],dfn[maxn],dep[maxn],son[maxn],top[maxn],size[maxn];\n    void add(int u,int v){e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;}\n    void insert(int u,int v){add(u,v);add(v,u);}\n    void build(int x){\n        dep[x]=dep[fa[x]]+1;size[x]=1;int mx=0;\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to){\n            if(v==fa[x])continue;\n            fa[v]=x;build(v);size[x]+=size[v];\n            if(size[v]>mx)mx=size[v],son[x]=v;\n        }\n    }\n    void dfs(int x){\n        if(!x)return ;dfn[x]=++idx;\n        top[x]=son[fa[x]]==x?top[fa[x]]:x;\n        dfs(son[x]);\n        for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)\n            if(v!=fa[x]&&v!=son[x])dfs(v);\n    }\n    int query(int u,int v){\n        while(top[u]!=top[v]){\n            if(dep[top[u]]<dep[top[v]])swap(u,v);\n            u=fa[top[u]];\n        }if(dep[u]>dep[v])swap(u,v);\n        return u;\n    }\n    int get_dis(int u,int v){return dep[u]+dep[v]-2*dep[query(u,v)];}\n}HLD[2];\nvoid init(int S){\n    queue<int >q;\n    q.push(S);vis[S]=1;\n    while(!q.empty()){\n        int x=q.front();q.pop();\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(!vis[v]&&HLD[0].dep[v]<HLD[1].dep[v])vis[v]=1,q.push(v);\n    }\n}\nvoid solve(){\n    for(int x=1;x<=n;x++){\n        if(!vis[x])continue;\n        ans=max(ans,HLD[1].dep[x]-1);\n        for(int i=HLD[0].head[x],v=HLD[0].e[i].to;i;i=HLD[0].e[i].nxt,v=HLD[0].e[i].to)\n            if(HLD[1].get_dis(v,x)>2){puts(\"-1\");return ;}\n    }write(ans<<1);\n}\nint main(){\n    n=read();x=read();y=read();\n    if(x==y){puts(\"0\");return 0;}\n    for(int i=1;i<n;i++)HLD[0].insert(read(),read());\n    for(int i=1;i<n;i++)HLD[1].insert(read(),read());\n    HLD[0].build(x);HLD[0].dfs(x);HLD[1].build(y);HLD[1].dfs(y);\n    init(x);solve();\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nint n,x,y;\nvector<int> e1[N],e2[N];\nint fa[N],dep[N],ance[18][N];\nvoid dfs(int x){\n    for (int i=0;i<e2[x].size();i++){\n        int v=e2[x][i];\n        if (fa[v]) continue;\n        fa[v]=x;\n        dep[v]=dep[x]+1;\n        dfs(v);\n    }\n}\nvoid init(){\n    fa[1]=1;dfs(1);\n    for (int i=1;i<=n;i++) ance[0][i]=fa[i];\n    for (int i=1;i<18;i++)\n    for (int j=1;j<=n;j++)\n        ance[i][j]=ance[i-1][ance[i-1][j]];\n}\nint go(int x,int k){\n    for (int i=0;i<18;i++)\n    if (k>>i&1) x=ance[i][x];\n    return x;\n}\nint lca(int x,int y){\n    if (dep[x]<dep[y]) swap(x,y);\n    x=go(x,dep[x]-dep[y]);\n    for (int i=17;i>=0;i--)\n    if (ance[i][x]!=ance[i][y]) x=ance[i][x],y=ance[i][y];\n    return x!=y?fa[x]:x;\n}\nint dist(int x,int y){\n    return dep[x]+dep[y]-2*dep[lca(x,y)];\n}\nint move(int x,int y){\n    int LCA=lca(x,y);\n    return y!=LCA?fa[y]:go(x,dep[x]-dep[y]-1);\n}\nvoid dfs(int x,int y,int fa){\n    if (x==y) return;\n    for (int i=0;i<e1[x].size();i++){\n        int v=e1[x][i];\n        if (v==fa) continue;\n        if (dist(x,v)>2) puts(\"-1\"),exit(0);\n        if (v!=y) dfs(v,move(v,y),x);\n    }\n}\nint ans;\nvoid calc(int x,int y,int fa,int times){\n    ans=max(ans,times+dist(x,y));\n    if (x==y) return;\n    for (int i=0;i<e1[x].size();i++){\n        int v=e1[x][i];\n        if (v==fa||v==y) continue;\n        calc(v,move(v,y),x,times+1);\n    }\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&x,&y);\n    for (int i=1;i<n;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        e1[a].push_back(b);\n        e1[b].push_back(a);\n    }\n    for (int i=1;i<n;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        e2[a].push_back(b);\n        e2[b].push_back(a);\n    }\n    init();\n    dfs(x,y,0);\n    calc(x,y,0,0);\n    printf(\"%d\\n\",ans*2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 200500;\n\nvector<int> E[N];\nvector<int> F[N];\n\nconst int LGN = 18;\nint up[LGN][N];\nint D[N];\n\nvoid DFS(int x, int p = -1) {\n    D[x] = (p == -1) ? 0 : D[p] + 1;\n    up[0][x] = (p == -1) ? x : p;\n    for (int d = 1; d < LGN; d++)\n        up[d][x] = up[d - 1][up[d - 1][x]];\n    for (int y : E[x]) {\n        if (y != p)\n            DFS(y, x);\n    }\n}\n\ninline int lca(int a, int b) {\n    if (D[a] > D[b]) {\n        swap(a, b);\n    }\n    for (int d = LGN - 1; d >= 0; d--)\n        if (D[up[d][b]] >= D[a])\n            b = up[d][b];\n    if (a == b)\n        return a;\n    for (int d = LGN - 1; d >= 0; d--)\n        if (up[d][a] != up[d][b])\n            a = up[d][a], b = up[d][b];\n    return up[0][a];\n}\n\ninline int dist(int a, int b) {\n    int l = lca(a, b);\n    return D[a] + D[b] - 2 * D[l];\n}\n\nbool infinite(int x) {\n    for (int y : F[x]) {\n        if (dist(x, y) >= 3)\n            return true;\n    }\n    return false;\n}\n\nbool isinfinite = false;\nint best = 0;\n\nint s, t;\n\n\nvoid DFS2(int x, int p = -1, int d = 0) {\n    best = max(best, dist(t, x));\n    if (infinite(x)) {\n        isinfinite = true;\n        return;\n    }\n    for (int y : F[x]) {\n        if (y == p)\n            continue;\n        if (d + 1 < dist(t, y)) {\n            DFS2(y, x, d + 1);\n            if (isinfinite)\n                return;\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d %d %d\", &n, &s, &t);\n    --s, --t;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        --a, --b;\n        F[a].push_back(b);\n        F[b].push_back(a);\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        --a, --b;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    DFS(0);\n    DFS2(s);\n    if (isinfinite) {\n        printf(\"%d\\n\", -1);\n    } else {\n        printf(\"%d\\n\", 2 * best);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n\nint n,X,Y,ans,A[N],B[N],d[N],fa[N];\nbool vis[N];\nvector<int> a[N],b[N];\n\nvoid dfs(int u){\n\tfor (int v:b[u])\n\t\tif (v!=fa[u]){d[v]=d[u]+1; fa[v]=u; dfs(v);}\n}\n\nvoid dfs2(int u,int par,int dist){\n\tif (vis[u]){puts(\"-1\"); exit(0);}\n\tans=max(ans,d[u]*2);\n\tfor (int v:a[u])\n\t\tif (v!=par){\n\t\t\tif (dist+1<d[v]) dfs2(v,u,dist+1);\n\t\t\telse if (dist+1==d[v]) ans=max(ans,d[v]*2);\n\t\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor (int i=1;i<n;++i){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tA[i]=x; B[i]=y;\n\t\ta[x].push_back(y); a[y].push_back(x);\n\t}\n\tfor (int i=1;i<n;++i){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tb[x].push_back(y); b[y].push_back(x);\n\t}\n\tdfs(Y);\n\tfor (int i=1;i<n;++i){\n\t\tint x=A[i],y=B[i];\n\t\tif (fa[x]!=y&&fa[fa[x]]!=y&&fa[x]!=fa[y]&&fa[y]!=x&&fa[fa[y]]!=x)\n\t\t\tvis[x]=vis[y]=1;\n\t}\n\tdfs2(X,0,0);\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <bitset>\n#include <random>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <functional>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < int(b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> int(a);)\n#define all(v) v.begin(),v.end()\n#define trav(x, v) for(auto &x : v)\n#define sz(v) int((v).size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long double ld;\n\nconst int lg = 20;\n\nstruct tree {\n\tint n;\n\tvector<vi> gr;\n\tvi par, h;\n\tvector<vi> hopp;\n\tvoid dfs(int v){\n\t\ttrav(u, gr[v]) if(u != par[v]){\n\t\t\tpar[u] = v;\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u);\n\t\t}\n\t}\n\ttree(vector<vi> gr) : gr(gr) {\n\t\tn = sz(gr);\n\t\tpar.resize(n), h.resize(n);\n\t\thopp.resize(lg, vi(n));\n\n\t\tdfs(0);\n\n\t\thopp[0] = par;\n\t\trep(t,1,lg) rep(i,0,n)\n\t\t\thopp[t][i] = hopp[t-1][hopp[t-1][i]];\n\t}\n\tint jump(int a, int steps){\n\t\tfor(int i = 0; steps; ++i){\n\t\t\tif(steps&1) a = hopp[i][a];\n\t\t\tsteps /= 2;\n\t\t}\n\t\treturn a;\n\t}\n\tint lca(int a, int b){\n\t\tif(h[a] > h[b]) swap(a,b);\n\t\tb = jump(b, h[b] - h[a]);\n\t\tif(a == b) return a;\n\t\trrep(i,0,lg){\n\t\t\tint aa = hopp[i][a], bb = hopp[i][b];\n\t\t\tif(aa != bb){\n\t\t\t\ta = aa, b = bb;\n\t\t\t}\n\t\t}\n\t\treturn par[b];\n\t}\n\tint dist(int a, int b){\n\t\tint c = lca(a,b);\n\t\treturn h[a] + h[b] - 2*h[c];\n\t}\n\tint closer(int v, int y){\n\t\tif(v == y) return v;\n\t\tint r = lca(v, y);\n\t\tif(y != r) return par[y];\n\t\treturn jump(v, h[v]-h[y]-1);\n\t}\n};\n\nvoid noend(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n, x, y;\n\tcin >> n >> x >> y;\n\t--x, --y;\n\tvector<vi> gred(n), gblue(n);\n\n\trep(_,0,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a,--b;\n\t\tgred[a].push_back(b);\n\t\tgred[b].push_back(a);\n\t}\n\trep(_,0,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a,--b;\n\t\tgblue[a].push_back(b);\n\t\tgblue[b].push_back(a);\n\t}\n\ttree red(gred), blue(gblue);\n\tint ans = 0;\n\tvector<bool> vis(n);\n\tqueue<pii> ko;\n\tko.push(pii(x, y));\n\tvis[x] = 1;\n\twhile(!ko.empty()){\n\t\tpii pa = ko.front();\n\t\tko.pop();\n\t\tans = max(ans, 2 * blue.dist(pa.first, y));\n\t//\tcout << pa.first+1 << ' ' << pa.second+1 << endl;\n\t\tif(pa.first == pa.second) continue;\n\t\ttrav(x1, gred[pa.first]) if(!vis[x1]){\n\t\t\tif(red.dist(x1, pa.first) > 2)\n\t\t\t\tnoend();\n\t\t\tvis[x1] = 1;\n\t\t\tko.push(pii(x1, red.closer(x1, pa.second)));\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nconst int mlog = 17;\nint n,a,b;\nvector<int> way1[maxn], way2[maxn];\nint depA[maxn], depB[maxn];\nint par[maxn][20];\nint good[maxn];\nint loop, ans;\nvoid build(int u, int last) {\n    par[u][0] = last;\n    for(int i=1;i<=mlog;i++) par[u][i] = par[par[u][i-1]][i-1];\n    for(auto v : way2[u]) {\n        if(v==last) continue;\n        depB[v] = depB[u] + 1;\n        build(v, u);\n    }\n}\nvoid dfs(int u, int last) {\n    if(depB[u]<=depA[u]) return ;\n    if(good[u]) loop = 1;\n    else ans = max(ans, depB[u]*2);\n    for(auto v : way1[u]) {\n        if(v==last) continue;\n        depA[v] = depA[u] + 1;\n        dfs(v, u);\n    }\n}\nint lca(int u, int v) {\n    int res = 0;\n    if(depB[u]<depB[v]) swap(u,v);\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i] && depB[par[u][i]]>=depB[v]) {\n            u = par[u][i];\n            res += (1<<i);\n        }\n    }\n    if(u==v) return res;\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i]!=par[v][i]) {\n            u = par[u][i]; v = par[v][i];\n            res += (1<<i)*2;\n        }\n    }\n    return res+2;\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way1[u].push_back(v);\n        way1[v].push_back(u);\n    }\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way2[u].push_back(v);\n        way2[v].push_back(u);\n    }\n    build(b,0);\n    for(int u=1;u<=n;u++) {\n        for(auto v : way1[u]) {\n            if(lca(u,v)>=3) {\n                good[u] = good[v] = 1;\n            }\n        }\n    }\n//    for(int u=1;u<=n;u++) printf(\"%d : %d\\n\",u,good[u]);\n    dfs(a,0);\n    if(loop) printf(\"-1\");\n    else printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector> \n#define MN 201000\n\nstd::vector<int> v1[MN], v2[MN];\nint dep[MN], fa[MN];\nint Max = 0;\n\nvoid dfs2(int x, int f)\n{\n\tfa[x] = f; \n\tfor(auto y : v2[x]) \n\t{\n\t\tif(y == f) continue;\n\t\tdep[y] = dep[x] + 1;\n\t\tdfs2(y, x);\n\t}\n}\n\nvoid dfs1(int x, int f, int t)\n{\n\tMax = std::max(Max, dep[x]);\n\tfor(auto y : v1[x])\n\t{\n\t\tif(y == f) continue;\n\t\tif(dep[y] > t + 1)\n\t\t{\t\n\t\t\tif(fa[x] == fa[y] || fa[x] == y || fa[y] == x || fa[fa[x]] == y || fa[fa[y]] == x)\n\t\t\t\tdfs1(y, x, t + 1);\n\t\t\telse Max = 1e9;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, x, y; scanf(\"%d%d%d\", &n, &x, &y);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tv1[u].push_back(v);\n\t\tv1[v].push_back(u);\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tv2[u].push_back(v);\n\t\tv2[v].push_back(u);\n\t}\n\tdfs2(y, 0); dfs1(x, 0, 0);\n\tif(Max >= 1e9) puts(\"-1\");\n\telse printf(\"%d\\n\", 2 * Max);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge\n{\n\tint x,y;\n}e[200010];\nint n,dep[200010],d[200010],sx,sy,fa[200010];\nbool used[200010],vis[200010];\nint cnt,head[200010],to[400010],nxt[400010];\nvector<int> v[200010];\nqueue<int> q;\nvoid add(int x,int y)\n{\n\tcnt++;\n\tto[cnt]=y;\n\tnxt[cnt]=head[x];\n\thead[x]=cnt;\n}\nvoid dfs(int x)\n{\n\tfor (int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif (y==fa[x])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfa[y]=x;\n\t\tdep[y]=dep[x]+1;\n\t\tdfs(y);\n\t}\n}\nbool check(int x,int y)\n{\n\tif (dep[x]>dep[y])\n\t{\n\t\tswap(x,y);\n\t}\n\tif (x==fa[y] || x==fa[fa[y]])\n\t{\n\t\treturn true;\n\t}\n\tif (fa[x]==fa[y])\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&sy,&sx);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdep[sx]=1;\n\tdfs(sx);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tx=e[i].x;\n\t\ty=e[i].y;\n\t\tif (!check(x,y))\n\t\t{\n\t\t\tused[x]=used[y]=true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t}\n\t}\n\tmemset(d,-1,sizeof(d));\n\td[sy]=1;\n\tvis[sy]=true;\n\tq.push(sy);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor (int i=0;i<v[x].size();i++)\n\t\t{\n\t\t\tint y=v[x][i];\n\t\t\tif (d[y]!=-1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[y]=d[x]+1;\n\t\t\tif (d[y]<dep[y])\n\t\t\t{\n\t\t\t\tvis[y]=true;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\tint mx=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (used[i] && vis[i])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (vis[i])\n\t\t{\n\t\t\tmx=max(mx,dep[i]);\n\t\t}\n\t}\n\tcout<<(mx-1)*2<<endl;\n\treturn 0;\n}\n//初见你时你给我你的心，里面是一个春天的早晨。\n//再见你时你给我你的话，说不出的是炽烈的火夏。\n//三次见你你给我你的手，里面藏着个叶落的深秋。\n//最后见你是我做的短梦，梦里有你还有一群冬风。\n//——《季候》"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <cassert>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <set>\n#include <bitset>\n#include <string>\n#include <utility>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <map>\n#else\n#include <bits/stdc++.h>\n#endif\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#define rep(i, n) for (int i = 0, i##_end_ = (n); i < i##_end_; ++i)\n#define per(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define forn(i, l, r) for (int i = (l), i##_end_ = (r); i <= i##_end_; ++i)\n#define nrof(i, r, l) for (int i = (r), i##_end_ = (l); i >= i##_end_; --i)\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\ntypedef pair<int, int> pii;\n\ntypedef long long LL;\n\ntemplate<typename T> inline bool chkmax(T &x, const T &y) {\n\treturn x < y && (~x) ? x = y, 1 : 0;\n}\n\ntemplate<typename T> inline bool chkmin(T &x, const T &y) {\n\treturn x > y ? x = y, 1 : 0;\n}\n\n#ifdef DEBUG\nchar *input_file, *output_file;\n#endif\n\nstruct IO {\n\tstatic const int maxn = (1 << 25) + 10;\n\n\tchar a[maxn], *s, b[maxn], *t;\n\n\tvoid INPUT() {\n\t\ts = a;\n\t\tt = b;\n\t\t#ifdef DEBUG\n\t\tFILE *f = fopen(input_file, \"r\");\n\t\ta[fread(a, 1, sizeof a, f)] = 0;\n\t\t#else\n\t\ta[fread(a, 1, sizeof a, stdin)] = 0;\n\t\t#endif\n\t}\n\n\tvoid OUTPUT() {\n#ifdef DEBUG\n\t\tFILE *f = fopen(output_file, \"w\");\n\t\tfwrite(b, 1, t - b, f);\n#else\n\t\tfwrite(b, 1, t - b, stdout);\n#endif\n\t}\n\n\toperator int() {\n\t\tint x = 0;\n\t\twhile(*s != '-' && (*s < '0' || *s > '9')) {\n\t\t\t++s;\n\t\t}\n\t\tbool f = 0;\n\t\tif(*s == '-') {\n\t\t\tf = 1;\n\t\t\t++s;\n\t\t}\n\t\twhile(*s >= '0' && *s <= '9') {\n\t\t\t(x *= 10) += *s - '0';\n\t\t\t++s;\n\t\t}\n\t\tif(f) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn x;\n\t}\n\n\toperator LL() {\n\t\tLL x = 0;\n\t\twhile(*s != '-' && (*s < '0' || *s > '9')) {\n\t\t\t++s;\n\t\t}\n\t\tbool f = 0;\n\t\tif(*s == '-') {\n\t\t\tf = 1;\n\t\t\t++s;\n\t\t}\n\t\twhile(*s >= '0' && *s <= '9') {\n\t\t\t(x *= 10) += *s - '0';\n\t\t\t++s;\n\t\t}\n\t\tif(f) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn x;\n\t}\n\n\toperator char() {\n\t\twhile(*s <= 32) {\n\t\t\t++s;\n\t\t}\n\t\tchar ret = *s;\n\t\t++s;\n\t\treturn ret;\n\t}\n\n\tinline void out(int x) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tint y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\treturn;\n\t}\n\n\tinline void out(int x, char C) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\t*t++ = C;\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tint y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\t*t++ = C;\n\t\treturn;\n\t}\n\n\tinline void out(LL x) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tLL y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\treturn;\n\t}\n\n\tinline void out(LL x, char C) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\t*t++ = C;\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tLL y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\t*t++ = C;\n\t\treturn;\n\t}\n\n\tinline void out(char c) {\n\t\t*t++ = c;\n\t\treturn;\n\t}\n\n\tinline void out(char *s) {\n\t\twhile(*s >= ' ') {\n\t\t\t*t++ = *s++;\n\t\t}\n\t\treturn;\n\t}\n}io;\n\nvoid Main();\n\nint main(int argc, char *argv[]) {\n#ifdef DEBUG\n\tinput_file = argv[1];\n\toutput_file = argv[2];\n#endif\n\tio.INPUT();\n\tMain();\n\tio.OUTPUT();\n\treturn 0;\n}\n\n//---------------------------------------------------------------------------------------head---------------------------------------------------------------------------------------\n\nconst int maxn = 2e5 + 100;\n\nconst int lgn = 19;\n\nint n, r1, r2, ans;\nvi g1[maxn], g2[maxn];\nint par1[maxn][lgn], par2[maxn][lgn];\nint dep1[maxn], dep2[maxn];\n\nvoid dfs1(int u = r1, int p = 0) {\n\tpar1[u][0] = p;\n\tforn(i, 1, lgn - 1) {\n\t\tpar1[u][i] = par1[par1[u][i - 1]][i - 1];\n\t}\n\tdep1[u] = dep1[p] + 1;\n\tfor (int v: g1[u]) {\n\t\tif(v != p) {\n\t\t\tdfs1(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfs2(int u = r2, int p = 0) {\n\tpar2[u][0] = p;\n\tforn(i, 1, lgn - 1) {\n\t\tpar2[u][i] = par2[par2[u][i - 1]][i - 1];\n\t}\n\tdep2[u] = dep2[p] + 1;\n\tfor (int v: g2[u]) {\n\t\tif(v != p) {\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nint lca(int u, int v) {\n\tif(dep2[u] < dep2[v]) {\n\t\tswap(u, v);\n\t}\n\tint dlt = dep2[u] - dep2[v];\n\trep(i, lgn) {\n\t\tif((dlt >> i) & 1) {\n\t\t\tu = par2[u][i];\n\t\t}\n\t}\n\tif(u == v) {\n\t\treturn u;\n\t}\n\tper(i, lgn) {\n\t\tif(par2[u][i] != par2[v][i]) {\n\t\t\tu = par2[u][i], v = par2[v][i];\n\t\t}\n\t}\n\treturn par2[u][0];\n}\n\nvoid dfs3(int u = r1, int p = 0) {\n\tchkmax(ans, dep2[u] - 1 << 1);\n\tif(dep1[u] >= dep2[u]) {\n\t\treturn;\n\t}\n\tif(p) {\n\t\tint f = lca(u, p);\n\t\tif(dep2[u] + dep2[p] - dep2[f] * 2 > 2) {\n\t\t\tans = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int v: g1[u]) {\n\t\tif(v != p) {\n\t\t\tdfs3(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid Main() {\n\tn = io;\n\tr1 = io;\n\tr2 = io;\n\trep(i, n - 1) {\n\t\tint u = io, v = io;\n\t\tg1[u].pb(v);\n\t\tg1[v].pb(u);\n\t}\n\trep(i, n - 1) {\n\t\tint u = io, v = io;\n\t\tg2[u].pb(v);\n\t\tg2[v].pb(u);\n\t}\n\tdfs1();\n\tdfs2();\n\tdfs3();\n\tio.out(ans, '\\n');\n\treturn;\n}\n"
  },
  {
    "language": "C++",
    "code": "//BadWaper gg\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<set>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define N 500010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint n,A,B;\nint p[N],q[N];\nint fa[N][21],dist[N],deep[N];\nstruct edge\n{\n\tint next,to,p;\n}e[N<<1];\nint head[N],cnt,win[N],vis[N];\nqueue<int>Q;\ninline void add_edge(int from,int to,int p){e[++cnt]=(edge){head[from],to,p};head[from]=cnt;}\nvoid dfs(int now,int father)\n{\n\tdeep[now]=deep[father]+1;fa[now][0]=father;\n\tfor(register int i=1;i<=20;i++)fa[now][i]=fa[fa[now][i-1]][i-1];\n\tfor(register int i=head[now];i;i=e[i].next)\n\t{\n\t\tif(e[i].to==father)continue;\n\t\tdfs(e[i].to,now);\n\t}\n}\nvoid bfs()\n{\n\tQ.push(A);vis[A]=1;dist[A]=1;vis[B]=1;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(register int i=head[x];i;i=e[i].next)\n\t\t{\n\t\t\tif(e[i].p&&!vis[e[i].to])\n\t\t\t{\n\t\t\t\tdist[e[i].to]=dist[x]+1;//cout<<\"WTF:\"<<e[i].to<<\" \"<<deep[e[i].to]<<\" \"<<dist[e[i].to]<<endl;\n\t\t\t\tif(dist[e[i].to]<deep[e[i].to]){vis[e[i].to]=1;Q.push(e[i].to);}\n\t\t\t}\n\t\t}\n\t}\n}\ninline int lca(int u,int v)\n{\n\tif(deep[u]<deep[v])swap(u,v);\n\tfor(register int i=20;i>=0;i--)if(deep[fa[u][i]]>=deep[v])u=fa[u][i];\n\tif(u==v)return u;\n\tfor(register int i=20;i>=0;i--)\n\t{\n\t\tif(fa[u][i]!=fa[v][i])\n\t\t{\n\t\t\tu=fa[u][i],v=fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\ninline int Dist(int x,int y){return deep[x]+deep[y]-2*deep[lca(x,y)];}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),A=read(),B=read();\n\tfor(register int i=1;i<n;i++)p[i]=read(),q[i]=read();\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y,0);add_edge(y,x,0);\n\t}\n\tdfs(B,0);\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tif(Dist(p[i],q[i])>=3)win[p[i]]=win[q[i]]=1;\n\t\telse add_edge(p[i],q[i],1),add_edge(q[i],p[i],1);\n\t}\n\tbfs();\n\tint ans=0;\n\tfor(register int i=1;i<=n;i++)if(win[i]&&vis[i]&&i!=B){puts(\"-1\");return 0;}\n\tfor(register int i=1;i<=n;i++)ans=max(ans,dist[i]<<1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define debug\n#define TRACE(x)\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 200010;\n\nvector<int> e[2][MAXN];\nint n, X, Y, dad[MAXN], sp[MAXN], dist[MAXN], sol;\nbool infi;\n\nvoid dfs(int t, int x, int par) {\n  dad[x] = par;\n  for (int y : e[t][x])\n    if (y != par) {\n      dist[y] = dist[x] + 1;\n      dfs(t, y, x);\n    }\n}\n\nvoid solve(int x, int par, int d) {\n  if (sp[x]) infi = true;\n  sol = max(sol, 2 * dist[x]);\n  for (int y : e[0][x]) {\n    TRACE(x _ y _ d _ dist[y]);\n    if (y != par && dist[y] > d + 1)\n      solve(y, x, d + 1);\n  }\n}\n\nint main(void) {\n  scanf(\"%d %d %d\",&n,&X,&Y);\n  --X; --Y;\n  REP(t, 2) REP(i, n - 1) {\n    int a, b;\n    scanf(\"%d %d\",&a,&b);\n    --a; --b;\n    e[t][a].push_back(b);\n    e[t][b].push_back(a);\n  }\n\n  dfs(1, Y, -1);\n\n  REP(a, n)\n    for (int b : e[0][a]) {\n      bool lng = true;\n      if (dad[a] == b) lng = false;\n      if (dad[b] == a) lng = false;\n      if (dad[a] == dad[b]) lng = false;\n      if (dad[a] != -1 && dad[dad[a]] == b) lng = false;\n      if (dad[b] != -1 && dad[dad[b]] == a) lng = false;\n      if (lng) sp[a] = sp[b] = 1;\n    }\n\n  REP(x, n) TRACE(x _ sp[x]);\n\n  solve(X, -1, 0);\n  if (infi)\n    sol = -1;\n  \n  printf(\"%d\\n\",sol);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 200005\nconst int INF=0x3f3f3f3f;\nstruct edge{\n\tint t,next;\n}e[N*4];int ecnt,head[N*2];//1~n blue n+1~n+n red\nvoid addedge(int f,int t){\n\te[++ecnt]=(edge){t,head[f]};head[f]=ecnt;\n\te[++ecnt]=(edge){f,head[t]};head[t]=ecnt;\n}\nint fa[N],dis[N];\nvoid DFS(int u,int fr){\n\tfa[u]=fr;dis[u]=dis[fr]+1;\n\tfor(int i=head[u];i;i=e[i].next)\n\t\tif(e[i].t!=fr) DFS(e[i].t,u);\n} \nbool judge(int f,int t){//is the distance between f and t is smaller or equal to 2\n\tif(dis[f]==dis[t]) return fa[f]==fa[t];\n\tif(dis[f]>dis[t]) swap(f,t);\n\treturn fa[t]==f||fa[fa[t]]==f;\n}\nint n,x,y,ans;\nvoid DFS2(int u,int fr,int d){\n\tif(dis[u-n]<=d) return;\n\tans=max(ans,dis[u-n]);\n\tfor(int i=head[u];i;i=e[i].next)\n\t\tif(e[i].t!=fr){\n\t\t\tDFS2(e[i].t,u,d+1);\n\t\t\tif(judge(u-n,e[i].t-n)==false)\n\t\t\t\tans=INF;\n\t\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1,f,t;i<n;i++)\n\t\tscanf(\"%d%d\",&f,&t),addedge(f+n,t+n);\n\tfor(int i=1,f,t;i<n;i++)\n\t\tscanf(\"%d%d\",&f,&t),addedge(f,t);\n\tdis[0]=-1;DFS(y,0);\n\tDFS2(x+n,0,0);\n\tif(ans==INF) ans=-1;\n\telse ans*=2;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 220000;\nint n;\nint was[MAXN];\nint h[MAXN];\nint p[MAXN];\nvector<int> eds0[MAXN];\nvector<int> eds1[MAXN];\nint dd[MAXN];\nqueue<int> qu;\n\nvoid dfs1(int v) {\n\twas[v] = 1;\n\tfor (int u: eds1[v]) {\n\t\tif (was[u])\n\t\t\tcontinue;\n\t\tp[u] = v;\n\t\th[u] = h[v] + 1;\n\t\tdfs1(u);\n\t}\n}\n\nint dst(int a, int b) {\n\tif (a == b)\n\t\treturn 0;\n\tif (p[a] == b || p[b] == a)\n\t\treturn 1;\n\tif (p[a] == p[b] || (p[a] != -1 && p[p[a]] == b) || (p[b] != -1 && p[p[b]] == a))\n\t\treturn 2;\n\treturn 3;\n}\n\nint main() {\n\tint x, y;\n\tint ans = 0;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\t--x, --y;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\teds0[a].push_back(b);\n\t\teds0[b].push_back(a);\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\teds1[a].push_back(b);\n\t\teds1[b].push_back(a);\n\t}\n\tdfs1(y);\n\tp[y] = -1;\n\t\n\tqu.push(x);\n\tfor (int i = 0; i < n; ++i)\n\t\tdd[i] = -1;\n\tdd[x] = 0;\n\twhile (!qu.empty()) {\n\t\tint x = qu.front();\n\t\tqu.pop();\n\t\tans = max(ans, h[x] * 2);\n\t\tif (dd[x] < h[x]) {\n\t\t\tfor (int u: eds0[x]) {\n\t\t\t\tif (dst(x, u) > 2) {\n\t\t\t\t\tcout << -1 << \"\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (dd[u] == -1)\n\t\t\t\t\tdd[u] = dd[x] + 1, qu.push(u);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(2e5) + 9;\n\nint n, x, y;\n\nstruct Tree{\n    vector<int> adj[N];\n    int d[N], p[N];\n    \n    void dfs(int u, int p = -1){\n        for (auto v: adj[u]){\n            if (v == p) continue;\n            d[v] = d[u] + 1; this->p[v] = u;\n            dfs(v, u);\n        }\n    }\n    void in(){\n        DO(n-1){\n            int x, y; RD(x, y); --x, --y;\n            adj[x].PB(y);\n            adj[y].PB(x);\n        }\n    }\n} R, B;\n\nint gao(){\n\n    RD(n, x, y); R.in(); B.in();\n    R.dfs(x); B.dfs(y);\n    \n    int z = 0;\n    REP(u, n) if (R.d[u] < B.d[u]){\n        int v = R.p[u];\n        if (v == B.p[u] || B.p[v] == u || B.p[B.p[u]] == v || B.p[B.p[v]] == u || B.p[u] == B.p[v]) checkMax(z, R.d[u]*2);\n        else return -1;\n    }\n    return z;\n}\n\nint main(){\n    \n#ifndef ONLINE_JUDGE\n    freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users//desktop/Exercise/out.txt\", \"w\", stdout);\n#endif\n    \n    OT(gao());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint main()\n{\nputs(\"-1\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <cassert>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <set>\n#include <bitset>\n#include <string>\n#include <utility>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <map>\n#else\n#include <bits/stdc++.h>\n#endif\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#define rep(i, n) for (int i = 0, i##_end_ = (n); i < i##_end_; ++i)\n#define per(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define forn(i, l, r) for (int i = (l), i##_end_ = (r); i <= i##_end_; ++i)\n#define nrof(i, r, l) for (int i = (r), i##_end_ = (l); i >= i##_end_; --i)\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\ntypedef pair<int, int> pii;\n\ntypedef long long LL;\n\ntemplate<typename T> inline bool chkmax(T &x, const T &y) {\n\treturn (x < y && x != -1) ? x = y, 1 : 0;\n}\n\ntemplate<typename T> inline bool chkmin(T &x, const T &y) {\n\treturn x > y ? x = y, 1 : 0;\n}\n\n#ifdef DEBUG\nchar *input_file, *output_file;\n#endif\n\nstruct IO {\n\tstatic const int maxn = (1 << 25) + 10;\n\n\tchar a[maxn], *s, b[maxn], *t;\n\n\tvoid INPUT() {\n\t\ts = a;\n\t\tt = b;\n\t\t#ifdef DEBUG\n\t\tFILE *f = fopen(input_file, \"r\");\n\t\ta[fread(a, 1, sizeof a, f)] = 0;\n\t\t#else\n\t\ta[fread(a, 1, sizeof a, stdin)] = 0;\n\t\t#endif\n\t}\n\n\tvoid OUTPUT() {\n#ifdef DEBUG\n\t\tFILE *f = fopen(output_file, \"w\");\n\t\tfwrite(b, 1, t - b, f);\n#else\n\t\tfwrite(b, 1, t - b, stdout);\n#endif\n\t}\n\n\toperator int() {\n\t\tint x = 0;\n\t\twhile(*s != '-' && (*s < '0' || *s > '9')) {\n\t\t\t++s;\n\t\t}\n\t\tbool f = 0;\n\t\tif(*s == '-') {\n\t\t\tf = 1;\n\t\t\t++s;\n\t\t}\n\t\twhile(*s >= '0' && *s <= '9') {\n\t\t\t(x *= 10) += *s - '0';\n\t\t\t++s;\n\t\t}\n\t\tif(f) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn x;\n\t}\n\n\toperator LL() {\n\t\tLL x = 0;\n\t\twhile(*s != '-' && (*s < '0' || *s > '9')) {\n\t\t\t++s;\n\t\t}\n\t\tbool f = 0;\n\t\tif(*s == '-') {\n\t\t\tf = 1;\n\t\t\t++s;\n\t\t}\n\t\twhile(*s >= '0' && *s <= '9') {\n\t\t\t(x *= 10) += *s - '0';\n\t\t\t++s;\n\t\t}\n\t\tif(f) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn x;\n\t}\n\n\toperator char() {\n\t\twhile(*s <= 32) {\n\t\t\t++s;\n\t\t}\n\t\tchar ret = *s;\n\t\t++s;\n\t\treturn ret;\n\t}\n\n\tinline void out(int x) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tint y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\treturn;\n\t}\n\n\tinline void out(int x, char C) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\t*t++ = C;\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tint y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\t*t++ = C;\n\t\treturn;\n\t}\n\n\tinline void out(LL x) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tLL y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\treturn;\n\t}\n\n\tinline void out(LL x, char C) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\t*t++ = C;\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tLL y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\t*t++ = C;\n\t\treturn;\n\t}\n\n\tinline void out(char c) {\n\t\t*t++ = c;\n\t\treturn;\n\t}\n\n\tinline void out(char *s) {\n\t\twhile(*s >= ' ') {\n\t\t\t*t++ = *s++;\n\t\t}\n\t\treturn;\n\t}\n}io;\n\nvoid Main();\n\nint main(int argc, char *argv[]) {\n#ifdef DEBUG\n\tinput_file = argv[1];\n\toutput_file = argv[2];\n#endif\n\tio.INPUT();\n\tMain();\n\tio.OUTPUT();\n\treturn 0;\n}\n\n//---------------------------------------------------------------------------------------head---------------------------------------------------------------------------------------\n\nconst int maxn = 2e5 + 100;\n\nconst int lgn = 19;\n\nint n, r1, r2, ans;\nvi g1[maxn], g2[maxn];\nint par1[maxn][lgn], par2[maxn][lgn];\nint dep1[maxn], dep2[maxn];\n\nvoid dfs1(int u = r1, int p = 0) {\n\tpar1[u][0] = p;\n\tforn(i, 1, lgn - 1) {\n\t\tpar1[u][i] = par1[par1[u][i - 1]][i - 1];\n\t}\n\tdep1[u] = dep1[p] + 1;\n\tfor (int v: g1[u]) {\n\t\tif(v != p) {\n\t\t\tdfs1(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfs2(int u = r2, int p = 0) {\n\tpar2[u][0] = p;\n\tforn(i, 1, lgn - 1) {\n\t\tpar2[u][i] = par2[par2[u][i - 1]][i - 1];\n\t}\n\tdep2[u] = dep2[p] + 1;\n\tfor (int v: g2[u]) {\n\t\tif(v != p) {\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nint lca(int u, int v) {\n\tif(dep2[u] < dep2[v]) {\n\t\tswap(u, v);\n\t}\n\tint dlt = dep2[u] - dep2[v];\n\trep(i, lgn) {\n\t\tif((dlt >> i) & 1) {\n\t\t\tu = par2[u][i];\n\t\t}\n\t}\n\tif(u == v) {\n\t\treturn u;\n\t}\n\tper(i, lgn) {\n\t\tif(par2[u][i] != par2[v][i]) {\n\t\t\tu = par2[u][i], v = par2[v][i];\n\t\t}\n\t}\n\treturn par2[u][0];\n}\n\nvoid dfs3(int u = r1, int p = 0) {\n\tchkmax(ans, dep2[u] - 1 << 1);\n\tif(dep1[u] >= dep2[u]) {\n\t\treturn;\n\t}\n\tif(p) {\n\t\tint f = lca(u, p);\n\t\tif(dep2[u] + dep2[p] - dep2[f] * 2 > 2) {\n\t\t\tans = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int v: g1[u]) {\n\t\tif(v != p) {\n\t\t\tdfs3(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid Main() {\n\tn = io;\n\tr1 = io;\n\tr2 = io;\n\trep(i, n - 1) {\n\t\tint u = io, v = io;\n\t\tg1[u].pb(v);\n\t\tg1[v].pb(u);\n\t}\n\trep(i, n - 1) {\n\t\tint u = io, v = io;\n\t\tg2[u].pb(v);\n\t\tg2[v].pb(u);\n\t}\n\tdfs1();\n\tdfs2();\n\tdfs3();\n\tio.out(ans, '\\n');\n\treturn;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,x,y;\nvi red[252521];\nvi blue[252521];\nbool win[252521];\nint reddepth[252521];\nint bluedepth[252521];\nint blueparent[252521];\n// sigma is red in x\n// sugim is blue in y\n// sugim chases sigma\n// sigma first\n\nint bluelength(int a,int b){\n  if(a==b)return 0;\n  if(bluedepth[a]>bluedepth[b])swap(a,b);\n  int dd = bluedepth[b]-bluedepth[a];\n  if(dd>=3){\n    return 3;\n  }else if(dd==2){\n    if(a==blueparent[blueparent[b]]){\n      return 2;\n    }else{\n      return 3;\n    }\n  }else if(dd==1){\n    if(a==blueparent[b]){\n      return 1;\n    }else{\n      return 3;\n    }\n  }else{\n    if(blueparent[a]==blueparent[b]){\n      return 2;\n    }else{\n      return 3;\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  --x;--y;\n  REP(i,n-1){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    red[a].push_back(b);\n    red[b].push_back(a);\n  }\n  REP(i,n-1){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    blue[a].push_back(b);\n    blue[b].push_back(a);\n  }\n  // search win point\n  REP(i,n)bluedepth[i] = 252521;\n  bluedepth[y] = 0;\n  blueparent[y] = -1;\n  stack<int> S;\n  S.push(y);\n  while(!S.empty()){\n    int p = S.top();S.pop();\n    int d = bluedepth[p]+1;\n    REP(i,blue[p].size()){\n      int to = blue[p][i];\n      if(bluedepth[to] < d)continue;\n      blueparent[to] = p;\n      bluedepth[to] = d;\n      S.push(to);\n    }\n  }\n  REP(i,n){\n    REP(j,red[i].size()){\n      int to = red[i][j];\n      // avoid duplication\n      if(i<to){\n        if(bluelength(i,to)>=3){\n          win[i] = true;\n          win[to] = true;\n        }\n      }\n    }\n  }\n  // flee\n  REP(i,n)reddepth[i] = 252521;\n  reddepth[x] = 0;\n  S.push(x);\n  while(!S.empty()){\n    int p = S.top();S.pop();\n    int d = reddepth[p]+1;\n    REP(i,red[p].size()){\n      int to = red[p][i];\n      if(reddepth[to] < d)continue;\n      if(bluedepth[to] <= d)continue;\n      reddepth[to] = d;\n      S.push(to);\n    }\n  }\n  // check\n  int ans = -1;\n  REP(i,n){\n    if(reddepth[i]!=252521){\n      if(win[i]){\n        ans = -2;\n        break;\n      }else{\n        CHMAX(ans,bluedepth[i]);\n      }\n    }\n  }\n  if(ans==-2){\n    puts(\"-1\");\n  }else{\n    printf(\"%d\\n\",ans*2);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=200200;\nint i,j,k,n,X,Y,x,y,ch,ff,ans;\nbool z[N];\nstruct edge { int s,n;};\nstruct tree {\n\tint i,j,k,En;\n\tint h[N],dp[N],fa[N];\n\tedge E[N<<1];\n\tvoid add(int x,int y) {\n\t\tE[++En].s=y;E[En].n=h[x];h[x]=En;\n\t\tE[++En].s=x;E[En].n=h[y];h[y]=En;\n\t}\n} A,B;\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n\tif (ff) x=-x;\n}\nvoid dfsB(int x,int F) {\n\tB.fa[x]=F;B.dp[x]=B.dp[F]+1;\n\tfor (int k=B.h[x];k;k=B.E[k].n) if (B.E[k].s!=F) dfsB(B.E[k].s,x);\n}\nvoid dfsA(int x,int F) {\n\tA.fa[x]=F;A.dp[x]=A.dp[F]+1;\n\tz[x]=z[F] || A.dp[x]>=B.dp[x];\n\tfor (int k=A.h[x];k;k=A.E[k].n) if (A.E[k].s!=F) dfsA(A.E[k].s,x);\n}\nbool check(int x,int y) {\n\tif (B.dp[x]<B.dp[y]) swap(x,y);\n\tif (B.dp[x]==B.dp[y] && B.fa[x]==B.fa[y]) return 0;\n\tif (B.fa[x]==y || B.fa[B.fa[x]]==y) return 0;\n\treturn 1;\n}\nint main() {\n\tR(n);R(X);R(Y);\n\tfor (i=1;i<n;i++) {\n\t\tR(x);R(y);\n\t\tA.add(x,y);\n\t}\n\tfor (i=1;i<n;i++) {\n\t\tR(x);R(y);\n\t\tB.add(x,y);\n\t}\n\tA.dp[0]=B.dp[0]=-1;\n\tdfsB(Y,0);\n\tdfsA(X,0);\n\tfor (i=1;i<=n;i++)\n\t\tfor (k=A.h[i];k;k=A.E[k].n) if (A.E[k].s!=A.fa[i]) {\n\t\t\tj=A.E[k].s;\n\t\t\tif (z[i] && z[j]) continue;\n\t\t\tif (check(i,j)) return puts(\"-1\"),0;\n\t\t}\n\tfor (i=1;i<=n;i++) if (!z[i]) ans=max(ans,B.dp[i]);\n\tprintf(\"%d\\n\",2*ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0;char ch=' ';\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q;\n}\nconst int N=200005;\nint n,s1,s2,tim,ans;\nint win[N],dep[N],in[N],out[N],fa[N],vis[N],dis[N],que[N];\nstruct edge{int x,y;}e1[N];\nstruct tree{\n\tint h[N],ne[N<<1],to[N<<1],tot;\n\tvoid add(int x,int y) {to[++tot]=y,ne[tot]=h[x],h[x]=tot;}\n}T1,T2;\nvoid dfs(int x,int las) {\n\tdep[x]=dep[las]+1,in[x]=++tim,fa[x]=las;\n\tfor(RI i=T2.h[x];i;i=T2.ne[i])\n\t\tif(T2.to[i]!=las) dfs(T2.to[i],x);\n\tout[x]=tim;\n}\nint check(int x,int y) {\n\tif(in[x]>in[y]) swap(x,y);\n\tif(in[x]<=in[y]&&out[x]>=in[y]) return dep[y]-dep[x]>2;\n\tif(fa[x]==fa[y]) return 0;\n\treturn 1;\n}\nvoid bfs() {\n\tint he=1,ta=1;\n\tvis[s1]=1,dis[s1]=0,que[1]=s1;\n\twhile(he<=ta) {\n\t\tint x=que[he];++he;\n\t\tfor(RI i=T1.h[x];i;i=T1.ne[i]) {\n\t\t\tif(dis[x]+1<dep[T1.to[i]]&&!vis[T1.to[i]])\n\t\t\t\tvis[T1.to[i]]=1,que[++ta]=T1.to[i];\n\t\t\t}\n\t}\n}\nint main()\n{\n\tint x,y;\n\tn=read(),s1=read(),s2=read();\n\tif(s1==s2) {puts(\"0\");return 0;}\n\tfor(RI i=1;i<n;++i) e1[i].x=read(),e1[i].y=read();\n\tfor(RI i=1;i<n;++i) x=read(),y=read(),T2.add(x,y),T2.add(y,x);\n\tdep[0]=-1,dfs(s2,0);\n\tfor(RI i=1;i<n;++i) {\n\t\tif(check(e1[i].x,e1[i].y)) win[e1[i].x]=win[e1[i].y]=1;\n\t\telse T1.add(e1[i].x,e1[i].y),T1.add(e1[i].y,e1[i].x);\n\t}\n\tbfs();\n\tfor(RI i=1;i<=n;++i)\n\t\tif(win[i]&&vis[i]) {puts(\"-1\");return 0;}\n\t\telse if(vis[i]) ans=max(ans,dep[i]+dep[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> par;\n\nconst int N=200010;\n\nint n,x,y,cnt,a[N],b[N],G[N];\nint fa[N][20];\nstruct edge{\n  int t,nx;\n}E[N<<2];\n\ninline void addedge(int x,int y){\n  E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n  E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n}\n\nint dpt[N];\n\nvoid dfs(int x,int f){\n  if(f) dpt[x]=dpt[f]+1;\n  fa[x][0]=f; for(int i=1;i<=18;i++) fa[x][i]=fa[fa[x][i-1]][i-1];\n  for(int i=G[x];i;i=E[i].nx)\n    if(E[i].t!=f) dfs(E[i].t,x);\n}\n\nnamespace Grp{\n  int cnt,G[N];\n  struct edge{\n    int t,nx;\n  }E[N<<1];\n\n  inline void addedge(int x,int y){\n    E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n    E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n  }\n}\n\nqueue<int> Q;\nint dis[N],mark[N];\n\nconst int inf=1<<29;\n\ninline void bfs(){\n  for(int i=1;i<=n;i++) dis[i]=inf;\n  Q.push(x); dis[x]=0;\n  while(!Q.empty()){\n    int x=Q.front(); Q.pop();\n    for(int i=Grp::G[x];i;i=Grp::E[i].nx){\n      int v=Grp::E[i].t;\n      if(dis[v]!=inf) continue;\n      dis[v]=dis[x]+1; Q.push(v);\n    }\n  }\n}\n\ninline int lca(int x,int y){\n  if(dpt[x]<dpt[y]) swap(x,y);\n  for(int i=18;~i;i--)\n    if(dpt[fa[x][i]]>=dpt[y]) x=fa[x][i];\n  if(x==y) return x;\n  for(int i=18;~i;i--)\n    if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n  return fa[x][0];\n}\n\ninline int dist(int x,int y){\n  return dpt[x]+dpt[y]-2*dpt[lca(x,y)];\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d\",&a[i],&b[i]);\n  for(int i=1,u,v;i<n;i++)\n    scanf(\"%d%d\",&u,&v),addedge(u,v);\n  dfs(y,0); dpt[0]=-1;\n  for(int i=1;i<n;i++)\n    if(dist(a[i],b[i])>2) mark[a[i]]=mark[b[i]]=1;\n    else Grp::addedge(a[i],b[i]);\n  bfs(); int ans=0;\n  for(int i=1;i<=n;i++){\n    if(mark[i] && dis[i]<dpt[i]) return puts(\"-1\"),0;\n    if(dis[i]<=dpt[i]) ans=max(ans,dpt[i]*2);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\ntypedef pair<int,int> pii;\nint n, x, y, dep[200005], par[20][200005];\nint da[200005], db[200005];\n\nvector<int> ra[200005], rb[200005];\nvector<pii> red;\n\nqueue<int> q;\n\nvoid calc (int cur, int prv) {\n\tdep[cur] = dep[prv] + 1;\n\tpar[0][cur] = prv;\n\tfor(auto &nxt : rb[cur]) {\n\t\tif(nxt == prv) continue;\n\t\tcalc(nxt, cur);\n\t}\n}\n\nint getdist (int A, int B) {\n\tif(dep[A] < dep[B]) swap(A, B);\n\tint ret = 0;\n\tfor(int i=20;i--;) {\n\t\tif(dep[A] - dep[B] >= (1<<i)) {\n\t\t\tA = par[i][A]; ret += (1<<i);\n\t\t}\n\t}\n\tif(A == B) return ret;\n\tfor(int i=20;i--;) {\n\t\tif(par[i][A] != par[i][B]) {\n\t\t\tA = par[i][A]; B = par[i][B];\n\t\t\tret += (1<<i) * 2;\n\t\t}\n\t}\n\treturn ret + 2;\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tred.push_back({A, B});\n\t\tra[A].push_back(B);\n\t\tra[B].push_back(A);\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\trb[A].push_back(B);\n\t\trb[B].push_back(A);\n\t}\n\tcalc(1, 0);\n\tfor(int k=1;k<20;k++) {\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tpar[k][i] = par[k-1][par[k-1][i]];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {da[i] = inf; db[i] = inf;}\n\tdb[y] = 2; q.push(y);\n\twhile(!q.empty()) {\n\t\tint cur = q.front(); q.pop();\n\t\tfor(auto &nxt : rb[cur]) {\n\t\t\tif(db[nxt] == inf) {\n\t\t\t\tdb[nxt] = db[cur] + 2;\n\t\t\t\tq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\tda[x] = 1; q.push(x);\n\twhile(!q.empty()) {\n\t\tint cur = q.front(); q.pop();\n\t\tfor(auto &nxt : ra[cur]) {\n\t\t\tif(da[nxt] == inf && db[nxt] > da[cur] + 3) {\n\t\t\t\tda[nxt] = da[cur] + 2;\n\t\t\t\tq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto &T : red) {\n\t\tint A = T.first, B = T.second;\n\t\tif(getdist(A, B) >= 3 && (da[A] != inf || da[B] != inf)) {\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(da[i] != inf) ans = max(ans, db[i]);\n\t}\n \tprintf(\"%d\\n\",ans-2);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint n;\nvvi s, t;\nvi ds, dt;\n\n// LCA (0-indexed)\nstruct LCA {\n  int n, bi;\n  vi dep;\n  vector<vi> to, par;\n  LCA(int n):n(n),dep(n),to(n){}\n  void add(int a, int b){ to[a].pb(b); to[b].pb(a);}\n  void calcDep(int v, int ndep=0, int p=-1){\n    dep[v] = ndep; par[0][v] = p;\n    for(int u : to[v]) if(u != p) calcDep(u,ndep+1,v);\n  }\n  void init(){\n    bi = 0;\n    while(1<<bi <= n) bi++;\n    par.resize(bi,vi(n,-1));\n    calcDep(0);\n    rep(i,bi-1)rep(j,n) par[i+1][j] = (par[i][j]==-1?-1:par[i][par[i][j]]);\n  }\n  int lca(int a, int b){\n    if(dep[a] < dep[b]) swap(a,b);\n    int x = dep[a]-dep[b];\n    for(int i = bi-1; i >= 0; --i){\n      if(1<<i <= x) a = par[i][a], x -= 1<<i;\n    }\n    if(a == b) return a;\n    for(int i = bi-1; i >= 0; --i){\n      if(par[i][a] != par[i][b]) a = par[i][a], b = par[i][b];\n    }\n    return par[0][a];\n  }\n  int dist(int a, int b){\n    int c = lca(a,b);\n    return dep[a]+dep[b] - dep[c]*2;\n  }\n};\n//\n\nvoid bfs(vvi& g, vi& d, int sv) {\n  d[sv] = 0;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == INF) {\n        d[u] = d[v]+1;\n        q.push(u);\n      }\n    }\n  }\n}\nvoid cfs(vvi& g, vi& d, int sv) {\n  if (d[sv] != 1) return;\n  d[sv] = 2;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == 1) {\n        d[u] = 2;\n        q.push(u);\n      }\n    }\n  }\n}\n\nint main() {\n  puts(\"-1\"); return 0;\n  scanf(\"%d\",&n);\n  int x, y;\n  scanf(\"%d%d\",&x,&y);\n  --x; --y;\n  s = t = vvi(n);\n  LCA g(n);\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    s[a].pb(b);\n    s[b].pb(a);\n  }\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    t[a].pb(b);\n    t[b].pb(a);\n    g.add(a,b);\n  }\n  g.init();\n  ds = dt = vi(n,INF);\n  bfs(s,ds,x);\n  bfs(t,dt,y);\n  int ans = 0;\n  vi c(n);\n  rep(i,n) if (ds[i] < dt[i]) c[i] = 1;\n  cfs(s,c,x);\n  rep(i,n) {\n    if (c[i] != 2) continue;\n    maxs(ans, dt[i]*2);\n    for (int u : s[i]) {\n      if (c[u] != 2) continue;\n      if (g.dist(i,u) >= 3) {\n        puts(\"-1\");\n        return 0;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(2e5) + 9;\n\nint n, x, y;\n\nstruct Tree{\n    vector<int> adj[N];\n    int d[N], p[N];\n    \n    void dfs(int u, int p = -1){\n        for (auto v: adj[u]){\n            if (v == p) continue;\n            d[v] = d[u] + 1; this->p[v] = u;\n            dfs(v, u);\n        }\n    }\n    void in(){\n        DO(n-1){\n            int x, y; RD(x, y); --x, --y;\n            adj[x].PB(y);\n            adj[y].PB(x);\n        }\n    }\n} R, B;\n\nint z;\n\nbool dfs(int u, int p = -1){\n    if (B.d[u] <= R.d[u]) return false;\n    for (auto v: R.adj[u]){\n        if (v == p) continue;\n        if (!(v == B.p[u] || B.p[v] == u || B.p[B.p[u]] == v || B.p[B.p[v]] == u || B.p[u] == B.p[v])) return true;\n        R.d[v] = R.d[u] + 1;\n        if (dfs(v, u)) return true;\n    }\n    checkMax(z, B.d[u]*2);\n    return false;\n}\n\nint gao(){\n    RD(n, x, y); --x, --y; R.in(); B.in(); B.dfs(y);\n    z = 0; if (dfs(x)) return -1;\n    return z;\n}\n\nint main(){\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users//desktop/Exercise/out.txt\", \"w\", stdout);\n#endif\n    \n    OT(gao());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=200005;\n\nint n,cnt,last[N],fa[N],dep[N],dis[N],q[N],dfn[N],mx[N],tim,a[N][2],sx,sy;\nbool vis[N],win[N];\nstruct edge{int to,next,col;}e[N*4];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid addedge(int u,int v,int col)\n{\n\te[++cnt].to=v;e[cnt].col=col;e[cnt].next=last[u];last[u]=cnt;\n\te[++cnt].to=u;e[cnt].col=col;e[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n\tdep[x]=dep[fa[x]]+1;dfn[x]=++tim;\n\tfor (int i=last[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa[x]) fa[e[i].to]=x,dfs(e[i].to);\n\tmx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n\tif (dfn[x]>dfn[y]) swap(x,y);\n\tif (dfn[x]<dfn[y]&&mx[x]>dfn[y]) return dep[y]-dep[x]>2;\n\tif (fa[x]==fa[y]) return 0;\n\treturn 1;\n}\n\nvoid bfs()\n{\n\tint h=1,t=1;q[1]=sx;vis[sx]=1;\n\twhile (h<=t)\n\t{\n\t\tint x=q[h++];\n\t\tfor (int i=last[x];i;i=e[i].next)\n\t\t\tif (!e[i].col&&!vis[e[i].to])\n\t\t\t{\n\t\t\t\tdis[e[i].to]=dis[x]+1;\n\t\t\t\tif (dis[e[i].to]<dep[e[i].to]) vis[e[i].to]=1,q[++t]=e[i].to;\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();sx=read();sy=read();\n\tfor (int i=1;i<n;i++) a[i][0]=read(),a[i][1]=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\taddedge(x,y,1);\n\t}\n\tdfs(sy);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tif (check(a[i][0],a[i][1])) win[a[i][0]]=win[a[i][1]]=1;\n\t\telse addedge(a[i][0],a[i][1],0);\n\t}\n\tbfs();\n\tfor (int i=1;i<=n;i++) if (win[i]&&vis[i]) {puts(\"-1\");return 0;}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) if (vis[i]) ans=max(ans,dep[i]*2-2);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf(x) (ll)(1e##x)\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nint u[N],v[N],d[N],tag[N],n,X,Y;\nclass graph{\npublic:\n\tvector<int> e[N];\n\tint dep[N],fa[20][N];\n\tvoid add(int x,int y){e[x].push_back(y);}\n\tvoid dfs(int x,int dad){\n\t\tdep[x]=dep[dad]+1;fa[0][x]=dad;\n\t\tfor(int v:e[x]) if(v!=dad) dfs(v,x);\n\t}\n\tvoid build(){\n\t\tfor(int i=1;i<=18;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tfa[i][j]=fa[i-1][fa[i-1][j]];\n\t}\n\tint lca(int x,int y){\n\t\tif(dep[x]<dep[y]) swap(x,y);\n\t\tfor(int k=dep[x]-dep[y],i=0;k;k>>=1,i++)\n\t\t\tif(k&1) x=fa[i][x];\n\t\tif(x==y) return x;\n\t\tfor(int i=18;~i;i--)\n\t\t\tif(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];\n\t\treturn fa[0][x];\n\t}\n\tint dis(int u,int v){return dep[u]+dep[v]-2*dep[lca(u,v)];}\n}g1,g2;\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int ,int> > > q;\nint main(){\n\tread(n);read(X);read(Y);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x);read(y);\n\t\tg1.add(x,y);g1.add(y,x);\n\t\tu[i]=x;v[i]=y;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x);read(y);\n\t\tg2.add(x,y);g2.add(y,x);\n\t}\n\tg2.dfs(Y,0);g2.build();\n\tfor(int i=1;i<n;i++)\n\t\tif(g2.dis(u[i],v[i])>2) tag[u[i]]=tag[v[i]]=1;\n\tmemset(d,63,sizeof(d));d[X]=0;\n\tq.push(make_pair(0,X));\n\twhile(!q.empty()){\n\t\tint u=q.top().second,dis=q.top().first;q.pop();\n\t\tif(dis>d[u]) continue;\n\t\tif(d[u]+1>=g2.dep[u]) continue;\n\t\tfor(int v:g1.e[u]) if(d[v]>d[u]+1){\n\t\t\td[v]=d[u]+1;\n\t\t\tq.push(make_pair(d[v],v));\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(tag[i]&&d[i]+1<g2.dep[i]){cout<<-1<<'\\n';return 0;}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[i]+1<=g2.dep[i]) ans=max(ans,g2.dep[i]*2-2);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int mlog = 18;\nint n,a,b;\nvector<int> way1[maxn], way2[maxn];\nint depA[maxn], depB[maxn];\nint par[maxn][20];\nint good[maxn];\nint loop, ans;\nvoid build(int u, int last) {\n    par[u][0] = last;\n    for(int i=1;i<=mlog;i++) par[u][i] = par[par[u][i-1]][i-1];\n    for(auto v : way2[u]) {\n        if(v==last) continue;\n        depB[v] = depB[u] + 1;\n        build(v, u);\n    }\n}\nvoid dfs(int u, int last) {\n    if(depB[u]<=depA[u]) return ;\n    if(good[u]) loop = 1;\n    else ans = max(ans, depB[u]*2);\n    for(auto v : way1[u]) {\n        if(v==last) continue;\n        depA[v] = depA[u] + 1;\n        dfs(v, u);\n    }\n}\nint lca(int u, int v) {\n    int res = 0;\n    if(depB[u]<depB[v]) swap(u,v);\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i] && depB[par[u][i]]>=depB[v]) {\n            u = par[u][i];\n            res += (1<<i);\n        }\n    }\n    if(u==v) return res;\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i]!=par[v][i]) {\n            u = par[u][i]; v = par[v][i];\n            res += (1<<i)*2;\n        }\n    }\n    return res+2;\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way1[u].push_back(v);\n        way1[v].push_back(u);\n    }\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way2[u].push_back(v);\n        way2[v].push_back(u);\n    }\n    build(b,0);\n    for(int u=1;u<=n;u++) {\n        for(auto v : way1[u]) {\n            if(lca(u,v)>=3) {\n                good[u] = good[v] = 1;\n            }\n        }\n    }\n//    for(int u=1;u<=n;u++) printf(\"%d : %d\\n\",u,good[u]);\n    dfs(a,0);\n    if(loop) printf(\"-1\");\n    else printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <bits/stdc++.h>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=1000000+10;\n\nstruct Tree {\n    struct edge { int v,nxt; } e[N<<1];\n    int head[N];\n    inline void addEdge(int u,int v) {\n        static int cnt=0;\n        e[++cnt]=(edge){v,head[u]},head[u]=cnt;\n    }\n\n    int dep[N],sz[N],fa[N],hson[N],top[N];\n    inline void dfs1(int u,int f) {\n        dep[u]=dep[fa[u]=f]+1,sz[u]=1;\n        for (re int i=head[u];i;i=e[i].nxt) {\n            int v=e[i].v; if (v==f) continue;\n            dfs1(v,u),sz[u]+=sz[v];\n            if (sz[v]>sz[hson[u]]) hson[u]=v;\n        }\n    }\n    inline void dfs2(int u,int anc) {\n        top[u]=anc;\n        if (hson[u]) dfs2(hson[u],anc);\n        for (re int i=head[u];i;i=e[i].nxt)\n            if (e[i].v!=fa[u]&&e[i].v!=hson[u]) dfs2(e[i].v,e[i].v);\n    }\n    \n    inline int getlca(int u,int v) {\n        while (top[u]!=top[v]) {\n            if (dep[top[u]]<dep[top[v]]) swap(u,v);\n            u=fa[top[u]];\n        }\n        return dep[u]<dep[v]?u:v;\n    }\n    inline int getdis(int u,int v) {\n        int t=getlca(u,v);\n        return dep[u]+dep[v]-(dep[t]<<1);\n    }\n} A,B;\n\nint n,x,y,vis[N];\n\ninline void bfs() {\n    queue<int> Q; vis[x]=1,Q.push(x);\n    while (!Q.empty()) {\n        int u=Q.front(); Q.pop();\n        for (re int i=A.head[u];i;i=A.e[i].nxt) {\n            int v=A.e[i].v; if (vis[v]) continue;\n            if (A.dep[v]<B.dep[v]) vis[v]=1,Q.push(v);\n        }\n    }\n}\n\nint main() {\n    n=read(),x=read(),y=read();\n    for (re int i=1;i<n;++i) {\n        int u=read(),v=read();\n        A.addEdge(u,v),A.addEdge(v,u);\n    }\n    for (re int i=1;i<n;++i) {\n        int u=read(),v=read();\n        B.addEdge(u,v),B.addEdge(v,u);\n    }\n    A.dfs1(x,0),A.dfs2(x,x); B.dfs1(y,0),B.dfs2(y,y);\n    bfs(); int ans=0;\n    for (re int u=1;u<=n;++u) {\n        if (!vis[u]) continue;\n        for (re int i=A.head[u];i;i=A.e[i].nxt) {\n            int v=A.e[i].v;\n            if (B.getdis(u,v)>2) { puts(\"-1\"); return 0; }\n        }\n        ans=max(ans,B.dep[u]-1);\n    }\n    printf(\"%d\\n\",ans<<1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define YYS(x, arr) for(auto& x: arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1e9 + 7;\n\ntemplate<class T> T &chmin(T &a, const T &b){return a = min(a, b);}\ntemplate<class T> T &chmax(T &a, const T &b){return a = max(a, b);}\ntemplate<class T> void UNIQUE(vector<T> &a){a.erase(unique(a.begin(), a.end()), a.end());}\n\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\" << endl; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; assert(scanf(\"%lld\", &x) == 1); return x;}\nld fin(){double x; assert(scanf(\"%lf\", &x) == 1); return x;}\nchar yuyushiki[10000010]; string stin(){assert(scanf(\"%s\", yuyushiki) == 1); return yuyushiki;}\n\n// head\n\nvector<int> G[200010];\nvector<int> H[200010];\n\nint distG[200010];\nint distH[200010];\nint par[200010][20];\n\nvoid dfs1(int x, int p = -1, int d = 0){\n  distG[x] = d;\n  YYS(w, G[x]){\n    if(w == p){\n      continue;\n    }\n    dfs1(w, x, d+1);\n  }\n}\n\nvoid dfs2(int x, int p = -1, int d = 0){\n  distH[x] = d;\n  par[x][0] = p;\n  YYS(w, H[x]){\n    if(w == p){\n      continue;\n    }\n    dfs2(w, x, d+1);\n  }\n}\n\nint lca(int a, int b){\n  if(distH[a] > distH[b]){\n    swap(a, b);\n  }\n  for(int i = 19; i >= 0; i--){\n    if((distH[b] - distH[a]) & PW(i)){\n      b = par[b][i];\n    }\n  }\n  if(a == b){\n    return a;\n  }\n  for(int i = 19; i >= 0; i--){\n    if(par[a][i] != par[b][i]){\n      a = par[a][i];\n      b = par[b][i];\n    }\n  }\n  return par[a][0];\n}\n\nint dist(int a, int b){\n  return distH[a] + distH[b] - 2 * distH[lca(a, b)];\n}\n\nint ans;\n\nvoid dfs3(int x, int p = -1){\n  chmax(ans, 2 * distH[x]);\n  YYS(w, G[x]){\n    if(w == p){\n      continue;\n    }\n    if(distG[w] <= distH[w]){\n      if(dist(x, w) >= 3){\n        ans = INF;\n      }\n      dfs3(w, x);\n    }\n  }\n}\n\nint main(){\n\n  int n = in();\n  int x = in() - 1;\n  int y = in() - 1;\n  REP(i, n-1){\n    int a = in() - 1;\n    int b = in() - 1;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  REP(i, n-1){\n    int a = in() - 1;\n    int b = in() - 1;\n    H[a].pb(b);\n    H[b].pb(a);\n  }\n\n  dfs1(x);\n  dfs2(y);\n\n  FOR(i, 1, 20){\n    REP(j, n){\n      if(par[j][i-1] == -1){\n        par[j][i] = -1;\n      } else {\n        par[j][i] = par[par[j][i-1]][i-1];\n      }\n    }\n  }\n\n  dfs3(x);\n\n  if(ans == INF){\n    ans = -1;\n  }\n  \n  cout << ans << endl;\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int lg = 20;\nvector<int> red[N];\nvector<int> blue[N];\nint h[N];\nint par[lg + 5][N];\nint n, x, y;\nbool winPos[N];\nint disR[N];\nint disB[N];\n\n\nvoid dfs(int v = 0, int p = -1)\n{\n    for (int u : blue[v])\n    {\n        if (u != p)\n        {\n            par[0][u] = v;\n            h[u] = h[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nvoid pre()\n{\n    for (int k = 1; k < lg; k++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            par[k][i] = par[k - 1][ par[k - 1][i] ];\n        }\n    }\n}\n\nint lca(int v, int u)\n{\n    if(h[v] > h[u])\n    {\n        swap(v, u);\n    }\n    for (int i = 0; i < lg; i++)\n    {\n        if (h[u] - h[v] >> i & 1)\n        {\n            u = par[i][u];\n        }\n    }\n    for (int i = lg - 1; i >= 0; i--)\n    {\n        if(par[i][v] != par[i][u])\n        {\n            v = par[i][v], u = par[i][u];\n        }\n    }\n    return v == u ? v : par[0][v];\n}\n\nvoid dfs1(int v, int par = -1)\n{\n    if (disR[v] > disB[v])\n    {\n        return;\n    }\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disR[u] = disR[v] + 1;\n            dfs1(u, v);\n        }\n    }\n}\n\nvoid dfs2(int v, int par = -1)\n{\n    for (auto u: blue[v])\n    {\n        if (u != par)\n        {\n            disB[u] = disB[v] + 1;\n            dfs2(u, v);\n        }\n    }\n}\n\n\n\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        red[u - 1].push_back(v - 1);\n        red[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        blue[u - 1].push_back(v - 1);\n        blue[v - 1].push_back(u - 1);\n    }\n    dfs();\n    pre();\n    for (int i = 0; i < n; i++)\n    {\n        for (auto u: red[i])\n        {\n            int tmp = lca(u, i);\n            if (h[u] - h[tmp] + h[i] - h[tmp] > 2)\n            {\n                winPos[i] = true;\n                winPos[u] = true;\n            }\n        }\n    }\n    memset(disR, 127, sizeof disR);\n    disR[x - 1] = 0;\n    dfs2(y - 1);\n    dfs1(x - 1);\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (winPos[i] && disR[i] <= disB[i])\n        {\n            cout << -1 << endl;\n            exit(0);\n        }\n        if (disR[i] < N)\n        {\n            //cout << endl;\n            //cout << i << \" \" << disB[i] << endl;\n            ans = max(ans, disB[i] * 2);\n        }\n    }\n    //cout << (1 << 20) << endl;\n    cout << ans << endl;\n\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,X,Y,fa[N],dep[N],ans;\nvi g[N],f[N];\nbool tag[N];\n\ninline bool large(int x,int y){\n\tif(dep[x]>dep[y]) swap(x,y);\n\treturn fa[x]!=fa[y]&&fa[y]!=x&&fa[fa[y]]!=x;\n}\ninline void dfs(int x,int F=0){\n\tfor(int y:g[x])\n\t\tif(y!=F){\n\t\t\tdep[y]=dep[x]+1;fa[y]=x;\n\t\t\tdfs(y,x);\n\t\t}\n}\ninline void dfs2(int x,int F=0,int d=0){\n\tif(d<=dep[x]) gmax(ans,dep[x]);\n\tif(d>=dep[x]) return;\n\tif(tag[x]){puts(\"-1\");exit(0);}\n\tfor(int y:f[x])\n\t\tif(y!=F) dfs2(y,x,d+1);\n}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tf[x].pb(y);f[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\tdfs(Y);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j:f[i])\n\t\t\tif(large(i,j)) tag[i]=1;\n\tdfs2(X);\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define Rep(i,a) for(int i = 0; i < a; i++)\nusing namespace std;\nconst int N = 1e5 + 10;\n\nstruct edge{ int to, pre; } e[N << 1]; int l = 0, u[N];\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint n, X, Y, a[N], b[N], dep[N], fa[N];\n\nvoid dfs(int x, int f) {\n\treg(i,x) if (v != f) dep[v] = dep[x] + 1, fa[v] = x, dfs(v, x);\n}\n\nbool jump(int a, int b) {\n\tif (dep[a] < dep[b]) swap(a, b);\n\tif (fa[a] == b || fa[fa[a]] == b || fa[a] == fa[b]) return false;\n\telse return true;\n}\n\nvector<int> adj[N];\n#define pb(a) push_back(a)\n\nbool inf = false, win[N];\nint ans = 0;\nvoid chk(int x, int f, int d) {\n\tif (d >= dep[x]) return; else ans = max(ans, dep[x]);\n\tinf |= win[x]; int l = adj[x].size();\n\tRep(j,l) if (adj[x][j] != f) chk(adj[x][j], x, d + 1);\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\trep(i,1,n - 1) scanf(\"%d%d\",a + i,b + i);\n\trep(i,1,n - 1) {\n\t\tint a, b; scanf(\"%d%d\",&a,&b);\n\t\tins(a, b), ins(b, a);\n\t}\n\tdfs(Y, 0);\n\trep(i,1,n - 1) \n\t\tif (!jump(a[i], b[i])) \n\t\t\tadj[a[i]].pb(b[i]), adj[b[i]].pb(a[i]);\n\t\telse win[a[i]] = win[b[i]] = true;\n\tchk(X, 0, 0);\n\tif (inf) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans * 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5e3+7, K = 18;\n\nstruct Tree{\n    vector<int> adj[N];\n\n    int anc[N][K];\n    int level[N];\n    bool mark[N];\n    int dis[N];\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    void setup(int u, int par) {\n        level[u] = level[par]+1;\n        anc[u][0] = par;\n        for (int k=1; k<K; k++)     anc[u][k] = anc[anc[u][k-1]][k-1];\n\n        for (int v: adj[u]) {\n            if (v == par)   continue;\n            setup(v, u);\n        }\n    }\n\n    int lca(int u, int v) {\n        if (level[u] > level[v])    swap(u, v);\n        for (int k=K-1; k>=0; k--)\n            if (level[u] + (1<<k) <= level[v])  v = anc[v][k];\n\n        if (u == v) return u;\n        for (int k=K-1; k>=0; k--)\n            if (anc[u][k] != anc[v][k])\n                u = anc[u][k], v = anc[v][k];\n        return anc[u][0];\n    }\n\n    int getanc(int u, int d) {\n        for (int k=0; k<K; k++)\n            if (d & (1<<k))\n                u = anc[u][k];\n        return u;\n    }\n\n    int dist(int u, int v) {\n        int g = lca(u, v);\n        return level[u] + level[v] - 2*level[g];\n    }\n\n    int solve(int u, int par, int dep) {\n        if (dis[u] <= dep)  return 0;\n        if (mark[u])        return N;\n        int ans = dis[u];\n        for (int v: adj[u]) {\n            if (v == par)   continue;\n            ans = max(solve(v, u, dep+1), ans);\n        }\n        return ans;\n    }\n};\n\n\n///Given u, v, d per query find dth node (0 indexed) on path from u to v.\n///https://codeforces.com/gym/102694/problem/C\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin>>n;\n\n    int x, y;\n    cin>>x>>y;\n\n    Tree red, blue;\n\n    for (int i=1; i<n; i++) {\n        int u, v;\n        cin>>u>>v;\n        red.addEdge(u, v);\n    }\n\n    for (int i=1; i<n; i++) {\n        int u, v;\n        cin>>u>>v;\n        blue.addEdge(u, v);\n    }\n\n    red.setup(1, 0);\n    blue.setup(1, 0);\n\n    for (int i=1; i<=n; i++) {\n        bool found = false;\n        for (int v: red.adj[i]) {\n            if (blue.dist(i, v) >= 3)   found = true;\n        }\n        red.mark[i] = found;\n        red.dis[i] = blue.dist(y, i);\n    }\n    int ans = red.solve(x, 0, 0);\n    if (ans == N)   ans = -1;\n    else            ans *= 2;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define MAXN 200010\n#define INF 0x3f3f3f3f\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint Bdj[MAXN],Vb[MAXN*2],nxtb[MAXN*2],cb;\nvoid Add(int u,int v)\n{\n\tcb++;Vb[cb]=v,nxtb[cb]=Bdj[u];Bdj[u]=cb;\n}\nint n,rt,s,ans;\nint dep[MAXN],fa[MAXN],e[MAXN][2],lon[MAXN],vis[MAXN];\nvoid dfs(int u)\n{\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=fa[u])\n\t\t{\n\t\t\tdep[V[i]]=dep[u]+1;\n\t\t\tfa[V[i]]=u;\n\t\t\tdfs(V[i]);\n\t\t}\n}\nint dis[MAXN];\nqueue<int>Q;\nvoid bfs()\n{\n\tdis[s]=0;\n\tvis[s]=1;\n\tQ.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=Bdj[u];i;i=nxtb[i])\n\t\t\tif(!vis[Vb[i]])\n\t\t\t{\n\t\t\t\tdis[Vb[i]]=dis[u]+1;\n\t\t\t\tif(dis[Vb[i]]<dep[Vb[i]])\n\t\t\t\t{\n\t\t\t\t\tvis[Vb[i]]=1;\n\t\t\t\t\tQ.push(Vb[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n}\nint check(int u,int v)\n{\n\tif(dep[u]<dep[v]) swap(u,v);\n\tint k=dep[u]-dep[v];\n\tif(k==0) return fa[u]!=fa[v];\n\tif(k==1) return fa[u]!=v;\n\tif(k==2) return fa[fa[u]]!=v;\n\treturn 1;\n}\nvoid Clear()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tAdj[i]=Bdj[i]=vis[i]=lon[i]=0;\n\tc=cb=0;\n\tans=0;\n}\nvoid Read(int &x)\n{\n\tx=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n}\nint main()\n{\n//\tfreopen(\"coalesce.in\",\"r\",stdin);\n//\tfreopen(\"coalesce.out\",\"w\",stdout);\n\tscanf(\"%d%d%d\",&n,&s,&rt);\n\tint u,v,flag=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tRead(e[i][0]);\n\t\tRead(e[i][1]);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tRead(u);Read(v);\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tif(s==rt)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tdfs(rt);\n\tfor(int i=1;i<n;i++)\n\t\tif(check(e[i][0],e[i][1]))\n\t\t\tlon[e[i][0]]=lon[e[i][1]]=1;\n\t\telse Add(e[i][0],e[i][1]),Add(e[i][1],e[i][0]);\n\tbfs();\n\tfor(int i=1;i<=n;i++)\n\t\tif(vis[i]&&lon[i])\n\t\t{\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\telse if(vis[i])\n\t\t\tans=max(ans,dep[i]);\n\tif(flag) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans*2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nusing namespace std;\nint n,x,y,f[200010][25],h[200010];\nvector<int> a[200010],b[200010];\nmap<L,bool> g;\ninline void dfs(int i)\n{\n\tint j;\n\tfor(j=1;j<=20;j++)\n\t  f[i][j]=f[f[i][j-1]][j-1];\n\tfor(j=0;j<b[i].size();j++)\n\t  if(b[i][j]!=f[i][0])\n\t    {\n\t\t f[b[i][j]][0]=i;\n\t\t h[b[i][j]]=h[i]+1;\n\t\t dfs(b[i][j]);\n\t\t}\n}\ninline bool check(int x,int y)\n{\n\treturn x==y || f[x][0]==y || f[y][0]==x;\n}\ninline void lca(int x,int y,int &i,int &j)\n{\n\tint a=x,b=y,k;\n\tif(h[a]>h[b])\n\t  {\n\t   for(k=20;k>=0;k--)\n\t     if(h[a]-(1<<k)>=h[b])\n\t       a=f[a][k];\n\t   if(a==b)\n\t     {\n\t\t  i=f[x][0];\n\t\t  j=h[x]-h[y]-1;\n\t\t  return;\n\t\t }\n\t  }\n\tif(h[a]<h[b])\n\t  {\n\t   for(k=20;k>=0;k--)\n\t     if(h[b]-(1<<k)>h[a])\n\t       b=f[b][k];\n\t   if(f[b][0]==a)\n\t     {\n\t\t  i=b;\n\t\t  j=h[y]-h[x]-1;\n\t\t  return;\n\t\t }\n\t   b=f[b][0];\n\t  }\n\tfor(k=20;k>=0;k--)\n\t  if(f[a][k]!=f[b][k])\n\t    a=f[a][k],b=f[b][k];\n\ti=f[x][0];\n\tj=h[x]+h[y]-h[a]-h[b]+1;\n}\ninline int dfs(int x,int y)\n{\n\tif(g[(L)x*n+y])\n\t  return -1;\n\tg[(L)x*n+y]=1;\n\tif(check(x,y))\n\t  {\n\t   int i,j,k=2;\n\t   for(i=0;i<a[x].size();i++)\n\t     if(!check(a[x][i],y))\n\t       {\n\t\t\tj=dfs(a[x][i],y);\n\t\t\tif(j==-1)\n\t\t\t  return -1;\n\t\t\tk=max(k,j);\n\t\t   }\n\t   return k;\n\t  }\n\telse\n\t  {\n\t   int i,j,k;\n\t   lca(x,y,i,j);\n\t   k=dfs(x,i);\n\t   if(k==-1)\n\t     return -1;\n\t   return k+2*j;\n\t  }\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   a[j].pb(k);\n\t   a[k].pb(j);\n\t  }\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   b[j].pb(k);\n\t   b[k].pb(j);\n\t  }\n\tdfs(1);\n\tprintf(\"%d\\n\",dfs(x,y));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define nn 65536*4\n#define lf double\nvector<int> va[nn],vb[nn];\nvector<pair<int,int> >ea;\nint dep[nn];int n;int sa,sb;\nint pa[nn];\nvoid dfs(int x,int p)\n{\n\tpa[x]=p;\n\tfor(int i=0;i<vb[x].size();i++)\n\t{\n\t\tif(vb[x][i]==p) continue;\n\t\tdep[vb[x][i]]=dep[x]+1;\t\t\n\t\tdfs(vb[x][i],x);\n\t}\n}\nint vis[nn];\nvoid bfs(int st)\n{\n\tqueue<int> q,cq;\n\tvis[st]=1;q.push(st);\n\tint now=1;\n\twhile(q.size() or cq.size())\n\t{\n\t\tif(q.size()==0)\n\t\t{\n\t\t\tswap(cq,q);\n\t\t\tnow++;\n\t\t}\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=0;i<va[x].size();i++)\n\t\t{\n\t\t\tint y=va[x][i];if(vis[y]) continue;\n\t\t\tif(pa[y]==pa[x] or pa[y]==x or pa[x]==y or pa[pa[x]]==y or pa[pa[y]]==x)\n\t\t\t{\n\t\t\t\tif(dep[y]>now)\n\t\t\t\t\tvis[y]=1,cq.push(y);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&sa,&sb);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tva[x].push_back(y);va[y].push_back(x);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tvb[x].push_back(y);vb[y].push_back(x);\n\t}\n\tdfs(sb,0);//cout<<\"k\";\n\tbfs(sa);int ma=0;\n\tfor(int i=1;i<=n;i++) if(vis[i]) ma=max(ma,dep[i]);\n\tcout<<ma*2;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<2];\nint n,X,Y,home[N],home1[N],cnt=-1,dep[N],fa[N][25];\nbool vis[N];\nvoid add(int *home,int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k,int F){\n\tdep[k]=dep[F]+1;fa[k][0]=F;\n\tfor(int i=1;i<=20;i++) fa[k][i]=fa[fa[k][i-1]][i-1];\n\tfor(int i=home1[k];~i;i=e[i].next){\n\t\tif(e[i].k!=F){\n\t\t\tdfs(e[i].k,k);\n\t\t}\n\t}\n}\nint q[N][2];\nint get(int x,int y){\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int i=20;i>=0;i--){\n\t\tif(dep[fa[x][i]]>dep[y]) x=fa[x][i];\n\t}\n\treturn x;\n}\nint bfs(){\n\tq[0][0]=X;q[0][1]=Y;\n\tint tou=0,wei=1;\n\tfor(int i=0;;i++){\n\t\tif(tou==wei) return i+i;\n\t\tint g=tou;tou=wei;\n\t\tfor(int p=g;p<tou;p++){\n\t\t\tint k=q[p][0];\n\t\t\tif(vis[k]) return -1;\n\t\t\tfor(int j=home[k];~j;j=e[j].next){\n\t\t\t\tif(dep[e[j].k]<dep[q[p][1]]) continue;\n\t\t\t\tq[wei][0]=e[j].k;\n\t\t\t\tq[wei][1]=get(e[j].k,q[p][1]);\n\t\t\t\tif(q[wei][0]!=q[wei][1]) wei++;\n\t\t\t}\n\t\t\tq[wei][0]=k;\n\t\t\tq[wei][1]=get(k,q[p][1]);\n\t\t\tif(q[wei][0]!=q[wei][1]) wei++;\n\t\t}\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tmemset(home1,-1,sizeof(home1));\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(home,x,y);add(home,y,x);\n\t}\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(home1,x,y);add(home1,y,x);\n\t}\n\tdfs(Y,0);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint x=e[p].k,y=i;\n\t\t\tif(dep[x]<dep[y]) swap(x,y);\n\t\t\tif(fa[x][0]!=y&&fa[x][0]!=fa[y][0]&&fa[x][1]!=y) vis[x]=vis[y]=1; \n\t\t}\n\t}\n\tprintf(\"%d\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 200000\n#define K 18\nstruct edge{int nx,t;}e[MN*4+5];\nint A[MN+5],B[MN+5],en,fa[K][MN+5],d[MN+5],ans;\ninline void ins(int*h,int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nvoid pre(int x)\n{\n\tfor(int i=B[x];i;i=e[i].nx)if(e[i].t!=fa[0][x])\n\t\td[e[i].t]=d[fa[0][e[i].t]=x]+1,pre(e[i].t);\n}\nint lca(int x,int y)\n{\n\tif(d[x]<d[y])swap(x,y); \n\tint k=d[x]-d[y],i;\n\tfor(i=0;k;k>>=1,++i)if(k&1)x=fa[i][x];\n\tif(x==y)return x;\n\tfor(i=K;i--;)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\nvoid solve(int x,int y,int f,int p)\n{\n\tif(x==y)return;\n\tans=max(ans,d[x]+d[y]-d[lca(x,y)]*2+p);\n\tfor(int i=A[x];i;i=e[i].nx)if(e[i].t!=f&&e[i].t!=y)\n\t{\n\t\tif(d[x]+d[e[i].t]-d[lca(x,e[i].t)]*2>2)ans=2e9;\n\t\tif(lca(e[i].t,y)==y)\n\t\t{\n\t\t\tint t=e[i].t,k=d[t]-d[y]-1,j;\n\t\t\tfor(j=0;k;k>>=1,++j)if(k&1)t=fa[j][t];\n\t\t\tsolve(e[i].t,t,x,p+1);\n\t\t}\n\t\telse solve(e[i].t,fa[0][y],x,p+1);\n\t}\n}\nint main()\n{\n\tint n,x,y,i,j;\n\tn=read();x=read();y=read();\n\tfor(i=1;i<n;++i)ins(A,read(),read());\n\tfor(i=1;i<n;++i)ins(B,read(),read());\n\tpre(1);\n\tfor(i=1;i<K;++i)for(j=1;j<=n;++j)fa[i][j]=fa[i-1][fa[i-1][j]];\n\tsolve(x,y,0,0);\n\tprintf(\"%d\",ans>1e9?-1:ans<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nstruct T{ int to, nxt; } way[maxn << 2];\nint h0[maxn], h1[maxn], num;\ninline void link(int x,int y,int * h) {\n\tway[++num] = {y,h[x]}, h[x] = num;\n\tway[++num] = {x,h[y]}, h[y] = num;\n}\nint n, x, y;\nint fa[maxn], dep[maxn];\ninline void dfs0(int x,int f = 0) {\n\tfa[x] = f, dep[x] = dep[f] + 1;\n\tfor(int i = h1[x];i;i = way[i].nxt) if(way[i].to != f)\n\t\tdfs0(way[i].to, x);\n}\nint a[maxn], b[maxn];\nint import[maxn], vis[maxn];\ninline bool chk(int x,int y) {\n\tif(dep[x] > dep[y]) x = fa[x]; else y = fa[y];\n\tif(x == y) return 0;\n\tif(dep[x] > dep[y]) x = fa[x]; else y = fa[y];\n\treturn x != y;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> x >> y;\n\tfor(int i = 1;i < n;++i) cin >> a[i] >> b[i], link(a[i], b[i], h0);\n\tfor(int i = 1, x, y;i < n;++i) cin >> x >> y, link(x, y, h1);\n\tdfs0(y);\n\tfor(int i = 1;i < n;++i) if(chk(a[i], b[i])) import[a[i]] = import[b[i]] = 1;\n\tstd::queue<int> q; q.push(x); vis[x] = 1;\n\tint ans = dep[x];\n\tfor(;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tif(import[t]) return puts(\"-1\"), 0;\n\t\tfor(int i = h0[t];i;i = way[i].nxt) {\n\t\t\tif(!vis[way[i].to]) {\n\t\t\t\tvis[way[i].to] = vis[t] + 1;\n\t\t\t\tif(vis[way[i].to] <= dep[way[i].to]) {\n\t\t\t\t\tq.push(way[i].to);\n\t\t\t\t\tans = std::max(ans, dep[way[i].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::cout << ans * 2 - 2 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 210000\n#define pb push_back\nusing namespace std;\nstruct node{int y,nex;}a[2*N];\nint e[N][2],len,fir[N],n,sa,sb,dep[N],dfn[N],las[N],id,f[N],p[N],tail,d[N],ans;\nbool b[N],v[N];\nvector<int> A[N];\nvoid ins(int x,int y) { a[++len].y=y;a[len].nex=fir[x];fir[x]=len; }\nvoid dfs(int x,int fa) { f[x]=fa; dfn[x]=++id; dep[x]=dep[fa]+1; for(int k=fir[x];k;k=a[k].nex) { int y=a[k].y; if(y==fa) continue; dfs(y,x); } las[x]=id; }\nbool check(int x,int y) { if(dep[x]>dep[y]) swap(x,y); if(dfn[x]<=dfn[y] && las[x]>=dfn[y]) { if(dep[y]-dep[x]>2) return 1; return 0; } if(f[x]==f[y]) return 0; return 1; }\nvoid bfs() {\n    v[sa]=1;p[1]=sa;tail=1;\n    for(int i=1;i<=tail;i++) { int x=p[i],siz=A[x].size(); for(int k=0;k<siz;k++) { int y=A[x][k]; d[y]=d[x]+1; if(d[y]<dep[y] && v[y]==0) {v[y]=1;p[++tail]=y;} } }\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&sa,&sb); for(int i=1;i<n;i++) scanf(\"%d%d\",&e[i][0],&e[i][1]); for(int i=1;i<n;i++) { int x,y;scanf(\"%d%d\",&x,&y); ins(x,y);ins(y,x); }\n    dfs(sb,0); for(int i=1;i<=n;i++) dep[i]--;\n    for(int i=1;i<n;i++) { int x=e[i][0],y=e[i][1]; if(check(x,y)) b[x]=b[y]=1; else A[e[i][0]].pb(e[i][1]),A[e[i][1]].pb(e[i][0]); }\n    bfs(); for(int i=1;i<=n;i++) { if(v[i] && b[i]) {printf(\"-1\\n\");return 0;} if(v[i]) ans=max(ans,dep[i]*2); }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 200000 + 5;\n\nint N, X, Y, answer;\nvector<int> rAdj[MAXN], bAdj[MAXN];\nint fa[MAXN], dep[MAXN];\n\nclass noSolution : std::exception\n{\n\n};\n\nvoid findBlueFa(int cur, int pre) noexcept\n{\n\tfa[cur] = pre;\n\n\tfor (int to : bAdj[cur])\n\t\tif (to != pre)\n\t\t\tdep[to] = dep[cur] + 1, findBlueFa(to, cur);\n}\n\nbool isShortPath(int u, int v) noexcept\n{\n\tif (dep[u] < dep[v])\n\t\tswap(u, v);\n\n\tfor (int len = 0; len < 2; len++)\n\t{\n\t\tif (u == v)\n\t\t\tbreak;\n\n\t\tif (dep[u] < dep[v])\n\t\t\tv = fa[v];\n\t\telse\n\t\t\tu = fa[u];\n\t}\n\treturn (u == v);\n}\n\nvoid DFS(int cur, int pre = -1, int constrain = 0) //throw (solution)\n{\n\tanswer = max(answer, dep[cur]);\n\tif(dep[cur] <= constrain)\n\t\treturn;\n\n\tfor(int to : rAdj[cur])\n\t{\n\t\tif(to == pre)\n\t\t\tcontinue;\n\t\tif(!isShortPath(cur, to))\n\t\t\tthrow noSolution();\n\t\tDFS(to, cur, constrain + 1);\n\t}\n}\n\nint main()\n{\n\tint u, v;\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor(int i = 1; i < N; i++)\n\t\tscanf(\"%d%d\", &u, &v), rAdj[u].push_back(v), rAdj[v].push_back(u);\n\tfor(int i = 1; i < N; i++)\n\t\tscanf(\"%d%d\", &u, &v), bAdj[u].push_back(v), bAdj[v].push_back(u);\n\n\tfindBlueFa(Y, 0);\n\n\ttry\n\t{\n\t\tDFS(X);\n\t\tprintf(\"%d\\n\", answer * 2);\n\t}\n\tcatch (noSolution & x)\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int NN = 2e5 + 5;\nstruct E {\n\tint v, nxt;\n\tE(int _v=0, int _nxt=0) : v(_v), nxt(_nxt) {}\n};\nstruct Graph {\n\tint head[NN], totE;\n\tE edge[NN*2];\n\tvoid AddEdge(int u, int v) {\n\t\tedge[++totE] = E(v, head[u]);\n\t\thead[u] = totE;\n\t}\n} a, b;\nint N, X, Y, da[NN], db[NN], fab[NN];\nbool save[NN];\nvoid Dfs1(int u, int fr) {\n\tfab[u] = fr;\n\tdb[u] = db[fr] + 1;\n\tfor (int p = b.head[u]; p; p = b.edge[p].nxt) {\n\t\tint v = b.edge[p].v; //注意两棵树别用串了 \n\t\tif (v != fr)\n\t\t\tDfs1(v, u);\n\t}\n}\nbool inf;\nvoid Dfs2(int u, int fr) {\n\tda[u] = da[fr] + 1;\n\tif (da[u] >= db[u]) return ;\n\tsave[u] = 1;\n\tif (fr != 0) {\n\t\tint x = u, y = fr;\n\t\tif (db[x] < db[y])\n\t\t\tswap(x, y);\n\t\tif (fab[x] == fab[y] || fab[x] == y || fab[fab[x]] == y) ;\n\t\telse inf = 1;\n\t}\n\tfor (int p = a.head[u]; p; p = a.edge[p].nxt) {\n\t\tint v = a.edge[p].v;\n\t\tif (v != fr)\n\t\t\tDfs2(v, u);\n\t}\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ta.AddEdge(u, v);\n\t\ta.AddEdge(v, u);\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb.AddEdge(u, v);\n\t\tb.AddEdge(v, u);\n\t}\n\tDfs1(Y, 0);\n\tDfs2(X, 0);\n\tif (inf) printf(\"-1\\n\");\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tif (save[i])\n\t\t\t\tans = max(ans, db[i]-1);\n\t\tans *= 2;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define per(i, a, b) for(int i = a; i >= b; i--)\ntypedef long long LL;\nconst int maxn = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\nint n, x, y, first[maxn], dep[maxn], s[maxn][2], f[maxn][27], g[maxn], dis[maxn], cnt;\nbool vis[maxn];\nstruct Edge {\n\tint to, next, ser;\n} e[maxn<<2];\n\nvoid Dfs(int u, int fa) {\n\tdep[u] = dep[fa] + 1;\n\tf[u][0] = fa;\n\tg[u] = dep[u];\n\tfor(int i = first[u]; i; i = e[i].next) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || e[i].ser) continue;\n\t\tDfs(v, u);\n\t\tg[u] = max(g[v], g[u]);\n\t}\n}\n\nvoid add(int u, int v, int ser) {\n\te[++cnt] = (Edge) {v, first[u], ser};\n\tfirst[u] = cnt;\n}\n\nint Lca(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tint dif = dep[u] - dep[v];\n\tper(i, 25, 0)\n\t    if(dif >= (1<<i)) {\n\t    \tdif -= 1<<i;\n\t    \tu = f[u][i];\n\t    }\n\tper(i, 25, 0)\n\t    if(f[u][i] != f[v][i]) {\n\t    \tu = f[u][i];\n\t    \tv = f[v][i];\n\t    }\n\treturn f[u][0];\n}\n\n\nbool Bfs(int s) {\n\tmemset(dis, 0x7f, sizeof(dis));\n\tqueue <int> q;\n\tdis[s] = 0;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = first[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\tif(!e[i].ser || dis[u] + 1 >= dep[v] || dis[u] + 1 >= dis[v]) continue;\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\trep(i, 1, n)\n\t    if(dis[i] < dep[i] && vis[i]) return 1;\n\treturn 0;\n}\n\nint main() {\n\tcin>>n>>x>>y;\n\tint u, v;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 1);\n\t\tadd(v, u, 1);\n\t\ts[i][0] = u, s[i][1] = v;\n\t}\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 0);\n\t\tadd(v, u, 0);\n\t}\n\tdep[0] = -1;\n\tDfs(y, 0);\n\trep(k, 1, 25)\n\t    rep(i, 1, n) \n\t        f[i][k] = f[f[i][k - 1]][k - 1];\n\trep(i, 1, n - 1) {\n\t\tint d = Lca(s[i][0], s[i][1]);\n\t\tif(dep[s[i][0]] + dep[s[i][1]] - 2*dep[d] > 2) vis[s[i][0]] = vis[s[i][1]] = 1;\n\t} \n\tif(Bfs(x)) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\telse {\n\t\tint ans = 0;\n\t\trep(i, 1, n)\n\t\t    if(dis[i] < dep[i]) ans = max(ans, dep[i]);\n\t\tcout<<ans*2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nint n,X,Y;\nvector <int> er[N],eb[N];\nint depth[N],fa[N][20];\nint tag[N];\nvoid dfs1(int x,int pre,int d){\n\tdepth[x]=d,fa[x][0]=pre;\n\tfor (int i=1;i<20;i++)\n\t\tfa[x][i]=fa[fa[x][i-1]][i-1];\n\tfor (auto y : eb[x])\n\t\tif (y!=pre)\n\t\t\tdfs1(y,x,d+1);\n}\nint LCA(int x,int y){\n\tif (depth[x]<depth[y])\n\t\tswap(x,y);\n\tfor (int i=19;i>=0;i--)\n\t\tif (depth[x]-(1<<i)>=depth[y])\n\t\t\tx=fa[x][i];\n\tif (x==y)\n\t\treturn x;\n\tfor (int i=19;i>=0;i--)\n\t\tif (fa[x][i]!=fa[y][i])\n\t\t\tx=fa[x][i],y=fa[y][i];\n\treturn fa[x][0];\n}\nint Dis(int x,int y){\n\treturn depth[x]+depth[y]-2*depth[LCA(x,y)];\n}\nint vis[N],ans=0;\nvoid dfs(int x,int d){\n\tvis[x]=1;\n\tint k1=Dis(x,Y);\n\tif (d>=k1){\n\t\tans=max(ans,d*2-(d>k1));\n\t\treturn;\n\t}\n\tif (tag[x]){\n\t\tans=max(ans,10000000);\n\t\treturn;\n\t}\n\tans=max(ans,k1*2);\n\tfor (auto y : er[x])\n\t\tif (!vis[y])\n\t\t\tdfs(y,d+1);\n}\nint main(){\n\tn=read(),X=read(),Y=read();\n\tfor (int i=1;i<=n;i++)\n\t\ter[i].clear(),eb[i].clear();\n\tfor (int i=1;i<n;i++){\n\t\tint a=read(),b=read();\n\t\ter[a].push_back(b);\n\t\ter[b].push_back(a);\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tint a=read(),b=read();\n\t\teb[a].push_back(b);\n\t\teb[b].push_back(a);\n\t}\n\tdfs1(1,0,0);\n\tmemset(tag,0,sizeof tag);\n\tmemset(vis,0,sizeof vis);\n\tfor (int x=1;x<=n;x++)\n\t\tfor (auto y : er[x])\n\t\t\tif (Dis(x,y)>2)\n\t\t\t\ttag[x]=tag[y]=1;\n\tdfs(X,0);\n\tprintf(\"%d\",ans<2e6?ans:-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\nusing namespace std;\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1],e2[MAXN<<1];\n\nint n,x1,x2;\nint g[MAXN],nume;\nint g2[MAXN],nume2;\nint dep[MAXN],size[MAXN],son[MAXN],top[MAXN],pre[MAXN],w[MAXN],pt[MAXN],numw;\nint pre2[MAXN],h[MAXN],dep2[MAXN];\nbool flag;\nint ans;\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid addEdge2(int u,int v){\n\te2[nume2]=edge(v,g2[u]);\n\tg2[u]=nume2++;\n}\n\nvoid dfs(int x,int p){\n\tsize[x]=1; son[x]=0;\n\tpre[x]=p;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdep[e[i].to]=dep[x]+1;\n\t\t\tdfs(e[i].to,x);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t\tif(size[e[i].to]>size[son[x]])\n\t\t\t\tson[x]=e[i].to;\n\t\t}\n}\n\nvoid dfs2(int x,int p){\n\tpt[w[x]=++numw]=x;\n\tif(son[x]){\n\t\ttop[son[x]]=top[x];\n\t\tdfs2(son[x],x);\n\t}\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to!=p && e[i].to!=son[x]){\n\t\t\ttop[e[i].to]=e[i].to;\n\t\t\tdfs2(e[i].to,x);\n\t\t}\n}\n\nint getLCA(int x,int y){\n\twhile(top[x]^top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tx=pre[top[x]];\n\t}\n\treturn dep[x]<dep[y]?x:y;\n}\n\nint getDis(int x,int y){\n\treturn dep[x]+dep[y]-2*dep[getLCA(x,y)];\n}\n\nint goUp(int x,int d){\n\twhile(dep[x]-dep[top[x]]+1<d){\n\t\td-=dep[x]-dep[top[x]]+1;\n\t\tx=pre[top[x]];\n\t}\n\treturn pt[w[x]-d];\n}\n\nint step(int x,int y){\n\tint lca=getLCA(x,y);\n\tif(lca!=x) return pre[x];\n\treturn goUp(y,dep[y]-dep[x]-1);\n}\n\nvoid dfs3(int x,int p){\n\tpre2[x]=p;\n\tfor(int i=g2[x];~i;i=e2[i].next)\n\t\tif(e2[i].to^p){\n\t\t\tint y=e2[i].to;\n\t\t\tint dis=getDis(x,y);\n\t\t\tif(dis>=3) flag=1;\n\t\t\tif(y==h[x] || x==h[x]) continue;\n\t\t\th[y]=step(h[x],y);\n\t\t\tdep2[y]=dep2[x]+1;\n\t\t\tdfs3(y,x);\n\t\t}\n\tint res=getDis(h[x],x)*2+dep2[x]*2;\n\tans=max(ans,res);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tmemset(g2,-1,sizeof g2);\n\tscanf(\"%d%d%d\",&n,&x1,&x2);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t\taddEdge2(v,u);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\ttop[1]=1;\n\tdfs2(1,0);\n\th[x1]=x2;\n\tdfs3(x1,0);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"ctime\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Lowest_Common_Ancestor {\n\tvector<int>depth;\n\tvector<vector<int>>parent;\n\tvector<vector<int>>edge;\n\tint height = 0;\n\tint node;\npublic:\n\tLowest_Common_Ancestor(int num) {\n\t\tnum++;\n\t\tnode = num;\n\t\twhile (num) {\n\t\t\theight++;\n\t\t\tnum /= 2;\n\t\t}\n\t\tparent.resize(height);\n\t\tedge.resize(node);\n\t\tdepth.resize(node);\n\t\tfor (int i = 0; i < height; i++)parent[i].resize(node);\n\t}\n\tvoid Add_Edge(int a, int b) {\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\treturn;\n\t}\n\tvoid Update(int rtnode) {\n\t\tqueue<int>QQ;\n\t\tfor (int i = 0; i < node; i++) depth[i] = INT_MAX;\n\t\tdepth[rtnode] = 0;\n\t\tQQ.push(rtnode);\n\t\twhile (!QQ.empty()) {\n\t\t\tint c = QQ.front();\n\t\t\tfor (auto i : edge[c]) {\n\t\t\t\tif (depth[i] > depth[c] + 1) {\n\t\t\t\t\tdepth[i] = depth[c] + 1;\n\t\t\t\t\tQQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQQ.pop();\n\t\t}\n\t\tparent[0][rtnode] = -1;\n\t\tfor (int i = 1; i < node; i++) {\n\t\t\tfor (auto j : edge[i]) {\n\t\t\t\tif (depth[i] - 1 == depth[j]) {\n\t\t\t\t\tparent[0][i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < height - 1; i++) {\n\t\t\tfor (int j = 0; j < node; j++) {\n\t\t\t\tif (parent[i][j] < 0)parent[i + 1][j] = -1;\n\t\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint LCA(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tif ((depth[v] - depth[u]) >> i & 1) {\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int i = height - 1; i >= 0; i--) {\n\t\t\tif (parent[i][v] != parent[i][u]) {\n\t\t\t\tu = parent[i][u];\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\tint Dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - depth[LCA(u, v)] * 2;\n\t}\n};\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tvector<vector<int>>edge(N + 1);\n\tLowest_Common_Ancestor lca(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tedge[H].push_back(W);\n\t\tedge[W].push_back(H);\n\t}\n\tvector<vector<int>>wedge(N + 1);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\twedge[H].push_back(W);\n\t\twedge[W].push_back(H);\n\t\tlca.Add_Edge(H, W);\n\t}\n\tlca.Update(R);\n\tvector<int>safe(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (lca.Dist(i, j) > 2)safe[i] = safe[j] = 1;\n\t\t}\n\t}\n\tvector<int>depth(N + 1, MOD);\n\tCalculate_Depth(wedge, depth, R);\n\tvector<int>dist(N + 1, MOD);\n\tdist[L] = 0;\n\tqueue<int>Q;\n\tQ.push(L);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tif (safe[cn]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (auto i : edge[cn]) {\n\t\t\tauto dis = lca.Dist(i, cn);\n\t\t\tif (dis > 2)continue;\n\t\t\tif (dist[i] > dist[cn] + 1 ) {\n\t\t\t\tif (dist[cn] + 1 < depth[i]) {\n\t\t\t\t\tdist[i] = dist[cn] + 1;\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\telse if (dist[cn] + 1 == depth[i]) {\n\t\t\t\t\tdist[i] = dist[cn] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (dist[i] == MOD)continue;\n\t\tans = max(ans, depth[i]);\n\t}\n\tcout << (ans << 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200100\nusing namespace std;\nvector<int>R[maxn],B[maxn];\nint ans,fa[maxn],dep[maxn],n,x,y,s[maxn];\nvoid dfs(int u,int f){\n\tdep[u]=dep[fa[u]=f]+1;\n\tfor(int i=0;i<B[u].size();++i)if(B[u][i]!=f)\n\t\tdfs(B[u][i],u);\n}\nint gd(int u,int v){\n\tif(dep[u]<dep[v])swap(u,v);\n\tint d=dep[u]-dep[v];\n\twhile(dep[u]>dep[v]&&d<=2)u=fa[u];\n\twhile(u!=v&&d<=2)u=fa[u],v=fa[v],d+=2;\n\treturn min(d,3);\n}\nvoid dfs2(int u,int f){\n\tif(f&&gd(u,f)>=3)s[u]=s[f]=1;\n\tfor(int i=0;i<R[u].size();++i)if(R[u][i]!=f)\n\t\tdfs2(R[u][i],u);\n}\nvoid sol(int u,int f,int len){\n\tif(dep[u]<=len)return ;\n\tans=max(ans,dep[u]);\n\tif(s[u])printf(\"-1\"),exit(0);\n\tfor(int i=0;i<R[u].size();++i)if(R[u][i]!=f)\n\t\tsol(R[u][i],u,len+1);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tR[u].push_back(v),\n\t\tR[v].push_back(u);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tB[u].push_back(v),\n\t\tB[v].push_back(u);\n\tdep[0]=-1;\n\tdfs(y,0),dfs2(x,0),sol(x,0,0);\n\tprintf(\"%d\",ans<<1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector <int> dr[1000100],db[1000100];\nint fa[1000100],dep[1000100],ans;\nvoid prework(int s)\n{\n\tfor (int k=0;k<db[s].size();k++) if (db[s][k]!=fa[s])\n\t{\n\t\tfa[db[s][k]]=s;\n\t\tdep[db[s][k]]=dep[s]+1;\n\t\tprework(db[s][k]);\n\t}\n}\nbool check(int u,int v)\n{\n\tif (dep[u]<dep[v]) swap(u,v);\n\tif (fa[fa[u]]==v) return true;\n\tif (fa[u]==fa[v]) return true;\n\tif (fa[u]==v) return true;\n\tif (u==v) return true;\n\treturn false;\n}\nvoid dfs(int s,int pre,int d)\n{\n\tans=max(ans,dep[s]);\n\tif (dep[s]<=d) return;\n\tfor (int k=0;k<dr[s].size();k++) if (dr[s][k]!=pre)\n\t{\n\t\tif (!check(dr[s][k],s)) {printf(\"-1\\n\");exit(0);}\n\t\tdfs(dr[s][k],s,d+1);\n\t}\n}\n\t\t\nint main()\n{\n\tint n,b,r;scanf(\"%d%d%d\",&n,&b,&r);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tdr[u].push_back(v);dr[v].push_back(u);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tdb[u].push_back(v);db[v].push_back(u);\n\t}\n\tprework(r);\n\tdfs(b,0,0);\n\tprintf(\"%d\\n\",ans<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define N 200001\n#define LL long long\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\t\n}\nusing namespace std;\nint n,X,Y;\nbool reach[N],ok;\nstruct tree\n{\n\tint dep[N],fa[N];\n\tint cnt,head[N],nxt[N+N],to[N+N];\n\tvoid add_edge(int u,int v)\n\t{\n\t\tnxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v;\n\t}\n\tvoid dfs(int u)\n\t{\n\t\tfor(int i=head[u],v;i;i=nxt[i])\n\t\t\tif((v=to[i]) != fa[u])\n\t\t\t{\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tfa[v]=u;\n\t\t\t\tdfs(v);\n\t\t\t}\n\t}\n}a,b;\nbool check(int u,int v)\n{\n\tif(b.dep[u]<b.dep[v])swap(u,v);\n\tif(b.fa[u]==v)return 0;\n\tif(b.fa[b.fa[u]]==v)return 0;\n\tif(b.fa[u]==b.fa[v])return 0;\n\treturn 1;\n}\nvoid wfs(int u)\n{\n\treach[u]=1;\n\tfor(int i=a.head[u],v;i;i=a.nxt[i])\n\t\tif((v=a.to[i])!=a.fa[u] && a.dep[v]<b.dep[v])\n\t\t{\n\t\t\tif(check(u,v))ok=1;\n\t\t\twfs(v);\n\t\t}\n}\nint main()\n{\n\tre(n);re(X);re(Y);\n\tfor(int u,v,i=1;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\ta.add_edge(u,v);\n\t\ta.add_edge(v,u);\n\t}\n\tfor(int u,v,i=1;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tb.add_edge(u,v);\n\t\tb.add_edge(v,u);\n\t}\n\ta.dfs(X);b.dfs(Y);\n\twfs(X);\n\tif(ok)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)\n\t\tif(reach[i])\n\t\t\tans=max(ans,b.dep[i]);\n\tprintf(\"%d\\n\",2*ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=200005;\n\nint n,X,Y,ncnt;\nint dfn[MAXN],efn[MAXN],fa[MAXN],dep[MAXN];\nstruct node{\n    int v,nex;\n}E[MAXN],G[MAXN];\nint Ehead[MAXN],Ghead[MAXN],dcnt[2];\nbool tag[MAXN];\npair<int,int> a[MAXN];\n\nvoid addedge(node edge[],int head[],int &cnt,int u,int v){\n    node &p=edge[++cnt];\n    p.v=v;\n    p.nex=head[u];\n    head[u]=cnt;\n}\n\nvoid dfs(int u,int fa=0){\n    ::fa[u]=fa;\n    dep[u]=dep[fa]+1;\n    dfn[u]=++ncnt;\n    for(int i=Ghead[u];i;i=G[i].nex){\n        int v=G[i].v;\n        if(v==fa) continue;\n        dfs(v,u);\n    }\n    efn[u]=++ncnt;\n}\n\nbool check(int u,int v){\n    if(dfn[u]>dfn[v]) swap(u,v);\n    if(dfn[u]<dfn[v]&&efn[v]<efn[u])\n        return dep[v]-dep[u]>=3;\n    return fa[u]!=fa[v];\n}\n\nint vis[MAXN],dis[MAXN],deq[MAXN],l,r;\nvoid bfs(){\n    for(int i=1;i<=n;i++) vis[i]=dis[i]=0;\n    l=r=1;\n    vis[X]=1;\n    deq[r++]=X;\n    while(l<r){\n        int u=deq[l++];\n        for(int i=Ehead[u];i;i=E[i].nex){\n            int v=E[i].v;\n            if(vis[v]) continue;\n            vis[v]=1;\n            dis[v]=dis[u]+1;\n            if(dis[v]<dep[v])\n                deq[r++]=v;\n        }\n    }\n}\n\nint main(){\n\n    dep[0]=-1;\n    while(~scanf(\"%d%d%d\",&n,&X,&Y)){\n        for(int i=1;i<=n;i++) Ehead[i]=Ghead[i]=0;\n        dcnt[0]=dcnt[1]=ncnt=0;\n        for(int i=1;i<=n;i++) tag[i]=0;\n        for(int i=1;i<n;i++) scanf(\"%d%d\",&a[i].first,&a[i].second);\n        for(int i=1;i<n;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            addedge(G,Ghead,dcnt[1],u,v);\n            addedge(G,Ghead,dcnt[1],v,u);\n        }\n        dfs(Y);\n        for(int i=1;i<n;i++)\n            if(check(a[i].first,a[i].second)) tag[a[i].first]=tag[a[i].second]=1;\n            else addedge(E,Ehead,dcnt[0],a[i].first,a[i].second),addedge(E,Ehead,dcnt[0],a[i].second,a[i].first);\n        bfs();\n        int ans=0;\n        bool flag=1;\n        for(int i=1;i<=n&&flag;i++){\n            if(!vis[i]) continue;\n            if(tag[i]) flag=0;\n            else ans=max(ans,2*dep[i]);\n        }\n        printf(\"%d\\n\",flag?ans:-1);\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l, s1, s2;\nint ans;\n\nconst int N = 200001;\nconst int M = 400;\nint d1[N], d2[N], reach[N];\nvector<int> v1[N], v2[N];\nvector<int> bad;\n\nvoid bfs(int start, vector<int>* v, int* d) {\n\tF1(i, n) d[i] = -1;\n\td[start] = 0;\n\n\tqueue<int> Q;\n\tQ.push(start);\n\twhile (!Q.empty()) {\n\t\tint i = Q.front(); Q.pop();\n\t\tfor (int j : v[i]) {\n\t\t\tif (d[j] == -1) {\n\t\t\t\td[j] = d[i] + 1;\n\t\t\t\tQ.push(j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nset<pii> S, S2;\n\nint good(pii P) {\n\tif (!reach[P.first]) return 0;\n\n\tfor (int j : bad) {\n\t\tpii P1(P.first, j);\n\t\tpii P2(P.second, j);\n\t\tif (P1.first > P1.second) swap(P1.first, P1.second);\n\t\tif (P2.first > P2.second) swap(P2.first, P2.second);\n\t\tif (S2.count(P1) && S2.count(P2)) return 0;\n\t}\n\treturn 1;\n}\n\nvoid dfs(int i) {\n\treach[i] = 1;\n\tfor (int j : v1[i]) if (!reach[j] && d1[j] < d2[j]) dfs(j);\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n >> s1 >> s2;\n\n\n\tF0(u, n - 1) {\n\t\tscanf(\"%d%d\", &i, &j);\n\t\tif (i > j) swap(i, j);\n\t\tv1[i].push_back(j);\n\t\tv1[j].push_back(i);\n\t\tS.insert(pii(i, j));\n\t}\n\tF0(u, n - 1) {\n\t\tscanf(\"%d%d\", &i, &j);\n\t\tif (i > j) swap(i, j);\n\t\tv2[i].push_back(j);\n\t\tv2[j].push_back(i);\n\t\tS2.insert(pii(i, j));\n\t\tif (S.count(pii(i, j))) S.erase(S.find(pii(i, j)));\n\t}\n\n\tF1(i, n) if (SZ(v2[i]) <= M) {\n\t\tF0(j1, SZ(v2[i]))\n\t\tfor (int j2 = j1 + 1; j2 < SZ(v2[i]); j2++) {\n\t\t\tint x = v2[i][j1], y = v2[i][j2];\n\t\t\tif (x > y) swap(x, y);\n\t\t\tif (S.count(pii(x, y))) {\n\t\t\t\tS.erase(S.find(pii(x, y)));\n\t\t\t\t//cout << x << \" \" << y << endl;\n\t\t\t}\n\t\t}\n\t}\n\telse bad.push_back(i);\n\n\tbfs(s1, v1, d1);\n\tbfs(s2, v2, d2);\n\n\tdfs(s1);\n\n\t// inf case\n\tfor (pii P : S) {\n\t\tif (good(P)) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\texit(0);\n\t\t}\n\t\tswap(P.first, P.second);\n\t\tif (good(P)) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tF1(i, n) if (reach[i]) ans = max(ans, 2 * d2[i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(head,u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\nusing namespace std;\nconst int N=1e6+5;\nstruct eg{int v,nx;}e[N<<1];int bl[N],rd[N],tot;\ninline void add(R int *head,R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\nint fr[N],to[N],dep[N],fa[N],dfn[N],low[N],ok[N],vis[N],dis[N],tim,n,S,T;\nvoid dfs(int *head,int u){\n\tdfn[u]=++tim;\n\tgo(head,u)if(v!=fa[u])fa[v]=u,dep[v]=dep[u]+1,dfs(head,v);\n\tlow[u]=tim;\n//\tprintf(\"%d %d\\n\",u,dep[u]);\n}\ninline bool ck(R int u,R int v){\n\tif(dfn[u]>dfn[v])swap(u,v);if(low[u]>=low[v])return dep[v]-dep[u]>2;\n\tif(fa[u]==fa[v])return false;return true;\n}\nint q[N];\nvoid bfs(){\n\tint h=1,t=0,u;q[++t]=S,vis[S]=1;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(rd,u)if(!vis[v]){\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tif(dis[v]<dep[v])vis[v]=1,q[++t]=v;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&S,&T);\n\tfor(R int i=1,u,v;i<n;++i)scanf(\"%d%d\",&u,&v),fr[i]=u,to[i]=v;\n\tfor(R int i=1,u,v;i<n;++i)scanf(\"%d%d\",&u,&v),add(bl,u,v),add(bl,v,u);\n\tdfs(bl,T);\n\tfor(R int i=1,u,v;i<n;++i){\n\t\tu=fr[i],v=to[i];\n\t\tif(ck(u,v))ok[u]=ok[v]=1;\n\t\telse add(rd,u,v),add(rd,v,u);\n\t}\n\tbfs();\n\tfp(i,1,n)if(vis[i]&&ok[i])return puts(\"-1\"),0;\n\tR int res=0;\n\tfp(i,1,n)if(vis[i])cmax(res,dep[i]<<1);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid inf() {\n    cout << \"-1\\n\";\n    exit(0);\n}\n\nint n, x, y;\nvector<vector<int> > gr1, gr2;\nvector<int> d, pr, d2, pr2;\n\nvoid readGr(vector<vector<int> > &gr1) {\n    gr1.assign(n, vector<int>());\n    for (int i = 1; i < n; ++i) {\n        int v1, v2;\n        scanf(\"%d%d\", &v1, &v2);\n        --v1;\n        --v2;\n        gr1[v1].push_back(v2);\n        gr1[v2].push_back(v1);\n    }\n}\n\nvoid dfs(int v, int prv, vector<vector<int> >& gr, vector<int>& d, vector<int>& pr) {\n    for (int nv : gr[v])\n        if (nv != prv) {\n            d[nv] = d[v] + 1;\n            pr[nv] = v;\n            dfs(nv, v, gr, d, pr);\n        }\n}\n\nint findDst(int v1, int v2, vector<int> &d, vector<int>& pr) {\n    if (d[v1] > d[v2])\n        swap(v1, v2);\n    if (d[v2] >= d[v1] + 3)\n        return 3;\n    int ans = 0;\n    while (d[v2] != d[v1]) {\n        ++ans;\n        v2 = pr[v2];\n    }\n    while (ans < 3 && v1 != v2) {\n        ans += 2;\n        v1 = pr[v1];\n        v2 = pr[v2];\n    }\n    return min(ans, 3);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    --x; --y;\n    readGr(gr1);\n    readGr(gr2);\n    \n    d2.assign(n, 0);\n    pr2.assign(n, -1);\n    dfs(y, -1, gr2, d2, pr2);\n    \n    vector<int> good(n, 0);\n    for (int i = 0; i < n; ++i)\n        for (int v : gr1[i])\n            if (i < v)\n                if (findDst(i, v, d2, pr2) >= 3) {\n                    good[i] = good[v] = 1;\n                }\n    vector<int> d(n, -1);\n    queue<int> Q;\n    Q.push(x);\n    \n    d[x] = 0;\n    int ans = d2[x];\n    while (!Q.empty()) {\n        int v = Q.front();\n        Q.pop();\n        if (good[v])\n            inf();\n        for (int nv : gr1[v])\n            if (d[nv] < 0 && d[v] + 1 < d2[nv]) {\n                Q.push(nv);\n                ans = max(ans, d2[nv]);\n                d[nv] = d[v] + 1;\n            }\n            else if (d[v] + 1 == d2[nv])\n                ans = max(ans, d2[nv]);\n    }\n    cout << 2*ans << \"\\n\";   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define REP(x, l, u) for(ll x = l;x<u;x++)\n#define RREP(x, l, u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(begin(a),end(a)),end(a))\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define rall(a) rbegin(a),rend(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst ll mod = 1e9 + 7;\n\n\nstring to_string (string s) { return '\"' + s + '\"'; }\n\nstring to_string (const char *s) { return to_string ((string) s); }\n\nstring to_string (bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string (pair<A, B> p) { return \"(\" + to_string (p.first) + \", \" + to_string (p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string (A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) { res += \", \"; }\n        first = false;\n        res += to_string (x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out () { cerr<<endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out (Head H, Tail... T) {\n    cerr<<\" \"<<to_string (H);\n    debug_out (T...);\n}\n\n#ifdef LOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin (T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax (T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\n\null twop (ll x) { return 1ULL<<x; }\n\nll MOD (ll a, ll m) {\n    a %= m;\n    if (a < 0)a += m;\n    return a;\n}\n\nll inverse (ll a, ll m) {\n    a = MOD (a, m);\n    if (a <= 1)return a;\n    return MOD ((1 - inverse (m, a) * m) / a, m);\n}\n\ntemplate<typename T>\nT sqr (T x) { return x * x; }\n\nll gcd (ll a, ll b) {\n    a = abs (a), b = abs (b);\n    while (b != 0) {\n        a %= b;\n        swap (a, b);\n    }\n    return a;\n}\n\nll fast (ll a, ll b) {\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans *= a;\n        a *= a;\n        b /= 2;\n    }\n    return ans;\n}\n\nll fast (ll a, ll b, ll mod) {\n    if (b < 0)a = inverse (a, mod), b = -b;\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans = ans * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return ans % mod;\n}\n\n\nnamespace SOLVE {\n    const ll N = 200010;\n    VLL red[N], blue[N];\n    ll n, x, y;\n    int par[N];\n    int dep[N];\n    \n    void dfs (int cur, int fa) {\n        par[cur] = fa;\n        for (auto s:blue[cur]) {\n            if (s != fa) {\n                dep[s] = dep[cur] + 1;\n                dfs (s, cur);\n            }\n        }\n    }\n    \n    bool niubi (int x, int y) {\n        REP(i, 0, 2) {\n            if (par[x] == par[y])return false;\n            if (par[par[x]] == y)return false;\n            if (par[x] == y)return false;\n            swap (x, y);\n        }\n        return true;\n    }\n    \n    void bfs () {\n        queue<int> q;\n        q.push (x);\n        VI vis (n + 1, 0);\n        VI dis (n + 1, 0);\n        vis[x] = 1;\n        int ans = dep[x]*2;\n        while (sz(q)) {\n            auto f = q.front ();\n            q.pop ();\n            for (auto s:red[f]) {\n                if (!vis[s]) {\n                    dis[s] = dis[f] + 1;\n                    vis[s] = 1;\n                    if (dis[s] < dep[s]) {\n                        q.push (s);\n                        if (niubi (s, f)) {\n                            cout<<\"-1\";\n                            return;\n                        }\n                    }\n                    if (dis[s] <= dep[s]) {\n                        dbg(s,dis[s]);\n                        upmax (ans, 2 * dep[s]);\n                    }\n                }\n            }\n        }\n        cout<<ans;\n    }\n    \n    void main () {\n        cin>>n>>x>>y;\n        REP(i, 1, n) {\n            ll a, b;\n            cin>>a>>b;\n            red[a].PB (b);\n            red[b].PB (a);\n        }\n        REP(i, 1, n) {\n            ll a, b;\n            cin>>a>>b;\n            blue[a].PB (b);\n            blue[b].PB (a);\n        }\n        \n        dfs (y, 0);\n        bfs ();\n        \n    }\n}\n\n\nsigned main () {\n#ifdef LOCAL\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    int t = 1;\n//    cin >> t;\n    for (int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\": \";\n        SOLVE::main ();\n        \n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X,Y;\nvector<int> E[202020],E2[202020];\n\nint P[21][200005],D[200005],D2[200005];\n\nvoid dfs(int cur) {\n\tITR(it,E[cur]) if(*it!=P[0][cur]) D[*it]=D[cur]+1, P[0][*it]=cur, dfs(*it);\n}\nint dist(int a,int b) {\n\tint ret=0,i,aa=a,bb=b;\n\tif(D[aa]>D[bb]) swap(aa,bb);\n\tfor(i=19;i>=0;i--) if(D[bb]-D[aa]>=1<<i) bb=P[i][bb];\n\tfor(i=19;i>=0;i--) if(P[i][aa]!=P[i][bb]) aa=P[i][aa], bb=P[i][bb];\n\treturn D[a]+D[b]-2*D[(aa==bb)?aa:P[0][aa]];  // dist\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\treturn _P(\"-1\\n\");\n\tcin>>N>>X>>Y;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE2[x].push_back(y);\n\t\tE2[y].push_back(x);\n\t}\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\tP[0][Y]=Y;\n\tdfs(Y);\n\tFOR(i,19) FOR(x,N) P[i+1][x+1]=P[i][P[i][x+1]];\n\tFOR(i,N) D2[i+1]=10101010;\n\t\n\tint ret=0;\n\tqueue<int> Q;\n\tD2[X]=0;\n\tQ.push(X);\n\twhile(Q.size()) {\n\t\tx = Q.front();\n\t\tQ.pop();\n\t\tif(D2[x]>D[x]) continue;\n\t\tret=max(ret,D[x]);\n\t\tFORR(e,E2[x]) {\n\t\t\tif(dist(x,e)>=3) return _P(\"-1\\n\");\n\t\t\tif(D2[e]>D2[x]+1) D2[e]=D2[x]+1, Q.push(e);\n\t\t}\n\t}\n\t\n\tcout<<ret*2<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1e9;\nint n, x, y, rp[200010], rd[200010], bp[200010], bd[200010], ans;\nvector<int> re[200010], be[200010];\n\nvoid T_T(){ puts(\"-1\"); exit(0); }\n\nvoid f(int t, int x, int pr, int de, int *p, int *d){\n\td[x] = de;\n\tp[x] = pr;\n\tif(t){\n\t\tfor(auto &i : be[x]){\n\t\t\tif(i != pr) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n\telse{\n\t\tfor(auto &i : re[x]){\n\t\t\tif(i != pr && i != y) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tauto in = [](int t){\n\t\tfor(int i = 0, x, y; i < n - 1; i++){\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t(t ? be[x] : re[x]).push_back(y);\n\t\t\t(t ? be[y] : re[y]).push_back(x);\n\t\t}\n\t};\n\tin(0); in(1);\n\tf(1, y, 0, 0, bp, bd);\n\tfill(rd + 1, rd + n + 1, inf);\n\tf(0, x, 0, 0, rp, rd);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(auto &j : re[i]){\n\t\t\tint a = i, b = j;\n\t\t\tif(bd[a] > bd[b]) swap(a, b);\n\t\t\tif(bp[b] == a || bp[bp[b]] == a || bp[a] == bp[b]) continue;\n\t\t\tif(bd[a] > rd[a] || bd[b] > rd[b]) T_T();\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) if(rd[i] < inf) ans = max(ans, 2 * bd[i]);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(!bad[u])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(h[u1[i]]<h[u2[i]])swap(u1[i],u2[i]);\n\trep(i,1,n)if(ok[i] && (!bad[u1[i]])){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#define SF scanf\n#define PF printf\n#define MAXN 200010\nusing namespace std;\nint n,x,y;\nvector<int> a[MAXN],b[MAXN];\npair<int,int> l[MAXN];\nint depA[MAXN],depB[MAXN];\nint fa[MAXN][21];\nvoid dfsA(int x,int f){\n\tdepA[x]=depA[f]+1;\n\tfor(int i=0;i<a[x].size();i++){\n\t\tint u=a[x][i];\n\t\tif(u==f)\n\t\t\tcontinue;\n\t\tdfsA(u,x);\t\n\t}\n}\nvoid dfsB(int x,int f){\n\tdepB[x]=depB[f]+1;\n\tfa[x][0]=f;\n\tfor(int i=1;i<20;i++)\n\t\tfa[x][i]=fa[fa[x][i-1]][i-1];\n\tfor(int i=0;i<b[x].size();i++){\n\t\tint u=b[x][i];\n\t\tif(u==f)\n\t\t\tcontinue;\n\t\tdfsB(u,x);\n\t}\n}\nint lca(int u,int v){\n\tif(depB[u]<depB[v])\n\t\tswap(u,v);\n\tfor(int i=19;i>=0;i--)\n\t\tif(depB[fa[u][i]]>=depB[v])\n\t\t\tu=fa[u][i];\n\tif(u==v)\n\t\treturn u;\n\tfor(int i=19;i>=0;i--)\n\t\tif(fa[u][i]!=fa[v][i]){\n\t\t\tu=fa[u][i];\n\t\t\tv=fa[v][i];\t\n\t\t}\n\treturn fa[u][0];\n}\nint ans;\nvoid dfs(int x,int f){\n\tif(depA[x]>=depB[x])\n\t\treturn ;\n\tif(ans!=-1)\n\t\tans=max(ans,(depB[x]-1)*2);\n\tfor(int i=0;i<a[x].size();i++){\n\t\tint u=a[x][i];\n\t\tif(u==f)\n\t\t\tcontinue;\n\t\tif(depB[u]+depB[x]-2*depB[lca(u,x)]>2)\n\t\t\tans=-1;\t\n\t\tdfs(u,x);\t\n\t}\n}\nint main(){\n\twhile(SF(\"%d%d%d\",&n,&x,&y)!=EOF){\n\t\tint u,v;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tSF(\"%d%d\",&u,&v);\n\t\t\tl[i]=make_pair(u,v);\n\t\t\ta[u].push_back(v);\n\t\t\ta[v].push_back(u);\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tSF(\"%d%d\",&u,&v);\n\t\t\tb[u].push_back(v);\n\t\t\tb[v].push_back(u);\t\n\t\t}\n\t\tdfsA(x,0);\n\t\tdfsB(y,0);\n\t\tans=0;\n\t\tdfs(x,0);\n\t\tPF(\"%d\\n\",ans);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i].clear();\n\t\t\tb[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n\nusing namespace std;\n\ninline int Read(){\n\tchar c = getchar();\n\twhile(c > '9' || c < '0') c = getchar();\n\tint x = c - '0'; c = getchar();\n\twhile(c <= '9' && c >= '0') x = x * 10 + c - '0', c = getchar();\n\treturn x;\n}\n\nconst int N = 200010;\n\nstruct Graph{\n\tint Begin[N], Next[N << 1], to[N << 1], e;\n\n\tGraph(){\n\t\te = 0;\t\n\t}\n\t\n\tvoid add(int u, int v){\n\t\tto[++e] = v, Next[e] = Begin[u], Begin[u] = e;\n\t\tto[++e] = u, Next[e] = Begin[v], Begin[v] = e;\n\t}\n}A, B;\n\nint depa[N], depb[N], fa[N];\nbool vis[N];\n\nvoid DFSA(int o, int f = 0){\n\tfor(int i = A.Begin[o]; i; i = A.Next[i]){\n\t\tint u = A.to[i];\n\t\tif(u == f) continue;\n\t\tdepa[u] = depa[o] + 1;\n\t\tfa[u] = o;\n\t\tDFSA(u, o);\n\t}\n}\n\nbool check(int u, int v){\n\tint d = 0;\n\tif(depa[u] < depa[v]) swap(u, v);\n\twhile(depa[u] > depa[v] && d < 3) u = fa[u], ++d;\n\twhile(u != v && d < 3) u = fa[u], v = fa[v], d += 2;\n\treturn d > 2;\n}\n\nint ans;\n\nvoid DFSB(int o, int f = 0){\n\tans = max(ans, depa[o]);\n\tvis[o] = true;\n\tfor(int i = B.Begin[o]; i; i = B.Next[i]){\n\t\tint u = B.to[i];\n\t\tif(u == f) continue;\n\t\tdepb[u] = depb[o] + 1;\n\t\tif(depa[u] <= depb[u]) continue;\n\t\tDFSB(u, o);\n\t}\n}\n\nint n, p, q;\n\nint main(){\n\tn = Read(), q = Read(), p = Read();\n\tFor(i, 2, n){\n\t\tint u = Read(), v = Read();\n\t\tB.add(u, v);\n\t}\n\tFor(i, 2, n){\n\t\tint u = Read(), v = Read();\n\t\tA.add(u, v);\n\t}\n\tDFSA(p), DFSB(q);\n\tFor(i, 1, n - 1){\n\t\tint u = B.to[i * 2], v = B.to[i * 2 - 1];\n\t\tif((vis[u] || vis[v]) && check(u, v)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans * 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define REP(x, l, u) for(ll x = l;x<u;x++)\n#define RREP(x, l, u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(begin(a),end(a)),end(a))\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define rall(a) rbegin(a),rend(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst ll mod = 1e9 + 7;\n\n\nstring to_string (string s) { return '\"' + s + '\"'; }\n\nstring to_string (const char *s) { return to_string ((string) s); }\n\nstring to_string (bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string (pair<A, B> p) { return \"(\" + to_string (p.first) + \", \" + to_string (p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string (A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) { res += \", \"; }\n        first = false;\n        res += to_string (x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out () { cerr<<endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out (Head H, Tail... T) {\n    cerr<<\" \"<<to_string (H);\n    debug_out (T...);\n}\n\n#ifdef LOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin (T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax (T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\n\null twop (ll x) { return 1ULL<<x; }\n\nll MOD (ll a, ll m) {\n    a %= m;\n    if (a < 0)a += m;\n    return a;\n}\n\nll inverse (ll a, ll m) {\n    a = MOD (a, m);\n    if (a <= 1)return a;\n    return MOD ((1 - inverse (m, a) * m) / a, m);\n}\n\ntemplate<typename T>\nT sqr (T x) { return x * x; }\n\nll gcd (ll a, ll b) {\n    a = abs (a), b = abs (b);\n    while (b != 0) {\n        a %= b;\n        swap (a, b);\n    }\n    return a;\n}\n\nll fast (ll a, ll b) {\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans *= a;\n        a *= a;\n        b /= 2;\n    }\n    return ans;\n}\n\nll fast (ll a, ll b, ll mod) {\n    if (b < 0)a = inverse (a, mod), b = -b;\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans = ans * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return ans % mod;\n}\n\n\nnamespace SOLVE {\n    const ll N = 200010;\n    VLL red[N], blue[N];\n    ll n, x, y;\n    int par[N];\n    int dep[N];\n    \n    void dfs (int cur, int fa) {\n        par[cur] = fa;\n        for (auto s:blue[cur]) {\n            if (s != fa) {\n                dep[s] = dep[cur] + 1;\n                dfs (s, cur);\n            }\n        }\n    }\n    \n    bool niubi (int x, int y) {\n        REP(i, 0, 2) {\n            if (par[x] == par[y])return false;\n            if (par[par[x]] == y)return false;\n            if (par[x] == y)return false;\n            swap (x, y);\n        }\n        return true;\n    }\n    \n    void bfs () {\n        queue<int> q;\n        q.push (x);\n        VI vis (n + 1, 0);\n        VI dis (n + 1, 0);\n        vis[x] = 1;\n        int ans = dep[x] * 2;\n        while (sz(q)) {\n            auto f = q.front ();\n            q.pop ();\n            for (auto s:red[f]) {\n                if (niubi (s, f)) {\n                    cout<<\"-1\";\n                    return;\n                }\n            }\n            for (auto s:red[f]) {\n                if (!vis[s]) {\n                    dis[s] = dis[f] + 1;\n                    vis[s] = 1;\n                    if (dis[s] < dep[s]) {\n                        q.push (s);\n                    }\n                    if (dis[s] <= dep[s]) {\n                        dbg(s, dis[s]);\n                        upmax (ans, 2 * dep[s]);\n                    }\n                }\n            }\n        }\n        cout<<ans;\n    }\n    \n    void main () {\n        cin>>n>>x>>y;\n        REP(i, 1, n) {\n            ll a, b;\n            cin>>a>>b;\n            red[a].PB (b);\n            red[b].PB (a);\n        }\n        REP(i, 1, n) {\n            ll a, b;\n            cin>>a>>b;\n            blue[a].PB (b);\n            blue[b].PB (a);\n        }\n        \n        dfs (y, 0);\n        bfs ();\n        \n    }\n}\n\n\nsigned main () {\n#ifdef LOCAL\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    int t = 1;\n//    cin >> t;\n    for (int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\": \";\n        SOLVE::main ();\n        \n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll mod=1e9+7;\nconst ll inf=1e17+500;\nconst ll maxn=2e5+500;\nll ans=0;\n\nvector<ll> red[maxn];\nvector<ll> blu[maxn];\nll minred[maxn];\nll parred[maxn][20];\nll minblu[maxn];\nll parblu[maxn][20];\n\nll stred[maxn];\nll etred[maxn];\n\nll stblu[maxn];\nll etblu[maxn];\n\nbool star[maxn];\nll tt=0;\n\nbool mishe[maxn];\n\nvoid dfsred(ll a,ll p=-1,ll H=0){\n    stred[a]=tt++;\n    minred[a]=H;\n    for(auto v:red[a]){\n        if(v!=p){\n            parred[v][0]=a;\n            dfsred(v,a,H+1);\n        }\n    }\n    etred[a]=tt++;\n}\nvoid dfsblu(ll a,ll p=-1,ll H=0){\n    stblu[a]=tt++;\n    minblu[a]=H;\n    for(auto v:blu[a]){\n        if(v!=p){\n            parblu[v][0]=a;\n            dfsblu(v,a,H+1);\n        }\n    }\n    etblu[a]=tt++;\n}\nbool is_par_red(ll a,ll b){\n    return (stred[a]<=stred[b] &&etred[a]>=etred[b]);\n}\nbool is_par_blu(ll a,ll b){\n    return (stblu[a]<=stblu[b] &&etblu[a]>=etblu[b]);\n}\nll lca_red(ll a,ll b){\n    if(is_par_red(a,b))return a;\n    if(is_par_red(b,a))return b;\n    for(ll i=19;i>=0;i--){\n        if(!is_par_red(parred[a][i],b))\n            a=parred[a][i];\n    }\n    return parred[a][0];\n}\nll lca_blu(ll a,ll b){\n    if(is_par_blu(a,b))return a;\n    if(is_par_blu(b,a))return b;\n    for(ll i=19;i>=0;i--){\n        if(!is_par_blu(parblu[a][i],b))\n            a=parblu[a][i];\n    }\n    return parblu[a][0];\n}\nll fas_red(ll a,ll b){\n    ll lc=lca_red(a,b);\n    return minred[a]+minred[b]-2*minred[lc];\n}\nll fas_blu(ll a,ll b){\n    ll lc=lca_blu(a,b);\n    return minblu[a]+minblu[b]-2*minblu[lc];\n}\nll nazdik_blu(ll a,ll b){\n    if(a==b)return a;\n    if(!is_par_blu(b,a)){\n        return parblu[b][0];\n    }\n    for(ll i=19;i>=0;i--){\n        if(!is_par_blu(parblu[a][i],b))\n            a=parblu[a][i];\n    }\n    return a;\n}\nvoid dfs_mishe(ll a,ll b,ll p=-1){\n    if(a==b){\n        return;\n    }\n    ans=max(ans,minred[a]*2+fas_blu(a,b)*2);\n    mishe[a]=1;\n    for(auto v:red[a]){\n        if(v!=p){\n            dfs_mishe(v,nazdik_blu(v,b),a);\n        }\n    }\n}\nint main(){\n    ll n,x,y;\n    cin>>n>>x>>y;\n    vector<pii> yal;\n    for(ll i=1;i<n;i++){\n        ll v,u;\n        cin>>v>>u;\n        yal.pb(mp(v,u));\n        red[u].pb(v);\n        red[v].pb(u);\n    }\n    for(ll i=1;i<n;i++){\n        ll v,u;\n        cin>>v>>u;\n        blu[u].pb(v);\n        blu[v].pb(u);\n    }\n    tt=0;\n    parred[x][0]=x;\n    dfsred(x);\n    tt=0;\n    parblu[y][0]=y;\n    dfsblu(y);\n    for(ll i=1;i<20;i++){\n        for(ll j=1;j<=n;j++){\n            parred[j][i]=parred[parred[j][i-1]][i-1];\n            parblu[j][i]=parblu[parblu[j][i-1]][i-1];\n        }\n    }\n    for(auto e:yal){\n        ll v=e.F;\n        ll u=e.S;\n        if(fas_blu(v,u)>2){\n            star[v]=1;\n            star[u]=1;\n        }\n    }\n    dfs_mishe(x,y);\n    for(ll i=1;i<=n;i++){\n        if(star[i] && mishe[i]){\n            cout<<-1;\n            return 0;\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 100, inF = N;\n\nint n, DIS[N];\nbool mark[N];\nstruct tree {\n\tint dex, root, dis[N], par[N];\n\tvector<int> nei[N];\n\ttree() {\n\t\tfill(par, par + N, -1);\n\t\tfill(dis, dis + N, inF);\n\t}\n\tvoid input() {\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tnei[--u].push_back(--v);\n\t\t\tnei[v].push_back(u);\n\t\t}\n\t}\n\tvoid dfs(int v, bool b = false) {\n\t\tdis[root] = 0;\n\t\tif (dis[v] >= DIS[v] && b)\n\t\t\treturn;\n\t\tfor (int u: nei[v])\n\t\t\tif (u ^ par[v]) {\n\t\t\t\tdis[u] = dis[v] + 1;\n\t\t\t\tpar[u] = v;\n\t\t\t\tdfs(u, b);\n\t\t\t}\n\t}\n\tbool far(int u, int v) {\n\t\tif (u == v || u == par[v] || v == par[u] || par[u] == par[v])\n\t\t\treturn false;\n\t\tif (par[u] != -1 && par[par[u]] == v)\n\t\t\treturn false;\n\t\tif (par[v] != -1 && par[par[v]] == u)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n} R, B;\n\nvoid INPUT() {\n\tcin >> n >> R.root >> B.root;\n\tR.root--;\n\tB.root--;\n\tR.input();\n\tB.input();\n\tB.dfs(B.root);\n\tcopy(B.dis, B.dis + n, DIS);\n\tR.dfs(R.root, true);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tINPUT();\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int u: R.nei[v])\n\t\t\tif (B.far(u, v))\n\t\t\t\tmark[u] = mark[v] = true;\n\tfor (int v = 0; v < n; v++)\n\t\tif (R.dis[v] < B.dis[v] && mark[v]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\tint a = -1, b = inF;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (R.dis[v] < B.dis[v])\n\t\t\ta = max(a, B.dis[v]);\n\t\tif (R.dis[v] <= B.dis[v])\n\t\t\tb = min(b, B.dis[v]);\n\t}\n\tcout << max(a, b) * 2;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n\nusing namespace std;\n\nconst int MaxN = 2e5 + 5;\n\nifstream fin(\"game.in\");\nofstream fout(\"game.out\");\n\nvector<int> gb[MaxN], gr[MaxN];\n\nint dep[MaxN], fa[MaxN], d[MaxN];\nbool safe[MaxN], vis[MaxN];\n\nint main() {\n  int n, sx, sy;\n  fin >> n >> sx >> sy;\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    fin >> x >> y;\n    gr[x].emplace_back(y);\n    gr[y].emplace_back(x);\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    fin >> x >> y;\n    gb[x].emplace_back(y);\n    gb[y].emplace_back(x);\n  }\n  queue<int> Q;\n  Q.push(sy);\n  fa[sy] = -1;\n  vis[sy] = true;\n  while (!Q.empty()) {\n    int k = Q.front();\n    for (int x : gb[k]) {\n      if (!vis[x]) {\n        Q.push(x);\n        vis[x] = true;\n        dep[x] = dep[k] + 1;\n        fa[x] = k;\n      }\n    }\n    Q.pop();\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int k : gr[i]) {\n      if (![](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n      } (i, k)) {\n        safe[i] = safe[k] = true;\n      }\n    }\n  }\n  if (safe[sx]) {\n    fout << -1 << endl;\n    return 0;\n  }\n  int ans = 0;\n  memset(d, 0xff, sizeof d);\n  memset(vis, 0x00, sizeof vis);\n  d[sx] = 0;\n  Q.push(sx);\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop();\n    if (d[k] >= dep[k]) {\n      continue;\n    }\n    if (safe[k]) {\n      fout << -1 << endl;\n      return 0;\n    }\n    ans = max(ans, dep[k] * 2);\n    for (int x : gr[k]) {\n      if (!vis[x] && d[k] + 1 < dep[x] && [](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n        } (k, x)) {\n        d[x] = d[k] + 1;\n        vis[x] = true;\n        Q.push(x);\n      }\n    }\n  }\n  fout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200000\n#define MD 18\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,X,Y,h1[MN+5],h2[MN+5],cnt=0,d1[MN+5],d2[MN+5],q[MN+5],top,vis[MN+5],dep[MN+5],fa[MD+1][MN+5],flag,ans=0;\nstruct edge{int to,next;}e[MN*4+5];\ninline void ins(int*H,int f,int t)\n{\n\te[++cnt]=(edge){t,H[f]};H[f]=cnt;\n\te[++cnt]=(edge){f,H[t]};H[t]=cnt;\t\n}\nvoid Bfs(int*d,int*head,int s)\n{\n\tmemset(vis,0,sizeof(vis));\n\tvis[q[top=1]=s]=1;\n\tfor(int i=1;i<=top;++i)\n\t\tfor(int j=head[q[i]];j;j=e[j].next)\n\t\t\tif(!vis[e[j].to]) vis[e[j].to]=1,d[q[++top]=e[j].to]=d[q[i]]+1;\t\n}\nvoid Pre(int x,int f)\n{\n\tfa[0][x]=f;\n\tfor(int i=h2[x];i;i=e[i].next)\n\t\tif(e[i].to!=f) dep[e[i].to]=dep[x]+1,Pre(e[i].to,x);\n}\ninline int lca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int k=dep[x]-dep[y],j=0;k;k>>=1,++j) if(k&1) x=fa[j][x];\t\n\tif(x==y) return x;\n\tfor(int i=MD;~i;--i) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\ninline int dis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\nvoid dfs(int x,int fa)\n{\n\tif(d1[x]>d2[x]) return;ans=max(ans,d1[x]+1);\n\tif(d1[x]==d2[x]) return;\n\tfor(int i=h1[x];i;i=e[i].next)\n\t\tif(dis(e[i].to,x)>2) flag=1;\n\tfor(int i=h1[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa) dfs(e[i].to,x);\n}\nint main()\n{\n\tn=read();X=read();Y=read();\n\tfor(int i=1;i<n;++i) ins(h1,read(),read());\n\tfor(int i=1;i<n;++i) ins(h2,read(),read());\n\tBfs(d1,h1,X);Bfs(d2,h2,Y);Pre(Y,0);\n\tfor(int i=1;i<=MD;++i) for(int j=1;j<=n;++j) fa[i][j]=fa[i-1][fa[i-1][j]];\n\tdfs(X,0);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans*2);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int maxn=2e5;\nint n,x,y,tot;\nint pre[maxn*4+8],son[maxn*4+8];\nbool can[maxn+8];\nqueue<int>st;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nstruct Tree\n{\n    int now[maxn+8],dep[maxn+8],f[maxn+8][20];\n    void add(int u,int v)\n    {\n\tpre[++tot]=now[u];\n\tnow[u]=tot;\n\tson[tot]=v;\n    }\n    void build(int x)\n    {\n\tdep[x]=dep[f[x][0]]+1;\n\tfor (int i=1;i<=log(dep[x])/log(2);i++) f[x][i]=f[f[x][i-1]][i-1];\n\tfor (int p=now[x];p;p=pre[p])\n\t    {\n\t\tint child=son[p];\n\t\tif (f[x][0]==child) continue;\n\t\tf[child][0]=x;\n\t\tbuild(child);\n\t    }\n    }\n    int Get_Lca(int x,int y)\n    {\n\tif (dep[x]<dep[y]) swap(x,y);\n\tfor (int i=log(dep[x])/log(2);~i;i--)\n\t    if (dep[f[x][i]]>=dep[y]) x=f[x][i];\n\tif (x==y) return x;\n\tfor (int i=log(dep[x])/log(2);~i;i--)\n\t    if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n\treturn f[x][0];\n    }\n    int Get_Dis(int x,int y){return dep[x]+dep[y]-dep[Get_Lca(x,y)]*2;}\n}T1,T2;\n\nvoid solve()\n{\n    //for (int i=1;i<=n;i++) printf(\"%d \",can[i]);puts(\"\");\n    int ans=0;\n    for (int i=1;i<=n;i++)\n\tif (can[i])\n\t    {\n\t\tans=max(ans,T2.dep[i]-1);\n\t\tfor (int p=T1.now[i];p;p=pre[p])\n\t\t    {\n\t\t\tint child=son[p];\n\t\t\tif (T2.Get_Dis(child,i)>2)\n\t\t\t    {\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t    }\n\t\t    }\n\t    }\n    printf(\"%d\\n\",ans*2);\n}\n\nvoid prepare()\n{\n    can[x]=1;\n    st.push(x);\n    while(!st.empty())\n\t{\n\t    int x=st.front();st.pop();\n\t    for (int p=T1.now[x];p;p=pre[p])\n\t\t{\n\t\t    int child=son[p];\n\t\t    if (can[child]) continue;\n\t\t    if (T1.dep[child]<T2.dep[child]) can[child]=1,st.push(child);\n\t\t}\n\t}\n}\n\nint main()\n{\n    n=read(),x=read(),y=read();\n    if (x==y)\n\t{\n\t    puts(\"0\");\n\t    return 0;\n\t}\n    for (int i=1;i<n;i++)\n\t{\n\t    int u=read(),v=read();\n\t    T1.add(u,v),T1.add(v,u);\n\t}\n    for (int i=1;i<n;i++)\n\t{\n\t    int u=read(),v=read();\n\t    T2.add(u,v),T2.add(v,u);\n\t}\n    T1.build(x),T2.build(y);\n    prepare();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//ll inv(ll a, ll p) {\n//\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n//}\n//modint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nvector<int> G[1 << 18];\n\nint depth[1 << 18];\nint par[1 << 18][18];\n\nvoid dfs(int id, int fr) {\n\tif (fr >= 0)depth[id] = depth[fr] + 1;\n\tpar[id][0] = fr;\n\tfor (int to : G[id]) {\n\t\tif (to == fr)continue;\n\t\tdfs(to, id);\n\t}\n}\nint n;\nvoid yaru(int root) {\n\tdfs(root, -1);\n\trep(j, 17) {\n\t\trep(i, n) {\n\t\t\tif (par[i][j] < 0)par[i][j + 1] = -1;\n\t\t\telse par[i][j + 1] = par[par[i][j]][j];\n\t\t}\n\t}\n}\nint lca(int a, int b) {\n\tif (depth[a] < depth[b])swap(a, b);\n\trep(k, 18) {\n\t\tif ((depth[a] - depth[b]) >> k & 1) {\n\t\t\ta = par[a][k];\n\t\t}\n\t}\n\tif (a == b)return a;\n\tper(k, 18) {\n\t\tif (par[a][k] != par[b][k]) {\n\t\t\ta = par[a][k], b = par[b][k];\n\t\t}\n\t}\n\treturn par[a][0];\n}\nint dist(int a, int b) {\n\tint l = lca(a, b);\n\treturn depth[a] + depth[b] - 2 * depth[l];\n}\n\nbool inf[1 << 18];\nvector<int> g[1 << 18];\n\nint d[1 << 18];\nvoid solve() {\n\tcin >> n;\n\tint x, y; cin >> x >> y; x--; y--;\n\tvector<P> v(n-1);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tv[i] = { a,b };\n\t}\n\trep(i, n-1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tyaru(y);\n\trep(i, n - 1) {\n\t\tint l = v[i].first, r = v[i].second;\n\t\tint d = dist(l,r);\n\t\tif (d >= 3) {\n\t\t\tinf[l] =inf[r]= true;\n\t\t}\n\t\telse {\n\t\t\tg[l].push_back(r);\n\t\t\tg[r].push_back(l);\n\t\t}\n\t}\n\tfill(d, d + n, mod);\n\td[x] = 0;\n\tqueue<int> q; q.push(x);\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\tfor (int to : g[id]) {\n\t\t\tint nd = d[id] + 1;\n\t\t\tif (nd < d[to] && nd < depth[to]) {\n\t\t\t\td[to] = nd; q.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tint ma = 0;\n\trep(i, n) {\n\t\tif (d[i] == mod)continue;\n\t\tif (inf[i]) {\n\t\t\tcout << -1 << endl; return;\n\t\t}\n\t\t//cout << i << \" \" << depth[i] << endl;\n\t\tma = max(ma, depth[i]);\n\t}\n\tcout << 2 * ma << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(7);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define edge(j) for (j=fst[x];j;j=nxt[j])\nusing namespace std;\nconst int N=2e5+5;\nint n,x,y,i,j,u,v,ans,mode;\nint En,fst[N],Fa[N],nxt[N*2],to[N*2];\nint U[N],V[N],A[N],B[N];\nvoid File()\n{\n\tfreopen(\"game.in\",\"r\",stdin);\n\tfreopen(\"game.out\",\"w\",stdout);\n}\nvoid add(int u,int v) {\n\tEn++; nxt[En]=fst[u]; fst[u]=En; to[En]=v;\n}\nvoid dfs(int x,int fa,int step,int *A)\n{\n\tint j,v;\n\tif (mode==1 && B[x]==n+1) return ;\n\tA[x]=step; Fa[x]=fa;\n\tedge(j)\n\t{\n\t\tv=to[j];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x,step+1,A);\n\t}\n}\nvoid Init()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t\tU[i]=u; V[i]=v;\n\t}\n\t\n\trep(i,1,n) A[i]=n+1;\n\tB[y]=n+1;\n\tfor (j=fst[y];j;j=nxt[j]) B[to[j]]=n+1;\n\tB[x]=0;\n\t\n\tmode=1; dfs(x,x,0,A);\n\tmemset(fst,0,sizeof(fst));\n\tEn=0;\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\t\t\n\t}\n\tmode=2; dfs(y,y,0,B);\n}\nvoid Solve()\n{\n\trep(i,1,n-1)\n\t{\n\t\tif (Fa[U[i]]==V[i] || Fa[V[i]]==U[i]) continue;\n\t\tif (Fa[U[i]]==Fa[V[i]] || Fa[Fa[U[i]]]==V[i] || Fa[Fa[V[i]]]==U[i]) continue;\n\t\tif (A[U[i]]<B[U[i]] || A[V[i]]<B[V[i]])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn ;\n\t\t}\n\t}\n\trep(i,1,n)\n\t\tif (A[i]<B[i])\n\t\t\tans=max(ans,B[i]);\n\tans*=2;\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n//\tFile();\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> adjl1[200005];\nvector<int> adjl2[200005];\nint dist2[200005];\nint p[200005];\n\nvoid dfs2(int node, int parent){\n    for (auto x : adjl2[node]){\n        if (x==parent) continue;\n        dist2[x]=dist2[node]+1;\n        p[x] = node;\n        dfs2(x,node);\n    }\n}\n\nint dfs(int node, int parent,int d){\n    int ans = dist2[node]*2;\n    for (auto x : adjl1[node]){\n        if (x==parent) continue;\n        if (p[x]==node||p[node]==x||p[x]==p[node]||p[p[x]]==node||p[p[node]]==x){\n            if (d+1<dist2[x]){\n                int t = dfs(x,node,d+1);\n                if (t==-1) return -1;\n                ans = max(ans,t);\n            }\n        }\n        else return -1;\n\n    }\n    return ans;\n}\n\nint n,X,Y;\nint main(){\n    scanf(\"%d%d%d\",&n,&X,&Y);\n    for (int x = 0; x<n-1; x++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        adjl1[a].push_back(b);\n        adjl1[b].push_back(a);\n    }\n    for (int x = 0; x<n-1; x++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        adjl2[a].push_back(b);\n        adjl2[b].push_back(a);\n    }\n    dist2[Y] = 0;\n    dfs2(Y,-1);\n    p[Y]=-1;\n    printf(\"%d\",dfs(X,-1,0));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200010;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';x=(x<<1)+(x<<3)+ch-'0',ch=getchar());\n\treturn x*f;\n}\nstruct tree{\n\tint hea[maxn],nxt[maxn<<1],to[maxn<<1],tot;\n\tvoid add(int x,int y)\n\t{\n\t\tnxt[++tot]=hea[x];\n\t\thea[x]=tot;\n\t\tto[tot]=y;\n\t}\n}T[2];\nint dep[maxn][2],jump[maxn][20],maxx;\nvoid dfs(int now,int fa,int opt)\n{\n\tdep[now][opt]=dep[fa][opt]+1;\n\tif(opt==1)jump[now][0]=fa;\n\tfor(int i=T[opt].hea[now];i;i=T[opt].nxt[i])\n\t{\n\t\tint to=T[opt].to[i];\n\t\tif(to==fa)continue;\n\t\tdfs(to,now,opt);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x][1]<dep[y][1])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t\tif(dep[jump[x][i]][1]>=dep[y][1])\n\t\t\tx=jump[x][i];\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t\tif(jump[x][i]!=jump[y][i])\n\t\t\tx=jump[x][i],y=jump[y][i];\n\treturn jump[x][0];\n}\nvoid getans(int now,int fa)\n{\n\tif(fa)\n\t{\n\t\tint p=lca(now,fa);\n\t\tif(dep[now][1]+dep[fa][1]-2*dep[p][1]>2)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tif(dep[now][0]>=dep[now][1])return;\n\tmaxx=max(maxx,dep[now][1]);\n\tfor(int i=T[0].hea[now];i;i=T[0].nxt[i])\n\t{\n\t\tint y=T[0].to[i];\n\t\tif(y==fa)continue;\n\t\tgetans(y,now);\n\t}\n}\nint main()\n{\n\tint n=read(),x=read(),y=read(),s,t;\n\tfor(int ii=0;ii<2;ii++)\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\ts=read(),t=read();\n\t\t\tT[ii].add(s,t);\n\t\t\tT[ii].add(t,s);\n\t\t}\n\tdfs(x,0,0),dfs(y,0,1);\n\tfor(int i=1;i<20;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tjump[j][i]=jump[jump[j][i-1]][i-1];\n\tgetans(x,0);\n\tprintf(\"%d\\n\",2*maxx-2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,y,ans;\n\nvector<int> G[maxn],G2[maxn];\n\nint tim[maxn],fa[maxn];\n\nvoid dfs2(int u,int ff){\n\tfa[u]=ff;\n\ttim[u]=tim[ff]+1;\n\tfor(auto v:G2[u])if(v!=ff)dfs2(v,u);\n}\n\nbool check(int x,int y){\n\tif(fa[fa[x]]==y)return 0;\n\tif(fa[x]==y)return 0;\n\tif(fa[fa[y]]==x)return 0;\n\tif(fa[y]==x)return 0;\n\tif(fa[x]==fa[y])return 0;\n\treturn 1;\n}\n\nvoid dfs1(int u,int fa,int now){\n\tans=max(ans,(tim[u]-1)*2);\n\tfor(auto v:G[u])if(v!=fa){\n\t\tif(check(u,v)){\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tif(now+1<tim[v]&&v!=fa)dfs1(v,u,now+1);\n\t}\n}\n\nvoid Work(){\n\tif(x==y){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tdfs2(y,0);\n\tdfs1(x,0,1);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,x,y);\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG2[u].PB(v);G2[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nvector <int> y[N];\nll h1[N],h2[N];\nll par[N];\nll dfsg(ll v,ll p,ll h){\n    h1[v]=h;\n    for (auto u : g[v]){\n        if (u==p) continue;\n        dfsg(u,v,h+1);\n    }\n}\nll dfsy(ll v,ll p,ll h){\n    h2[v]=h;\n    par[v]=p;\n    for (auto u : y[v]){\n        if (u==p) continue;\n        dfsy(u,v,h+1);\n    }\n}\nll check(ll u,ll v){\n    if (par[u]==par[v] || u==par[v] || v==par[u] || v==par[par[u]] || u==par[par[v]]) return 0;\n    return 1;\n}\nll dp[N];\nvoid dfs(ll v,ll p){\n    if (h1[v]>=h2[v]) return ;\n    dp[v]=h2[v]-h1[v];\n    dp[v]*=2;\n    for (auto u : g[v]){\n        if (p==u) continue;\n        dfs(u,v);\n        dp[v]=max(dp[v],dp[u]+2);\n        if (check(u,v)) dp[v]=1e9;\n    }\n}\nint32_t main(){\n    ll n,x,y1;\n    cin >> n >> x >> y1;\n    for (int i=0;i<n-1;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    for (int i=0;i<n-1;i++){\n        ll u,v;\n        cin >> u >> v;\n        y[u].pb(v);\n        y[v].pb(u);\n    }\n    dfsg(x,x,1);\n    dfsy(y1,y1,1);\n    dfs(x,x);\n    if (dp[x]==1e9) kill(-1);\n    kill(dp[x]);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int N = (int) 2e5 + 100;\nvector <int> g[2][N];\n\nint h[2][N];\nint up[2][N];\nbool mark[N];\nint s[2];\n\nint smallDist(int t, int a, int b)\n{\n    int ans = 0;\n    while (ans < 3 && a != b)\n    {\n        if (h[t][a] > h[t][b])\n        {\n            a = up[t][a];\n            ans++;\n        }\n        else\n        {\n            b = up[t][b];\n            ans++;\n        }\n    }\n    if (ans < 3 && a != b) throw;\n    return ans;\n}\n\n\nvoid dfs(int t, int v, int par, int ch)\n{\n    h[t][v] = ch;\n    up[t][v] = par;\n    for (int to : g[t][v])\n    {\n        if (to == par)\n            continue;\n        dfs(t, to, v, ch + 1);\n    }\n}\n\nint n;\n\nvoid readG(int t)\n{\n    for (int i = 0; i < n - 1; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        a--;\n        b--;\n        g[t][a].push_back(b);\n        g[t][b].push_back(a);\n    }\n    dfs(t, s[t], s[t], 0);\n}\n\nint answer = 0;\n\nvoid dfsAns(int v, int par)\n{\n    answer = max(answer, h[1][v]);\n    if (mark[v])\n    {\n        answer = N;\n        return;\n    }\n    for (int to : g[0][v])\n    {\n        if (to == par)\n            continue;\n        answer = max(answer, h[1][to]);\n        if (h[0][to] < h[1][to])\n            dfsAns(to, v);\n    }\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    scanf(\"%d%d%d\", &n, &s[0], &s[1]);\n    s[0]--;\n    s[1]--;\n\n    readG(0);\n    readG(1);\n\n    for (int v = 0; v < n; v++)\n        for (int to : g[0][v])\n        {\n            //eprintf(\"%d %d : %d\\n\", v, to, smallDist(1, v, to));\n            if (smallDist(1, v, to) >= 3)\n            {\n                mark[v] = true;\n                mark[to] = true;\n            }\n        }\n\n    dfsAns(s[0], s[0]);\n\n    if (answer >= N)\n        answer = -1;\n    else\n        answer *= 2;\n    printf(\"%d\\n\", answer);\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int lg = 20;\nvector<int> red[N];\nvector<int> blue[N];\nint h[N];\nint par[lg + 5][N];\nint n, x, y;\nbool winPos[N];\nint disR[N];\nint disB[N];\n\n\nvoid dfs(int v = 0, int p = -1)\n{\n    for (int u : blue[v])\n    {\n        if (u != p)\n        {\n            par[0][u] = v;\n            h[u] = h[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nvoid pre()\n{\n    for (int k = 1; k < lg; k++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            par[k][i] = par[k - 1][ par[k - 1][i] ];\n        }\n    }\n}\n\nint lca(int v, int u)\n{\n    if(h[v] > h[u])\n    {\n        swap(v, u);\n    }\n    for (int i = 0; i < lg; i++)\n    {\n        if (h[u] - h[v] >> i & 1)\n        {\n            u = par[i][u];\n        }\n    }\n    for (int i = lg - 1; i >= 0; i--)\n    {\n        if(par[i][v] != par[i][u])\n        {\n            v = par[i][v], u = par[i][u];\n        }\n    }\n    return v == u ? v : par[0][v];\n}\n\nvoid dfs1(int v, int par = -1)\n{\n    if (disR[v] >= disB[v])\n    {\n        return;\n    }\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disR[u] = disR[v] + 1;\n            dfs1(u, v);\n        }\n    }\n}\n\nvoid dfs2(int v, int par = -1)\n{\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disB[u] = disB[v] + 1;\n            dfs2(u, v);\n        }\n    }\n}\n\n\n\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        red[u - 1].push_back(v - 1);\n        red[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        blue[u - 1].push_back(v - 1);\n        blue[v - 1].push_back(u - 1);\n    }\n    dfs();\n    pre();\n    for (int i = 0; i < n; i++)\n    {\n        for (auto u: red[i])\n        {\n            int tmp = lca(u, i);\n            if (h[u] - h[tmp] + h[i] - h[tmp] > 2)\n            {\n                winPos[i] = true;\n                winPos[u] = true;\n            }\n        }\n    }\n    memset(disR, 127, sizeof disR);\n    disR[x - 1] = 0;\n    dfs2(y - 1);\n    dfs1(x - 1);\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (winPos[i] && disR[i] <= disB[i])\n        {\n            cout << -1 << endl;\n            exit(0);\n        }\n        if (disR[i] < N)\n        {\n            ans = max(ans, max(disR[i], disB[i]) * 2);\n        }\n    }\n    cout << ans << endl;\n\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void mmax(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void mmin(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N, X, Y;\nmap<int, vector<int>> ab, cd;\n\nvector<int> gen_parent(int N, int root, map<int, vector<int>> &to)\n{\n    vector<int> res(N, -1);\n    queue<pint> q;\n    q.push(pint(root, -1));\n    while (!q.empty())\n    {\n        pint pa = q.front();\n        q.pop();\n        for (auto nxt : to[pa.first]) if (nxt != pa.second)\n        {\n            res[nxt] = pa.first;\n            q.push(pint(nxt, pa.first));\n        }\n    }\n    return res;\n}\n\n// 世代をつくる\nvector<int> generation(int N, int root, map<int, vector<int>> &to)\n{\n    vector<int> res(N); // res[root] = 0;\n    queue<pint> q;\n    q.push(pint(root, -1));\n    while(!q.empty())\n    {\n        pint pa = q.front();\n        q.pop();\n        if (pa.second >= 0) res[pa.first] = res[pa.second] + 1;\n        for (auto nxt : to[pa.first]) if (nxt != pa.second) q.push(pint(nxt, pa.first));\n    }\n    return res;\n}\n\nvector<vector<int>> doubling_parent(const vector<int> &par)\n{\n    int V = par.size();\n    int lnV = 1;\n    while ((1 << (lnV - 1)) < V) lnV++;\n\n    vector<vector<int>> res(lnV, vector<int>(V, -1));\n    res[0] = par;\n    FOR(d, 1, lnV) REP(i, V) if (res[d - 1][i] >= 0) res[d][i] = res[d - 1][res[d - 1][i]];\n    return res;\n}\n\npint lowest_common_ancestor(int s, int t, const vector<int> &gen, const vector<vector<int>> &doubling_par)\n{\n    pint res;\n    int d = 0, diff = gen[s] - gen[t];\n    if (diff < 0)\n    {\n        res = lowest_common_ancestor(t, s, gen, doubling_par);\n        return pint(res.second, res.first);\n    }\n    res.first = diff;\n    while (diff)\n    {\n        if (diff & 1) s = doubling_par[d][s];\n        d++, diff >>= 1;\n    }\n\n    if (s != t)\n    {\n        int oya = 1;\n        IREP(d, doubling_par.size()) if (doubling_par[d][s] != doubling_par[d][t])\n        {\n            oya += 1 << d;\n            s = doubling_par[d][s], t = doubling_par[d][t];\n        }\n        res.first += oya;\n        res.second += oya;\n    }\n    return res;\n}\n\nint nth_parent(int now, int k, const vector<vector<int>> &doubling_par)\n{\n    int d = 0;\n    while (k)\n    {\n        if (k & 1) now = doubling_par[d][now];\n        k >>= 1; d++;\n    }\n    return now;\n}\n\nvoid minus1()\n{\n    cout << -1 << endl;\n    exit(0);\n}\n\nvector<int> gen_cd, par_cd;\nvector<vector<int>> doubling_par_cd;\nbool is_safe(int x)\n{\n    for (auto nxt : ab[x])\n    {\n        pint pa = lowest_common_ancestor(x, nxt, gen_cd, doubling_par_cd);\n        if (pa.first + pa.second >= 3) return true;\n    }\n    return false;\n}\n\nint main()\n{\n    cin >> N >> X >> Y;\n    X--;\n    Y--;\n    REP(_, N - 1)\n    {\n        int a, b;\n        cin >> a >> b;\n        ab[a - 1].push_back(b - 1);\n        ab[b - 1].push_back(a - 1);\n    }\n    REP(_, N - 1)\n    {\n        int c, d;\n        cin >> c >> d;\n        cd[c - 1].push_back(d - 1);\n        cd[d - 1].push_back(c - 1);\n    }\n\n    gen_cd = generation(N, Y, cd);\n    par_cd = gen_parent(N, Y, cd);\n    doubling_par_cd = doubling_parent(par_cd);\n\n    set<int> ni, ni_tmp, Ys;\n    ni.insert(X);\n    ni_tmp.insert(X);\n    Ys.insert(Y);\n\n    int T = 0;\n    while (true)\n    {\n        T += 2;\n        set<int> ni_tmptmp;\n        for (auto now : ni_tmp)\n        {\n            if (is_safe(now)) minus1();\n            for (auto nxt : ab[now]) if (!ni.count(nxt)) ni.insert(nxt), ni_tmptmp.insert(nxt);\n        }\n        swap(ni_tmp, ni_tmptmp);\n\n        for (auto y : Ys)\n        {\n            ni.erase(y), ni_tmp.erase(y);\n            for (auto t : cd[y]) ni.erase(t), ni_tmp.erase(t);\n        }\n\n        if (ni.empty())\n        {\n            cout << T << endl;\n            return 0;\n        }\n\n        set<int> Ys_tmp;\n        for (auto y : Ys) for (auto nxt : cd[y]) if (nxt != par_cd[y]) Ys_tmp.insert(nxt);\n        swap(Ys, Ys_tmp);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<vector>\n#define N 210000\n#define pb push_back\nusing namespace std;\nstruct node{int y,nex;}a[2*N];\nint e[N][2],len,fir[N],n,sa,sb,dep[N],dfn[N],las[N],id,f[N],p[N],tail,d[N],ans;\nbool b[N],v[N];\nvector<int> A[N];\nvoid ins(int x,int y)\n{\n\ta[++len].y=y;a[len].nex=fir[x];fir[x]=len;\n}\nvoid dfs(int x,int fa)\n{\n\tf[x]=fa;\n\tdfn[x]=++id;\n\tdep[x]=dep[fa]+1;\n\tfor(int k=fir[x];k;k=a[k].nex)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y==fa) continue;\n\t\tdfs(y,x);\n\t}\n\tlas[x]=id;\n}\nbool check(int x,int y)\n{\n\tif(dep[x]>dep[y]) swap(x,y);\n\tif(dfn[x]<=dfn[y] && las[x]>=dfn[y])\n\t{\n\t\tif(dep[y]-dep[x]>2) return 1;\n\t\treturn 0;\n\t}\n\tif(f[x]==f[y]) return 0;\n\treturn 1;\n}\nvoid bfs()\n{\n\tv[sa]=1;p[1]=sa;tail=1;\n\tfor(int i=1;i<=tail;i++)\n\t{\n\t\tint x=p[i],siz=A[x].size();\n\t\tfor(int k=0;k<siz;k++)\n\t\t{\n\t\t\tint y=A[x][k];\n\t\t\td[y]=d[x]+1;\n\t\t\tif(d[y]<dep[y] && v[y]==0) {v[y]=1;p[++tail]=y;}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&sa,&sb);\n\tfor(int i=1;i<n;i++) scanf(\"%d%d\",&e[i][0],&e[i][1]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tins(x,y);ins(y,x);\n\t}\n\tdfs(sb,0);\n\tfor(int i=1;i<=n;i++) dep[i]--;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=e[i][0],y=e[i][1];\n\t\tif(check(x,y)) \n\t\t\tb[x]=b[y]=1;\n\t\telse A[e[i][0]].pb(e[i][1]),A[e[i][1]].pb(e[i][0]);\n\t}\n\tbfs();\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(v[i] && b[i]) {printf(\"-1\\n\");return 0;}\n\t\tif(v[i]) ans=max(ans,dep[i]*2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint n,x,y;\nvvi g[2];\nvi d[2],p,a;\n\nvoid In(int I){\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[I][u].push_back(v);\n\t\tg[I][v].push_back(u);\n\t}\n}\n\nvoid dfs(int v,int v_,int D,int I){\n\td[I][v]=D;\n\tif(I==1) p[v]=v_;\n\tfor(auto u:g[I][v]) if(u!=v_) dfs(u,v,D+1,I);\n}\n\nint DFS(int v,int v_){\n\tif(d[0][v]>=d[1][v]) return 0;\n\tif(a[v]) return inf;\n\tint t=0;\n\tfor(auto u:g[0][v]) if(u!=v_) t=max(t,DFS(u,v));\n\treturn max(t,2*d[1][v]);\n}\n\nint main(){\n\tcin>>n>>x>>y;\n\tx--;y--;\n\tg[0]=g[1]=vvi(n);\n\td[0]=d[1]=a=vi(n);\n\tp=vi(n+1);\n\tp[n]=n;\n\tIn(0);In(1);\n\tdfs(x,n,0,0);dfs(y,n,0,1);\n\tfor(int v=0;v<n;v++) for(auto u:g[0][v]){\n\t\tif(p[u]!=v&&p[v]!=u&&p[p[v]]!=u&&p[p[u]]!=v&&p[u]!=p[v]) a[u]=a[v]=1;\n\t}\n\tint res=DFS(x,n);\n\tcout<<(res==inf?-1:res)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 200005\nusing namespace std;\n//小号提交大号的代码别棕啊qwq\nint n,cnt,last[MAXN];\nint father[MAXN],deep[MAXN],dis[MAXN];\nint q[MAXN],nnn[MAXN],mx[MAXN];\nint tim,a[MAXN][2],xx,yy;\nbool vis[MAXN],win[MAXN];\n\nstruct edge\n{\n    int to,next,h;\n}t[MAXN*4];\n\nvoid add(int u,int v,int h)\n{\n    t[++cnt].to=v;t[cnt].h=h;\n    t[cnt].next=last[u];last[u]=cnt;\n    t[++cnt].to=u;t[cnt].h=h;\n    t[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n    deep[x]=deep[father[x]]+1;nnn[x]=++tim;\n    for (int i=last[x];i;i=t[i].next)\n        if (t[i].to!=father[x]) father[t[i].to]=x,dfs(t[i].to);\n    mx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n    if (nnn[x]>nnn[y]) swap(x,y);\n    if (nnn[x]<nnn[y]&&mx[x]>nnn[y]) return deep[y]-deep[x]>2 ? true : false;\n    if (father[x]==father[y]) return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int h=1,tt=1;q[1]=xx;vis[xx]=1;\n    while (h<=tt)\n    {\n        int x=q[h++];\n        for (int i=last[x];i;i=t[i].next)\n            if (!t[i].h&&!vis[t[i].to])\n            {\n                dis[t[i].to]=dis[x]+1;\n                if (dis[t[i].to]<deep[t[i].to]) vis[t[i].to]=1,q[++tt]=t[i].to;\n            }\n    }\n}\n\nint max(int a,int b){return a>b?a:b;}\n\ntemplate<class T>inline void read(T &res)\n{\n    static char ch;T flag=1;\n    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;\n    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;\n}\n\nint main()\n{\n    int ans=0;\n    read(n);read(xx);read(yy);\n\n    for (int i=1;i<n;i++) {read(a[i][0]);read(a[i][1]);}\n    for (int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x);read(y);\n        add(x,y,1);\n    }\n\n    deep[0]=-1;\n    dfs( yy );\n\n    for (int i=1;i<n;i++)\n    {\n        if (check(a[i][0],a[i][1]))\n            win[a[i][0]]=win[a[i][1]]=1;\n        else add(a[i][0],a[i][1],0);\n    }\n\n    bfs();\n\n    for (int i=1;i<=n;i++)\n        if (win[i]&&vis[i])\n            {putchar('-');putchar('1');return 0;}\n\n    for (int i=1;i<=n;i++)\n        if (vis[i])\n            ans=max(ans,deep[i]<<1);\n\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1e9;\nint n, x, y, rp[200010], rd[200010], bp[200010], bd[200010], ans;\nvector<int> re[200010], be[200010];\n\nvoid T_T(){ puts(\"-1\"); exit(0); }\n\nvoid f(int t, int x, int pr, int de, int *p, int *d){\n\tif(!t && bd[x] <= de) return;\n\td[x] = de;\n\tp[x] = pr;\n\tif(t){\n\t\tfor(auto &i : be[x]){\n\t\t\tif(i != pr) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n\telse{\n\t\tfor(auto &i : re[x]){\n\t\t\tif(i != pr) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tauto in = [](int t){\n\t\tfor(int i = 0, x, y; i < n - 1; i++){\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t(t ? be[x] : re[x]).push_back(y);\n\t\t\t(t ? be[y] : re[y]).push_back(x);\n\t\t}\n\t};\n\tin(0); in(1);\n\tf(1, y, 0, 0, bp, bd);\n\tfill(rd + 1, rd + n + 1, inf);\n\tf(0, x, 0, 0, rp, rd);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(auto &j : re[i]){\n\t\t\tint a = i, b = j;\n\t\t\tif(bd[a] > bd[b]) swap(a, b);\n\t\t\tif(bp[b] == a || bp[bp[b]] == a || bp[a] == bp[b]) continue;\n\t\t\tif(bd[a] > rd[a] || bd[b] > rd[b]) T_T();\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) if(rd[i] < inf) ans = max(ans, 2 * bd[i]);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> par;\n\nconst int N=200010;\n\nint n,x,y,cnt,a[N],b[N],G[N];\nint fa[N][20];\nstruct edge{\n  int t,nx;\n}E[N<<2];\n\ninline void addedge(int x,int y){\n  E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n  E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n}\n\nint dpt[N];\n\nvoid dfs(int x,int f){\n  if(f) dpt[x]=dpt[f]+1;\n  fa[x][0]=f; for(int i=1;i<=18;i++) fa[x][i]=fa[fa[x][i-1]][i-1];\n  for(int i=G[x];i;i=E[i].nx)\n    if(E[i].t!=f) dfs(E[i].t,x);\n}\n\nnamespace Grp{\n  int cnt,G[N];\n  struct edge{\n    int t,nx;\n  }E[N<<1];\n\n  inline void addedge(int x,int y){\n    E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n    E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n  }\n}\n\nqueue<int> Q;\nint dis[N],mark[N];\n\nconst int inf=1<<29;\n\ninline void bfs(){\n  for(int i=1;i<=n;i++) dis[i]=inf;\n  Q.push(x); dis[x]=0;\n  while(!Q.empty()){\n    int x=Q.front(); Q.pop();\n    for(int i=Grp::G[x];i;i=Grp::E[i].nx){\n      int v=Grp::E[i].t;\n      if(dis[x]+1>=dis[v]) continue;\n      if(dis[x]+1>=dpt[v]) continue;\n      dis[v]=dis[x]+1; Q.push(v);\n    }\n  }\n}\n\ninline int lca(int x,int y){\n  if(dpt[x]<dpt[y]) swap(x,y);\n  for(int i=18;~i;i--)\n    if(dpt[fa[x][i]]>=dpt[y]) x=fa[x][i];\n  if(x==y) return x;\n  for(int i=18;~i;i--)\n    if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n  return fa[x][0];\n}\n\ninline int dist(int x,int y){\n  return dpt[x]+dpt[y]-2*dpt[lca(x,y)];\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d\",&a[i],&b[i]);\n  for(int i=1,u,v;i<n;i++)\n    scanf(\"%d%d\",&u,&v),addedge(u,v);\n  dfs(y,0); dpt[0]=-1;\n  for(int i=1;i<n;i++)\n    if(dist(a[i],b[i])>2) mark[a[i]]=mark[b[i]]=1;\n    else Grp::addedge(a[i],b[i]);\n  bfs(); int ans=0;\n  if(mark[x]) return puts(\"-1\"),0;\n  for(int i=1;i<=n;i++){\n    if(mark[i] && dis[i]<dpt[i]) return puts(\"-1\"),0;\n    if(dis[i]<dpt[i]) ans=max(ans,dpt[i]*2);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint n,x,y;\nint xx[N],yy[N];\nint head[N],ver[N*2],nxt[N*2],tot;\nvoid add(int a,int b)\n{\n\ttot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint dis[N];\nint f[N][20];\nvoid dfs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(ver[i]==fa)continue;\n\t\tdis[ver[i]]=dis[x]+1;\n\t\tf[ver[i]][0]=x;\n\t\tdfs(ver[i],x);\n\t}\n\treturn ;\n}\nint ans;\nbool v[N];\nint lca(int a,int b)\n{\n\tif(dis[a]<dis[b])swap(a,b);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dis[f[a][i]]>=dis[b])a=f[a][i];\n\t}\n\tif(a==b)return a;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(f[a][i]!=f[b][i])\n\t\t{\n\t\t\ta=f[a][i];b=f[b][i];\n\t\t}\n\t}\n\treturn f[a][0];\n}\nint calc(int a,int b)\n{\n\treturn dis[a]+dis[b]-2*dis[lca(a,b)];\n}\nvoid dffs(int x,int fa,int now)\n{\n\tif(ans!=-1)ans=max(ans,(dis[x]-1)*2);\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(ver[i]==fa)continue;\n\t\tif(dis[ver[i]]<=now+1)continue;\n\t\tif(calc(x,ver[i])>=3)\n\t\t{\n\t\t\tans=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tdffs(ver[i],x,now+1);\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tint t1,t2;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&xx[i],&yy[i]);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tadd(t1,t2);add(t2,t1);\n\t}\n\tdis[y]=1;dfs(y,-1);\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tf[j][i]=f[f[j][i-1]][i-1];\n\t\t}\n\t}\n\ttot=0;memset(head,0,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(xx[i],yy[i]);add(yy[i],xx[i]);\n\t}\n\tdffs(x,-1,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint n,x,y;\nint xx[N],yy[N];\nint head[N],ver[N*2],nxt[N*2],tot;\nvoid add(int a,int b)\n{\n\ttot++;nxt[tot]=head[a];head[a]=tot;ver[tot]=b;return ;\n}\nint dis[N];\nint f[N][20];\nvoid dfs(int x,int fa)\n{\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(ver[i]==fa)continue;\n\t\tdis[ver[i]]=dis[x]+1;\n\t\tf[ver[i]][0]=x;\n\t\tdfs(ver[i],x);\n\t}\n\treturn ;\n}\nint ans;\nbool v[N];\nint lca(int a,int b)\n{\n\tif(dis[a]<dis[b])swap(a,b);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dis[f[a][i]]>=dis[b])a=f[a][i];\n\t}\n\tif(a==b)return a;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(f[a][i]!=f[b][i])\n\t\t{\n\t\t\ta=f[a][i];b=f[b][i];\n\t\t}\n\t}\n\treturn f[a][0];\n}\nint calc(int a,int b)\n{\n\treturn dis[a]+dis[b]-2*dis[lca(a,b)];\n}\nvoid dffs(int x,int fa,int now)\n{\n\tif(ans!=-1)ans=max(ans,(dis[x]-1)*2);\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(ver[i]==fa)continue;\n\t\tif(calc(x,ver[i])>=3)\n\t\t{\n\t\t\tans=-1;\n\t\t\tcontinue;\n\t\t}\n\t\tif(dis[ver[i]]<=now+1)continue;\n\t\tdffs(ver[i],x,now+1);\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tint t1,t2;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&xx[i],&yy[i]);\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tadd(t1,t2);add(t2,t1);\n\t}\n\tdis[y]=1;dfs(y,-1);\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tf[j][i]=f[f[j][i-1]][i-1];\n\t\t}\n\t}\n\ttot=0;memset(head,0,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(xx[i],yy[i]);add(yy[i],xx[i]);\n\t}\n\tdffs(x,-1,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = (a + (b)) % MOD\n#define Mul(a, b) a = (a * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 200010;\nconst ll maxnlg = 19;\n\nll n, X, Y;\npii es_a[maxn];\nvi g[2][maxn];\nll st[maxn], ft[maxn], pars[maxnlg][maxn], ht[maxn];\nll q[maxn * 2], col[maxn], d[maxn];\nbool vis[maxn];\n\nll tim = 0;\nvoid dfs_lca(ll x, ll par) {\n    st[x] = tim++;\n    pars[0][x] = par;\n    fori (i, maxnlg - 1) pars[i + 1][x] = pars[i][pars[i][x]];\n    for (auto y : g[1][x]) {\n        if (y != par) {\n            ht[y] = ht[x] + 1;\n            dfs_lca(y, x);\n        }\n    }\n    ft[x] = tim;\n}\n\nll LCA(ll a, ll b) {\n    if (st[a] > st[b]) swap(a, b);\n    if (ft[a] >= ft[b]) return a;\n    forir (i, maxnlg) {\n        if (ft[pars[i][a]] < ft[b]) a = pars[i][a];\n    }\n    return pars[0][a];\n}\n\nvoid MAIN() {\n\n    cin >> n >> X >> Y; --X, --Y;\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        es_a[i] = {a, b};\n        g[0][a].eb(b), g[0][b].eb(a);\n    }\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        g[1][a].eb(b), g[1][b].eb(a);\n    }\n\n    dfs_lca(Y, Y);\n\n    memset(col, -1, sizeof col);\n    memset(d, -1, sizeof d);\n    ll l = 0, r = 0;\n    q[r++] = X;\n    q[r++] = Y;\n    vis[X] = true;\n    col[X] = 0;\n    col[Y] = 1;\n    while (r != l) {\n        ll x = q[l++];\n        for (auto y : g[col[x]][x]) {\n            if (col[y] == -1 || col[x] == 1 && col[y] != 1) {\n                if (col[x] == 0) vis[y] = true;\n                col[y] = col[x];\n                q[r++] = y;\n            }\n        }\n    }\n\n    fori (i, n - 1) {\n        ll a, b; tie(a, b) = es_a[i];\n        if ((vis[a] || vis[b]) && ht[a] + ht[b] - ht[LCA(a, b)] * 2 > 2) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    ll ans = 0;\n    fori (i, n) {\n        if (vis[i]) smax(ans, ht[i]);\n    }\n    cout << ans * 2 << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nconst int N=200005;\n\nstruct node{\n\tint x,y;\n\tnode(){}\n\tnode(int x,int y):x(x),y(y){}\n}a[N];\nint n,x,y,S,T,cnt,rt,ans,z;\nint dep[N],vis[N],dis[N],fa[N],in[N],ot[N],tag[N];\nvector<int> lv1[N],lv2[N];\nqueue<int> q;\n\nvoid dfs2(int k,int pre){\n\tint j,u;\n\tin[k]=++cnt;\n\tfor (j=0;j<lv2[k].size();j++){\n\t\tu=lv2[k][j];\n\t\tif (u==pre) continue;\n\t\tdep[u]=dep[k]+1; fa[u]=k;\n\t\tdfs2(u,k);\n\t}\n\tot[k]=++cnt;\n}\n\nbool check(int x,int y){\n\tif (in[x]>in[y]) swap(x,y);\n\tif (in[x]<in[y]&&ot[x]>in[y]) return (dep[y]-dep[x]>2);\n\tif (fa[x]==fa[y]) return 0;\n\treturn 1;\n}\n\nvoid bfs(){\n\tint j,k,u;\n\tq.push(S); vis[S]=1;\n\twhile (!q.empty()){\n\t\tk=q.front(); q.pop();\n\t\tfor (j=0;j<lv1[k].size();j++){\n\t\t\tu=lv1[k][j];\n\t\t\tif (!vis[u]&&dis[k]+1<dep[u]){\n\t\t\t\tdis[u]=dis[k]+1;\n\t\t\t\tvis[u]=1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d%d%d\",&n,&S,&T);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ta[i]=node(x,y);\n\t}\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlv2[x].push_back(y);\n\t\tlv2[y].push_back(x);\n\t}\n\tdfs2(T,0);\n\tfor (i=1;i<n;i++){\n\t\tif (check(a[i].x,a[i].y)) tag[a[i].x]=tag[a[i].y]=1;\n\t\telse{\n\t\t\tlv1[a[i].x].push_back(a[i].y);\n\t\t\tlv1[a[i].y].push_back(a[i].x);\n\t\t}\n\t}\n\tbfs();\n\tfor (i=1;i<=n;i++)\n\t\tif (tag[i]&&vis[i]){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor (i=1;i<=n;i++)\n\t\tif (vis[i]) ans=max(ans,dep[i]*2);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, s1, s2;\nvector<int>E[201000], G[201000];\nstruct Edge {\n\tint a, b;\n}Ed[201000];\nint par[201000], Dep[201000], v[201000];\nvoid DFS1(int a, int pp) {\n\tpar[a] = pp;\n\tint i;\n\tfor (i = 0; i < E[a].size(); i++) {\n\t\tif (E[a][i] != pp) {\n\t\t\tDep[E[a][i]] = Dep[a] + 1;\n\t\t\tDFS1(E[a][i], a);\n\t\t}\n\t}\n}\nvoid DFS2(int a, int pp, int d) {\n\tint i;\n\tv[a] = 1;\n\tfor (i = 0; i < G[a].size(); i++) {\n\t\tif (G[a][i] != pp && d + 1 < Dep[G[a][i]])DFS2(G[a][i], a, d + 1);\n\t}\n}\nint main() {\n\tint i, a, b;\n\tscanf(\"%d%d%d\", &n, &s1, &s2);\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tEd[i] = { a,b };\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tDFS1(s2, 0);\n\tDFS2(s1, 0, 0);\n\tint res = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tif (v[i])res = max(res, Dep[i] * 2);\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\ta = Ed[i].a, b = Ed[i].b;\n\t\tif (Dep[a] < Dep[b])swap(a, b);\n\t\tif (par[a] == b || par[par[a]] == b || par[a] == par[b])continue;\n\t\tif (v[a] || v[b]) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) //fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=2e5+50,oo=1e9;\n\nint ans,dep[N],prt[N],n,pX,pY,eu[N],win[N],ev[N];\n\nvector<int> g[N],g2[N];\n\nvoid dfs(int v,int p){\n\tprt[v]=p;\n\tfor(int d:g[v])if(d!=p){\n\t\tdep[d]=dep[v]+1;\n\t\tdfs(d,v); \n\t}\n}\n\nvoid chk(int u,int v){\n\tbool ok=false;\n\tok|=prt[u]==v||prt[v]==u;\n\tok|=prt[u]==prt[v]||prt[prt[u]]==v||prt[prt[v]]==u;\n\tPr(\"Chk %d,%d,ok=%d\\n\",u,v,(int)ok); \n\tif(!ok)win[u]=win[v]=true;\n\telse g2[u].pb(v),g2[v].pb(u);\n}\n\nint q[N],h,t,dis[N];\nvoid bfs(){\n\tmem(dis,-1); \n\tq[t++]=pX;\n\tdis[pX]=0;\n\twhile(h!=t){\n\t\tint v=q[h++];\n\t\tfor(int d:g2[v])if(dis[d]==-1){\n\t\t\tdis[d]=dis[v]+1;\n\t\t\tPr(\"d=%d,dep[d]=%d\\n\",d,dep[d]);\n\t\t\tif(dep[d]>dis[d])q[t++]=d;\n\t\t}\n\t}\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout);\n#endif\n\tread(n),read(pX),read(pY); \n\trep(i,1,n-1)read(eu[i]),read(ev[i]); \n\trep(i,1,n-1){\n\t\tint u,v;\n\t\tread(u),read(v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs(pY,0);\n\trep(i,1,n-1){\n\t\tchk(eu[i],ev[i]); \n\t}\n\tbfs();\n\trep(i,1,n)if(dis[i]!=-1&&dep[i]>dis[i]){\n\t\tif(win[i])ans=oo;\n\t\telse cmax(ans,2*(dep[i]));\n\t}\n\tprintf(\"%d\\n\",ans==oo?-1:ans); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N, X, Y;\n\nvvll g;\nvvll h;\n\nvll par;\nvll ht;\n\nvoid dfsh(ll u, ll v) {\n\tpar[v] = u;\n\tht[v] = ht[u] + 1;\n\t\n\tfor (ll w : h[v]) {\n\t\tif (u == w) { continue; }\n\t\tdfsh(v, w);\n\t}\n\treturn;\n}\n\n\nint main(){\n\tcout << -1 << endl;\n\treturn 0;\n\n\tcin >> N >> X >> Y;\n\tg.resize(N + 1);\n\th.resize(N + 1);\n\trepn(i, N - 1) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\trepn(i, N - 1) {\n\t\tll c, d;\n\t\tcin >> c >> d;\n\t\th[c].push_back(d);\n\t\th[d].push_back(c);\n\t}\n\n\tpar.assign(N + 1, 0);\n\tht.assign(N + 1, -1);\n\tdfsh(0, Y);\n\t//repn(v, N)cout << par[v] << ht[v] << endl;\n\n\n\tvll win(N + 1, 0);\n\trepn(v, N) {\n\t\tfor (ll w : g[v]) {\n\t\t\tbool b = 1;\n\t\t\tif (par[w] == v || par[v] == w) { b = 0; }\n\t\t\tif (par[par[w]] == v || par[v] == par[w] || par[par[v]] == w) { b = 0; }\n\t\t\tif (b) { win[v] = 1; break; }\n\t\t}\n\n\t\t//cout << v << win[v] << endl;\n\t}\n\n\tset<pair<ll, ll>> st;\n\tvll lis;\n\tvll vis(N + 1, 0);\n\n\tst.insert({ ht[X],X });\n\tvis[X] = 1;\n\tlis.push_back(X);\n\n\n\tll tern = 0;\n\twhile (!st.empty()) {\n\t\tvll nlis;\n\n\t\tfor (ll v : lis) {\n\t\t\tfor (ll w : g[v]) {\n\t\t\t\tif (vis[w] == 1) { continue; }\t\t\t\t\n\t\t\t\tif (ht[w] == tern) { continue; }\n\n\t\t\t\tnlis.push_back(w);\n\t\t\t\tst.insert({ ht[w],w });\n\t\t\t\tvis[w] = 1;\n\n\t\t\t\tif (win[w] == 1) { cout << -1 << endl; return 0; }\n\t\t\t}\n\t\t}\n\n\t\tlis = nlis;\n\t\twhile (!st.empty()&&(*st.begin()).first <= tern + 1) {\n\t\t\tst.erase(st.begin());\n\t\t}\n\t\t\n\t\ttern++;\n\t\n\t}\n\n\tcout << tern * 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,X,Y,par[MX], dist[2][MX];\nvi adj[2][MX];\nbool spec[MX];\nvpi ed;\n\nvoid dfs(int x) {\n\ttrav(t,adj[1][x]) if (t != par[x]) {\n\t\tpar[t] = x; dist[1][t] = dist[1][x]+1;\n\t\tdfs(t);\n\t}\n}\n\nbool far(int a, int b) {\n\tint d = 0;\n\twhile (a != b) {\n\t\tif (dist[1][a] < dist[1][b]) swap(a,b);\n\t\ta = par[a]; d ++; if (d > 2) return 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n    setIO(); re(N,X,Y);\n    F0R(i,N-1) {\n    \tint a,b; re(a,b);\n    \ted.pb({a,b});\n    }\n    F0R(i,N-1) {\n    \tint c,d; re(c,d);\n    \tadj[1][c].pb(d), adj[1][d].pb(c);\n    }\n    dfs(Y);\n    trav(t,ed) {\n    \tif (far(t.f,t.s)) spec[t.f] = spec[t.s] = 1;\n    \telse adj[0][t.f].pb(t.s), adj[0][t.s].pb(t.f);\n    }\n    FOR(i,1,N+1) dist[0][i] = MOD;\n    queue<int> q; q.push(X); dist[0][X] = 0;\n    int ret = 0;\n    while (sz(q)) {\n    \tint x = q.front(); q.pop();\n    \tif (dist[0][x] > dist[1][x]) continue;\n    \tckmax(ret,2*dist[1][x]);\n    \tif (spec[x]) {\n    \t\tps(-1);\n    \t\texit(0);\n    \t}\n    \tif (dist[0][x] == dist[1][x]) continue;\n    \ttrav(t,adj[0][x]) if (dist[0][t] == MOD) {\n    \t\tdist[0][t] = dist[0][x]+1;\n    \t\tq.push(t);\n    \t}\n    }\n    ps(ret);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint n;\nvvi s, t;\nvi ds, dt;\n\n// LCA (0-indexed)\nstruct LCA {\n  int n, bi;\n  vi dep;\n  vector<vi> to, par;\n  LCA(int n):n(n),dep(n),to(n){}\n  void add(int a, int b){ to[a].pb(b); to[b].pb(a);}\n  void calcDep(int v, int ndep=0, int p=-1){\n    dep[v] = ndep; par[0][v] = p;\n    for(int u : to[v]) if(u != p) calcDep(u,ndep+1,v);\n  }\n  void init(){\n    bi = 0;\n    while(1<<bi <= n) bi++;\n    par.resize(bi,vi(n,-1));\n    calcDep(0);\n    rep(i,bi-1)rep(j,n) par[i+1][j] = (par[i][j]==-1?-1:par[i][par[i][j]]);\n  }\n  int lca(int a, int b){\n    if(dep[a] < dep[b]) swap(a,b);\n    int x = dep[a]-dep[b];\n    for(int i = bi-1; i >= 0; --i){\n      if(1<<i <= x) a = par[i][a], x -= 1<<i;\n    }\n    if(a == b) return a;\n    for(int i = bi-1; i >= 0; --i){\n      if(par[i][a] != par[i][b]) a = par[i][a], b = par[i][b];\n    }\n    return par[0][a];\n  }\n  int dist(int a, int b){\n    int c = lca(a,b);\n    return dep[a]+dep[b] - dep[c]*2;\n  }\n};\n//\n\nvoid bfs(vvi& g, vi& d, int sv) {\n  d[sv] = 0;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == INF) {\n        d[u] = d[v]+1;\n        q.push(u);\n      }\n    }\n  }\n}\nvoid cfs(vvi& g, vi& d, int sv) {\n  if (d[sv] != 1) return;\n  d[sv] = 2;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == 1) {\n        d[u] = 2;\n        q.push(u);\n      }\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d\",&n);\n  int x, y;\n  scanf(\"%d%d\",&x,&y);\n  --x; --y;\n  s = t = vvi(n);\n  LCA g(n);\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    s[a].pb(b);\n    s[b].pb(a);\n  }\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    t[a].pb(b);\n    t[b].pb(a);\n    g.add(a,b);\n  }\n  g.init();\n  ds = dt = vi(n,INF);\n  bfs(s,ds,x);\n  bfs(t,dt,y);\n  int ans = 0;\n  vi c(n);\n  rep(i,n) if (ds[i] < dt[i]) c[i] = 1;\n  cfs(s,c,x);\n  rep(i,n) {\n    if (c[i] != 2) continue;\n    maxs(ans, dt[i]*2);\n    for (int u : s[i]) {\n      if (c[u] != 2) continue;\n      if (g.dist(i,u) >= 3) {\n        puts(\"-1\");\n        assert(false);\n        return 0;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200010;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';x=(x<<1)+(x<<3)+ch-'0',ch=getchar());\n\treturn x*f;\n}\nstruct tree{\n\tint hea[maxn],nxt[maxn<<1],to[maxn<<1],tot;\n\tvoid add(int x,int y)\n\t{\n\t\tnxt[++tot]=hea[x];\n\t\thea[x]=tot;\n\t\tto[tot]=y;\n\t}\n}T[2];\nint dep[maxn][2],jump[maxn][20],maxx;\nvoid dfs(int now,int fa,int opt)\n{\n\tdep[now][opt]=dep[fa][opt]+1;\n\tif(opt==1)jump[now][0]=fa;\n\tfor(int i=T[opt].hea[now];i;i=T[opt].nxt[i])\n\t{\n\t\tint to=T[opt].to[i];\n\t\tif(to==fa)continue;\n\t\tdfs(to,now,opt);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x][1]<dep[y][1])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t\tif(dep[jump[x][i]][1]>=dep[y][1])\n\t\t\tx=jump[x][i];\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t\tif(jump[x][i]!=jump[y][i])\n\t\t\tx=jump[x][i],y=jump[y][i];\n\treturn jump[x][0];\n}\nvoid getans(int now,int fa)\n{\n\tif(fa)\n\t{\n\t\tint p=lca(now,fa);\n\t\tif(dep[now][1]+dep[fa][1]-2*dep[p][1]>2)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tif(dep[now][0]>=dep[now][1])return;\n\tmaxx=max(maxx,dep[now][1]);\n\tfor(int i=T[0].hea[now];i;i=T[0].nxt[i])\n\t{\n\t\tint y=T[0].to[i];\n\t\tif(y==fa)continue;\n\t\tgetans(y,now);\n\t}\n}\nint main()\n{\n\tint n=read(),x=read(),y=read(),s,t;\n\tfor(int ii=0;ii<2;ii++)\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\ts=read(),t=read();\n\t\t\tT[ii].add(s,t);\n\t\t\tT[ii].add(t,s);\n\t\t}\n\tdfs(x,0,0),dfs(y,0,1);\n\tfor(int i=1;i<20;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tjump[j][i]=jump[jump[j][i-1]][i-1];\n\tgetans(x,0);\n\tprintf(\"%d\\n\",2*maxx-2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nclass LCA{\n\tpublic:\n\tint N,root,max_log;\n\tvvi G,parent;\n\tvi depth;\n\tLCA(int size){\n\t\tN=size;\n\t\tG=vvi(size);\n\t\tmax_log=20;\n\t\tdepth=vi(size);\n\t\tparent=vvi(max_log,vi(size));\n\t}\n\tvoid add_edge(int a,int b){\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tvoid dfs(int v,int p,int d){\n\t\tparent[0][v]=p;\n\t\tdepth[v]=d;\n\t\trep(i,G[v].size())if(G[v][i]!=p)dfs(G[v][i],v,d+1);\n\t}\n\tvoid init(){\n\t\troot=0;\n\t\tdfs(root,-1,0);\n\t\tfor(int k=0;k+1<max_log;k++){//doubling\n\t\t\tfor(int v=0;v<N;v++){\n\t\t\t\tif(parent[k][v]<0)parent[k+1][v]=-1;\n\t\t\t\telse parent[k+1][v]=parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u,int v){\n\t\tint out=depth[u]+depth[v];\n\t\tif(depth[u]>depth[v])swap(u,v);\n\t\trep(k,max_log)if((depth[v]-depth[u])>>k&1)v=parent[k][v];\n\t\tif(u==v){\n\t\t\tout-=2*depth[u];\n\t\t\treturn out;\n\t\t}\n\t\tfor(int k=max_log-1;k>=0;k--){\n\t\t\tif(parent[k][u]!=parent[k][v]){\n\t\t\t\tu=parent[k][u];\n\t\t\t\tv=parent[k][v];\n\t\t\t}\n\t\t}\n\t\tout-=2*depth[parent[0][u]];\n\t\treturn out;\n\t}\n};\nint n,x,y,out;\nvvi G,tG;\nvi co,h;\nvoid dfs1(int a,int p,int c){\n\tco[a]=c;\n\trep(i,tG[a].size()){\n\t\tint to=tG[a][i];\n\t\tif(to==p)continue;\n\t\tdfs1(to,a,c+1);\n\t}\n}\nvoid dfs2(int a,int p,int c){\n\tif(c>=co[a])return;\n\tif(h[a])out=inf;\n\tcmax(out,2*co[a]);\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tdfs2(to,a,c+1);\n\t}\n}\nsigned main(){\n\tcin>>n>>x>>y;\n\tG=tG=vvi(n);\n\tco=h=vi(n);\n\tLCA lca(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tlca.add_edge(a,b);\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tlca.init();\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\ttG[a].pb(b);\n\t\ttG[b].pb(a);\n\t\tif(lca.lca(a,b)>=3)h[a]=h[b]=1;\n\t}\n\tdfs1(y-1,-1,0);\n\tdfs2(x-1,-1,0);\n\tif(out==inf)cout<<-1<<endl;\n\telse cout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = (a + (b)) % MOD\n#define Mul(a, b) a = (a * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 200010;\nconst ll maxnlg = 19;\n\nll n, X, Y;\npii es_a[maxn];\nvi g[2][maxn];\nll st[maxn], ft[maxn], pars[maxnlg][maxn], ht[maxn];\nll q[maxn * 2], col[maxn];\nbool vis[maxn], vis2[maxn];\n\nll tim = 0;\nvoid dfs_lca(ll x, ll par) {\n    st[x] = tim++;\n    pars[0][x] = par;\n    fori (i, maxnlg - 1) pars[i + 1][x] = pars[i][pars[i][x]];\n    for (auto y : g[1][x]) {\n        if (y != par) {\n            ht[y] = ht[x] + 1;\n            dfs_lca(y, x);\n        }\n    }\n    ft[x] = tim;\n}\n\nll LCA(ll a, ll b) {\n    if (st[a] > st[b]) swap(a, b);\n    if (ft[a] >= ft[b]) return a;\n    forir (i, maxnlg) {\n        if (ft[pars[i][a]] < ft[b]) a = pars[i][a];\n    }\n    return pars[0][a];\n}\n\nvoid MAIN() {\n\n    cin >> n >> X >> Y; --X, --Y;\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        es_a[i] = {a, b};\n        g[0][a].eb(b), g[0][b].eb(a);\n    }\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        g[1][a].eb(b), g[1][b].eb(a);\n    }\n\n    dfs_lca(Y, Y);\n\n    memset(col, -1, sizeof col);\n    ll l = 0, r = 0;\n    q[r++] = Y;\n    q[r++] = X;\n    vis[X] = true;\n    col[X] = 0;\n    col[Y] = 1;\n    while (r != l) {\n        ll x = q[l++];\n        for (auto y : g[col[x]][x]) {\n            if (col[y] == -1 || col[x] == 1 && col[y] != 1) {\n                if (col[x] == 0) vis[y] = true;\n                col[y] = col[x];\n                q[r++] = y;\n            }\n        }\n    }\n\n    memset(col, -1, sizeof col);\n    l = 0, r = 0;\n    q[r++] = X;\n    q[r++] = Y;\n    vis2[X] = true;\n    col[X] = 0;\n    col[Y] = 1;\n    while (r != l) {\n        ll x = q[l++];\n        for (auto y : g[col[x]][x]) {\n            if (col[y] == -1 || col[x] == 1 && col[y] != 1) {\n                if (col[x] == 0) vis2[y] = true;\n                col[y] = col[x];\n                q[r++] = y;\n            }\n        }\n    }\n\n    fori (i, n - 1) {\n        ll a, b; tie(a, b) = es_a[i];\n        if ((vis[a] || vis[b]) && ht[a] + ht[b] - ht[LCA(a, b)] * 2 > 2) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    ll ans = 0;\n    fori (i, n) {\n        if (vis2[i]) smax(ans, ht[i]);\n    }\n    cout << ans * 2 << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n5 2 1\n1 5\n1 4\n4 3\n3 2\n1 5\n5 3\n1 4\n2 3\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int oo = 0x3f3f3f3f;\nconst int maxn = 200000 + 5;\n \ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nint n, A, B;\nvector<int> G[maxn], T[maxn];\n\nbool flag[maxn];\nint fa[maxn][21], dep[maxn];\n\nvoid dfs(int u, int f = 0) {\n    fa[u][0] = f;\n    dep[u] = dep[f] + 1;\n    for(int i = 1; i <= 20; ++i) fa[u][i] = fa[fa[u][i-1]][i-1];\n    for(int i = 0; i < int(G[u].size()); ++i) if(G[u][i] != f) { dfs(G[u][i], u); }\n}\nint lca(int u, int v) {\n    if(dep[u] < dep[v]) swap(u, v);\n    for(int i = 20; i >= 0; --i) \n        if(dep[fa[u][i]] >= dep[v]) u = fa[u][i];\n\n    if(u == v) return u;\n    for(int i = 20; i >= 0; --i) if(fa[u][i] ^ fa[v][i])\n        u = fa[u][i], v = fa[v][i];\n    return fa[u][0];\n}\ninline int dis(int u, int v) { return dep[u] + dep[v] - (dep[lca(u, v)] << 1); }\n\nvoid Input() {\n    n = read<int>();\n    A = read<int>();\n    B = read<int>();\n\n    for(int i = 1; i < n; ++i) {\n        static int x, y;\n        x = read<int>();\n        y = read<int>();\n        T[x].pb(y), T[y].pb(x);\n    }\n\n    for(int i = 1; i < n; ++i) {\n        static int x, y;\n        x = read<int>();\n        y = read<int>();\n        G[x].pb(y), G[y].pb(x);\n    }\n\n    dfs(B, 0);\n\n    for(int i = 1; i <= n; ++i) {\n        for(int j = 0; j < int(T[i].size()); ++j) {\n            int v = T[i][j];\n            if(dis(i, v) > 2) flag[i] = flag[v] = true;\n        }\n    }\n}\n\nint ans = 1;\nvoid Dfs(int u, int fu = 0, int step = 1) {\n\n    if(dep[u] == step) return;\n    if(flag[u]) {\n        puts(\"-1\"); \n        exit(0);\n    }\n\n    chkmax(ans, dep[u]);\n    for(int i = 0; i < int(T[u].size()); ++i) if(T[u][i] != fu) {\n        if(dep[T[u][i]] > step) Dfs(T[u][i], u, step + 1);\n    }\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"b.in\", \"r\", stdin);\n    freopen(\"b.out\", \"w\", stdout);\n#endif\n\n    Input();\n    Dfs(A, 0);\n    printf(\"%d\\n\", (ans - 1) << 1);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2000005;\n\nint N,X,Y;\nvector<int> red[MAXN],blue[MAXN];\nint dep[MAXN],fa[MAXN];\n\nbool isTable(int u,int v)\n{\n\tif(dep[u]>dep[v])\n\t\tswap(u,v);\n\tif(fa[v]==u||fa[fa[v]]==u||fa[u]==fa[v])\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs1(int u)\n{\n\tfor(auto v:blue[u])\n\t\tif(v!=fa[u])\n\t\t{\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs1(v);\n\t\t}\n}\nint dfs2(int u,int f=0,int step=0)\n{\n\tstep++;\n\tint res=dep[u];\n\tfor(auto v:red[u])\n\t{\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tif(isTable(u,v))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tres=max(res,dep[v]);\n\t\tif(dep[v]>step)\n\t\t\tres=max(res,dfs2(v,u,step+1));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&X,&Y);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred[u].push_back(v);\n\t\tred[v].push_back(u);\n\t}\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue[u].push_back(v);\n\t\tblue[v].push_back(u);\n\t}\n\tdfs1(Y);\n\tint ans=dfs2(X)*2;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\nconst int MaxN = 2e5 + 5;\n\nvector<int> gb[MaxN], gr[MaxN];\n\nint dep[MaxN], fa[MaxN], d[MaxN];\nbool safe[MaxN], vis[MaxN];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, sx, sy;\n  cin >> n >> sx >> sy;\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    gr[x].emplace_back(y);\n    gr[y].emplace_back(x);\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    gb[x].emplace_back(y);\n    gb[y].emplace_back(x);\n  }\n  list<int> Q;\n  Q.emplace_back(sy);\n  fa[sy] = -1;\n  vis[sy] = true;\n  while (!Q.empty()) {\n    int k = Q.front();\n    for (int x : gb[k]) {\n      if (!vis[x]) {\n        Q.emplace_back(x);\n        vis[x] = true;\n        dep[x] = dep[k] + 1;\n        fa[x] = k;\n      }\n    }\n    Q.pop_front();\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int k : gr[i]) {\n      if (![](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n      } (i, k)) {\n        safe[i] = safe[k] = true;\n      }\n    }\n  }\n  if (safe[sx]) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int ans = 0;\n  memset(d, 0xff, sizeof d);\n  d[sx] = 0;\n  Q.emplace_back(sx);\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop_front();\n    if (d[k] >= dep[k]) {\n      continue;\n    }\n    if (safe[k]) {\n      cout << -1 << endl;\n      return 0;\n    }\n    ans = max(ans, dep[k] * 2);\n    for (int x : gr[k]) {\n      if (vis[x] && d[k] + 1 < dep[x] && [](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n        } (k, x)) {\n        d[x] = d[k] + 1;\n        vis[x] = false;\n        Q.emplace_back(x);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=200007;\nstd::vector<int>e1[N],e2[N];\nint n,p1,p2,dep[N],fa[N],un[N],ans=0;\nvoid f1(int w,int pa){\n\tfor(int i=0;i<e2[w].size();++i){\n\t\tint u=e2[w][i];\n\t\tif(u!=pa){\n\t\t\tdep[u]=dep[w]+2;\n\t\t\tfa[u]=w;\n\t\t\tf1(u,w);\n\t\t}\n\t}\n}\nvoid f2(int w,int pa,int d){\n\tif(d>dep[w])return;\n\tif(un[w])ans=-1;\n\tif(ans!=-1&&ans<dep[w])ans=dep[w];\n\tfor(int i=0;i<e1[w].size();++i){\n\t\tint u=e1[w][i];\n\t\tif(u!=pa)f2(u,w,d+2);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&p1,&p2);\n\tfor(int i=1,a,b;i<n;++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te1[a].push_back(b);\n\t\te1[b].push_back(a);\n\t}\n\tfor(int i=1,a,b;i<n;++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te2[a].push_back(b);\n\t\te2[b].push_back(a);\n\t}\n\tf1(p2,0);\n\tfor(int w=1;w<=n;++w){\n\t\tfor(int i=0;i<e1[w].size();++i){\n\t\t\tint a=w,b=e1[w][i],c=0;\n\t\t\tfor(;a!=b&&c<3;++c){\n\t\t\t\tif(dep[a]>dep[b])a=fa[a];\n\t\t\t\telse b=fa[b];\n\t\t\t}\n\t\t\tif(c==3)un[w]=1;\n\t\t}\n\t}\n\tf2(p1,0,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define N 200010\nusing namespace std;\nint n,cnt,tot,X,Y,ans,head[N],fa[N],dep[N],dis[N],Q[N],be[N],ed[N],a[N][2];\nbool vis[N],p[N];\nstruct edge { int to,from,v; }e[N*4];\n\nvoid insert(int x,int y,int v) \n{\n\te[++cnt].to=y,e[cnt].from=head[x],head[x]=cnt,e[cnt].v=v;\n\te[++cnt].to=x,e[cnt].from=head[y],head[y]=cnt,e[cnt].v=v;\n}\nvoid dfs(int x)\n{\n\tdep[x]=dep[fa[x]]+1,be[x]=++tot;\n\tfor (int i=head[x];i;i=e[i].from) if (e[i].to!=fa[x]) fa[e[i].to]=x,dfs(e[i].to);\n\ted[x]=++tot;\n}\nvoid bfs()\n{\n\tint l=1,r=1; Q[1]=X,vis[X]=1;\n\twhile (l<=r)\n\t{\n\t\tint x=Q[l++];\n\t\tfor (int i=head[x];i;i=e[i].from) if (!e[i].v&&!vis[e[i].to])\n\t\t{\n\t\t\tdis[e[i].to]=dis[x]+1;\n\t\t\tif (dis[e[i].to]<dep[e[i].to]) vis[e[i].to]=1,Q[++r]=e[i].to;\n\t\t}\n\t}\n}\nbool pd(int x,int y)\n{\n\tif (be[x]>be[y]) swap(x,y);\n\tif (be[x]<be[y]&&ed[x]>ed[y]) return dep[y]-dep[x]>2?true:false;\n\tif (fa[x]==fa[y]) return false;\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor (int i=1;i<n;i++) scanf(\"%d%d\",&a[i][0],&a[i][1]);\n\tfor (int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),insert(x,y,1);\n\tdep[0]=-1,dfs(Y);\n\tfor (int i=1;i<n;i++) if (pd(a[i][0],a[i][1])) p[a[i][0]]=p[a[i][1]]=1; else insert(a[i][0],a[i][1],0);\n\tbfs();\n\tfor (int i=1;i<=n;i++) if (p[i]&&vis[i]) { printf(\"-1\"); return 0; }\n\tfor (int i=1;i<=n;i++) if (vis[i]) ans=max(ans,dep[i]*2);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chkmax(T& a,T b){return a<b?a=b,1:0;}\ntemplate<class T> inline bool chkmin(T& a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T& read(T& x){\n    static char c; bool flag=0;\n    while(!isdigit(c=getchar())) if(c=='-') flag=1;\n    for(x=c-'0';isdigit(c=getchar());(x*=10)+=c-'0');\n    if(flag) x=-x;\n    return x;\n}\nconst int maxn=200010;\nint n,A,B;\nint head[maxn],nxt[maxn<<1],to[maxn<<1],e;\nint head2[maxn],nxt2[maxn<<1],to2[maxn<<1],e2;\nvoid ae(int x,int y){\n    to[++e]=y; nxt[e]=head[x]; head[x]=e;\n}\nvoid ae2(int x,int y){\n    to2[++e2]=y; nxt2[e2]=head2[x]; head2[x]=e2;\n}\nint fa[maxn][20],dep[maxn];\nvoid dfs(int u){\n    for(int i=1;i<20;i++) fa[u][i]=fa[fa[u][i-1]][i-1];\n    for(int i=head[u];i;i=nxt[i]){\n        int v=to[i];\n        if(v!=fa[u][0]){\n            fa[v][0]=u; dep[v]=dep[u]+1; dfs(v);\n        }\n    }\n}\nint lca(int u,int v){\n    if(dep[u]<dep[v]) swap(u,v);\n    for(int i=19;i>=0;i--) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];\n    if(u==v) return u;\n    for(int i=19;i>=0;i--) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];\n    return fa[u][0];\n}\nbool p[maxn];\nint ans;\nvoid dfs2(int u,int d,int f){\n    if(d>=dep[u]) return;\n    chkmax(ans,dep[u]);\n    if(p[u]) cout<<-1<<endl,exit(0);\n    for(int i=head2[u];i;i=nxt2[i]){\n        int v=to2[i];\n        if(v!=f) dfs2(v,d+1,u);\n    }\n}\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"b.in\",\"r\",stdin);\n    freopen(\"b.out\",\"w\",stdout);\n#endif\n    read(n); read(A); read(B);\n    for(int i=1;i<n;i++){\n        int u,v;\n        read(u); read(v);\n        ae(u,v); ae(v,u);\n    }\n    dfs(B);\n    for(int i=1;i<n;i++){\n        int u,v;\n        read(u); read(v);\n        ae2(u,v); ae2(v,u);\n        if(dep[u]+dep[v]-2*dep[lca(u,v)]>=3) p[u]=p[v]=1;\n    }\n    dfs2(A,0,0);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=0;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(!bad[u])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(ok[i] && (!bad[u1[i]] && !bad[u2[i]]) ){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005;\nint n, x, y;\n\nint a[N], b[N], c[N], d[N];\nstruct tree {\n\tint head[N], tot;\n\tstruct edge { int to, nxt; } e[N << 1];\n\tvoid link(int x, int y) {\n\t\te[++tot] = (edge) {y, head[x]}, head[x] = tot;\n\t\te[++tot] = (edge) {x, head[y]}, head[y] = tot;\n\t}\n} R, B;\nbool mark[N];\n\nint depB[N], fB[N];\nvoid dfs0(int x) {\n\tstatic auto head = B.head;\n\tstatic auto e = B.e;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (e[i].to != fB[x])\n\t\t\tfB[e[i].to] = x, depB[e[i].to] = depB[x] + 1, dfs0(e[i].to);\n}\nint ans = 0;\nvoid dfs1(int x, int f = 0, int dep = 0) {\n\tif (dep >= depB[x]) return;\n\tif (mark[x]) std::cout << -1 << '\\n', std::exit(0);\n\tans = std::max(ans, depB[x]);\n\tstatic auto head = R.head;\n\tstatic auto e = R.e;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (depB[e[i].to] > dep) dfs1(e[i].to, x, dep + 1);\n}\n\nbool qaq(int x, int y) {\n\tif (depB[x] > depB[y]) std::swap(x, y);\n\tauto f = fB;\n\treturn f[y] == f[x] || f[y] == x || f[f[y]] == x;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> x >> y;\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cin >> a[i] >> b[i], R.link(a[i], b[i]);\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cin >> c[i] >> d[i], B.link(c[i], d[i]);\n\tdfs0(y);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!qaq(a[i], b[i])) mark[a[i]] = mark[b[i]] = 1;\n\tdfs1(x), std::cout << ans * 2 << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=0;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(!bad[u])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(ok[i] && (!bad[u1[i]] || !bad[u2[i]]) ){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 2e5 + 20 ;\nint n , x , y , ans ;\n\nint hr[N] , parr[N] ;\nint hb[N] , parb[N] ;\n\nbool spec[N] ;\n\nvector <int> gr[N] , gb[N] ;\n\nvoid dfs (int v , vector <int> g[N] , int h[N] , int par[N]) {\n\tfor (int u : g[v])\n\t\tif (u != par[v]) {\n\t\t\tpar[u] = v ;\n\t\t\th[u] = h[v] + 1 ;\n\t\t\tdfs(u , g , h , par) ;\n\t\t}\n}\n\ninline bool ok (int u , int v) {\n\tif (hb[u] > hb[v]) swap(u , v) ;\n\n\tif (hb[v] - hb[u] > 2) return 0 ;\n\tif (hb[v] - hb[u] == 2) return parb[parb[v]] == u ;\n\tif (hb[v] - hb[u] == 1) return parb[v] == u ;\n\treturn parb[v] == parb[u] ;\n}\n\nvoid dfs_calc (int v) {\n\tif (hb[v] <= hr[v]) return ;\n\n\tif (spec[v]) {\n\t\tcout << \"-1\\n\" ;\n\t\texit(0) ;\n\t}\n\tans = max(ans , 2 * hb[v]) ;\n\n\tfor (int u : gr[v])\n\t\tif (u != parr[v]) dfs_calc(u) ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n >> x >> y ;\n\tx -- , y -- ;\n\n\tfor (int i = 0 ; i < 2 * n - 2 ; i ++) {\n\t\tint u , v ;\n\t\tcin >> u >> v ;\n\t\tu -- , v -- ;\n\t\t(i < n - 1 ? gr : gb)[u].push_back(v) ;\n\t\t(i < n - 1 ? gr : gb)[v].push_back(u) ;\n\t}\n\n\tmemset(parr , -1 , sizeof parr) ;\n\tdfs(x , gr , hr , parr) ;\n\tmemset(parb , -1 , sizeof parb) ;\n\tdfs(y , gb , hb , parb) ;\n\n\tfor (int v = 0 ; v < n ; v ++)\n\t\tfor (int u : gr[v])\n\t\t\tif (!ok(u , v)) spec[u] = 1 ;\n\n\tdfs_calc(x) ;\n\n\tcout << ans << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\nstruct LowestCommonAncestor{\n  int n,h;\n  vector<vector<int> > G,par;\n  vector<int> dep;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int n):n(n),G(n),dep(n){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n  }\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    for(int u:G[v])\n      if(u!=p) dfs(u,v,d+1);\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<h;k++){\n      for(int v=0;v<n;v++){\n        if(par[k][v]<0) par[k+1][v]=-1;\n        else par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int k=0;k<h;k++){\n      if((dep[v]-dep[u])>>k&1){\n        v=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=h-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n        u=par[k][u];\n        v=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,x,y;\n  cin>>n>>x>>y;\n  x--;y--;\n  // G: sugim, H: sigma\n  vector<vector<int> > G(n),H(n);\n  for(int t=0;t<2;t++){\n    auto &T=(t==0?H:G);\n    for(int i=1;i<n;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      T[a].emplace_back(b);\n      T[b].emplace_back(a);\n    }\n  }\n  \n  LowestCommonAncestor lca(n);\n  lca.G=G;\n  lca.build(y);\n  \n  vector<int> dist(n,-1);\n  queue<int> q;\n  dist[x]=0;\n  q.emplace(x);\n\n  auto WIN=[](){cout<<-1<<endl;exit(0);};\n  int ans=0;\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    chmax(ans,lca.dep[v]);\n    for(int u:H[v]){\n      if(~dist[u]) continue;\n      dist[u]=dist[v]+1;\n      if(dist[u]>=lca.dep[u]) continue;\n      q.emplace(u);\n            \n      if(lca.distance(u,v)>=3) WIN();\n    }\n  }\n  assert(0);\n  cout<<ans*2<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define N 200010\nusing namespace std;\nint n,cnt,tot,X,Y,ans,head[N],fa[N],dep[N],dis[N],Q[N],be[N],ed[N],a[N][2];\nbool vis[N],p[N];\nstruct edge { int to,from,v; }e[N*4];\nvoid insert(int x,int y,int v) \n{\n\te[++cnt].to=y,e[cnt].from=head[x],head[x]=cnt,e[cnt].v=v;\n\te[++cnt].to=x,e[cnt].from=head[y],head[y]=cnt,e[cnt].v=v;\n}\nvoid dfs(int x)\n{\n\tdep[x]=dep[fa[x]]+1,be[x]=++tot;\n\tfor (int i=head[x];i;i=e[i].from) if (e[i].to!=fa[x]) fa[e[i].to]=x,dfs(e[i].to);\n\ted[x]=++tot;\n}\nvoid bfs()\n{\n\tint l=1,r=1; Q[1]=X,vis[X]=1;\n\twhile (l<=r)\n\t{\n\t\tint x=Q[l++];\n\t\tfor (int i=head[x];i;i=e[i].from) if (!e[i].v&&!vis[e[i].to])\n\t\t{\n\t\t\tdis[e[i].to]=dis[x]+1;\n\t\t\tif (dis[e[i].to]<dep[e[i].to]) vis[e[i].to]=1,Q[++r]=e[i].to;\n\t\t}\n\t}\n}\nbool pd(int x,int y)\n{\n\tif (be[x]>be[y]) swap(x,y);\n\tif (be[x]<be[y]&&ed[x]>ed[y]) return dep[y]-dep[x]>2?true:false;\n\tif (fa[x]==fa[y]) return false;\n\treturn true;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor (int i=1;i<n;i++) scanf(\"%d%d\",&a[i][0],&a[i][1]);\n\tfor (int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),insert(x,y,1);\n\tdep[0]=-1,dfs(Y);\n\tfor (int i=1;i<n;i++) if (pd(a[i][0],a[i][1])) p[a[i][0]]=p[a[i][1]]=1; else insert(a[i][0],a[i][1],0);\n\tbfs();\n\tfor (int i=1;i<=n;i++) if (p[i]&&vis[i]) { printf(\"-1\"); return 0; }\n\tfor (int i=1;i<=n;i++) if (vis[i]) ans=max(ans,dep[i]*2);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\ntypedef int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\nconst ll maxn=2e5+10, maxm=5e3+10, lg=20, mod=998244353, inf=1e18;\n\nll n,X,Y,par[maxn],h[maxn],ans=0;\nvector<ll> g[maxn],ex[maxn];\nbool bad[maxn],mk[maxn];\nvoid dfs(ll v){for(auto u:g[v])if(u!=par[v])par[u]=v,h[u]=h[v]+1,dfs(u);}\nvoid df2(ll v,ll d=0){\n\tmk[v]=1;\n\tans=max(ans,2*h[v]);\n\tif(h[v]<=d) return;\n\tif(bad[v]){cout<<-1;exit(0);}\n\tfor(auto u:ex[v])if(!mk[u]) df2(u,d+1);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>X>>Y;\n\tvector<pll> E;\n\tfor(int i=1;i<n;i++){\n\t\tll v,u; cin>>v>>u;\n\t\tE.pb({v,u});\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tll v,u; cin>>v>>u;\n\t\tg[v].pb(u), g[u].pb(v);\n\t}\n\tdfs(Y);\n\tfor(auto e:E){\n\t\tll v=e.F, u=e.S;\n\t\tif(par[par[v]]==u || par[v]==u || par[par[u]]==v || par[u]==v || par[v]==par[u]) ex[v].pb(u), ex[u].pb(v);\n\t\telse bad[v]=bad[u]=1;\n\t}\n\tdf2(X);\n\tcout<<ans;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,y,ans;\n\nvector<int> G[maxn],G2[maxn];\n\nint tim[maxn],fa[maxn];\n\nvoid dfs2(int u,int ff){\n\tfa[u]=ff;\n\ttim[u]=tim[ff]+1;\n\tfor(auto v:G2[u])if(v!=ff)dfs2(v,u);\n}\n\nbool check(int x,int y){\n\tif(fa[fa[x]]==y)return 0;\n\tif(fa[x]==y)return 0;\n\tif(fa[fa[y]]==x)return 0;\n\tif(fa[y]==x)return 0;\n\tif(fa[x]==fa[y])return 0;\n\treturn 1;\n}\n\nvoid dfs1(int u,int fa,int now){\n\tans=max(ans,(tim[u]-1)*2);\n\tfor(auto v:G[u])if(now+1<tim[v]&&v!=fa){\n\t\tif(check(u,v)){\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tdfs1(v,u,now+1);\n\t}\n}\n\nvoid Work(){\n\tif(x==y){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tdfs2(y,0);\n\tdfs1(x,0,1);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,x,y);\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG2[u].PB(v);G2[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 200000\n#define MD 18\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,X,Y,h1[MN+5],h2[MN+5],cnt=0,d1[MN+5],d2[MN+5],q[MN+5],top;\nint nl[MN+5],nr[MN+5],dn=0,vis[MN+5],dep[MN+5],fa[MD+1][MN+5],flag,ans=0;\nstruct edge{int to,next;}e[MN*4+5];\ninline void ins(int*H,int f,int t)\n{\n\te[++cnt]=(edge){t,H[f]};H[f]=cnt;\n\te[++cnt]=(edge){f,H[t]};H[t]=cnt;\t\n}\nvoid Bfs(int*d,int*head,int s)\n{\n\tmemset(vis,0,sizeof(vis));\n\tvis[q[top=1]=s]=1;\n\tfor(int i=1;i<=top;++i)\n\t\tfor(int j=head[q[i]];j;j=e[j].next)\n\t\t\tif(!vis[e[j].to]) vis[e[j].to]=1,d[q[++top]=e[j].to]=d[q[i]]+1;\t\n}\nvoid Pre(int x,int f)\n{\n\tfa[0][x]=f;nl[x]=++dn;\n\tfor(int i=h2[x];i;i=e[i].next)\n\t\tif(e[i].to!=f) dep[e[i].to]=dep[x]+1,Pre(e[i].to,x);\n\tnr[x]=dn;\n}\ninline int GetUp(int x,int k)\n{\n\tfor(int j=0;k;k>>=1,++j) if(k&1) x=fa[j][x];\n\treturn x;\n}\ninline int lca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tx=GetUp(x,dep[x]-dep[y]);\n\tif(x==y) return x;\n\tfor(int i=MD;~i;--i) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y];\n\treturn fa[0][x];\n}\ninline int dis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\ninline int Move(int x,int y)\n{\n\tif(x==y) return x;\n\tif(nl[y]>=nl[x]&&nl[y]<=nr[x]) return GetUp(y,dep[y]-dep[x]-1);\n\telse return fa[0][x];\n}\nvoid dfs(int x,int fa,int oth)\n{\n\tans=max(ans,d1[x]+1);\n\tif(x==oth) return;\n\tfor(int i=h1[x];i;i=e[i].next)\n\t\tif(dis(e[i].to,x)>2) flag=1;\n\tfor(int i=h1[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa&&e[i].to!=oth) dfs(e[i].to,x,Move(oth,e[i].to));\n}\nint main()\n{\n\tn=read();X=read();Y=read();\n\tfor(int i=1;i<n;++i) ins(h1,read(),read());\n\tfor(int i=1;i<n;++i) ins(h2,read(),read());\n\tBfs(d1,h1,X);Bfs(d2,h2,Y);Pre(Y,0);\n\tfor(int i=1;i<=MD;++i) for(int j=1;j<=n;++j) fa[i][j]=fa[i-1][fa[i-1][j]];\n\tdfs(X,0,Y);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans*2);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cctype>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=200005;\nint n,vis[N],ans;\nstruct edge{int v,n;};\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nstruct tree\n{\n\tint h[N],cnt,dep[N],fa[N],root;\n\tedge e[N<<1];\n\n\tvoid addedge(int u,int v)\n\t{\n\t\te[cnt]=(edge){v,h[u]},h[u]=cnt++;\n\t\te[cnt]=(edge){u,h[v]},h[v]=cnt++;\n\t}\n\t\n\tvoid dfs(int x,int f,int d)\n\t{\n\t\tdep[x]=d,fa[x]=f;\n\t\tfor(int i=h[x]; i!=-1; i=e[i].n)\n\t\t\tif(e[i].v!=f) dfs(e[i].v,x,d+1);\n\t}\n\n\tvoid build()\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\trep(i,1,n-1) addedge(getint(),getint());\n\t\tdfs(root,0,0);\n\t}\n\n\tbool query(int x,int y)\n\t{\n\t\tint rt=0;\n\t\twhile(x!=y)\n\t\t{\n\t\t\tif(++rt,dep[x]>dep[y]) x=fa[x];\n\t\t\telse y=fa[y];\n\t\t\tif(rt>2) return 1;\n\t\t}\n\t\treturn 0;\n\t}\n} t1,t2;\n\nvoid dfs(int x,int fa)\n{\n\tif(t1.dep[x]>=t2.dep[x]) return;\n\tvis[x]=1;\n\tfor(int i=t1.h[x]; i!=-1; i=t1.e[i].n)\n\t\tif(t1.e[i].v!=fa) dfs(t1.e[i].v,x);\n}\n\nint main()\n{\n\tn=getint(),t1.root=getint(),t2.root=getint();\n\tt1.build(),t2.build(),dfs(t1.root,0);\n\trep(i,1,n) if(vis[i])\n\t{\n\t\tans=max(ans,t2.dep[i]);\n\t\tfor(int j=t1.h[i]; j!=-1; j=t1.e[j].n)\n\t\t\tif(t2.query(i,t1.e[j].v))\n\t\t\t\treturn puts(\"-1\"),0;\n\t}\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 21\nvector<int> ex[N], ey[N];\nvoid init(int n, vector<int>* e) {\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n}\nint fx[N], fy[N][M], dx[N], dy[N];\nvoid dfsx(int u) {\n    for (auto v : ex[u]) {\n        if (v == fx[u]) continue;\n        fx[v] = u, dx[v] = dx[u] + 1;\n        dfsx(v);\n    }\n}\nvoid dfsy(int u) {\n    for (auto v : ey[u]) {\n        if (v == fy[u][0]) continue;\n        fy[v][0] = u, dy[v] = dy[u] + 1;\n        for (int i = 1; i < M; i++) fy[v][i] = fy[fy[v][i - 1]][i - 1];\n        dfsy(v);\n    }\n}\nint lca(int u, int v) {\n    if (dy[u] < dy[v]) swap(u, v);\n    for (int i = M - 1; ~i; i--)\n        if (dy[fy[u][i]] >= dy[v]) u = fy[u][i];\n    if (u == v) return u;\n    for (int i = M - 1; ~i; i--)\n        if (fy[u][i] != fy[v][i]) u = fy[u][i], v = fy[v][i];\n    return fy[u][0];\n}\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    init(n, ex);\n    init(n, ey);\n    dfsx(addx);\n    dfsy(addy);\n    queue<int> que;\n    que.push(addx);\n    int ans = 0;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        if (dx[u] >= dy[u]) continue;\n        if (~ans) ans = max(ans, dy[u] << 1);\n        for (auto v : ex[u]) {\n            if (v == fx[u]) continue;\n            if (dy[v] + dy[u] - 2 * dy[lca(u, v)] > 2) ans = -1;\n            que.push(v);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 200005\nusing namespace std;\n\nint n,cnt,last[MAXN];\nint father[MAXN],deep[MAXN],dis[MAXN];\nint q[MAXN],nnn[MAXN],mx[MAXN];\nint tim,a[MAXN][2],xx,yy;\nbool vis[MAXN],win[MAXN];\n\nstruct edge\n{\n    int to,next,h;\n}t[MAXN*4];\n\nvoid add(int u,int v,int h)\n{\n    t[++cnt].to=v;t[cnt].h=h;\n    t[cnt].next=last[u];last[u]=cnt;\n    t[++cnt].to=u;t[cnt].h=h;\n    t[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n    deep[x]=deep[father[x]]+1;nnn[x]=++tim;\n    for (int i=last[x];i;i=t[i].next)\n        if (t[i].to!=father[x]) father[t[i].to]=x,dfs(t[i].to);\n    mx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n    if (nnn[x]>nnn[y]) swap(x,y);\n    if (nnn[x]<nnn[y]&&mx[x]>nnn[y]) return deep[y]-deep[x]>2 ? true : false;\n    if (father[x]==father[y]) return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int h=1,tt=1;q[1]=xx;vis[xx]=1;\n    while (h<=tt)\n    {\n        int x=q[h++];\n        for (int i=last[x];i;i=t[i].next)\n            if (!t[i].h&&!vis[t[i].to])\n            {\n                dis[t[i].to]=dis[x]+1;\n                if (dis[t[i].to]<deep[t[i].to]) vis[t[i].to]=1,q[++tt]=t[i].to;\n            }\n    }\n}\n\n\ntemplate<class T>inline void read(T &res)\n{\n    static char ch;T flag=1;\n    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;\n    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;\n}\n\nint main()\n{\n    int ans=0;\n    read(n);read(xx);read(yy);\n\n    for (int i=1;i<n;i++) {read(a[i][0]);read(a[i][1]);}\n\n    for (int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x);read(y);\n        add(x,y,1);\n    }\n\n    deep[0]=-1;\n    dfs( yy );\n\n    for (int i=1;i<n;i++)\n    {\n        if (check(a[i][0],a[i][1]))\n            win[a[i][0]]=win[a[i][1]]=1;\n        else add(a[i][0],a[i][1],0);\n    }\n\n    bfs();\n\n    for (int i=1;i<=n;i++)\n        if (win[i]&&vis[i])\n            {putchar('-');putchar('1');return 0;}\n\n    for (int i=1;i<=n;i++)\n        if (vis[i])\n            ans=max(ans,deep[i]<<1);\n\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=200005;\n\nint n,X,Y,ncnt;\nint dfn[MAXN],efn[MAXN],fa[MAXN],dep[MAXN];\nstruct node{\n    int v,nex;\n}E[MAXN*2],G[MAXN*2];\nint Ehead[MAXN],Ghead[MAXN],dcnt[2];\nbool tag[MAXN];\npair<int,int> a[MAXN];\n\nvoid addedge(node edge[],int head[],int &cnt,int u,int v){\n    node &p=edge[++cnt];\n    p.v=v;\n    p.nex=head[u];\n    head[u]=cnt;\n}\n\nvoid dfs(int u,int fa=0){\n    ::fa[u]=fa;\n    dep[u]=dep[fa]+1;\n    dfn[u]=++ncnt;\n    for(int i=Ghead[u];i;i=G[i].nex){\n        int v=G[i].v;\n        if(v==fa) continue;\n        dfs(v,u);\n    }\n    efn[u]=++ncnt;\n}\n\nbool check(int u,int v){\n    if(dfn[u]>dfn[v]) swap(u,v);\n    if(dfn[u]<dfn[v]&&efn[v]<efn[u])\n        return dep[v]-dep[u]>=3;\n    return fa[u]!=fa[v];\n}\n\nint vis[MAXN],dis[MAXN],deq[MAXN],l,r;\nvoid bfs(){\n    for(int i=1;i<=n;i++) vis[i]=dis[i]=0;\n    l=r=1;\n    deq[r++]=X;\n    while(l<r){\n        int u=deq[l++];\n        vis[u]=1;\n        for(int i=Ehead[u];i;i=E[i].nex){\n            int v=E[i].v;\n            if(vis[v]) continue;\n            dis[v]=dis[u]+1;\n            if(dis[v]<dep[v])\n                deq[r++]=v;\n        }\n    }\n}\n\nint main(){\n    //freopen(\"coalesce.in\",\"r\",stdin);\n    //freopen(\"coalesce.out\",\"w\",stdout);\n\n    dep[0]=-1;\n    while(~scanf(\"%d%d%d\",&n,&X,&Y)){\n        for(int i=1;i<=n;i++) Ehead[i]=Ghead[i]=0;\n        dcnt[0]=dcnt[1]=ncnt=0;\n        for(int i=1;i<=n;i++) tag[i]=0;\n        for(int i=1;i<n;i++) scanf(\"%d%d\",&a[i].first,&a[i].second);\n        for(int i=1;i<n;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            addedge(G,Ghead,dcnt[1],u,v);\n            addedge(G,Ghead,dcnt[1],v,u);\n        }\n        dfs(Y);\n        for(int i=1;i<n;i++)\n            if(check(a[i].first,a[i].second)) tag[a[i].first]=tag[a[i].second]=1;\n            else addedge(E,Ehead,dcnt[0],a[i].first,a[i].second),addedge(E,Ehead,dcnt[0],a[i].second,a[i].first);\n        bfs();\n        int ans=0;\n        bool flag=1;\n        for(int i=1;i<=n&&flag;i++){\n            if(!vis[i]) continue;\n            if(tag[i]) flag=0;\n            else ans=max(ans,2*dep[i]);\n        }\n        printf(\"%d\\n\",flag?ans:-1);\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nstruct T{ int to, nxt; } way[maxn << 2];\nint h0[maxn], h1[maxn], num;\ninline void link(int x,int y,int * h) {\n\tway[++num] = {y,h[x]}, h[x] = num;\n\tway[++num] = {x,h[y]}, h[y] = num;\n}\nint n, x, y;\nint fa[maxn], dep[maxn];\ninline void dfs0(int x,int f = 0) {\n\tfa[x] = f, dep[x] = dep[f] + 1;\n\tfor(int i = h1[x];i;i = way[i].nxt) if(way[i].to != f)\n\t\tdfs0(way[i].to, x);\n}\nint a[maxn], b[maxn];\nint import[maxn], vis[maxn];\ninline bool chk(int x,int y) {\n\tif(dep[x] > dep[y]) x = fa[x]; else y = fa[y];\n\tif(x == y) return 0;\n\tif(dep[x] > dep[y]) x = fa[x]; else y = fa[y];\n\treturn x != y;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> x >> y;\n\tfor(int i = 1;i < n;++i) cin >> a[i] >> b[i], link(a[i], b[i], h0);\n\tfor(int i = 1, x, y;i < n;++i) cin >> x >> y, link(x, y, h1);\n\tdfs0(y);\n\tfor(int i = 1;i < n;++i) if(chk(a[i], b[i])) import[a[i]] = import[b[i]] = 1;\n\tstd::queue<int> q; q.push(x); vis[x] = 1;\n\tint ans = dep[x];\n\tfor(;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tif(import[t]) return puts(\"-1\"), 0;\n\t\tfor(int i = h0[t];i;i = way[i].nxt) {\n\t\t\tif(!vis[way[i].to]) {\n\t\t\t\tvis[way[i].to] = vis[t] + 1;\n\t\t\t\tif(vis[way[i].to] < dep[way[i].to]) {\n\t\t\t\t\tq.push(way[i].to);\n\t\t\t\t\tans = std::max(ans, dep[way[i].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::cout << ans * 2 - 2 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e5+5;\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<2];\nint ha[N], hb[N], tot;\nvoid _add(int *h, int x, int y) { edge[++tot] = Edge(h[x], y); h[x] = tot; }\nvoid add(int *h, int x, int y) { _add(h, x, y); _add(h, y, x); }\nint fa[N], son[N], size[N], top[N], d[N];\nint ans, cir;\nvoid dfs(int x)\n{\n    size[x] = 1;\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; if(y == fa[x]) continue;\n        d[y] = d[x]+1, fa[y] = x, dfs(y), \n        size[x] += size[y], son[x] = size[son[x]]>size[y]?son[x]:y; \n    }\n}\nint lca(int x, int y)\n{\n    while(top[x] != top[y])\n    {\n        if(d[top[x]] < d[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint dis(int x, int y) { return d[x]+d[y]-2*d[lca(x, y)]; }\nvoid dfs(int x, int topf)\n{\n    top[x] = topf; if(son[x]) dfs(son[x], topf);\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(y != fa[x]&&y != son[x]) dfs(y, y);\n    }\n}\nvoid escape(int x, int fa, int dep)\n{\n    ans = max(ans, d[x]<<1); \n    for(int i = ha[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(dis(x, y) > 2) cir = 1;    \n        if(y == fa||dep+1 >= d[y]) continue;\n        escape(y, x, dep+1);\n    }\n}\nint n, a, b;\nint main()\n{\n    n = read(), a = read(), b = read();\n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(ha, x, y);\n    } \n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(hb, x, y);\n    }\n    dfs(b); dfs(b, b); escape(a, 0, 0);\n    printf(\"%d\\n\", cir?-1:ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int N=100005;\nint deep[N],dfn[N],ed[N],fa[N],dis[N],Time,ans;\nstruct Tree{\n\tint Head[N],Next[N<<1],Adj[N<<1],tot;\n\tinline void addedge(int u,int v){\n\t\tNext[++tot]=Head[u],Head[u]=tot,Adj[tot]=v;\n\t\tNext[++tot]=Head[v],Head[v]=tot,Adj[tot]=u;\n\t}\n\tinline void dfs(int x,int f){\n\t\tdfn[x]=++Time,fa[x]=f;\n\t\tfor (int e=Head[x];e;e=Next[e])\n\t\t\tif (Adj[e]!=f){\n\t\t\t\tdis[Adj[e]]=dis[x]+1;\n\t\t\t\tdfs(Adj[e],x);\n\t\t\t}\n\t\ted[x]=Time;\n\t}\n\tinline bool check(int x,int y){\n\t\tif (dfn[x]>dfn[y]) swap(x,y);\n\t\tif (dfn[y]>=dfn[x]&&dfn[y]<=ed[x]) return dis[y]-dis[x]>2;\n\t\treturn fa[x]!=fa[y];\n\t}\n\tinline void dfs2(int x,int f){\n\t\tif (deep[x]>=dis[x]) return;\n\t\tans=max(ans,dis[x]*2);\n\t\tfor (int e=Head[x];e;e=Next[e])\n\t\t\tif (Adj[e]!=f){\n\t\t\t\tdeep[Adj[e]]=deep[x]+1;\n\t\t\t\tdfs2(Adj[e],x);\n\t\t\t\tif (check(x,Adj[e])) {puts(\"-1\");exit(0);}\n\t\t\t}\n\t}\n}T1,T2;\nint main(){\n\tint n,x,y;scanf (\"%d%d%d\",&n,&x,&y);\n\tif (x==y){puts(\"0\");return 0;}\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;scanf (\"%d%d\",&u,&v);\n\t\tT1.addedge(u,v);\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;scanf (\"%d%d\",&u,&v);\n\t\tT2.addedge(u,v);\n\t}\n\tT2.dfs(y,0);\n\tT1.dfs2(x,0);\n\tprintf (\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 200005\n\nusing namespace std;\n\nint n, s, t, ans;\n\nstruct graph {\n    vector<int> g[MAXN];\n    int fa[MAXN][19], dep[MAXN];\n    \n    void connect(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    void build(int u = s, int pre = 0) {\n        fa[u][0] = pre;\n        dep[u] = dep[pre] + 1;\n        for (int i = 1; i <= 18; ++i)\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        for (int i = 0; i < (int)g[u].size(); ++i) {\n            int v = g[u][i];\n            if (v == pre)\n                continue;\n            build(v, u);\n        }\n    }\n    \n    int query(int u, int v) {\n        if (dep[u] < dep[v])\n            swap(u, v);\n        for (int i = 18; i >= 0; --i)\n            if (dep[fa[u][i]] >= dep[v])\n                u = fa[u][i];\n        if (u == v)\n            return u;\n        for (int i = 18; i >= 0; --i)\n            if (fa[u][i] != fa[v][i]) {\n                u = fa[u][i];\n                v = fa[v][i];\n            }\n        return fa[u][0];\n    }\n    \n    int calc(int u, int v) {\n        return dep[u] + dep[v] - dep[query(u, v)] * 2;\n    }\n}A, B;\n\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nbool DFS(int u, int pre) {\n    if (A.dep[u] - 1 > B.calc(t, u))\n        return false;\n    for (int i = 0; i < (int)A.g[u].size(); ++i) {\n        int v = A.g[u][i];\n        if (v == pre)\n            continue;\n        if (B.calc(u, v) > 2|| DFS(v, u))\n            return true;\n    }\n    return false;\n}\n\nvoid find(int u, int pre) {\n    if (A.dep[u] - 1 > B.calc(t, u))\n        return ;\n    ans = max(ans, B.calc(t, u) * 2);\n    for (int i = 0; i < (int)A.g[u].size(); ++i) {\n        int v = A.g[u][i];\n        if (v == pre)\n            continue;\n        find(v, u);\n    }\n}\n\nint main() {\n    n = read();\n    s = read();\n    t = read();\n    for (int i = 1; i < n; ++i)\n        A.connect(read(), read());\n    for (int i = 1; i < n; ++i)\n        B.connect(read(), read());\n    A.build();\n    B.build();\n    bool isinfinity = DFS(s, 0);\n    if (isinfinity)\n        puts(\"-1\");\n    else {\n        find(s, 0);\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 2e5 + 10;\nint n;\n\nint vs[2];\n\nvector<vector<int> > es[2];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  scanf(\"%d%d\", vs, vs + 1);\n  --vs[0], --vs[1];\n\n  for (int it = 0; it < 2; ++it) {\n    es[it] = vector<vector<int> >(n);\n    for (int i = 0; i < n - 1; ++i) {\n      int s, t;\n      scanf(\"%d%d\", &s, &t);\n      --s, --t;\n      es[it][s].pb(t), es[it][t].pb(s);\n    }\n  }\n  return 1;\n}\n\nint pr[maxn];\nint used[maxn];\n\nint res;\n\nvector<int> st;\nint l;\n\nvoid dfs(int v, int v1, int pass) {\n  assert(v1 == st[l] && v == st.back());\n  assert(v != v1);\n  used[v] = 1;\n  res = max(res, 2 * (sz(st) - l - 1 + pass));\n\n  for (int nv : es[0][v]) {\n    if (used[nv]) {\n      continue;\n    }\n    int s = v, t = nv;\n    int x = -1;\n    bool ok = 0;\n    if (pr[s] == pr[t]) {\n      ok = 1;\n      x = pr[s];\n    }\n    for (int it = 0; !ok && it < 2; ++it) {\n      if (pr[s] == t) {\n        ok = 1;\n        x = -1;\n      } else {\n        if (pr[s] != -1 && pr[pr[s]] == t) {\n          ok = 1;\n          x = pr[s];\n        }\n      }\n      swap(s, t);\n    }\n\n    if (!ok) {\n      res = -1;\n      break;\n    }\n\n    if (x == v1 || nv == v1) {\n      continue;\n    }\n    int vs[3] = {v, x, nv};\n    int k = 3;\n    if (x == -1) {\n      vs[1] = vs[2];\n      --k;\n    }\n    int cnt = 0;\n    while (cnt < k && vs[cnt] == st[sz(st) - cnt - 1]) {\n      ++cnt;\n    }\n    assert(cnt);\n    st.resize(sz(st) - cnt + 1);\n\n    for (int i = cnt; i < k; ++i) {\n      st.pb(vs[i]);\n    }\n\n    ++l;\n    if (l + 1 < sz(st)) {\n      dfs(st.back(), st[l], pass + 1);\n      if (res == -1) {\n        break;\n      }\n    }\n    --l;\n\n    st.resize(sz(st) - (k - cnt));\n    for (int i = cnt - 2; i >= 0; --i) {\n      st.pb(vs[i]);\n    }\n  }\n}\n\nbool dfs2(int v, int p, int need) {\n  pr[v] = p;\n  bool res = 0;\n  if (need == v) {\n    st.clear();\n    res = 1;\n  }\n  for (int u : es[1][v]) {\n    if (u == p) {\n      continue;\n    }\n    if (dfs2(u, v, need)) {\n      res = 1;\n    }\n  }\n\n  if (res) {\n    st.pb(v);\n  }\n\n  return res;\n}\n\nvoid solve() {\n  for (int i = 0; i < n; ++i) {\n    used[i] = 0;\n  }\n\n  assert(dfs2(vs[0], -1, vs[1]));\n\n  res = 0;\n  dfs(vs[0], vs[1], 0);\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N=2e5+10;\nstruct Tree\n{\n\tstruct edge{int next,to;}a[N<<1];\n\tint head[N],cnt;\n\tvoid link(int x,int y)\n\t\t{\n\t\t\ta[++cnt]=(edge){head[x],y};head[x]=cnt;\n\t\t\ta[++cnt]=(edge){head[y],x};head[y]=cnt;\n\t\t}\n}A,B;\nint n,p1,p2,dep[N],dis[N],fr[N],vis[N],ans;\nqueue<int> Q;\nvoid bfs1()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tif(dep[p1]) Q.push(p1);dis[p1]=0;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();vis[x]=1;\n\t\tfor(int i=A.head[x];i;i=A.a[i].next)\n\t\t{\n\t\t\tint R=A.a[i].to;\n\t\t\tif(dis[R]==-1)\n\t\t\t{\n\t\t\t\tdis[R]=dis[x]+1;\n\t\t\t\tif(dis[R]<dep[R]) Q.push(R);\n\t\t\t\telse if(dis[R]==dis[R]) vis[R]=1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bfs2()\n{\n\tmemset(dep,-1,sizeof(dep));\n\tQ.push(p2);dep[p2]=0;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=B.head[x];i;i=B.a[i].next)\n\t\t{\n\t\t\tint R=B.a[i].to;\n\t\t\tif(dep[R]==-1) dep[R]=dep[x]+1,fr[R]=x,Q.push(R);\n\t\t}\n\t}\n}\nint Dis(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tif(fr[x]==fr[y]||x==y||fr[x]==y) return 0;\n\tif(fr[fr[x]]==y) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n>>p1>>p2;\n\tfor(int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),A.link(x,y);\n\tfor(int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),B.link(x,y);\n\tbfs2();bfs1();\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int i=A.head[x];i;i=A.a[i].next)\n\t\t\tif(vis[x]&&vis[A.a[i].to]&&Dis(x,A.a[i].to))\n\t\t\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;i++) if(vis[i]) ans=max(dep[i],ans);\n\tcout<<ans*2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\nstruct Edge{\n    int from,to;\n    Edge(int from,int to)\n        : from(from),to(to){};\n    Edge(){Edge(0,0);}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct HeavyLightDecomposition{\n    vector<int> index, htop, hchild, par, dep, idtov, topo,sub,heads;\n    Graph T;\n    HeavyLightDecomposition(int n) :index(n,-1),htop(n),hchild(n,-1),par(n),dep(n),idtov(n),sub(n),T(n){}\n\n    void calc(int root){\n        queue<int> Q({root});\n        par[root]=-1;\n        while(!Q.empty()){\n            int curr=Q.front(); Q.pop(); topo.push_back(curr);\n            for(auto &x: T[curr]){\n                if(x.to!=par[curr]){\n                    par[x.to]=x.from;\n                    Q.push(x.to);\n                    dep[x.to]=dep[x.from]+1;\n                }\n            }\n        }\n        heads.push_back(root);\n        for(int i=par.size()-1,msub=0; i>=0; --i){\n            ++sub[topo[i]];\n            if(i>0)sub[par[topo[i]]]+=sub[topo[i]];\n            if(i<par.size()-1)if(par[topo[i+1]]!=par[topo[i]])msub=0;\n            if(sub[topo[i]]>msub) hchild[par[topo[i]]]=topo[i];\n            for(auto &x : T[topo[i]])if(x.to!=par[topo[i]]&&x.to!=hchild[topo[i]]) heads.push_back(x.to);\n        }\n        int id=0;\n        for(int x : heads) {\n            for(int i=x; i!=-1; i=hchild[i]){\n                index[i]=id++;\n                idtov[index[i]]=i;\n                htop[i]=x;\n            }\n        }\n    }\n    inline bool same(int a,int b){return htop[a]==htop[b];}\n\n    int lca(int a, int b){\n        if(index[a]>index[b])swap(a,b);\n        if(same(a,b)) return a;\n        return lca(a,par[htop[b]]);\n    }\n    int dist(int a, int b){\n        return dep[a]+dep[b]-2*dep[lca(a,b)];\n    }\n};\n\nstruct Problem{\n    int size,gma,gim;\n    HeavyLightDecomposition sigma,sugim;\n    Problem(int n):size(n),sigma(n),sugim(n){};\n    void input(HeavyLightDecomposition &hl){\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            hl.T[a].push_back(Edge(a,b));\n            hl.T[b].push_back(Edge(b,a));\n        }\n    }\n    bool is_sigma_nearer(int i){\n        return sigma.dist(i,gma)<sugim.dist(i,gim);\n    }\n    int dfs(int par, int cur){\n        if(!is_sigma_nearer(cur)) return -INF;\n        if(sigma.T[cur].size()==1 and sigma.T[cur][0].to==par){\n            return sugim.dist(cur,gim);\n        }\n        int ret=sugim.dist(cur,gim);\n        for(auto e: sigma.T[cur]){\n            if(e.to!=par){\n                if(sugim.dist(cur,e.to)>=3) return INF;\n                ret=max(ret,dfs(cur,e.to));\n            }\n        }\n        return ret;\n    }\n\n    void solve(){\n        cin >> gma >> gim;\n        --gma;--gim;\n        input(sigma);\n        input(sugim);\n        sigma.calc(gma);\n        sugim.calc(gim);\n        int ans=dfs(-1,gma);\n        if(ans==INF)cout << -1 <<\"\\n\";\n        else cout << ans*2<<\"\\n\";\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    Problem e(n);\n    e.solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> par;\n\nconst int N=200010;\n\nint n,x,y,cnt,a[N],b[N],G[N];\nint fa[N][20];\nstruct edge{\n  int t,nx;\n}E[N<<2];\n\ninline void addedge(int x,int y){\n  E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n  E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n}\n\nint dpt[N];\n\nvoid dfs(int x,int f){\n  if(f) dpt[x]=dpt[f]+1;\n  fa[x][0]=f; for(int i=1;i<=18;i++) fa[x][i]=fa[fa[x][i-1]][i-1];\n  for(int i=G[x];i;i=E[i].nx)\n    if(E[i].t!=f) dfs(E[i].t,x);\n}\n\nnamespace Grp{\n  int cnt,G[N];\n  struct edge{\n    int t,nx;\n  }E[N<<1];\n\n  inline void addedge(int x,int y){\n    E[++cnt].t=y; E[cnt].nx=G[x]; G[x]=cnt;\n    E[++cnt].t=x; E[cnt].nx=G[y]; G[y]=cnt;\n  }\n}\n\nqueue<int> Q;\nint dis[N],mark[N];\n\nconst int inf=1<<29;\n\ninline void bfs(){\n  for(int i=1;i<=n;i++) dis[i]=inf;\n  Q.push(x); dis[x]=0;\n  while(!Q.empty()){\n    int x=Q.front(); Q.pop();\n    for(int i=Grp::G[x];i;i=Grp::E[i].nx){\n      int v=Grp::E[i].t;\n      if(dis[v]!=inf) continue;\n      dis[v]=dis[x]+1; Q.push(v);\n    }\n  }\n}\n\ninline int lca(int x,int y){\n  if(dpt[x]<dpt[y]) swap(x,y);\n  for(int i=18;~i;i--)\n    if(dpt[fa[x][i]]>=dpt[y]) x=fa[x][i];\n  if(x==y) return x;\n  for(int i=18;~i;i--)\n    if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n  return fa[x][0];\n}\n\ninline int dist(int x,int y){\n  return dpt[x]+dpt[y]-2*dpt[lca(x,y)];\n}\n\nint main(){\n  scanf(\"%d%d%d\",&n,&x,&y);\n  for(int i=1;i<n;i++)\n    scanf(\"%d%d\",&a[i],&b[i]);\n  for(int i=1,u,v;i<n;i++)\n    scanf(\"%d%d\",&u,&v),addedge(u,v);\n  dfs(y,0); dpt[0]=-1;\n  for(int i=1;i<n;i++)\n    if(dist(a[i],b[i])>2) mark[a[i]]=mark[b[i]]=1;\n    else Grp::addedge(a[i],b[i]);\n  bfs(); int ans=0;\n  for(int i=1;i<=n;i++){\n    if(mark[i] && dis[i]<dpt[i]) return puts(\"-1\"),0;\n    if(dis[i]<dpt[i]) ans=max(ans,dpt[i]*2);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\nusing namespace std;\nconst int N=200010;\nint tt,tim;\nbool w[N];\nvector <int> q[N];\nint fa[N],dep[N],dis[N],head[N],to[N*2],nxt[N*2],a[N],b[N],dfn[N],ed[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline void dfs(int x,int f) {\n    fa[x]=f,dep[x]=dep[f]+1,dfn[x]=++tim;\n    for(int i=head[x];i;i=nxt[i])\n\tif(to[i]!=f) dfs(to[i],x);\n    ed[x]=tim;\n}\ninline void solve(int x,int f) {\n    dis[x]=dis[f]+1;\n    if(dis[x]>=dep[x]) return;\n    w[x]=1;\n    for(int i=0;i<q[x].size();i++)\n\tif(q[x][i]!=f) solve(q[x][i],x);\n}\ninline bool check(int x,int y) {\n    if(dep[x]<dep[y]) swap(x,y);\n    if(dfn[y]<=dfn[x]&&dfn[x]<=ed[y]) return dep[x]-dep[y]>2;\n    return fa[x]!=fa[y];\n}\nint main() {\n    int n,A,B,ans=0;\n    cin>>n>>A>>B;\n    for(int i=1;i<n;i++) {\n\tint x=a[i]=gi(),y=b[i]=gi();\n\tq[x].push_back(y),q[y].push_back(x);\n    }\n    for(int i=1;i<n;i++) {\n\tint x=gi(),y=gi();\n\tto[++tt]=y,nxt[tt]=head[x],head[x]=tt;\n\tto[++tt]=x,nxt[tt]=head[y],head[y]=tt;\n    }\n    dfs(B,0),solve(A,0);\n    for(int i=1;i<n;i++)\n\tif(check(a[i],b[i])&&(w[a[i]]||w[b[i]])) return puts(\"-1\"),0;\n    for(int i=1;i<=n;i++)\n\tif(w[i]) ans=max(ans,dep[i]*2-2);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX_LG = 20;\nconst int MAX_N = 2e5 + 5;\nconst int INF = 1e9 + 5;\n\nnamespace Ender {\n  vector<int> adj [MAX_N];\n  int par [MAX_N];\n  int lvl [MAX_N];\n  int lend [MAX_N], rend [MAX_N];\n  int jmp [MAX_N][MAX_LG];\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  int lca (int u, int v) {\n    if (lvl[u] < lvl[v]) swap(u, v);\n\n    int diff = lvl[u] - lvl[v];\n    for (int i = 0; i < MAX_LG; i++) {\n      if (diff & 1 << i) {\n        u = jmp[u][i];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int i = MAX_LG - 1; i >= 0; i--) {\n      if (jmp[u][i] != jmp[v][i]) {\n        u = jmp[u][i];\n        v = jmp[v][i];\n      }\n    }\n    return jmp[u][0];\n  }\n\n  int dist (int u, int v) {\n    return lvl[u] + lvl[v] - 2 * lvl[lca(u, v)];\n  }\n  \n  void dfs (int u, int p, int &cur) {\n    jmp[u][0] = p;\n    for (int i = 1; i < MAX_LG; i++) {\n      jmp[u][i] = jmp[jmp[u][i - 1]][i - 1];\n    }\n    \n    cur++;\n    lend[u] = cur;\n    lvl[u] = lvl[p] + 1;\n    par[u] = p;\n\n    for (int nxt : adj[u]) {\n      if (nxt != p) {\n        dfs(nxt, u, cur);\n      }\n    }\n    \n    rend[u] = cur;\n  }\n  \n  void build () {\n    int cur = 0;\n    dfs(1, 0, cur);\n  }\n  \n  bool islong (int u, int v) {\n    if (u == v) return false; // dist 0\n    if (par[u] == v || par[v] == u) return false; // dist 1\n    if (par[par[u]] == v || par[par[v]] == u) return false; // dist 2, grandparent\n    if (par[u] == par[v]) return false; // dist 2, cousin\n    return true;\n  }\n\n  int towards (int cur, int tar) {\n    if (cur == tar) return cur;\n    if (lend[tar] < lend[cur] || rend[cur] < lend[tar]) return par[cur];\n    for (int nxt : adj[cur]) {\n      if (nxt != par[cur]) {\n        if (lend[nxt] <= lend[tar] && rend[tar] <= rend[nxt]) {\n          return nxt;\n        }\n      }\n    }\n    assert(false);\n  }\n}\n\nnamespace Delayer {\n  vector<int> adj [MAX_N];\n  int special [MAX_N];\n  \n  vector<pair<int, int>> edges;\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    edges.push_back(make_pair(u, v));\n  }\n\n  void build () {\n    for (auto pr : edges) {\n      if (Ender::islong(pr.first, pr.second)) {\n        special[pr.first] = 1;\n        special[pr.second] = 1;\n      }\n    }\n  }\n}\n\nint dpt = 0;\nint play (int d, int dl, int e) {\n  /*\n  for (int i = 0; i < 2 * dpt; i++) {\n    cout << \" \";\n  }\n  cout << d << \" \" << e << endl;\n  */\n  \n  if (e == d) return 0;\n  if (Delayer::special[d]) return INF;\n  \n  int ans = 2 * Ender::dist(d, e);\n  for (int nxt : Delayer::adj[d]) {\n    if (nxt != dl) {\n      dpt += 2;\n      ans = max(ans, 2 + play(nxt, d, Ender::towards(e, nxt)));\n      dpt -= 2;\n    }\n  }\n  return ans;\n}\n\nint main () {\n  int n, x, y;\n  cin >> n >> x >> y;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Delayer::add_edge(u, v);\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Ender::add_edge(u, v);\n  }\n\n  Ender::build();\n  Delayer::build();\n\n  int ans = play(x, -1, y);\n  if (ans >= INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nconst int N=1e5+5;\nint n;\n\ntemplate <class T> inline void apx(T &x,const T y){\n\tif(x<y) x=y;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=getchar())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\treturn x;\n}\n\nnamespace G{\n\tint st_f,st_s,dep[N],xdis;\n\tint fa[N],sz[N],son[N],top[N];\n\tstd::vector <int> vf[N],vs[N];\n\n\tinline int get_lca(int x,int y){\n\t\twhile(top[x]!=top[y]){\n\t\t\tdep[top[x]]>dep[top[y]]?x=fa[top[x]]:y=fa[top[y]];\n\t\t}\n\t\treturn dep[x]<dep[y]?x:y;\n\t}\n\n\tinline int get_dis(const int x,const int y){\n\t\treturn dep[x]+dep[y]-(dep[get_lca(x,y)]<<1);\n\t}\n\n\tvoid dfs_sz(const int x){\n\t\tsz[x]=1;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!sz[*it]){\n\t\t\t\tdep[*it]=dep[x]+1;\n\t\t\t\tfa[*it]=x;\n\t\t\t\tdfs_sz(*it);\n\t\t\t\tif(sz[*it]>sz[son[x]]) son[x]=*it;\n\t\t\t\tsz[x]+=sz[*it];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs_top(const int x){\n\t\ttop[x]=son[fa[x]]==x?top[fa[x]]:x;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!top[*it]) dfs_top(*it);\n\t\t}\n\t}\n\n\tbool dfs_free(const int x,const int fa,const int dis){\n\t\tstd::vector <int> ::iterator it;\n\t\tif(dis<dep[x]){\n\t\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\t\tif(get_dis(x,*it)>2) return 1;\n\t\t\t}\n\t\t}\n\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(*it!=fa){\n\t\t\t\tif(dfs_free(*it,x,dis+1)) return 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid dfs_xdis(const int x,const int fa,const int dis){\n\t\tapx(xdis,dep[x]);\n\t\tfor(std::vector <int> ::iterator it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(*it==fa) continue;\n\t\t\tif(dis+1==dep[*it]) apx(xdis,dis+1);\n\t\t\tif(dis+1<dep[*it]){\n\t\t\t\tdfs_xdis(*it,x,dis+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tn=nxi();\n\tG::st_f=nxi(),G::st_s=nxi();\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vf[x].push_back(y);\n\t\tG::vf[y].push_back(x);\n\t}\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vs[x].push_back(y);\n\t\tG::vs[y].push_back(x);\n\t}\n\tG::dfs_sz(G::st_s);\n\tG::dfs_top(G::st_s);\n\tif(G::dfs_free(G::st_f,0,0)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tG::dfs_xdis(G::st_f,0,0);\n\tprintf(\"%d\\n\",G::xdis<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 200003;\nint n, sr, sb, p1[N], p2[N], fab[N], disb[N], disr[N], q[N], front, rear;\nvector<int> Er[N], Eb[N];\nbool vis[N], win[N];\ninline void dfs(int x){\n\tfor(Rint v : Eb[x]) if(v != fab[x]){\n\t\tfab[v] = x; disb[v] = disb[x] + 1; dfs(v);\n\t}\n}\ninline bool check(int x, int y){\n\treturn fab[x] == y || fab[y] == x || fab[x] == fab[y] || fab[fab[x]] == y || fab[fab[y]] == x;\n}\ninline void bfs(int S){\n\tfront = rear = 0; q[rear ++] = S;\n\tmemset(disr, 0x3f, sizeof disr);\n\tdisr[S] = 0;\n\twhile(front < rear){\n\t\tint now = q[front ++];\n\t\tvis[now] = 1;\n\t\tfor(Rint v : Er[now])\n\t\t\tif(disr[v] > disr[now] + 1 && disb[v] > disr[now] + 1){\n\t\t\t\tdisr[v] = disr[now] + 1; q[rear ++] = v;\n\t\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\", &n, &sr, &sb);\n\tfor(Rint i = 1;i < n;i ++)\n\t\tscanf(\"%d%d\", p1 + i, p2 + i);\n\tfor(Rint i = 1;i < n;i ++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tEb[x].push_back(y); Eb[y].push_back(x);\n\t}\n\tdfs(sb);\n\tfor(Rint i = 1;i < n;i ++)\n\t\tif(!check(p1[i], p2[i])) win[p1[i]] = win[p2[i]] = true;\n\t\telse {Er[p1[i]].push_back(p2[i]); Er[p2[i]].push_back(p1[i]);}\n\tbfs(sr);\n\tint ans = 0;\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tif(vis[i] && win[i]){puts(\"-1\"); return 0;}\n\t\telse if(vis[i]) ans = max(ans, disb[i]);\n\tprintf(\"%d\", ans << 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,a,b,i,x[200005],y[200005],sd[200005],zz[200005],book[200005],ans,flag;\nint top,nex[400005],to[400005],fir[200005],top2,nex2[400005],to2[400005],fir2[200005];\nvoid lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n}\nvoid lj2(int u,int v){\n\ttop2++;\n\tnex2[top2]=fir2[u];\n\tfir2[u]=top2;\n\tto2[top2]=v;\n}\nvoid ss(int u,int v,int w){\n\tsd[v]=w;\n\tzz[v]=u;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(to[top1]!=u)\n\t\t\tss(v,to[top1],w+1);\n}\nvoid ss2(int u,int v,int w){\n\tif(sd[v]<=w)\n\t\treturn;\n\tif(book[v]==1)\n\t\tflag=1;\n\tans=max(ans,sd[v]);\n\tfor(int top1=fir2[v];top1;top1=nex2[top1])\n\t\tif(to2[top1]!=u)\n\t\t\tss2(v,to2[top1],w+1);\n}\nint main(){\n\tn=read();a=read();b=read();\n\tfor(i=1;i<n;i++){\n\t\tx[i]=read();y[i]=read();\n\t\tlj2(x[i],y[i]);\n\t\tlj2(y[i],x[i]);\n\t}\n\tfor(i=1;i<n;i++){\n\t\tx[0]=read();y[0]=read();\n\t\tlj(x[0],y[0]);\n\t\tlj(y[0],x[0]);\n\t}\n\tss(b,b,0);\n\tfor(i=1;i<n;i++){\n\t\tif(sd[x[i]]<sd[y[i]])\n\t\t\tswap(x[i],y[i]);\n\t\tif(zz[x[i]]!=y[i]&&zz[zz[x[i]]]!=y[i]&&zz[x[i]]!=zz[y[i]]){\n\t\t\tbook[x[i]]=1;\n\t\t\tbook[y[i]]=1;\n\t\t}\n\t}\n\tss2(a,a,0);\n\tif(flag==1)\n\t\tpus(-1,2);\n\telse\n\t\tpus(ans*2,2);\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N], dfn;\nint dp[N][20], lg2[N], dph[N];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x])\n        if (y != fx) dfsb(y, x);\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] >= db[x]) return;\n    if (~ans) ans = max((db[x] - 1) << 1, ans);\n    for (int y : a[x]) {\n    \tif (y == fx) continue;\n        if (db[x] + db[y] - 2 * db[LCA(x, y)] > 2) ans = -1;\n        dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O2,no-stack-protector,unroll-loops,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n#define MP make_pair\ntypedef int ll;\ntypedef long double ld;\ntypedef pair<ll,ll> pll;\nconst ll maxn=2e5+10, maxm=5e3+10, lg=20, mod=998244353, inf=1e18;\n\nll n,X,Y,par[maxn],h[maxn],ans=0;\nvector<ll> g[maxn],ex[maxn];\nbool bad[maxn],mk[maxn];\nvoid dfs(ll v){for(auto u:g[v])if(u!=par[v])par[u]=v,h[u]=h[v]+1,dfs(u);}\nvoid df2(ll v,ll d=0){\n\tmk[v]=1;\n\tif(bad[v] && h[v]-d>0){cout<<-1;exit(0);}\n\tans=max(ans,2*h[v]);\n\tfor(auto u:ex[v]) df2(u,d+1);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>n>>X>>Y;\n\tvector<pll> E;\n\tfor(int i=1;i<n;i++){\n\t\tll v,u; cin>>v>>u;\n\t\tE.pb({v,u});\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tll v,u; cin>>v>>u;\n\t\tg[v].pb(u), g[u].pb(v);\n\t}\n\tdfs(Y);\n\tfor(auto e:E){\n\t\tll v=e.F, u=e.S;\n\t\tif(par[v]==par[u]) continue;\n\t\tif(par[par[v]]==u || par[v]==u) ex[u].pb(v);\n\t\telse if(par[par[u]]==v || par[u]==v) ex[v].pb(u);\n\t\telse bad[v]=bad[u]=1;\n\t}\n\tdf2(X);\n\tcout<<ans;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint n;\nvvi s, t;\nvi ds, dt;\n\n// LCA (0-indexed)\nstruct LCA {\n  int n, bi;\n  vi dep;\n  vector<vi> to, par;\n  LCA(int n):n(n),dep(n),to(n){}\n  void add(int a, int b){ to[a].pb(b); to[b].pb(a);}\n  void calcDep(int v, int ndep=0, int p=-1){\n    dep[v] = ndep; par[0][v] = p;\n    for(int u : to[v]) if(u != p) calcDep(u,ndep+1,v);\n  }\n  void init(){\n    bi = 0;\n    while(1<<bi <= n) bi++;\n    par.resize(bi,vi(n,-1));\n    calcDep(0);\n    rep(i,bi-1)rep(j,n) par[i+1][j] = (par[i][j]==-1?-1:par[i][par[i][j]]);\n  }\n  int lca(int a, int b){\n    if(dep[a] < dep[b]) swap(a,b);\n    int x = dep[a]-dep[b];\n    for(int i = bi-1; i >= 0; --i){\n      if(1<<i <= x) a = par[i][a], x -= 1<<i;\n    }\n    if(a == b) return a;\n    for(int i = bi-1; i >= 0; --i){\n      if(par[i][a] != par[i][b]) a = par[i][a], b = par[i][b];\n    }\n    return par[0][a];\n  }\n  int dist(int a, int b){\n    int c = lca(a,b);\n    return dep[a]+dep[b] - dep[c]*2;\n  }\n};\n//\n\nvoid bfs(vvi& g, vi& d, int sv) {\n  d[sv] = 0;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == INF) {\n        d[u] = d[v]+1;\n        q.push(u);\n      }\n    }\n  }\n}\nvoid cfs(vvi& g, vi& d, int sv) {\n  if (d[sv] != 1) return;\n  d[sv] = 2;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == 1) {\n        d[u] = 2;\n        q.push(u);\n      }\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d\",&n);\n  int x, y;\n  scanf(\"%d%d\",&x,&y);\n  --x; --y;\n  s = t = vvi(n);\n  LCA g(n);\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    s[a].pb(b);\n    s[b].pb(a);\n  }\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    t[a].pb(b);\n    t[b].pb(a);\n    g.add(a,b);\n  }\n  g.init();\n  ds = dt = vi(n,INF);\n  bfs(s,ds,x);\n  bfs(t,dt,y);\n  int ans = 0;\n  vi c(n);\n  rep(i,n) if (ds[i] < dt[i]) c[i] = 1;\n  cfs(s,c,x);\n  rep(i,n) {\n    if (c[i] != 2) continue;\n    maxs(ans, dt[i]*2);\n    for (int u : s[i]) {\n      // if (c[u] != 2) continue;\n      if (g.dist(i,u) >= 3) {\n        puts(\"-1\");\n        return 0;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X,Y;\nvector<int> E[202020],E2[202020];\n\nint P[21][200005],D[200005],D2[200005];\n\nvoid dfs(int cur) {\n\tITR(it,E[cur]) if(*it!=P[0][cur]) D[*it]=D[cur]+1, P[0][*it]=cur, dfs(*it);\n}\nint dist(int a,int b) {\n\tint ret=0,i,aa=a,bb=b;\n\tif(D[aa]>D[bb]) swap(aa,bb);\n\tfor(i=19;i>=0;i--) if(D[bb]-D[aa]>=1<<i) bb=P[i][bb];\n\tfor(i=19;i>=0;i--) if(P[i][aa]!=P[i][bb]) aa=P[i][aa], bb=P[i][bb];\n\treturn D[a]+D[b]-2*D[(aa==bb)?aa:P[0][aa]];  // dist\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>X>>Y;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE2[x].push_back(y);\n\t\tE2[y].push_back(x);\n\t}\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\tP[0][Y]=Y;\n\tdfs(Y);\n\tFOR(i,19) FOR(x,N) P[i+1][x+1]=P[i][P[i][x+1]];\n\tFOR(i,N) D2[i+1]=10101010;\n\t\n\tint ret=0;\n\tqueue<int> Q;\n\tD2[X]=0;\n\tQ.push(X);\n\twhile(Q.size()) {\n\t\tx = Q.front();\n\t\tQ.pop();\n\t\tret=max(ret,D[x]);\n\t\tif(D2[x]>=D[x]) continue;\n\t\tFORR(e,E2[x]) {\n\t\t\tif(dist(x,e)>=3) return _P(\"-1\\n\");\n\t\t\tif(D2[e]>D2[x]+1) D2[e]=D2[x]+1, Q.push(e);\n\t\t}\n\t}\n\t\n\tcout<<ret*2<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge\n{\n\tint x,y;\n}e[200010];\nint n,dep[200010],d[200010],sx,sy,fa[200010];\nbool used[200010],vis[200010];\nint cnt,head[200010],to[400010],nxt[400010];\nvector<int> v[200010];\nqueue<int> q;\nvoid add(int x,int y)\n{\n\tcnt++;\n\tto[cnt]=y;\n\tnxt[cnt]=head[x];\n\thead[x]=cnt;\n}\nvoid dfs(int x)\n{\n\tfor (int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif (y==fa[x])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfa[y]=x;\n\t\tdep[y]=dep[x]+1;\n\t\tdfs(y);\n\t}\n}\nbool check(int x,int y)\n{\n\tif (dep[x]>dep[y])\n\t{\n\t\tswap(x,y);\n\t}\n\tif (x==fa[y] || x==fa[fa[y]])\n\t{\n\t\treturn true;\n\t}\n\tif (fa[x]==fa[y])\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&sy,&sx);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdep[sx]=1;\n\tdfs(sx);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tx=e[i].x;\n\t\ty=e[i].y;\n\t\tif (!check(x,y))\n\t\t{\n\t\t\tused[x]=used[y]=true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//cerr<<x<<\" \"<<y<<endl;\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t}\n\t}\n\tmemset(d,-1,sizeof(d));\n\td[sy]=1;\n\tvis[sy]=true;\n\tq.push(sy);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor (int i=0;i<v[x].size();i++)\n\t\t{\n\t\t\tint y=v[x][i];\n\t\t\tif (d[y]!=-1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[y]=d[x]+1;\n\t\t\tif (d[y]<dep[y])\n\t\t\t{\n\t\t\t\t//cerr<<y<<endl;\n\t\t\t\tvis[y]=true;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\tint mx=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (used[i] && vis[i])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (vis[i])\n\t\t{\n\t\t\tmx=max(mx,dep[i]);\n\t\t}\n\t}\n\tcout<<(mx-1)*2<<endl;\n\treturn 0;\n}\n//初见你时你给我你的心，里面是一个春天的早晨。\n//再见你时你给我你的话，说不出的是炽烈的火夏。\n//三次见你你给我你的手，里面藏着个叶落的深秋。\n//最后见你是我做的短梦，梦里有你还有一群冬风。\n//——《季候》"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,X,Y,x[200005],y[200005],f[200005][18],d[200005],wi[200005],D[200005],ans;\nvector<int> v[200005];\nvoid dfs(int x,int y){\n    f[x][0]=y,d[x]=d[y]+1;\n    for(int i=0;i<17;++i)f[x][i+1]=f[f[x][i]][i];\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint lca(int x,int y){\n    if(d[x]<d[y])swap(x,y);\n    for(int i=17;i>=0;--i)if(d[f[x][i]]>=d[y])x=f[x][i];\n    if(x==y) return x;\n    for(int i=17;i>=0;--i)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\nvoid dfs2(int x,int y){\n    D[x]=D[y]+1;\n    if(D[x]>d[x]) return;\n    if(wi[x])ans=orz;\n    else ans=max(ans,d[x]*2);\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs2(v[x][i],x);\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&X,&Y);\n    for(int i=1;i<n;++i)scanf(\"%d%d\",x+i,y+i);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    d[0]=-1;\n    dfs(Y,0);\n    for(int i=1;i<=n;++i)v[i].clear();\n    for(int i=1;i<n;++i){\n        int o=d[x[i]]+d[y[i]]-d[lca(x[i],y[i])]*2;\n        if(o>2)wi[x[i]]=wi[y[i]]=1;\n        else v[x[i]].pb(y[i]),v[y[i]].pb(x[i]);\n    }\n    D[0]=-1;\n    dfs2(X,0);\n    if(ans==orz)puts(\"-1\");\n    else printf(\"%d\\n\",ans);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,y,ans;\n\nvector<int> G[maxn],G2[maxn];\n\nint tim[maxn],fa[maxn];\n\nvoid dfs2(int u,int ff){\n\tfa[u]=ff;\n\ttim[u]=tim[ff]+1;\n\tfor(auto v:G2[u])if(v!=ff)dfs2(v,u);\n}\n\nbool check(int x,int y){\n\tif(fa[fa[x]]==y)return 0;\n\tif(fa[x]==y)return 0;\n\tif(fa[fa[y]]==x)return 0;\n\tif(fa[y]==x)return 0;\n\tif(fa[x]==fa[y])return 0;\n\treturn 1;\n}\n\nvoid dfs1(int u,int fa,int now){\n\tif(fa)\n\t\tif(check(u,fa)){\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\tans=max(ans,(tim[u]-1)*2);\n\tfor(auto v:G[u])if(now+1<tim[v]&&v!=fa){\n\t\tdfs1(v,u,now+1);\n\t}\n}\n\nvoid Work(){\n\tif(x==y){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tdfs2(y,0);\n\tdfs1(x,0,1);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,x,y);\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG2[u].PB(v);G2[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MAXN = 2e5 + 10;\nstruct edge {\n    static int ptr;\n    int to, next;\n} e[MAXN * 4];\nint edge::ptr = 0;\n\nint G1[MAXN], G2[MAXN], depth2[MAXN], parent2[MAXN];\nvoid dfs2(int o, int p, int d) {\n    parent2[o] = p, depth2[o] = d;\n    for (int i = G2[o]; i; i = e[i].next) {\n        if (e[i].to == p) continue;\n        dfs2(e[i].to, o, d + 1);\n    }\n}\nconstexpr int INF = 1e9;\nint baluteshih_orz(int x, int y) {\n    if (depth2[x] < depth2[y]) swap(x, y);\n    if (x == y) return 0;\n    if (parent2[x] == y) return 1;\n    if (parent2[x] == parent2[y]) return 2;\n    if (parent2[parent2[x]] == y) return 2;\n    return INF;\n}\nint dfs1(int o, int p, int d2) {\n    if (depth2[o] <= d2) return d2;\n    int ret = depth2[o];\n    for (int i = G1[o]; i; i = e[i].next) {\n        int to = e[i].to;\n        if (to == p) continue;\n        if (baluteshih_orz(o, to) == INF) return INF;\n        ret = max(ret, dfs1(to, o, d2 + 1));\n    }\n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N, X, Y;\n    cin >> N >> X >> Y;\n    for (int i = 1, u, v; i < N; i++) {\n        cin >> u >> v;\n        e[++edge::ptr] = {v, G1[u]}, G1[u] = edge::ptr;\n        e[++edge::ptr] = {u, G1[v]}, G1[v] = edge::ptr;\n    }\n    for (int i = 1, u, v; i < N; i++) {\n        cin >> u >> v;\n        e[++edge::ptr] = {v, G2[u]}, G2[u] = edge::ptr;\n        e[++edge::ptr] = {u, G2[v]}, G2[v] = edge::ptr;\n    }\n    dfs2(Y, 0, 0);\n    int ans = dfs1(X, 0, 0);\n    cout << (ans == INF ? -1 : 2 * ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 400004\nint a[2][N],b[2][N],c[2][N],e[N],f[N],h[N],i,l,n,q[N],r,s[N],t,x,y;bool d[N][2],g[N];\ninline bool cmp(int u,int v){return f[u]!=v&&u!=f[v]&&f[u]!=f[v]&&f[f[u]]!=v&&u!=f[f[v]];}\nint u,v;\nint main()\n{\n\tfor(scanf(\"%d%d%d\",&n,&x,&y),i=t=1;i<n;i++)scanf(\"%d%d\",&u,&v),b[0][++t]=a[0][u],c[0][a[0][u]=t]=v,b[0][++t]=a[0][v],c[0][a[0][v]=t]=u;\n\tfor(i=t=1,e[n]=-1;i<n;e[i++]=-1)scanf(\"%d%d\",&u,&v),b[1][++t]=a[1][u],c[1][a[1][u]=t]=v,b[1][++t]=a[1][v],c[1][a[1][v]=t]=u;\n\tfor(d[q[r++]=y][e[y]=1]=true,d[q[r++]=x][e[x]=0]=true,e[y]=1;l<r;)for(v=e[u=q[l++]],i=a[v][u];i;i=b[v][i])if(e[c[v][i]]<e[u])d[q[r++]=c[v][i]][e[c[v][i]]=e[u]]=true,f[c[v][i]]=u,g[c[v][i]]=h[c[v][i]]==h[u]+1,h[c[v][i]]=h[u]+1;\n\tfor(i=1;i<n;i++)if(cmp(c[0][i<<1],c[0][i<<1|1])&&(!g[c[0][i<<1]]&&(!g[c[0][i<<1|1]]||*d[c[0][i<<1]])&&*d[c[0][i<<1|1]]))return 0&puts(\"-1\");\n\tfor(i=1,v=0;i<=n;i++)if(*d[i]&&v<h[i])v=h[i];\n\treturn 0&printf(\"%d\\n\",v<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nvector<int> r[200000], b[200000];\nint x, y;\nint dist[200000], can[200000];\nqueue<int> q;\nvector<PII> all;\nset<PII> be;\nset<int> se[200000];\n\nint main() {\n    scanf(\"%d\", &n);\n    scanf(\"%d%d\", &x, &y), --x, --y;\n    forn(i, n - 1) {\n        int from, to;\n        scanf(\"%d%d\", &from, &to), --from, --to;\n        r[from].pb(to);\n        r[to].pb(from);\n    }\n    forn(i, n - 1) {\n        int from, to;\n        scanf(\"%d%d\", &from, &to), --from, --to;\n        b[from].pb(to);\n        b[to].pb(from);\n        be.insert(mp(min(from, to), max(from, to)));\n        se[from].insert(to);\n        se[to].insert(from);\n    }\n    memset(dist, -1, sizeof dist);\n    dist[y] = 0;\n    q.push(y);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int to : b[v]) if (dist[to] == -1) {\n            dist[to] = dist[v] + 1;\n            q.push(to);\n        }\n    }\n    memset(can, -1, sizeof can);\n    can[x] = 0;\n    q.push(x);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int to : r[v]) if (can[to] == -1 && can[v] + 1 < dist[to]) {\n            can[to] = can[v] + 1;\n        }\n    }\n    forn(i, n) if (can[i] != -1) {\n        for (int to : r[i]) {\n            all.pb(mp(min(i, to), max(i, to)));\n        }\n    }\n    sort(all.begin(), all.end());\n    all.erase(unique(all.begin(), all.end()), all.end());\n    for (PII x : all) {\n        if (be.count(x)) {\n            continue;\n        }\n        int mn = x.first;\n        int oth = x.second;\n        if (b[x.second].size() < b[x.first].size()) {\n            swap(mn, oth);\n        }\n        bool ok = true;\n        for (int to : b[mn]) {\n            if (se[to].count(oth)) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    int ans = 0;\n    forn(i, n) if (can[i] != -1) {\n        ans = max(ans, dist[i]);\n        for (int to : r[i]) {\n            ans = max(ans, dist[to]);\n        }\n    }\n    cout << 2 * ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e5+5,LG=19,SM=4000+5,inf=1e18+1;\nll mod=924844033;\n\nll n;\nll ru[M],rv[M];\nll bu[M],bv[M];\nll h[M];\nbool spc[M];\nll dis[M];\nvll g[M],tr[M];\nll x,y;\nll par[M];\nbool acc[M];\n\nvoid dfs(ll x)\n{\n    for (ll y:tr[x])\n    {\n        if (par[x]==y) continue;\n        par[y]=x;\n        h[y]=h[x]+1;\n        dfs(y);\n    }\n}\n\nbool dis3(ll x,ll y)\n{\n    if (h[x]>h[y]) swap(x,y);\n    if (h[x]==h[y])\n        return par[x]==par[y];\n    else if (h[y]-h[x]==1)\n        return par[y]==x;\n    else return par[par[y]]==x;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n >> x >> y;\n    x--;\n    y--;\n    For(i,1,n)\n    {\n        ll u,v;\n        cin >> u >> v;\n        u--;v--;\n        ru[i]=u;\n        rv[i]=v;\n    }\n    For(i,1,n)\n    {\n        ll u,v;\n        cin >> u >> v;\n        u--;v--;\n        bu[i]=u;\n        bv[i]=v;\n        tr[u].PB(v);\n        tr[v].PB(u);\n    }\n    par[y]=y;\n    dfs(y);\n    For(i,1,n)\n    {\n        if (dis3(ru[i],rv[i]))\n        {\n            g[ru[i]].PB(rv[i]);\n            g[rv[i]].PB(ru[i]);\n        }\n        else\n            spc[ru[i]]=spc[rv[i]]=1;        \n    }\n    queue<ll> qu;\n    memset(dis,sizeof dis,1);\n    qu.push(x);\n    dis[x]=0;\n    while (SZ(qu))\n    {\n        ll f=qu.front();\n        qu.pop();\n        //ER(f);ER(dis[f]);ER(h[f]);\n        if (dis[f]>=h[f])\n        {\n            continue;\n        }\n        acc[f]=1;\n        for (ll y:g[x])\n        {\n            if (dis[y]>dis[x]+1)\n            {\n                dis[y]=dis[x]+1;\n                qu.push(y);\n            }\n        }\n    }\n    ll res=0;\n    For(i,0,n)\n    {\n        if (acc[i])\n        {\n            smax(res,h[i]);\n            if (spc[i]) RET(-1);\n        }\n    }\n    RET(2*res);\n}    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <codecvt>\n\nconst int N = 200001;\n\nint n, x, y, a[N], b[N], depth[N], parent[N], escape[N], dist[N];\nstd::vector<int> tree[N], graph[N];\n\nvoid prepare(int p, int u) {\n  depth[u] = depth[p] + 1, parent[u] = p;\n  for (int v : tree[u]) {\n    if (v != p) {\n      prepare(u, v);\n    }\n  }\n}\n\nint treedist(int a, int b) {\n  int d = 0;\n  while (d < 3 && a != b) {\n    int &u = depth[a] > depth[b] ? a : b;\n    d++, u = parent[u];\n  }\n  return d;\n}\n\nint main() {\n  scanf(\"%d%d%d\", &n, &x, &y);\n  for (int i = 0; i < n - 1; ++i) {\n    scanf(\"%d%d\", a + i, b + i);\n  }\n  for (int i = 0, c, d; i < n - 1; ++i) {\n    scanf(\"%d%d\", &c, &d);\n    tree[c].push_back(d);\n    tree[d].push_back(c);\n  }\n  depth[0] = -1;\n  prepare(0, y);\n  for (int i = 0; i < n - 1; ++i) {\n    if (treedist(a[i], b[i]) == 3) {\n      escape[a[i]] = escape[b[i]] = true;\n    } else {\n      graph[a[i]].push_back(b[i]);\n      graph[b[i]].push_back(a[i]);\n    }\n  }\n  std::vector<int> queue;\n  queue.push_back(x);\n  memset(dist, -1, sizeof(dist));\n  dist[x] = 0;\n  for (int head = 0; head < static_cast<int>(queue.size()); ++head) {\n    int u = queue[head];\n    for (int v : graph[u]) {\n      if (dist[v] == -1) {\n        dist[v] = dist[u] + 1;\n        queue.push_back(v);\n      }\n    }\n  }\n  int result = 0;\n  for (int i = 1; i <= n; ++i) {\n    if (~dist[i] && dist[i] < depth[i]) {\n      result = std::max(result, depth[i] * 2);\n    }\n    if (escape[i] && ~dist[i] && dist[i] < depth[i]) {\n      result = -1;\n      break;\n    }\n  }\n  printf(\"%d\\n\", result);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 200005\n\nusing namespace std;\n\nint n, s, t, ans;\n\nstruct graph {\n    vector<int> g[MAXN];\n    int fa[MAXN][19], dep[MAXN];\n    \n    void connect(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    void build(int u = s, int pre = 0) {\n        fa[u][0] = pre;\n        dep[u] = dep[pre] + 1;\n        for (int i = 1; i <= 18; ++i)\n            fa[u][i] = fa[fa[u][i - 1]][i - 1];\n        for (int i = 0; i < (int)g[u].size(); ++i) {\n            int v = g[u][i];\n            if (v == pre)\n                continue;\n            build(v, u);\n        }\n    }\n    \n    int query(int u, int v) {\n        if (dep[u] < dep[v])\n            swap(u, v);\n        for (int i = 18; i >= 0; --i)\n            if (dep[fa[u][i]] >= dep[v])\n                u = fa[u][i];\n        if (u == v)\n            return u;\n        for (int i = 18; i >= 0; --i)\n            if (fa[u][i] != fa[v][i]) {\n                u = fa[u][i];\n                v = fa[v][i];\n            }\n        return fa[u][0];\n    }\n    \n    int calc(int u, int v) {\n        return dep[u] + dep[v] - dep[query(u, v)] * 2;\n    }\n}A, B;\n\n\nint read() {\n    char c = getchar();\n    int x = 0;\n    while (!isdigit(c))\n        c = getchar();\n    while (isdigit(c)) {\n        x = (x << 3) + (x << 1) + c - '0';\n        c = getchar();\n    }\n    return x;\n}\n\nbool DFS(int u, int pre) {\n    if (A.dep[u] - 1 >= B.calc(t, u))\n        return false;\n    for (int i = 0; i < (int)A.g[u].size(); ++i) {\n        int v = A.g[u][i];\n        if (v == pre)\n            continue;\n        if (B.calc(u, v) > 2 || DFS(v, u))\n            return true;\n    }\n    return false;\n}\n\nvoid find(int u, int pre) {\n    if (A.dep[u] - 1 > B.calc(t, u))\n        return ;\n    ans = max(ans, B.calc(t, u) * 2);\n    for (int i = 0; i < (int)A.g[u].size(); ++i) {\n        int v = A.g[u][i];\n        if (v == pre)\n            continue;\n        find(v, u);\n    }\n}\n\nint main() {\n//    freopen(\"giri4.in\", \"r\", stdin);\n    n = read();\n    s = read();\n    t = read();\n    for (int i = 1; i < n; ++i)\n        A.connect(read(), read());\n    for (int i = 1; i < n; ++i)\n        B.connect(read(), read());\n    A.build();\n    B.build();\n    bool isinfinity = DFS(s, 0);\n    if (isinfinity)\n        puts(\"-1\");\n    else {\n        find(s, 0);\n        printf(\"%d\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 21\nstruct {\n    vector<int> e[N];\n    int fa[N][M], d[N];\n    void dfs(int u) {\n        for (auto v : e[u]) {\n            if (v == fa[u][0]) continue;\n            fa[v][0] = u, d[v] = d[u] + 1;\n            for (int i = 1; i < M; i++) fa[v][i] = fa[fa[v][i - 1]][i - 1];\n            dfs(v);\n        }\n    }\n    void init(int n) {\n        for (int i = 1, u, v; i < n; i++) {\n            scanf(\"%d%d\", &u, &v);\n            e[u].push_back(v);\n            e[v].push_back(u);\n        }\n    }\n    int lca(int u, int v) {\n        if (d[u] < d[v]) swap(u, v);\n        for (int i = M - 1; ~i; i--)\n            if (d[fa[u][i]] >= d[v]) u = fa[u][i];\n        if (u == v) return u;\n        for (int i = M - 1; ~i; i--)\n            if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];\n        return fa[u][0];\n    }\n} ex, ey;\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    ex.init(n);\n    ey.init(n);\n    ex.dfs(addx);\n    ey.dfs(addy);\n    queue<int> que;\n    que.push(addx);\n    int ans = 0;\n    while (!que.empty()) {\n        int u = que.front();\n        que.pop();\n        int f = ex.fa[u][0], tmp = ey.lca(u, f);\n        if (ey.d[u] + ey.d[f] - 2 * ey.d[tmp] > 2) {\n            puts(\"-1\");\n            return 0;\n        }\n        ans = max(ans, ey.d[u] << 1);\n        if (ex.d[u] >= ey.d[u]) continue;\n        for (auto v : ex.e[u])\n            if (v != f) que.push(v);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(u!= U && !bad[pre[u]])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(h[u1[i]]>h[u2[i]])swap(u1[i],u2[i]);\n\trep(i,1,n)if(ok[i] && (!bad[u1[i]])){\n\t\tma=-1;\n\t}\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb(n) push_back(n)\n#define maxn 200010\n#define inf 1000000000\n\nusing namespace std;\n\nbool czy [maxn], special [maxn], czy1[maxn];\nint bdistance [maxn], ojciec[maxn], ile[maxn];\nvector<int> red[maxn], blue[maxn];\n\nint Find (int x)\n{\n\tif (ojciec[x]!=x)\n\t\tojciec[x]=Find(ojciec[x]);\n\treturn ojciec[x];\n}\n\nvoid join (int a, int b)\n{\n\ta = Find(a);\n\tb = Find(b);\n\tif (ile[a] > ile[b])\n\t\tswap(a,b);\n\tif (a != b)\n\t{\n\t\tojciec[a]=b;\n\t\tile[b] += ile[a];\n\t}\n}\n\nvoid calculate_blue (int x)\n{\n\tczy[x]=true;\n\tint s = (int)blue[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif(!czy[blue[x][i]])\n\t\t{\n\t\t\tbdistance[blue[x][i]] = bdistance[x] + 1;\n\t\t\tcalculate_blue(blue[x][i]);\n\t\t}\n\t}\n\tczy[x]=false;\n}\n\nvoid calculate_special (int x, int y)\n{\n\tczy[x]=true;\n\tint s = (int)red[x].size();\n\tfor(int i=0; i<s; ++i)\n\t{\n\t\tif (czy[red[x][i]])\n\t\t{\n\t\t\tint odl = bdistance[x] + bdistance[red[x][i]] - 2 * bdistance[Find(red[x][i])];\n\t\t\t//cout << x << \" \" << red[x][i] << \" \" << odl << endl;\n\t\t\tif (odl >= 3)\n\t\t\t\tspecial[x] = special[red[x][i]] = true;\n\t\t}\n\t}\n\ts = (int) blue[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif(!czy[blue[x][i]])\n\t\t\tcalculate_special (blue[x][i], x);\n\t}\n\tjoin (x, y);\n}\n\nint answer (int x, int y)\n{\n\tczy1 [x] = true;\n\tif (special[x] && bdistance [x] > y)\n\t\treturn inf;\n\tif (bdistance [x] <= y)\n\t\treturn y;\n\tint odp = bdistance [x];\n\tint s = (int)red[x].size();\n\tfor (int i = 0; i<s; ++i)\n\t{\n\t\tif (!czy1[red[x][i]])\n\t\t{\n\t\t\todp = max(answer (red[x][i], y + 1), odp);\n\t\t}\n\t}\n\treturn odp;\t\n}\n\n\nint main()\n{\n\tint n, x, y,a,b;\n\tcin >> n >> x >> y;\n\tfor(int i=1; i<n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tred[a].pb(b);\n\t\tred[b].pb(a);\n\t\tojciec[i]=i;\n\t\tile[i]=1;\n\t}\n\tojciec[n]=n;\n\tile[n]=1;\n\tfor(int i=1; i<n; ++i)\n\t{\n\t\tcin >> a >> b;\n\t\tblue[a].pb(b);\n\t\tblue[b].pb(a);\n\t}\n\tcalculate_blue (y);\n\tcalculate_special (y, y);\n\tint ans = answer (x, 0);\n\tif (ans == inf)\n\t\tputs (\"-1\");\n\telse\n\t\tcout << 2 * ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define OUT(x)  cerr << #x << \" = \" << x << endl;\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define pll     pair<long long, long long>\n#define ll      long long\n\nstruct state {\n        int v, step;\n        state(int v, int step) : v(v), step(step) { }\n};\n\nvector<int> gx[202020];\nint depth_x[202020];\n\nvector<int> gy[202020];\nint depth_y[202020];\nint parent[30][202020];\n\nvoid dfs_lca(int v, int p, int d) {\n        parent[0][v] = p;\n        depth_y[v] = d;\n        for (auto i : gy[v]) if (i != p) dfs_lca(i, v, d + 1);\n}\nvoid init_lca(int s, int V) {\n        dfs_lca(s, -1, 0);\n        for (int k = 0; k < 30 - 1; k ++) {\n                for (int i = 0; i < V; i ++) {\n                        if (parent[k][i] < 0) parent[k + 1][i] = -1;\n                        else parent[k + 1][i] = parent[k][parent[k][i]];\n                }\n        }\n}\nint lca(int u, int v) { \n        if (depth_y[u] > depth_y[v]) swap(u, v);\n        for (int k = 0; k < 30; k ++) {\n                if ((depth_y[v] - depth_y[u]) >> k & 1) { \n                        v = parent[k][v];\n                }\n        }\n        if (u == v) return u;\n        for (int k = 30 - 1; k >= 0; k --) {\n                if (parent[k][u] != parent[k][v]) {\n                        u = parent[k][u];\n                        v = parent[k][v];\n                }\n        }\n        return parent[0][u];\n}\nint dist(int u, int v) {\n        return depth_y[u] + depth_y[v] - depth_y[lca(u, v)] * 2;\n}\n\nint main() {\n        int n, x, y;\n        cin >> n >> x >> y;\n        x --, y --;\n        vector<pii> edge(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                cin >> a >> b;\n                a --, b --;\n                edge[i] = mp(a, b);\n                gx[a].push_back(b);\n                gx[b].push_back(a);\n        }\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                cin >> a >> b;\n                a --, b --;\n                gy[a].push_back(b);\n                gy[b].push_back(a);\n        }\n        init_lca(y, n);\n        vector<pii> loop;\n        for (int i = 0; i < n - 1; i ++) {\n                if (dist(edge[i].first, edge[i].second) >= 3) loop.push_back(edge[i]);\n        }\n        set<int> loop_set;\n        for (int i = 0; i < loop.size(); i ++) {\n                loop_set.insert(loop[i].first);\n                loop_set.insert(loop[i].second);\n        }\n        queue<state> q;\n        q.push((state){ x, 0 });\n        int ans = -1;\n        vector<bool> used(n, false);\n        used[x] = true;\n        while (!q.empty()) {\n                state now = q.front(); q.pop();\n                //cerr << \"now.v = \" << now.v << endl;\n                ans = max(ans, depth_y[now.v] * 2);\n                if (loop_set.count(now.v)) {\n                        cout << -1 << endl;\n                        return 0;\n                }\n                for (auto next : gx[now.v]) if (!used[next]) {\n                        used[next] = true;\n                        if (depth_y[next] <= now.step + 1) continue;\n                        q.push((state){ next, now.step + 1 });\n                }\n        }\n        cout << ans << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define edge(j) for (j=fst[x];j;j=nxt[j])\nusing namespace std;\nconst int N=2e5+5;\nint n,x,y,i,u,v,ans,mode;\nint En,fst[N],Fa[N],nxt[N*2],to[N*2];\nint U[N],V[N],A[N],B[N];\nvoid File()\n{\n\tfreopen(\"game.in\",\"r\",stdin);\n\tfreopen(\"game.out\",\"w\",stdout);\n}\nvoid add(int u,int v) {\n\tEn++; nxt[En]=fst[u]; fst[u]=En; to[En]=v;\n}\nvoid dfs(int x,int fa,int step,int *A)\n{\n\tint j,v;\n\tif (mode==1 && x==y) return ;\n\tA[x]=step; Fa[x]=fa;\n\tedge(j)\n\t{\n\t\tv=to[j];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x,step+1,A);\n\t}\n}\nvoid Init()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t\tU[i]=u; V[i]=v;\n\t}\n\trep(i,1,n) A[i]=B[i]=n+1;\n\tmode=1; dfs(x,x,0,A);\n\tmemset(fst,0,sizeof(fst));\n\tEn=0;\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\t\t\n\t}\n\tmode=2; dfs(y,y,0,B);\n}\nvoid Solve()\n{\n\trep(i,1,n-1)\n\t{\n\t\tif (Fa[U[i]]==V[i] || Fa[V[i]]==U[i]) continue;\n\t\tif (Fa[U[i]]==Fa[V[i]] || Fa[Fa[U[i]]]==V[i] || Fa[Fa[V[i]]]==U[i]) continue;\n\t\tif (A[U[i]]<B[U[i]] || A[V[i]]<B[V[i]])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn ;\n\t\t}\n\t}\n\trep(i,1,n)\n\t\tif (A[i]<B[i])\n\t\t\tans=max(ans,B[i]);\n\tans*=2;\n\tprintf(\"-1\\n\"); //printf(\"%d\\n\",ans);\n}\nint main()\n{\n//\tFile();\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=2e5+5;\nstruct edge{\n\tint v,Next;\n}e[2][N<<2];\nint head[2][N],cnt[2],n,dep[2][N],f[N][30],tot[2],rt[2],ans;\nvoid addedge(int u,int v,int col){\n\te[col][++cnt[col]].v=v;\n\te[col][cnt[col]].Next=head[col][u];\n\thead[col][u]=cnt[col];\n}\nvoid dfs(int p,int fa,int type){\n\tif(type) rep(i,1,20) f[p][i]=f[f[p][i-1]][i-1];\n\tfor(int ne=head[type][p];ne;ne=e[type][ne].Next){\n\t\tif(e[type][ne].v==fa) continue;\n\t\tif(type) f[e[type][ne].v][0]=p;\n\t\tdep[type][e[type][ne].v]=dep[type][p]+1;\n\t\tdfs(e[type][ne].v,p,type);\n\t}\n}\nint LCA(int u,int v){\n\tif(dep[1][u]<dep[1][v]) swap(u,v);\n\tper(i,20,0) if(dep[1][f[u][i]]>=dep[1][v]) u=f[u][i];\n\tif(u==v) return u;\n\tper(i,20,0) if(f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i];\n\treturn f[u][0]; \n}\nvoid solve(int p,int fa){\n\tif(dep[0][p]>=dep[1][p]) return ;\n\tif(ans==-1) return ;\n\tans=max(ans,(dep[1][p]-1)*2);\n\tfor(int ne=head[0][p];ne;ne=e[0][ne].Next){\n\t\tif(e[0][ne].v==fa) continue;\n\t\tif(dep[1][p]+dep[1][e[0][ne].v]-2*dep[1][LCA(p,e[0][ne].v)]>2) return (void)(ans=-1);\n\t\tsolve(e[0][ne].v,p);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&rt[0],&rt[1]);\n\tdep[0][rt[0]]=1,dep[1][rt[1]]=1;\n\trep(i,2,n){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v,0);addedge(v,u,0);\n\t}\n\trep(i,2,n){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v,1);addedge(v,u,1);\n\t}\n\tdfs(rt[0],0,0);dfs(rt[1],0,1);\n\tans=0; solve(rt[0],0);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2000005;\n\nint N,X,Y;\nvector<int> red[MAXN],blue[MAXN];\nint dep[MAXN],fa[MAXN];\n\nbool isTable(int u,int v)\n{\n\tif(dep[u]>dep[v])\n\t\tswap(u,v);\n\tif(fa[v]==u||fa[fa[v]]==u||fa[u]==fa[v])\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs1(int u)\n{\n\tfor(auto v:blue[u])\n\t\tif(v!=fa[u])\n\t\t{\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs1(v);\n\t\t}\n}\nint dfs2(int u,int f=0,int step=0)\n{\n\tstep++;\n\tint res=dep[u];\n\tfor(auto v:red[u])\n\t{\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tif(dep[v]>step)\n\t\t{\n\t\t\tif(isTable(u,v))\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tres=max(res,dfs2(v,u,step+1));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&X,&Y);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred[u].push_back(v);\n\t\tred[v].push_back(u);\n\t}\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue[u].push_back(v);\n\t\tblue[v].push_back(u);\n\t}\n\tdfs1(Y);\n\tint ans=dfs2(X)*2;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 9;\n\nvector<int>r[N], b[N];\nint n, R, B, d[N], fa[N], ans;\n\nvoid Dfs (int u) {\n\tfor (auto v : b[u]) if (v != fa[u]) fa[v] = u, d[v] = d[u] + 1, Dfs(v);\n}\n\nbool Judge (int x, int y) {\n\tfor (int i = 1; x != y; ++i) {\n\t\tif (d[x] > d[y]) x = fa[x];\n\t\telse y = fa[y];\n\t\tif (i > 2) return 1;\n\t}\n\treturn 0;\n}\n\nvoid Dfs (int u, int k) {\n\tif (k >= d[u]) return ;\n\tif (d[u] > ans) ans = d[u];\n\tfor (auto v : r[u]) {\n\t\tDfs(v, k + 1);\n\t\tif (Judge(u, v)) puts(\"-1\"), exit(0);\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%d\", &n, &R, &B);\n\tfor (int i = 1, u, v; i < n; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tr[u].emplace_back(v);\n\t\tr[v].emplace_back(u);\n\t}\n\tfor (int i = 1, u, v; i < n; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb[u].emplace_back(v);\n\t\tb[v].emplace_back(u);\n\t}\n\td[B] = 0; Dfs(B);\n\tDfs(R, 0);\n\tprintf(\"%d\\n\", ans << 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"ctime\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nclass Lowest_Common_Ancestor {\n\tvector<int>depth;\n\tvector<vector<int>>parent;\n\tvector<vector<int>>edge;\n\tint height = 0;\n\tint node;\npublic:\n\tLowest_Common_Ancestor(int num) {\n\t\tnum++;\n\t\tnode = num;\n\t\twhile (num) {\n\t\t\theight++;\n\t\t\tnum /= 2;\n\t\t}\n\t\tparent.resize(height);\n\t\tedge.resize(node);\n\t\tdepth.resize(node);\n\t\tfor (int i = 0; i < height; i++)parent[i].resize(node);\n\t}\n\tvoid Add_Edge(int a, int b) {\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\treturn;\n\t}\n\tvoid Update(int rtnode) {\n\t\tqueue<int>QQ;\n\t\tfor (int i = 0; i < node; i++) depth[i] = INT_MAX;\n\t\tdepth[rtnode] = 0;\n\t\tQQ.push(rtnode);\n\t\twhile (!QQ.empty()) {\n\t\t\tint c = QQ.front();\n\t\t\tfor (auto i : edge[c]) {\n\t\t\t\tif (depth[i] > depth[c] + 1) {\n\t\t\t\t\tdepth[i] = depth[c] + 1;\n\t\t\t\t\tQQ.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQQ.pop();\n\t\t}\n\t\tparent[0][rtnode] = -1;\n\t\tfor (int i = 1; i < node; i++) {\n\t\t\tfor (auto j : edge[i]) {\n\t\t\t\tif (depth[i] - 1 == depth[j]) {\n\t\t\t\t\tparent[0][i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < height - 1; i++) {\n\t\t\tfor (int j = 0; j < node; j++) {\n\t\t\t\tif (parent[i][j] < 0)parent[i + 1][j] = -1;\n\t\t\t\telse parent[i + 1][j] = parent[i][parent[i][j]];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint LCA(int u, int v) {\n\t\tif (depth[u] > depth[v])swap(u, v);\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tif ((depth[v] - depth[u]) >> i & 1) {\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)return u;\n\t\tfor (int i = height - 1; i >= 0; i--) {\n\t\t\tif (parent[i][v] != parent[i][u]) {\n\t\t\t\tu = parent[i][u];\n\t\t\t\tv = parent[i][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n\tint Dist(int u, int v) {\n\t\treturn depth[u] + depth[v] - depth[LCA(u, v)] * 2;\n\t}\n};\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> L >> R;\n\tvector<vector<int>>edge(N + 1);\n\tLowest_Common_Ancestor lca(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tedge[H].push_back(W);\n      edge[W].push_back(H);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> H >> W;\n\t\tlca.Add_Edge(H, W);\n\t}\n\tlca.Update(1);\n\tvector<int>safe(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (lca.Dist(i, j) > 2)safe[i] = safe[j] = 1;\n\t\t}\n\t}\n\tvector<int>depth(N + 1, MOD);\n\tCalculate_Depth(edge, depth, L);\n\tvector<int>reachable(N + 1);\n\treachable[L] = lca.Dist(R, L);\n\tqueue<int>Q;\n\tQ.push(L);\n\twhile (!Q.empty()){\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (reachable[i])continue;\n\t\t\tif (depth[i] < lca.Dist(R, i)) {\n\t\t\t\treachable[i] = lca.Dist(R, i);\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tans = max(ans, reachable[i]);\n\t}\n\tans <<= 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (reachable[i] && safe[i])ans = -1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, X, Y;\nint head[200001], next[399999], to[399999], lon[399999], E;\nint dep[200001], dep2[200001], fa[200001];\nint au[200000], av[200000], al[200000];\nint q[200001];\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; i++)\n\t\tscanf(\"%d%d\", au + i, av + i);\n\tfor (int i = 1, u, v; i < N; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tnext[++E] = head[u], to[E] = v, head[u] = E;\n\t\tnext[++E] = head[v], to[E] = u, head[v] = E;\n\t}\n\tint H = 0, T = 1, u;\n\tq[1] = Y;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t{\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\t\t\t\tdep[to[e]] = dep[u] + 1;\n\t\t\t}\n\tfor (int i = 1; i < N; i++)\n\t\tal[i] = !(fa[au[i]] == av[i] || fa[av[i]] == au[i] || fa[fa[au[i]]] == av[i] || fa[fa[av[i]]] == au[i] || fa[au[i]] == fa[av[i]]);\n\tfor (int i = 1; i <= N; i++)\n\t\thead[i] = 0;\n\tE = 0;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tnext[++E] = head[au[i]], to[E] = av[i], lon[E] = al[i], head[au[i]] = E;\n\t\tnext[++E] = head[av[i]], to[E] = au[i], lon[E] = al[i], head[av[i]] = E;\n\t}\n\tH = 0, T = 1;\n\tq[1] = X;\n\tfa[X] = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tdep2[i] = 1000000000;\n\tdep2[X] = 0;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u] && dep2[u] + 1 < dep[to[e]])\n\t\t\t{\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\t\t\t\tdep2[to[e]] = dep2[u] + 1;\n\t\t\t}\n\tint O = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tif (dep2[i] < dep[i])\n\t\t{\n\t\t\tint Inf = 0;\n\t\t\tfor (int e = head[i]; e; e = next[e])\n\t\t\t\tif (lon[e])\n\t\t\t\t\tInf = 1;\n\t\t\tif (Inf)\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tO = std::max(O, dep[i]);\n\t\t}\n\tprintf(\"%d\\n\", O << 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\nstruct Edge{\n    int from,to;\n    Edge(int from,int to)\n        : from(from),to(to){};\n    Edge(){Edge(0,0);}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct HeavyLightDecomposition{\n    vector<int> index, htop, hchild, par, dep, idtov, topo,sub,heads;\n    Graph T;\n    HeavyLightDecomposition(int n) :index(n,-1),htop(n),hchild(n,-1),par(n),dep(n),idtov(n),sub(n),T(n){}\n\n    void calc(int root){\n        queue<int> Q({root});\n        par[root]=-1;\n        while(!Q.empty()){\n            int curr=Q.front(); Q.pop(); topo.push_back(curr);\n            for(auto &x: T[curr]){\n                if(x.to!=par[curr]){\n                    par[x.to]=curr;\n                    Q.push(x.to);\n                    dep[x.to]=dep[curr]+1;\n                }\n            }\n        }\n        for(int i=par.size()-1,max_sub=0; i>=0; --i){\n            ++sub[topo[i]];\n            if(i>0)sub[par[topo[i]]]+=sub[topo[i]];\n            if(i>0 and i<par.size()-1)if(par[topo[i+1]]!=par[topo[i]])max_sub=0;\n            if(i>0 and sub[topo[i]]>max_sub) hchild[par[topo[i]]]=topo[i];\n            for(auto &x : T[topo[i]])if(x.to!=par[topo[i]] and x.to!=hchild[topo[i]]) heads.push_back(x.to);\n        }\n        heads.push_back(root);\n        reverse(heads.begin(),heads.end());\n        int id=0;\n        for(int x : heads) {\n            for(int i=x; i!=-1; i=hchild[i]){\n                index[i]=id++;\n                idtov[index[i]]=i;\n                htop[i]=x;\n            }\n        }\n    }\n    inline bool same(int a,int b){return htop[a]==htop[b];}\n\n    int lca(int a, int b){\n        if(index[a]>index[b])swap(a,b);\n        if(same(a,b)) return a;\n        return lca(a,par[htop[b]]);\n    }\n    int dist(int a, int b){\n        return dep[a]+dep[b]-2*dep[lca(a,b)];\n    }\n};\n\nstruct Problem{\n    int size,x,y;\n    HeavyLightDecomposition sigma,sugim;\n    Problem(int n):size(n),sigma(n),sugim(n){};\n    bool is_sigma_nearer(int i){\n        return sigma.dist(i,x)<sugim.dist(i,y);\n    }\n    int dfs(int par, int cur){\n        if(!is_sigma_nearer(cur)) return -INF;\n        if(sigma.T[cur].size()==1 and sigma.T[cur][0].to==par){\n            return sugim.dist(cur,y);\n        }\n        int ret=sugim.dist(cur,y);\n        for(auto e: sigma.T[cur]){\n            if(e.to!=par){\n                if(sugim.dist(cur,e.to)>=3) return INF;\n                ret=max(ret,dfs(cur,e.to));\n            }\n        }\n        return ret;\n    }\n\n    void solve(){\n        cin >> x >> y;\n        --x;--y;\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            sigma.T[a].push_back(Edge(a,b));\n            sigma.T[b].push_back(Edge(b,a));\n        }\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            sugim.T[a].push_back(Edge(a,b));\n            sugim.T[b].push_back(Edge(b,a));\n        }\n        sigma.calc(x);\n        sugim.calc(y);\n        int ans=dfs(-1,x);\n        if(ans==INF)cout << -1 <<\"\\n\";\n        else cout << ans*2<<\"\\n\";\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    Problem e(n);\n    e.solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define maxn 400001\nusing namespace std;\nint nt1[maxn], go1[maxn], fi1[maxn], ff[maxn][21];\nint nt2[maxn], go2[maxn], fi2[maxn], cnt;\nint dep[maxn], f[maxn], n, s, t, ans = -1;\nvector <int> Q[maxn];\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nvoid add1(int x, int y){\n    nt1[++cnt] = fi1[x]; fi1[x] = cnt; go1[cnt] = y;\n}\nvoid add2(int x, int y){\n    nt2[++cnt] = fi2[x]; fi2[x] = cnt; go2[cnt] = y;\n}   \nvoid DFS2(int x, int fa){\n    //cout << x << endl;\n    dep[x] = dep[fa] + 1; f[x] = fa;\n    ff[x][0] = fa;\n    for(int i = 1; i <= 20; i++)\n        ff[x][i] = ff[ff[x][i - 1]][i - 1];\n    for(int i = fi2[x]; i; i = nt2[i]){\n        int v = go2[i]; if(v == fa) continue;\n        DFS2(v, x); Q[x].push_back(v);\n    }\n    sort(Q[x].begin(), Q[x].end());\n}\nint lca(int u, int v)\n{\n    if(dep[u] < dep[v]) swap(u, v);\n    for(int i = 20; i >= 0; i--)\n        if(dep[ff[u][i]] >= dep[v]) u = ff[u][i];\n    if(u == v) return u;\n    for(int i = 20; i >= 0; i--)\n    {\n        if(ff[u][i] != ff[v][i]) {\n            u = ff[u][i]; v = ff[v][i];\n        }\n    }\n    return ff[u][0];\n}\nint get_dis(int x, int y){\n    return dep[x] + dep[y] - dep[lca(x, y)] * 2;\n}\nvoid DFS1(int x, int fa, int h){\n    bool flag = true, t = false;\n    int siz = Q[h].size();\n    for(int i = fi1[x]; i; i = nt1[i]){\n        int v = go1[i]; if(v == fa) continue;\n        if(get_dis(x, v) >= 3) { flag = false; break;}\n        int now = lower_bound(Q[h].begin(), Q[h].end(), x) - Q[h].begin();\n        if(now < siz && Q[h][now] == v) continue;\n        if(v == f[h] || v == h) continue; \n        t = true; DFS1(v, x, f[v]); \n    }\n    if(!flag) {printf(\"-1\\n\"); exit(0);}\n    if(!t) ans = max(ans, dep[h]); \n}\n\nint main(){\n    //freopen(\"giri1.in\", \"r\", stdin);\n    n = read(); s = read(); t = read();\n    for(int i = 1; i < n; i++){\n        int x = read(), y = read();\n        add1(x, y); add1(y, x);\n    }\n    cnt = 0;\n    for(int i = 1; i < n; i++){\n        int x = read(), y = read();\n        add2(x, y); add2(y, x);\n    }\n    DFS2(t, 0); //cout << t << endl;\n    int u = f[s]; DFS1(s, 0, u);\n    if(ans != -1) ans <<= 1; \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 200000 + 5;\n\nint N;\nvector <int> tomTree[NMAX];\nvector <int> jerryTree[NMAX];\n\nint tomCnt;\nint tomH[NMAX];\nint tomFather[NMAX];\nint tomFirst[NMAX];\nint tomLast[NMAX];\n\nvoid dfsPrepareTomTree(int node) {\n    tomFirst[node] = ++tomCnt;\n    if (tomFather[node])\n        tomTree[node].erase(find(tomTree[node].begin(), tomTree[node].end(), tomFather[node]));\n    for (auto it: tomTree[node]) {\n        tomH[it] = 1 + tomH[node];\n        tomFather[it] = node;\n        dfsPrepareTomTree(it);  \n    }\n    tomLast[node] = tomCnt;\n}\n\nint moveCloser(int t, int j) {\n    if (t == j) // No need to move\n        return t;\n    else if (tomFirst[t] <= tomFirst[j] && tomFirst[j] <= tomLast[t]) { // Move in a son\n        int st = 1, dr = tomTree[t].size() - 1;\n        int ans = 0;\n        while (st <= dr) {\n            int mid = (st + dr) >> 1;\n            if (tomFirst[tomTree[t][mid]] <= tomFirst[j])\n                ans = mid, st = mid + 1;\n            else\n                dr = mid - 1;\n        }\n        return tomTree[t][ans];\n    }\n    else // Move in the father\n        return tomFather[t];\n}\n\nint getDist(int a, int b) {\n    int ans = 0;\n    while (a != b) {\n        if (tomH[a] < tomH[b])\n            swap(a, b);\n        ++ ans;\n        if (ans == 3)\n            break;\n        a = tomFather[a];\n    }\n    return ans;\n}\n\nconst int INF = 2E9 + 256;\nbool easyWinJerry[NMAX];\n\nbool jerryVis[NMAX];\nint play(int t, int j) { // Jerry moves\n    if (t == j)\n        return 0;\n    if (easyWinJerry[j])\n        return INF;\n    jerryVis[j] = true;\n\n    int longest = 2 + play(moveCloser(t, j), j);\n    for (auto it: jerryTree[j])\n        if (!jerryVis[it])\n            longest = max(longest, 2 + play(moveCloser(t, it), it));\n    jerryVis[j] = false;\n    return longest;\n}\n\nint main() {\n    //freopen(\"data.in\", \"r\", stdin);\n    ios_base :: sync_with_stdio(false);\n\n    int t, j;\n    cin >> N >> j >> t;\n    for (int i = 1; i < N; ++ i) {\n        int a, b;\n        cin >> a >> b;\n        jerryTree[a].push_back(b);\n        jerryTree[b].push_back(a);\n    }\n    for (int i = 1; i < N; ++ i) {\n        int a, b;\n        cin >> a >> b;\n        tomTree[a].push_back(b);\n        tomTree[b].push_back(a);\n    }\n    dfsPrepareTomTree(t);\n\n    for (int i = 1; i <= N; ++ i)\n        for (auto it: jerryTree[i]) {\n            int d = getDist(i, it);\n            if (d >= 3)\n                easyWinJerry[i] = easyWinJerry[it] = true;\n        }\n\n    int ans = play(t, j);\n    if (ans >= INF)\n        cout << \"-1\\n\";\n    else\n        cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N * 2 , inf = 1e9 + 7;\nusing namespace std ;\n\nbool vis[N], path[N] ;\nint n, rt, S, e, ter[M], nxt[M], lnk[N], dep[N], fa[N], ans ;\nstruct edge {\n\tint x, y ;\n} ed[N] ;\n\nvoid add(int x, int y) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e ;\n}\n\nvoid dfs(int p, int las) {\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) {\n\t\tdep[ter[i]] = dep[p] + 1 ;\n\t\tfa[ter[i]] = p ;\n\t\tdfs(ter[i], p) ;\n\t}\n}\n\nvoid dfs2(int p, int las, int len) {\n\tif (ans == inf) return ;\n\tif (dep[p] < len) {\n\t\tans = max(ans, (len - 1) * 2 + 1) ;\n\t\treturn ;\n\t}\n\tif (dep[p] == len) {\n\t\tans = max(ans, len * 2) ;\n\t\treturn ;\n\t}\n\tif (vis[p]) {\n\t\tans = inf ;\n\t\treturn ;\n\t}\n\tdfs2(p, las, len + 1) ;\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) dfs2(ter[i], p, len + 1) ;\n}\n\nbool chk(int x, int y) {\n\tif (dep[x] < dep[y]) swap(x, y) ;\n\tif (fa[x] == y) return false ;\n\tif (fa[fa[x]] == y) return false ;\n\tif (fa[x] == fa[y]) return false ;\n\treturn true ;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &S, &rt) ;\n\trep(i, 1, n - 1) scanf(\"%d%d\", &ed[i].x, &ed[i].y) ;\n\tint x, y ;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &x, &y) ;\n\t\tadd(x, y), add(y, x) ;\n\t}\n\tdfs(rt, 0) ;\n\trep(i, 1, n - 1) if (chk(ed[i].x, ed[i].y)) vis[ed[i].x] = vis[ed[i].y] = true ;\n\trep(i, 1, n) lnk[i] = 0 ;\n\trep(i, 1, e) nxt[i] = 0 ; e = 0 ;\n\trep(i, 1, n - 1) add(ed[i].x, ed[i].y), add(ed[i].y, ed[i].x) ;\n\tdfs2(S, 0, 0) ;\n\tif (ans == (int) (1e9 + 7)) {\n\t\tprintf(\"-1\\n\") ;\n\t} else printf(\"%d\\n\", ans) ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#define SF scanf\n#define PF printf\n#define MAXN 200010\nusing namespace std;\nint n,x,y;\nvector<int> a[MAXN],b[MAXN];\npair<int,int> l[MAXN];\nint depA[MAXN],depB[MAXN];\nint fa[MAXN][21];\nvoid dfsA(int x,int f){\n\tdepA[x]=depA[f]+1;\n\tfor(int i=0;i<a[x].size();i++){\n\t\tint u=a[x][i];\n\t\tif(u==f)\n\t\t\tcontinue;\n\t\tdfsA(u,x);\t\n\t}\n}\nvoid dfsB(int x,int f){\n\tdepB[x]=depB[f]+1;\n\tfa[x][0]=f;\n\tfor(int i=1;i<20;i++)\n\t\tfa[x][i]=fa[fa[x][i-1]][i-1];\n\tfor(int i=0;i<b[x].size();i++){\n\t\tint u=b[x][i];\n\t\tif(u==f)\n\t\t\tcontinue;\n\t\tdfsB(u,x);\n\t}\n}\nint lca(int u,int v){\n\tif(depB[u]<depB[v])\n\t\tswap(u,v);\n\tfor(int i=19;i>=0;i--)\n\t\tif(depB[fa[u][i]]>=depB[v])\n\t\t\tu=fa[u][i];\n\tif(u==v)\n\t\treturn u;\n\tfor(int i=19;i>=0;i--)\n\t\tif(fa[u][i]!=fa[v][i]){\n\t\t\tu=fa[u][i];\n\t\t\tv=fa[v][i];\t\n\t\t}\n\treturn fa[u][0];\n}\nint ans;\nvoid dfs(int x,int f){\n\tif(depA[x]>=depB[x])\n\t\treturn ;\n\tif(ans!=-1)\n\t\tans=max(ans,(depB[x]-1)*2);\n\tfor(int i=0;i<a[x].size();i++){\n\t\tint u=a[x][i];\n\t\tif(u==f)\n\t\t\tcontinue;\n\t\tif(depB[u]+depB[x]-2*depB[lca(u,x)]>2)\n\t\t\tans=-1;\t\n\t\tdfs(u,x);\t\n\t}\n}\nint main(){\n\twhile(SF(\"%d%d%d\",&n,&x,&y)!=EOF){\n\t\tint u,v;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tSF(\"%d%d\",&u,&v);\n\t\t\tl[i]=make_pair(u,v);\n\t\t\ta[u].push_back(v);\n\t\t\ta[v].push_back(u);\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tSF(\"%d%d\",&u,&v);\n\t\t\tb[u].push_back(v);\n\t\t\tb[v].push_back(u);\t\n\t\t}\n\t\tdfsA(x,0);\n\t\tdfsB(y,0);\n\t\tans=0;\n\t\tdfs(x,0);\n\t\tPF(\"%d\\n\",ans);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i].clear();\n\t\t\tb[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define per(i, a, b) for(int i=(b)-1; i>=(a); i--)\n#define sz(a) (int)a.size()\n#define de(a) cout << #a << \" = \" << a << endl\n#define dd(a) cout << #a << \" = \" << a << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef double db;\n\nvoid file_put() {\n    freopen(\"filename.in\", \"r\", stdin);\n    freopen(\"filename.out\", \"w\", stdout);\n}\n\nconst int N=2e5+5;\nint n,X,Y,d[N],f[N],ret=0,x,y; vi R[N],B[N];\n\nbool check(int x,int y) {\n\tif (!y) return 1;\n\tif (f[x]==y || f[y]==x) return 1;\n\tif (f[f[x]]==y || f[f[y]]==x) return 1;\n\treturn f[x]==f[y];\n}\n\nvoid dfs(int x,int p) {\n\td[x]=d[p]+1,f[x]=p;\n\tfor (auto y: B[x]) if (y!=p) dfs(y,x);\n}\n\nvoid dfs(int x,int p,int k) {\n\tret=max(ret,d[x]);\n\tfor (auto y: R[x]) if (y!=p) {\n\t\tif (!check(x,y)) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tif (d[y]>k+1) dfs(y,x,k+1);\n\t}\n}\n\nint main() {\n//\tfile_put();\n\t\n\tscanf(\"%d%d%d\",&n,&X,&Y),d[0]=-1;\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),R[x].pb(y),R[y].pb(x);\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),B[x].pb(y),B[y].pb(x);\n\tdfs(Y,0),dfs(X,0,0);\n\tprintf(\"%d\\n\",ret<<1);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nint n,X,Y,Dep[N],vis[N],ans;\n\nstruct graph{\n\tstruct edge{int s,t,n;}e[4*N];\n\tint h[N],f[N][20],dep[N];\n\n\tvoid dfs1(int x,int fa)\n\t{\n\t\tf[x][0]=fa,dep[x]=dep[fa]+1;\n\t\tfor (int i=1; i<20; i++)  f[x][i]=f[f[x][i-1]][i-1];\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)  if (y!=fa)  dfs1(y,x);\n\t}\n\n\tvoid init()\n\t{\n\t\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t\t}\n\t\tdfs1(1,0);\n\t}\t\n\n\tint dis(int x,int y)\n\t{\n\t\tint s=0;\n\t\tif (dep[x]>dep[y])  swap(x,y);\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (dep[f[y][i]]>=dep[x])\n\t\t\t\ty=f[y][i],s+=1<<i;\n\t\tif (x==y)  return s;\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (f[x][i]!=f[y][i])\n\t\t\t\tx=f[x][i],y=f[y][i],s+=2<<i;\n\t\treturn s+2;\n\t}\n\n\tbool dfs2(int x,int f)\n\t{\n\t\tint _=(x==X);\n\t\tDep[x]=Dep[f]+1,vis[x]=vis[0];\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((y!=f)&&(dfs2(y,x)))  _=1;\n\t\treturn _;\n\t}\n\n\tvoid mark()\n\t{\n\t\tfor (int i=h[Y],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif (vis[0]++,dfs2(y,Y))  return;\n\t}\n\n\tvoid dfs3(int x)\n\t{\n\t\tans=max(ans,Dep[x]),vis[x]++;\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif (vis[y]==vis[0])  dfs3(y);\n\t}\n}A,B;\n\nvoid work()\n{\n\tscanf(\"%d %d %d\",&n,&X,&Y);\n\tA.init(),B.init(),B.mark(),A.dfs3(X);\n\tfor (int i=2; i<2*n; i+=2)\n\t\tif ((vis[A.e[i].s]>vis[0])||(vis[A.e[i].t]>vis[0]))\n\t\t\tif (B.dis(A.e[i].s,A.e[i].t)>2)\n\t\t\t\tputs(\"-1\"),exit(0);\n\tprintf(\"%d\",2*ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint ans, N, X, Y, niv[200009], t[200009], dp[200009];\nbool safe[200009];\nvector < int > red[200009], blue[200009];\nqueue < int > cc;\n\nvoid dfsBlue (int nod, int tata)\n{\n    t[nod] = tata;\n    for (auto it = blue[nod].begin (); it != blue[nod].end (); it ++)\n        if (*it != tata)\n            niv[*it] = niv[nod] + 1, dfsBlue (*it, nod);\n}\n\nbool atMost2BlueD (int x, int y) {return (t[x] == t[y] || x == t[y] || y == t[x] || x == t[t[y]] || y == t[t[x]]);}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d %d\\n\", &N, &X, &Y);\nfor (int i=1; i<N; i++)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y);\n    red[x].push_back (y);\n    red[y].push_back (x);\n}\nfor (int i=1; i<N; i++)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y);\n    blue[x].push_back (y);\n    blue[y].push_back (x);\n}\ndfsBlue (Y, -1);\nfor (int i=1; i<=N; i++)\n    for (auto it = red[i].begin (); it != red[i].end (); it ++)\n        if (!atMost2BlueD (i, *it))\n            safe[i] = safe[*it] = 1;\nif (safe[X])\n{\n    printf (\"-1\\n\");\n    return 0;\n}\nfor (int i=1; i<=N; i++)\n    dp[i] = N + 2;\ndp[X] = 0, cc.push (X), ans = niv[X];\nwhile (!cc.empty ())\n{\n    int nod = cc.front ();\n    cc.pop ();\n    if (dp[nod] >= niv[nod]) continue;\n    if (niv[nod] > ans) ans = niv[nod];\n    if (safe[nod])\n    {\n        printf (\"-1\\n\");///Escape\n        return 0;\n    }\n    for (auto it = red[nod].begin (); it != red[nod].end (); it ++)\n        if (dp[*it] > dp[nod] + 1 && atMost2BlueD (nod, *it))\n            dp[*it] = dp[nod] + 1, cc.push (*it);\n}\nprintf (\"%d\\n\", 2 * ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N=2e5+10;\nstruct Tree\n{\n\tstruct edge{int next,to;}a[N<<1];\n\tint head[N],cnt;\n\tvoid link(int x,int y)\n\t\t{\n\t\t\ta[++cnt]=(edge){head[x],y};head[x]=cnt;\n\t\t\ta[++cnt]=(edge){head[y],x};head[y]=cnt;\n\t\t}\n}A,B;\nint n,p1,p2,dep[N],dis[N],fr[N],vis[N],ans;\nqueue<int> Q;\nvoid bfs1()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tif(dep[p1]) Q.push(p1);dis[p1]=0;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();vis[x]=1;\n\t\tfor(int i=A.head[x];i;i=A.a[i].next)\n\t\t{\n\t\t\tint R=A.a[i].to;\n\t\t\tif(dis[R]==-1)\n\t\t\t{\n\t\t\t\tdis[R]=dis[x]+1;\n\t\t\t\tif(dis[R]<dep[R]) Q.push(R);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bfs2()\n{\n\tmemset(dep,-1,sizeof(dep));\n\tQ.push(p2);dep[p2]=0;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=B.head[x];i;i=B.a[i].next)\n\t\t{\n\t\t\tint R=B.a[i].to;\n\t\t\tif(dep[R]==-1) dep[R]=dep[x]+1,fr[R]=x,Q.push(R);\n\t\t}\n\t}\n}\nint Dis(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tif(fr[x]==fr[y]||x==y||fr[x]==y) return 0;\n\tif(fr[fr[x]]==y) return 0;\n\treturn 1;\n}\nint main()\n{\n\tcin>>n>>p1>>p2;\n\tfor(int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),A.link(x,y);\n\tfor(int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),B.link(x,y);\n\tbfs2();bfs1();\n//\tfor(int i=1;i<=n;i++) printf(\"dep[%d]=%d,dis[%d]=%d,fr[%d]=%d\\n\",i,dep[i],i,dis[i],i,fr[i]);\n\tfor(int x=1;x<=n;x++)\n\t\tfor(int i=A.head[x];i;i=A.a[i].next)\n\t\t\tif(vis[x]&&vis[A.a[i].to]&&Dis(x,A.a[i].to))\n\t\t\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;i++) if(vis[i]) ans=max(dep[i],ans);\n\tcout<<ans*2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX_LG = 20;\nconst int MAX_N = 2e5 + 5;\nconst int INF = 1e9 + 5;\n\nnamespace Ender {\n  vector<int> adj [MAX_N];\n  int par [MAX_N];\n  int lvl [MAX_N];\n  int lend [MAX_N], rend [MAX_N];\n  int jmp [MAX_N][MAX_LG];\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  int lca (int u, int v) {\n    if (lvl[u] < lvl[v]) swap(u, v);\n\n    int diff = lvl[u] - lvl[v];\n    for (int i = 0; i < MAX_LG; i++) {\n      if (diff & 1 << i) {\n        u = jmp[u][i];\n      }\n    }\n\n    if (u == v) return u;\n\n    for (int i = MAX_LG - 1; i >= 0; i--) {\n      if (jmp[u][i] != jmp[v][i]) {\n        u = jmp[u][i];\n        v = jmp[v][i];\n      }\n    }\n    return jmp[u][0];\n  }\n\n  int dist (int u, int v) {\n    return lvl[u] + lvl[v] - 2 * lvl[lca(u, v)];\n  }\n  \n  void dfs (int u, int p, int &cur) {\n    jmp[u][0] = p;\n    for (int i = 1; i < MAX_LG; i++) {\n      jmp[u][i] = jmp[jmp[u][i - 1]][i - 1];\n    }\n    \n    cur++;\n    lend[u] = cur;\n    lvl[u] = lvl[p] + 1;\n    par[u] = p;\n\n    for (int nxt : adj[u]) {\n      if (nxt != p) {\n        dfs(nxt, u, cur);\n      }\n    }\n    \n    rend[u] = cur;\n  }\n  \n  void build () {\n    int cur = 0;\n    dfs(1, 0, cur);\n  }\n  \n  bool islong (int u, int v) {\n    if (u == v) return false; // dist 0\n    if (par[u] == v || par[v] == u) return false; // dist 1\n    if (par[par[u]] == v || par[par[v]] == u) return false; // dist 2, grandparent\n    if (par[u] == par[v]) return false; // dist 2, cousin\n    return true;\n  }\n\n  int towards (int cur, int tar) {\n    if (cur == tar) return cur;\n    if (lend[tar] < lend[cur] || rend[cur] < lend[tar]) return par[cur];\n    for (int nxt : adj[cur]) {\n      if (nxt != par[cur]) {\n        if (lend[nxt] <= lend[tar] && rend[tar] <= rend[nxt]) {\n          return nxt;\n        }\n      }\n    }\n    assert(false);\n  }\n}\n\nnamespace Delayer {\n  vector<int> adj [MAX_N];\n  int special [MAX_N];\n  \n  vector<pair<int, int>> edges;\n  \n  void add_edge (int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n    edges.push_back(make_pair(u, v));\n  }\n\n  void build () {\n    for (auto pr : edges) {\n      if (Ender::islong(pr.first, pr.second)) {\n        special[pr.first] = 1;\n        special[pr.second] = 1;\n      }\n    }\n  }\n}\n\nint dpt = 0;\nint play (int d, int dl, int e) {\n  /*\n  for (int i = 0; i < 2 * dpt; i++) {\n    cout << \" \";\n  }\n  cout << d << \" \" << e << endl;\n  */\n  \n  if (e == d) return 0;\n  if (Delayer::special[d]) return INF;\n  \n  int ans = 2 * Ender::dist(d, e);\n  for (int nxt : Delayer::adj[d]) {\n    if (nxt != dl) {\n      dpt += 2;\n      ans = max(ans, 2 + play(nxt, d, Ender::towards(e, nxt)));\n      dpt -= 2;\n    }\n  }\n  return ans;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n  \n  int n, x, y;\n  cin >> n >> x >> y;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Delayer::add_edge(u, v);\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    Ender::add_edge(u, v);\n  }\n\n  Ender::build();\n  Delayer::build();\n\n  int ans = play(x, -1, y);\n  if (ans >= INF) {\n    cout << -1 << endl;\n  } else {\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\nconst int N=2e5+3,K=18;\nstd::vector<int>g1[N],g2[N];\nint n,rt1,rt2,d1[N],d2[N],fa[N][K],ans;\ninline int Lca(int u,int v){\n\tif(d2[u]<d2[v])std::swap(u,v);\n\tfor(int j=K-1;~j;j--)if(d2[fa[u][j]]>=d2[v])\n\t  u=fa[u][j];\n\tif(u==v)return u;\n\tfor(int j=K-1;~j;j--)if(fa[u][j]!=fa[v][j])\n\t  u=fa[u][j],v=fa[v][j];\n\treturn fa[u][0];\n}\nvoid Dfs2(int u){\n\tint v;\n\tfor(int j=1;j<K;j++)fa[u][j]=fa[fa[u][j-1]][j-1];\n\tfor(int i=0;i<g2[u].size();i++)if((v=g2[u][i])!=fa[u][0])\n\t  d2[v]=d2[u]+1,fa[v][0]=u,Dfs2(v);\n}\nvoid Dfs1(int u,int fa){\n\tint v;\n\tif(d1[u]>=d2[u])return;\n\tfor(int i=0;i<g1[u].size();i++){\n\t  v=g1[u][i];\n\t  if(d2[u]+d2[v]-2*d2[Lca(u,v)]>2)exit(0*puts(\"-1\"));\n\t}\n\tans=std::max(ans,d2[u]);\n\tfor(int i=0;i<g1[u].size();i++)if((v=g1[u][i])!=fa)\n\t  d1[v]=d1[u]+1,Dfs1(v,u);\n}\nint main(){\n\tint u,v;\n\tscanf(\"%d%d%d\",&n,&rt1,&rt2);\n\tfor(int i=1;i<n;i++)\n\t  scanf(\"%d%d\",&u,&v),g1[u].push_back(v),g1[v].push_back(u);\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&u,&v),g2[u].push_back(v),g2[v].push_back(u);\n\tDfs2(rt2);\n\tDfs1(rt1,0);\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nstd::vector<int> adj_r[200005], adj_b[200005];\nint pa[200005], dep[200005], ans;\nvoid init(int u, int fa = -1)\n{\n\tpa[u] = fa;\n\tfor (int v : adj_b[u])\n\t{\n\t\tif (v != fa)\n\t\t{\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tinit(v, u);\n\t\t}\n\t}\n}\ninline bool chk(int u, int v)\n{\n\tif (dep[u] < dep[v])\n\t\tstd::swap(u, v);\n\tfor (int i = 0; i < 2 && u != v; i++)\n\t{\n\t\tif (dep[u] < dep[v])\n\t\t\tv = pa[v];\n\t\telse\n\t\t\tu = pa[u];\n\t}\n\treturn u == v;\n}\nvoid dfs(int u, int len = 0, int fa = -1)\n{\n\tans = std::max(ans, dep[u]);\n\tif (dep[u] <= len)\n\t\treturn;\n\tfor (int v : adj_r[u])\n\t{\n\t\tif (v == fa)\n\t\t\tcontinue;\n\t\tif (!chk(u, v))\n\t\t\tthrow false;\n\t\tdfs(v, len + 1, u);\n\t}\n}\nint main()\n{\n\tint n, x, y;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadj_r[--u].pb(--v);\n\t\tadj_r[v].pb(u);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadj_b[--u].pb(--v);\n\t\tadj_b[v].pb(u);\n\t}\n\tinit(--y);\n\ttry\n\t{\n\t\tdfs(--x);\n\t\tprintf(\"%d\\n\", ans << 1);\n\t}\n\tcatch (...)\n\t{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define iter(i, n) for (int i = 1; i <= n; ++i)\n#define iter_d0(i, n) for (int i = n - 1; i >= 0; --i)\n\nconst int inf = 1e9;\nconst int NR = 2e5 + 10;\n\nint n, X, Y, xa[NR], ya[NR], fa[NR], f[NR][20], dep[NR];\nvector<int> Ta[NR], Tb[NR];\n\nvoid dfs(int x) {\n\tf[x][0] = fa[x];\n\tfor (int i = 1; (1 << i) <= dep[x]; ++i)\n\t\tf[x][i] = f[f[x][i - 1]][i - 1];\n\tfor (int v : Tb[x]) if (v != fa[x]) {\n\t\tfa[v] = x, dep[v] = dep[x] + 1, dfs(v);\n\t}\n}\n\nint lca(int x, int y) {\n\tif (dep[x] < dep[y]) swap(x, y);\n\titer_d0(i, 20) if (dep[f[x][i]] >= dep[y]) x = f[x][i];\n\tif (x == y) return x;\n\titer_d0(i, 20) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];\n\treturn fa[x];\n}\n\nint dist(int x, int y) {\n\treturn dep[x] + dep[y] - 2 * dep[lca(x, y)];\n}\n\nint getans(int x, int fa, int d) {\n\tint res = dist(x, Y); //printf(\"!!%d\\n\", x);\n\tfor (int v : Ta[x]) if (v != fa) {\n\t\t//printf(\"!%d %d\\n\", v, dist(v, Y));\n\t\tif (dist(x, v) >= 3) return inf;\n\t\tif (dep[v] > d + 1)\n\t\t\tres = max(res, getans(v, x, d + 1));\n\t}\n\treturn res;\n}\n\nint main() {\n\t//freopen(\"5E.in\", \"r\", stdin);\n\tscanf(\"%d%d%d\", &n, &X, &Y); dep[0] = -1;\n\titer(i, n - 1) {\n\t\tscanf(\"%d%d\", &xa[i], &ya[i]);\n\t\tTa[xa[i]].push_back(ya[i]);\n\t\tTa[ya[i]].push_back(xa[i]);\n\t}\n\titer(i, n - 1) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tTb[x].push_back(y);\n\t\tTb[y].push_back(x);\n\t}\n\n\tdfs(Y);\n\tint tmp = getans(X, 0, 0);\n\tprintf(\"%d\\n\", tmp == inf ? -1 : 2 * tmp);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nconst int N=2e5+5;\nint n;\n\ntemplate <class T> inline void apx(T &x,const T y){\n\tif(x<y) x=y;\n}\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=getchar())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\treturn x;\n}\n\nnamespace G{\n\tint st_f,st_s,dep[N],xdis;\n\tint fa[N],sz[N],son[N],top[N];\n\tstd::vector <int> vf[N],vs[N];\n\n\tinline int get_lca(int x,int y){\n\t\twhile(top[x]!=top[y]){\n\t\t\tdep[top[x]]>dep[top[y]]?x=fa[top[x]]:y=fa[top[y]];\n\t\t}\n\t\treturn dep[x]<dep[y]?x:y;\n\t}\n\n\tinline int get_dis(const int x,const int y){\n\t\treturn dep[x]+dep[y]-(dep[get_lca(x,y)]<<1);\n\t}\n\n\tvoid dfs_sz(const int x){\n\t\tsz[x]=1;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!sz[*it]){\n\t\t\t\tdep[*it]=dep[x]+1;\n\t\t\t\tfa[*it]=x;\n\t\t\t\tdfs_sz(*it);\n\t\t\t\tif(sz[*it]>sz[son[x]]) son[x]=*it;\n\t\t\t\tsz[x]+=sz[*it];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs_top(const int x){\n\t\ttop[x]=son[fa[x]]==x?top[fa[x]]:x;\n\t\tfor(std::vector <int> ::iterator it=vs[x].begin(); it!=vs[x].end(); ++it){\n\t\t\tif(!top[*it]) dfs_top(*it);\n\t\t}\n\t}\n\n\tbool dfs_free(const int x,const int fa,const int dis){\n\t\tstd::vector <int> ::iterator it;\n\t\tif(dis<dep[x]){\n\t\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\t\tif(get_dis(x,*it)>2) return 1;\n\t\t\t}\n\t\t}\n\t\tfor(it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(*it!=fa){\n\t\t\t\tif(dfs_free(*it,x,dis+1)) return 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid dfs_xdis(const int x,const int fa,const int dis){\n\t\tapx(xdis,dep[x]);\n\t\tfor(std::vector <int> ::iterator it=vf[x].begin(); it!=vf[x].end(); ++it){\n\t\t\tif(*it==fa) continue;\n\t\t\tif(dis+1==dep[*it]) apx(xdis,dis+1);\n\t\t\tif(dis+1<dep[*it]){\n\t\t\t\tdfs_xdis(*it,x,dis+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tn=nxi();\n\tG::st_f=nxi(),G::st_s=nxi();\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vf[x].push_back(y);\n\t\tG::vf[y].push_back(x);\n\t}\n\tfor(int i=1; i<n; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tG::vs[x].push_back(y);\n\t\tG::vs[y].push_back(x);\n\t}\n\tG::dfs_sz(G::st_s);\n\tG::dfs_top(G::st_s);\n\tif(G::dfs_free(G::st_f,0,0)){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tG::dfs_xdis(G::st_f,0,0);\n\tprintf(\"%d\\n\",G::xdis<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define edge(j) for (j=fst[x];j;j=nxt[j])\nusing namespace std;\nconst int N=2e5+5;\nint n,x,y,i,u,v,ans,mode;\nint En,fst[N],Fa[N],nxt[N*2],to[N*2];\nint U[N],V[N],A[N],B[N];\nvoid File()\n{\n\tfreopen(\"game.in\",\"r\",stdin);\n\tfreopen(\"game.out\",\"w\",stdout);\n}\nvoid add(int u,int v) {\n\tEn++; nxt[En]=fst[u]; fst[u]=En; to[En]=v;\n}\nvoid dfs(int x,int fa,int step,int *A)\n{\n\tint j,v;\n\tif (mode==1 && x==y) return ;\n\tA[x]=step; Fa[x]=fa;\n\tedge(j)\n\t{\n\t\tv=to[j];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x,step+1,A);\n\t}\n}\nvoid Init()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t\tU[i]=u; V[i]=v;\n\t}\n\trep(i,1,n) A[i]=B[i]=n+1;\n\tmode=1; dfs(x,x,0,A);\n\tmemset(fst,0,sizeof(fst));\n\tEn=0;\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\t\t\n\t}\n\tmode=2; dfs(y,y,0,B);\n}\nvoid Solve()\n{\n\trep(i,1,n-1)\n\t{\n\t\tif (Fa[U[i]]==V[i] || Fa[V[i]]==U[i]) continue;\n\t\tif (Fa[U[i]]==Fa[V[i]] || Fa[Fa[U[i]]]==V[i] || Fa[Fa[V[i]]]==U[i]) continue;\n\t\tif (A[U[i]]<B[U[i]] || A[V[i]]<B[V[i]])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn ;\n\t\t}\n\t}\n\trep(i,1,n)\n\t\tif (A[i]<B[i])\n\t\t\tans=max(ans,B[i]);\n\tans*=2;\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n//\tFile();\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int lg = 20;\nvector<int> red[N];\nvector<int> blue[N];\nint h[N];\nint par[lg + 5][N];\nint n, x, y;\nbool winPos[N];\nint disR[N];\nint disB[N];\n\n\nvoid dfs(int v = 0, int p = -1)\n{\n    for (int u : blue[v])\n    {\n        if (u != p)\n        {\n            par[0][u] = v;\n            h[u] = h[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nvoid pre()\n{\n    for (int k = 1; k < lg; k++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            par[k][i] = par[k - 1][ par[k - 1][i] ];\n        }\n    }\n}\n\nint lca(int v, int u)\n{\n    if(h[v] > h[u])\n    {\n        swap(v, u);\n    }\n    for (int i = 0; i < lg; i++)\n    {\n        if (h[u] - h[v] >> i & 1)\n        {\n            u = par[i][u];\n        }\n    }\n    for (int i = lg - 1; i >= 0; i--)\n    {\n        if(par[i][v] != par[i][u])\n        {\n            v = par[i][v], u = par[i][u];\n        }\n    }\n    return v == u ? v : par[0][v];\n}\n\nvoid dfs1(int v, int par = -1)\n{\n    if (disR[v] >= disB[v])\n    {\n        return;\n    }\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disR[u] = disR[v] + 1;\n            dfs1(u, v);\n        }\n    }\n}\n\nvoid dfs2(int v, int par = -1)\n{\n    for (auto u: blue[v])\n    {\n        if (u != par)\n        {\n            disB[u] = disB[v] + 1;\n            dfs2(u, v);\n        }\n    }\n}\n\n\n\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        red[u - 1].push_back(v - 1);\n        red[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        blue[u - 1].push_back(v - 1);\n        blue[v - 1].push_back(u - 1);\n    }\n    dfs();\n    pre();\n    for (int i = 0; i < n; i++)\n    {\n        for (auto u: red[i])\n        {\n            int tmp = lca(u, i);\n            if (h[u] - h[tmp] + h[i] - h[tmp] > 2)\n            {\n                winPos[i] = true;\n                winPos[u] = true;\n            }\n        }\n    }\n    memset(disR, 127, sizeof disR);\n    disR[x - 1] = 0;\n    dfs2(y - 1);\n    dfs1(x - 1);\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (winPos[i] && disR[i] <= disB[i])\n        {\n            assert(1 == 1);\n            cout << -1 << endl;\n            exit(0);\n        }\n        if (disR[i] < N)\n        {\n            //cout << endl;\n            //cout << i << \" \" << disB[i] << endl;\n            ans = max(ans, disB[i] * 2);\n        }\n    }\n    //cout << (1 << 20) << endl;\n    cout << ans << endl;\n\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 2e5+5;\n\nint n, da[MAXN], db[MAXN], x, y;\nvector<int> a[MAXN], b[MAXN];\nint ans = 0;\nmap<pii, int> m;\nbool s[MAXN];\n\nvoid compdb(int v, int f = -1) {\n    if (f == -1)\n        db[v] = 0;\n    else\n        db[v] = db[f]+1;\n\n    for (int u : b[v])\n        if (u != f)\n            compdb(u, v);\n}\n\nvoid dfs(int v, int f = -1) {\n    if (f == -1)\n        da[v] = 0;\n    else\n        da[v] = da[f] + 1;\n    if (da[v] > db[v])\n        return;\n    if (s[v]) {\n        cout << \"-1\\n\";\n        exit(0);\n    }\n\n    ans = max(ans, db[v]);\n    for (int u : a[v])\n        if (u != f)\n            dfs(u, v);\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    cin >> n >> x >> y;\n    x--; y--;\n    for (int i = 0; i < n-1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n\n    for (int i = 0; i < n-1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        b[u].push_back(v);\n        b[v].push_back(u);\n        m[pii(u, v)] = m[pii(v, u)] = 1;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int v : a[i]) {\n            bool z = 1;\n            if (b[i].size() > b[v].size())\n                continue;\n            if (m.count(pii(i, v)) > 0)\n                z = 0;\n            for (int u : b[i])\n                if (m.count(pii(u, v)) > 0)\n                    z = 0;\n            s[i] |= z;\n            s[v] |= z;\n        }\n    }\n\n    compdb(y);\n    dfs(x);\n\n    cout << 2*ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e5+5;\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<2];\nint ha[N], hb[N], tot;\nvoid _add(int *h, int x, int y) { edge[++tot] = Edge(h[x], y); h[x] = tot; }\nvoid add(int *h, int x, int y) { _add(h, x, y); _add(h, y, x); }\nint fa[N], son[N], size[N], top[N], d[N];\nint ans, cir;\nvoid dfs(int x)\n{\n    size[x] = 1;\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; if(y == fa[x]) continue;\n        d[y] = d[x]+1, fa[y] = x, dfs(y), \n        size[x] += size[y], son[x] = size[son[x]]>size[y]?son[x]:y; \n    }\n}\nint lca(int x, int y)\n{\n    while(top[x] != top[y])\n    {\n        if(d[top[x]] < d[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint dis(int x, int y) { return d[x]+d[y]-2*d[lca(x, y)]; }\nvoid dfs(int x, int topf)\n{\n    top[x] = topf; if(son[x]) dfs(son[x], topf);\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(y != fa[x]&&y != son[x]) dfs(y, y);\n    }\n}\nvoid escape(int x, int fa, int dep)\n{\n    ans = max(ans, d[x]<<1); \n    for(int i = ha[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(dis(x, y) > 2) cir = 1;    \n        if(y == fa||dep+1 >= d[y]) continue;\n        escape(y, x, dep+1);\n    }\n}\nint n, a, b;\nint main()\n{\n    n = read(), a = read(), b = read();\n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(ha, x, y);\n    } \n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(hb, x, y);\n    }\n    dfs(b); dfs(b, b); escape(a, 0, 0);\n    printf(\"%d\\n\", cir?-1:ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nclass LCA{\n\tpublic:\n\tint N,root,max_log;\n\tvvi G,parent;\n\tvi depth;\n\tLCA(int size){\n\t\tN=size;\n\t\tG=vvi(size);\n\t\tmax_log=20;\n\t\tdepth=vi(size);\n\t\tparent=vvi(max_log,vi(size));\n\t}\n\tvoid add_edge(int a,int b){\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tvoid dfs(int v,int p,int d){\n\t\tparent[0][v]=p;\n\t\tdepth[v]=d;\n\t\trep(i,G[v].size())if(G[v][i]!=p)dfs(G[v][i],v,d+1);\n\t}\n\tvoid init(){\n\t\troot=0;\n\t\tdfs(root,-1,0);\n\t\tfor(int k=0;k+1<max_log;k++){//doubling\n\t\t\tfor(int v=0;v<N;v++){\n\t\t\t\tif(parent[k][v]<0)parent[k+1][v]=-1;\n\t\t\t\telse parent[k+1][v]=parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u,int v){\n\t\tint out=depth[u]+depth[v];\n\t\tif(depth[u]>depth[v])swap(u,v);\n\t\trep(k,max_log)if((depth[v]-depth[u])>>k&1)v=parent[k][v];\n\t\tif(u==v){\n\t\t\tout-=2*depth[u];\n\t\t\treturn out;\n\t\t}\n\t\tfor(int k=max_log-1;k>=0;k--){\n\t\t\tif(parent[k][u]!=parent[k][v]){\n\t\t\t\tu=parent[k][u];\n\t\t\t\tv=parent[k][v];\n\t\t\t}\n\t\t}\n\t\tout-=2*depth[parent[0][u]];\n\t\treturn out;\n\t}\n};\nint n,x,y,out;\nvvi G,tG;\nvi co,h;\nvoid dfs1(int a,int p,int c){\n\tco[a]=c;\n\trep(i,tG[a].size()){\n\t\tint to=tG[a][i];\n\t\tif(to==p)continue;\n\t\tdfs1(to,a,c+1);\n\t}\n}\nvoid dfs2(int a,int p,int c){\n\tif(c>=co[a])return;\n\tif(h[a])out=inf;\n\tcmax(out,2*co[a]);\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to==p)continue;\n\t\tdfs2(to,a,c+1);\n\t}\n}\nsigned main(){\n\tcin>>n>>x>>y;\n\tG=tG=vvi(n);\n\tco=h=vi(n);\n\tLCA lca(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tlca.add_edge(a,b);\n\t\ttG[a].pb(b);\n\t\ttG[b].pb(a);\n\t}\n\tlca.init();\n\trep(i,n)rep(j,G[i].size()){\n\t\tint to=G[i][j];\n\t\tif(lca.lca(i,to)>=3)h[i]=h[to]=1;\n\t}\n\tdfs1(y-1,-1,0);\n\tdfs2(x-1,-1,0);\n\tif(out==inf)cout<<-1<<endl;\n\telse cout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\nstruct LowestCommonAncestor{\n  int n,h;\n  vector<vector<int> > G,par;\n  vector<int> dep;\n  LowestCommonAncestor(){}\n  LowestCommonAncestor(int n):n(n),G(n),dep(n){\n    h=1;\n    while((1<<h)<=n) h++;\n    par.assign(h,vector<int>(n,-1));\n  }\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  void dfs(int v,int p,int d){\n    par[0][v]=p;\n    dep[v]=d;\n    for(int u:G[v])\n      if(u!=p) dfs(u,v,d+1);\n  }\n  \n  void build(int r=0){\n    dfs(r,-1,0);\n    for(int k=0;k+1<h;k++){\n      for(int v=0;v<n;v++){\n        if(par[k][v]<0) par[k+1][v]=-1;\n        else par[k+1][v]=par[k][par[k][v]];\n      }\n    }\n  }\n  \n  int lca(int u,int v){\n    if(dep[u]>dep[v]) swap(u,v);\n    for(int k=0;k<h;k++){\n      if((dep[v]-dep[u])>>k&1){\n        v=par[k][v];\n      }\n    }\n    if(u==v) return u;\n    for(int k=h-1;k>=0;k--){\n      if(par[k][u]!=par[k][v]){\n        u=par[k][u];\n        v=par[k][v];\n      }\n    }\n    return par[0][u];\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-dep[lca(u,v)]*2;\n  }\n};\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,x,y;\n  cin>>n>>x>>y;\n  x--;y--;\n  // G: sugim, H: sigma\n  vector<vector<int> > G(n),H(n);\n  for(int t=0;t<2;t++){\n    auto &T=(t==0?H:G);\n    for(int i=1;i<n;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      T[a].emplace_back(b);\n      T[b].emplace_back(a);\n    }\n  }\n  \n  LowestCommonAncestor lca(n);\n  lca.G=G;\n  lca.build(y);\n  \n  vector<int> dist(n,-1);\n  queue<int> q;\n  dist[x]=0;\n  q.emplace(x);\n\n  auto WIN=[](){cout<<-1<<endl;exit(0);};\n  int ans=0;\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    chmax(ans,lca.dep[v]);\n    for(int u:H[v]){\n      if(~dist[u]) continue;\n      if(lca.distance(u,v)>=3) WIN();\n      \n      dist[u]=dist[v]+1;\n      if(dist[u]>=lca.dep[u]) continue;\n      q.emplace(u);            \n    }\n  }\n  cout<<ans*2<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nvector<int> v[2][200005];\nint p[20][200005];\nint dis[200005];\nvoid dfs(int x,int f, vector<int> *v){\n    dis[ x ] = dis[ f ] + 1;\n    p[ 0 ][ x ] = f;\n    for(auto it : v[x]){\n        if(it != f){\n            dfs(it, x, v);\n        }\n    }\n}\nvoid build(int n){\n    for(int i = 1 ; i < 20 ; i++){\n        for(int j = 1 ; j <= n ; j++){\n            p[ i ][ j ] = p[ i - 1 ][ p[ i - 1 ][ j ] ];\n        }\n    }\n}\nint lca(int x, int y){\n    if (dis[ x ] > dis[ y ])swap(x, y);\n    int d = dis[ y ] - dis[ x ];\n    for(int i = 0 ; i < 20 ; i++ ){\n        if( d & (1 << i) ){\n            y = p[ i ][ y ];\n        }\n    }\n    if (x == y)\n        return x;\n    for(int i = 19 ; i >= 0 ; i-- ){\n        if( p[ i ][ x ] != p[ i ][ y ] ){\n            x = p[ i ][ x ];\n            y = p[ i ][ y ];\n        }\n    } \n    return p[ 0 ][ x ];\n}\nint getdis(int x, int y){\n    return dis[ x ] + dis[ y ] - dis[ lca(x, y) ];\n}\nint ans;\nvoid dfs2(int x,int f,vector<int> *v,int sum=0){\n    if(dis[x]==sum){\n        ans=max(ans,dis[x]*2);\n    }\n    if(dis[x]<=sum)return;\n    ans=max(ans,dis[x]*2);\n    for(auto it:v[x]){\n        if( it != f){\n            if(getdis(x,it)>=3&&dis[x] > sum){\n              //  printf(\"%d %d %d %d %d\\n\",x,it,dis[x],sum,getdis(x,it));\n             //   printf(\"-1\\n\");\n               // exit(0);\n            }\n            dfs2(it, x, v, sum+1);\n        }\n    }\n}\nint main(){\n    int n, x, y;\n    scanf(\"%d %d %d\", &n, &x, &y);\n    for(int i = 0 ; i < 2 ; i++ ){\n        for(int j = 1 ; j < n ; j++ ){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            v[i][x].pb(y);\n            v[i][y].pb(x);\n        }\n    }\n    dis[0]=-1;\n    dfs(y, 0, v[1]);\n    build(n);\n    dfs2(x, 0, v[0]);\n    printf(\"%d\\n\",ans);\n}\n/*\n\nb[i]*K!/(i)!*(K-i)!\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector> \n#define MN 201000\n\nstd::vector<int> v1[MN], v2[MN];\nint dep[MN], fa[MN];\nint Max = 0;\n\nvoid dfs2(int x, int f)\n{\n\tfa[x] = f; \n\tfor(auto y : v2[x]) \n\t{\n\t\tif(y == f) continue;\n\t\tdep[y] = dep[x] + 1;\n\t\tdfs2(y, x);\n\t}\n}\n\nvoid dfs1(int x, int f, int t)\n{\n\tif(dep[x] <= t) return;\n\tMax = std::max(Max, dep[x]);\n\tfor(auto y : v1[x])\n\t{\n\t\tif(y == f) continue;\n\t\tif(fa[x] == fa[y] || fa[x] == y || fa[y] == x || fa[fa[x]] == y || fa[fa[y]] == x)\n\t\t\tdfs1(y, x, t + 1);\n\t\telse Max = 1e9;\n\t}\n}\n\nint main()\n{\n\tint n, x, y; scanf(\"%d%d%d\", &n, &x, &y);\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tv1[u].push_back(v);\n\t\tv1[v].push_back(u);\n\t}\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tv2[u].push_back(v);\n\t\tv2[v].push_back(u);\n\t}\n\tdfs2(y, 0); dfs1(x, 0, 0);\n\tif(Max >= 1e9) puts(\"-1\");\n\telse printf(\"%d\\n\", 2 * Max);\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n#define ITER(it,a) for(__typeof(a.begin()) it=a.begin();it!=a.end();++it)\n#define DBG1(a) cerr<<#a<<\"=\"<<(a)<<\"\\n\"\n#define DBG2(a,b) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000*1000*1000 + 7;\nconst LL LINF = 1LL*INF*INF;\n\nconst LL MOD = 1000000007;\n\nconst int MAX = 200005;\n\nVI g[2][MAX];\n\nint d[2][MAX];\n\nint par[MAX];\n\n\nvoid dfs(int v,int ind,int p)\n{\n\tif(ind == 1)par[v] = p;\n\tFOR(i,0,SZ(g[ind][v]))\n\t{\n\t\tint to = g[ind][v][i];\n\t\tif(to == p)continue;\n\n\t\td[ind][to] = d[ind][v]+1;\n\t\tdfs(to,ind,v);\n\t}\n}\n\nint ans = 0;\nbool ok[MAX];\nvoid getAns(int v,int p)\n{\n\tans = max(ans,d[1][v]);\n\tok[v] = true;\n\tFOR(i,0,SZ(g[0][v]))\n\t{\n\t\tint to = g[0][v][i];\n\t\tif(to==p)continue;\n\n\t\tif(d[0][to]<d[1][to])getAns(to,v);\n\t}\n}\nset<PII> e2;\n\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//ios::sync_with_stdio(false);cin.tie(0);\n\n\tint n,r1,r2;\n\tcin>>n>>r1>>r2;\n\n\t--r1;--r2;\n\n\tFOR(ind,0,2)\n\tFOR(i,1,n)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tg[ind][a].PB(b);\n\t\tg[ind][b].PB(a);\n\t\tif(ind == 1)e2.insert(MP(min(a,b),max(a,b)));\n\t}\n\n\n\tdfs(r1,0,-1);\n\tdfs(r2,1,-1);\n\n\tFOR(i,0,n)\n\t{\n\t\tint p = par[i];\n\t\tif(p==-1 || par[p] == -1)continue;\n\t\tp = par[p];\n\t\te2.insert(MP(min(p,i),max(p,i)));\n\t}\n\n\tgetAns(r1,-1);\n\n\tFOR(i,0,n)\n\tFOR(j,0,SZ(g[0][i]))\n\t{\n\t\tint to = g[0][i][j];\n\t\tint v = i;\n\t\t\tif(ok[v] && par[v]!=par[to] && !e2.count(MP(min(v,to),max(v,to))))\n\t\t\t{\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\n\n\tcout<<ans*2;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\n\nconst int N=200005;\nint n,U,R,dep[N],fa[N],m;\nvector<int>er[N],eb[N];\n\nvoid dfs(int x){for(int v:eb[x])if(v!=fa[x])fa[v]=x,dep[v]=dep[x]+1,dfs(v);}\ninline bool check(int u,int v){\n\tif(dep[u]<dep[v]) swap(u,v);\n\tint d=0;\n\twhile(++d<=2&&u!=v)if(dep[u]<dep[v])v=fa[v];else u=fa[u];\n\treturn u==v;\n}\nvoid dfs(int x,int fa,int k){\n\tm=max(m,dep[x]);\n\tif(dep[x]<=k)return;\n\tfor(int v:er[x])if(v!=fa){\n\t\tif(!check(x,v))puts(\"-1\"),exit(0);\n\t\tdfs(v,x,k+1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&U,&R);\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),er[u].pb(v),er[v].pb(u);\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),eb[u].pb(v),eb[v].pb(u);\n\tdfs(R),dfs(U,0,0);\n\tprintf(\"%d\\n\",m<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate<class T = ll> constexpr T TEN(int n) {return (n==0)?1:10*TEN<T>(n-1);}\n\nconst int MN = 200200;\nint n;\nvector<int> g[MN], ga[MN];\n\nint dps[MN], par[MN];\nvoid dfs(int p, int b, int dp = 0) {\n    dps[p] = dp;\n    par[p] = b;\n    for (int d: g[p]) {\n        if (d == b) continue;\n        dfs(d, p, dp+1);\n    }\n}\n\nint dist3(int a, int b) {\n    if (dps[a] < dps[b]) swap(a, b);\n    if (a == b) return false; // dist 0\n    if (par[a] == b) return false; // dist 1\n    if (par[a] == par[b]) return false; // dist 2(a)\n    if (par[a] != -1 && par[par[a]] == b) return false; // dist 2(b)\n    return true;\n}\n\nint calc(int p, int b, int dp = 0) {\n    if (dps[p] <= dp) return 0;\n    int ans = 2*(dps[p]-dp); // pass\n    for (int d: ga[p]) {\n        if (d == b) continue;\n        if (dist3(d, p)) {\n            return TEN(9); // dist 3 jump\n        }\n        ans = max(ans, 2+calc(d, p, dp+1));\n    }\n    return ans;\n}\n\nint main() {\n    int x, y;\n    scanf(\"%d %d %d\", &n, &x, &y); x--; y--;\n    for (int i = 0; i < n-1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b); a--; b--;\n        ga[a].push_back(b);\n        ga[b].push_back(a);\n    }\n    for (int i = 0; i < n-1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b); a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(y, -1);\n    int ans = calc(x, -1);\n    if (ans > TEN(9)/2) ans = -1;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int N = 2e5 + 10;\n\nint n;\n\nVI A[N], B[N];\n\nint fa[N], in[N], out[N], dep[N], dfs_clock;\n\nvoid dfsB(int u)\n{\n\tin[u] = ++dfs_clock;\n\tfor (auto v : B[u])\n\t{\n\t\tif (v == fa[u]) continue;\n\t\tfa[v] = u;\n\t\tdep[v] = dep[u] + 1;\n\t\tdfsB(v);\n\t}\n\tout[u] = dfs_clock;\n}\n\nbool check(int u, int v)\n{\n\tif (in[u] <= in[v] && in[v] <= out[u])\n\t{\n\t\tif (fa[v] == u) return 1;\n\t\tif (fa[fa[v]] == u) return 1;\n\t\treturn 0;\n \t}\n \tif (in[v] <= in[u] && in[u] <= out[v])\n\t{\n\t\tif (fa[u] == v) return 1;\n\t\tif (fa[fa[u]] == v) return 1;\n\t\treturn 0;\n \t}\n \tif (fa[u] == fa[v]) return 1;\n \treturn 0;\n}\n\nbool vis[N];\n\nint d[N];\n\nvoid bfsA(int s)\n{\n\tstatic int q[N]; int l = 0, r = 0;\n\tq[r++] = s; vis[s] = 1;\n\twhile (l < r)\n\t{\n\t\tint u = q[l++];\n\t\tfor (auto v : A[u])\n\t\t{\n\t\t\tif (vis[v]) continue;\n\t\t\td[v] = d[u] + 1;\n\t\t\tif (d[v] < dep[v] && !vis[v])\n\t\t\t{\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq[r++] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint rootA, rootB;\n\nbool win[N];\n\nint main()\n{\n\tgiii(n, rootA, rootB);\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tgii(u, v);\n\t\tA[u].pb(v);\n\t\tA[v].pb(u);\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tgii(u, v);\n\t\tB[u].pb(v);\n\t\tB[v].pb(u);\n\t}\n\tdfsB(rootB);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tfor (auto j : A[i])\n\t\t\tif (!check(i, j)) win[i] = win[j] = 1;\n\t}\n\tbfsA(rootA);\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tif (vis[i] && win[i]) \n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (vis[i]) ans = max(ans, dep[i] * 2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define YYS(x, arr) for(auto& x: arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1e9 + 7;\n\ntemplate<class T> T &chmin(T &a, const T &b){return a = min(a, b);}\ntemplate<class T> T &chmax(T &a, const T &b){return a = max(a, b);}\ntemplate<class T> void UNIQUE(vector<T> &a){a.erase(unique(a.begin(), a.end()), a.end());}\n\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\" << endl; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; assert(scanf(\"%lld\", &x) == 1); return x;}\nld fin(){double x; assert(scanf(\"%lf\", &x) == 1); return x;}\nchar yuyushiki[10000010]; string stin(){assert(scanf(\"%s\", yuyushiki) == 1); return yuyushiki;}\n\n// head\n\nvector<int> G[200010];\nvector<int> H[200010];\n\nint distG[200010];\nint distH[200010];\nint par[200010][20];\n\nvoid dfs1(int x, int p = -1, int d = 0){\n  distG[x] = d;\n  YYS(w, G[x]){\n    if(w == p){\n      continue;\n    }\n    dfs1(w, x, d+1);\n  }\n}\n\nvoid dfs2(int x, int p = -1, int d = 0){\n  distH[x] = d;\n  par[x][0] = p;\n  YYS(w, H[x]){\n    if(w == p){\n      continue;\n    }\n    dfs2(w, x, d+1);\n  }\n}\n\nint lca(int a, int b){\n  if(distH[a] > distH[b]){\n    swap(a, b);\n  }\n  for(int i = 19; i >= 0; i--){\n    if((distH[b] - distH[a]) & PW(i)){\n      b = par[b][i];\n    }\n  }\n  if(a == b){\n    return a;\n  }\n  for(int i = 19; i >= 0; i--){\n    if(par[a][i] != par[b][i]){\n      a = par[a][i];\n      b = par[b][i];\n    }\n  }\n  assert(a != b);\n  assert(par[a][0] == par[b][0]);\n  return par[a][0];\n}\n\nint dist(int a, int b){\n  return distH[a] + distH[b] - 2 * distH[lca(a, b)];\n}\n\nint ans;\n\nvoid dfs3(int x, int p = -1){\n  chmax(ans, 2 * distH[x]);\n  if(distG[x] < distH[x]){\n    YYS(w, G[x]){\n      if(w == p){\n        continue;\n      }\n      if(dist(x, w) >= 3){\n        ans = INF;\n      }\n      if(distG[w] <= distH[w]){\n        dfs3(w, x);\n      }\n    }\n  }\n}\n\nint main(){\n\n  int n = in();\n  int x = in() - 1;\n  int y = in() - 1;\n  REP(i, n-1){\n    int a = in() - 1;\n    int b = in() - 1;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  REP(i, n-1){\n    int a = in() - 1;\n    int b = in() - 1;\n    H[a].pb(b);\n    H[b].pb(a);\n  }\n\n  dfs1(x);\n  dfs2(y);\n\n  FOR(i, 1, 20){\n    REP(j, n){\n      if(par[j][i-1] == -1){\n        par[j][i] = -1;\n      } else {\n        par[j][i] = par[par[j][i-1]][i-1];\n      }\n    }\n  }\n\n  dfs3(x);\n\n  if(ans == INF){\n    ans = -1;\n  }\n  \n  cout << ans << endl;\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n    static const int BITLEN_MAX = 30;\n    vector<int> parent[BITLEN_MAX];\n    vector<int> depth;\n    int bitlen;\n\n    void initialize(int N, const vector<int> edges[]){\n        int root = 0;\n        bitlen = 1;\n        while((1<<bitlen) < N) bitlen += 1;\n        for(int i=0; i<bitlen; i++) parent[i].resize(N);\n        depth.resize(N, -1);\n\n        dfs(root, -1, 0, edges);\n        for(int k=0; k<bitlen-1; k++){\n            for(int v=0; v<N; v++){\n                if(depth[v] == -1) continue;\n                if(parent[k][v] < 0){\n                    parent[k+1][v] = -1;\n                }else{\n                    parent[k+1][v] = parent[k][parent[k][v]];\n                }\n            }\n        }\n    }\n\n    void dfs(int v, int p, int d, const vector<int> edges[]){\n        parent[0][v] = p;\n        depth[v] = d;\n        for(auto u : edges[v]){\n            if(u != p) dfs(u, v, d+1, edges);\n        }\n    }\n\n    int calc_lca(int u, int v){\n        if(depth[u] > depth[v]) swap(u, v);\n        for(int k=0; k<bitlen; k++){\n            if( ((depth[v]-depth[u]) >> k) & 1 ) v = parent[k][v];\n        }\n        if(u == v) return u;\n        for(int k=bitlen-1; k>=0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n\n    int calc_dist(int u, int v){\n        int l = calc_lca(u, v);\n        return depth[u] + depth[v] - depth[l]*2;\n    }\n};\n\nvector<int> edges[2][200000];\nint dist[2][200000];\nbitset<200000> dead, eternal;\n\nvoid dfs(int i, int p, int d, int k){\n    dist[k][i] = d;\n    for(int j : edges[k][i]) if(j != p) dfs(j, i, d+1, k);\n}\n\nint ans = 0;\nconst int INF = 1e9;\nvoid dfs2(int i, int p){\n    ans = max(ans, eternal[i] ? INF : dist[1][i] * 2);\n    for(int j : edges[0][i]) if(j != p && !dead[j]) dfs2(j, i);\n}\n\nint main(){\n    int N, S[2];\n    cin >> N >> S[0] >> S[1];\n    for(int k=0; k<2; k++){\n        for(int i=0; i<N-1; i++){\n            int a, b;\n            cin >> a >> b;\n            edges[k][a-1].push_back(b-1);\n            edges[k][b-1].push_back(a-1);\n        }\n        S[k]--;\n        dfs(S[k], -1, 0, k);\n    }\n\n    for(int i=0; i<N; i++) if(dist[0][i] >= dist[1][i]) dead[i] = true;\n\n    LCA lca1;\n    lca1.initialize(N, edges[1]);\n    for(int i=0; i<N; i++){\n        if(dead[i]) continue;\n        for(int j : edges[0][i]){\n            if(dead[j]) continue;\n            if(lca1.calc_dist(i, j) > 2) eternal[i] = eternal[j] = true;\n        }\n    }\n\n    dfs2(S[0], -1);\n    cout << (ans == INF ? -1 : ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\ninline int read(){\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c); c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c); c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn 0-x;\n}\nint n,x,y;\nstruct edge{int v,nxt;}e[N<<1];\nint hd[N],cnt;\ninline void add(int u, int v){e[++cnt]=(edge){v,hd[u]}, hd[u]=cnt;}\nint dep[N];\nvoid dfs(int u, int fa){\n\tdep[u]=dep[fa]+1;\n\tfor(int i=hd[u]; i; i=e[i].nxt) if(e[i].v!=fa) dfs(e[i].v,u);\n}\nint dis[N],ans;\nvoid dfs2(int u, int fa){\n\tdis[u]=dis[fa]+1, ans=max(ans,dep[u]);\n\tfor(int i=hd[u]; i; i=e[i].nxt) if(e[i].v!=fa && dis[u]+1<dep[u]) dfs2(e[i].v,u);\n}\nint main(){\n\tn=read(), x=read(), y=read();\n\tint u,v;\n\tfor(int i=1; i<n; ++i) u=read(), v=read(), add(u,v), add(v,u);\n\tdep[0]=-1;\n\tdfs(y,0);\n\tdfs2(x,0);\n\tcout<<ans*2<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint n,u,v,fa[N],fst[N],to[N],nxt[N],l,dep[N],dis[N],Ans,f[N],q[N];\nstruct T\n{\n\tint x,y;\n}a[N],b[N];\nvector<int>e[N];\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nvoid dfs(int x)\n{\n\tfor (int i=fst[x];i;i=nxt[i])\n\t\tif (to[i]!=fa[x])\n\t\t{\n\t\t\tfa[to[i]]=x;\n\t\t\tdep[to[i]]=dep[x]+1;\n\t\t\tdfs(to[i]);\n\t\t}\n}\nint Gdis(int x,int y)\n{\n\tif (x==y) return 0;\n\tif (fa[x]==y||fa[y]==x) return 1;\n\tif (fa[x]==fa[y]||fa[fa[x]]==y||fa[fa[y]]==x) return 2;\n\treturn 3;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&u,&v);\n\t//if (u==v){puts(\"0\");,return 0;}\n\tfor (int i=1;i<n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&b[i].x,&b[i].y);\n\t\tlink(b[i].x,b[i].y);\n\t}\n\tdfs(v);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint tmp=Gdis(a[i].x,a[i].y);\n\t\tif (tmp==1)\n\t\t{\n\t\t\te[a[i].x].push_back(a[i].y);\n\t\t\te[a[i].y].push_back(a[i].x);\n\t\t}\n\t\telse if (tmp==2)\n\t\t{\n\t\t\tif (fa[a[i].x]!=v||fa[a[i].y]!=v)\n\t\t\t{\n\t\t\t\te[a[i].x].push_back(a[i].y);\n\t\t\t\te[a[i].y].push_back(a[i].x);\n\t\t\t}\n\t\t}\n\t\telse f[a[i].x]=f[a[i].y]=1;\n\t}\n\tmemset(dis,0x3f,sizeof dis);\n\tint l=0,r=1;\n\tq[1]=u;dis[u]=0;\n\twhile(l<r)\n\t{\n\t\tint t=q[++l];\n\t\t//cout<<t<<' '<<dis[t]<<endl;\n\t\tif (f[t]==1){puts(\"-1\");return 0;}\n\t\telse Ans=max(Ans,dep[t]*2);\n\t\tfor (int i=0;i<e[t].size();i++)\n\t\t\tif (dis[e[t][i]]>dis[t]+1&&dis[t]+1<dep[e[t][i]])\n\t\t\t{\n\t\t\t\tdis[e[t][i]]=dis[t]+1;\n\t\t\t\tq[++r]=e[t][i];\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(!bad[u])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(h[u1[i]]>h[u2[i]])swap(u1[i],u2[i]);\n\t/*rep(i,1,n)if(ok[i] && (!bad[u1[i]])){\n\t\tma=-1;\n\t}*/\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nP dp[200005];\nint lca[200005][18],dist2[200005];\nint calc(int x,int y){\n\tif(dist2[x] > dist2[y]) swap(x,y);\n\trep(i,18){\n\t\tif((((dist2[y]-dist2[x])>>i)&1)){\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\tfor(int i=17;i>=0;i--){\n\t\tif(lca[x][i] != lca[y][i]){\n\t\t\tx = lca[x][i];\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\treturn (x==y?x:lca[x][0]);\n}\nbool fe;\nint go(int a,int b){\n\tint c = calc(a,b);\n\tif(a == c){\n\t\tfor(int i=0;i<18;i++){\n\t\t\tif((((dist2[b]-dist2[a]-1)>>i)&1)){\n\t\t\t\tb = lca[b][i];\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\telse{\n\t\treturn lca[a][0];\n\t}\n}\nint ret = 0;\nvoid dfs(int v,int u,int d){\n\tif(dp[v].fi >= 0){\n\t\tret = max(ret,2*d+dp[v].fi*2);\n\t}\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint D = dist2[v]+dist2[edge[v][i]]-2*dist2[calc(v,edge[v][i])];\n\t\t//cout << v << \" \" << edge[v][i] << \" \" << \" \" << calc(v,edge[v][i]) << D << endl;\n\t\tif(D>=3 && lca[edge[v][i]][0] != dp[v].sc && lca[dp[v].sc][0] != edge[v][i] && edge[v][i] != dp[v].sc){\n\t\t\t\n\t\t\tfe = 1;\n\t\t}\n\t\telse {\n\t\t\tD = dist2[edge[v][i]]+dist2[dp[v].sc]-2*dist2[calc(edge[v][i],dp[v].sc)];\n\t\t\tif(D<=1){\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(0,edge[v][i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(D-1,go(dp[v].sc,edge[v][i])));\n\t\t\t\tdfs(edge[v][i],v,d+1);\n\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d; lca[v][0] = u;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs2(b,-1,0);\n\tdp[a] = mp(dist2[a],b);\n\tfor(int j=0;j<17;j++) for(int i=1;i<=n;i++){\n\t\tif(lca[i][j] == -1) lca[i][j+1] = -1;\n\t\telse lca[i][j+1] = lca[lca[i][j]][j];\n\t}\n\tdfs(a,-1,0);\n\tif(fe) puts(\"-1\");\n\telse cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\n#define MAX 200200\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next,col;}e[MAX<<2];\nint h[MAX],cnt=1,E[MAX][2];\ninline void Add(int u,int v,int col){e[cnt]=(Line){v,h[u],col};h[u]=cnt++;}\nint dfn[MAX],tim,fa[MAX],dep[MAX],low[MAX],dis[MAX],X,Y,n;\nbool inf[MAX],vis[MAX];\nvoid dfs(int u,int ff)\n{\n\tdfn[u]=++tim;fa[u]=ff;dep[u]=dep[ff]+1;\n\tfor(int i=h[u];i;i=e[i].next)\n\t\tif(e[i].col&&e[i].v!=ff)\n\t\t\tdfs(e[i].v,u);\n\tlow[u]=++tim;\n}\nbool check(int x,int y)\n{\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tif(low[x]>=low[y])return dep[y]-dep[x]>2;\n\tif(fa[x]==fa[y])return false;\n\treturn true;\n}\nvoid BFS()\n{\n\tqueue<int> Q;vis[X]=true;Q.push(X);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(!e[i].col&&!vis[e[i].v])\n\t\t\t{\n\t\t\t\tdis[e[i].v]=dis[u]+1;\n\t\t\t\tif(dis[e[i].v]<dep[e[i].v])\n\t\t\t\t\tvis[e[i].v]=true,Q.push(e[i].v);\n\t\t\t}\n\t}\n}\nint main()\n{\n\tn=read();X=read();Y=read();\n\tfor(int i=1;i<n;++i)E[i][0]=read(),E[i][1]=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=read(),v=read();\n\t\tAdd(u,v,1);Add(v,u,1);\n\t}\n\tdep[0]=-1;dfs(Y,0);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=E[i][0],v=E[i][1];\n\t\tif(check(u,v))inf[u]=inf[v]=true;\n\t\telse Add(u,v,0),Add(v,u,0);\n\t}\n\tBFS();\n\tfor(int i=1;i<=n;++i)if(vis[i]&&inf[i]){puts(\"-1\");return 0;}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)if(vis[i])ans=max(ans,dep[i]<<1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 200003;\nint n, sr, sb, p1[N], p2[N], fab[N], disb[N], disr[N], q[N], front, rear;\nvector<int> Er[N], Eb[N];\nbool vis[N], win[N];\ninline void dfs(int x){\n\tfor(Rint v : Eb[x]) if(v != fab[x]){\n\t\tfab[v] = x; disb[v] = disb[x] + 1; dfs(v);\n\t}\n}\ninline bool check(int x, int y){\n\treturn fab[x] == y || fab[y] == x || fab[x] == fab[y] || fab[fab[x]] == y || fab[fab[y]] == x;\n}\ninline void bfs(int S){\n\tfront = rear = 0; q[rear ++] = S;\n\tmemset(disr, 0x3f, sizeof disr);\n\tdisr[S] = 0;\n\twhile(front < rear){\n\t\tint now = q[front ++];\n\t\tvis[now] = 1;\n\t\tif(disb[now] <= disr[now]) continue;\n\t\tfor(Rint v : Er[now])\n\t\t\tif(disr[v] >= disr[now] + 1 && disb[v] >= disr[now] + 1){\n\t\t\t\tdisr[v] = disr[now] + 1; q[rear ++] = v;\n\t\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\", &n, &sr, &sb);\n\tfor(Rint i = 1;i < n;i ++)\n\t\tscanf(\"%d%d\", p1 + i, p2 + i);\n\tfor(Rint i = 1;i < n;i ++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tEb[x].push_back(y); Eb[y].push_back(x);\n\t}\n\tdfs(sb);\n\tfor(Rint i = 1;i < n;i ++)\n\t\tif(!check(p1[i], p2[i])) win[p1[i]] = win[p2[i]] = true;\n\t\telse {Er[p1[i]].push_back(p2[i]); Er[p2[i]].push_back(p1[i]);}\n\tbfs(sr);\n\tint ans = 0;\n\tfor(Rint i = 1;i <= n;i ++)\n\t\tif(vis[i] && win[i]){puts(\"-1\"); return 0;}\n\t\telse if(vis[i]) ans = max(ans, disb[i]);\n\tprintf(\"%d\", ans << 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ Fast IO\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 200010;\n\nint n;\n\nvector<pair<int, int> >E;\n\nstruct Graph {\n\tint S;\n\tint tot;\n\tint fi[MAXN];\n\tint dep[MAXN];\n\tint fa[MAXN][20];\n\tint ne[MAXN << 1];\n\tint to[MAXN << 1];\n\n\tinline void Link(int u, int v) {\n\t\ttot++;\n\t\tto[tot] = v;\n\t\tne[tot] = fi[u];\n\t\tfi[u] = tot;\n\t}\n\n\tinline void dfs(int x, int la) {\n\t\tfa[x][0] = la, dep[x] = dep[la] + 1;\n\t\tfor(int i = 1; i < 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n\t\tfor(int i = fi[x]; i; i = ne[i]) {\n\t\t\tint u = to[i];\n\t\t\tif(u == la) continue;\n\t\t\tdfs(u, x);\n\t\t}\n\t}\n\n\tinline int LCA(int x, int y) {\n\t\tif(dep[x] < dep[y]) swap(x, y);\n\t\tint k = dep[x] - dep[y];\n\t\tfor(int i = 0; i < 20; i++)\n\t\t \tif(k & (1 << i)) x = fa[x][i];\n\t\tif(x == y) return x;\n\t\tfor(int i = 19; ~i; --i)\n\t\t\tif(fa[x][i] != fa[y][i])\n\t\t\t\tx = fa[x][i], y = fa[y][i];\n\t\treturn fa[x][0];\n\t}\n\n\tinline int dis(int u, int v) { return dep[u] + dep[v] - dep[LCA(u, v)] * 2; }\n\tinline int dis_S(int x) { return dep[x] - 1; }\n\n\tinline void AddEdge(int ty = 0) {\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tint u = ri, v = ri;\n\t\t\tLink(u, v), Link(v, u);\n\t\t\tif(ty) E.push_back(make_pair(u, v));\n\t\t} dfs(S, S);\n\t}\n}A, B;\n\nint chk[MAXN];\nint vis[MAXN];\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tn = ri, A.S = ri, B.S = ri;\n\tA.AddEdge(1), B.AddEdge();\n\tfor(auto e : E) {\n\t\tint u = e.first, v = e.second;\n\t\tif(B.dis(u, v) > 2) {\n\t\t\tif(A.dep[u] < B.dep[u]) chk[u] = 1;\n\t\t\tif(A.dep[v] < B.dep[v]) chk[v] = 1;\n\t\t}\n\t} int res = B.dep[A.S] - 1;\n\tqueue<int>q;\n\tq.push(A.S), vis[A.S] = 1;\n\twhile(!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\tfor(int i = A.fi[x]; i; i = A.ne[i]) {\n\t\t\tint u = A.to[i];\n\t\t\tif(vis[u] || A.dep[u] >= B.dep[u]) continue;\n\t\t\tif(chk[u]) return puts(\"-1\"), 0;\n\t\t\tvis[u] = 1;\n\t\t\tchkmax(res, B.dep[u] - 1);\n\t\t\tq.push(u);\n\t\t}\n\t}\n\tcout << res * 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nvector<int>A[210000];\nvector<int>B[210000];\nint num;\nint sz;\nint segtree[1048576];\nint conv[210000];\nint eu[420000];\nint ord[210000];\nint vis[210000];\nint dep[210000];\nvoid dfs(int a,int b){\n\tord[a]=num;\n\teu[sz++]=num;\n\tconv[num]=a;\n\tnum++;\n\tfor(int i=0;i<A[a].size();i++){\n\t\tif(A[a][i]==b)continue;\n\t\tdep[A[a][i]]=dep[a]+1;\n\t\tdfs(A[a][i],a);\n\t\teu[sz++]=ord[a];\n\t}\n}\nint query(int a,int b,int c,int d,int e){\n\tif(d<a||b<c)return 1000000007;\n\tif(c<=a&&b<=d)return segtree[e];\n\treturn min(query(a,(a+b)/2,c,d,e*2),query((a+b)/2+1,b,c,d,e*2+1));\n}\nvoid update(int a,int b){\n\ta+=524288;\n\twhile(a){\n\t\tsegtree[a]=min(segtree[a],b);\n\t\ta/=2;\n\t}\n}\nint ap[210000];\nint goal[210000];\n\nint da[210000];\nint db[210000];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);b--;c--;\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tB[p].push_back(q);\n\t\tB[q].push_back(p);\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tA[p].push_back(q);\n\t\tA[q].push_back(p);\n\t}\n\tdfs(0,-1);\n\tfor(int i=0;i<1048576;i++)segtree[i]=1000000007;\n\t//for(int i=0;i<sz;i++)printf(\"%d\\n\",eu[i]);\n\tfor(int i=0;i<sz;i++)update(i,eu[i]);\n\tfor(int i=0;i<sz;i++)ap[eu[i]]=i;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<B[i].size();j++){\n\t\t\tint lca=conv[query(0,524287,min(ap[ord[i]],ap[ord[B[i][j]]]),max(ap[ord[i]],ap[ord[B[i][j]]]),1)];\n\t\t\tint dist=dep[i]+dep[B[i][j]]-dep[lca]*2;\n\t\t//\tprintf(\"%d %d %d %d\\n\",i,B[i][j],query(0,524287,min(ap[ord[i]],ap[ord[B[i][j]]]),max(ap[ord[i]],ap[ord[B[i][j]]]),1),lca);\n\t\t\tif(dist>2)goal[i]=goal[B[i][j]]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)da[i]=db[i]=-1;\n\tda[c]=0;\n\tdb[b]=0;\n\tqueue<int>Q;\n\tQ.push(c);\n\twhile(Q.size()){\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<A[at].size();i++){\n\t\t\tif(!~da[A[at][i]]){\n\t\t\t\tda[A[at][i]]=da[at]+1;\n\t\t\t\tQ.push((A[at][i]));\n\t\t\t}\n\t\t}\n\t}\n\tQ.push(b);\n\twhile(Q.size()){\n\t\tint at=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<B[at].size();i++){\n\t\t\tif(!~db[B[at][i]]){\n\t\t\t\tdb[B[at][i]]=db[at]+1;\n\t\t\t\tQ.push((B[at][i]));\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<a;i++)printf(\"%d %d\\n\",da[i],db[i]);\n\tint ret=da[b]*2;\n\tQ.push(b);\n\tvis[b]=1;\n\twhile(Q.size()){\n\t\tint at=Q.front();Q.pop();\n\t\tfor(int i=0;i<B[at].size();i++){\n\t\t\tif(vis[B[at][i]])continue;\n\t\t\tint to=B[at][i];\n\t\t\tif(da[to]==db[to])ret=max(ret,da[to]*2);\n\t\t\tif(da[to]>db[to]){\n\t\t\t\tvis[to]=1;\n\t\t\t\tret=max(ret,da[to]*2);\n\t\t\t\tif(goal[to])ret=999999999;\n\t\t\t\tQ.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tif(ret>9999999)ret=-1;\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X,Y;\nvector<int> E[202020],E2[202020];\n\nint P[21][200005],D[200005],D2[200005];\n\nvoid dfs(int cur) {\n\tITR(it,E[cur]) if(*it!=P[0][cur]) D[*it]=D[cur]+1, P[0][*it]=cur, dfs(*it);\n}\nint dist(int a,int b) {\n\tint ret=0,i,aa=a,bb=b;\n\tif(D[aa]>D[bb]) swap(aa,bb);\n\tfor(i=19;i>=0;i--) if(D[bb]-D[aa]>=1<<i) bb=P[i][bb];\n\tfor(i=19;i>=0;i--) if(P[i][aa]!=P[i][bb]) aa=P[i][aa], bb=P[i][bb];\n\treturn D[a]+D[b]-2*D[(aa==bb)?aa:P[0][aa]];  // dist\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>X>>Y;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE2[x].push_back(y);\n\t\tE2[y].push_back(x);\n\t}\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\tP[0][Y]=Y;\n\tdfs(Y);\n\tFOR(i,19) FOR(x,N) P[i+1][x+1]=P[i][P[i][x+1]];\n\tFOR(i,N) D2[i+1]=10101010;\n\t\n\tint ret=0;\n\tqueue<int> Q;\n\tD2[X]=0;\n\tQ.push(X);\n\twhile(Q.size()) {\n\t\tx = Q.front();\n\t\tQ.pop();\n\t\tif(D2[x]>D[x]) continue;\n\t\tret=max(ret,D[x]);\n\t\tFORR(e,E2[x]) {\n\t\t\tif(dist(x,e)>=3) return _P(\"-1\\n\");\n\t\t\tif(D2[e]>D2[x]+1) D2[e]=D2[x]+1, Q.push(e);\n\t\t}\n\t}\n\t\n\tcout<<ret*2<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Never let them see you bleed...\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn = 2e5 + 10, mod = 1e9 + 7, inf = 1e9 + 10;\n\nvector<int> v[maxn], g[maxn];\n\nbool good[maxn];\n\nint h[maxn], pr[maxn];\n\nvoid dfs1(int u, int par = 0){\n    h[u] = h[par] + 1;\n    pr[u] = par;\n    for(int y : g[u]){\n\tif(y != par)\n\t    dfs1(y, u);\n    }\n}\n\nvector<int> vec;\n\nvoid dfs2(int u, int H = 1, int par = 0){\n    if(H >= h[u])\n\treturn;\n    vec.PB(u);\n    for(int y : v[u]){\n\tif(y != par)\n\t    dfs2(y, H+1, u);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    int n, a, b;\n    cin >> n >> a >> b;\n    for(int i = 0; i < n-1; i++){\n\tint a, b;\n\tcin >> a >> b;\n\tv[a].PB(b);\n\tv[b].PB(a);\n    }\n    for(int i = 0; i < n-1; i++){\n\tint a, b;\n\tcin >> a >> b;\n\tg[a].PB(b);\n\tg[b].PB(a);\n    }\n    dfs1(b);\n    for(int i = 1; i <= n; i++){\n\tfor(int j : v[i]){\n\t    if(pr[i] != j && pr[j] != i && pr[i] != pr[j] && pr[pr[i]] != j && pr[pr[j]] != i)\n\t\tgood[i] = good[j] = 1;\n\t}\n    }\n    dfs2(a);\n\n    int ans = 0;\n    for(int u : vec){\n\tif(good[u])\n\t    return cout << -1 << endl, 0;\n\tans = max(ans, h[u]);\n    }\n    return cout << 2 * (ans-1) << endl, 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?(c=getchar()):0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){\n\tif(a<b){\n\t\ta=b;\n\t}\n}\nconst int N=200010,INF=0x7f7f7f7f;\nint ans=0;\nnamespace T{\n\tconst int E=N<<2;\n\tint to[E],bro[E],mhead[N],dhead[N],e=0;\n\tint fa[N],dep[N],dfn[N],dfe[N],tim=0;\n\tbool col[N];\n\tinline void init(){\n\t\tmemset(mhead,-1,sizeof(mhead));\n\t\tmemset(dhead,-1,sizeof(dhead));\n\t}\n\tinline void ae(int u,int v,int *head){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v,int *head){\n\t\tae(u,v,head),ae(v,u,head);\n\t}\n\tvoid dfs1(int x){\n\t\tdfn[x]=++tim;\n\t\tfor(int i=mhead[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=fa[x]){\n\t\t\t\tfa[v]=x;\n\t\t\t\tdep[v]=dep[x]+1;\n\t\t\t\tdfs1(v);\n\t\t\t}\n\t\t}\n\t\tdfe[x]=tim;\n\t}\n\tinline bool cont(int u,int v){\n\t\treturn dfn[u]<=dfn[v]&&dfe[u]>=dfe[v];\n\t}\n\tinline bool gcol(int u,int v){\n\t\tif(cont(u,v)){\n\t\t\treturn dep[v]-dep[u]>2;\n\t\t}\n\t\tif(cont(v,u)){\n\t\t\treturn dep[u]-dep[v]>2;\n\t\t}\n\t\treturn fa[u]!=fa[v];\n\t}\n\tvoid dfs2(int x,int fa,int stp){\n\t\tif(dep[x]<=stp){\n\t\t\treturn;\n\t\t}\n\t\tif(col[x]){\n\t\t\tthrow -1;\n\t\t}\n\t\tapmax(ans,dep[x]);\n\t\tfor(int i=dhead[x];~i;i=bro[i]){\n\t\t\tif(to[i]!=fa){\n\t\t\t\tdfs2(to[i],x,stp+1);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint n=ni,drt=ni,rt=ni;\n\tT::init();\n\tfor(int i=1;i<n;T::add(ni,ni,T::dhead),i++);\n\tfor(int i=1;i<n;T::add(ni,ni,T::mhead),i++);\n\tT::dfs1(rt);\n\tfor(int i=0,ti=T::e>>1;i<ti;i+=2){\n\t\tint u=T::to[i],v=T::to[i^1];\n\t\tif(T::gcol(u,v)){\n\t\t\tT::col[u]=T::col[v]=true;\n\t\t}\n\t}\n\ttry{\n\t\tT::dfs2(drt,0,0);\n\t\tprintf(\"%d\\n\",ans<<1);\n\t}catch(int ans){\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,y,ans;\n\nvector<int> G[maxn],G2[maxn];\n\nint tim[maxn];\n\nvoid dfs2(int u,int fa){\n\ttim[u]=tim[fa]+1;\n\tfor(auto v:G2[u])if(v!=fa)dfs2(v,u);\n}\n\nvoid dfs1(int u,int fa,int now){\n\tans=max(ans,(tim[u]-1)*2);\n\tfor(auto v:G[u])if(now+1<tim[v]&&v!=fa){\n\t\tdfs1(v,u,now+1);\n\t}\n}\n\nvoid Work(){\n\tif(x==y){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tdfs2(y,0);\n\tdfs1(x,0,1);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n,x,y);\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG2[u].PB(v);G2[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define per(i, a, b) for(int i=(b)-1; i>=(a); i--)\n#define sz(a) (int)a.size()\n#define de(a) cout << #a << \" = \" << a << endl\n#define dd(a) cout << #a << \" = \" << a << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef double db;\n\nvoid file_put() {\n    freopen(\"filename.in\", \"r\", stdin);\n    freopen(\"filename.out\", \"w\", stdout);\n}\n\nconst int N=2e5+5;\nint n,X,Y,d[N],f[N],ret=0,x,y; vi R[N],B[N];\n\nbool check(int x,int y) {\n\tif (!y) return 1;\n\tif (f[x]==y || f[y]==x) return 1;\n\tif (f[f[x]]==y || f[f[y]]==x) return 1;\n\treturn f[x]==f[y];\n}\n\nvoid dfs(int x,int p) {\n\td[x]=d[p]+1,f[x]=p;\n\tfor (auto y: B[x]) if (y!=p) dfs(y,x);\n}\n\nvoid dfs(int x,int p,int k) {\n\tif (!check(x,p)) {\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t}\n\tret=max(ret,d[x]);\n\tif (d[x]>k) return;\n\tfor (auto y: R[x]) if (y!=p) dfs(y,x,k+1);\n}\n\nint main() {\n//\tfile_put();\n\t\n\tscanf(\"%d%d%d\",&n,&X,&Y),d[0]=-1;\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),R[x].pb(y),R[y].pb(x);\n\trep(i,1,n) scanf(\"%d%d\",&x,&y),B[x].pb(y),B[y].pb(x);\n\tdfs(Y,0),dfs(X,0,0);\n\tprintf(\"%d\\n\",ret<<1);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N << 1], dph[N << 1], dfn = 0;\nint dp[N << 1][20], lg2[N << 1];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x]) {\n    \tif (y == fx) continue; \n        dfsb(y, x);\n        q[++dfn] = x;\n        dph[dfn] = db[x];\n    }\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] >= db[x]) return;\n    if (~ans) ans = max((db[x] - 1) << 1, ans);\n    for (int y : a[x]) {\n        if (y == fx) continue;\n        if (db[x] + db[y] - 2 * db[LCA(x, y)] > 2) ans = -1;\n        dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\nconst int N = 2e5;\nconst int lgN = 18;\nconst int INF = 1e7;\nstruct Edge\n{\n\tint v,nxt;\n} e1[(N<<1)+3],e2[(N<<1)+3];\nint fe1[N+3],fe2[N+3];\nint dep1[N+3],dep2[N+3];\nint fa2[N+3][lgN+3];\nint n,en1,en2,s1,s2,ans;\n\nvoid addedge1(int u,int v)\n{\n\ten1++; e1[en1].v = v;\n\te1[en1].nxt = fe1[u]; fe1[u] = en1;\n}\nvoid addedge2(int u,int v)\n{\n\ten2++; e2[en2].v = v;\n\te2[en2].nxt = fe2[u]; fe2[u] = en2;\n}\n\nvoid dfs1(int u,int prv)\n{\n\tfor(int i=fe1[u]; i; i=e1[i].nxt)\n\t{\n\t\tint v = e1[i].v;\n\t\tif(v==prv) continue;\n\t\tdep1[v] = dep1[u]+1;\n\t\tdfs1(v,u);\n\t}\n}\n\nvoid dfs2(int u)\n{\n\tfor(int i=1; i<=lgN; i++) fa2[u][i] = fa2[fa2[u][i-1]][i-1];\n\tfor(int i=fe2[u]; i; i=e2[i].nxt)\n\t{\n\t\tint v = e2[i].v;\n\t\tif(v==fa2[u][0]) continue;\n\t\tfa2[v][0] = u; dep2[v] = dep2[u]+1;\n\t\tdfs2(v);\n\t}\n}\n\nint LCA(int u,int v)\n{\n\tif(dep2[u]<dep2[v]) swap(u,v);\n\tint dif = dep2[u]-dep2[v];\n\tfor(int i=0; i<=lgN; i++)\n\t{\n\t\tif(dif&(1<<i)) {u = fa2[u][i];}\n\t}\n\tif(u==v) return u;\n\tfor(int i=lgN; i>=0; i--)\n\t{\n\t\tif(fa2[u][i]!=fa2[v][i]) {u = fa2[u][i],v = fa2[v][i];}\n\t}\n\treturn fa2[u][0];\n}\n\nvoid dfs(int u,int fa)\n{\n\tif(dep1[u]>=dep2[u]) {return;}\n\tans = max(ans,dep2[u]);\n\tfor(int i=fe1[u]; i; i=e1[i].nxt)\n\t{\n\t\tint v = e1[i].v;\n\t\tif(v==fa) continue;\n\t\tif(dep2[u]+dep2[v]-2*dep2[LCA(u,v)]>2) {ans = INF; return;}\n\t\tdfs(v,u);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&s1,&s2);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\taddedge1(u,v); addedge1(v,u);\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\taddedge2(u,v); addedge2(v,u);\n\t}\n\tdfs1(s1,0); dfs2(s2);\n\tans = 0; dfs(s1,0);\n\tprintf(\"%d\\n\",ans==INF?-1:ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1e9;\nint n, x, y, rp[100010], rd[100010], bp[100010], bd[100010], ans;\nvector<int> re[100010], be[100010];\n\nvoid T_T(){ puts(\"-1\"); exit(0); }\n\nvoid f(int t, int x, int pr, int de, int *p, int *d){\n\td[x] = de;\n\tp[x] = pr;\n\tif(t){\n\t\tfor(auto &i : be[x]){\n\t\t\tif(i != pr) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n\telse{\n\t\tfor(auto &i : re[x]){\n\t\t\tif(i != pr && i != y) f(t, i, x, de + 1, p, d);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tauto in = [](int t){\n\t\tfor(int i = 0, x, y; i < n - 1; i++){\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t(t ? be[x] : re[x]).push_back(y);\n\t\t\t(t ? be[y] : re[y]).push_back(x);\n\t\t}\n\t};\n\tin(0); in(1);\n\tf(1, y, 0, 0, bp, bd);\n\tfill(rd + 1, rd + n + 1, inf);\n\tf(0, x, 0, 0, rp, rd);\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(auto &j : re[i]){\n\t\t\tint a = i, b = j;\n\t\t\tif(bd[a] > bd[b]) swap(a, b);\n\t\t\tif(bp[b] == a || bp[bp[b]] == a || bp[a] == bp[b]) continue;\n\t\t\tif(bd[a] >= rd[a] || bd[b] >= rd[b]) T_T();\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) if(rd[i] < inf) ans = max(ans, 2 * bd[i]);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 200005;\nconst int LOG = 18;\n\nint N, X, Y;\nvector <int> red[MAXN], blue[MAXN];\nint anc[MAXN][LOG];\nint disc[MAXN], fin[MAXN];\nint depth[MAXN];\nint timer = 1;\nint sol;\n\nvoid load() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tred[a].push_back(b);\n\t\tred[b].push_back(a);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\tint c, d;\n\t\tscanf(\"%d%d\", &c, &d);\n\t\tblue[c].push_back(d);\n\t\tblue[d].push_back(c);\n\t}\n}\n\nvoid dfs(int x, int p) {\n\tdisc[x] = timer++;\n\tdepth[x] = depth[p] + 1;\n\tanc[x][0] = p;\n\tfor (auto it : blue[x])\n\t\tif (it != p)\n\t\t\tdfs(it, x);\n\tfin[x] = timer;\n}\n\nint jmp(int x, int k) {\n\tfor (int i = 0; i < LOG; i++)\n\t\tif (k >> i & 1)\n\t\t\tx = anc[x][i];\n\treturn x;\n}\n\nint lca(int x, int y) {\n\tif (depth[x] < depth[y])\n\t\tswap(x, y);\n\tx = jmp(x, depth[x] - depth[y]);\n\tif (x == y)\n\t\treturn x;\n\tfor (int i = LOG - 1; i >= 0; i--)\n\t\tif (anc[x][i] != anc[y][i]) {\n\t\t\tx = anc[x][i];\n\t\t\ty = anc[y][i];\n\t\t}\n\treturn anc[x][0];\n}\n\nint dist(int x, int y) {\n\treturn depth[x] + depth[y] - 2 * depth[lca(x, y)];\n}\n\nint get_nxt(int x, int y) {\n\tif (x == y)\n\t\treturn x;\n\tif (disc[y] < disc[x] || disc[y] >= fin[x])\n\t\treturn anc[x][0];\n\treturn jmp(y, depth[y] - depth[x] - 1);\n}\n\nvoid go(int x, int p, int pos, int steps) {\n\tsol = max(sol, steps + dist(pos, x));\n\tfor (auto it : red[x]) \n\t\tif (it != p) {\n\t\t\tint tmp = get_nxt(pos, it);\n\t\t\tif (tmp == it)\n\t\t\t\tcontinue;\n\t\t\tif (dist(x, it) >= 3)\n\t\t\t\tsol = MAXN;\n\t\t\tgo(it, x, tmp, steps + 1);\n\t\t}\n}\n\nint solve() {\n\tdfs(1, 0);\t\n\t\n\tfor (int j = 1; j < LOG; j++)\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tanc[i][j] = anc[anc[i][j - 1]][j - 1];\n\t\n\tgo(X, 0, Y, 0);\n\t\n\treturn sol < MAXN ? 2 * sol : -1;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxn = 2e6 + 5;\nvector<int> blue[maxn], red[maxn];\nint dep[maxn], fa[maxn], dp[maxn];\nbool safe[maxn];\nvoid dfs(int v, int p) {\n    fa[v] = p;\n    for (int i=0; i<blue[v].size(); i++) if(blue[v][i] != p) {\n        dep[blue[v][i]] = dep[v] + 1;\n        dfs(blue[v][i], v);\n    }\n}\nbool atMost2(int x, int y) {\n    return (fa[x] == fa[y]) || (fa[x] == y) || (x == fa[y]) || (fa[fa[x]] == y) || (x == fa[fa[y]]);\n}\nint main() {\n    int n, X, Y, x, y;\n    scanf(\"%d %d %d\", &n, &X, &Y);\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        red[x].push_back(y), red[y].push_back(x);\n    }\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        blue[x].push_back(y), blue[y].push_back(x);\n    }\n    dfs(Y, -1);\n    for (int i=1; i<=n; i++)\n        for (int j=0; j<red[i].size(); j++)\n            if (!atMost2(i, red[i][j]))\n                safe[i] = safe[red[i][j]] = 1;\n    if (safe[X]) {puts(\"-1\"); return 0;}\n    memset(dp, -1, sizeof(dp));\n    queue<int> q;\n    q.push(X); dp[X] = 0;\n    int ans = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (dp[u] >= dep[u]) continue;\n        if (safe[u]) {puts(\"-1\"); return 0;}\n        ans = max(ans, dep[u] * 2);\n        for (int i=0; i<red[u].size(); i++) {\n            int v = red[u][i];\n            if (dp[u] + 1 < dep[v] && atMost2(u, v)) {\n                dp[v] = dp[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N=200005;\n\nint fst[N],dep[N],d[N],a[N],b[N],fa[N],tot=0,ans=0;\nbool u[N];\nstruct Edge{\n\tint to,nxt;\n}e[N*2];\n\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\n\nvoid dfs(int x){\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y!=fa[x]){\n\t\t\tfa[y]=x;\n\t\t\tdep[y]=dep[x]+1;\n\t\t\tdfs(y);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x,int v){\n\tif (ans==-1 || d[x]>=dep[x]) return;\n\tif (u[x]) ans=-1;\n\t\telse if (dep[x]*2>ans) ans=dep[x]*2;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y!=v){\n\t\t\td[y]=d[x]+1;\n\t\t\tdfs2(y,x);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,X,Y;\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor (int i=1;i<n;i++) scanf(\"%d%d\\n\",&a[i],&b[i]);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y);\n\t\taddedge(y,x);\n\t}\n\tdfs(Y);\n\tfor (int i=1;i<=n;i++) fst[i]=0;\n\ttot=0;\n\tfor (int i=1;i<n;i++){\n\t\tint x=a[i],y=b[i],fx=fa[x],fy=fa[y];\n\t\tif (fx==y||fy==x||fa[fx]==y||fa[fy]==x||fx==fy) addedge(x,y),addedge(y,x);\n\t\t\telse u[x]=u[y]=1;\n\t}\n\tdfs2(X,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    //printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(2e5) + 9;\n\nint n, x, y;\n\nstruct Tree{\n    vector<int> adj[N];\n    int d[N], p[N];\n    \n    void dfs(int u, int p = -1){\n        for (auto v: adj[u]){\n            if (v == p) continue;\n            d[v] = d[u] + 1; this->p[v] = u;\n            dfs(v, u);\n        }\n    }\n    void in(){\n        DO(n-1){\n            int x, y; RD(x, y); --x, --y;\n            adj[x].PB(y);\n            adj[y].PB(x);\n        }\n    }\n} R, B;\n\nint gao(){\n\n    RD(n, x, y); R.in(); B.in();\n    R.dfs(x); B.dfs(y);\n    \n    int z = 0;\n    REP(u, n) if (R.d[u] < B.d[u]){\n        int v = R.p[u];\n        if (v == B.p[u] || B.p[v] == u || B.p[B.p[u]] == v || B.p[B.p[v]] == u || B.p[u] == B.p[v]) checkMax(z, R.d[u]*2);\n        else return -1;\n    }\n    return z;\n}\n\nint main(){\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users//desktop/Exercise/out.txt\", \"w\", stdout);\n#endif\n    \n    OT(gao());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct LCA{\n\tvector<vector<int> > g;\n\tconst int MAX_LOG = 22;\n\tvector<vector<int> > lcc;\n\tvector<int> dep;\n\tvector<int> myr;\nprivate:\n\tvoid init2(){\n\t\tint n = g.size();\n\t\tfor (int i = 0; i + 1 < MAX_LOG; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (lcc[i][j] == -1){\n\t\t\t\t\tlcc[i + 1][j] = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlcc[i + 1][j] = lcc[i][lcc[i][j]];\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tint lca(int a, int b){\n\t\tif (dep[a] < dep[b]){\n\t\t\tswap(a, b);\n\t\t}\n\t\tfor (int i = 0; i < MAX_LOG; i++){\n\t\t\tif (((dep[a] - dep[b]) >> i) & 1){\n\t\t\t\ta = lcc[i][a];\n\t\t\t}\n\t\t}\n\t\tif (a == b){\n\t\t\treturn a;\n\t\t}\n\t\tfor (int i = MAX_LOG - 1; i >= 0; i--){\n\t\t\tif (lcc[i][a] != lcc[i][b]){\n\t\t\t\ta = lcc[i][a];\n\t\t\t\tb = lcc[i][b];\n\t\t\t}\n\t\t}\n\t\treturn lcc[0][a];\n\t}\nprivate:\n\tint flag_r;\n\tinline void dfs(int b, int pr = -1, int d = 0){\n\t\tfor (auto &i : g[b]){\n\t\t\tif (i == pr)continue;\n\t\t\tdfs(i, b, d + 1);\n\t\t}\n\t\tdep[b] = d;\n\t\tlcc[0][b] = pr;\n\t\tmyr[b] = flag_r;\n\t}\npublic:\n\n\tvoid init(vector<vector<int> > &tree, int root = 0){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tflag_r = root;\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tdfs(root);\n\t\tinit2();\n\t}\n\tvoid init(vector<vector<int> > &tree, vector<int> &root){\n\t\tg = tree;\n\t\tmyr.resize(tree.size(), -1);\n\t\tlcc.resize(MAX_LOG, vector<int>(g.size(), 0));\n\t\tdep.resize(g.size());\n\t\tfor (int &i : root){\n\t\t\tif (myr[i] == -1){\n\t\t\t\tflag_r = i;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t}\n\tint dist(int a, int b){ \n\t\tif (myr[a] != myr[b]){\n\t\t\treturn -1;\n\t\t}\n\t\tint lc = lca(a, b);\n\t\treturn dep[a] + dep[b] - 2 * dep[lc];\n\t}\n};\n\n#define MAX 200002\n\nint n;\n\nint x;\nint y;\n\nvector<vector<int> > sigma;\nvector<vector<int> > sugim;\n\nLCA sigmaL;\nLCA sugimL;\n\nbool win[MAX];\n\nvector<vector<int> > vv;\nqueue<int> q;\nvector<int> ord;\nbool vis[MAX];\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t}\n};\nUF uf;\n\nint main(){\n\tcin >> n;\n\tuf.resize(n);\n\tcin >> x >> y;\n\tsigma.resize(n,vector<int>());\n\tsugim = sigma; \n\tvv = sigma;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsigma[a].push_back(b);\n\t\tsigma[b].push_back(a);\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tsugim[a].push_back(b);\n\t\tsugim[b].push_back(a);\n\t}\n\tx--;\n\ty--;\n\tsugimL.init(sugim,y);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int &j : sigma[i]){\n\t\t\tif (i > j)continue;\n\t\t\tint d = sugimL.dist(i, j);\n\t\t\tif (d > 2){\n\t\t\t\twin[i] = true;\n\t\t\t\twin[j] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint ll = sugimL.lca(i, j);\n\t\t\t\tuf.merge(i, ll);\n\t\t\t\tuf.merge(j, ll);\n\t\t\t}\n\t\t}\n\t}\n\tsigmaL.init(sigma, y);\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i]){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (uf.root(a)!=uf.root(b)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tif (tim == -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (win[i] == false){\n\t\t\tint a = x;\n\t\t\tint b = i;\n\t\t\tif (uf.root(a)!= uf.root(b) ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint lc = sugimL.lca(a, b);\n\t\t\tint tim = sigmaL.dist(a, lc);\n\t\t\tint tim2 = sugimL.dist(lc, y);\n\t\t\tint cost = sigmaL.dist(a, b);\n\t\t\tif (tim > tim2){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (tim == tim2){\n\t\t\t\tif (b == lc){\n\t\t\t\t\tans = max(ans, cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tim < tim2){\n\t\t\t\tans = max(ans, cost + tim2 - tim);\n\t\t\t}\n\t\t}\n\t}\n\tcout << 2*ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n\ninline int read(){\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tx=c-48;\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-48;\n\treturn x;\n}\n\nconst int maxn=2e5+10;\nint n,a,b,uu[maxn],vv[maxn],dep[maxn],fa[20][maxn],dist[maxn],ans;\nint ecnt,ebeg[maxn],enxt[maxn<<1],eto[maxn<<1];\nint eecnt,eebeg[maxn],eenxt[maxn<<1],eeto[maxn<<1];\nbool safe[maxn];\n\ninline void ae(int u,int v){\n\t++ecnt;\n\tenxt[ecnt]=ebeg[u];\n\tebeg[u]=ecnt;\n\teto[ecnt]=v;\n}\ninline void aee(int u,int v){\n\t++eecnt;\n\teenxt[eecnt]=eebeg[u];\n\teebeg[u]=eecnt;\n\teeto[eecnt]=v;\n}\ninline void chkmax(int&a,int b){\n\tif(a<b)a=b;\n}\nvoid dfs(int pos){\n\tfor(int i=ebeg[pos],v;i;i=enxt[i])\n\t\tif((v=eto[i])!=fa[0][pos]){\n\t\t\tfa[0][v]=pos;\n\t\t\tdep[v]=dep[pos]+1;\n\t\t\tdfs(v);\n\t\t}\n}\nint lca(int u,int v){\n\tif(dep[u]<dep[v])u^=v,v^=u,u^=v;\n\tfor(int i=19;~i;--i)\n\t\tif(dep[fa[i][u]]>dep[v])\n\t\t\tu=fa[i][u];\n\tif(dep[u]>dep[v])\n\t\tu=fa[0][u];\n\tfor(int i=19;~i;--i)\n\t\tif(fa[i][u]!=fa[i][v])\n\t\t\tu=fa[i][u],v=fa[i][v];\n\tif(u!=v)\n\t\tu=fa[0][u],v=fa[0][v];\n\treturn u;\n}\nvoid dfss(int pos,int last){\n\tchkmax(ans,dep[pos]);\n\tif(dist[pos]>=dep[pos])\n\t\treturn;\n\tif(safe[pos]){\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n\tfor(int i=eebeg[pos];i;i=eenxt[i])\n\t\tif(eeto[i]!=last){\n\t\t\tdist[eeto[i]]=dist[pos]+1;\n\t\t\tdfss(eeto[i],pos);\n\t\t}\n}\n\nint main(){\n\tn=read();a=read();b=read();\n\tfor(int i=1;i<n;++i)\n\t\tuu[i]=read(),vv[i]=read();\n\tfor(int i=1,u,v;i<n;++i){\n\t\tu=read();v=read();\n\t\tae(u,v);\n\t\tae(v,u);\n\t}\n\tdfs(b);\n\tfor(int i=1;i<20;++i)\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tfa[i][j]=fa[i-1][fa[i-1][j]];\n\tfor(int i=1,u,v;i<n;++i){\n\t\tu=uu[i];v=vv[i];\n\t\taee(u,v);aee(v,u);\n\t\tif(dep[u]+dep[v]-dep[lca(u,v)]*2>=3)\n\t\t\tsafe[u]=safe[v]=true;\n\t}\n\tdfss(a,0);\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"0\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nint n;\nvvi s, t;\nvi ds, dt;\n\n// LCA (0-indexed)\nstruct LCA {\n  int n, bi;\n  vi dep;\n  vector<vi> to, par;\n  LCA(int n):n(n),dep(n),to(n){}\n  void add(int a, int b){ to[a].pb(b); to[b].pb(a);}\n  void calcDep(int v, int ndep=0, int p=-1){\n    dep[v] = ndep; par[0][v] = p;\n    for(int u : to[v]) if(u != p) calcDep(u,ndep+1,v);\n  }\n  void init(){\n    bi = 0;\n    while(1<<bi <= n) bi++;\n    par.resize(bi,vi(n,-1));\n    calcDep(0);\n    rep(i,bi-1)rep(j,n) par[i+1][j] = (par[i][j]==-1?-1:par[i][par[i][j]]);\n  }\n  int lca(int a, int b){\n    if(dep[a] < dep[b]) swap(a,b);\n    int x = dep[a]-dep[b];\n    for(int i = bi-1; i >= 0; --i){\n      if(1<<i <= x) a = par[i][a], x -= 1<<i;\n    }\n    if(a == b) return a;\n    for(int i = bi-1; i >= 0; --i){\n      if(par[i][a] != par[i][b]) a = par[i][a], b = par[i][b];\n    }\n    return par[0][a];\n  }\n  int dist(int a, int b){\n    int c = lca(a,b);\n    return dep[a]+dep[b] - dep[c]*2;\n  }\n};\n//\n\nvoid bfs(vvi& g, vi& d, int sv) {\n  d[sv] = 0;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == INF) {\n        d[u] = d[v]+1;\n        q.push(u);\n      }\n    }\n  }\n}\nvoid cfs(vvi& g, vi& d, int sv) {\n  if (d[sv] != 1) return;\n  d[sv] = 2;\n  queue<int> q;\n  q.push(sv);\n  while (sz(q)) {\n    int v = q.front(); q.pop();\n    for (int u : g[v]) {\n      if (d[u] == 1) {\n        d[u] = 2;\n        q.push(u);\n      }\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d\",&n);\n  int x, y;\n  scanf(\"%d%d\",&x,&y);\n  --x; --y;\n  s = t = vvi(n);\n  LCA g(n);\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    s[a].pb(b);\n    s[b].pb(a);\n  }\n  rep(i,n-1) {\n    int a, b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    t[a].pb(b);\n    t[b].pb(a);\n    g.add(a,b);\n  }\n  g.init();\n  ds = dt = vi(n,INF);\n  bfs(s,ds,x);\n  bfs(t,dt,y);\n  int ans = 0;\n  vi c(n);\n  rep(i,n) if (ds[i] < dt[i]) c[i] = 1;\n  cfs(s,c,x);\n  rep(i,n) {\n    if (c[i] != 2) continue;\n    maxs(ans, dt[i]*2);\n    for (int u : s[i]) {\n      if (c[u] != 2) continue;\n      if (g.dist(i,u) >= 3) {\n        puts(\"-1\");\n        return 0;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=200005;\n\nint n,X,Y,ncnt;\nint dfn[MAXN],efn[MAXN],fa[MAXN],dep[MAXN];\nstruct node{\n    int v,nex;\n}E[MAXN*2],G[MAXN*2];\nint Ehead[MAXN],Ghead[MAXN],dcnt[2];\nbool tag[MAXN];\npair<int,int> a[MAXN];\n\nvoid addedge(node edge[],int head[],int &cnt,int u,int v){\n    node &p=edge[++cnt];\n    p.v=v;\n    p.nex=head[u];\n    head[u]=cnt;\n}\n\nvoid dfs(int u,int fa=0){\n    ::fa[u]=fa;\n    dep[u]=dep[fa]+1;\n    dfn[u]=++ncnt;\n    for(int i=Ghead[u];i;i=G[i].nex){\n        int v=G[i].v;\n        if(v==fa) continue;\n        dfs(v,u);\n    }\n    efn[u]=++ncnt;\n}\n\nbool check(int u,int v){\n    if(dfn[u]>dfn[v]) swap(u,v);\n    if(dfn[u]<dfn[v]&&efn[v]<efn[u])\n        return dep[v]-dep[u]>=3;\n    return fa[u]!=fa[v];\n}\n\nint vis[MAXN],dis[MAXN],deq[MAXN],l,r;\nvoid bfs(){\n    for(int i=1;i<=n;i++) vis[i]=dis[i]=0;\n    l=r=1;\n    deq[r++]=X;\n    while(l<r){\n        int u=deq[l++];\n        vis[u]=1;\n        for(int i=Ehead[u];i;i=E[i].nex){\n            int v=E[i].v;\n            if(vis[v]) continue;\n            dis[v]=dis[u]+1;\n            if(dis[v]<dep[v])\n                deq[r++]=v;\n        }\n    }\n}\n\nint main(){\n    //freopen(\"coalesce.in\",\"r\",stdin);\n    //freopen(\"coalesce.out\",\"w\",stdout);\n\n    dep[0]=-1;\n    while(~scanf(\"%d%d%d\",&n,&X,&Y)){\n        for(int i=1;i<=n;i++) Ehead[i]=Ghead[i]=0;\n        dcnt[0]=dcnt[1]=ncnt=0;\n        for(int i=1;i<=n;i++) tag[i]=0;\n        for(int i=1;i<n;i++) scanf(\"%d%d\",&a[i].first,&a[i].second);\n        for(int i=1;i<n;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            addedge(G,Ghead,dcnt[1],u,v);\n            addedge(G,Ghead,dcnt[1],v,u);\n        }\n        dfs(Y);\n        for(int i=1;i<n;i++)\n            if(check(a[i].first,a[i].second)) tag[a[i].first]=tag[a[i].second]=1;\n            else addedge(E,Ehead,dcnt[0],a[i].first,a[i].second),addedge(E,Ehead,dcnt[0],a[i].second,a[i].first);\n        bfs();\n        int ans=0;\n        bool flag=1;\n        for(int i=1;i<=n&&flag;i++){\n            if(!vis[i]) continue;\n            if(tag[i]) flag=0;\n            else ans=max(ans,2*dep[i]);\n        }\n        printf(\"%d\\n\",flag?ans:-1);\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n\nusing namespace std;\n\nconst int MaxN = 2e5 + 5;\n\nvector<int> gb[MaxN], gr[MaxN];\n\nint dep[MaxN], fa[MaxN], d[MaxN];\nbool safe[MaxN], vis[MaxN];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, sx, sy;\n  cin >> n >> sx >> sy;\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    gr[x].emplace_back(y);\n    gr[y].emplace_back(x);\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    gb[x].emplace_back(y);\n    gb[y].emplace_back(x);\n  }\n  queue<int> Q;\n  Q.push(sy);\n  fa[sy] = -1;\n  vis[sy] = true;\n  while (!Q.empty()) {\n    int k = Q.front();\n    for (int x : gb[k]) {\n      if (!vis[x]) {\n        Q.push(x);\n        vis[x] = true;\n        dep[x] = dep[k] + 1;\n        fa[x] = k;\n      }\n    }\n    Q.pop();\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int k : gr[i]) {\n      if (![](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n      } (i, k)) {\n        safe[i] = safe[k] = true;\n      }\n    }\n  }\n  if (safe[sx]) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int ans = 0;\n  memset(d, 0xff, sizeof d);\n  d[sx] = 0;\n  Q.push(sx);\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop();\n    if (d[k] >= dep[k]) {\n      continue;\n    }\n    if (safe[k]) {\n      cout << -1 << endl;\n      return 0;\n    }\n    ans = max(ans, dep[k] * 2);\n    for (int x : gr[k]) {\n      if (vis[x] && d[k] + 1 < dep[x] && [](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n        } (k, x)) {\n        d[x] = d[k] + 1;\n        vis[x] = false;\n        Q.push(x);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 200010\nusing namespace std;\n\nstruct edge{int x, y, next;}a[N*2], b[N*2];\nint n, p1, p2, l, p[N], q[N], x, y, dis1[N], dis2[N], fa[N], flag[N], ff[N], ans;\n\ninline char gc(){\n\tstatic char now[1<<16], *S, *T;\n\tif(S==T){T=(S=now)+fread(now, 1, 1<<16, stdin); if(S==T)return EOF;}\n\treturn *S++;\n}\ninline int read(){\n\tint x=0, f=1; char ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=gc();}\n\treturn x*f;\n}\n\ninline void add1(int x, int y){a[++l].x=x; a[l].y=y; a[l].next=p[x]; p[x]=l;}\ninline void add2(int x, int y){b[++l].x=x; b[l].y=y; b[l].next=q[x]; q[x]=l;}\n\ninline int check(int x, int y){\n\tif(fa[x]==y||fa[y]==x)return 0;\n\tif(fa[fa[x]]==y||fa[fa[y]]==x||fa[x]==fa[y])return 0;\n\treturn 1;\n}\ninline void dfs1(int x, int fa){\n\tif(dis1[x]<dis2[x]&&flag[fa])flag[x]=1;\n\tfor(int i=p[x]; i; i=a[i].next)if(fa!=a[i].y){\n\t\tif(check(x, a[i].y))ff[x]=ff[a[i].y]=1;\n\t\tdis1[a[i].y]=dis1[x]+1; dfs1(a[i].y, x);\n\t}\n}\ninline void dfs2(int x){\n\tfor(int i=q[x]; i; i=b[i].next)if(fa[x]!=b[i].y){\n\t\tfa[b[i].y]=x; dis2[b[i].y]=dis2[x]+1; dfs2(b[i].y);\n\t}\n}\n\nint main(){\n\tn=read(); p1=read(); p2=read();\n\tl=0; memset(p, 0, sizeof(p));\n\tfor(int i=1; i<=n-1; i++){x=read(); y=read(); add1(x, y); add1(y, x);}\n\tl=0; memset(q, 0, sizeof(q));\n\tfor(int i=1; i<=n-1; i++){x=read(); y=read(); add2(x, y); add2(y, x);}\n\tfa[p2]=dis2[p2]=0; dfs2(p2);\n\tmemset(ff, 0, sizeof(ff)); memset(flag, 0, sizeof(flag)); flag[0]=1;\n\tdis1[p1]=0; dfs1(p1, 0);\n\tfor(int i=1; i<=n; i++)if(flag[i]&&ff[i]){printf(\"-1\"); return 0;}\n\tans=0; for(int i=1; i<=n; i++)if(flag[i])ans=max(ans, dis2[i]);\n\tprintf(\"%d\", ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nint n,m,sr,sb,i,j,disb[200005],disr[200005],px[200005],py[200005],fab[200005],winr[200005],visr[200005],ans;\nvector<int> bib[200005],bir[200005];\nvoid dfsb(int x,int fa)\n{\n\tfab[x]=fa;\n\tff(bib[x],it){\n\t\tif(*it==fa)continue;\n\t\tdisb[*it]=disb[x]+1;\n\t\tdfsb(*it,x);\n\t}\n}\nint check(int x,int y)\n{\n\tif(fab[x]==y||fab[y]==x) return 0;\n\tif(fab[x]==fab[y]) return 0;\n\tif(fab[fab[x]]==y) return 0;\n\tif(fab[fab[y]]==x) return 0;\n\treturn 1;\n}\nvoid bfsr(int x)\n{\n\tqueue<int> qx;\n\tqx.push(x);\n\tmemset(disr,0x3f,sizeof(disr));\n\tdisr[x]=0;\n\twhile(!qx.empty()){\n\t\tint x=qx.front();qx.pop();\n\t\tvisr[x]=1;\n\t\tff(bir[x],it){\n\t\t\tint y=*it,z=disr[x]+1;\n\t\t\tif(disr[y]>z&&disb[y]>z){\n\t\t\t\tdisr[y]=z;\n\t\t\t\tqx.push(y);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&sr,&sb);\n\tfz1(i,n-1){\n\t\tscanf(\"%d%d\",&px[i],&py[i]);\n\t}\n\tfz1(i,n-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tbib[x].push_back(y);\n\t\tbib[y].push_back(x);\n\t}\n\tdfsb(sb,0);\n\tfz1(i,n-1){\n\t\tif(check(px[i],py[i])){\n\t\t\twinr[px[i]]=winr[py[i]]=1;\n\t\t}\n\t\telse{\n\t\t\tbir[px[i]].push_back(py[i]);\n\t\t\tbir[py[i]].push_back(px[i]);\n\t\t}\n\t}\n\tbfsr(sr);\n\tfz1(i,n){\n\t\tif(visr[i]&&winr[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(visr[i]){\n\t\t\tans=max(ans,disb[i]*2);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, X, Y;\nint head[200001], next[399999], to[399999], lon[399999], E;\nint dep[200001], dep2[200001], pst[200001], fa[200001];\nint au[200000], av[200000], al[200000];\nint q[200001];\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; i++)\n\t\tscanf(\"%d%d\", au + i, av + i);\n\tfor (int i = 1, u, v; i < N; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tnext[++E] = head[u], to[E] = v, head[u] = E;\n\t\tnext[++E] = head[v], to[E] = u, head[v] = E;\n\t}\n\tint H = 0, T = 1, u;\n\tq[1] = Y;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t{\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\t\t\t\tdep[to[e]] = dep[u] + 1;\n\t\t\t}\n\tfor (int i = 1; i < N; i++)\n\t\tal[i] = !(fa[au[i]] == av[i] || fa[av[i]] == au[i] || fa[fa[au[i]]] == av[i] || fa[fa[av[i]]] == au[i] || fa[au[i]] == fa[av[i]]);\n\tfor (int i = 1; i <= N; i++)\n\t\thead[i] = 0;\n\tE = 0;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tnext[++E] = head[au[i]], to[E] = av[i], lon[E] = al[i], head[au[i]] = E;\n\t\tnext[++E] = head[av[i]], to[E] = au[i], lon[E] = al[i], head[av[i]] = E;\n\t}\n\tH = 0, T = 1;\n\tq[1] = X;\n\tfa[X] = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tdep2[i] = 1000000000;\n\tdep2[X] = 0;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u] && dep2[u] + 1 < dep[to[e]])\n\t\t\t{\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\t\t\t\tdep2[to[e]] = dep2[u] + 1;\n\t\t\t\tpst[to[e]] = pst[u] | lon[e];\n\t\t\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tif (pst[i] && dep2[i] < dep[i])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tint O = 0;\n\tfor (int i = 1; i <= N; i++)\n\t\tif (dep2[i] < dep[i])\n\t\t\tO = std::max(O, dep[i]);\n\tprintf(\"%d\\n\", O << 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 200100;\nvi a[N], b[N];\nint da[N], db[N];\nint n;\nint X, Y;\nconst int inf = 1e9;\n\nvoid dfs(int v, int pr, int dst, vi a[], int d[]) {\n\td[v] = dst;\n\tforn(i, sz(a[v])) {\n\t\tint to = a[v][i];\n\t\tif (to != pr) {\n\t\t\tdfs(to, v, dst + 1, a, d);\n\t\t}\n\t}\n}\n\nbool good[N];\nset<int> be[N];\nint ans;\n\nvoid precalc(int v, int pr) {\n\tbool ok = 1;\n\tforn(i, sz(b[v])) {\n\t\tint to = b[v][i];\n\t\tif (to == pr || be[to].find(pr) != be[to].end()) {\n\t\t\tok = 0;\n\t\t\t break;\n\t\t}\n\t}\n\tif (ok && pr >= 0) {\n\t\tgood[v] = 1;\n\t\tgood[pr] = 1;\n\t}\n\tforn(i, sz(a[v])) {\n\t\tint to = a[v][i];\n\t\tif (to != pr)\n\t\t\tprecalc(to, v);\n\t}\n}\n\nvoid calc(int v, int pr) {\n\tif (good[v]) {\n\t\tans = inf;\n\t\treturn;\n\t}\n\tumx(ans, db[v]);\n\tforn(i, sz(a[v])) {\n\t\tint to = a[v][i];\n\t\tif (to == pr)\n\t\t\tcontinue;\n\t\tif (db[to] > da[to]) {\n\t\t\tcalc(to, v);\n\t\t}\n\t}\n}\t\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tcin >> n >> X >> Y;\n\tX--, Y--;\n\tforn(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu--, v--;\n\t\ta[u].pb(v);\n\t\ta[v].pb(u);\n\t}\n\tmemset(good, 0, sizeof(good));\n\tforn(i, n - 1) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu--, v--;\n\t\tb[u].pb(v);\n\t\tb[v].pb(u);\n\t\tbe[u].insert(v);\n\t\tbe[v].insert(u);\n\t}\n\tans = 0;\n\tdfs(X, -1, 0, a, da);\n\tdfs(Y, -1, 0, b, db);\n\tprecalc(X, -1);\n\tcalc(X, -1);\n\tif (ans == inf) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << 2 * ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define f(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define file(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool chkmin(T &a,T b){return (a>b)?a=b,1:0;}\n\ninline int read() {\n int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\nint n;\nint X,Y;\nint p[200005][2];\nint fa[400005],dfn[400005],low[400005];\nint he[400005],ne[800005],to[800005],cost[800005],e;\nvoid add(int x,int y,int z){\n    to[++e]=y;\n\tne[e]=he[x];\n\the[x]=e;\n\tcost[e]=z;\n}\nint vis[400005];\nint tot;\nint dep[400005];\nvoid dfs(int x,int ff){\n     fa[x]=ff;\n\t dfn[x]=++tot;\n\t for(int i=he[x];i;i=ne[i]){\n\t   int v=to[i];\n\t   if(!cost[i])continue;\n\t   if(v==ff)continue;\n\t   dep[v]=dep[x]+1;\n\t   dfs(v,x);\n\t }\n\t low[x]=++tot;\n}\nbool check(int x,int y){\n    if(dfn[x]>dfn[y])swap(x,y);\n    if(dfn[x]<=dfn[y]&&low[x]>=low[y])return dep[y]-dep[x]>2;\n    if(fa[x]==fa[y])return 0;\n\telse return 1;\n}\nint ans[200005];\nint dis[200005];\nqueue<int>q;\nvoid bfs(){\n     vis[X]=1;\n\t q.push(X);\n\t while(!q.empty()){\n\t    int x=q.front();\n\t\tq.pop();\n\t\tfor(int i=he[x];i;i=ne[i]){\n\t\t\tint v=to[i];\n\t\t   if(!cost[i]&&!vis[v]){\n\t\t      dis[v]=dis[x]+1;\n\t\t\t  if(dis[v]<dep[v]){\n\t\t\t      q.push(v);\n\t\t\t\t  vis[v]=1;\n\t\t\t  }\n\t\t   }\n\t\t}\n\t }\n}\nint main () {\n#ifndef ONLINE_JUDGE\n//file(\"agc005e\");\n#endif\n    n=read();\n\tX=read();\n\tY=read();\n\tF(i,1,n-1){\n\t    p[i][0]=read();\n\t\tp[i][1]=read();\n\t}\n\tF(i,1,n-1){\n\t   int x=read(),y=read();\n\t   add(x,y,1);\n\t   add(y,x,1);\n\t}\n\tdfs(Y,0);\n    F(i,1,n-1){\n\t   int x=p[i][0],y=p[i][1];\n\t   if(check(x,y))ans[x]=ans[y]=1;\n\t   else add(x,y,0),add(y,x,0);\n\t}\n\tbfs();\n\tint Ans=0;\n\tF(i,1,n){\n\t   if(vis[i]&&ans[i]){\n\t       puts(\"-1\");\n\t\t   return 0;\n\t   }\n\t   else chkmax(Ans,dep[i]*2);\n\t}\n\tprintf(\"%d\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define repst(p) for(int i=begin[p],q;i;i=next[i])if((q=to[i])!=h)\n#define rept(p,t) for(int i=t.begin[p],q;i;i=t.next[i])if((q=t.to[i])!=h)\ntemplate<typename T>inline void check_max(T a,T &b){if(a>b)b=a;}\ntemplate<typename T>inline void read(T &x)\n{\n\tchar c=x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);\n}\nnamespace wrong\n{\n\tconst int N=201000,M=N*2;\n\tstruct tool\n\t{\n\t\tint begin[N],next[M],to[M];\n\t\tint fa[N][20],dep[N];\n\t\tint e;\n\t\tvoid add(int x,int y,bool k=1)\n\t\t{\n\t\t\tto[++e]=y;\n\t\t\tnext[e]=begin[x];\n\t\t\tbegin[x]=e;\n\t\t\tif(k)add(y,x,0);\n\t\t}\n\t\tvoid predfs(int p=1,int h=0)\n\t\t{\n\t\t\tdep[p]=dep[h]+1;\n\t\t\tfor(int k=1;k<=18;k++)\n\t\t\t\tfa[p][k]=fa[fa[p][k-1]][k-1];\n\t\t\trepst(p)\n\t\t\t{\n\t\t\t\tfa[q][0]=p;\n\t\t\t\tpredfs(q,p);\n\t\t\t}\n\t\t}\n\t\tint get_lca(int u,int v)\n\t\t{\n\t\t\tif(dep[u]<dep[v])std::swap(u,v);\n\t\t\tfor(int k=18;k>=0;k--)\n\t\t\t\twhile(dep[fa[u][k]]>=dep[v])u=fa[u][k];\n\t\t\tfor(int k=18;k>=0;k--)\n\t\t\t\twhile(fa[u][k]!=fa[v][k])\n\t\t\t\t\tu=fa[u][k],v=fa[v][k];\n\t\t\treturn u==v?u:fa[u][0];\n\t\t}\n\t\tint dis(int u,int v){return dep[u]+dep[v]-2*dep[get_lca(u,v)];}\n\t\tbool check(int u,int v)\n\t\t{\n\t\t\tif(dep[u]<dep[v])std::swap(u,v);\n\t\t\tif(fa[u][0]==v || fa[u][1]==v)return 0;\n\t\t\tif(fa[u][0]==fa[v][0])return 0;\n\t\t\treturn 1;\n\t\t}\n\t\tint go(int p,int q)\n\t\t{\n\t\t\tif(dep[p]>=dep[q])return fa[p][0];\n\t\t\tfor(int k=18;k>=0;k--)\n\t\t\t\twhile(dep[fa[q][k]]>dep[p])q=fa[q][k];\n\t\t\tif(fa[q][0]==p)return q;\n\t\t\treturn fa[p][0];\n\t\t}\n\t}s,t;\n\tint f[N],g[N];\n\tbool isit[N];\n\tint n,X,Y;\n\tvoid initialize()\n\t{\n\t\tread(n),read(X),read(Y);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tread(u),read(v),s.add(u,v);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tread(u),read(v),t.add(u,v);\n\t\tt.predfs();\n\t\tf[X]=Y,g[X]=0;\n\t}\n\tvoid dfs(int p=X,int h=0)\n\t{\n\n\t\tif(p==f[p])return;\n\t\trept(p,s)\n\t\t{\n\t\t\tif(t.check(p,q))isit[p]=isit[q]=1;\n\t\t\tif(q==f[p])continue;\n\t\t\tf[q]=t.go(f[p],q);\n\t\t\tg[q]=g[p]+1;\n\t\t\tdfs(q,p);\n\t\t}\n\t}\n\tint getans()\n\t{\n\t\tint ret=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(!f[i])continue;\n\t\t\tif(f[i]!=i && isit[i])return -1;\n//\t\t\tprintf(\"%d %d %d\\n\",i,f[i],g[i]);\n\n\t\t\tcheck_max(g[i]+t.dis(i,f[i]),ret);\n\t\t}\n\t\treturn ret*2;\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tdfs();\n\t\tprintf(\"%d\\n\",getans());\n\t}\n}\nint main()\n{\n//\tfreopen(\"in\",\"r\",stdin);\n\twrong::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define SF scanf\n#define PF printf\n#define MAXN 200010\nusing namespace std;\nint n, x, y;\nvector<int> a[MAXN], b[MAXN];\nint depA[MAXN], depB[MAXN];\nint fa[MAXN][21];\nvoid dfsA(int x, int f) {\n    depA[x] = depA[f] + 1;\n    for (int i = 0; i < a[x].size(); i++) {\n        int u = a[x][i];\n        if (u == f) continue;\n        dfsA(u, x);\n    }\n}\nvoid dfsB(int x, int f) {\n    depB[x] = depB[f] + 1;\n    fa[x][0] = f;\n    for (int i = 1; i < 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n    for (int i = 0; i < b[x].size(); i++) {\n        int u = b[x][i];\n        if (u == f) continue;\n        dfsB(u, x);\n    }\n}\nint lca(int u, int v) {\n    if (depB[u] < depB[v]) swap(u, v);\n    for (int i = 19; i >= 0; i--)\n        if (depB[fa[u][i]] >= depB[v]) u = fa[u][i];\n    if (u == v) return u;\n    for (int i = 19; i >= 0; i--)\n        if (fa[u][i] != fa[v][i]) {\n            u = fa[u][i];\n            v = fa[v][i];\n        }\n    return fa[u][0];\n}\nint ans;\nvoid dfs(int x, int f) {\n    if (depA[x] >= depB[x]) return;\n    if (ans != -1) ans = max(ans, (depB[x] - 1) * 2);\n    for (int i = 0; i < a[x].size(); i++) {\n        int u = a[x][i];\n        if (u == f) continue;\n        if (depB[u] + depB[x] - 2 * depB[lca(u, x)] > 2) ans = -1;\n        dfs(u, x);\n    }\n}\nint main() {\n    while (SF(\"%d%d%d\", &n, &x, &y) != EOF) {\n        int u, v;\n        for (int i = 1; i < n; i++) {\n            SF(\"%d%d\", &u, &v);\n            a[u].push_back(v);\n            a[v].push_back(u);\n        }\n        for (int i = 1; i < n; i++) {\n            SF(\"%d%d\", &u, &v);\n            b[u].push_back(v);\n            b[v].push_back(u);\n        }\n        dfsA(x, 0);\n        dfsB(y, 0);\n        ans = 0;\n        dfs(x, 0);\n        PF(\"%d\\n\", ans);\n        for (int i = 1; i <= n; i++) {\n            a[i].clear();\n            b[i].clear();\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int NN = 2e5 + 5;\nstruct E {\n\tint v, nxt;\n\tE(int _v=0, int _nxt=0) : v(_v), nxt(_nxt) {}\n};\nstruct Graph {\n\tint head[NN], totE;\n\tE edge[NN*2];\n\tvoid AddEdge(int u, int v) {\n\t\tedge[++totE] = E(v, head[u]);\n\t\thead[u] = totE;\n\t}\n} a, b;\nint N, X, Y, da[NN], db[NN], fab[NN];\nbool save[NN];\nvoid Dfs1(int u, int fr) {\n\tfab[u] = fr;\n\tdb[u] = db[fr] + 1;\n\tfor (int p = b.head[u]; p; p = b.edge[p].nxt) {\n\t\tint v = b.edge[p].v; //注意两棵树别用串了 \n\t\tif (v != fr)\n\t\t\tDfs1(v, u);\n\t}\n}\nbool inf, edgetag[NN];\nvoid Dfs2(int u, int fr) {\n\tda[u] = da[fr] + 1;\n\tif (da[u] >= db[u]) ;\n\telse save[u] = 1;\n\tif (fr != 0) {\n\t\tint x = u, y = fr;\n\t\tif (db[x] < db[y]) swap(x, y);\n\t\tif (fab[x] == fab[y] || fab[x] == y || fab[fab[x]] == y) ;\n\t\telse {\n\t\t\tinf = 1;\n\t\t\tedgetag[u] = 1;\n\t\t}\n\t}\n\tfor (int p = a.head[u]; p; p = a.edge[p].nxt) {\n\t\tint v = a.edge[p].v;\n\t\tif (v != fr) {\n\t\t\tDfs2(v, u);\n\t\t\tif (edgetag[v])\n\t\t\t\tinf = 1;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ta.AddEdge(u, v);\n\t\ta.AddEdge(v, u);\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb.AddEdge(u, v);\n\t\tb.AddEdge(v, u);\n\t}\n\tDfs1(Y, 0);\n\tDfs2(X, 0);\n\tif (inf) printf(\"-1\\n\");\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tif (save[i])\n\t\t\t\tans = max(ans, db[i]-1);\n\t\tans *= 2;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 400004\nint a[2][N],b[2][N],c[2][N],e[N],f[N],h[N],i,l,n,q[N],r,s[N],t,x,y;bool d[N][2];\ninline bool cmp(int u,int v){return f[u]!=v&&u!=f[v]&&f[u]!=f[v]&&f[f[u]]!=v&&u!=f[f[v]];}\nint u,v;\nint main()\n{\n\tfor(scanf(\"%d%d%d\",&n,&x,&y),i=t=1;i<n;i++)scanf(\"%d%d\",&u,&v),b[0][++t]=a[0][u],c[0][a[0][u]=t]=v,b[0][++t]=a[0][v],c[0][a[0][v]=t]=u;\n\tfor(i=t=1,e[n]=-1;i<n;e[i++]=-1)scanf(\"%d%d\",&u,&v),b[1][++t]=a[1][u],c[1][a[1][u]=t]=v,b[1][++t]=a[1][v],c[1][a[1][v]=t]=u;\n\tfor(d[q[r++]=y][e[y]=1]=true,d[q[r++]=x][e[x]=0]=true,e[y]=1;l<r;)for(v=e[u=q[l++]],i=a[v][u];i;i=b[v][i])if(e[c[v][i]]<e[u])d[q[r++]=c[v][i]][e[c[v][i]]=e[u]]=true,f[c[v][i]]=u,h[c[v][i]]=h[u]+1;\n\tfor(i=1;i<n;i++)if(cmp(c[0][i<<1],c[0][i<<1|1])&&*d[c[0][i<<1]]&&*d[c[0][i<<1|1]])return 0&puts(\"-1\");\n\tfor(i=1,v=0;i<=n;i++)if(*d[i]&&v<h[i])v=h[i];\n\treturn 0&printf(\"%d\\n\",v<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <bitset>\n#include <random>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <functional>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < int(b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> int(a);)\n#define all(v) v.begin(),v.end()\n#define trav(x, v) for(auto &x : v)\n#define sz(v) int((v).size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long double ld;\n\nconst int lg = 20;\n\nstruct tree {\n\tint n;\n\tvector<vi> gr;\n\tvi par, h;\n\tvector<vi> hopp;\n\tvoid dfs(int v){\n\t\ttrav(u, gr[v]) if(u != par[v]){\n\t\t\tpar[u] = v;\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u);\n\t\t}\n\t}\n\ttree(vector<vi> gr) : gr(gr) {\n\t\tn = sz(gr);\n\t\tpar.resize(n), h.resize(n);\n\t\thopp.resize(lg, vi(n));\n\n\t\tdfs(0);\n\n\t\thopp[0] = par;\n\t\trep(t,1,lg) rep(i,0,n)\n\t\t\thopp[t][i] = hopp[t-1][hopp[t-1][i]];\n\t}\n\tint jump(int a, int steps){\n\t\tfor(int i = 0; steps; ++i){\n\t\t\tif(steps&1) a = hopp[i][a];\n\t\t\tsteps /= 2;\n\t\t}\n\t\treturn a;\n\t}\n\tint lca(int a, int b){\n\t\tif(h[a] > h[b]) swap(a,b);\n\t\tb = jump(b, h[b] - h[a]);\n\t\tif(a == b) return a;\n\t\trrep(i,0,lg){\n\t\t\tint aa = hopp[i][a], bb = hopp[i][b];\n\t\t\tif(aa != bb){\n\t\t\t\ta = aa, b = bb;\n\t\t\t}\n\t\t}\n\t\treturn par[b];\n\t}\n\tint dist(int a, int b){\n\t\tint c = lca(a,b);\n\t\treturn h[a] + h[b] - 2*h[c];\n\t}\n\tint closer(int v, int y){\n\t\tif(v == y) return v;\n\t\tint r = lca(v, y);\n\t\tif(y != r) return par[y];\n\t\treturn jump(v, h[v]-h[y]-1);\n\t}\n};\n\nvoid noend(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n, x, y;\n\tcin >> n >> x >> y;\n\t--x, --y;\n\tvector<vi> gred(n), gblue(n);\n\n\trep(_,0,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a,--b;\n\t\tgred[a].push_back(b);\n\t\tgred[b].push_back(a);\n\t}\n\trep(_,0,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a,--b;\n\t\tgblue[a].push_back(b);\n\t\tgblue[b].push_back(a);\n\t}\n\ttree blue(gblue);\n\tint ans = 0;\n\tvector<bool> vis(n);\n\tqueue<pii> ko;\n\tko.push(pii(x, y));\n\tvis[x] = 1;\n\twhile(!ko.empty()){\n\t\tpii pa = ko.front();\n\t\tko.pop();\n\t\tans = max(ans, 2 * blue.dist(pa.first, y));\n\t//\tcout << pa.first+1 << ' ' << pa.second+1 << endl;\n\t\tif(pa.first == pa.second) continue;\n\t\ttrav(x1, gred[pa.first]) if(!vis[x1]){\n\t\t\tif(blue.dist(x1, pa.first) > 2)\n\t\t\t\tnoend();\n\t\t\tvis[x1] = 1;\n\t\t\tko.push(pii(x1, blue.closer(x1, pa.second)));\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,X,Y;\nint par[20][200010],dep[200010];\nvector<int> R[200010],B[200010];\nint INF = 1001001001;\nint ans = 0;\nbool in[200010];\n\nint LCA(int x,int y)\n{\n    if(dep[x] > dep[y])swap(x,y);\n    int dif = dep[y] - dep[x];\n    for(int i = 19; i >= 0; i--)if(dif & (1 << i))y = par[i][y];\n    if(x == y)return x;\n    for(int i = 19; i >= 0; i--)\n    {\n        if(par[i][x] != par[i][y])\n        {\n            x = par[i][x];\n            y = par[i][y];\n        }\n    }\n    return par[0][x];\n}\n\nint dis(int x,int y)\n{\n    return dep[x] + dep[y] - 2 * dep[LCA(x,y)];\n}\n\nvoid DFS(int v,int p,int d)\n{\n    par[0][v] = p;\n    dep[v] = d;\n    for(int i = 0; i < B[v].size(); i++)\n    {\n        int w = B[v][i];\n        if(w == p)continue;\n        DFS(w,v,d + 1);\n    }\n    return;\n}\n\nvoid DFS2(int v,int p)\n{\n    in[v] = true;\n    for(int i = 0; i < R[v].size(); i++)\n    {\n        int w = R[v][i];\n        if(w == p || dis(v,w) > 2)continue;\n        DFS2(w,v);\n    }\n    return;\n}\n\nvoid DFS3(int v,int p,int d)\n{\n    if(d >= dis(Y,v) || !in[v])return;\n    ans = max(ans,dis(Y,v) * 2);\n    for(int i = 0; i < R[v].size(); i++)\n    {\n        int w = R[v][i];\n        if(w == p)continue;\n        if(!in[w])ans = INF;\n        DFS3(w,v,d + 1);\n    }\n    return;\n}\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&X,&Y);\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        R[a].push_back(b);\n        R[b].push_back(a);\n    }\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        B[a].push_back(b);\n        B[b].push_back(a);\n    }\n\n    DFS(1,0,0);\n\n    for(int i = 1; i < 20; i++)\n    {\n        for(int j = 1; j <= N; j++)\n        {\n            if(par[i - 1][j] == 0)par[i][j] = 0;\n            else par[i][j] = par[i - 1][par[i - 1][j]];\n        }\n    }\n\n    DFS2(X,0);\n\n    DFS3(X,0,0);\n\n    if(ans == INF)printf(\"-1\\n\");\n    else printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nP dp[200005];\nint lca[200005][18],dist2[200005];\nint calc(int x,int y){\n\tif(dist2[x] > dist2[y]) swap(x,y);\n\trep(i,18){\n\t\tif((((dist2[y]-dist2[x])>>i)&1)){\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\tfor(int i=17;i>=0;i--){\n\t\tif(lca[x][i] != lca[y][i]){\n\t\t\tx = lca[x][i];\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\treturn (x==y?x:lca[x][0]);\n}\nbool fe;\nint go(int a,int b){\n\tint c = calc(a,b);\n\tif(a == c){\n\t\tfor(int i=0;i<18;i++){\n\t\t\tif((((dist2[b]-dist2[a]-1)>>i)&1)){\n\t\t\t\tb = lca[b][i];\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\telse{\n\t\treturn lca[a][0];\n\t}\n}\nint ret = 0;\nvoid dfs(int v,int u,int d){\n\tif(dp[v].fi > 0){\n\t\tret = max(ret,2*d+dp[v].fi*2);\n\t}\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint D = dist2[v]+dist2[edge[v][i]]-2*dist2[calc(v,edge[v][i])];\n\t\t//cout << v << \" \" << edge[v][i] << \" \" << \" \" << calc(v,edge[v][i]) << D << endl;\n\t\tif(D>=3 && lca[edge[v][i]][0] != dp[v].sc && lca[dp[v].sc][0] != edge[v][i] && edge[v][i] != dp[v].sc){\n\t\t\tcout << v << edge[v][i] << dp[v].sc << endl; fe = 1;\n\t\t}\n\t\telse {\n\t\t\tD = dist2[edge[v][i]]+dist2[dp[v].sc]-2*dist2[calc(edge[v][i],dp[v].sc)];\n\t\t\tif(D<=1){\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(0,edge[v][i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(D-1,go(dp[v].sc,edge[v][i])));\n\t\t\t\tdfs(edge[v][i],v,d+1);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d; lca[v][0] = u;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs2(b,-1,0);\n\tdp[a] = mp(dist2[a],b);\n\tfor(int j=0;j<17;j++) for(int i=1;i<=n;i++){\n\t\tif(lca[i][j] == -1) lca[i][j+1] = -1;\n\t\telse lca[i][j+1] = lca[lca[i][j]][j];\n\t}\n\tdfs(a,-1,0);\n\tif(fe) puts(\"-1\");\n\telse cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nP dp[200005];\nint lca[200005][18],dist2[200005];\nint calc(int x,int y){\n\tif(dist2[x] > dist2[y]) swap(x,y);\n\trep(i,18){\n\t\tif((((dist2[y]-dist2[x])>>i)&1)){\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\tfor(int i=17;i>=0;i--){\n\t\tif(lca[x][i] != lca[y][i]){\n\t\t\tx = lca[x][i];\n\t\t\ty = lca[y][i];\n\t\t}\n\t}\n\treturn (x==y?x:lca[x][0]);\n}\nbool fe;\nint go(int a,int b){\n\tint c = calc(a,b);\n\tif(a == c){\n\t\tfor(int i=0;i<18;i++){\n\t\t\tif((((dist2[b]-dist2[a]-1)>>i)&1)){\n\t\t\t\tb = lca[b][i];\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n\telse{\n\t\treturn lca[a][0];\n\t}\n}\nint ret = 0;\nvoid dfs(int v,int u,int d){\n\tif(dp[v].fi >= 0){\n\t\tret = max(ret,2*d+dp[v].fi*2);\n\t}\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint D = dist2[v]+dist2[edge[v][i]]-2*dist2[calc(v,edge[v][i])];\n\t\t//cout << v << \" \" << edge[v][i] << \" \" << \" \" << calc(v,edge[v][i]) << D << endl;\n\t\tif(D>=3 && lca[edge[v][i]][0] != dp[v].sc && lca[dp[v].sc][0] != edge[v][i] && edge[v][i] != dp[v].sc){\n\t\t\t\n\t\t\tfe = 1;\n\t\t}\n\t\telse {\n\t\t\tD = dist2[edge[v][i]]+dist2[dp[v].sc]-2*dist2[calc(edge[v][i],dp[v].sc)];\n\t\t\tif(D<=1){\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(0,edge[v][i]));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[edge[v][i]] = max(dp[edge[v][i]],mp(D-1,go(dp[v].sc,edge[v][i])));\n\t\t\t\tdfs(edge[v][i],v,d+1);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d; lca[v][0] = u;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs2(b,-1,0);\n\tdp[a] = mp(dist2[a],b);\n\tfor(int j=0;j<17;j++) for(int i=1;i<=n;i++){\n\t\tif(lca[i][j] == -1) lca[i][j+1] = -1;\n\t\telse lca[i][j+1] = lca[lca[i][j]][j];\n\t}\n\tdfs(a,-1,0);\n\tif(fe) puts(\"-1\");\n\telse cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstdlib>\nconst int N=1e5+3,K=17;\nstd::vector<int>g1[N],g2[N];\nint n,rt1,rt2,d1[N],d2[N],fa[N][K],ans;\ninline int Lca(int u,int v){\n\tif(d2[u]<d2[v])std::swap(u,v);\n\tfor(int j=K-1;~j;j--)if(d2[fa[u][j]]>=d2[v])\n\t  u=fa[u][j];\n\tif(u==v)return u;\n\tfor(int j=K-1;~j;j--)if(fa[u][j]!=fa[v][j])\n\t  u=fa[u][j],v=fa[v][j];\n\treturn fa[u][0];\n}\nvoid Dfs2(int u){\n\tint v;\n\tfor(int j=1;j<K;j++)fa[u][j]=fa[fa[u][j-1]][j-1];\n\tfor(int i=0;i<g2[u].size();i++)if((v=g2[u][i])!=fa[u][0])\n\t  d2[v]=d2[u]+1,fa[v][0]=u,Dfs2(v);\n}\nvoid Dfs1(int u,int fa){\n\tint v;\n\tif(d1[u]>=d2[u])return;\n\tfor(int i=0;i<g1[u].size();i++){\n\t  v=g1[u][i];\n\t  if(d2[u]+d2[v]-2*d2[Lca(u,v)]>2)exit(0*puts(\"-1\"));\n\t}\n\tans=std::max(ans,d2[u]);\n\tfor(int i=0;i<g1[u].size();i++)if((v=g1[u][i])!=fa)\n\t  d1[v]=d1[u]+1,Dfs1(v,u);\n}\nint main(){\n\tint u,v;\n\tscanf(\"%d%d%d\",&n,&rt1,&rt2);\n\tfor(int i=1;i<n;i++)\n\t  scanf(\"%d%d\",&u,&v),g1[u].push_back(v),g1[v].push_back(u);\n\tfor(int i=1;i<n;i++)scanf(\"%d%d\",&u,&v),g2[u].push_back(v),g2[v].push_back(u);\n\tDfs2(rt2);\n\tDfs1(rt1,0);\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int INF=1e9;\nstruct node{\n\tint s,t;\n}w1[200100],w2[200100];\nint beg[200100],nex[400100],tto[400100],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint n;\nvoid clear(){\n\te=1;\n\tfor(int i=0;i<=n;i++)\n\t\tbeg[i]=0;\n}\nbool vis[200100];\nint f[200100];\nint dis[200100];\nvoid getfa(int u){\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==f[u]) continue;\n\t\tf[tto[i]]=u;\n\t\tdis[tto[i]]=dis[u]+1;\n\t\tgetfa(tto[i]);\n\t}\n}\nint ans;\nvoid dfs(int u,int fa,int dep){\n\tif(dis[u]>ans) ans=dis[u];\n\tif(dep>=dis[u]) return;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tif(vis[i>>1]){\n\t\t\tans=INF;\n\t\t\treturn;\n\t\t}\n\t\tdfs(tto[i],u,dep+1);\n\t}\n}\nint main(){\n//\tfreopen(\"b.in\",\"r\",stdin);\n//\tfreopen(\"b.out\",\"w\",stdout);\n\tint A,B;\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif(A==B){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tclear();\n\tfor(int i=1;i<n;i++)\n\t\tscanf(\"%d%d\",&w1[i].s,&w1[i].t);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&w2[i].s,&w2[i].t);\n\t\tputin(w2[i].s,w2[i].t);\n\t\tputin(w2[i].t,w2[i].s);\n\t}\n\tgetfa(B);\n\tclear();\n\tfor(int i=1;i<n;i++){\n\t\tif(f[w1[i].s]!=f[w1[i].t]&&f[f[w1[i].s]]!=w1[i].t&&\n\t\t\t\tw1[i].s!=f[f[w1[i].t]]&&f[w1[i].s]!=w1[i].t&&f[w1[i].t]!=w1[i].s)\n\t\t\tvis[i]=1;\n\t\telse\n\t\t\tvis[i]=0;\n\t\tputin(w1[i].s,w1[i].t);\n\t\tputin(w1[i].t,w1[i].s);\n\t}\n\tdfs(A,-1,0);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 200010;\nstruct graph {\n\tint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\n\tvoid addedge(int b, int e) {\n\t\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\t\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n\t}\n} A, B;\nint * head, * nxt, * to;\nvoid init(graph * X) { head = X->head, nxt = X->nxt, to = X->to; }\nint dep[MAXN], fa[MAXN];\nvoid dfs(int u) {\n\tfor (int i = head[u]; i; i = nxt[i])\n\t\tif (to[i] != fa[u]) {\n\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\tfa[to[i]] = u;\n\t\t\tdfs(to[i]);\n\t\t}\n}\nint dis12(int u, int v) {\n\tif (dep[u] > dep[v]) std::swap(u, v);\n\treturn fa[v] == u || fa[fa[v]] == u || fa[u] == fa[v];\n}\nint n, X, Y, ans;\nvoid dfs2(int u, int fa = 0, int dep = 0) {\n\tif (fa && !dis12(fa, u))\n\t\texit((std::cout << -1 << std::endl, 0));\n\tif (dep > ::dep[u]) return ;\n\tans = std::max(ans, ::dep[u]);\n\tif (dep == ::dep[u]) return ;\n\tfor (int i = head[u]; i; i = nxt[i])\n\t\tif (to[i] != fa)\n\t\t\tdfs2(to[i], u, dep + 1);\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> X >> Y;\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, A.addedge(t1, t2);\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, B.addedge(t1, t2);\n\tinit(&B); dfs(Y);\n\tinit(&A); dfs2(X);\n\tstd::cout << ans * 2 << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5+7, K = 18;\n\nstruct Tree{\n    vector<int> adj[N];\n\n    int anc[N][K];\n    int level[N];\n    bool mark[N];\n    int dis[N];\n\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    void setup(int u, int par) {\n        level[u] = level[par]+1;\n        anc[u][0] = par;\n        for (int k=1; k<K; k++)     anc[u][k] = anc[anc[u][k-1]][k-1];\n\n        for (int v: adj[u]) {\n            if (v == par)   continue;\n            setup(v, u);\n        }\n    }\n\n    int lca(int u, int v) {\n        if (level[u] > level[v])    swap(u, v);\n        for (int k=K-1; k>=0; k--)\n            if (level[u] + (1<<k) <= level[v])  v = anc[v][k];\n\n        if (u == v) return u;\n        for (int k=K-1; k>=0; k--)\n            if (anc[u][k] != anc[v][k])\n                u = anc[u][k], v = anc[v][k];\n        return anc[u][0];\n    }\n\n    int getanc(int u, int d) {\n        for (int k=0; k<K; k++)\n            if (d & (1<<k))\n                u = anc[u][k];\n        return u;\n    }\n\n    int dist(int u, int v) {\n        int g = lca(u, v);\n        return level[u] + level[v] - 2*level[g];\n    }\n\n    int solve(int u, int par, int dep) {\n        if (dis[u] <= dep)  return 0;\n        if (mark[u])        return N;\n        int ans = dis[u];\n        for (int v: adj[u]) {\n            if (v == par)   continue;\n            ans = max(solve(v, u, dep+1), ans);\n        }\n        return ans;\n    }\n};\n\n\n///Given u, v, d per query find dth node (0 indexed) on path from u to v.\n///https://codeforces.com/gym/102694/problem/C\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin>>n;\n\n    int x, y;\n    cin>>x>>y;\n\n    Tree red, blue;\n\n    for (int i=1; i<n; i++) {\n        int u, v;\n        cin>>u>>v;\n        red.addEdge(u, v);\n    }\n\n    for (int i=1; i<n; i++) {\n        int u, v;\n        cin>>u>>v;\n        blue.addEdge(u, v);\n    }\n\n    red.setup(1, 0);\n    blue.setup(1, 0);\n\n    for (int i=1; i<=n; i++) {\n        bool found = false;\n        for (int v: red.adj[i]) {\n            if (blue.dist(i, v) >= 3)   found = true;\n        }\n        red.mark[i] = found;\n        red.dis[i] = blue.dist(y, i);\n    }\n    int ans = red.solve(x, 0, 0);\n    if (ans == N)   ans = -1;\n    else            ans *= 2;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nconst int MAXN = 2E5 + 10, MAXD = 19;\n\nint n;\nint X, Y;\nvector<int> E[MAXN], F[MAXN];\n\n/* for F */\nint dep[MAXN];\nint p[MAXD][MAXN];\n\n/* for E */\nbool mark[MAXN];\n\nvoid DFS(int u, int pre){\n\tdep[u] = dep[pre] + 1;\n\tp[0][u] = pre;\n\tfor (int v, i = 0; i < F[u].size(); ++i){\n\t\tif ((v = F[u][i]) == pre)\n\t\t\tcontinue;\n\t\tDFS(v, u);\n\t}\n}\n\nvoid LCA_build(int n){\n\tfor (int i = 1; i < MAXD; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tp[i][j] = p[i - 1][p[i - 1][j]];\n}\n\nint LCA_query(int u, int v){\n\tif (dep[u] < dep[v])\n\t\tswap(u, v);\n\tfor (int t = dep[u] - dep[v], i = 0; t; t >>= 1, ++i)\n\t\tif (t & 1)\n\t\t\tu = p[i][u];\n\tif (u == v)\n\t\treturn u;\n\tfor (int i = MAXD - 1; i >= 0; --i)\n\t\tif (p[i][u] != p[i][v])\n\t\t\tu = p[i][u], v = p[i][v];\n\treturn p[0][u];\n}\n\nint LCA_dis(int u, int v){\n\treturn dep[u] + dep[v] - (dep[LCA_query(u, v)] << 1);\n}\n\nint ans;\n\nvoid DFS2(int u, int pre, int dep){\n\tint t;\n\tif (dep >= (t = LCA_dis(u, Y)))\n\t\treturn;\n\tans = max(ans, t);\n\tif (mark[u])\n\t\tans = n + 1;\n\tfor (int v, i = 0; i < E[u].size(); ++i){\n\t\tif ((v = E[u][i]) == pre || v == Y)\n\t\t\tcontinue;\n\t\tDFS2(v, u, dep + 1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &X, &Y);\n\tfor (int u, v, i = 1; i < n; ++i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tfor (int u, v, i = 1; i < n; ++i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tF[u].push_back(v);\n\t\tF[v].push_back(u);\n\t}\n\tDFS(1, 0);\n\tLCA_build(n);\n\tfor (int i = 1; i <= n; ++i){\n\t\tfor (int j = 0; j < E[i].size(); ++j)\n\t\t\tif (LCA_dis(i, E[i][j]) >= 3)\n\t\t\t\tmark[i] = true;\n\t}\n\tDFS2(X, 0, 0);\n\tprintf(\"%d\\n\", ans <= n ? ans << 1 : -1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=200005;\n\nint n,cnt,last[N],fa[N],dep[N],dis[N],q[N],dfn[N],mx[N],tim,a[N][2],sx,sy;\nbool vis[N],win[N];\nstruct edge{int to,next,col;}e[N*4];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid addedge(int u,int v,int col)\n{\n\te[++cnt].to=v;e[cnt].col=col;e[cnt].next=last[u];last[u]=cnt;\n\te[++cnt].to=u;e[cnt].col=col;e[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n\tdep[x]=dep[fa[x]]+1;dfn[x]=++tim;\n\tfor (int i=last[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa[x]) fa[e[i].to]=x,dfs(e[i].to);\n\tmx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n\tif (dfn[x]>dfn[y]) swap(x,y);\n\tif (dfn[x]<dfn[y]&&mx[x]>dfn[y]) return dep[y]-dep[x]>2;\n\tif (fa[x]==fa[y]) return 0;\n\treturn 1;\n}\n\nvoid bfs()\n{\n\tint h=1,t=1;q[1]=sx;vis[sx]=1;\n\twhile (h<=t)\n\t{\n\t\tint x=q[h++];\n\t\tfor (int i=last[x];i;i=e[i].next)\n\t\t\tif (!e[i].col&&!vis[e[i].to])\n\t\t\t{\n\t\t\t\tdis[e[i].to]=dis[x]+1;\n\t\t\t\tif (dis[e[i].to]<dep[e[i].to]) vis[e[i].to]=1,q[++t]=e[i].to;\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();sx=read();sy=read();\n\tfor (int i=1;i<n;i++) a[i][0]=read(),a[i][1]=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\taddedge(x,y,1);\n\t}\n\tdep[0]=-1;dfs(sy);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tif (check(a[i][0],a[i][1])) win[a[i][0]]=win[a[i][1]]=1;\n\t\telse addedge(a[i][0],a[i][1],0);\n\t}\n\tbfs();\n\tfor (int i=1;i<=n;i++) if (win[i]&&vis[i]) {puts(\"-1\");return 0;}\n\tint ans=0;\n\tfor (int i=1;i<=n;i++) if (vis[i]) ans=max(ans,dep[i]*2);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<vector>\n#define N 210000\n#define pb push_back\nusing namespace std;\nstruct node{int y,nex;}a[2*N];\nint e[N][2],len,fir[N],n,sa,sb,dep[N],dfn[N],las[N],id,f[N],p[N],tail,d[N],ans;\nbool b[N],v[N];\nvector<int> A[N];\nvoid ins(int x,int y)\n{\n    a[++len].y=y;a[len].nex=fir[x];fir[x]=len;\n}\nvoid dfs(int x,int fa)\n{\n    f[x]=fa;\n    dfn[x]=++id;\n    dep[x]=dep[fa]+1;\n    for(int k=fir[x];k;k=a[k].nex)\n    {\n        int y=a[k].y;\n        if(y==fa) continue;\n        dfs(y,x);\n    }\n    las[x]=id;\n}\nbool check(int x,int y)\n{\n    if(dep[x]>dep[y]) swap(x,y);\n    if(dfn[x]<=dfn[y] && las[x]>=dfn[y])\n    {\n        if(dep[y]-dep[x]>2) return 1;\n        return 0;\n    }\n    if(f[x]==f[y]) return 0;\n    return 1;\n}\nvoid bfs()\n{\n    v[sa]=1;p[1]=sa;tail=1;\n    for(int i=1;i<=tail;i++)\n    {\n        int x=p[i],siz=A[x].size();\n        for(int k=0;k<siz;k++)\n        {\n            int y=A[x][k];\n            d[y]=d[x]+1;\n            if(d[y]<dep[y] && v[y]==0) {v[y]=1;p[++tail]=y;}\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&sa,&sb);\n    for(int i=1;i<n;i++) scanf(\"%d%d\",&e[i][0],&e[i][1]);\n    for(int i=1;i<n;i++)\n    {\n        int x,y;scanf(\"%d%d\",&x,&y);\n        ins(x,y);ins(y,x);\n    }\n    dfs(sb,0);\n    for(int i=1;i<=n;i++) dep[i]--;\n    for(int i=1;i<n;i++)\n    {\n        int x=e[i][0],y=e[i][1];\n        if(check(x,y)) \n            b[x]=b[y]=1;\n        else A[e[i][0]].pb(e[i][1]),A[e[i][1]].pb(e[i][0]);\n    }\n    bfs();\n    for(int i=1;i<=n;i++) \n    {\n        if(v[i] && b[i]) {printf(\"-1\\n\");return 0;}\n        if(v[i]) ans=max(ans,dep[i]*2);\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define N 200005\n#define rep(i,j,k) for(i=j;i<=k;++i)\n#define down(i,j,k) for(i=j;i>=k;--i)\nstruct E{\n\tint to,nxt;\n}ed[2][N<<1];\nstruct node{\n\tint u,s;\n}t,nw;\nint x,y,n,i,j,k,top,u,v,s;\nint head[2][N],dep[N],anc[N][20];\nqueue<node> q;\nvoid read(int &p){\n\tp=0; char x=getchar();\n\twhile(x<'0' || x>'9') x=getchar();\n\twhile(x>='0'&&x<='9'){p=p*10+x-'0'; x=getchar();}\n}\nvoid add(int u,int v,int wh){\n\ttop++; ed[wh][top]=(E){v,head[wh][u]}; head[wh][u]=top;\n}\nvoid dfs(int x){\n\tint i,to;\n\trep(i,1,19) anc[x][i]=anc[anc[x][i-1]][i-1];\n\tfor(i=head[1][x];i;i=ed[1][i].nxt)\n\tif((to=ed[1][i].to)!=anc[x][0]){\n\t\tanc[to][0]=x; dep[to]=dep[x]+1;\n\t\tdfs(to);\n\t}\n}\nint dis(int u,int v){\n\tint i,tmp=dep[u]+dep[v];\n\tif(dep[u]<dep[v]) swap(u,v);\n\tdown(i,19,0)\n\tif(dep[anc[u][i]]>=dep[v]) u=anc[u][i];\n\tif(u==v) return tmp-(dep[u]<<1);\n\tdown(i,19,0)\n\tif(anc[u][i]!=anc[v][i]){\n\t\tu=anc[u][i]; v=anc[v][i];\n\t}\n\treturn tmp-(dep[anc[u][0]]<<1);\n}\nint main(){\n\tread(n); read(x); read(y);\n\trep(i,1,n-1){\n\t\tread(u); read(v);\n\t\tadd(u,v,0); add(v,u,0);\n\t}\n\ttop=0;\n\trep(i,1,n-1){\n\t\tread(u); read(v);\n\t\tadd(u,v,1); add(v,u,1);\n\t}\n\tdep[y]=1; dfs(y);\n\tt=(node){x,0}; q.push(t);\n\twhile(!q.empty()){\n\t\tt=q.front(); q.pop();\n\t\tu=t.u; s=t.s;\n\t\tfor(i=head[0][u];i;i=ed[0][i].nxt){\n\t\t\tv=ed[0][i].to;\n\t\t\tif(dis(u,v)>2) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(dep[v]-1>s+1){\n\t\t\t\tnw=(node){v,s+1};\n\t\t\t\tq.push(nw);\n\t\t\t}\n\t\t}\n\t\tif(dep[u]-1>s+1){\n\t\t\tnw=(node){u,s+1};\n\t\t\tq.push(nw);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(t.s+1)<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n \nconst int N = (int)2e5 + 9;\nvector<int> B[N];\nvector<int> R[N];\nbool black[N];\nint par[N];\nint lay[N];\n \nvoid dfs1(int u, int pp){ \n  par[u] = pp;\n  for(auto x : B[u]){\n    if(x == pp) continue;\n    lay[x] = lay[u] + 1;\n    dfs1(x,u);\n  }\n}\n \nint dis[N];\n \nvoid dfs2(int u, int pp){\n  if(dis[u] >= lay[u]){\n    dis[u] = (int)1e9;\n  }\n  for(auto x : R[u]){\n    if(x == pp) continue;\n    dis[x] = dis[u] + 1;\n    dfs2(x,u);\n  }\n}\n \nint main(){\n  fastIO;\n  int n, x, y;\n  cin >> n >> x >> y;\n  int u, v;\n  for(int i = 1 ; i < n; i ++ ){\n    cin >> u >> v;\n    R[u].push_back(v);\n    R[v].push_back(u);\n  }\n  for(int i = 1; i < n; i ++ ){\n    cin >> u >> v;\n    B[u].push_back(v);\n    B[v].push_back(u);\n  }\n  dfs1(y,0);\n  dfs2(x,0);\n  bool check;\n  for(int i = 1; i <= n; i ++ ){\n    for(auto j : R[i]){\n      check = true;\n      if(par[j] == i || par[par[j]] == i || par[i] == j || par[par[i]] == j || par[i] == par[j]) check = false;\n      if(check){\n        black[i] = true;\n        black[j] = true;\n      }\n    }\n  }\n  for(int i = 1; i <= n; i ++ ){\n    if(black[i] && dis[i] < (int)1e9){\n      cout << \"-1\\n\";\n      return 0;\n    }\n  }\n  int res = 2;\n  for(int i = 1; i <= n; i ++ ){\n    if(dis[i] >= (int)1e9) continue;\n    res = max(res, lay[i] * 2);\n  }\n  cout << res << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e5+5,LG=19,SM=4000+5,inf=1e18+1;\nll mod=924844033;\n\nll n;\nll ru[M],rv[M];\nll bu[M],bv[M];\nll h[M];\nbool spc[M];\nll dis[M];\nvll g[M],tr[M];\nll x,y;\nll par[M];\nbool acc[M];\n\nvoid dfs(ll x)\n{\n    for (ll y:tr[x])\n    {\n        if (par[x]==y) continue;\n        par[y]=x;\n        h[y]=h[x]+1;\n        dfs(y);\n    }\n}\n\nbool dis3(ll x,ll y)\n{\n    if (h[x]>h[y]) swap(x,y);\n    if (h[x]==h[y])\n        return par[x]==par[y];\n    else if (h[y]-h[x]==1)\n        return par[y]==x;\n    else return par[par[y]]==x;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n >> x >> y;\n    x--;\n    y--;\n    For(i,1,n)\n    {\n        ll u,v;\n        cin >> u >> v;\n        u--;v--;\n        ru[i]=u;\n        rv[i]=v;\n    }\n    For(i,1,n)\n    {\n        ll u,v;\n        cin >> u >> v;\n        u--;v--;\n        bu[i]=u;\n        bv[i]=v;\n        tr[u].PB(v);\n        tr[v].PB(u);\n    }\n    par[y]=y;\n    dfs(y);\n    For(i,1,n)\n    {\n        if (dis3(ru[i],rv[i]))\n        {\n            g[ru[i]].PB(rv[i]);\n            g[rv[i]].PB(ru[i]);\n        }\n        else\n            spc[ru[i]]=spc[rv[i]]=1;        \n    }\n    queue<ll> qu;\n    memset(dis,1,sizeof dis);\n    qu.push(x);\n    dis[x]=0;\n    while (SZ(qu))\n    {\n        ll f=qu.front();\n        qu.pop();\n        //ER(f);ER(dis[f]);ER(h[f]);\n        if (dis[f]>=h[f])\n        {\n            continue;\n        }\n        acc[f]=1;\n        for (ll y:g[f])\n        {\n        //ER(y);ER(dis[y]);ER(h[y]);\n            if (dis[y]>dis[f]+1)\n            {\n                \n                dis[y]=dis[f]+1;\n                qu.push(y);\n            }\n        }\n    }\n    ll res=0;\n    For(i,0,n)\n    {\n        if (acc[i])\n        {\n            smax(res,h[i]);\n            if (spc[i]) RET(-1);\n        }\n    }\n    RET(2*res);\n}    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\n#define MAX 200200\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next,col;}e[MAX<<2];\nint h[MAX],cnt=1,E[MAX][2];\ninline void Add(int u,int v,int col){e[cnt]=(Line){v,h[u],col};h[u]=cnt++;}\nint dfn[MAX],tim,fa[MAX],dep[MAX],low[MAX],dis[MAX],X,Y,n;\nbool inf[MAX],vis[MAX];\nvoid dfs(int u,int ff)\n{\n\tdfn[u]=++tim;fa[u]=ff;dep[u]=dep[ff]+1;\n\tfor(int i=h[u];i;i=e[i].next)\n\t\tif(e[i].col&&e[i].v!=ff)\n\t\t\tdfs(e[i].v,u);\n\tlow[u]=++tim;\n}\nbool check(int x,int y)\n{\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tif(low[x]>=low[y])return dep[y]-dep[x]>2;\n\tif(fa[x]==fa[y])return false;\n\treturn true;\n}\nvoid BFS()\n{\n\tqueue<int> Q;vis[X]=true;Q.push(X);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(!e[i].col&&!vis[e[i].v])\n\t\t\t{\n\t\t\t\tdis[e[i].v]=dis[u]+1;\n\t\t\t\tif(dis[e[i].v]<dep[e[i].v])\n\t\t\t\t\tvis[e[i].v]=true,Q.push(e[i].v);\n\t\t\t}\n\t}\n}\nint main()\n{\n\tn=read();X=read();Y=read();\n\tfor(int i=1;i<n;++i)E[i][0]=read(),E[i][1]=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=read(),v=read();\n\t\tAdd(u,v,1);Add(v,u,1);\n\t}\n\tdep[0]=-1;dfs(Y,0);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=E[i][0],v=E[i][1];\n\t\tif(check(u,v))inf[u]=inf[v]=true;\n\t\telse Add(u,v,0),Add(v,u,0);\n\t}\n\tBFS();\n\tfor(int i=1;i<=n;++i)if(vis[i]&&inf[i]){puts(\"-1\");return 0;}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)if(vis[i])ans=max(ans,dep[i]<<1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n#define ITER(it,a) for(__typeof(a.begin()) it=a.begin();it!=a.end();++it)\n#define DBG1(a) cerr<<#a<<\"=\"<<(a)<<\"\\n\"\n#define DBG2(a,b) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000*1000*1000 + 7;\nconst LL LINF = 1LL*INF*INF;\n\nconst LL MOD = 1000000007;\n\nconst int MAX = 200005;\n\nVI g[2][MAX];\n\nint d[2][MAX];\n\nint par[MAX];\n\n\nvoid dfs(int v,int ind,int p)\n{\n\tif(ind == 1)par[v] = p;\n\tFOR(i,0,SZ(g[ind][v]))\n\t{\n\t\tint to = g[ind][v][i];\n\t\tif(to == p)continue;\n\n\t\td[ind][to] = d[ind][v]+1;\n\t\tdfs(to,ind,v);\n\t}\n}\n\nint ans = 0;\nvoid getAns(int v,int p)\n{\n\tans = max(ans,d[1][v]);\n\tFOR(i,0,SZ(g[0][v]))\n\t{\n\t\tint to = g[0][v][i];\n\t\tif(to==p)continue;\n\n\t\tif(d[0][to]<d[1][to])getAns(to,v);\n\t}\n}\nset<PII> e2;\n\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//ios::sync_with_stdio(false);cin.tie(0);\n\n\tint n,r1,r2;\n\tcin>>n>>r1>>r2;\n\n\t--r1;--r2;\n\n\tFOR(ind,0,2)\n\tFOR(i,1,n)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tg[ind][a].PB(b);\n\t\tg[ind][b].PB(a);\n\t\tif(ind == 1)e2.insert(MP(min(a,b),max(a,b)));\n\t}\n\n\n\tdfs(r1,0,-1);\n\tdfs(r2,1,-1);\n\n\tFOR(i,0,n)\n\t{\n\t\tint p = par[i];\n\t\tif(p==-1 || par[p] == -1)continue;\n\t\tp = par[p];\n\t\te2.insert(MP(min(p,i),max(p,i)));\n\t}\n\n\tFOR(i,0,n)\n\tFOR(j,0,SZ(g[0][i]))\n\t{\n\t\tint to = g[0][i][j];\n\t\tint v = i;\n\t\tif(d[0][v] > d[0][to])swap(v,to);\n\n\t\tif(d[0][v] < d[1][v] && par[v]!=par[to] && !e2.count(MP(min(v,to),max(v,to))))\n\t\t{\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgetAns(r1,-1);\n\n\tcout<<ans*2;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,x,y;\nbool sp[SZ];\nnamespace T2\n{\nEdg\nint fa[SZ],dep[SZ];\nint sd(int a,int b)\n{\n\tif(a==b) return 0;\n\tif(a==fa[b]||b==fa[a]) return 1;\n\tif(fa[fa[a]]==b||a==fa[fa[b]]||fa[a]==fa[b])\n\t\treturn 2;\n\treturn 3;\n}\nvoid dfs(int x,int f=0,int d=0)\n{\n\tfa[x]=f; dep[x]=d;\n\tfor esb(x,e,b) if(b!=f) dfs(b,x,d+1);\n}\n}\nnamespace T1\n{\nEdg\nint mx;\nvoid dfs(int x,int f=0,int d=0)\n{\n\tif(d>=T2::dep[x]) return;\n\tmx=max(mx,T2::dep[x]-1); if(sp[x]) {mx=1e9; return;}\n\tfor esb(x,e,b) if(b!=f) dfs(b,x,d+1);\n}\n}\nint A[SZ],B[SZ];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;++i)\n\t\tscanf(\"%d%d\",A+i,B+i),T1::adde(A[i],B[i]);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tT2::adde(p,q);\n\t}\n\tT2::dfs(y);\n\tfor(int i=1;i<n;++i)\n\t\tif(T2::sd(A[i],B[i])==3)\n\t\t\tsp[A[i]]=sp[B[i]]=1;\n\tT1::dfs(x);\n\tif(T1::mx>1e8)\n\t\tputs(\"-1\");\n\telse printf(\"%d\\n\",T1::mx*2+2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=200010;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';x=(x<<1)+(x<<3)+ch-'0',ch=getchar());\n\treturn x*f;\n}\nstruct tree{\n\tint hea[maxn],nxt[maxn<<1],to[maxn<<1],tot;\n\tvoid add(int x,int y)\n\t{\n\t\tnxt[++tot]=hea[x];\n\t\thea[x]=tot;\n\t\tto[tot]=y;\n\t}\n}T[2];\nint dep[maxn][2],jump[maxn][20],maxx;\nvoid dfs(int now,int fa,int opt)\n{\n\tdep[now][opt]=dep[fa][opt]+1;\n\tif(opt==1)jump[now][0]=fa;\n\tfor(int i=T[opt].hea[now];i;i=T[opt].nxt[i])\n\t{\n\t\tint to=T[opt].to[i];\n\t\tif(to==fa)continue;\n\t\tdfs(to,now,opt);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x][1]<dep[y][1])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t\tif(dep[jump[x][i]][1]>=dep[y][1])\n\t\t\tx=jump[x][i];\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t\tif(jump[x][i]!=jump[y][i])\n\t\t\tx=jump[x][i],y=jump[y][i];\n\treturn jump[x][0];\n}\nvoid getans(int now,int fa)\n{\n\tif(dep[now][0]>=dep[now][1])return;\n\tif(fa)\n\t{\n\t\tint p=lca(now,fa);\n\t\tif(dep[now][1]+dep[fa][1]-2*dep[p][1]>2)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t}\n\tmaxx=max(maxx,dep[now][1]);\n\tfor(int i=T[0].hea[now];i;i=T[0].nxt[i])\n\t{\n\t\tint y=T[0].to[i];\n\t\tif(y==fa)continue;\n\t\tgetans(y,now);\n\t}\n}\nint main()\n{\n\tint n=read(),x=read(),y=read(),s,t;\n\tfor(int ii=0;ii<2;ii++)\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\ts=read(),t=read();\n\t\t\tT[ii].add(s,t);\n\t\t\tT[ii].add(t,s);\n\t\t}\n\tdfs(x,0,0),dfs(y,0,1);\n\tfor(int i=1;i<20;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tjump[j][i]=jump[jump[j][i-1]][i-1];\n\tgetans(x,0);\n\tprintf(\"%d\\n\",2*maxx-2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int Maxn = 200010;\nint sta, stb;\nvector <int> veca[Maxn], vecb[Maxn];\nint n, e[Maxn][2];\nint disa[Maxn], disb[Maxn], size[Maxn], dfn[Maxn], id, fa[Maxn];\nvoid dfs(int x) {\n\tint sz = vecb[x].size();\n\tsize[x] = 1; dfn[x] = ++id;\n\tfor(int i = 0; i < sz; i++){\n\t\tint y = vecb[x][i];\n\t\tif(y == fa[x]) continue;\n\t\tfa[y] = x; disb[y] = disb[x]+1; dfs(y);\n\t\tsize[x] += size[y];\n\t}\n}\nbool v[Maxn], bo[Maxn];\nbool check(int x, int y) {\n\tif(disb[x] < disb[y]) swap(x, y);\n\tif(disb[x]-disb[y] > 2) return true;\n\tif(dfn[y] <= dfn[x] && dfn[x] < dfn[y]+size[y]) return false;\n\tif(fa[x] == fa[y]) return false;\n\treturn true;\n}\nvoid bfs() {\n\tqueue <int> q;\n\tq.push(sta); bo[sta] = true;\n\twhile(!q.empty()){\n\t\tint x = q.front(); q.pop();\n\t\tint sz = veca[x].size();\n\t\tfor(int i = 0; i < sz; i++){\n\t\t\tint y = veca[x][i];\n\t\t\tdisa[y] = disa[x]+1;\n\t\t\tif(disa[y] < disb[y]) bo[y] = true, q.push(y);\n\t\t}\n\t}\n}\nint _max(int x, int y) { return x > y ? x : y; }\nint main() {\n\tint i, j, k;\n\tscanf(\"%d%d%d\", &n, &sta, &stb);\n\tfor(i = 1; i < n; i++) scanf(\"%d%d\", &e[i][0], &e[i][1]);\n\tfor(i = 1; i < n; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tvecb[x].push_back(y); vecb[y].push_back(x);\n\t}\n\tdfs(stb);\n\tfor(i = 1; i < n; i++){\n\t\tif(check(e[i][0], e[i][1])) v[e[i][0]] = v[e[i][1]] = true;\n\t\telse veca[e[i][0]].push_back(e[i][1]), veca[e[i][1]].push_back(e[i][0]);\n\t}\n\tbfs();\n\tint ans = 0;\n\tfor(i = 1; i <= n; i++){\n\t\tif(v[i] && bo[i]){ printf(\"-1\\n\"); return 0; }\n\t\tif(bo[i]) ans = _max(ans, disb[i]*2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e5 + 100, maxlg = 20;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, X, Y, par[2][maxn][maxlg], h[2][maxn], st[2][maxn], et[2][maxn], curt;\nvector<int> graph[2][maxn];\npair<int, int> edge[2][maxn], mn[2][maxn][maxlg];\nbool mode = true;\n\nvoid getH(int u, int prev, int tree)\n{\n\tst[tree][u] = curt++;\n\tfor (int i : graph[tree][u])\n\t\tif (i != prev)\n\t\t{\n\t\t\th[tree][i] = h[tree][u] + 1;\n\t\t\tgetH(i, u, tree);\n\t\t}\n\tet[tree][u] = curt;\n}\n\nbool isPar(int u, int v, int tree)\n{\n\treturn (st[tree][u] <= st[tree][v] && et[tree][v] <= et[tree][u]);\n}\n\nvoid prepLCA(int u, int prev, int tree)\n{\n\t//if (tree == 0 && u == 0)\n\t//\tcerr << '#' << mn[0][0][0].ff << ' ' << mn[0][0][0].ss << endl;\n\tfor (int i : graph[tree][u])\n\t\tif (i != prev)\n\t\t{\n\t\t\t//if (tree == 0 && i == 0)\n\t\t\t//\tcerr << \"PREP \" << i << ' ' << h[1][i] << endl;\n\t\t\tmn[tree][i][0] = mp(h[1][i], i);\n\t\t\tpar[tree][i][0] = u;\n\t\t\tfor (int j = 1; j < maxlg; j++)\n\t\t\t{\n\t\t\t\tpar[tree][i][j] = par[tree][par[tree][i][j - 1]][j - 1];\n\t\t\t\tmn[tree][i][j] = min(mn[tree][i][j - 1], mn[tree][par[tree][i][j - 1]][j - 1]);\n\t\t\t}\n\t\t\tprepLCA(i, u, tree);\n\t\t}\n}\n\nint parent(int u, int h, int tree)\n{\n\tfor (int i = 0; i < maxlg; i++)\n\t\tif ((h >> i) & 1)\n\t\t\tu = par[tree][u][i];\n\treturn u;\n}\n\npair<int, int> getMin(int u, int h, int tree)\n{\n\tpair<int, int> res = mp(mod, mod);\n\tfor (int i =  0; i < maxlg; i++)\n\t\tif ((h >> i) & 1)\n\t\t{\n\t\t\tres = min(res, mn[tree][u][i]);\n\t\t\tu = par[tree][u][i];\n\t\t}\n\treturn res;\n}\n\nint lca(int u, int v, int tree)\n{\n\tif (h[tree][u] < h[tree][v])\n\t\tswap(u, v);\n\tu = parent(u, h[tree][u] - h[tree][v], tree);\n\tif (u == v)\n\t\treturn u;\n\tfor (int i = maxlg - 1; i >= 0; i--)\n\t\tif (par[tree][u][i] != par[tree][v][i])\n\t\t{\n\t\t\tu = par[tree][u][i];\n\t\t\tv = par[tree][v][i];\n\t\t}\n\treturn par[tree][u][0];\n}\n\nint dist(int u, int v, int tree)\n{\n\tint LCA = lca(u, v, tree);\n\treturn (h[tree][u] + h[tree][v] - 2 * h[tree][LCA]);\n}\n\npair<int, int> minPath(int u, int v, int tree)\n{\n\tint LCA = lca(u, v, tree);\n\treturn min(mn[tree][LCA][0], min(getMin(u, h[tree][u] - h[tree][LCA], tree), getMin(v, h[tree][v] - h[tree][LCA], tree)));\n}\n\nint HANDLE(int u)\n{\n\t//if (mode)\n\t//\tcerr << \"MODE \" << u << endl;\n\tint vert = minPath(X, u, 0).ss;\n\tint distY = dist(Y, vert, 1), distX = dist(X, vert, 0);\n\t//cerr << \"HERE \" << u << ' ' << vert << ':' << distY << ' ' << distX << endl;\n\tif (distY > distX)\n\t{\n\t\tif (mode)\n\t\t\treturn -1;\n\t\treturn max(dist(X, u, 0), dist(Y, u, 1)) * 2;\n\t}\n\treturn distY + distX;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> X >> Y;\n\tX--;\n\tY--;\n\tfor (int tree = 0; tree < 2; tree++)\n\t{\n\t\tfor (int i = 0; i < maxlg; i++)\n\t\t\tpar[tree][Y][i] = Y, mn[tree][Y][i] = mp(0, Y);\n\t\tint u, v;\n\t\tfor (int i = 0; i < n - 1; i++)\n\t\t{\n\t\t\tcin >> u >> v;\n\t\t\tedge[tree][i] = mp(--u, --v);\n\t\t\tgraph[tree][u].pb(v);\n\t\t\tgraph[tree][v].pb(u);\n\t\t}\n\t}\n\n\tfor (int tree = 0; tree < 2; tree++)\n\t{\n\t\tcurt = 0;\n\t\tgetH(Y, -1, tree);\n\t}\n\tfor (int tree = 0; tree < 2; tree++)\n\t\tprepLCA(Y, -1, tree);\n\n\t/*for (int i = 0; i < n; i++)\n\t\tcerr << '_' << h[1][i];\n\tcerr << endl;\n\tfor (int i = 0; i < n; i++)\n\t\tcerr << '_' << mn[0][i][0].ff << ' ' << mn[0][i][0].ss;\n\tcerr << endl;*/\n\n\tint VERT = parent(X, h[1][X] - h[1][Y] - 1, 1);\n\n\t//cerr << \"delta h \" << h[1][X] - h[1][Y] << endl;\n\t//cerr << \"VERT \" << VERT << endl;\n\n\tbool win = false;\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint u = edge[0][i].ff, v = edge[0][i].ss;\n\t\tif (dist(u, v, 1) > 2)\n\t\t{\n\t\t\tif (dist(u, X, 0) > dist(v, X, 0))\n\t\t\t\tswap(u, v);\n\t\t\t//cerr << \"LONG EDGE \" << u << ' ' << v << endl;\n\t\t\tif (isPar(VERT, u, 1) && HANDLE(u) == -1)\n\t\t\t\twin = true;\n\t\t}\n\t}\n\tmode = false;\n\t//cerr << '#' << win << endl;\n\tif (win)\n\t\tcout << -1 << endl;\n\telse\n\t{\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (isPar(VERT, i, 1))\n\t\t\t{\n\t\t\t\t//cerr << \"HANDLE \" << i << ' ' << HANDLE(i) << endl;\n\t\t\t\tans = max(ans, HANDLE(i));\n\t\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define travel(x, i) for (int i = fir[x]; i; i = e[i].nxt)\n#define rep(i, x, y) for (int i = (x); i <= (y); i ++)\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2e5 + 5;\n\nnamespace Graph2 {\n    struct edge {\n\tint nxt, to;\n    } e[N << 1];\n    int fir[N], cnt = 0, dep[N], fa[N][18];\n\n    inline void addedge(int x, int y) {\n\te[++ cnt] = (edge){fir[x], y};\n\tfir[x] = cnt;\n    }\n    inline void Dfs(int x, int f) {\n\tdep[x] = dep[f] + 1;\n\tfa[x][0] = f;\n\trep(i, 1, 17)\n\t    fa[x][i] = fa[fa[x][i - 1]][i - 1];\n\ttravel(x, i)\n\t    if (e[i].to != f) Dfs(e[i].to, x);\n    }\n    inline int LCA(int x, int y) {\n\tif (dep[x] < dep[y]) swap(x, y);\n\tfor (int i = 17; (~ i) && dep[x] != dep[y]; i --)\n\t    if (dep[fa[x][i]] >= dep[y]) x = fa[x][i];\n\tif (x == y) return x;\n\tfor (int i = 17; (~ i) && fa[x][0] != fa[y][0]; i --)\n\t    if (fa[x][i] != fa[y][i]) {\n\t\tx = fa[x][i];\n\t\ty = fa[y][i];\n\t    }\n\treturn fa[x][0];\n    }\n    inline int Dis(int x, int y) {\n\treturn dep[x] + dep[y] - (dep[LCA(x, y)] << 1);\n    }\n}\n\nnamespace Graph1 {\n    struct edge {\n\tint nxt, to;\n    } e[N << 1];\n    int fir[N], cnt = 0, dep[N], MAX;\n    bool safe[N], flag;\n\n    inline void addedge(int x, int y) {\n\te[++ cnt] = (edge){fir[x], y};\n\tfir[x] = cnt;\n    }\n    inline void Dfs(int x, int f) {\n\tif (flag) return;\n\tdep[x] = dep[f] + 1;\n\tif (Graph2 :: dep[x] <= dep[x]) return;\n\tMAX = max(MAX, max(dep[x], Graph2 :: dep[x]) << 1);\n\tif (safe[x]) {\n\t    flag = 1;\n\t    return;\n\t}\n\ttravel(x, i)\n\t    if (e[i].to != f) Dfs(e[i].to, x);\n    }\n}\n\nusing namespace Graph1;\n\nint main() {\n    int n, x, y, u, v;\n    scanf(\"%d%d%d\", &n, &x, &y);\n    dep[0] = -1;\n    Graph2 :: dep[0] = -1;\n    rep(i, 1, n - 1) {\n\tscanf(\"%d%d\", &u, &v);\n\taddedge(u, v);\n\taddedge(v, u);\n    }\n    rep(i, 1, n - 1) {\n\tscanf(\"%d%d\", &u, &v);\n\tGraph2 :: addedge(u, v);\n\tGraph2 :: addedge(v, u);\n    }\n    Graph2 :: Dfs(y, 0);\n    rep(i, 1, n) {\n\ttravel(i, j) {\n\t    if (Graph2 :: Dis(i, e[j].to) >= 3) safe[i] = 1;\n\t}\n    }\n    Dfs(x, 0);\n    if (flag) puts(\"-1\");\n    else printf(\"%d\\n\", MAX);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<cmath>\n#include<stack>\n#include<algorithm>\n#define rg register\n#define ll long long\n#define LDB long double\n#define ull unsigned long long\n#define view(i,x) for(rg int i=hd[x];i!=-1;i=e[i].nt)\n#define go(i,x,a) for(rg int i=a;i<x;i++)\n#define inf 0x3f3f3f3f\n#define INF 0x7fffffff\nusing namespace std;\n\nconst int maxn=2e5+5;\nint n,X,Y,hd1[maxn],k1,hd2[maxn],k2,dep[maxn],p[maxn][21],tis[maxn];\nint ans=0;\nstruct edd{\n\tint nt,v;\n}e1[maxn*2],e2[maxn*2];\n\ninline int rd(){\n\tint ret=0,af=1; char gc=getchar();\n\twhile(gc < '0' || gc > '9'){ if(gc=='-') af=-af; gc=getchar(); }\n\twhile(gc >= '0' && gc <= '9') ret=ret*10+gc-'0',gc=getchar();\n\treturn ret*af;\n}\n\ninline void add1(int a,int b){\n\te1[k1].v=b; e1[k1].nt=hd1[a]; hd1[a]=k1++;\n\te1[k1].v=a; e1[k1].nt=hd1[b]; hd1[b]=k1++;\n}\n\ninline void add2(int a,int b){\n\te2[k2].v=b; e2[k2].nt=hd2[a]; hd2[a]=k2++;\n\te2[k2].v=a; e2[k2].nt=hd2[b]; hd2[b]=k2++;\n}\n\ninline void dfs(int x,int fa){\n\tp[x][0]=fa; dep[x]=dep[fa]+1;\n\tfor(rg int i=hd2[x];i!=-1;i=e2[i].nt){\n\t\tint v=e2[i].v; if(v == fa) continue;\n\t\tdfs(v,x);\n\t}\n}\n\nvoid pre(){\n\tgo(j,20,1)\n\t\tgo(i,n+1,1) p[i][j]=p[p[i][j-1]][j-1];\n}\n\ninline int lca(int x,int y){\n\tif(dep[x] > dep[y]) swap(x,y);\n\tfor(rg int j=19;j>=0;j--){\n\t\tif(dep[p[y][j]] < dep[x]) continue;\n\t\ty=p[y][j];\n\t}\n\tfor(rg int j=19;j>=0;j--){\n\t\tif(p[x][j] == p[y][j]) continue;\n\t\tx=p[x][j]; y=p[y][j];\n\t}\n\treturn x == y ? x : p[x][0];\n}\n\ninline int dis(int x,int y){\n\tint d=lca(x,y);\n\treturn dep[x]+dep[y]-dep[d]*2;\n}\n\nvoid walk(int x,int fa){\n\ttis[x]=tis[fa]+1;\n\tif(dep[x] < tis[x]) return ;\n\tif(ans != -1) ans=max(ans,dep[x]);\n\tif(dep[x] == tis[x]) return ;\n\tfor(rg int i=hd1[x];i!=-1;i=e1[i].nt){\n\t\tint v=e1[i].v; if(v == fa) continue;\n\t\tif(dis(x,v) >= 3){\n\t\t\tans=-1; return ;\n\t\t}\n\t\twalk(v,x);\n\t\tif(ans == -1) return ;\n\t}\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t#endif\n\tmemset(hd1,-1,sizeof(hd1)); k1=0;\n\tmemset(hd2,-1,sizeof(hd2)); k2=0;\n\tn=rd(); X=rd(); Y=rd(); int a,b;\n\tgo(i,n,1){ a=rd(); b=rd(); add1(a,b); }\n\tgo(i,n,1){ a=rd(); b=rd(); add2(a,b); }\n\tdep[0]=-1; dfs(Y,0); pre();\n\ttis[0]=-1; walk(X,0);\n\tprintf(\"%d\",ans == -1 ? -1 : ans*2);\n\treturn 0;\n}//Faze\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200100;\nint n,S,T,dis1[N],dis2[N],lst[N];\nvector<int>g1[N],g2[N];\nqueue<int>q;\nvoid bfs(int s,int*dis,vector<int>*g){\n\tfor(int i=1;i<=n;++i)dis[i]=n,lst[i]=0;\n\tdis[s]=0;q.push(s);\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i:g[u])\n\t\t\tif(dis[i]>dis[u]+1){\n\t\t\t\tlst[i]=u;dis[i]=dis[u]+1;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t}\n}\nint ans;\nvoid dfs(int x,int fa=-1){\n\tfor(int i:g1[x])if(i!=fa){\n\t\tif(dis1[i]<dis2[i])dfs(i,x);\n\t\tif(lst[i]!=x&&lst[x]!=i&&lst[x]!=lst[i]&&lst[lst[x]]!=i&&lst[lst[i]]!=x){\n\t\t\tcout<<-1<<'\\n';\n\t\t\texit(0);\n\t\t}\n\t}\n\tans=max(ans,dis2[x]);\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>S>>T;\n\tfor(int i=1;i<n;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg1[x].push_back(y);g1[y].push_back(x);\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg2[x].push_back(y);g2[y].push_back(x);\n\t}\n\tbfs(S,dis1,g1);bfs(T,dis2,g2);\n\tdfs(S);\n\tcout<<2*ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ Fast IO\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 200010;\n\nint n;\n\nvector<pair<int, int> >E;\n\nstruct Graph {\n\tint S;\n\tint tot;\n\tint fi[MAXN];\n\tint dep[MAXN];\n\tint fa[MAXN][20];\n\tint ne[MAXN << 1];\n\tint to[MAXN << 1];\n\n\tinline void Link(int u, int v) {\n\t\ttot++;\n\t\tto[tot] = v;\n\t\tne[tot] = fi[u];\n\t\tfi[u] = tot;\n\t}\n\n\tinline void dfs(int x, int la) {\n\t\tfa[x][0] = la, dep[x] = dep[la] + 1;\n\t\tfor(int i = 1; i < 20; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n\t\tfor(int i = fi[x]; i; i = ne[i]) {\n\t\t\tint u = to[i];\n\t\t\tif(u == la) continue;\n\t\t\tdfs(u, x);\n\t\t}\n\t}\n\n\tinline int LCA(int x, int y) {\n\t\tif(dep[x] < dep[y]) swap(x, y);\n\t\tint k = dep[x] - dep[y];\n\t\tfor(int i = 0; i < 20; i++)\n\t\t \tif(k & (1 << i)) x = fa[x][i];\n\t\tif(x == y) return x;\n\t\tfor(int i = 19; ~i; --i)\n\t\t\tif(fa[x][i] != fa[y][i])\n\t\t\t\tx = fa[x][i], y = fa[y][i];\n\t\treturn fa[x][0];\n\t}\n\n\tinline int dis(int u, int v) { return dep[u] + dep[v] - dep[LCA(u, v)] * 2; }\n\tinline int dis_S(int x) { return dep[x] - 1; }\n\n\tinline void AddEdge(int ty = 0) {\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tint u = ri, v = ri;\n\t\t\tLink(u, v), Link(v, u);\n\t\t\tif(ty) E.push_back(make_pair(u, v));\n\t\t} dfs(S, S);\n\t}\n}A, B;\n\nint chk[MAXN];\nint vis[MAXN];\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\n\tn = ri, A.S = ri, B.S = ri;\n\tA.AddEdge(1), B.AddEdge();\n\tfor(auto e : E) {\n\t\tint u = e.first, v = e.second;\n\t\tif(B.dis(u, v) > 2) {\n\t\t\tint miA = min(A.dep[u], A.dep[v]) - 1;\n\t\t\tint miB = min(B.dep[u], B.dep[v]) - 1;\n\t\t\tif(miA < miB) chk[u] = chk[v] = 1;\n\t\t}\n\t} int res = B.dep[A.S] - 1;\n\tqueue<int>q;\n\tq.push(A.S), vis[A.S] = 1;\n\twhile(!q.empty()) {\n\t\tint x = q.front(); q.pop();\n\t\tfor(int i = A.fi[x]; i; i = A.ne[i]) {\n\t\t\tint u = A.to[i];\n\t\t\tif(vis[u] || A.dep[u] >= B.dep[u]) continue;\n\t\t\tif(chk[u]) return puts(\"-1\"), 0;\n\t\t\tvis[u] = 1;\n\t\t\tchkmax(res, B.dep[u] - 1);\n\t\t\tq.push(u);\n\t\t}\n\t}\n\tcout << res * 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int MN = 200005;\n\nint N, X, Y, Ans;\nstd::vector<int> G[2][MN];\n\nint par[MN], dep[MN];\nvoid DFS0(int u, int p) {\n\tdep[u] = dep[par[u] = p] + 1;\n\tfor (int v : G[1][u]) if (v != p) DFS0(v, u);\n}\n\nvoid DFS1(int u, int p, int d) {\n\tint win = 0;\n\tAns = std::max(Ans, dep[u]);\n\tfor (int v : G[0][u]) if (v != p) {\n\t\tif (u == par[v] || v == par[u] || u == par[par[v]] || v == par[par[u]] || par[u] == par[v]) {\n\t\t\tif (d + 1 < dep[v]) DFS1(v, u, d + 1);\n\t\t} else { win = 1; break; }\n\t}\n\tif (win) Ans = N;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int o = 0; o < 2; ++o)\n\t\tfor (int i = 1, x, y; i < N; ++i)\n\t\t\tscanf(\"%d%d\", &x, &y),\n\t\t\tG[o][x].push_back(y),\n\t\t\tG[o][y].push_back(x);\n\tdep[0] = -1, DFS0(Y, 0);\n\tDFS1(X, 0, 0);\n\tprintf(\"%d\\n\", Ans == N ? -1 : 2 * Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct lca_finder{\n    int size, lg;\n    vector<vector<int> > lca;\n    vector<int> depths;\n    lca_finder(vector<int> & parents, vector<int> & dep){\n        // root should have -1 as parent\n        size = parents.size();\n        depths = dep;\n        lg = log2(size) + 2;\n        lca.assign(lg, vector<int>(size));\n        for(int e = 0; e < size; e++)\n            lca[0][e] = parents[e];\n        build();\n    }\n    void build(){\n        for(int e = 1; e < lg; e++)\n            for(int f = 0; f < size; f++)\n                if(lca[e-1][f] != -1)\n                    lca[e][f] = lca[e-1][lca[e-1][f]];\n    }\n    int get_lca(int u, int v){\n        if(depths[u] < depths[v]) swap(u, v);\n        for(int e = lg - 1; e >= 0; e--)\n            if((depths[u] - depths[v]) & (1 << e))\n                u = lca[e][u];\n        if(u == v) return u;\n        for(int e = lg - 1; e >= 0; e--)\n            if(lca[e][u] != lca[e][v]){\n                u = lca[e][u];\n                v = lca[e][v];\n            }\n        return lca[0][u];\n    }\n};\nconst int maxn = 200200;\nvector<int> red[maxn], blue[maxn];\nint dist_blue[maxn], good[maxn], parent[maxn];\nvoid dfs(int cur, int par){\n\tparent[cur] = par;\n\tfor(int nxt : blue[cur]){\n\t\tif(nxt == par) continue;\n\t\tdist_blue[nxt] = dist_blue[cur] + 1;\n\t\tdfs(nxt, cur);\n\t}\n}\nint mx;\nvoid loop(){\n\tcout << -1 << endl;\n\texit(0);\n}\nvoid run(int cur, int par, int i){\n\tif(dist_blue[cur] <= i) return;\n\tmx = max(mx, (dist_blue[cur] - 1) * 2);\n\tif(good[cur]) loop();\n\tfor(int nxt : red[cur]){\n\t\tif(nxt == par) continue;\n\t\trun(nxt, cur, i + 1);\n\t}\n}\nint main(){\n\tint n, X, Y; cin >> n >> X >> Y; X--; Y--;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tred[a].push_back(b);\n\t\tred[b].push_back(a);\n\t}\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tblue[a].push_back(b);\n\t\tblue[b].push_back(a);\n\t}\n\tdfs(Y, -1);\n\tvector<int> _parent(n), _depth(n);\n\tfor(int i = 0; i < n; i++){\n\t\t_parent[i] = parent[i];\n\t\t_depth[i] = dist_blue[i];\n\t}\n\tlca_finder lc(_parent, _depth);\n\tauto get_blue_distance = [&](int u, int v){\n\t\treturn dist_blue[u] + dist_blue[v] - 2 * dist_blue[lc.get_lca(u, v)];\n\t};\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j : red[i]){\n\t\t\tif(get_blue_distance(i, j) >= 3){\n\t\t\t\tgood[i] = 1;\n\t\t\t\tgood[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\trun(X, -1, 0);\n\tcout << mx + 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<vector>\n#define N 210000\n#define pb push_back\nusing namespace std;\nstruct node{int y,nex;}a[2*N];\nint e[N][2],len,fir[N],n,sa,sb,dep[N],dfn[N],las[N],id,f[N],p[N],tail,d[N],ans;\nbool b[N],v[N];\nvector<int> A[N];\nvoid ins(int x,int y)\n{\n\ta[++len].y=y;a[len].nex=fir[x];fir[x]=len;\n}\nvoid dfs(int x,int fa)\n{\n\tf[x]=fa;\n\tdfn[x]=++id;\n\tdep[x]=dep[fa]+1;\n\tfor(int k=fir[x];k;k=a[k].nex)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y==fa) continue;\n\t\tdfs(y,x);\n\t}\n\tlas[x]=id;\n}\nbool check(int x,int y)\n{\n\tif(dep[x]>dep[y]) swap(x,y);\n\tif(dfn[x]<=dfn[y] && las[x]>=dfn[y])\n\t{\n\t\tif(dep[y]-dep[x]>2) return 1;\n\t\treturn 0;\n\t}\n\tif(f[x]==f[y]) return 0;\n\treturn 1;\n}\nvoid bfs()\n{\n\tv[sa]=1;p[1]=sa;tail=1;\n\tfor(int i=1;i<=tail;i++)\n\t{\n\t\tint x=p[i],siz=A[x].size();\n\t\tfor(int k=0;k<siz;k++)\n\t\t{\n\t\t\tint y=A[x][k];\n\t\t\td[y]=d[x]+1;\n\t\t\tif(d[y]<dep[y]) {v[y]=1;p[++tail]=y;}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&sa,&sb);\n\tfor(int i=1;i<n;i++) scanf(\"%d%d\",&e[i][0],&e[i][1]);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tins(x,y);ins(y,x);\n\t}\n\tdfs(sb,0);\n\tfor(int i=1;i<=n;i++) dep[i]--;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=e[i][0],y=e[i][1];\n\t\tif(check(x,y)) \n\t\t\tb[x]=b[y]=1;\n\t\telse A[e[i][0]].pb(e[i][1]),A[e[i][1]].pb(e[i][0]);\n\t}\n\tbfs();\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(v[i] && b[i]) {printf(\"-1\\n\");return 0;}\n\t\tif(v[i]) ans=max(ans,dep[i]*2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 100, inF = N;\n\nint n, DIS[N];\nbool mark[N];\nstruct tree {\n\tint dex, root, dis[N], par[N];\n\tvector<int> nei[N];\n\ttree() {\n\t\tfill(par, par + N, -1);\n\t\tfill(dis, dis + N, inF);\n\t}\n\tvoid input() {\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tnei[--u].push_back(--v);\n\t\t\tnei[v].push_back(u);\n\t\t}\n\t}\n\tvoid dfs(int v, bool b = false) {\n\t\tdis[root] = 0;\n\t\tif (dis[v] >= DIS[v] && b)\n\t\t\treturn;\n\t\tfor (int u: nei[v])\n\t\t\tif (u ^ par[v]) {\n\t\t\t\tdis[u] = dis[v] + 1;\n\t\t\t\tpar[u] = v;\n\t\t\t\tdfs(u, b);\n\t\t\t}\n\t}\n\tbool far(int u, int v) {\n\t\tif (u == v || u == par[v] || v == par[u] || par[u] == par[v])\n\t\t\treturn false;\n\t\tif (par[u] != -1 && par[par[u]] == v)\n\t\t\treturn false;\n\t\tif (par[v] != -1 && par[par[v]] == u)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n} R, B;\n\nvoid INPUT() {\n\tcin >> n >> R.root >> B.root;\n\tR.root--;\n\tB.root--;\n\tR.input();\n\tB.input();\n\tB.dfs(B.root);\n\tcopy(B.dis, B.dis + n, DIS);\n\tR.dfs(R.root, true);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tINPUT();\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int u: R.nei[v])\n\t\t\tif (B.far(u, v))\n\t\t\t\tmark[u] = mark[v] = true;\n\tfor (int v = 0; v < n; v++)\n\t\tif (R.dis[v] < B.dis[v] && mark[v]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\tint a = -1, b = inF;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (R.dis[v] < B.dis[v])\n\t\t\ta = max(a, B.dis[v]);\n\t\tif (R.dis[v] <= B.dis[v])\n\t\t\tb = min(b, B.dis[v]);\n\t}\n\tcout << max(a, b) * 2;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nint n,X,Y,f[N][20],dep[N],vis[N],ans;\n\nstruct graph{\n\tstruct edge{int s,t,n;}e[4*N];\n\tint h[N];\n\n\tvoid init()\n\t{\n\t\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t\t}\n\t}\t\n\n\tint dis(int x,int y)\n\t{\n\t\tint s=0;\n\t\tif (dep[x]>dep[y])  swap(x,y);\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (dep[f[y][i]]>=dep[x])\n\t\t\t\ty=f[y][i],s+=1<<i;\n\t\tif (x==y)  return s;\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (f[x][i]!=f[y][i])\n\t\t\t\tx=f[x][i],y=f[y][i],s+=2<<i;\n\t\treturn s+2;\n\t}\n\n\tbool dfs(int x,int fa)\n\t{\n\t\tint _=(x==X);\n\t\tf[x][0]=fa,dep[x]=dep[fa]+1,vis[x]=vis[0];\n\t\tfor (int i=1; i<20; i++)  f[x][i]=f[f[x][i-1]][i-1];\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((y!=fa)&&(dfs(y,x)))  _=1;\n\t\treturn _;\n\t}\n\n\tvoid mark()\n\t{\n\t\tint _;\n\t\tdep[0]=-1;\n\t\tfor (int i=h[Y],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif (vis[0]++,dfs(y,Y))  _=vis[0];\n\t\tvis[0]=_;\n\t}\n\n\tvoid dfs2(int x,int tim)\n\t{\n\t\tans=max(ans,dep[x]),vis[x]=vis[0]+1;\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((vis[y]==vis[0])&&(dep[y]>tim))\n\t\t\t\tdfs2(y,tim+1);\n\t}\n}A,B;\n\nvoid work()\n{\n\tscanf(\"%d %d %d\",&n,&X,&Y);\n\tA.init(),B.init(),B.mark(),A.dfs2(X,1);\n\tfor (int i=2; i<2*n; i+=2)\n\t\tif ((vis[A.e[i].s]>vis[0])||(vis[A.e[i].t]>vis[0]))\n\t\t\tif (B.dis(A.e[i].s,A.e[i].t)>2)\n\t\t\t\tputs(\"-1\"),exit(0);\n\tprintf(\"%d\",2*ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvector<int>edge[200005];\nvector<int>edge2[200005];\nint a,b,n;\nint dist[200005],dist2[200005];\nvoid dfs(int v,int u,int d){\n\tdist[v] = d;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tdfs(edge[v][i],v,d+1);\n\t}\n}\nvoid dfs2(int v,int u,int d){\n\tdist2[v] = d;\n\tfor(int i=0;i<edge2[v].size();i++){\n\t\tif(edge2[v][i] == u) continue;\n\t\tdfs2(edge2[v][i],v,d+1);\n\t}\n}\nint main(){\nputs(\"-1\"); return 0;\n\tscanf(\"%d%d%d\",&n,&a,&b);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tedge2[x].pb(y);\n\t\tedge2[y].pb(x);\n\t}\n\tdfs(a,-1,0); dfs2(b,-1,0);\n\tint lb = 0,ub = n+10;\n\twhile(ub-lb>1){\n\t\tint mid = (lb+ub)/2;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(dist[i] <= mid && dist2[i] > mid) goto ok;\n\t\t}\n\t\tub = mid; continue;\n\t\tok:; lb = mid;\n\t}\n\tcout << ub*2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int maxn = 2e6 + 5;\nvector<int> blue[maxn], red[maxn];\nint dep[maxn], fa[maxn], dp[maxn];\nbool safe[maxn];\nvoid dfs(int v, int p) {\n    fa[v] = p;\n    for (int i=0; i<blue[v].size(); i++) if(blue[v][i] != p) {\n        dep[blue[v][i]] = dep[v] + 1;\n        dfs(blue[v][i], v);\n    }\n}\nbool atMost2(int x, int y) {\n    return (fa[x] == fa[y]) || (fa[x] == y) || (x == fa[y]) || (fa[fa[x]] == y) || (x == fa[fa[y]]);\n}\nint main() {\n    int n, X, Y, x, y;\n    scanf(\"%d %d %d\", &n, &X, &Y);\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        red[x].push_back(y), red[y].push_back(x);\n    }\n    for (int i=1; i<n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        blue[x].push_back(y), blue[y].push_back(x);\n    }\n    dfs(Y, -1);\n    for (int i=1; i<=n; i++)\n        for (int j=0; j<red[i].size(); j++)\n            if (!atMost2(i, red[i][j]))\n                safe[i] = safe[red[i][j]] = 1;\n    if (safe[X]) {puts(\"-1\"); return 0;}\n    memset(dp, -1, sizeof(dp));\n    queue<int> q;\n    q.push(X); dp[X] = 0;\n    int ans = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        if (dp[u] >= dep[u]) continue;\n        if (safe[u]) {puts(\"-1\"); return 0;}\n        ans = max(ans, dep[u] * 2);\n        for (int i=0; i<red[u].size(); i++) {\n            int v = red[u][i];\n            if (dp[u] + 1 < dep[v] && atMost2(u, v)) {\n                dp[v] = dp[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2e+5+5;\n\nstruct edge{\n\tint x,nxt;\n}e1[N*2],e2[N*2];\nint h1[N],h2[N],tot1,tot2;\nint n,X,Y;\nint dep2[N],dep1[N];\nbool bz1[N],bz2[N];\nint fa[N][20];\nint ans;\ndb tim;\n\nvoid inse(int x,int y,int *h,edge *e,int &tot){e[++tot].x=y;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid dfs2(int x){\n\tbz2[x]=1;\n\tfo(i,1,tim)fa[x][i]=fa[fa[x][i-1]][i-1];\n\tfor(int p=h2[x];p;p=e2[p].nxt)\n\tif (!bz2[e2[p].x]){\n\t\tdep2[e2[p].x]=dep2[x]+1;\n\t\tfa[e2[p].x][0]=x;\n\t\tdfs2(e2[p].x);\n\t}\n}\n\nint getdis(int x,int y){\n\tint tmp=dep2[x]+dep2[y];\n\tif (dep2[x]<dep2[y])swap(x,y);\n\tfd(i,tim,0)\n\tif (fa[x][i]&&dep2[fa[x][i]]>=dep2[y])x=fa[x][i];\n\tif (x==y)return tmp-2*dep2[x];\n\tfd(i,tim,0)\n\tif (fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n\treturn tmp-2*dep2[x]+2;\n}\n\nvoid dfs1(int x){\n\tbz1[x]=1;\n\tif (dep1[x]>=dep2[x])return;\n\tans=max(ans,2*dep2[x]);\n\tfor(int p=h1[x];p;p=e1[p].nxt)\n\tif (!bz1[e1[p].x]){\n\t\tdep1[e1[p].x]=dep1[x]+1;\n\t\tdfs1(e1[p].x);\n\t\tint d=getdis(x,e1[p].x);\n\t\tif (d>2)ans=1e+9;\n\t}\n}\n\nint main(){\n\tn=get();X=get();Y=get();\n\tfo(i,2,n){int x=get(),y=get();inse(x,y,h1,e1,tot1);inse(y,x,h1,e1,tot1);}\n\tfo(i,2,n){int x=get(),y=get();inse(x,y,h2,e2,tot2);inse(y,x,h2,e2,tot2);}\n\ttim=log(n)/log(2);\n\tdfs2(Y);\n\tdfs1(X);\n\tprintf(\"%d\\n\",ans==1e+9?-1:ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 9;\n\nvector<int>r[N], b[N];\nint n, R, B, d[N], fa[N], ans;\nbool vis[N];\n\nvoid Dfs (int u) {\n\tfor (auto v : b[u]) if (v != fa[u]) fa[v] = u, d[v] = d[u] + 1, Dfs(v);\n}\n\nbool Judge (int x, int y) {\n\tfor (int i = 1; x != y; ++i) {\n\t\tif (d[x] > d[y]) x = fa[x];\n\t\telse y = fa[y];\n\t\tif (i > 2) return 1;\n\t}\n\treturn 0;\n}\n\nvoid Dfs (int u, int k) {\n\tif (vis[u] || k >= d[u]) return ; vis[u] ^= 1;\n\tif (d[u] > ans) ans = d[u];\n\tfor (auto v : r[u]) {\n\t\tDfs(v, k + 1);\n\t\tif (Judge(u, v)) puts(\"-1\"), exit(0);\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%d\", &n, &R, &B);\n\tfor (int i = 1, u, v; i < n; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tr[u].emplace_back(v);\n\t\tr[v].emplace_back(u);\n\t}\n\tfor (int i = 1, u, v; i < n; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb[u].emplace_back(v);\n\t\tb[v].emplace_back(u);\n\t}\n\td[B] = 0; Dfs(B);\n\tDfs(R, 0);\n\tprintf(\"%d\\n\", ans << 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N * 2 , inf = 1e9 + 7;\nusing namespace std ;\n\nbool vis[N] ;\nint n, rt, S, e, ter[M], nxt[M], lnk[N], dep[N], fa[N], ans ;\nstruct edge {\n\tint x, y ;\n} ed[N] ;\n\nvoid add(int x, int y) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e ;\n}\n\nvoid dfs(int p, int las) {\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) {\n\t\tdep[ter[i]] = dep[p] + 1 ;\n\t\tfa[ter[i]] = p ;\n\t\tdfs(ter[i], p) ;\n\t}\n}\n\nvoid dfs2(int p, int las, int len) {\n\tif (ans == inf) return ;\n\tif (dep[p] < len) return ;\n\tif (dep[p] == len) {\n\t\tans = max(ans, len * 2) ;\n\t\treturn ;\n\t}\n\tif (vis[p]) {\n\t\tans = inf ;\n\t\treturn ;\n\t}\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) dfs2(ter[i], p, len + 1) ;\n\tans = max(ans, dep[p] * 2) ;\n}\n\nbool chk(int x, int y) {\n\tif (dep[x] < dep[y]) swap(x, y) ;\n\tif (fa[x] == y) return false ;\n\tif (fa[fa[x]] == y) return false ;\n\tif (fa[x] == fa[y]) return false ;\n\treturn true ;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &S, &rt) ;\n\trep(i, 1, n - 1) scanf(\"%d%d\", &ed[i].x, &ed[i].y) ;\n\tint x, y ;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &x, &y) ;\n\t\tadd(x, y), add(y, x) ;\n\t}\n\tdfs(rt, 0) ;\n\trep(i, 1, n - 1) if (chk(ed[i].x, ed[i].y)) vis[ed[i].x] = vis[ed[i].y] = true ;\n\trep(i, 1, n) lnk[i] = 0 ;\n\trep(i, 1, e) nxt[i] = 0 ; e = 0 ;\n\trep(i, 1, n - 1) add(ed[i].x, ed[i].y), add(ed[i].y, ed[i].x) ;\n\tdfs2(S, 0, 0) ;\n\tif (ans == inf) {\n\t\tprintf(\"-1\\n\") ;\n\t} else printf(\"%d\\n\", ans) ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\ntypedef pair<int,int> pii;\nint n, x, y, dep[200005], par[20][200005];\nint da[200005], db[200005];\n\nvector<int> ra[200005], rb[200005];\nvector<pii> red;\n\nqueue<int> q;\n\nvoid calc (int cur, int prv) {\n\tdep[cur] = dep[prv] + 1;\n\tpar[0][cur] = prv;\n\tfor(auto &nxt : rb[cur]) {\n\t\tif(nxt == prv) continue;\n\t\tcalc(nxt, cur);\n\t}\n}\n\nint getdist (int A, int B) {\n\tif(dep[A] < dep[B]) swap(A, B);\n\tint ret = 0;\n\tfor(int i=20;i--;) {\n\t\tif(dep[A] - dep[B] >= (1<<i)) {\n\t\t\tA = par[i][A]; ret += (1<<i);\n\t\t}\n\t}\n\tif(A == B) return ret;\n\tfor(int i=20;i--;) {\n\t\tif(par[i][A] != par[i][B]) {\n\t\t\tA = par[i][A]; B = par[i][B];\n\t\t\tret += (1<<i) * 2;\n\t\t}\n\t}\n\treturn ret + 2;\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tred.push_back({A, B});\n\t\tra[A].push_back(B);\n\t\tra[B].push_back(A);\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\trb[A].push_back(B);\n\t\trb[B].push_back(A);\n\t}\n\tcalc(1, 0);\n\tfor(int k=1;k<20;k++) {\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tpar[k][i] = par[k-1][par[k-1][i]];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {da[i] = inf; db[i] = inf;}\n\tdb[y] = 2; q.push(y);\n\twhile(!q.empty()) {\n\t\tint cur = q.front(); q.pop();\n\t\tfor(auto &nxt : rb[cur]) {\n\t\t\tif(db[nxt] == inf) {\n\t\t\t\tdb[nxt] = db[cur] + 2;\n\t\t\t\tq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\tda[x] = 1; q.push(x);\n\twhile(!q.empty()) {\n\t\tint cur = q.front(); q.pop();\n\t\tfor(auto &nxt : ra[cur]) {\n\t\t\tif(da[nxt] == inf && db[nxt] > da[cur] + 2) {\n\t\t\t\tda[nxt] = da[cur] + 2;\n\t\t\t\tq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto &T : red) {\n\t\tint A = T.first, B = T.second;\n\t\tif(getdist(A, B) >= 3 && (da[A] != inf || da[B] != inf)) {\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(da[i] != inf) ans = max(ans, db[i]);\n\t}\n\tprintf(\"%d\\n\",ans-2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define edge(j) for (j=fst[x];j;j=nxt[j])\nusing namespace std;\nconst int N=2e5+5;\nint n,x,y,i,j,u,v,ans,mode;\nint En,fst[N],Fa[N],nxt[N*2],to[N*2];\nint U[N],V[N],X[N],Y[N],A[N],B[N];\nvoid File()\n{\n\tfreopen(\"game.in\",\"r\",stdin);\n\tfreopen(\"game.out\",\"w\",stdout);\n}\nvoid add(int u,int v) {\n\tEn++; nxt[En]=fst[u]; fst[u]=En; to[En]=v;\n}\nvoid dfs(int x,int fa,int step,int *A)\n{\n\tint j,v;\n\tif (mode==1 && step>=B[x]) return ;\n\tA[x]=step;\n\tif (mode==2) Fa[x]=fa;\n\tedge(j)\n\t{\n\t\tv=to[j];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x,step+1,A);\n\t}\n}\nvoid Init()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\trep(i,1,n-1)\n\t\tscanf(\"%d%d\",&U[i],&V[i]);\n\t\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t}\n\trep(i,1,n) A[i]=n+1;\n\t\n\tmode=2; dfs(y,y,0,B);\n\tmemset(fst,0,sizeof(fst));\n\tEn=0;\n\trep(i,1,n-1)\n\t\t{add(U[i],V[i]); add(V[i],U[i]);\t}\t\n\tmode=1; dfs(x,x,0,A);\n}\nvoid Solve()\n{\n\trep(i,1,n-1)\n\t{\n\t\tif (Fa[U[i]]==V[i] || Fa[V[i]]==U[i]) continue;\n\t\tif (Fa[U[i]]==Fa[V[i]] || Fa[Fa[U[i]]]==V[i] || Fa[Fa[V[i]]]==U[i]) continue;\n\t\tif (A[U[i]]<B[U[i]] || A[V[i]]<B[V[i]])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn ;\n\t\t}\n\t}\n\trep(i,1,n)\n\t\tif (A[i]<B[i])\n\t\t\tans=max(ans,B[i]);\n\tans*=2;\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n\t//File();\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\nusing namespace std;\nint n,x,y,f[200010][25],h[200010];\nvector<int> a[200010],b[200010];\nmap<L,bool> g;\ninline void dfs(int i)\n{\n\tint j;\n\tfor(j=1;j<=20;j++)\n\t  f[i][j]=f[f[i][j-1]][j-1];\n\tfor(j=0;j<b[i].size();j++)\n\t  if(b[i][j]!=f[i][0])\n\t    {\n\t\t f[b[i][j]][0]=i;\n\t\t h[b[i][j]]=h[i]+1;\n\t\t dfs(b[i][j]);\n\t\t}\n}\ninline bool check(int x,int y)\n{\n\treturn x==y || f[x][0]==y || f[y][0]==x;\n}\ninline void lca(int x,int y,int &i,int &j)\n{\n\tint a=x,b=y,k;\n\tif(h[a]>h[b])\n\t  {\n\t   for(k=20;k>=0;k--)\n\t     if(h[a]-(1<<k)>=h[b])\n\t       a=f[a][k];\n\t   if(a==b)\n\t     {\n\t\t  i=f[x][0];\n\t\t  j=h[x]-h[y]-1;\n\t\t  return;\n\t\t }\n\t  }\n\tif(h[a]<h[b])\n\t  {\n\t   for(k=20;k>=0;k--)\n\t     if(h[b]-(1<<k)>h[a])\n\t       b=f[b][k];\n\t   if(f[b][0]==a)\n\t     {\n\t\t  i=b;\n\t\t  j=h[y]-h[x]-1;\n\t\t  return;\n\t\t }\n\t   b=f[b][0];\n\t  }\n\tfor(k=20;k>=0;k--)\n\t  if(f[a][k]!=f[b][k])\n\t    a=f[a][k],b=f[b][k];\n\ti=f[x][0];\n\tj=h[x]+h[y]-h[a]-h[b]+1;\n}\ninline L dfs(int x,int y)\n{\n\tif(g[(L)x*n+y])\n\t  return -1;\n\tg[(L)x*n+y]=1;\n\tif(check(x,y))\n\t  {\n\t   int i;\n\t   L j,k=2;\n\t   for(i=0;i<a[x].size();i++)\n\t     if(!check(a[x][i],y))\n\t       {\n\t\t\tj=dfs(a[x][i],y);\n\t\t\tif(j==-1)\n\t\t\t  return -1;\n\t\t\tk=max(k,j);\n\t\t   }\n\t   return k;\n\t  }\n\telse\n\t  {\n\t   int i,j;\n\t   L k;\n\t   lca(x,y,i,j);\n\t   k=dfs(x,i);\n\t   if(k==-1)\n\t     return -1;\n\t   return k+2*j;\n\t  }\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   a[j].pb(k);\n\t   a[k].pb(j);\n\t  }\n\tfor(i=1;i<n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   b[j].pb(k);\n\t   b[k].pb(j);\n\t  }\n\tdfs(1);\n\tprintf(\"%lld\\n\",dfs(x,y));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Don4ick \n//#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define y1 qewr1234\n\nconst double PI = acos(-1.0);\nconst int DIR = 4;\nconst int X[] = {1, 0, -1, 0};\nconst int Y[] = {0, 1, 0, -1};\n\nconst int N = (int)2e5 + 228;\nconst int LOG = 20;\n\nusing namespace std;\n\nint n, x, y, tin[N], tout[N], timer, up[LOG][N], depth[N], ans;\nvector < int > g[N], t[N];\n\nvoid dfs1(int v, int pr)\n{\n\ttin[v] = ++timer;\n\tfor (auto to : t[v])\n\t{\n\t\tif (to == pr)\n\t\t\tcontinue;\n\t\tup[0][to] = v;\n\t\tdepth[to] = depth[v] + 1;\n\t\tdfs1(to, v);\t\n\t}\n\ttout[v] = timer;\n}\n\nbool upper(int v, int u)\n{\n\treturn tin[v] <= tin[u] && tout[v] >= tout[u];\n}\n\nint lift(int v, int u)\n{\n\tfor (int i = LOG - 1; i >= 0; i--)\n\t{\n\t\tif (up[i][v] && !upper(up[i][v], u))\n\t\t\tv = up[i][v];\n\t}\n\treturn v;\n}\n\nint lca(int v, int u)\n{\n\tif (upper(v, u))\n\t\treturn v;\n\tif (upper(u, v))\n\t\treturn u;\n\tv = lift(v, u);\n\treturn up[0][v];\n}\n\nint dist(int v, int u)\n{\n\tint pr = lca(v, u);\n\treturn depth[v] + depth[u] - 2 * depth[pr];\n}\n\nvoid dfs(int v, int pr, int u, int cnt)\n{\n\tans = max(ans, cnt + 2 * dist(v, u));\n\tif (u == v)\n\t\treturn;\t\n\tfor (auto to : g[v])\n\t{\n\t\tif (to == pr || to == u)\n\t\t\tcontinue;\t\n\t\tint newU = up[0][u];\n\t\tif (upper(u, to))\n\t\t\tnewU = lift(to, u);\n\t\tdfs(to, v, newU, cnt + 2);\n\t\tif (dist(v, to) > 2)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie();\n\t//cout.tie();\t\t\n\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\t\t\n\n\t//~read\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tforn(i, n - 1)\n\t{\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tg[v].pb(u), g[u].pb(v);\n\t}\t\t\n\tforn(i, n - 1)\n\t{\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tt[v].pb(u), t[u].pb(v);\n\t}\n\t//~dfs1\n\tdfs1(y, -1);\n\tfor (int i = 1; i < LOG; i++)\n\t{\n\t\tforn(j, n)\n\t\t{\t\n\t\t\tif (up[i - 1][j])\t\n\t\t\t\tup[i][j] = up[i - 1][up[i - 1][j]];\n\t\t}\n\t}\n\t//~solve\t\n\tdfs(x, -1, y, 0);\n\t//~result\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 200001\n#define M 21\nvector<int> ex[N], ey[N];\nvoid init(int n, vector<int>* e) {\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n}\nint fx[N], fy[N][M], dx[N], dy[N];\nvoid dfsy(int u) {\n    for (auto v : ey[u]) {\n        if (v == fy[u][0]) continue;\n        fy[v][0] = u, dy[v] = dy[u] + 1;\n        for (int i = 1; i < M; i++) fy[v][i] = fy[fy[v][i - 1]][i - 1];\n        dfsy(v);\n    }\n}\nint lca(int u, int v) {\n    if (dy[u] < dy[v]) swap(u, v);\n    for (int i = M - 1; ~i; i--)\n        if (dy[fy[u][i]] >= dy[v]) u = fy[u][i];\n    if (u == v) return u;\n    for (int i = M - 1; ~i; i--)\n        if (fy[u][i] != fy[v][i]) u = fy[u][i], v = fy[v][i];\n    return fy[u][0];\n}\nint ans;\nvoid dfsx(int u) {\n    if (dx[u] >= dy[u]) return;\n    if (~ans) ans = max(ans, dy[u] << 1);\n    for (auto v : ex[u]) {\n        if (v == fx[u]) continue;\n        fx[v] = u, dx[v] = dx[u] + 1;\n        if (dy[v] + dy[u] - 2 * dy[lca(u, v)] > 2) ans = -1;\n        dfsx(v);\n    }\n}\nint main() {\n    int n, addx, addy;\n    scanf(\"%d%d%d\", &n, &addx, &addy);\n    init(n, ex);\n    init(n, ey);\n    dfsy(addy);\n    dfsx(addx);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair <int, int> PII;\ntypedef pair <int, int> PLL;\ntypedef pair <PLL, int> PLLI;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <ll, int> PLI;\ntypedef pair <ld, ld> PLD;\ntypedef pair <PLD, ld> PLDD;\ntypedef pair <PLL, ll> PLLL;\ntypedef unsigned int ui;\nconst int inf = 1e9+9;\nconst int mod = 1e9+7;\nconst ll MOD = 1e9+696969;\nconst long long INF = (ll)1e18+3;\nint n, m, k, a, b, c, DL = 0, CC = 0, T;\n#define maxn 200100\nvector <int> v[2][maxn];\nint d[maxn][2];\nint X, Y;\n\nvoid BFS(int graf, int start) {\n\tbool sp = 0;\n\tif (graf == 2) graf = 0, sp = 1;\n\tqueue <int> q;\n\twhile (!q.empty()) q.pop();\n\tFOR(i, 1, n) d[i][graf] = inf;\n\td[start][graf] = 0;\n\tq.push(start);\n\twhile (!q.empty()) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tif (sp && d[x][graf] >= d[x][1]) continue;\n\t\tfor (auto u : v[graf][x])\n\t\t  if (d[u][graf] == inf) {\n\t\t\t  d[u][graf] = d[x][graf] + 1;\n\t\t\t  q.push(u);\n\t\t  }\n\t}\n}\n\nmap <PII, bool> mapa;\n\nconst int D = 1000;\nint BIG[maxn];\n\nint main() {\n\tboost;\n\tcin >> n >> X >> Y;\n\tFOR(i, 2, n) {\n\t\tcin >> a >> b;\n\t\tv[0][a].pb(b);\n\t\tv[0][b].pb(a);\n\t}\n\t\n\tFOR(i, 2, n) {\n\t\tcin >> a >> b;\n\t\tmapa[{a, b}] = 1;\n\t\tv[1][a].pb(b);\n\t\tv[1][b].pb(a);\n\t}\n\t\n\tFOR(i, 1, n) sort(v[1][i].begin(), v[1][i].end());\n\t\n\tint ILE = 0;\n\tFOR(i, 1, n)\n\t  if (v[1][i].size() < 400) {\n\t\t  for (auto u : v[1][i])\n\t\t    for (auto p : v[1][i])\n\t\t      if (u != p) mapa[{u, p}] = 1;\n\t  }\n\t  else BIG[++ILE] = i;\n\t  \n\tFOR(i, 1, n)\n\t  for (auto u : v[0][i]) {\n\t\t  //to sumarycznie robi obrot N petli\n\t\t  FOR(cnt, 1, ILE) {\n\t\t\t  int kt = BIG[cnt];\n\t\t\t  if (binary_search(v[1][kt].begin(), v[1][kt].end(), i) &&\n\t\t\t\t  binary_search(v[1][kt].begin(), v[1][kt].end(), u)) mapa[{i,u}] = 1;\n\t\t}\n  }\n\t\n\tBFS(0, X);\n\tBFS(1, Y);\n\n\t\n\t \n\tBFS(2, X);\n\tint wynik = 0;\n\tFOR(i, 1, n)\n\t  if (d[i][0] < d[i][1]) wynik = max(wynik, 2 * d[i][1]);\n\tFOR(i, 1, n)\n\t  for (auto u : v[0][i]) {\n\t\t  if (!mapa[{i,u}] && !mapa[{u,i}]) {\n\t\t\t  //jest potencjalnie dobra para\n\t\t\t  if (d[i][0] < d[u][0]) {\n\t\t\t\tif (d[i][0] < d[i][1]) OUT(-1);\n\t\t\t}\n\t\t\t  else {\n\t\t\t\t  if (d[u][0] < d[u][1]) OUT(-1);\n\t\t\t  }\n\t\t  }\n\t  }  \n\tcout << wynik << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 200005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<2];\nint n,X,Y,home[N],home1[N],cnt=-1,dep[N],fa[N][25];\nbool vis[N];\nvoid add(int *home,int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nvoid dfs(int k,int F){\n\tdep[k]=dep[F]+1;fa[k][0]=F;\n\tfor(int i=1;i<=20;i++) fa[k][i]=fa[fa[k][i-1]][i-1];\n\tfor(int i=home1[k];~i;i=e[i].next){\n\t\tif(e[i].k!=F){\n\t\t\tdfs(e[i].k,k);\n\t\t}\n\t}\n}\nint q[N][2];\nbool used[N];\nint get(int x,int y){\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int i=20;i>=0;i--){\n\t\tif(dep[fa[x][i]]>dep[y]) x=fa[x][i];\n\t}\n\treturn x;\n}\nint bfs(){\n\tq[0][0]=X;q[0][1]=Y;used[X]=1;\n\tint tou=0,wei=1,ans=0;\n\tfor(int i=0;;i++){\n\t\tif(tou==wei) return ans;\n\t\tint g=tou;tou=wei;\n\t\tfor(int p=g;p<tou;p++){\n\t\t\tint k=q[p][0];\n\t\t\tif(vis[k]) return -1;\n\t\t\tfor(int j=home[k];~j;j=e[j].next){\n\t\t\t\tif(dep[e[j].k]<dep[q[p][1]]) continue;\n\t\t\t\tq[wei][0]=e[j].k;\n\t\t\t\tq[wei][1]=get(e[j].k,q[p][1]);\n\t\t\t\tif(q[wei][0]!=q[wei][1]&&!used[q[wei][0]]) used[q[wei][0]]=1,wei++;\n\t\t\t}\n\t\t\tans=max(ans,i+i+2*(dep[q[p][0]]-dep[q[p][1]]));\n\t\t}\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tmemset(home1,-1,sizeof(home1));\n\tscanf(\"%d%d%d\",&n,&X,&Y);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(home,x,y);add(home,y,x);\n\t}\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(home1,x,y);add(home1,y,x);\n\t}\n\tdfs(Y,0);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=home[i];~p;p=e[p].next){\n\t\t\tint x=e[p].k,y=i;\n\t\t\tif(dep[x]<dep[y]) swap(x,y);\n\t\t\tif(fa[x][0]!=y&&fa[x][0]!=fa[y][0]&&fa[x][1]!=y) vis[x]=vis[y]=1; \n\t\t}\n\t}\n\tprintf(\"%d\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2000005;\n\nint N,X,Y;\nvector<int> red[MAXN],blue[MAXN];\nint dep[MAXN],fa[MAXN];\n\nbool isTable(int u,int v)\n{\n\tif(dep[u]>dep[v])\n\t\tswap(u,v);\n\tif(fa[v]==u||fa[fa[v]]==u||fa[u]==fa[v])\n\t\treturn false;\n\treturn true;\n}\n\nvoid dfs1(int u)\n{\n\tfor(auto v:blue[u])\n\t\tif(v!=fa[u])\n\t\t{\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs1(v);\n\t\t}\n}\nint dfs2(int u,int f=0,int step=0)\n{\n\tstep++;\n\tint res=dep[u];\n\tfor(auto v:red[u])\n\t{\n\t\tif(v==f)\n\t\t\tcontinue;\n\t\tif(dep[v]>step)\n\t\t{\n\t\t\tif(isTable(u,v))\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tres=max(res,dfs2(v,u,step+1));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&X,&Y);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred[u].push_back(v);\n\t\tred[v].push_back(u);\n\t}\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue[u].push_back(v);\n\t\tblue[v].push_back(u);\n\t}\n\tdfs1(Y);\n\tint ans=dfs2(X)*2;\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int INF=1e9;\nstruct node{\n\tint s,t;\n}w1[200100],w2[200100];\nint beg[200100],nex[400100],tto[400100],e;\nvoid putin(int s,int t){\n\ttto[++e]=t;\n\tnex[e]=beg[s];\n\tbeg[s]=e;\n}\nint n;\nvoid clear(){\n\te=1;\n\tfor(int i=0;i<=n;i++)\n\t\tbeg[i]=0;\n}\nbool vis[200100];\nint f[200100];\nint dis[200100];\nvoid getfa(int u){\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==f[u]) continue;\n\t\tf[tto[i]]=u;\n\t\tdis[tto[i]]=dis[u]+1;\n\t\tgetfa(tto[i]);\n\t}\n}\nint ans;\nvoid dfs(int u,int fa,int dep){\n\tif(dis[u]>ans) ans=dis[u];\n\tif(dep>=dis[u]) return;\n\tfor(int i=beg[u];i;i=nex[i]){\n\t\tif(tto[i]==fa) continue;\n\t\tif(vis[i>>1]){\n\t\t\tans=INF;\n\t\t\treturn;\n\t\t}\n\t\tdfs(tto[i],u,dep+1);\n\t}\n}\nint main(){\n//\tfreopen(\"b.in\",\"r\",stdin);\n//\tfreopen(\"b.out\",\"w\",stdout);\n\tint A,B;\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tif(A==B){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tclear();\n\tfor(int i=1;i<n;i++)\n\t\tscanf(\"%d%d\",&w1[i].s,&w1[i].t);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&w2[i].s,&w2[i].t);\n\t\tputin(w2[i].s,w2[i].t);\n\t\tputin(w2[i].t,w2[i].s);\n\t}\n\tgetfa(B);\n\tclear();\n\tfor(int i=1;i<n;i++){\n\t\tif(f[w1[i].s]!=f[w1[i].t]&&f[f[w1[i].s]]!=w1[i].t&&\n\t\t\t\tw1[i].s!=f[f[w1[i].t]]&&f[w1[i].s]!=w1[i].t&&f[w1[i].t]!=w1[i].s)\n\t\t\tvis[i]=1;\n\t\telse\n\t\t\tvis[i]=0;\n\t\tputin(w1[i].s,w1[i].t);\n\t\tputin(w1[i].t,w1[i].s);\n\t}\n\tdfs(A,-1,0);\n\tif(ans==INF) printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans*2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 200007 , __ = _<<1 , lglg = 17 , inf = 0x3f3f3f3f;\n\nint n;\n\nstruct trees\n{\n\tint to[__],ne[__],he[_],ecnt;\n\tinline void adde(int a,int b){to[++ecnt]=b,ne[ecnt]=he[a],he[a]=ecnt;}\n\tinline void addde(int a,int b){adde(a,b),adde(b,a);}\n\n\tint fa[_],dep[_],sz[_],mxch[_];\n\n\tvoid dfs(int x,int ff)\n\t{\n\t\tfa[x]=ff,dep[x]=dep[ff]+1,sz[x]=1;\n\t\tfor(int i=he[x];i;i=ne[i])\n\t\t{\n\t\t\tint b=to[i];\n\t\t\tif(b==ff)continue;\n\t\t\tdfs(b,x),sz[x]+=sz[b];\n\t\t\tif(sz[mxch[x]]<sz[b])mxch[x]=b;\n\t\t}\n\t}\n\n\tint top[_];\n\t\n\tvoid dfs2(int x,int tp)\n\t{\n\t\ttop[x]=tp;\n\t\tif(mxch[x])dfs2(mxch[x],tp);\n\t\tfor(int i=he[x];i;i=ne[i])\n\t\t{\n\t\t\tint b=to[i];\n\t\t\tif(b==fa[x] || b==mxch[x])continue;\n\t\t\tdfs2(b,b);\n\t\t}\n\t}\n\n\tinline int lca(int a,int b)\n\t{\n\t\twhile(top[a]!=top[b])\n\t\t{\n\t\t\tif(dep[top[a]]<dep[top[b]])swap(a,b);\n\t\t\ta=fa[top[a]];\n\t\t}\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\treturn a;\n\t}\n\n\tinline int distan(int a,int b)\n\t{\n\t\treturn dep[a]+dep[b]-2*dep[lca(a,b)];\n\t}\n\n\tint rt;\n\t\n\tinline void make(int rt_)\n\t{\n\t\trt=rt_,dfs(rt,0),dfs2(rt,rt);\n\t}\n\n\ttrees()\n\t{\n\t\tmemset(he,0,sizeof(he)),ecnt=1;\n\t\tmemset(fa,0,sizeof(fa));\n\t\tmemset(dep,0,sizeof(dep));\n\t\tmemset(sz,0,sizeof(sz));\n\t\tmemset(mxch,0,sizeof(mxch));\n\t\tmemset(top,0,sizeof(top));\n\t}\n}t1,t2;\n\nint st1,st2,ans=0;\n\nvoid dfs(int x)\n{\n\tif(t1.dep[x]>=t2.dep[x])return;\n\tans=max(ans,t2.dep[x]-1);\n\tfor(int i=t1.he[x];i;i=t1.ne[i])\n\t{\n\t\tint b=t1.to[i];\n\t\tif(b==t1.fa[x])continue;\n\t\tif(t2.distan(x,b)>=3){ans=inf;return;}\n\t\tdfs(b);\n\t}\n}\n\t\t\t\n\nint main()\n{\n\tn=ty(),st1=ty(),st2=ty();\n\tfor(int i=1,a,b;i<n;i++)a=ty(),b=ty(),t1.addde(a,b);\n\tfor(int i=1,a,b;i<n;i++)a=ty(),b=ty(),t2.addde(a,b);\n\n\tt1.make(st1),t2.make(st2);\n\tdfs(st1);\n\tif(ans>=inf)ans=-1;\n\telse ans<<=1;\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 2e5 + 5, logn = 20;\nint n, x, y;\nint p[maxn][logn];\nint tin[maxn], tout[maxn], t;\nint dep[maxn];\nint can[maxn][2];\nvector<int> gr[maxn], gb[maxn];\n\nint read() {\n  if (scanf(\"%d%d%d\", &n, &x, &y) < 3) {\n    return false;\n  }\n  x--;\n  y--;\n  for (int i = 0; i < n; i++) {\n    gr[i].clear();\n    gb[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    v--;\n    u--;\n    gr[v].push_back(u);\n    gr[u].push_back(v);\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    v--;\n    u--;\n    gb[v].push_back(u);\n    gb[u].push_back(v);\n  }\n  return true;\n}\n\nvoid buildLCA(int v) {\n  tin[v] = t++;\n  for (int i = 1; i < logn; i++) {\n    p[v][i] = p[p[v][i - 1]][i - 1];\n  }\n  for (int i = 0; i < sz(gb[v]); i++) {\n    int u = gb[v][i];\n    if (u == p[v][0]) {\n      continue;\n    }\n    p[u][0] = v;\n    dep[u] = dep[v] + 1;\n    buildLCA(u);\n  }\n  tout[v] = t++;\n}\n\nbool anc(int v, int u) {\n  return tin[v] <= tin[u] && tout[v] >= tout[u];\n}\n\nint lca(int v, int u) {\n  if (anc(v, u)) {\n    return v;\n  }\n  if (anc(u, v)) {\n    return u;\n  }\n  for (int i = logn - 1; i >= 0; i--) {\n    if (!anc(p[v][i], u)) {\n      v = p[v][i];\n    }\n  }\n  return p[v][0];\n}\n\nint dist(int v, int u) {\n  return dep[v] + dep[u] - 2 * dep[lca(v, u)];\n}\n\nint go(int v, int u) {\n  if (anc(v, u)) {\n    for (int i = logn - 1; i >= 0; i--) {\n      if (!anc(p[u][i], v)) {\n        u = p[u][i];\n      }\n    }\n    return u;\n  }\n  return p[v][0];\n}\n\nvoid bfs() {\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) {\n      can[i][j] = false;\n    }\n  }\n  vector< pair<int, int> > q;\n  q.push_back(make_pair(x, y));\n  can[x][0] = true;\n  can[x][1] = true;\n  for (int l = 0; l < sz(q); l++) {\n    int v = q[l].first, u = q[l].second;\n    for (int i = 0; i < sz(gr[v]); i++) {\n      int vv = gr[v][i];\n      if (can[vv][0]) {\n        continue;\n      }\n      can[vv][0] = true;\n      int uu = go(u, vv);\n      if (uu != vv) {\n        can[vv][1] = true;\n        q.push_back(make_pair(vv, uu));\n      }\n    }\n  }\n}\n\nvoid solve() {\n  p[y][0] = y;\n  dep[y] = 0;\n  t = 0;\n  buildLCA(y);\n  bfs();\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (can[i][0]) {\n      ans = max(ans, 2 * dep[i]);\n    }\n    if (can[i][1]) {\n      bool ok = false;\n      for (int ii = 0; ii < sz(gr[i]); ii++) {\n        int j = gr[i][ii];\n        if (dist(i, j) > 2) {\n          ok = true;\n          break;\n        }\n      }\n      if (ok) {\n        ans = inf;\n      }\n    }\n  }\n  if (ans == inf) {\n    ans = -1;\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint n, stx, sty;\nstruct Edge {\n\tint to, next;\n} edge[(N << 1) + 1];\nint start[N + 1], tot;\nint depa[N + 1], depb[N + 1], up[21][N + 1];\nint xx[N + 1], yy[N + 1];\nint ans;\n\ninline void addedge(int u, int v)\n{\n\tedge[++tot] = Edge{ v, start[u] };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v] };\n\tstart[v] = tot;\n\treturn;\n}\ninline void dfs1(int u, int fa)\n{\n\tdepa[u] = depa[fa] + 1;\n\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (v != fa && depb[v] > depa[u] + 1)\n\t\t\tdfs1(v, u);\n\t}\n\treturn;\n}\ninline void dfs2(int u, int fa)\n{\n\tdepb[u] = depb[fa] + 1;\n\tfor (int i = 1; i <= 20; i++)\n\t\tup[i][u] = up[i - 1][up[i - 1][u]];\n\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (v != fa) {\n\t\t\tup[0][v] = u;\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\ninline int lca(int x, int y)\n{\n\tif (depb[x] > depb[y])\n\t\tswap(x, y);\n\tfor (int i = 20; i >= 0; i--) {\n\t\tif (up[i][y] && depb[up[i][y]] >= depb[x])\n\t\t\ty = up[i][y];\n\t\tif (x == y)\n\t\t\treturn x;\n\t}\n\tfor (int i = 20; i >= 0; i--) {\n\t\tif (up[i][x] && up[i][x] != up[i][y]) {\n\t\t\tx = up[i][x];\n\t\t\ty = up[i][y];\n\t\t}\n\t}\n\treturn up[0][x];\n}\ninline int dis(int x, int y)\n{\n\tint llca = lca(x, y);\n\n\treturn depb[x] + depb[y] - (depb[llca] << 1);\n}\nint main()\n{\n\tn = read();\n\tstx = read();\n\tsty = read();\n\tfor (int i = 1; i < n; i++) {\n\t\txx[i] = read();\n\t\tyy[i] = read();\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint a = read(), b = read();\n\t\taddedge(a, b);\n\t}\n\tdfs2(sty, 0);\n\ttot = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tstart[i] = 0;\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(xx[i], yy[i]);\n\tdfs1(stx, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tif (dis(xx[i], yy[i]) > 2 && ((depa[xx[i]] < depb[xx[i]] && depa[xx[i]]) || (depa[yy[i]] < depb[yy[i]] && depa[yy[i]]))) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (depa[i] < depb[i] && depa[i])\n\t\t\tans = max(ans, depb[i] - 1);\n\tprintf(\"%d\\n\", ans << 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ===================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// ===================================\n#include <bits/stdc++.h>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=400000+10;\n\nstruct Tree {\n    struct edge { int v,nxt; } e[N<<1];\n    int head[N];\n    inline void addEdge(int u,int v) {\n        static int cnt=0;\n        e[++cnt]=(edge){v,head[u]},head[u]=cnt;\n    }\n\n    int dep[N],sz[N],fa[N],hson[N],top[N];\n    inline void dfs1(int u,int f) {\n        dep[u]=dep[fa[u]=f]+1,sz[u]=1;\n        for (re int i=head[u];i;i=e[i].nxt) {\n            int v=e[i].v; if (v==f) continue;\n            dfs1(v,u),sz[u]+=sz[v];\n            if (sz[v]>sz[hson[u]]) hson[u]=v;\n        }\n    }\n    inline void dfs2(int u,int anc) {\n        top[u]=anc;\n        if (hson[u]) dfs2(hson[u],anc);\n        for (re int i=head[u];i;i=e[i].nxt)\n            if (e[i].v!=fa[u]&&e[i].v!=hson[u]) dfs2(e[i].v,e[i].v);\n    }\n    \n    inline int getlca(int u,int v) {\n        while (top[u]!=top[v]) {\n            if (dep[top[u]]<dep[top[v]]) swap(u,v);\n            u=fa[top[u]];\n        }\n        return dep[u]<dep[v]?u:v;\n    }\n    inline int getdis(int u,int v) {\n        int t=getlca(u,v);\n        return dep[u]+dep[v]-(dep[t]<<1);\n    }\n} A,B;\n\nint n,x,y,vis[N];\n\ninline void bfs() {\n    queue<int> Q; vis[x]=1,Q.push(x);\n    while (!Q.empty()) {\n        int u=Q.front(); Q.pop();\n        for (re int i=A.head[u];i;i=A.e[i].nxt) {\n            int v=A.e[i].v; if (vis[v]) continue;\n            if (A.dep[v]<B.dep[v]) vis[v]=1,Q.push(v);\n        }\n    }\n}\n\nint main() {\n    n=read(),x=read(),y=read();\n    for (re int i=1;i<n;++i) {\n        int u=read(),v=read();\n        A.addEdge(u,v),A.addEdge(v,u);\n    }\n    for (re int i=1;i<n;++i) {\n        int u=read(),v=read();\n        B.addEdge(u,v),B.addEdge(v,u);\n    }\n    A.dfs1(x,0),A.dfs2(x,x); B.dfs1(y,0),B.dfs2(y,y);\n    bfs(); int ans=0;\n    for (re int u=1;u<=n;++u) {\n        if (!vis[u]) continue;\n        for (re int i=A.head[u];i;i=A.e[i].nxt) {\n            int v=A.e[i].v;\n            if (B.getdis(u,v)>2) { puts(\"-1\"); return 0; }\n        }\n        ans=max(ans,B.dep[u]-1);\n    }\n    printf(\"%d\\n\",ans<<1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 200005\nusing namespace std;\n\nint n,cnt,last[MAXN];\nint father[MAXN],deep[MAXN],dis[MAXN];\nint q[MAXN],nnn[MAXN],mx[MAXN];\nint tim,a[MAXN][2],xx,yy;\nbool vis[MAXN],win[MAXN];\n\nstruct edge\n{\n    int to,next,h;\n}t[MAXN*4];\n\nvoid add(int u,int v,int h)\n{\n    t[++cnt].to=v;t[cnt].h=h;\n    t[cnt].next=last[u];last[u]=cnt;\n    t[++cnt].to=u;t[cnt].h=h;\n    t[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n    deep[x]=deep[father[x]]+1;nnn[x]=++tim;\n    for (int i=last[x];i;i=t[i].next)\n        if (t[i].to!=father[x]) father[t[i].to]=x,dfs(t[i].to);\n    mx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n    if (nnn[x]>nnn[y]) swap(x,y);\n    if (nnn[x]<nnn[y]&&mx[x]>nnn[y]) return deep[y]-deep[x]>2 ? true : false;\n    if (father[x]==father[y]) return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int h=1,tt=1;q[1]=xx;vis[xx]=1;\n    while (h<=tt)\n    {\n        int x=q[h++];\n        for (int i=last[x];i;i=t[i].next)\n            if (!t[i].h&&!vis[t[i].to])\n            {\n                dis[t[i].to]=dis[x]+1;\n                if (dis[t[i].to]<deep[t[i].to]) vis[t[i].to]=1,q[++tt]=t[i].to;\n            }\n    }\n}\n\nint max(int a,int b){return a<b?a:b;}//\n\ntemplate<class T>inline void read(T &res)\n{\n    static char ch;T flag=1;\n    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;\n    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;\n}\n\nint main()\n{\n    int ans=0;\n    read(n);read(xx);read(yy);\n\n    for (int i=1;i<n;i++) {read(a[i][0]);read(a[i][1]);}\n\n    for (int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x);read(y);\n        add(x,y,1);\n    }\n\n    deep[0]=-1;\n    dfs( yy );\n\n    for (int i=1;i<n;i++)\n    {\n        if (check(a[i][0],a[i][1]))\n            win[a[i][0]]=win[a[i][1]]=1;\n        else add(a[i][0],a[i][1],0);\n    }\n\n    bfs();\n\n    for (int i=1;i<=n;i++)\n        if (win[i]&&vis[i])\n            {putchar('-');putchar('1');return 0;}\n\n    for (int i=1;i<=n;i++)\n        if (vis[i])\n            ans=max(ans,deep[i]<<1);\n\n   cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N], dfn;\nint dp[N << 1][20], lg2[N], dph[N];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x])\n        if (y != fx) dfsb(y, x);\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] > db[x]) return;\n    if (~ans) ans = max((db[x] - 1)<<1, ans);\n    for (int y : a[x]) {\n        if (db[x] + db[y] - 2 * db[LCA(x, y)] > 2) ans = -1;\n        if (y != fx) dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: zxy_hhhh\n    date: 2020/03/13\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<iostream>\n#define ll long long\ninline ll rd() {\n    ll _x=0;int _ch=getchar(),_f=1;\n    for(;!isdigit(_ch)&&(_ch!='-')&&(_ch!=EOF);_ch=getchar());\n    if (_ch=='-'){_f=0;_ch=getchar();}\n    for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0';\n    return _f?_x:-_x;\n}\nvoid write(ll _x){if (_x>=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); }\ninline void wrt(ll _x,char _p){if (_x<0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);}\n#define maxn 200005\nint dis[maxn],Fa[maxn];\nstd::vector<int> G1[maxn],G2[maxn];\nint n,A,B;\nvoid dfs(int u,int fa) {\n    Fa[u]=fa;\n    for(auto i:G2[u]) if (i!=fa) {\n        dis[i]=dis[u]+1;\n        dfs(i,u);\n    }\n}\nint ans;\nvoid DFS(int u,int fa,int D) {\n    if (dis[u]<=D) return ;\n    ans=std::max(ans,dis[u]*2);\n    for(auto i:G1[u]) if (i!=fa) {\n        if (!(Fa[u]==i||Fa[i]==u||Fa[u]==Fa[i]||Fa[Fa[i]]==u||Fa[Fa[i]]==u)) \n            ans=1e9;\n        DFS(i,u,D+1);\n    }\n}\nint main() {\n    n=rd();A=rd(),B=rd();\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G1[x].push_back(y);\n        G1[y].push_back(x);\n    }\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G2[x].push_back(y);\n        G2[y].push_back(x);\n    }\n    dfs(B,0);\n    DFS(A,0,0);\n    if (ans>1e8) wrt(-1,'\\n');\n    else wrt(ans,'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <cassert>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <set>\n#include <bitset>\n#include <string>\n#include <utility>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <map>\n#else\n#include <bits/stdc++.h>\n#endif\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#define rep(i, n) for (int i = 0, i##_end_ = (n); i < i##_end_; ++i)\n#define per(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define forn(i, l, r) for (int i = (l), i##_end_ = (r); i <= i##_end_; ++i)\n#define nrof(i, r, l) for (int i = (r), i##_end_ = (l); i >= i##_end_; --i)\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\ntypedef pair<int, int> pii;\n\ntypedef long long LL;\n\ntemplate<typename T> inline bool chkmax(T &x, const T &y) {\n\treturn x < y && (~x) ? x = y, 1 : 0;\n}\n\ntemplate<typename T> inline bool chkmin(T &x, const T &y) {\n\treturn x > y ? x = y, 1 : 0;\n}\n\n#ifdef DEBUG\nchar *input_file, *output_file;\n#endif\n\nstruct IO {\n\tstatic const int maxn = (1 << 25) + 10;\n\n\tchar a[maxn], *s, b[maxn], *t;\n\n\tvoid INPUT() {\n\t\ts = a;\n\t\tt = b;\n\t\t#ifdef DEBUG\n\t\tFILE *f = fopen(input_file, \"r\");\n\t\ta[fread(a, 1, sizeof a, f)] = 0;\n\t\t#else\n\t\ta[fread(a, 1, sizeof a, stdin)] = 0;\n\t\t#endif\n\t}\n\n\tvoid OUTPUT() {\n#ifdef DEBUG\n\t\tFILE *f = fopen(output_file, \"w\");\n\t\tfwrite(b, 1, t - b, f);\n#else\n\t\tfwrite(b, 1, t - b, stdout);\n#endif\n\t}\n\n\toperator int() {\n\t\tint x = 0;\n\t\twhile(*s != '-' && (*s < '0' || *s > '9')) {\n\t\t\t++s;\n\t\t}\n\t\tbool f = 0;\n\t\tif(*s == '-') {\n\t\t\tf = 1;\n\t\t\t++s;\n\t\t}\n\t\twhile(*s >= '0' && *s <= '9') {\n\t\t\t(x *= 10) += *s - '0';\n\t\t\t++s;\n\t\t}\n\t\tif(f) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn x;\n\t}\n\n\toperator LL() {\n\t\tLL x = 0;\n\t\twhile(*s != '-' && (*s < '0' || *s > '9')) {\n\t\t\t++s;\n\t\t}\n\t\tbool f = 0;\n\t\tif(*s == '-') {\n\t\t\tf = 1;\n\t\t\t++s;\n\t\t}\n\t\twhile(*s >= '0' && *s <= '9') {\n\t\t\t(x *= 10) += *s - '0';\n\t\t\t++s;\n\t\t}\n\t\tif(f) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn x;\n\t}\n\n\toperator char() {\n\t\twhile(*s <= 32) {\n\t\t\t++s;\n\t\t}\n\t\tchar ret = *s;\n\t\t++s;\n\t\treturn ret;\n\t}\n\n\tinline void out(int x) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tint y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\treturn;\n\t}\n\n\tinline void out(int x, char C) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\t*t++ = C;\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tint y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\t*t++ = C;\n\t\treturn;\n\t}\n\n\tinline void out(LL x) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tLL y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\treturn;\n\t}\n\n\tinline void out(LL x, char C) {\n\t\tif(!x) {\n\t\t\t*t++ = '0';\n\t\t\t*t++ = C;\n\t\t\treturn;\n\t\t}\n\t\tif(x < 0) {\n\t\t\t*t++ = '-';\n\t\t\tx = -x;\n\t\t}\n\t\tstatic char c[20], *i;\n\t\ti = c;\n\t\twhile(x) {\n\t\t\tLL y = x / 10;\n\t\t\t*i++ = x - y * 10 + '0';\n\t\t\tx = y;\n\t\t}\n\t\twhile(i != c) {\n\t\t\t*t++ = *--i;\n\t\t}\n\t\t*t++ = C;\n\t\treturn;\n\t}\n\n\tinline void out(char c) {\n\t\t*t++ = c;\n\t\treturn;\n\t}\n\n\tinline void out(char *s) {\n\t\twhile(*s >= ' ') {\n\t\t\t*t++ = *s++;\n\t\t}\n\t\treturn;\n\t}\n}io;\n\nvoid Main();\n\nint main(int argc, char *argv[]) {\n#ifdef DEBUG\n\tinput_file = argv[1];\n\toutput_file = argv[2];\n#endif\n\tio.INPUT();\n\tMain();\n\tio.OUTPUT();\n\treturn 0;\n}\n\n//---------------------------------------------------------------------------------------head---------------------------------------------------------------------------------------\n\nconst int maxn = 2e5 + 100;\n\nconst int lgn = 19;\n\nint n, r1, r2, ans;\nvi g1[maxn], g2[maxn];\nint par1[maxn][lgn], par2[maxn][lgn];\nint dep1[maxn], dep2[maxn];\n\nvoid dfs1(int u = r1, int p = 0) {\n\tpar1[u][0] = p;\n\tforn(i, 1, lgn - 1) {\n\t\tpar1[u][i] = par1[par1[u][i - 1]][i - 1];\n\t}\n\tdep1[u] = dep1[p] + 1;\n\tfor (int v: g1[u]) {\n\t\tif(v != p) {\n\t\t\tdfs1(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfs2(int u = r2, int p = 0) {\n\tpar2[u][0] = p;\n\tforn(i, 1, lgn - 1) {\n\t\tpar2[u][i] = par2[par2[u][i - 1]][i - 1];\n\t}\n\tdep2[u] = dep2[p] + 1;\n\tfor (int v: g2[u]) {\n\t\tif(v != p) {\n\t\t\tdfs2(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nint lca(int u, int v) {\n\tif(dep2[u] < dep2[v]) {\n\t\tswap(u, v);\n\t}\n\tint dlt = dep2[u] - dep2[v];\n\trep(i, lgn) {\n\t\tif((dlt >> i) & 1) {\n\t\t\tu = par2[u][i];\n\t\t}\n\t}\n\tif(u == v) {\n\t\treturn u;\n\t}\n\tper(i, lgn) {\n\t\tif(par2[u][i] != par2[v][i]) {\n\t\t\tu = par2[u][i], v = par2[v][i];\n\t\t}\n\t}\n\treturn par2[u][0];\n}\n\nvoid dfs3(int u = r1, int p = 0) {\n\tdebug(\"dfs3(%d, %d)\\n\", u, p);\n\tchkmax(ans, max(dep1[u], dep2[u]) - 1 << 1);\n\tif(dep1[u] >= dep2[u]) {\n\t\treturn;\n\t}\n\tif(p) {\n\t\tint f = lca(u, p);\n\t\tif(dep2[u] + dep2[p] - dep2[f] * 2 > 2) {\n\t\t\tans = -1;\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int v: g1[u]) {\n\t\tif(v != p) {\n\t\t\tdfs3(v, u);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid Main() {\n\tn = io;\n\tr1 = io;\n\tr2 = io;\n\trep(i, n - 1) {\n\t\tint u = io, v = io;\n\t\tg1[u].pb(v);\n\t\tg1[v].pb(u);\n\t}\n\trep(i, n - 1) {\n\t\tint u = io, v = io;\n\t\tg2[u].pb(v);\n\t\tg2[v].pb(u);\n\t}\n\tdfs1();\n\tdfs2();\n\tdfs3();\n\tio.out(ans, '\\n');\n\treturn;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for(int i = a; i <= b; i++)\n#define per(i, a, b) for(int i = a; i >= b; i--)\ntypedef long long LL;\nconst int maxn = 2e5 + 5;\nconst LL mod = 1e9 + 7;\n\nint n, x, y, first[maxn], dep[maxn], s[maxn][2], f[maxn][27], g[maxn], dis[maxn], cnt;\nbool vis[maxn];\nstruct Edge {\n\tint to, next, ser;\n} e[maxn<<1];\n\nvoid Dfs(int u, int fa) {\n\tdep[u] = dep[fa] + 1;\n\tf[u][0] = fa;\n\tg[u] = dep[u];\n\tfor(int i = first[u]; i; i = e[i].next) {\n\t\tint v = e[i].to;\n\t\tif(v == fa || e[i].ser) continue;\n\t\tDfs(v, u);\n\t\tg[u] = max(g[v], g[u]);\n\t}\n}\n\nvoid add(int u, int v, int ser) {\n\te[++cnt] = (Edge) {v, first[u], ser};\n\tfirst[u] = cnt;\n}\n\nint Lca(int u, int v) {\n\tif(dep[u] < dep[v]) swap(u, v);\n\tint dif = dep[u] - dep[v];\n\trep(i, 25, 0)\n\t    if(dif >= (1<<i)) {\n\t    \tdif -= 1<<i;\n\t    \tu = f[u][i];\n\t    }\n\trep(i, 25, 0)\n\t    if(f[u][i] != f[v][i]) {\n\t    \tu = f[u][i];\n\t    \tv = f[v][i];\n\t    }\n\treturn f[u][0];\n}\n\n\nbool Bfs(int s) {\n\tmemset(dis, 0x7f, sizeof(dis));\n\tqueue <int> q;\n\tdis[s] = 0;\n\tq.push(s);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = first[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\tif(!e[i].ser || dis[u] + 1 >= dep[v] || dis[u] + 1 >= dis[v]) continue;\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tq.push(v);\n\t\t}\n\t}\n\trep(i, 1, n)\n\t    if(dis[i] < dep[i] && vis[i]) return 1;\n\treturn 0;\n}\n\nint main() {\n\tcin>>n>>x>>y;\n\tint u, v;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 1);\n\t\tadd(v, u, 1);\n\t\ts[i][0] = u, s[i][1] = v;\n\t}\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v, 0);\n\t\tadd(v, u, 0);\n\t}\n\tdep[0] = -1;\n\tDfs(y, 0);\n\trep(k, 1, 25)\n\t    rep(i, 1, n) \n\t        f[i][k] = f[f[i][k - 1]][k - 1];\n\trep(i, 1, n - 1) {\n\t\tint d = Lca(s[i][0], s[i][1]);\n\t\tif(dep[s[i][0]] + dep[s[i][1]] - 2*dep[d] > 2) vis[s[i][0]] = vis[s[i][1]] = 1;\n\t} \n\tif(Bfs(x)) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\telse {\n\t\tint ans = 0;\n\t\trep(i, 1, n)\n\t\t    if(dis[i] < dep[i]) ans = max(ans, dep[i]);\n\t\tcout<<ans*2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = (int) 1e9;\nconst int N = 1234567;\n\nint save_x[N], save_y[N];\n\nvector <int> g[N], g_blue[N];\nint d[N], d_blue[N];\nint pr[N], pr_blue[N];\n\nvoid dfs(int v, int pv) {\n  if (d[v] >= d_blue[v]) {\n    return;\n  }\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j];\n    if (u == pv) {\n      continue;\n    }\n    pr[u] = v;\n    d[u] = d[v] + 1;\n    dfs(u, v);\n  }\n}\n\nint n;\n\nvoid get_d(int start) {\n  for (int i = 0; i < n; i++) {\n    d[i] = inf;\n    pr[i] = -1;\n  }\n  d[start] = 0;\n  pr[start] = start;\n  dfs(start, -1);\n}\n\nint main() {\n  int x, y;\n  scanf(\"%d %d %d\", &n, &x, &y);\n  x--; y--;\n  for (int i = 0; i < n - 1; i++) {\n    scanf(\"%d %d\", save_x + i, save_y + i);\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar;\n    scanf(\"%d %d\", &foo, &bar);\n    foo--; bar--;\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  for (int i = 0; i < n; i++) {\n    d_blue[i] = inf;\n  }\n  get_d(y);\n  for (int i = 0; i < n; i++) {\n    d_blue[i] = d[i];\n    g_blue[i] = g[i];\n    pr_blue[i] = pr[i];\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar;\n    foo = save_x[i];\n    bar = save_y[i];\n    foo--; bar--;\n    g[foo].push_back(bar);\n    g[bar].push_back(foo);\n  }\n  get_d(x);\n  int mx = 0;\n  for (int i = 0; i < n; i++) {\n    if (d[i] < d_blue[i]) {\n      mx = max(mx, 2 * d_blue[i]);\n      for (int j = 0; j < (int) g[i].size(); j++) {\n        int to = g[i][j];\n        if (pr_blue[to] == i || pr_blue[i] == to || pr_blue[pr_blue[to]] == i || pr_blue[pr_blue[i]] == to || pr_blue[i] == pr_blue[to]) {\n          continue;\n        }\n        cout << -1 << endl;\n        return 0;\n      }\n    }\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e5+5;\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<2];\nint ha[N], hb[N], tot;\nvoid _add(int *h, int x, int y) { edge[++tot] = Edge(h[x], y); h[x] = tot; }\nvoid add(int *h, int x, int y) { _add(h, x, y); _add(h, y, x); }\nint fa[N], son[N], size[N], top[N], d[N];\nint ans, cir;\nvoid dfs(int x)\n{\n    size[x] = 1;\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; if(y == fa[x]) continue;\n        d[y] = d[x]+1, fa[y] = x, dfs(y), \n        size[x] += size[y], son[x] = size[son[x]]>size[y]?son[x]:y; \n    }\n}\nint lca(int x, int y)\n{\n    while(top[x] != top[y])\n    {\n        if(d[top[x]] < d[top[y]]) swap(x, y);\n        x = fa[top[x]];\n    }\n    return d[x]<d[y]?x:y;\n}\nint dis(int x, int y) { return d[x]+d[y]-2*d[lca(x, y)]; }\nvoid dfs(int x, int topf)\n{\n    top[x] = topf; if(son[x]) dfs(son[x], topf);\n    for(int i = hb[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(y != fa[x]&&y != son[x]) dfs(y, y);\n    }\n}\nvoid escape(int x, int fa, int dep)\n{\n    ans = max(ans, d[x]<<1); \n    for(int i = ha[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; \n        if(y == fa||dep >= d[y]) continue;\n        if(dis(x, y) > 2) cir = 1;\n        escape(y, x, dep+1);\n    }\n}\nint n, a, b;\nint main()\n{\n    n = read(), a = read(), b = read();\n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(ha, x, y);\n    } \n    for(int i = 1; i < n; ++i)\n    {\n        int x = read(), y = read();\n        add(hb, x, y);\n    }\n    dfs(b); dfs(b, b); escape(a, 0, 0);\n    printf(\"%d\\n\", cir?-1:ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 200005, LOG = 20;\nconst int INF = 0x3f3f3f3f;\n\nvector<int> T1[NMAX], T2[NMAX];\nint father[NMAX], level[NMAX];\nint anc[LOG][NMAX];\n\nint dist[NMAX];\n\nvoid dfs(int node, int prev) {\n    father[node] = prev;\n    for (int to: T2[node]) {\n        if (to != prev) {\n            level[to] = level[node] + 1;\n            dfs(to, node);\n        }\n    }\n}\n\nint goUp(int x, int lvl) {\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (lvl & (1 << k)) {\n            x = anc[k][x];\n        }\n    }\n    return x;\n}\n\nint lca(int x, int y) {\n    if (level[y] > level[x]) {\n        y = goUp(y, level[y] - level[x]);\n    } else if (level[x] > level[y]) {\n        x = goUp(x, level[x] - level[y]);\n    }\n    if (x == y) {\n        return x;\n    }\n    for (int k = LOG - 1; k >= 0; --k) {\n        if (anc[k][x] != anc[k][y]) {\n            x = anc[k][x];\n            y = anc[k][y];\n        }\n    }\n    return father[x];\n}\n\nint xdist(int x, int y) {\n    return level[x] + level[y] - 2 * level[lca(x, y)];\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, r1, r2;\n    cin >> n >> r1 >> r2;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T1[x].push_back(y);\n        T1[y].push_back(x);\n    }\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        T2[x].push_back(y);\n        T2[y].push_back(x);\n    }\n    dfs(r2, -1);\n    father[r2] = r2;\n\n    for (int i = 1; i <= n; ++i) {\n        anc[0][i] = father[i];\n    }\n    for (int k = 1; k < LOG; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            anc[k][i] = anc[k - 1][anc[k - 1][i]];\n        }\n    }\n\n    memset(dist, INF, sizeof dist);\n    queue<int> q;\n    dist[r1] = 0;\n    q.push(r1);\n    int ans = 0;\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        ans = max(ans, 2 * level[node]);\n\n        for (int to: T1[node]) {\n            if (dist[to] > dist[node] + 1 && dist[node] + 1 <= level[to]) {\n                dist[to] = dist[node] + 1;\n                q.push(to);\n                if (xdist(node, to) > 2) {\n                    cout << \"-1\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=4e5+10;\n\nint n,x,y,fa[maxn],dep[maxn];\n\nstruct Tree{\n\tint tote,FIR[maxn],TO[maxn],NEXT[maxn];\n\n\tvoid addedge(int u,int v)\n\t{\n\t\tTO[++tote]=v;\n\t\tNEXT[tote]=FIR[u];\n\t\tFIR[u]=tote;\n\t}\n\n\tvoid dfs(int u)\n\t{\n//\t\tprintf(\"dfs %d : dep=%d\\n\",u,dep[u]);\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (fa[u]==v) continue;\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tdfs(v);\n\t\t}\n\t}\n\n\tint solve(int u,int f,int dis)\n\t{\n//\t\tprintf(\"u=%d\\n\",u);\n\t\tint Ans=dep[u];\n\t\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (v==f) continue;\n\t\t\tif (dis+1>=dep[v]) continue;\n\t\t\tbool flag=fa[v]==u||fa[u]==v||fa[fa[v]]==u||fa[fa[u]]==v||fa[u]==fa[v];\n\t\t\tif (!flag) return 1e8;\n//\t\t\tprintf(\"solving %d : %d--->%d\\n\",u,u,v);\n\t\t\tAns=max(Ans,solve(v,u,dis+1));\n\t\t}\n\t\treturn Ans;\n\t}\n}red,blue;\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,u,v;\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tred.addedge(u,v);\n\t\tred.addedge(v,u);\n\t}\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tblue.addedge(u,v);\n\t\tblue.addedge(v,u);\n\t}\n\tblue.dfs(y);\n\tint Ans=red.solve(x,0,0);\n\tif (Ans>=1e7) puts(\"-1\");\n\telse printf(\"%d\\n\",Ans*2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\ntypedef pair<int,int> pii;\nint n, x, y, dep[200005], par[20][200005];\nint da[200005], db[200005];\n\nvector<int> ra[200005], rb[200005];\nvector<pii> red;\n\nqueue<int> q;\n\nvoid calc (int cur, int prv) {\n\tdep[cur] = dep[prv] + 1;\n\tpar[0][cur] = prv;\n\tfor(auto &nxt : rb[cur]) {\n\t\tif(nxt == prv) continue;\n\t\tcalc(nxt, cur);\n\t}\n}\n\nint getdist (int A, int B) {\n\tif(dep[A] < dep[B]) swap(A, B);\n\tint ret = 0;\n\tfor(int i=20;i--;) {\n\t\tif(dep[A] - dep[B] >= (1<<i)) {\n\t\t\tA = par[i][A]; ret += (1<<i);\n\t\t}\n\t}\n\tif(A == B) return ret;\n\tfor(int i=20;i--;) {\n\t\tif(par[i][A] != par[i][B]) {\n\t\t\tA = par[i][A]; B = par[i][B];\n\t\t\tret += (1<<i) * 2;\n\t\t}\n\t}\n\treturn ret + 2;\n}\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\tred.push_back({A, B});\n\t\tra[A].push_back(B);\n\t\tra[B].push_back(A);\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tint A, B;\n\t\tscanf(\"%d%d\",&A,&B);\n\t\trb[A].push_back(B);\n\t\trb[B].push_back(A);\n\t}\n\tcalc(1, 0);\n\tfor(int k=1;k<20;k++) {\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tpar[k][i] = par[k-1][par[k-1][i]];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) {da[i] = inf; db[i] = inf;}\n\tdb[y] = 2; q.push(y);\n\twhile(!q.empty()) {\n\t\tint cur = q.front(); q.pop();\n\t\tfor(auto &nxt : rb[cur]) {\n\t\t\tif(db[nxt] == inf) {\n\t\t\t\tdb[nxt] = db[cur] + 2;\n\t\t\t\tq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\tda[x] = 1; q.push(x);\n\twhile(!q.empty()) {\n\t\tint cur = q.front(); q.pop();\n\t\tfor(auto &nxt : ra[cur]) {\n\t\t\tif(da[nxt] == inf && db[nxt] > da[cur] + 2) {\n\t\t\t\tda[nxt] = da[cur] + 2;\n\t\t\t\tq.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto &T : red) {\n\t\tint A = T.first, B = T.second;\n\t\tif(getdist(A, B) >= 3 && (da[A] != inf && da[B] != inf)) {\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tif(da[i] != inf) ans = max(ans, db[i]);\n\t}\n\tprintf(\"%d\\n\",ans-2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 2e5 + 5, M = N * 2 , inf = 1e9 + 7;\nusing namespace std ;\n\nbool vis[N], path[N] ;\nint n, rt, S, e, ter[M], nxt[M], lnk[N], dep[N], fa[N], ans ;\nstruct edge {\n\tint x, y ;\n} ed[N] ;\n\nvoid add(int x, int y) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e ;\n}\n\nvoid dfs(int p, int las) {\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) {\n\t\tdep[ter[i]] = dep[p] + 1 ;\n\t\tfa[ter[i]] = p ;\n\t\tdfs(ter[i], p) ;\n\t}\n}\n\nvoid dfs2(int p, int las, int len) {\n\tif (ans == inf) return ;\n\tif (dep[p] < len) {\n\t\tans = max(ans, (len - 1) * 2 + 1) ;\n\t\treturn ;\n\t}\n\tif (dep[p] == len) {\n\t\tans = max(ans, len * 2) ;\n\t\treturn ;\n\t}\n\tif (vis[p]) {\n\t\tans = inf ;\n\t\treturn ;\n\t}\n\tbool flg = false ;\n\tfor (int i = lnk[p] ; i; i = nxt[i]) if (ter[i] != las) flg = true, dfs2(ter[i], p, len + 1) ;\n\tif (!flg) {\n\t\tans = max(ans, dep[p] * 2) ;\n\t\treturn ;\n\t}\n}\n\nbool chk(int x, int y) {\n\tif (dep[x] < dep[y]) swap(x, y) ;\n\tif (fa[x] == y) return false ;\n\tif (fa[fa[x]] == y) return false ;\n\tif (fa[x] == fa[y]) return false ;\n\treturn true ;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &S, &rt) ;\n\trep(i, 1, n - 1) scanf(\"%d%d\", &ed[i].x, &ed[i].y) ;\n\tint x, y ;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &x, &y) ;\n\t\tadd(x, y), add(y, x) ;\n\t}\n\tdfs(rt, 0) ;\n\trep(i, 1, n - 1) if (chk(ed[i].x, ed[i].y)) vis[ed[i].x] = vis[ed[i].y] = true ;\n\trep(i, 1, n) lnk[i] = 0 ;\n\trep(i, 1, e) nxt[i] = 0 ; e = 0 ;\n\trep(i, 1, n - 1) add(ed[i].x, ed[i].y), add(ed[i].y, ed[i].x) ;\n\tdfs2(S, 0, 0) ;\n\tif (ans == (int) (1e9 + 7)) {\n\t\tprintf(\"-1\\n\") ;\n\t} else printf(\"%d\\n\", ans) ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct Tree\n{\n\tstruct data\n\t{\n\t\tll w;\n\t};\n\t\n\tstruct node\n\t{\n\t\tint p; //parent\n\t\tll w; //modify for different problems\n\t};\n\t\n\tstruct edge\n\t{\n\t\tint v; data dat;\n\t};\n\t\n\tvector<vector<edge> > adj;\n\tint n;\n\tint s;\n\t\n\tTree(int _n, int _s)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n; s = _s;\n\t}\n\t\n\tvi level;\n\tvi depth;\n\tvi h;\n\tvi euler;\n\tvi firstocc;\n\tvector<vi> rmqtable;\n\tvi subsize;\n\tvi start; vi en;\n\tvector<vector<node> > st;\n\t\n\tvoid addedge(int u, int v)\n\t{\n\t\tedge tmp; tmp.v = v;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset(int _n)\n\t{\n\t\tadj.clear();\n\t\tlevel.clear();\n\t\tdepth.clear();\n\t\teuler.clear();\n\t\trmqtable.clear();\n\t\tsubsize.clear();\n\t\tstart.clear();\n\t\ten.clear();\n\t\tst.clear();\n\t\tfirstocc.clear();\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid dfssub(int u, int p)\n\t{\n\t\tsubsize[u] = 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfssub(v, u);\n\t\t\tsubsize[u] += subsize[v];\n\t\t}\n\t}\n\t\n\tvoid calcsub()\n\t{\n\t\tsubsize.resize(n);\n\t\tdfssub(0, -1);\n\t}\n\t\n\tint timer;\n\t\n\tvoid dfsstartend(int u, int p)\n\t{\n\t\tstart[u] = ++timer;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfsstartend(v, u);\n\t\t}\n\t\ten[u] = ++timer;\n\t}\n\t\n\tvoid calcstartend()\n\t{\n\t\ttimer = 0;\n\t\tstart.resize(n); en.resize(n); h.resize(n);\n\t\tdfsstartend(0, -1);\n\t}\n\t\n\tint eulercnt;\n\t\n\tvoid dfseuler(int u, int p)\n\t{\n\t\teuler[eulercnt] = u; eulercnt++;\n\t\tif(p == -1) {depth[u] = 0;}\n\t\telse {depth[u] = depth[p] + 1;}\n\t\tfirstocc[u] = eulercnt-1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue ;\n\t\t\tdfseuler(v, u);\n\t\t\teuler[eulercnt] = u; eulercnt++;\n\t\t}\n\t}\n\t\n\tvoid calceuler()\n\t{\n\t\teulercnt = 0;\n\t\tlevel.assign(2*n+1, 0);\n\t\teuler.assign(2*n+1, 0);\n\t\tdepth.assign(n, 0);\n\t\tfirstocc.resize(n);\n\t\tdfseuler(s, -1);\n\t}\n\n\tvoid filllevel()\n\t{\n\t\tint LG = 0;\n\t\twhile((1<<LG) <= n*2) LG++;\n\t\trmqtable.resize(LG);\n\t\tfor(int i = 0; i < LG; i++) rmqtable[i].resize(eulercnt);\n\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t{\n\t\t\tlevel[i] = depth[euler[i]];\n\t\t}\n\t\tlevel[eulercnt] = 1000000000;\n\t\tfor(int j = 0; j < LG; j++)\n\t\t{\n\t\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t\t{\n\t\t\t\trmqtable[j][i] = eulercnt;\n\t\t\t\tif(i + (1<<j) - 1 < eulercnt)\n\t\t\t\t{\n\t\t\t\t\tif(j == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trmqtable[j][i] = i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(level[rmqtable[j - 1][i]] < level[rmqtable[j-1][i + (1<<(j-1))]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i + (1<<(j-1))];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint rmq(int l, int r)\n\t{\n\t\tint k = 31 - __builtin_clz(r-l);\n\t\t//cout << l << ' ' << r << ' ' << rmqtable[l][k] << ' ' << rmqtable[r - (1<<k) + 1][k] << endl;\n\t\tif(level[rmqtable[k][l]] < level[rmqtable[k][r - (1<<k) + 1]])\n\t\t{\n\t\t\treturn rmqtable[k][l];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn rmqtable[k][r - (1<<k) + 1];\n\t\t}\n\t}\n\n\tint lcaeuler(int u, int v)\n\t{\n\t\tif(firstocc[u] > firstocc[v]) swap(u, v);\n\t\t//cerr << firstocc[u] << ' ' << firstocc[v] << ' ' << rmq(firstocc[u], firstocc[v]) << ' ' << euler[rmq(firstocc[u], firstocc[v])] << endl;\n\t\treturn euler[rmq(firstocc[u], firstocc[v])];\n\t}\n\t\n\tbool insub(int u, int v) //is u in the subtree of v?\n\t{\n\t\tif(start[v] <= start[u] && en[u] <= en[v]) return true;\n\t\treturn false;\n\t}\n\t\n\tvoid dfspar(int u, int p)\n\t{\n\t\t//cerr << u << ' ' << p << '\\n';\n\t\tst[0][u].p = p;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfspar(v, u);\n\t\t}\n\t}\n\t\n\tint LOG;\n\t\n\tvoid calcpar()\n\t{\n\t\th.resize(n);\n\t\tint LG = 0; LOG = 0;\n\t\twhile((1<<LG) <= n) {LG++; LOG++;}\n\t\tst.resize(LG);\n\t\tfor(int i = 0; i < LG; i++)\n\t\t{\n\t\t\tst[i].resize(n);\n\t\t}\n\t\tdfspar(s, -1);\n\t\t//cerr << \"HER\" << ' ' << LG << endl;\n\t\tfor(int i = 1; i < LG; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tif(st[i-1][j].p == -1) st[i][j].p = -1;\n\t\t\t\telse st[i][j].p = st[i-1][st[i-1][j].p].p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getpar(int u, ll k)\n\t{\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(k&(1<<i))\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t}\n\t\t}\n\t\treturn u;\n\t}\n\t\n\tint lca(int u, int v)\n\t{\n\t\tif(h[u] > h[v]) swap(u, v);\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && h[st[i][v].p] >= h[u])\n\t\t\t{\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && st[i][v].p != st[i][u].p)\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\treturn st[0][u].p;\n\t}\n\n\tint distance(int u, int v)\n\t{\n\t\tint lc = lca(u, v);\n\t\treturn (h[u]+h[v]-2*h[lc]);\n\t}\n};\n\nint U[211111],V[211111];\nvi adj[211111];\nint dist[211111];\nbool bad[211111];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n; int s,e; cin>>s>>e; s--; e--;\n\tTree T(n,e);\n\tfor(int i=0;i<n-1;i++){cin>>U[i]>>V[i]; U[i]--; V[i]--;}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u,v; cin>>u>>v; u--; v--;\n\t\tT.addedge(u,v);\n\t}\n\tT.calcpar();\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u=U[i]; int v=V[i];\n\t\tif(T.distance(u,v)>=3) bad[u]=bad[v]=1;\n\t\telse {adj[u].pb(v); adj[v].pb(u);}\n\t}\n\tfor(int i=0;i<n;i++) dist[i]=int(1e9);\n\tdist[s]=0;\n\tqueue<int> q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front(); q.pop();\n\t\tfor(int i=0;i<adj[u].size();i++)\n\t\t{\n\t\t\tint v=adj[u][i];\n\t\t\tif(dist[v]>=int(1e9))\n\t\t\t{\n\t\t\t\tif(dist[u]+1<T.h[v])\n\t\t\t\t{\n\t\t\t\t\tdist[v]=dist[u]+1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(dist[i]<int(1e9)&&bad[i])\n\t\t{\n\t\t\tcout<<-1<<'\\n'; return 0;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(dist[i]<int(1e9))\n\t\t{\n\t\t\tans=max(ans,2*T.h[i]);\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int NN = 2e5 + 5;\nstruct E {\n\tint v, nxt;\n\tE(int _v=0, int _nxt=0) : v(_v), nxt(_nxt) {}\n};\nstruct Graph {\n\tint head[NN], totE;\n\tE edge[NN*2];\n\tvoid AddEdge(int u, int v) {\n\t\tedge[++totE] = E(v, head[u]);\n\t\thead[u] = totE;\n\t}\n} a, b;\nint N, X, Y, da[NN], db[NN], fab[NN];\nbool save[NN];\nvoid Dfs1(int u, int fr) {\n\tfab[u] = fr;\n\tdb[u] = db[fr] + 1;\n\tfor (int p = b.head[u]; p; p = b.edge[p].nxt) {\n\t\tint v = b.edge[p].v; //注意两棵树别用串了 \n\t\tif (v != fr)\n\t\t\tDfs1(v, u);\n\t}\n}\nbool inf, edgetag[NN];\nvoid Dfs2(int u, int fr, int is) {\n\tda[u] = da[fr] + 1;\n\tif (da[u] >= db[u]) is = 0;\n\telse if (is) {\n\t\tsave[u] = 1;\n\t}\n\tif (fr != 0) {\n\t\tint x = u, y = fr;\n\t\tif (db[x] < db[y]) swap(x, y);\n\t\tif (fab[x] == fab[y] || fab[x] == y || fab[fab[x]] == y) ;\n\t\telse if (save[u] || save[fr]) {\n\t\t\tinf = 1;\n\t\t\tedgetag[u] = 1;\n\t\t}\n\t}\n\tfor (int p = a.head[u]; p; p = a.edge[p].nxt) {\n\t\tint v = a.edge[p].v;\n\t\tif (v != fr) {\n\t\t\tDfs2(v, u, is);\n\t\t\tif (edgetag[v] && (save[u] || save[v]))\n\t\t\t\tinf = 1;\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\ta.AddEdge(u, v);\n\t\ta.AddEdge(v, u);\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tb.AddEdge(u, v);\n\t\tb.AddEdge(v, u);\n\t}\n\tDfs1(Y, 0);\n\tDfs2(X, 0, 1);\n\tif (inf) printf(\"-1\\n\");\n\telse {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tif (save[i]) {\n\t\t\t\tans = max(ans, db[i]-1);\n\t\t\t}\n\t\tans *= 2;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int NN = 2e5 + 5;\nstruct E {\n\tint v, nxt;\n\tE(int _v=0, int _nxt=0) : v(_v), nxt(_nxt) {}\n};\nstruct Graph {\n\tint head[NN], totE;\n\tE edge[NN*2];\n\tvoid AddEdge(int u, int v) {\n\t\tedge[++totE] = E(v, head[u]);\n\t\thead[u] = totE;\n\t}\n} a, b;\nint N, X, Y, da[NN], db[NN], fab[NN];\nbool save[NN];\nvoid Dfs1(int u, int fr) {\n\tfab[u] = fr;\n\tdb[u] = db[fr] + 1;\n\tfor (int p = b.head[u]; p; p = b.edge[p].nxt) {\n\t\tint v = b.edge[p].v; //注意两棵树别用串了 \n\t\tif (v != fr)\n\t\t\tDfs1(v, u);\n\t}\n}\nbool inf;\nvoid Dfs2(int u, int fr) {\n\tda[u] = da[fr] + 1;\n\tif (da[u] >= db[u]) return ;\n\tsave[u] = 1;\n\tif (fr != 0) {\n\t\tint x = u, y = fr;\n\t\tif (db[x] < db[y])\n\t\t\tswap(x, y);\n\t\tif (fab[x] == fab[y] || fab[x] == y || fab[fab[x]] == y) ;\n\t\telse inf = 1;\n\t}\n\tfor (int p = a.head[u]; p; p = a.edge[p].nxt) {\n\t\tint v = a.edge[p].v;\n\t\tif (v != fr)\n\t\t\tDfs2(v, u);\n\t}\n}\nint main() {\n\tprintf(\"-1\\n\");\n//\tscanf(\"%d%d%d\", &N, &X, &Y);\n//\tfor (int i = 1; i < N; ++i) {\n//\t\tint u, v;\n//\t\tscanf(\"%d%d\", &u, &v);\n//\t\ta.AddEdge(u, v);\n//\t\ta.AddEdge(v, u);\n//\t}\n//\tfor (int i = 1; i < N; ++i) {\n//\t\tint u, v;\n//\t\tscanf(\"%d%d\", &u, &v);\n//\t\tb.AddEdge(u, v);\n//\t\tb.AddEdge(v, u);\n//\t}\n//\tDfs1(Y, 0);\n//\tDfs2(X, 0);\n//\tif (inf) printf(\"-1\\n\");\n//\telse {\n//\t\tint ans = 0;\n//\t\tfor (int i = 1; i <= N; ++i)\n//\t\t\tif (save[i])\n//\t\t\t\tans = max(ans, db[i]-1);\n//\t\tans *= 2;\n//\t\tprintf(\"%d\\n\", ans);\n//\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define fr(N,i,x) for (int i=N.lnk[x];i;i=N.nxt[i])\nusing namespace std;\nconst int maxn=200005,maxe=maxn<<1;\nint n,X,Y,dst[maxn],fa[maxn],Dst[maxn],Q[maxn],ans;bool vis[maxn];\nstruct ljb{\n\tint e,lnk[maxn],nxt[maxe],son[maxe];\n\tinline void add_e(int x,int y){son[++e]=y;nxt[e]=lnk[x];lnk[x]=e;}\n}A,B;\ninline char nc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read(){\n\tint ret=0;bool f=0;char ch=nc();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=nc();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=nc();\n\treturn f?-ret:ret;\n}\nvoid DFS(int x){fr(B,i,x) if(B.son[i]^fa[x]) dst[B.son[i]]=dst[x]+1,fa[B.son[i]]=x,DFS(B.son[i]);}\ninline void BFS(){\n\tint hed=0,til=1;Q[vis[X]=1]=X;\n\twhile(hed++<til) if(Dst[Q[hed]]<dst[Q[hed]]) fr(A,i,Q[hed])\n\tif(!vis[A.son[i]]) vis[A.son[i]]=1,Dst[A.son[i]]=Dst[Q[hed]]+1,Q[++til]=A.son[i];\n}\ninline bool check(int x,int y){\n\tif(dst[x]>dst[y]){int t=x;x=y;y=t;}\n\tif(dst[y]-dst[x]==2) return fa[fa[y]]==x;\n\tif(dst[y]-dst[x]==1) return fa[y]==x;\n\tif(dst[y]-dst[x]==0) return fa[x]==fa[y];\n\treturn 0;\n}\nint main(){\n\tn=read(),X=read(),Y=read();\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),A.add_e(x,y),A.add_e(y,x);\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),B.add_e(x,y),B.add_e(y,x);\n\tdst[Y]=0;DFS(Y);BFS();\n\tfor (int i=1;i<=n;i++) if(vis[i]){\n\t\tif(Dst[i]<=dst[i]&&dst[i]>ans) ans=dst[i];\n\t\tif(Dst[i]<dst[i]) fr(A,j,i) if(!check(A.son[j],i)) ans=1e9;\n\t}\n\tprintf(\"%d\\n\",ans==1e9?-1:ans<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\nstruct Edge{\n    int from,to;\n    Edge(int from,int to)\n        : from(from),to(to){};\n    Edge(){Edge(0,0);}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct HeavyLightDecomposition{\n    vector<int> index, htop, hchild, par, dep, idtov, topo,sub,heads;\n    Graph T;\n    HeavyLightDecomposition(int n) :index(n,-1),htop(n),hchild(n,-1),par(n),dep(n),idtov(n),sub(n),T(n){}\n\n    void calc(int root){\n        queue<int> Q({root});\n        par[root]=-1;\n        while(!Q.empty()){\n            int curr=Q.front(); Q.pop(); topo.push_back(curr);\n            for(auto &x: T[curr]){\n                if(x.to!=par[curr]){\n                    par[x.to]=x.from;\n                    Q.push(x.to);\n                    dep[x.to]=dep[x.from]+1;\n                }\n            }\n        }\n        heads.push_back(root);\n        for(int i=par.size()-1,msub=0; i>=0; --i){\n            ++sub[topo[i]];\n            if(i>0)sub[par[topo[i]]]+=sub[topo[i]];\n            if(i<par.size()-1)if(par[topo[i+1]]!=par[topo[i]])msub=0;\n            if(sub[topo[i]]>msub) hchild[par[topo[i]]]=topo[i];\n            for(auto &x : T[topo[i]])if(x.to!=par[topo[i]]&&x.to!=hchild[topo[i]]) heads.push_back(x.to);\n        }\n        int id=0;\n        for(int x : heads) {\n            for(int i=x; i!=-1; i=hchild[i]){\n                index[i]=id++;\n                idtov[index[i]]=i;\n                htop[i]=x;\n            }\n        }\n    }\n    inline bool same(int a,int b){return htop[a]==htop[b];}\n\n    int lca(int a, int b){\n        if(index[a]>index[b])swap(a,b);\n        if(same(a,b)) return a;\n        return lca(a,par[htop[b]]);\n    }\n    int dist(int a, int b){\n        return dep[a]+dep[b]-2*dep[lca(a,b)];\n    }\n};\n\nstruct Problem{\n    int size,gma,gim;\n    HeavyLightDecomposition sigma,sugim;\n    Problem(int n):size(n),sigma(n),sugim(n){};\n    void input(HeavyLightDecomposition &hl){\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            hl.T[a].push_back(Edge(a,b));\n            hl.T[b].push_back(Edge(b,a));\n        }\n    }\n    bool is_sigma_nearer(int i){\n        return sigma.dist(i,gma)<sugim.dist(i,gim);\n    }\n    int dfs(int par, int cur){\n        if(!is_sigma_nearer(cur)) return -INF;\n        if(par!=-1 and sugim.dist(par,cur)>=3) return INF;\n        if(sigma.T[cur].size()==1 and sigma.T[cur][0].to==par){\n            return sugim.dist(cur,gim);\n        }\n        int ret=sugim.dist(cur,gim);\n        for(auto e: sigma.T[cur]){\n            if(e.to!=par){\n                ret=max(ret,dfs(cur,e.to));\n            }\n        }\n        return ret;\n    }\n\n    void solve(){\n        cin >> gma >> gim;\n        --gma;--gim;\n        input(sigma);\n        input(sugim);\n        sigma.calc(gma);\n        sugim.calc(gim);\n        int ans=dfs(-1,gma);\n        if(ans==INF)cout << -1 <<\"\\n\";\n        else cout << ans*2<<\"\\n\";\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    Problem e(n);\n    e.solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std; \nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N], dfn;\nint dp[N << 1][20], lg2[N], dph[N];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x])\n        if (y != fx) dfsb(y, x);\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] > db[x]) return;\n    if (~ans) ans = max((db[x] - 1)<<1, ans);\n    for (int y : a[x]) {\n        if (dph[x] + dph[y] - 2 * dph[LCA(x, y)] > 2) ans = -1;\n        if (y != fx) dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr LL LINF=334ll<<53;\nconstexpr int INF=15<<26;\nconstexpr LL  MOD=1E9+7;\nstruct Edge{\n    int from,to;\n    Edge(int from,int to)\n        : from(from),to(to){};\n    Edge(){Edge(0,0);}\n};\ntypedef vector<vector<Edge>> Graph;\n\nstruct HeavyLightDecomposition{\n    vector<int> index, htop, hchild, par, dep, idtov, topo,sub,heads;\n    Graph T;\n    HeavyLightDecomposition(int n) :index(n,-1),htop(n),hchild(n,-1),par(n),dep(n),idtov(n),sub(n),T(n){}\n\n    void calc(int root){\n        queue<int> Q({root});\n        par[root]=-1;\n        while(!Q.empty()){\n            int curr=Q.front(); Q.pop(); topo.push_back(curr);\n            for(auto &x: T[curr]){\n                if(x.to!=par[curr]){\n                    par[x.to]=curr;\n                    Q.push(x.to);\n                    dep[x.to]=dep[curr]+1;\n                }\n            }\n        }\n        for(int i=par.size()-1,max_sub=0; i>=0; --i){\n            ++sub[topo[i]];\n            if(i>0)sub[par[topo[i]]]+=sub[topo[i]];\n            if(i>0 and i<par.size()-1)if(par[topo[i+1]]!=par[topo[i]])max_sub=0;\n            if(i>0 and sub[topo[i]]>max_sub) {\n                hchild[par[topo[i]]]=topo[i];\n                max_sub=sub[topo[i]];\n            }\n            for(auto &x : T[topo[i]])if(x.to!=par[topo[i]] and x.to!=hchild[topo[i]]) heads.push_back(x.to);\n        }\n        heads.push_back(root);\n        reverse(heads.begin(),heads.end());\n        DBG(heads.size())\n        int id=0;\n        for(int x : heads) {\n            for(int i=x; i!=-1; i=hchild[i]){\n                index[i]=id++;\n                idtov[index[i]]=i;\n                htop[i]=x;\n            }\n        }\n    }\n    inline bool same(int a,int b){return htop[a]==htop[b];}\n\n    int lca(int a, int b,int cnt=0){\n        if(index[a]>index[b])swap(a,b);\n        if(same(a,b)) {DBG(cnt)return a;}\n        return lca(a,par[htop[b]],cnt+1);\n    }\n    int dist(int a, int b){\n        return dep[a]+dep[b]-2*dep[lca(a,b)];\n    }\n};\n\nstruct Problem{\n    int size,x,y;\n    HeavyLightDecomposition sigma,sugim;\n    Problem(int n):size(n),sigma(n),sugim(n){};\n\n    int dfs(int par, int cur, int d){\n        int d2=sugim.dist(cur,y);\n        if(d>=d2) return -INF;\n        if(sigma.T[cur].size()==1 and sigma.T[cur][0].to==par){\n            return d2;\n        }\n        int ret=d2;\n        for(auto e: sigma.T[cur]){\n            if(e.to!=par){\n                if(sugim.dist(cur,e.to)>=3) return INF;\n                ret=max(ret,dfs(cur,e.to,d+1));\n            }\n        }\n        return ret;\n    }\n\n    void solve(){\n        cin >> x >> y;\n        --x;--y;\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            sigma.T[a].push_back(Edge(a,b));\n            sigma.T[b].push_back(Edge(b,a));\n        }\n        for(int i=0; i<size-1; ++i){\n            int a,b;\n            cin >> a >> b;\n            --a;--b;\n            sugim.T[a].push_back(Edge(a,b));\n            sugim.T[b].push_back(Edge(b,a));\n        }\n        //sigma.calc(x);\n        sugim.calc(y);\n        int ans=dfs(-1,x,0);\n        if(ans==INF)cout << -1 <<\"\\n\";\n        else cout << ans*2<<\"\\n\";\n    }\n\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    Problem e(n);\n    e.solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n, x, y;\nvector<int> G[200005], g[200005], g2[200005];\nbool valid[200005], win[200005];\nint dist[200005], dist2[200005];\n\nint Prev[200005][18];\nint depth[200005];\n\nint getLCA(int u, int v){\n\tint x = u, y = v;\n\tif(depth[y] > depth[x]) swap(x, y);\n\t\n\tfor(int i = 17; i >= 0; i--){\n\t\tif(depth[x] - (1<<i) >= depth[y]) x = Prev[x][i];\n\t}\n\tif(x == y) return x;\n\tfor(int i = 17; i >= 0; i--){\n\t\tif(Prev[x][i] != Prev[y][i]){\n\t\t\tx = Prev[x][i];\n\t\t\ty = Prev[y][i];\n\t\t}\n\t}\n\tx = Prev[x][0];\n\treturn x;\n}\n\nvoid predfs(int v, int p, int d)\n{\n\tdepth[v] = d;\n\tPrev[v][0] = p;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tpredfs(G[v][i], v, d+1);\n\t}\n}\n\nvoid dfs(int v, int p, int d, int dist[], vector<int> G[])\n{\n\tdist[v] = d;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tdfs(G[v][i], v, d+1, dist, G);\n\t}\n}\n\nint dfs2(int v, int p)\n{\n\tif(win[v]) return -1;\n\t\n\tint ret = dist[v];\n\tfor(int i = 0; i < g2[v].size(); i++){\n\t\tif(g2[v][i] == p) continue;\n\t\tif(!valid[g2[v][i]]) continue;\n\t\tint res = dfs2(g2[v][i], v);\n\t\tif(res == -1) return -1;\n\t\tret = max(ret, res);\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> x >> y;\n\tint u, v;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tpredfs(1, 0, 0);\n\tfor(int i = 1; i < 18; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tPrev[j][i] = Prev[Prev[j][i-1]][i-1];\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\tint dist = depth[i] + depth[g[i][j]] - 2*depth[getLCA(i, g[i][j])];\n\t\t\tif(dist >= 3) win[i] = win[g[i][j]] = true;\n\t\t\telse g2[i].push_back(g[i][j]);\n\t\t}\n\t}\n\t\n\tdfs(x, -1, 0, dist2, g2);\n\tdfs(y, -1, 0, dist, G);\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tif(dist[i] > dist2[i]) valid[i] = true;\n\t}\n\t\n\tint ret = dfs2(x, -1);\n\tif(ret != -1) ret *= 2;\n\tcout << ret << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=200000+10;\nint h[maxn],go[maxn*4],nxt[maxn*4],co[maxn*4],e[maxn][2];\nint dfn[maxn],low[maxn],dep[maxn],d[maxn],dl[maxn],fa[maxn];\nbool bz[maxn],pd[maxn];\nint i,j,k,l,t,n,m,x,y,tot,top,ans,head,tail;\nvoid add(int x,int y,int z){\n\tgo[++tot]=y;\n\tco[tot]=z;\n\tnxt[tot]=h[x];\n\th[x]=tot;\n}\nvoid dfs(int x,int y){\n\tfa[x]=y;\n\tdfn[x]=++top;\n\tint t=h[x];\n\twhile (t){\n\t\tif (co[t]&&go[t]!=y){\n\t\t\tdep[go[t]]=dep[x]+1;\n\t\t\tdfs(go[t],x);\n\t\t}\n\t\tt=nxt[t];\n\t}\n\tlow[x]=++top;\n}\nbool check(int x,int y){\n\tif (dfn[x]>dfn[y]) swap(x,y);\n\tif (dfn[x]<=dfn[y]&&low[x]>=low[y]) return dep[y]-dep[x]>2;\n\tif (fa[x]==fa[y]) return 0;else return 1;\n}\nvoid bfs(){\n\tint now,t;\n\tpd[x]=1;\n\tdl[tail=1]=x;\n\twhile (head<tail){\n\t\tnow=dl[++head];\n\t\tt=h[now];\n\t\twhile (t){\n\t\t\tif (!co[t]&&!pd[go[t]]){\n\t\t\t\td[go[t]]=d[now]+1;\n\t\t\t\tif (d[go[t]]<dep[go[t]]){\n\t\t\t\t\tpd[go[t]]=1;\n\t\t\t\t\tdl[++tail]=go[t];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt=nxt[t];\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfo(i,1,n-1){\n\t\tscanf(\"%d%d\",&j,&k);\n\t\t//add(j,k,0);add(k,j,0);\n\t\te[i][0]=j;e[i][1]=k;\n\t}\n\tfo(i,1,n-1){\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tadd(j,k,1);add(k,j,1);\n\t}\n\tdfs(y,0);\n\tfo(i,1,n-1){\n\t\tj=e[i][0];k=e[i][1];\n\t\tif (check(j,k)) bz[j]=bz[k]=1;\n\t\telse{\n\t\t\tadd(j,k,0);\n\t\t\tadd(k,j,0);\n\t\t}\n\t}\n\tbfs();\n\tfo(i,1,n){\n\t\tif (pd[i]&&bz[i]){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if (pd[i]) ans=max(ans,dep[i]*2);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DIM = 2e5 + 5;\n\ndeque<pair<int, int>> que;\nvector<int> edg[DIM], axe[DIM];\n\nint lev[DIM], fth[DIM];\nbool oki[DIM], mrk[DIM];\n\nvoid dfs( int x, int f ) {\n    lev[x] = lev[f] + 1; fth[x] = f;\n    \n    for( int y : edg[x] )\n        if( y != f )\n            dfs( y, x );\n    \n    return;\n}\n\nint main( void ) {\n    \n    int n, x, y;\n    cin >> n >> x >> y;\n    \n    for( int i = 2; i <= n; i ++ ) {\n        int x, y;\n        cin >> x >> y;\n        \n        axe[x].push_back( y );\n        axe[y].push_back( x );\n    }\n    \n    for( int i = 2; i <= n; i ++ ) {\n        int x, y;\n        cin >> x >> y;\n        \n        edg[x].push_back( y );\n        edg[y].push_back( x );\n    }\n    \n    lev[0] = -1; dfs( y, 0 );\n    for( int i = 1; i <= n; i ++ ) {\n        for( int j : axe[i] ) {\n            bool ok = true;\n            int x = i, y = j;\n            \n            if( lev[x] > lev[y] )\n                swap( x, y );\n            \n            if( fth[x] == fth[y] ) ok = false;\n            if( fth[fth[y]] == x ) ok = false;\n            if( fth[y] == x )      ok = false;\n            \n            if( ok == true )\n                oki[x] = oki[y] = true;\n        }\n    }\n    \n    mrk[x] = true; int ans = 0;\n    que.push_back( make_pair( x, 0 ) );\n    for( ; que.empty() == false; que.pop_front() ) {\n        pair<int, int> x = que.front();\n        ans = max( ans, lev[x.first] * 2 );\n        \n        if( oki[x.first] == true )\n            ans = 1e9;\n        \n        for( int y : axe[x.first] ) {\n            if( mrk[y] == 1 || x.second + 1 >= lev[y] )\n                continue;\n            \n            mrk[y] = true;\n            que.push_back( make_pair( y, x.second + 1 ) );\n        }\n    }\n    \n    if( ans == 1e9 )\n        ans = -1;\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nvector<int> v[2][200005];\nint p[20][200005];\nint dis[200005];\nvoid dfs(int x,int f, vector<int> *v){\n    dis[ x ] = dis[ f ] + 1;\n    p[ 0 ][ x ] = f;\n    for(auto it : v[x]){\n        if(it != f){\n            dfs(it, x, v);\n        }\n    }\n}\nvoid build(int n){\n    for(int i = 1 ; i < 20 ; i++){\n        for(int j = 1 ; j <= n ; j++){\n            p[ i ][ j ] = p[ i - 1 ][ p[ i - 1 ][ j ] ];\n        }\n    }\n}\nint lca(int x, int y){\n    if (dis[ x ] > dis[ y ])swap(x, y);\n    int d = dis[ y ] - dis[ x ];\n    for(int i = 0 ; i < 20 ; i++ ){\n        if( d & (1 << i) ){\n            y = p[ i ][ y ];\n        }\n    }\n    if (x == y)\n        return x;\n    for(int i = 19 ; i >= 0 ; i-- ){\n        if( p[ i ][ x ] != p[ i ][ y ] ){\n            x = p[ i ][ x ];\n            y = p[ i ][ y ];\n        }\n    } \n    return p[ 0 ][ x ];\n}\nint getdis(int x, int y){\n    return dis[ x ] + dis[ y ] - dis[ lca(x, y) ];\n}\nvoid dfs2(int x,int f,vector<int> *v,int sum=0){\n    if(dis[x]<=sum)return;\n    for(auto it:v[x]){\n        if( it != f){\n            if(getdis(x,it)>=3&&dis[x] > sum){\n              //  printf(\"%d %d %d %d %d\\n\",x,it,dis[x],sum,getdis(x,it));\n                printf(\"-1\\n\");\n                exit(0);\n            }\n            dfs2(it, x, v, sum+1);\n        }\n    }\n}\nint main(){\n    int n, x, y;\n    scanf(\"%d %d %d\", &n, &x, &y);\n    for(int i = 0 ; i < 2 ; i++ ){\n        for(int j = 1 ; j < n ; j++ ){\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            v[i][x].pb(y);\n            v[i][y].pb(x);\n        }\n    }\n    dis[0]=-1;\n    dfs(y, 0, v[1]);\n    build(n);\n    dfs2(x, 0, v[0]);\n}\n/*\n\nb[i]*K!/(i)!*(K-i)!\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MaxN = 2e5 + 5;\n\nvector<int> gb[MaxN], gr[MaxN];\n\nint dep[MaxN], fa[MaxN], d[MaxN];\nbool safe[MaxN], vis[MaxN];\n\nvoid Dfs(int x, int f) {\n  ::fa[x] = f;\n  for (int k : gb[x]) {\n    if (k != f) {\n      dep[k] = dep[x] + 1;\n      Dfs(k, x);\n    }\n  }\n}\n\n#define fin cin\n#define fout cout\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, sx, sy;\n  fin >> n >> sx >> sy;\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    fin >> x >> y;\n    gr[x].emplace_back(y);\n    gr[y].emplace_back(x);\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    fin >> x >> y;\n    gb[x].emplace_back(y);\n    gb[y].emplace_back(x);\n  }\n  Dfs(sy, -1);\n  for (int i = 1; i <= n; ++i) {\n    for (int k : gr[i]) {\n      if (![](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n      } (i, k)) {\n        safe[i] = safe[k] = true;\n      }\n    }\n  }\n  if (safe[sx]) {\n    fout << -1 << endl;\n    return 0;\n  }\n  int ans = 0;\n  memset(d, 0xff, sizeof d);\n  d[sx] = 0;\n  queue<int> Q;\n  Q.push(sx);\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop();\n    if (d[k] >= dep[k]) {\n      continue;\n    }\n    if (safe[k]) {\n      fout << -1 << endl;\n      return 0;\n    }\n    ans = max(ans, dep[k] * 2);\n    for (int x : gr[k]) {\n      if (!vis[x] && d[k] + 1 < dep[x] && [](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n        } (k, x)) {\n        d[x] = d[k] + 1;\n        vis[x] = true;\n        Q.push(x);\n      }\n    }\n  }\n  fout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define fr(N,i,x) for (int i=N.lnk[x];i;i=N.nxt[i])\nusing namespace std;\nconst int maxn=200005,maxe=maxn<<1;\nint n,X,Y,dst[maxn],fa[maxn],Dst[maxn],Q[maxn],ans;bool vis[maxn];\nstruct ljb{\n\tint e,lnk[maxn],nxt[maxe],son[maxe];\n\tinline void add_e(int x,int y){son[++e]=y;nxt[e]=lnk[x];lnk[x]=e;}\n}A,B;\ninline char nc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read(){\n\tint ret=0;bool f=0;char ch=nc();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=nc();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=nc();\n\treturn f?-ret:ret;\n}\nvoid DFS(int x){fr(B,i,x) if(B.son[i]^fa[x]) dst[B.son[i]]=dst[x]+1,fa[B.son[i]]=x,DFS(B.son[i]);}\ninline void BFS(){\n\tint hed=0,til=1;Q[vis[X]=1]=X;\n\twhile(hed++<til) if(Dst[Q[hed]]<dst[Q[hed]]) fr(A,i,Q[hed])\n\tif(!vis[A.son[i]]) vis[A.son[i]]=1,Dst[A.son[i]]=Dst[Q[hed]]+1;\n}\ninline bool check(int x,int y){\n\tif(dst[x]>dst[y]){int t=x;x=y;y=t;}\n\tif(dst[y]-dst[x]==2) return fa[fa[y]]==x;\n\tif(dst[y]-dst[x]==1) return fa[y]==x;\n\tif(dst[y]-dst[x]==0) return fa[x]==fa[y];\n\treturn 0;\n}\nint main(){\n\tn=read(),X=read(),Y=read();\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),A.add_e(x,y),A.add_e(y,x);\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),B.add_e(x,y),B.add_e(y,x);\n\tdst[Y]=0;DFS(Y);BFS();\n\tfor (int i=1;i<=n;i++) if(vis[i]){\n\t\tif(Dst[i]<=dst[i]&&dst[i]>ans) ans=dst[i];\n\t\tif(Dst[i]<dst[i]) fr(A,j,i) if(!check(A.son[j],i)) ans=1e9;\n\t}\n\tprintf(\"%d\\n\",ans==1e9?-1:ans<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nint n,X,Y,Dep[N],vis[N],ans;\n\nstruct graph{\n\tstruct edge{int s,t,n;}e[4*N];\n\tint h[N],f[N][20],dep[N];\n\n\tvoid dfs1(int x,int fa)\n\t{\n\t\tf[x][0]=fa,dep[x]=dep[fa]+1;\n\t\tfor (int i=1; i<20; i++)  f[x][i]=f[f[x][i-1]][i-1];\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)  if (y!=fa)  dfs1(y,x);\n\t}\n\n\tvoid init()\n\t{\n\t\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t\t}\n\t\tdfs1(1,0);\n\t}\t\n\n\tint dis(int x,int y)\n\t{\n\t\tint s=0;\n\t\tif (dep[x]>dep[y])  swap(x,y);\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (dep[f[y][i]]>=dep[x])\n\t\t\t\ty=f[y][i],s+=1<<i;\n\t\tif (x==y)  return s;\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (f[x][i]!=f[y][i])\n\t\t\t\tx=f[x][i],y=f[y][i],s+=2<<i;\n\t\treturn s+2;\n\t}\n\n\tbool dfs2(int x,int f)\n\t{\n\t\tint _=(x==X);\n\t\tDep[x]=Dep[f]+1,vis[x]=vis[0];\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((y!=f)&&(dfs2(y,x)))  _=1;\n\t\treturn _;\n\t}\n\n\tvoid mark()\n\t{\n\t\tfor (int i=h[Y],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif (vis[0]++,dfs2(y,Y))  return;\n\t}\n\n\tvoid dfs3(int x,int f)\n\t{\n\t\tans=max(ans,Dep[x]);\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((y!=f)&&(vis[y]))  dfs3(y,x);\n\t}\n}A,B;\n\nvoid work()\n{\n\tscanf(\"%d %d %d\",&n,&X,&Y);\n\tA.init(),B.init(),B.mark();\n\tfor (int i=1; i<=n; i++)  vis[i]=(vis[i]==vis[0]);\n\tfor (int i=2; i<2*n; i+=2)\n\t\tif (((vis[A.e[i].s])||(vis[A.e[i].t]))&&(B.dis(A.e[i].s,A.e[i].t)>2))\n\t\t\tputs(\"-1\"),exit(0);\n\tA.dfs3(X,0);\n\tprintf(\"%d\",2*ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author: zxy_hhhh\n    date: 2020/03/13\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n#include<iostream>\n#define ll long long\ninline ll rd() {\n    ll _x=0;int _ch=getchar(),_f=1;\n    for(;!isdigit(_ch)&&(_ch!='-')&&(_ch!=EOF);_ch=getchar());\n    if (_ch=='-'){_f=0;_ch=getchar();}\n    for(;isdigit(_ch);_ch=getchar()) _x=_x*10+_ch-'0';\n    return _f?_x:-_x;\n}\nvoid write(ll _x){if (_x>=10) write(_x/10),putchar(_x%10+'0'); else putchar(_x+'0'); }\ninline void wrt(ll _x,char _p){if (_x<0) putchar('-'),_x=-_x; write(_x); if (_p) putchar(_p);}\n#define maxn 200005\nint dis[maxn],Fa[maxn];\nstd::vector<int> G1[maxn],G2[maxn];\nint n,A,B;\nvoid dfs(int u,int fa) {\n    Fa[u]=fa;\n    for(auto i:G2[u]) if (i!=fa) {\n        dis[i]=dis[u]+1;\n        dfs(i,u);\n    }\n}\nint ans;\nvoid DFS(int u,int fa,int D) {\n    if (dis[u]<=D) return ;\n    if (fa&&!(Fa[u]==fa||Fa[fa]==u||Fa[u]==Fa[fa]||Fa[Fa[u]]==fa||Fa[Fa[fa]]==u)) ans=1e9;\n    ans=std::max(ans,dis[u]*2);\n    for(auto i:G1[u]) if (i!=fa) {\n        DFS(i,u,D+1);\n    }\n}\nint main() {\n    n=rd();A=rd(),B=rd();\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G1[x].push_back(y);\n        G1[y].push_back(x);\n    }\n    for(int i=2;i<=n;i++) {\n        int x=rd(),y=rd();\n        G2[x].push_back(y);\n        G2[y].push_back(x);\n    }\n    dfs(B,0);\n    DFS(A,0,0);\n    if (ans>1e8) wrt(-1,'\\n');\n    else wrt(ans,'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define edge(j) for (j=fst[x];j;j=nxt[j])\nusing namespace std;\nconst int N=2e5+5;\nint n,x,y,i,j,u,v,ans,mode;\nint En,fst[N],Fa[N],nxt[N*2],to[N*2];\nint U[N],V[N],X[N],Y[N],A[N],B[N];\nvoid File()\n{\n\tfreopen(\"game.in\",\"r\",stdin);\n\tfreopen(\"game.out\",\"w\",stdout);\n}\nvoid add(int u,int v) {\n\tEn++; nxt[En]=fst[u]; fst[u]=En; to[En]=v;\n}\nvoid dfs(int x,int fa,int step,int *A)\n{\n\tint j,v;\n\tif (mode==1 && B[x]==n+1) return ;\n\tA[x]=step; Fa[x]=fa;\n\tedge(j)\n\t{\n\t\tv=to[j];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x,step+1,A);\n\t}\n}\nvoid Init()\n{\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t\tU[i]=u; V[i]=v;\n\t}\n\t\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&X[i],&Y[i]);\n\t\tif (X[i]==y) B[Y[i]]=n+1;\n\t\tif (Y[i]==y) B[X[i]]=n+1;\n\t}\n\trep(i,1,n) A[i]=n+1;\n\tB[y]=n+1; B[x]=0;\n\t\n\tmode=1; dfs(x,x,0,A);\n\tmemset(fst,0,sizeof(fst));\n\tEn=0;\n\trep(i,1,n-1)\n\t{\n\t\tu=X[i]; v=Y[i];\n\t\tadd(u,v); add(v,u);\t\t\n\t}\n\tmode=2; dfs(y,y,0,B);\n}\nvoid Solve()\n{\n\trep(i,1,n-1)\n\t{\n\t\tif (Fa[U[i]]==V[i] || Fa[V[i]]==U[i]) continue;\n\t\tif (Fa[U[i]]==Fa[V[i]] || Fa[Fa[U[i]]]==V[i] || Fa[Fa[V[i]]]==U[i]) continue;\n\t\tif (A[U[i]]<B[U[i]] || A[V[i]]<B[V[i]])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn ;\n\t\t}\n\t}\n\trep(i,1,n)\n\t\tif (A[i]<B[i])\n\t\t\tans=max(ans,B[i]);\n\tans*=2;\n\tprintf(\"%d\\n\",ans);\n}\nint main()\n{\n//\tFile();\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nconst int mlog = 18;\nint n,a,b;\nvector<int> way1[maxn], way2[maxn];\nint depA[maxn], depB[maxn];\nint par[maxn][20];\nint good[maxn];\nint loop, ans;\nvoid build(int u, int last) {\n    par[u][0] = last;\n    for(int i=1;i<=mlog;i++) par[u][i] = par[par[u][i-1]][i-1];\n    for(auto v : way2[u]) {\n        if(v==last) continue;\n        depB[v] = depB[u] + 1;\n        build(v, u);\n    }\n}\nvoid dfs(int u, int last) {\n    if(depB[u]<=depA[u]) return ;\n    if(good[u]) loop = 1;\n    else ans = max(ans, depB[u]*2);\n    for(auto v : way1[u]) {\n        if(v==last) continue;\n        depA[v] = depA[u] + 1;\n        dfs(v, u);\n    }\n}\nint lca(int u, int v) {\n    int res = 0;\n    if(depB[u]<depB[v]) swap(u,v);\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i] && depB[par[u][i]]>=depB[v]) {\n            u = par[u][i];\n            res += (1<<i);\n        }\n    }\n    if(u==v) return res;\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i]!=par[v][i]) {\n            u = par[u][i]; v = par[v][i];\n            res += (1<<i)*2;\n        }\n    }\n    return res+2;\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way1[u].push_back(v);\n        way1[v].push_back(u);\n    }\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way2[u].push_back(v);\n        way2[v].push_back(u);\n    }\n    return 0;\n    build(b,0);\n    return 0;\n    for(int u=1;u<=n;u++) {\n        for(auto v : way1[u]) {\n            if(lca(u,v)>=3) {\n                good[u] = good[v] = 1;\n            }\n        }\n    }\n//    for(int u=1;u<=n;u++) printf(\"%d : %d\\n\",u,good[u]);\n    dfs(a,0);\n    if(loop) printf(\"-1\");\n    else printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = (a + (b)) % MOD\n#define Mul(a, b) a = (a * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 200010;\nconst ll maxnlg = 19;\n\nll n, X, Y;\npii es_a[maxn];\nvi g[2][maxn];\nll st[maxn], ft[maxn], pars[maxnlg][maxn], ht[maxn];\nll q[maxn * 2], col[maxn];\nbool reach_N_move[maxn], reach[maxn];\n\nll tim = 0;\nvoid dfs_lca(ll x, ll par) {\n    st[x] = tim++;\n    pars[0][x] = par;\n    fori (i, maxnlg - 1) pars[i + 1][x] = pars[i][pars[i][x]];\n    for (auto y : g[1][x]) {\n        if (y != par) {\n            ht[y] = ht[x] + 1;\n            dfs_lca(y, x);\n        }\n    }\n    ft[x] = tim;\n}\n\nll LCA(ll a, ll b) {\n    if (st[a] > st[b]) swap(a, b);\n    if (ft[a] >= ft[b]) return a;\n    forir (i, maxnlg) {\n        if (ft[pars[i][a]] < ft[b]) a = pars[i][a];\n    }\n    return pars[0][a];\n}\n\nvoid MAIN() {\n\n    cin >> n >> X >> Y; --X, --Y;\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        es_a[i] = {a, b};\n        g[0][a].eb(b), g[0][b].eb(a);\n    }\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        g[1][a].eb(b), g[1][b].eb(a);\n    }\n    dfs_lca(Y, Y);\n\n    memset(col, -1, sizeof col);\n    ll l = 0, r = 0;\n    q[r++] = X;\n    q[r++] = Y;\n    reach[X] = true;\n    col[X] = 0;\n    col[Y] = 1;\n    while (r != l) {\n        ll x = q[l++];\n        if (col[x] == 0) reach_N_move[x] = true;\n        for (auto y : g[col[x]][x]) {\n            if (col[y] == -1 || col[x] == 1 && col[y] != 1) {\n                if (col[x] == 0) reach[y] = true;\n                col[y] = col[x];\n                q[r++] = y;\n            }\n        }\n    }\n\n    fori (i, n - 1) {\n        ll a, b; tie(a, b) = es_a[i];\n        if ((reach_N_move[a] || reach_N_move[b]) && ht[a] + ht[b] - ht[LCA(a, b)] * 2 > 2) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    ll ans = 0;\n    fori (i, n) {\n        if (reach[i]) smax(ans, ht[i]);\n    }\n    cout << ans * 2 << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n5 2 1\n1 5\n1 4\n4 3\n3 2\n1 5\n5 3\n1 4\n2 3\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200010;\nvector<int> a[N], b[N];\nint da[N], db[N];\nint id[N], q[N << 1], dph[N << 1], dfn = 0;\nint dp[N << 1][20], lg2[N];\nint n, x, y;\nvoid dfsb(int x, int fx) {\n    id[x] = ++dfn;\n    q[dfn] = x;\n    db[x] = db[fx] + 1;\n    dph[dfn] = db[x];\n    for (int y : b[x]) {\n        if (y != fx) dfsb(y, x);\n        q[++dfn] = x;\n        dph[dfn] = db[x];\n    }\n}\nvoid RMQ_init(int n) {\n    for (int i = 2; i <= n; i++) lg2[i] = lg2[i / 2] + 1;\n    for (int i = 1; i <= n; i++) dp[i][0] = i;\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 1; i + (1 << j) - 1 <= n; i++) {\n            int a = dp[i][j - 1], b = dp[i + (1 << (j - 1))][j - 1];\n            dp[i][j] = dph[a] <= dph[b] ? a : b;\n        }\n    }\n}\nint RMQ_min(int L, int R) {\n    if (L > R) swap(L, R);\n    int k = lg2[R - L + 1];\n    int a = dp[L][k], b = dp[R - (1 << k) + 1][k];\n    return dph[a] <= dph[b] ? a : b;\n}\nint LCA(int u, int v) {\n    int x = id[u], y = id[v];\n    return q[RMQ_min(x, y)];\n}\nint ans = 0;\nvoid dfsa(int x, int fx) {\n    da[x] = da[fx] + 1;\n    if (da[x] >= db[x]) return;\n    if (~ans) ans = max((db[x] - 1) << 1, ans);\n    for (int y : a[x]) {\n        if (y == fx) continue;\n        if (db[x] + db[y] - 2 * db[LCA(x, y)] > 2) ans = -1;\n        dfsa(y, x);\n    }\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &x, &y);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        a[u].push_back(v);\n        a[v].push_back(u);\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        b[u].push_back(v);\n        b[v].push_back(u);\n    }\n    dfsb(y, 0);\n    RMQ_init(dfn);\n    dfsa(x, 0);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,X,Y,x[200005],y[200005],f[200005][18],d[200005],wi[200005],D[200005],ans;\nvector<int> v[200005];\nvoid dfs(int x,int y){\n    f[x][0]=y,d[x]=d[y]+1;\n    for(int i=0;i<17;++i)f[x][i+1]=f[f[x][i]][i];\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint lca(int x,int y){\n    if(d[x]<d[y])swap(x,y);\n    for(int i=17;i>=0;--i)if(d[f[x][i]]>=d[y])x=f[x][i];\n    if(x==y) return x;\n    for(int i=17;i>=0;--i)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\nvoid dfs2(int x,int y){\n    D[x]=D[y]+1;\n    if(D[x]>d[x]) return;\n    if(wi[x]&&D[x]<d[x])ans=orz;\n    else ans=max(ans,d[x]*2);\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs2(v[x][i],x);\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&X,&Y);\n    for(int i=1;i<n;++i)scanf(\"%d%d\",x+i,y+i);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    d[0]=-1;\n    dfs(Y,0);\n    for(int i=1;i<=n;++i)v[i].clear();\n    for(int i=1;i<n;++i){\n        int o=d[x[i]]+d[y[i]]-d[lca(x[i],y[i])]*2;\n        if(o>2)wi[x[i]]=wi[y[i]]=1;\n        else v[x[i]].pb(y[i]),v[y[i]].pb(x[i]);\n    }\n    D[0]=-1;\n    dfs2(X,0);\n    if(ans==orz)puts(\"-1\");\n    else printf(\"%d\\n\",ans);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200100\nusing namespace std;\nvector<int>R[maxn],B[maxn];\nint ans,fa[maxn],dep[maxn],n,x,y,s[maxn];\nvoid dfs(int u,int f){\n\tdep[u]=dep[fa[u]=f]+1;\n\tfor(int i=0;i<B[u].size();++i)if(B[u][i]!=f)\n\t\tdfs(B[u][i],u);\n}\nint gd(int u,int v){\n\tif(dep[u]<dep[v])swap(u,v);\n\tint d=dep[u]-dep[v];\n\twhile(dep[u]>dep[v]&&d<=2)u=fa[u];\n\twhile(u!=v&&d<=2)u=fa[u],v=fa[v],d+=2;\n\treturn min(d,3);\n}\nvoid dfs2(int u,int f){\n\tif(f&&gd(u,f)>=3)s[u]=s[f]=1;\n\tfor(int i=0;i<R[u].size();++i)if(R[u][i]!=f)\n\t\tdfs2(R[u][i],u);\n}\nvoid sol(int u,int f,int len){\n\tif(dep[u]<len)return ;\n\tans=max(ans,dep[u]);\n\tif(s[u])printf(\"-1\"),exit(0);\n\tfor(int i=0;i<R[u].size();++i)if(R[u][i]!=f)\n\t\tsol(R[u][i],u,len+1);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&x,&y);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tR[u].push_back(v),\n\t\tR[v].push_back(u);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tB[u].push_back(v),\n\t\tB[v].push_back(u);\n\tdep[0]=-1;\n\tdfs(y,0),dfs2(x,0),sol(x,0,0);\n\tprintf(\"%d\",ans<<1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 200010;\nstruct graph {\n\tint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\n\tvoid addedge(int b, int e) {\n\t\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\t\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n\t}\n} A, B;\nint * head, * nxt, * to;\nvoid init(graph * X) { head = X -> head, nxt = X -> nxt, to = X -> to; }\nint dep[MAXN], fa[MAXN];\nvoid dfs(int u) {\n\tfor (int i = head[u]; i; i = nxt[i])\n\t\tif (to[i] != fa[u]) {\n\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\tfa[to[i]] = u;\n\t\t\tdfs(to[i]);\n\t\t}\n}\nint dis12(int u, int v) {\n\tif (dep[u] > dep[v]) std::swap(u, v);\n\treturn fa[v] == u || fa[fa[v]] == u || fa[u] == fa[v];\n}\nint n, X, Y, ans;\nvoid dfs2(int u, int fa = 0, int dep = 0) {\n\tif (dep > ::dep[u]) return ;\n\tans = std::max(ans, ::dep[u]);\n\tif (dep == ::dep[u]) return ;\n\tif (fa && !dis12(fa, u)) {\n\t\tstd::cout << -1 << std::endl;\n\t\texit(0);\n\t}\n\tfor (int i = head[u]; i; i = nxt[i])\n\t\tif (to[i] != fa)\n\t\t\tdfs2(to[i], u, dep + 1);\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> X >> Y;\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, A.addedge(t1, t2);\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, B.addedge(t1, t2);\n\tinit(&B); dfs(Y);\n\tinit(&A); dfs2(X);\n\tstd::cout << ans * 2 << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N, X, Y;\nvector<int> adj1[MN], adj2[MN];\nint par[20][MN], dep[MN], tin[MN], tout[MN], timer;\n\nvoid dfs0(int u, int p) {\n    tin[u] = timer++;\n\n    par[0][u] = p;\n    for(int i = 1; i < 20; i++) {\n        int t = par[i - 1][u];\n        if(t == -1) break;\n        par[i][u] = par[i - 1][t];\n    }\n\n    for(int i = 0; i < adj2[u].size(); i++) {\n        int v = adj2[u][i];\n        if(v == p) continue;\n        dep[v] = dep[u] + 1;\n        dfs0(v, u);\n    }\n\n    tout[u] = timer;\n}\n\nint lca(int a, int b) {\n    if(dep[a] < dep[b]) swap(a, b);\n    int diff = dep[a] - dep[b];\n    for(int i = 0; i < 20; i++) {\n        if(diff & (1 << i)) a = par[i][a];\n    }\n    if(a == b) return a;\n    for(int i = 20; i--;) {\n        if(par[i][a] != par[i][b]) {\n            a = par[i][a];\n            b = par[i][b];\n        }\n    }\n    return par[0][a];\n}\n\nint dist(int u, int v) {\n    return dep[u] + dep[v] - 2 * dep[ lca(u, v) ];\n}\n\nint ans;\nvoid dfs1(int u, int p) {\n    ans = max(ans, dep[u]);\n    for(int i = 0; i < adj1[u].size(); i++) {\n        int v = adj1[u][i];\n        if(v == p) continue;\n        if(dist(v, u) >= 3) {\n            printf(\"-1\");\n            exit(0);\n        }\n        if(dep[v] - dep[Y] < 2 && tin[Y] <= tin[v] && tin[v] < tout[Y]) continue;\n        dfs1(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    X--; Y--;\n\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj1[a].push_back(b);\n        adj1[b].push_back(a);\n    }\n    for(int i = 0; i < N - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        a--; b--;\n\n        adj2[a].push_back(b);\n        adj2[b].push_back(a);\n    }\n\n    dfs0(Y, -1);\n\n    while(dep[X] - dep[Y] > 2) {\n        int mn = 1e9, p = -1;\n        for(int i = 0; i < adj1[X].size(); i++) {\n            int v = adj1[X][i];\n\n            if(dist(X, v) >= 3) {\n                printf(\"-1\");\n                return 0;\n            }\n\n            if(mn > dep[v]) {\n                mn = dep[v];\n                p = v;\n            }\n        }\n        if(mn > dep[X]) break;\n        X = p;\n\n        for(int i = 0; i < adj2[Y].size(); i++) {\n            int v = adj2[Y][i];\n            if(tin[v] <= tin[X] && tin[X] < tout[v]) {\n                Y = v;\n                break;\n            }\n        }\n    }\n\n    dfs1(X, -1);\n\n    printf(\"%d\", 2 * ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int,int> ii;\ntypedef pair<ii,int> iii;\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define RST(i,n) memset(i,n,sizeof i)\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(),a.end()\n#define X first\n#define Y second\n#define eb emplace_back\n#ifdef cold66\n#define debug(...) do{\\\n    fprintf(stderr,\"LINE %d: (%s) = \",__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#endif // cold66\n//}\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\n\nconst ll MAXn=2e5+5,MAXlg=__lg(MAXn)+2;\nconst ll MOD=1000000007;\nconst ll INF=0x3f3f3f3f;\n\nint n,X,Y;\nint ans = 0;\nvector<int> r[MAXn],b[MAXn];\nint ancb[MAXlg][MAXn],depb[MAXn];\nvoid dfsb(int x,int p){\n    if (x != p) depb[x] = depb[p] + 1;\n    debug(x,depb[x]);\n    ancb[0][x] = p;\n    for (int i=1;1<<i < MAXn;++i) {\n        ancb[i][x] = ancb[i-1][ancb[i-1][x]];\n    }\n    for (auto i:b[x]) {\n        if (i == p) continue;\n        dfsb(i,x);\n    }\n}\nint LCA(int x,int y){\n    if (depb[x] < depb[y]) {\n        swap(x,y);\n    }\n    for (int i=MAXlg;i>=0;--i) {\n        if (((depb[x] - depb[y])>>i)&1) {\n            x = ancb[i][x];\n        }\n    }\n    if (x == y) return x;\n    for (int i=MAXlg;i>=0;--i) {\n        if (ancb[i][x] != ancb[i][y]) {\n            x = ancb[i][x];\n            y = ancb[i][y];\n        }\n    }\n    return ancb[0][x];\n}\nint dis(int x,int y){\n    int lca = LCA(x,y);\n    debug(x,y,lca);\n    return depb[x] + depb[y] - 2 * depb[lca];\n}\nvoid dfsr(int x,int p,int d){\n    debug(x,p,d,depb[x]);\n    if (d > depb[x]) return;\n    ans = max(ans,depb[x]*2);\n    if (d == depb[x]) return;\n    for (auto i:r[x]) {\n        if (i == p) continue;\n        if (dis(x,i) >= 3) {\n            debug(x,i);\n            ans = INF;\n            break;\n        }\n        dfsr(i,x,d+1);\n    }\n}\nint main(){\n    IOS();\n    cin >> n >> X >> Y;\n    for (int i=0;i<n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        r[u].eb(v);\n        r[v].eb(u);\n    }\n    for (int i=0;i<n-1;++i) {\n        int u,v;\n        cin >> u >> v;\n        b[u].eb(v);\n        b[v].eb(u);\n    }\n    dfsb(Y,Y);\n    dfsr(X,X,0);\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n\nusing namespace std;\n\nconst int MaxN = 2e5 + 5;\n\nvector<int> gb[MaxN], gr[MaxN];\n\nint dep[MaxN], fa[MaxN], d[MaxN];\nbool safe[MaxN], vis[MaxN];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  int n, sx, sy;\n  cin >> n >> sx >> sy;\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    gr[x].emplace_back(y);\n    gr[y].emplace_back(x);\n  }\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    cin >> x >> y;\n    gb[x].emplace_back(y);\n    gb[y].emplace_back(x);\n  }\n  queue<int> Q;\n  Q.push(sy);\n  fa[sy] = -1;\n  vis[sy] = true;\n  while (!Q.empty()) {\n    int k = Q.front();\n    for (int x : gb[k]) {\n      if (!vis[x]) {\n        Q.push(x);\n        vis[x] = true;\n        dep[x] = dep[k] + 1;\n        fa[x] = k;\n      }\n    }\n    Q.pop();\n  }\n  for (int i = 1; i <= n; ++i) {\n    for (int k : gr[i]) {\n      if (![](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n      } (i, k)) {\n        safe[i] = safe[k] = true;\n      }\n    }\n  }\n  if (safe[sx]) {\n    cout << -1 << endl;\n    return 0;\n  }\n  int ans = 0;\n  memset(d, 0xff, sizeof d);\n  memset(vis, 0x00, sizeof vis);\n  d[sx] = 0;\n  Q.push(sx);\n  while (!Q.empty()) {\n    int k = Q.front();\n    Q.pop();\n    if (d[k] >= dep[k]) {\n      continue;\n    }\n    if (safe[k]) {\n      cout << -1 << endl;\n      return 0;\n    }\n    ans = max(ans, dep[k] * 2);\n    for (int x : gr[k]) {\n      if (!vis[x] && d[k] + 1 < dep[x] && [](int x, int y) -> bool {\n        return fa[x] == fa[y] || fa[x] == y || x == fa[y] || fa[fa[x]] == y || x == fa[fa[y]];\n        } (k, x)) {\n        d[x] = d[k] + 1;\n        vis[x] = true;\n        Q.push(x);\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 400004\nint a[2][N],b[2][N],c[2][N],e[N],f[N],h[N],i,l,n,q[N],r,s[N],t,x,y;bool d[N][2],g[N];\ninline bool cmp(int u,int v){return f[u]!=v&&u!=f[v]&&f[u]!=f[v]&&f[f[u]]!=v&&u!=f[f[v]];}\nint u,v;\nint main()\n{\n\tfor(scanf(\"%d%d%d\",&n,&x,&y),i=t=1;i<n;i++)scanf(\"%d%d\",&u,&v),b[0][++t]=a[0][u],c[0][a[0][u]=t]=v,b[0][++t]=a[0][v],c[0][a[0][v]=t]=u;\n\tfor(i=t=1,e[n]=-1;i<n;e[i++]=-1)scanf(\"%d%d\",&u,&v),b[1][++t]=a[1][u],c[1][a[1][u]=t]=v,b[1][++t]=a[1][v],c[1][a[1][v]=t]=u;\n\tfor(d[q[r++]=x][e[x]=0]=true,d[q[r++]=y][e[y]=1]=true;l<r;)for(v=e[u=q[l++]],i=a[v][u];i;i=b[v][i])if(e[c[v][i]]<e[u])d[q[r++]=c[v][i]][e[c[v][i]]=e[u]]=true,g[c[v][i]]=h[c[v][i]]==h[f[c[v][i]]=u]+1,h[c[v][i]]=h[u]+1;\n\tfor(i=1;i<n;i++)if(cmp(c[0][i<<1],c[0][i<<1|1])&&(!g[c[0][i<<1]]&&*d[c[0][i<<1]]||!g[c[0][i<<1|1]]&&*d[c[0][i<<1|1]]))return 0&puts(\"-1\");\n\tfor(i=1,v=0;i<=n;i++)if(*d[i]&&v<h[i])v=h[i];\n\treturn 0&printf(\"%d\\n\",v<<1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N=2e5+10;\nstruct Tree\n{\n    struct edge{int next,to;}a[N<<1];\n    int head[N],cnt;\n    void link(int x,int y)\n        {\n            a[++cnt]=(edge){head[x],y};head[x]=cnt;\n            a[++cnt]=(edge){head[y],x};head[y]=cnt;\n        }\n}A,B;\nint n,p1,p2,dep[N],dis[N],fr[N],vis[N],ans;\nqueue<int> Q;\nvoid bfs1()\n{\n    memset(dis,-1,sizeof(dis));\n    if(dep[p1]) Q.push(p1);dis[p1]=0;\n    while(!Q.empty())\n    {\n        int x=Q.front();Q.pop();vis[x]=1;\n        for(int i=A.head[x];i;i=A.a[i].next)\n        {\n            int R=A.a[i].to;\n            if(dis[R]==-1)\n            {\n                dis[R]=dis[x]+1;\n                if(dis[R]<dep[R]) Q.push(R);\n                else if(dis[R]==dis[R]) vis[R]=1;\n            }\n        }\n    }\n}\nvoid bfs2()\n{\n    memset(dep,-1,sizeof(dep));\n    Q.push(p2);dep[p2]=0;\n    while(!Q.empty())\n    {\n        int x=Q.front();Q.pop();\n        for(int i=B.head[x];i;i=B.a[i].next)\n        {\n            int R=B.a[i].to;\n            if(dep[R]==-1) dep[R]=dep[x]+1,fr[R]=x,Q.push(R);\n        }\n    }\n}\nint Dis(int x,int y)\n{\n    if(dep[x]<dep[y]) swap(x,y);\n    if(fr[x]==fr[y]||x==y||fr[x]==y) return 0;\n    if(fr[fr[x]]==y) return 0;\n    return 1;\n}\nint main()\n{\n    cin>>n>>p1>>p2;\n    for(int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),A.link(x,y);\n    for(int i=1,x,y;i<n;i++) scanf(\"%d%d\",&x,&y),B.link(x,y);\n    bfs2();bfs1();\n    for(int x=1;x<=n;x++)\n        for(int i=A.head[x];i;i=A.a[i].next)\n            if(vis[x]&&vis[A.a[i].to]&&Dis(x,A.a[i].to))\n                puts(\"-1\"),exit(0);\n    for(int i=1;i<=n;i++) if(vis[i]) ans=max(dep[i],ans);\n    cout<<ans*2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn(2e5 + 5);\n\nint n, x, y, lim[maxn], fa[maxn], ans, dis[maxn];\nqueue <int> q;\nvector <int> edge1[maxn], edge2[maxn];\n\n# define Orzyyb puts(\"-1\"), exit(0)\n\ninline void Add1(int u, int v) {\n\tedge1[u].push_back(v), edge1[v].push_back(u);\n}\n\ninline void Add2(int u, int v) {\n\tedge2[u].push_back(v), edge2[v].push_back(u);\n}\n\ninline int Dis(int x, int y) {\n\tif (fa[x] == y || fa[y] == x) return 1;\n\tif (fa[x] == fa[y] || fa[fa[x]] == y || fa[fa[y]] == x) return 2;\n\treturn 233;\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add1(u, v);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), Add2(u, v);\n\tlim[y] = 1, q.push(y);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tfor (auto to : edge2[u])\n\t\t\tif (!lim[to]) fa[to] = u, lim[to] = lim[u] + 1, q.push(to);\n\t}\n\tfor (i = 1; i <= n; ++i) --lim[i];\n\tdis[x] = 1, q.push(x);\n\twhile (!q.empty()) {\n\t\tu = q.front(), q.pop();\n\t\tif (dis[u] - 1 > lim[u]) continue;\n\t\tans = max(ans, lim[u]);\n\t\tif (dis[u] - 1 == lim[u]) continue;\n\t\tfor (auto to : edge1[u]) if (Dis(u, to) > 2) Orzyyb;\n\t\tfor (auto to : edge1[u])\n\t\t\tif (!dis[to]) dis[to] = dis[u] + 1, q.push(to);\n\t}\n\tprintf(\"%d\\n\", ans << 1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define pr pair<ll,ll>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    #define bin(x) (1ll<<(x))\n    #define GG(x) if(x) {puts(\"error\");exit(666);}\n    #define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n    #define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T> void chmax(T &x,const T y) {x=(x>y?x:y);}\n    template<typename T> void chmin(T &x,const T y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=1e9+7;\n    int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n    ll qpower(ll x,ll e,int mod=MOD){ll ans=1;GG(e<0)while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    vc<int> to[2][N];int dep[N],fs[N][30];\n    void pre1(int x,int fa)\n    {\n        dep[x]=dep[fa]+1;fs[x][0]=fa;fo(i,1,20) fs[x][i]=fs[fs[x][i-1]][i-1];\n        for(auto y:to[1][x]) if(y!=fa) pre1(y,x);\n    }\n    int getlca(int x,int y)\n    {\n        if(dep[x]<dep[y]) swap(x,y);\n        fd(t,20,0) if(bin(t)<=dep[x]-dep[y]) x=fs[x][t];if(x==y) return x;\n        fd(t,20,0) if(fs[x][t]!=fs[y][t]) x=fs[x][t],y=fs[y][t];return fs[x][0];\n    }\n    int getdis(int x,int y){return dep[x]+dep[y]-2*dep[getlca(x,y)];}\n    int ans=0;\n    void solve(int x,int fa,int dis)\n    {\n        if(dis>=dep[x]) return;chmax(ans,dep[x]*2);\n        if(fa and getdis(fa,x)>2) {puts(\"-1\");exit(0);}\n        for(auto y:to[0][x]) if(y!=fa) solve(y,x,dis+1);\n    }\n\tvoid main()\n\t{\n        int n=qread(),X=qread(),Y=qread();\n        fo(i,1,n-1){int x=qread(),y=qread();to[0][x].PB(y);to[0][y].PB(x);}\n        fo(i,1,n-1){int x=qread(),y=qread();to[1][x].PB(y);to[1][y].PB(x);}\n        dep[0]=-1;pre1(Y,0);solve(X,0,0);write(ans);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define len(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define chmax(x, v) x = max((x), (v))\n#define chmin(x, v) x = min((x), (v))\nusing namespace std;\nusing ll = long long;\n\nconst int upTo = 201*1000;\nconst int lg = 18;\nint nbNode;\nint origRed, origBlue;\nvector<int> adjRed[upTo];\nvector<int> adjBlue[upTo];\n\nint depth[upTo];\nint anc[lg][upTo];\n\nvoid dfs(int node, int parent) {\n\tanc[0][node] = parent;\n\tfor (int i = 1; i < lg; ++i) {\n\t\tint tmp = anc[i-1][node];\n\t\tanc[i][node] = (tmp == -1 ? -1 : anc[i-1][tmp]);\n\t}\n\tfor (int nei : adjBlue[node]) if (nei != parent) {\n\t\tdepth[nei] = depth[node] + 1;\n\t\tdfs(nei, node);\n\t}\n}\n\nint dist(int u, int v) {\n\tint res = depth[u]+depth[v];\n\tif (depth[u] < depth[v]) swap(u,v);\n\tfor (int i = lg-1; i >= 0; --i) {\n\t\tif (depth[u]-depth[v] >= (1<<i)) {\n\t\t\tu = anc[i][u];\n\t\t}\t\n\t}\n\tif (u == v) {\n\t\treturn res - 2*depth[v];\n\t}\n\tfor (int i = lg-1; i >= 0; --i) {\n\t\tint nu = anc[i][u], nv = anc[i][v];\n\t\tif (min(nu,nv) != -1 && nu != nv) {\n\t\t\tu = nu; v = nv;\n\t\t}\n\t}\n\tint lca = anc[0][u];\n\treturn res - 2*depth[lca];\n}\n\nint res = 0;\nvoid esc(int node, int parent, int tps) {\n\tif (depth[node] <= tps) return;\n\tchmax(res, depth[node]);\n\tfor (int nei : adjRed[node]) if (nei != parent) {\n\t\tint d = dist(node, nei);\n\t\tif (d >= 3) res = 3*upTo;\n\t\tesc(nei, node, tps+1);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> nbNode;\n\tcin >> origRed >> origBlue;\n\t--origRed; --origBlue;\n\tfor (int i = 0; i < 2; ++i) {\n\t\tauto adj = (i ? adjBlue : adjRed);\n\t\tfor (int iEdge = 0; iEdge < nbNode-1; ++iEdge) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\t--u; --v;\n\t\t\tadj[u].push_back(v);\n\t\t\tadj[v].push_back(u);\n\t\t}\n\t}\t\n\tdfs(origBlue, -1); \n\tesc(origRed, -1, 0);\n\tres *= 2;\n\tif (res == 6*upTo) res = -1;\n\tcout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define fr(N,i,x) for (int i=N.lnk[x];i;i=N.nxt[i])\nusing namespace std;\nconst int maxn=200005,maxe=maxn<<1;\nint n,X,Y,dst[maxn],fa[maxn],Dst[maxn],Q[maxn],ans;bool vis[maxn];\nstruct ljb{\n\tint e,lnk[maxn],nxt[maxe],son[maxe];\n\tinline void add_e(int x,int y){son[++e]=y;nxt[e]=lnk[x];lnk[x]=e;}\n}A,B;\ninline char nc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read(){\n\tint ret=0;bool f=0;char ch=nc();\n\twhile(ch>'9'||ch<'0') f^=ch=='-',ch=nc();\n\twhile(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=nc();\n\treturn f?-ret:ret;\n}\nvoid DFS(int x){fr(B,i,x) if(B.son[i]^fa[x]) dst[B.son[i]]=dst[x]+1,fa[B.son[i]]=x,DFS(B.son[i]);}\ninline void BFS(){\n\tint hed=0,til=1;Q[vis[X]=1]=X;\n\twhile(hed<til) if(Dst[Q[++hed]]<dst[Q[hed]]) fr(A,i,Q[hed])\n\tif(!vis[A.son[i]]) vis[A.son[i]]=1,Dst[A.son[i]]=Dst[Q[hed]]+1;\n}\ninline check(int x,int y){\n\tif(dst[x]>dst[y]){int t=x;x=y;y=t;}\n\tif(dst[y]-dst[x]==2) return fa[fa[y]]==x;\n\tif(dst[y]-dst[x]==1) return fa[y]==x;\n\tif(dst[y]-dst[x]==0) return fa[x]==fa[y];\n\treturn 0;\n}\nint main(){\n\tn=read(),X=read(),Y=read();\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),A.add_e(x,y),A.add_e(y,x);\n\tfor (int i=1,x,y;i<n;i++) x=read(),y=read(),B.add_e(x,y),B.add_e(y,x);\n\tdst[Y]=0;DFS(Y);BFS();\n\tfor (int i=1;i<=n;i++) if(vis[i]){\n\t\tif(dst[i]>ans) ans=dst[i];\n\t\tif(Dst[i]<dst[i]) fr(A,j,i) if(!check(A.son[j],i)) ans=1e9;\n\t}\n\tprintf(\"%d\\n\",ans==1e9?-1:ans<<1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nconst int mlog = 17;\nint n,a,b;\nvector<int> way1[maxn], way2[maxn];\nint depA[maxn], depB[maxn];\nint par[maxn][20];\nint good[maxn];\nint loop, ans;\nvoid build(int u, int last) {\n    par[u][0] = last;\n    for(int i=1;i<=mlog;i++) par[u][i] = par[par[u][i-1]][i-1];\n    for(auto v : way2[u]) {\n        if(v==last) continue;\n        depB[v] = depB[u] + 1;\n        build(v, u);\n    }\n}\nvoid dfs(int u, int last) {\n    if(depB[u]<=depA[u]) return ;\n    if(good[u]) loop = 1;\n    else ans = max(ans, depB[u]*2);\n    for(auto v : way1[u]) {\n        if(v==last) continue;\n        depA[v] = depA[u] + 1;\n        dfs(v, u);\n    }\n}\nint lca(int u, int v) {\n    int res = 0;\n    if(depB[u]<depB[v]) swap(u,v);\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i] && depB[par[u][i]]>=depB[v]) {\n            u = par[u][i];\n            res += (1<<i);\n        }\n    }\n    if(u==v) return res;\n    for(int i=mlog;i>=0;i--) {\n        if(par[u][i]!=par[v][i]) {\n            u = par[u][i]; v = par[v][i];\n            res += (1<<i)*2;\n        }\n    }\n    return res+2;\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&a,&b);\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way1[u].push_back(v);\n        way1[v].push_back(u);\n    }\n    for(int i=1;i<=n-1;i++) {\n        int u,v; scanf(\"%d%d\",&u,&v);\n        way2[u].push_back(v);\n        way2[v].push_back(u);\n    }\n    return 0;\n    build(b,0);\n    return 0;\n    for(int u=1;u<=n;u++) {\n        for(auto v : way1[u]) {\n            if(lca(u,v)>=3) {\n                good[u] = good[v] = 1;\n            }\n        }\n    }\n//    for(int u=1;u<=n;u++) printf(\"%d : %d\\n\",u,good[u]);\n    dfs(a,0);\n    if(loop) printf(\"-1\");\n    else printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n\nconst int TREE_MAXV=300000+5;\nconst int LCA_UP=20;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pr[LCA_UP][TREE_MAXV],pre[TREE_MAXV],h[TREE_MAXV];\nint n;\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpr[0][rt]=pre[rt]=0;\n\th[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpr[0][e[i].v]=pre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t\th[e[i].v]=h[u]+1;\n\t\t}\n\t}\n\tfor (int i=1;i<LCA_UP;i++)\n\t\tfor (int u=1;u<=n;u++){\n\t\t\tpr[i][u]=pr[i-1][pr[i-1][u]];\n\t\t}\n}\nint lca(int u,int v){\n\tif(h[u]>h[v])swap(u,v);\n\tfor (int i=0;h[v]-h[u];i++)if((1<<i)&(h[v]-h[u])){\n\t\tv=pr[i][v];\n\t}\n\tif(u==v)return u;\n\tfor (int i=LCA_UP-1;i>=0;i--)if(pr[i][u]!=pr[i][v]){\n\t\tv=pr[i][v];\n\t\tu=pr[i][u];\n\t}\n\treturn pr[0][u];\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\n\nint u1[222222],v1[222222];\nint ok[222222];\nint u2[222222],v2[222222];\nint pre2[222222],pre1[222222];\nint dis2[222222],dis1[222222];\nint bad[222222];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tint U,V;\n\tgn(n);\n\tgn(U);gn(V);\n\trep(i,1,n)gn(u1[i]),gn(v1[i]);\n\trep(i,1,n)gn(u2[i]),gn(v2[i]);\n\n\n\ttree_init();\n\trep(i,1,n)ae(u2[i],v2[i]),ae(v2[i],u2[i]);\n\tbfs(V);\n\trep(i,1,n){\n\t\tint u=u1[i],v=v1[i];\n\t\tint r=lca(u,v);\n\t\tint d=h[u]+h[v]-2*h[r];\n\t\tif(d>=3)ok[i]=1;\n\t}\n\trep(i,1,n+1)dis2[i]=h[i];\n\trep(i,1,n+1)pre2[i]=pre[i];\n\n\ttree_init();\n\trep(i,1,n)ae(u1[i],v1[i]),ae(v1[i],u1[i]);\n\tbfs(U);\n\trep(i,1,n+1)dis1[i]=h[i];\n\trep(i,1,n+1)pre1[i]=pre[i];\n\n\tint ma=2;\n\trep(u,1,n+1){\n\t\tint ato=dis1[u],bto=dis2[u];\n\t\tif(bto<=ato)bad[u]=1;\n\t}\n\trep(j,0,n){\n\t\tint u=qu[j];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(bad[u] && e[i].v!=pre[u]){\n\t\t\tbad[e[i].v]=1;\n\t\t}\n\t}\n\trep(u,1,n+1)if(u!= U && !bad[pre[u]])upmax(ma,dis2[u]*2);\n\trep(i,1,n)if(h[u1[i]]>h[u2[i]])swap(u1[i],u2[i]);\n\t/*rep(i,1,n)if(ok[i] && (!bad[u1[i]])){\n\t\tma=-1;\n\t}*/\n\tprintf(\"%d\\n\",ma);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nint n,X,Y,f[N][20],dep[N],vis[N],ans;\n\nstruct graph{\n\tstruct edge{int s,t,n;}e[4*N];\n\tint h[N];\n\n\tvoid init()\n\t{\n\t\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t\t}\n\t}\t\n\n\tint dis(int x,int y)\n\t{\n\t\tint s=0;\n\t\tif (dep[x]>dep[y])  swap(x,y);\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (dep[f[y][i]]>=dep[x])\n\t\t\t\ty=f[y][i],s+=1<<i;\n\t\tif (x==y)  return s;\n\t\tfor (int i=19; i>=0; i--)\n\t\t\tif (f[x][i]!=f[y][i])\n\t\t\t\tx=f[x][i],y=f[y][i],s+=2<<i;\n\t\treturn s+2;\n\t}\n\n\tbool dfs(int x,int fa)\n\t{\n\t\tint _=(x==X);\n\t\tf[x][0]=fa,dep[x]=dep[fa]+1,vis[x]=vis[0];\n\t\tfor (int i=1; i<20; i++)  f[x][i]=f[f[x][i-1]][i-1];\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((y!=fa)&&(dfs(y,x)))  _=1;\n\t\treturn _;\n\t}\n\n\tvoid mark()\n\t{\n\t\tdep[0]=-1;\n\t\tfor (int i=h[Y],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif (vis[0]++,dfs(y,Y))  vis[n+1]=vis[0];\n\t}\n\n\tvoid dfs2(int x,int tim)\n\t{\n\t\tans=max(ans,dep[x]),vis[x]=vis[0]+1;\n\t\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\t\tif ((vis[y]==vis[n+1])&&(dep[y]>tim))\n\t\t\t\tdfs2(y,tim+1);\n\t}\n}A,B;\n\nvoid work()\n{\n\tscanf(\"%d %d %d\",&n,&X,&Y);\n\tA.init(),B.init(),B.mark(),A.dfs2(X,1);\n\tfor (int i=2; i<2*n; i+=2)\n\t\tif ((vis[A.e[i].s]>vis[0])||(vis[A.e[i].t]>vis[0]))\n\t\t\tif (B.dis(A.e[i].s,A.e[i].t)>2)\n\t\t\t\tputs(\"-1\"),exit(0);\n\tprintf(\"%d\",2*ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 7;\n\nint ans, dep[N][2], par[N][25], n;\nvector<int > p[N][2];\n\nvoid dfs(int x, int fa, int op){\n\tdep[x][op] = dep[fa][op] + 1;\n\tif (op == 1) par[x][0] = fa;\n\tfor (int v : p[x][op]) if (v != fa){\n\t\tdfs(v, x, op);\n\t}\n}\nvoid init(){\n\tfor (int i = 1; i < 20; i++){\n\t\tfor (int j = 1; j <= n; j++){\n\t\t\tpar[j][i] = par[par[j][i - 1]][i - 1];\n\t\t}\n\t}\n}\nint lca(int u, int v){\n\tif (dep[u][1] < dep[v][1]) swap(u, v);\n\tfor (int i = 0; i < 20; i++) if ((dep[u][1] - dep[v][1]) >> i & 1) u = par[u][i];\n\tif (u == v) return u;\n\tfor (int i = 19; i >= 0; i--) if (par[u][i] != par[v][i]) u = par[u][i], v = par[v][i];\n\treturn par[u][0]; \n}\nint dis(int u, int v){\n\tint lc = lca(u, v);\n\treturn dep[u][1] + dep[v][1] - 2 * dep[lc][1];\n}\nvoid ddfs(int x, int fa){\n\tif (ans != -1) ans = max(ans, (dep[x][1] - 1) * 2);\n\tfor (int v : p[x][0]){\n\t\tif (dis(x, v) >= 3) ans = -1;\n\t}\n\n\tfor (int v : p[x][0]) if (v != fa){\n\t\tif (dep[v][0] < dep[v][1]){\n\t\t\tddfs(v, x);\t\t\t\n\t\t}\t\n\t}\n}\n\nint main(){\n\tint S, T, u, v;\n\tscanf(\"%d%d%d\", &n, &S, &T);\n\tfor (int i = 1; i < n; i++){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tp[u][0].push_back(v); p[v][0].push_back(u);\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tp[u][1].push_back(v); p[v][1].push_back(u);\n\t}\n\tdfs(S, 0, 0);\n\tdfs(T, 0, 1);\n\tinit();\n\tans = 0;\n\tddfs(S, 0);\n\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 200005\nusing namespace std;\n\nint n,cnt,last[MAXN];\nint father[MAXN],deep[MAXN],dis[MAXN];\nint q[MAXN],nnn[MAXN],mx[MAXN];\nint tim,a[MAXN][2],xx,yy;\nbool vis[MAXN],win[MAXN];\n\nstruct edge\n{\n    int to,next,h;\n}t[MAXN*4];\n\nvoid add(int u,int v,int h)\n{\n    t[++cnt].to=v;t[cnt].h=h;\n    t[cnt].next=last[u];last[u]=cnt;\n    t[++cnt].to=u;t[cnt].h=h;\n    t[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x)\n{\n    deep[x]=deep[father[x]]+1;nnn[x]=++tim;\n    for (int i=last[x];i;i=t[i].next)\n        if (t[i].to!=father[x]) father[t[i].to]=x,dfs(t[i].to);\n    mx[x]=++tim;\n}\n\nbool check(int x,int y)\n{\n    if (nnn[x]>nnn[y]) swap(x,y);\n    if (nnn[x]<nnn[y]&&mx[x]>nnn[y]) return deep[y]-deep[x]>2 ? true : false;\n    if (father[x]==father[y]) return false;\n    return true;\n}\n\nvoid bfs()\n{\n    int h=1,tt=1;q[1]=xx;vis[xx]=1;\n    while (h<=tt)\n    {\n        int x=q[h++];\n        for (int i=last[x];i;i=t[i].next)\n            if (!t[i].h&&!vis[t[i].to])\n            {\n                dis[t[i].to]=dis[x]+1;\n                if (dis[t[i].to]<deep[t[i].to]) vis[t[i].to]=1,q[++tt]=t[i].to;\n            }\n    }\n}\n\nint max(int a,int b){return a>b?a:b;}\n\ntemplate<class T>inline void read(T &res)\n{\n    static char ch;T flag=1;\n    while((ch=getchar())<'0'||ch>'9')if(ch=='-')flag=-1;res=ch-48;\n    while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-48;res*=flag;\n}\n\nint main()\n{\n    int ans=0;\n    read(n);read(xx);read(yy);\n\n    for (int i=1;i<n;i++) {read(a[i][0]);read(a[i][1]);}\n\n    for (int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x);read(y);\n        add(x,y,1);\n    }\n\n    deep[0]=-1;\n    dfs( yy );\n\n    for (int i=1;i<n;i++)\n    {\n        if (check(a[i][0],a[i][1]))\n            win[a[i][0]]=win[a[i][1]]=1;\n        else add(a[i][0],a[i][1],0);\n    }\n\n    bfs();\n\n    for (int i=1;i<=n;i++)\n        if (win[i]&&vis[i])\n            {putchar('-');putchar('1');return 0;}\n\n    for (int i=1;i<=n;i++)\n        if (vis[i])\n            ans=max(ans,deep[i]<<1);\n\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2017-10-21\n//miaomiao\n//\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n#define Forr(i, a, b) for(int i = (a); i >= (int)(b); --i)\n\n#define LOG 20\n#define N (200000+5)\n\nvector<int> G1[N], G2[N];\n\nint n, ans, dep2[N], u1[N], v1[N], f[N][LOG];\nbool reach[N];\n\nvoid Dfs2(int now, int D, int F){\n\tdep2[now] = D; f[now][0] = F;\n\tFor(i, 1, 18) f[now][i] = f[f[now][i-1]][i-1];\n\n\tFor(i, 0, G2[now].size()-1)\n\t\tif(G2[now][i] != F) Dfs2(G2[now][i], D+1, now);\n}\n\nvoid Dfs1(int now, int D, int F){\n\tif(dep2[now] <= D) return;\n\t\n\treach[now] = true; ans = max(ans, dep2[now]);\n\tFor(i, 0, G1[now].size()-1)\n\t\tif(G1[now][i] != F) Dfs1(G1[now][i], D+1, now);\n}\n\nint Dis(int u, int v){\n\tif(dep2[u] < dep2[v]) swap(u, v);\n\n\tint ret = 0;\n\tForr(i, 18, 0) if(dep2[f[u][i]] >= dep2[v]){\n\t\tret += 1<<i; u = f[u][i];\n\t}\n\tif(u == v) return ret;\n\t\n\tForr(i, 18, 0) if(f[u][i] ^ f[v][i]){\n\t\tret += (1<<i) << 1;\n\t\tu = f[u][i]; v = f[v][i];\n\t}\n\treturn ret + 2;\n}\n\nvoid Check(){\n\tint u, v;\n\n\tFor(i, 1, n) ++dep2[i];\n\tFor(i, 1, n-1){\n\t\tu = u1[i], v = v1[i];\n      \tif(Dis(u, v) >= 3){puts(\"-1\"); return;}\n\t\tif(!reach[u] || !reach[v]) continue;\n\t}\n\n\tprintf(\"%d\\n\", ans<<1);\n}\n\nint main(){\n\tint st1, st2, u, v;\n\n\tscanf(\"%d%d%d\", &n, &st1, &st2);\n\t\n\tFor(i, 1, n-1){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG1[u].pb(v); G1[v].pb(u);\n\t\tu1[i] = u; v1[i] = v;\n\t}\n\tFor(i, 1, n-1){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG2[u].pb(v); G2[v].pb(u);\n\t}\n\n\tDfs2(st2, 0, 0); Dfs1(st1, 0, 0);\n\tCheck();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2017-10-21\n//miaomiao\n//\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n#define Forr(i, a, b) for(int i = (a); i >= (int)(b); --i)\n\n#define LOG 20\n#define N (200000+5)\n\nvector<int> G1[N], G2[N];\n\nint n, ans, dep2[N], u1[N], v1[N], f[N][LOG];\nbool reach[N];\n\nvoid Dfs2(int now, int D, int F){\n\tdep2[now] = D; f[now][0] = F;\n\tFor(i, 1, 18) f[now][i] = f[f[now][i-1]][i-1];\n\n\tFor(i, 0, G2[now].size()-1)\n\t\tif(G2[now][i] != F) Dfs2(G2[now][i], D+1, now);\n}\n\nvoid Dfs1(int now, int D, int F){\n\tif(dep2[now] <= D) return;\n\t\n\treach[now] = true; ans = max(ans, dep2[now]);\n\tFor(i, 0, G1[now].size()-1)\n\t\tif(G1[now][i] != F) Dfs1(G1[now][i], D+1, now);\n}\n\nint Dis(int u, int v){\n\tif(dep2[u] < dep2[v]) swap(u, v);\n\n\tint ret = 0;\n\tForr(i, 18, 0) if(dep2[f[u][i]] >= dep2[v]){\n\t\tret += 1<<i; u = f[u][i];\n\t}\n\tif(u == v) return ret;\n\t\n\tForr(i, 18, 0) if(f[u][i] ^ f[v][i]){\n\t\tret += (1<<i) << 1;\n\t\tu = f[u][i]; v = f[v][i];\n\t}\n\treturn ret + 2;\n}\n\nvoid Check(){\n\tint u, v;\n\n\tFor(i, 1, n) ++dep2[i];\n\tFor(i, 1, n-1){\n\t\tu = u1[i], v = v1[i];\n\t\tif(!reach[u] || !reach[v]) continue;\n\t\tif(Dis(u, v) >= 3){puts(\"-1\"); return;}\n\t}\n\n\tprintf(\"%d\\n\", ans<<1);\n}\n\nint main(){\n\tint st1, st2, u, v;\n\n\tscanf(\"%d%d%d\", &n, &st1, &st2);\n\t\n\tFor(i, 1, n-1){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG1[u].pb(v); G1[v].pb(u);\n\t\tu1[i] = u; v1[i] = v;\n\t}\n\tFor(i, 1, n-1){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG2[u].pb(v); G2[v].pb(u);\n\t}\n\n\tDfs2(st2, 0, 0); Dfs1(st1, 0, 0);\n\tCheck();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n    static char ibuf[RLEN],*ib,*ob;\n    (ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n    return (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n    char ch=nc(); int i=0,f=1;\n    while(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n    while(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n    return i*f;\n}\n\nconst int N=2e5+50;\nint n,col[N];\nstruct Tree {\n    int stx,fa[N],dep[N];\n    vector <int> edge[N];\n    inline void dfs(int x,int f,int d=0) {\n        fa[x]=f; dep[x]=d;\n        for(auto v:edge[x]) if(v!=f) dfs(v,x,d+1);\n    }\n    inline void init() {\n        for(int i=1;i<n;i++) {\n            int x=rd(), y=rd();\n            edge[x].push_back(y);\n            edge[y].push_back(x);\n        } dfs(stx,0);\n    }\n    inline bool valid(int x,int y,int rs=0) {\n        while(dep[x]>dep[y]) if((x=fa[x],++rs)>=3) return false;\n        while(dep[x]<dep[y]) if((y=fa[y],++rs)>=3) return false;\n        while(x!=y) if((y=fa[y],x=fa[x],rs+=2)>=3) return false;\n        return true;\n    }\n} A,B;\ninline void dfs(int x) {\n    if(A.dep[x]>=B.dep[x]) return;\n    col[x]=1;\n    for(auto v:A.edge[x]) if(v!=A.fa[x]) dfs(v);\n}\nint main() {\n    n=rd(); A.stx=rd(); B.stx=rd();\n    if(A.stx==B.stx) {puts(\"0\"); return 0;}\n    A.init(); B.init();\n    dfs(A.stx);\n    for(int i=1;i<=n;i++) \n        for(auto v:A.edge[i])\n            if(col[i] && !B.valid(i,v)) {puts(\"-1\"); return 0;}\n    int ans=0;\n    for(int i=1;i<=n;i++) \n        if(col[i]) ans=max(ans,B.dep[i]);\n    cout<<(ans<<1)<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int maxn=2e5;\nint n,x,y,tot;\nint pre[maxn*4+8],son[maxn*4+8];\nbool can[maxn+8];\nqueue<int>st;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nstruct Tree\n{\n    int now[maxn+8],dep[maxn+8],f[maxn+8][20];\n    void add(int u,int v)\n    {\n\tpre[++tot]=now[u];\n\tnow[u]=tot;\n\tson[tot]=v;\n    }\n    void build(int x)\n    {\n\tdep[x]=dep[f[x][0]]+1;\n\tfor (int i=1;i<=log(dep[x])/log(2);i++) f[x][i]=f[f[x][i-1]][i-1];\n\tfor (int p=now[x];p;p=pre[p])\n\t    {\n\t\tint child=son[p];\n\t\tif (f[x][0]==child) continue;\n\t\tf[child][0]=x;\n\t\tbuild(child);\n\t    }\n    }\n    int Get_Lca(int x,int y)\n    {\n\tif (dep[x]<dep[y]) swap(x,y);\n\tfor (int i=log(dep[x])/log(2);~i;i--)\n\t    if (dep[f[x][i]]>=dep[y]) x=f[x][i];\n\tif (x==y) return x;\n\tfor (int i=log(dep[x])/log(2);~i;i--)\n\t    if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n\treturn f[x][0];\n    }\n    int Get_Dis(int x,int y){return dep[x]+dep[y]-dep[Get_Lca(x,y)]*2;}\n}T1,T2;\n\nvoid solve()\n{\n    //for (int i=1;i<=n;i++) printf(\"%d \",can[i]);puts(\"\");\n    int ans=0;\n    for (int i=1;i<=n;i++)\n\tif (can[i])\n\t    {\n\t\tans=max(ans,T2.dep[i]-1);\n\t\tfor (int p=T1.now[i];p;p=pre[p])\n\t\t    {\n\t\t\tint child=son[p];\n\t\t\tif (T2.Get_Dis(child,i)>2)\n\t\t\t    {\n\t\t\t\tputs(\"-1\");\n\t\t\t\texit(0);\n\t\t\t    }\n\t\t    }\n\t    }\n    printf(\"%d\\n\",ans*2);\n}\n\nvoid prepare()\n{\n    can[x]=1;\n    st.push(x);\n    while(!st.empty())\n\t{\n\t    int x=st.front();st.pop();\n\t    for (int p=T1.now[x];p;p=pre[p])\n\t\t{\n\t\t    int child=son[p];\n\t\t    if (can[child]) continue;\n\t\t    if (T1.dep[child]<T2.dep[child]) can[child]=1,st.push(child);\n\t\t}\n\t}\n}\n\nint main()\n{\n    n=read(),x=read(),y=read();\n    if (x==y)\n\t{\n\t    puts(\"0\");\n\t    return 0;\n\t}\n    for (int i=1;i<n;i++)\n\t{\n\t    int u=read(),v=read();\n\t    T1.add(u,v),T1.add(v,u);\n\t}\n    for (int i=1;i<n;i++)\n\t{\n\t    int u=read(),v=read();\n\t    T2.add(u,v),T2.add(v,u);\n\t}\n    T1.build(x),T2.build(y);\n    prepare();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define FILL(A,val) memset(A,val,sizeof(A))\n#define ITER(it,a) for(__typeof(a.begin()) it=a.begin();it!=a.end();++it)\n#define DBG1(a) cerr<<#a<<\"=\"<<(a)<<\"\\n\"\n#define DBG2(a,b) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n\n#define ALL(V) V.begin(),V.end()\n#define SZ(V) (int)V.size()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000*1000*1000 + 7;\nconst LL LINF = 1LL*INF*INF;\n\nconst LL MOD = 1000000007;\n\nconst int MAX = 200005;\n\nVI g[2][MAX];\n\nint d[2][MAX];\n\nint par[MAX];\n\n\nvoid dfs(int v,int ind,int p)\n{\n\tif(ind == 1)par[v] = p;\n\tFOR(i,0,SZ(g[ind][v]))\n\t{\n\t\tint to = g[ind][v][i];\n\t\tif(to == p)continue;\n\n\t\td[ind][to] = d[ind][v]+1;\n\t\tdfs(to,ind,v);\n\t}\n}\n\nint ans = 0;\nvoid getAns(int v,int p)\n{\n\tans = max(ans,d[1][v]);\n\tFOR(i,0,SZ(g[0][v]))\n\t{\n\t\tint to = g[0][v][i];\n\t\tif(to==p)continue;\n\n\t\tif(d[0][to]<d[1][to])getAns(to,v);\n\t}\n}\nset<PII> e2;\n\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//ios::sync_with_stdio(false);cin.tie(0);\n\n\tint n,r1,r2;\n\tcin>>n>>r1>>r2;\n\n\t--r1;--r2;\n\n\tFOR(ind,0,2)\n\tFOR(i,1,n)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t--a;--b;\n\t\tg[ind][a].PB(b);\n\t\tg[ind][b].PB(a);\n\t\tif(ind == 1)e2.insert(MP(min(a,b),max(a,b)));\n\t}\n\n\n\tdfs(r1,0,-1);\n\tdfs(r2,1,-1);\n\n\tFOR(i,0,n)\n\t{\n\t\tint p = par[i];\n\t\tif(p==-1 || par[p] == -1)continue;\n\t\tp = par[p];\n\t\te2.insert(MP(min(p,i),max(p,i)));\n\t}\n\n\tFOR(i,0,n)\n\tFOR(j,0,SZ(g[0][i]))\n\t{\n\t\tint to = g[0][i][j];\n\t\tint v = i;\n\t\t\tif(d[0][v] < d[1][v] && par[v]!=par[to] && !e2.count(MP(min(v,to),max(v,to))))\n\t\t\t{\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\n\tgetAns(r1,-1);\n\n\tcout<<ans*2;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <bitset>\n#include <random>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#include <functional>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < int(b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> int(a);)\n#define all(v) v.begin(),v.end()\n#define trav(x, v) for(auto &x : v)\n#define sz(v) int((v).size())\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long double ld;\n\nconst int lg = 20;\n\nstruct tree {\n\tint n;\n\tvector<vi> gr;\n\tvi par, h;\n\tvector<vi> hopp;\n\tvoid dfs(int v){\n\t\ttrav(u, gr[v]) if(u != par[v]){\n\t\t\tpar[u] = v;\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u);\n\t\t}\n\t}\n\ttree(vector<vi> gr) : gr(gr) {\n\t\tn = sz(gr);\n\t\tpar.resize(n), h.resize(n);\n\t\thopp.resize(lg, vi(n));\n\n\t\tdfs(0);\n\n\t\thopp[0] = par;\n\t\trep(t,1,lg) rep(i,0,n)\n\t\t\thopp[t][i] = hopp[t-1][hopp[t-1][i]];\n\t}\n\tint jump(int a, int steps){\n\t\tfor(int i = 0; steps; ++i){\n\t\t\tif(steps&1) a = hopp[i][a];\n\t\t\tsteps /= 2;\n\t\t}\n\t\treturn a;\n\t}\n\tint lca(int a, int b){\n\t\tif(h[a] > h[b]) swap(a,b);\n\t\tb = jump(b, h[b] - h[a]);\n\t\tif(a == b) return a;\n\t\trrep(i,0,lg){\n\t\t\tint aa = hopp[i][a], bb = hopp[i][b];\n\t\t\tif(aa != bb){\n\t\t\t\ta = aa, b = bb;\n\t\t\t}\n\t\t}\n\t\treturn par[b];\n\t}\n\tint dist(int a, int b){\n\t\tint c = lca(a,b);\n\t\treturn h[a] + h[b] - 2*h[c];\n\t}\n\tint closer(int v, int y){\n\t\tif(v == y) return v;\n\t\tint r = lca(v, y);\n\t\tif(y != r) return par[y];\n\t\treturn jump(v, h[v]-h[y]-1);\n\t}\n};\n\nvoid noend(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint n, x, y;\n\tcin >> n >> x >> y;\n\t--x, --y;\n\tvector<vi> gred(n), gblue(n);\n\n\trep(_,0,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a,--b;\n\t\tgred[a].push_back(b);\n\t\tgred[b].push_back(a);\n\t}\n\trep(_,0,n-1){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a,--b;\n\t\tgblue[a].push_back(b);\n\t\tgblue[b].push_back(a);\n\t}\n\ttree red(gred), blue(gblue);\n\tint ans = 0;\n\tvector<bool> vis(n);\n\tqueue<pii> ko;\n\tko.push(pii(x, y));\n\tvis[x] = 1;\n\twhile(!ko.empty()){\n\t\tpii pa = ko.front();\n\t\tko.pop();\n\t\tans = max(ans, 2 * blue.dist(pa.first, y));\n\t//\tcout << pa.first+1 << ' ' << pa.second+1 << endl;\n\t\tif(pa.first == pa.second) continue;\n\t\ttrav(x1, gred[pa.first]) if(!vis[x1]){\n\t\t\tif(blue.dist(x1, pa.first) > 2)\n\t\t\t\tnoend();\n\t\t\tvis[x1] = 1;\n\t\t\tko.push(pii(x1, red.closer(x1, pa.second)));\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define RepG0(i, x) for (int i = head0[x]; i; i = edge0[i].next)\n#define v0 edge0[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 100010;\nstruct Edge{ int to, next;} edge[N * 2], edge0[N * 2];\n\nint head[N], num, head0[N], num0;\n\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\nvoid add_edge0(int a, int b) { edge0[++ num0] = (Edge){b, head0[a]}, head0[a] = num0;}\n\nint f[N], dep[N];\n\nvoid dfs(int x)\n{\n\t//printf(\"_%d %d\\n\", x, f[x]);\n\tRepG0(i, x) if (v0 != f[x]) {\n\t\tdep[v0] = dep[x] + 1, f[v0] = x;\n\t\tdfs(v0);\n\t}\n}\n\nbool jud(int x, int y) { return (f[x] == y || f[f[x]] == y || f[y] == x || f[f[y]] == x || f[x] == f[y]); }\n\nbool flag;\nint ans;\n\nvoid dfs(int x, int fa, int dis)\n{\n\tif (dis >= dep[x]) return;\n\telse ans = max(ans, dep[x]);\n\tRepG(i, x) if (v != fa) {\n\t\tif (jud(x, v)) dfs(v, x, dis + 1); \n\t\telse{\n\t\t\tflag = true;\n\t\t//\tprintf(\"%d %d ???\\n\", x, v);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, x, y;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge(a, b); add_edge(b, a);\n\t}\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge0(a, b); add_edge0(b, a);\n\t}\n\tdfs(y); dfs(x, 0, 0);\n\t\n\tif (flag) printf(\"-1\\n\");\n\telse printf(\"%d\\n\", ans * 2);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2017-10-21\n//miaomiao\n//\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n#define Forr(i, a, b) for(int i = (a); i >= (int)(b); --i)\n\n#define LOG 20\n#define N (200000+5)\n\nvector<int> G1[N], G2[N];\n\nint n, ans, dep2[N], u1[N], v1[N], f[N][LOG];\nbool reach[N];\n\nvoid Dfs2(int now, int D, int F){\n\tdep2[now] = D; f[now][0] = F;\n\tFor(i, 1, 18) f[now][i] = f[f[now][i-1]][i-1];\n\n\tFor(i, 0, G2[now].size()-1)\n\t\tif(G2[now][i] != F) Dfs2(G2[now][i], D+1, now);\n}\n\nvoid Dfs1(int now, int D, int F){\n\tif(dep2[now] <= D) return;\n\t\n\treach[now] = true; ans = max(ans, dep2[now]);\n\tFor(i, 0, G1[now].size()-1)\n\t\tif(G1[now][i] != F) Dfs1(G1[now][i], D+1, now);\n}\n\nint Dis(int u, int v){\n\tif(dep2[u] < dep2[v]) swap(u, v);\n\n\tint ret = 0;\n\tForr(i, 18, 0) if(dep2[f[u][i]] >= dep2[v]){\n\t\tret += 1<<i; u = f[u][i];\n\t}\n\tif(u == v) return ret;\n\t\n\tForr(i, 18, 0) if(f[u][i] ^ f[v][i]){\n\t\tret += (1<<i) << 1;\n\t\tu = f[u][i]; v = f[v][i];\n\t}\n\treturn ret + 2;\n}\n\nvoid Check(){\n\tint u, v;\n\n\tFor(i, 1, n) ++dep2[i];\n\tFor(i, 1, n-1){\n\t\tu = u1[i], v = v1[i];\n\t\tif(!reach[u] && !reach[v]) continue;\n\t\tif(Dis(u, v) >= 3){puts(\"-1\"); return;}\n\t}\n\n\tprintf(\"%d\\n\", ans<<1);\n}\n\nint main(){\n\tint st1, st2, u, v;\n\n\tscanf(\"%d%d%d\", &n, &st1, &st2);\n\t\n\tFor(i, 1, n-1){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG1[u].pb(v); G1[v].pb(u);\n\t\tu1[i] = u; v1[i] = v;\n\t}\n\tFor(i, 1, n-1){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG2[u].pb(v); G2[v].pb(u);\n\t}\n\n\tDfs2(st2, 0, 0); Dfs1(st1, 0, 0);\n\tCheck();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define SZ(x) ((int) (x).size())\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <typename T, typename TT> ostream & operator << (ostream &out, pair<T, TT> t) { return out << \"(\" << t.X << \",\" << t.Y << \")\";}\ntemplate <typename T> ostream & operator << (ostream &out,vector<T> t) { out << \"[\"; for (auto x:t) out << x << \" \"; out << \"]\"; return out;}\ntemplate <typename T> inline bool cmin(T & a, const T & b) { return a > b ? a = b, 1 : 0;}\ntemplate <typename T> inline bool cmax(T & a, const T & b) { return a < b ? a = b, 1 : 0;}\ntemplate <typename T> void read(T & x) \n{\n\tint f = 1; char ch; x = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n\twhile(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); x *= f;\n}\n\nconst int NX = 201234;\n\nint n, s_a, s_b, k, dep[NX], par[NX], l[NX], r[NX];\nvector<int> e_a[NX], e_b[NX];\n\nvoid dfs(int x, int fa)\n{\n\tl[x] = ++k;\n\tfor (int y : e_b[x])\n\t{\n\t\tif(y != fa)\n\t\t{\n\t\t\tdep[y] = dep[x] + 1;\n\t\t\tpar[y] = x;\n\t\t\tdfs(y, x);\n\t\t}\n\t}\n\tr[x] = k;\n}\n\nbool cho[NX], good[NX]; int ans = 0;\nvoid dfs2(int x, int fa, int d)\n{\n\tif(d < dep[x])\n\t{\n\t\tcmax(ans, dep[x] << 1);\n\t\tif(good[x])\n\t\t\tputs(\"-1\"), exit(0);\n\t} else\n\t\treturn;\n\t\n\tfor (int y : e_a[x])\n\t{\n\t\tif(y != fa)\n\t\t\tdfs2(y, x, d + 1);\n\t}\n}\n\nint main() \n{\n\tread(n); read(s_a); read(s_b);\n\tvector<pair<int, int> > buf;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v; read(u); read(v);\n\t\tbuf.pb(mp(u, v));\n\t}\n\t\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v; read(u); read(v);\n\t\te_b[u].pb(v);\n\t\te_b[v].pb(u);\n\t}\n\t\n\tdfs(s_b, 0);\n\tfor (int k = 0; k < SZ(buf); k++)\n\t{\n\t\tint i = buf[k].first;\n\t\tint j = buf[k].second;\n\t\t\n\t\tif(l[i] > l[j]) swap(i, j);\n\t\tbool t = r[j] <= r[i] && dep[j] > dep[i] + 2;\n\t\t\n\t\tif(t || (r[j] > r[i] && par[i] != par[j]))\n\t\t{\n\t\t\tgood[i] = true;\n\t\t\tgood[j] = true;\n\t\t}else {\n\t\t\te_a[i].pb(j);\n\t\t\te_a[j].pb(i);\n\t\t}\n\t}\n\t\n\tdfs2(s_a, 0, 0);\t\n\t\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = (a + (b)) % MOD\n#define Mul(a, b) a = (a * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 200010;\nconst ll maxnlg = 19;\n\nll n, X, Y;\npii es_a[maxn];\nvi g[2][maxn];\nll st[maxn], ft[maxn], pars[maxnlg][maxn], ht[maxn];\nll q[maxn], col[maxn], d[maxn];\nbool vis[maxn];\n\nll tim = 0;\nvoid dfs_lca(ll x, ll par) {\n    st[x] = tim++;\n    pars[0][x] = par;\n    fori (i, maxnlg - 1) pars[i + 1][x] = pars[i][pars[i][x]];\n    for (auto y : g[1][x]) {\n        if (y != par) {\n            ht[y] = ht[x] + 1;\n            dfs_lca(y, x);\n        }\n    }\n    ft[x] = tim;\n}\n\nll LCA(ll a, ll b) {\n    if (st[a] > st[b]) swap(a, b);\n    if (ft[a] >= ft[b]) return a;\n    forir (i, maxnlg) {\n        if (ft[pars[i][a]] < ft[b]) a = pars[i][a];\n    }\n    return pars[0][a];\n}\n\nvoid MAIN() {\n\n    cin >> n >> X >> Y; --X, --Y;\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        es_a[i] = {a, b};\n        g[0][a].eb(b), g[0][b].eb(a);\n    }\n    fori (i, n - 1) {\n        ll a, b; cin >> a >> b; --a, --b;\n        g[1][a].eb(b), g[1][b].eb(a);\n    }\n\n    dfs_lca(Y, Y);\n\n    memset(col, -1, sizeof col);\n    memset(d, -1, sizeof d);\n    ll l = 0, r = 0;\n    q[r++] = X;\n    q[r++] = Y;\n    vis[X] = true;\n    col[X] = 0;\n    col[Y] = 1;\n    while (r != l) {\n        ll x = q[l++];\n        for (auto y : g[col[x]][x]) {\n            if (col[y] == -1 || col[x] == 1 && col[y] != 1) {\n                if (col[x] == 0) vis[y] = true;\n                col[y] = col[x];\n                q[r++] = y;\n            }\n        }\n    }\n\n    fori (i, n - 1) {\n        ll a, b; tie(a, b) = es_a[i];\n        if ((vis[a] || vis[b]) && ht[a] + ht[b] - ht[LCA(a, b)] * 2 > 2) {\n            cout << \"-1\\n\";\n            return;\n        }\n    }\n    ll ans = 0;\n    fori (i, n) {\n        if (vis[i]) smax(ans, ht[i]);\n    }\n    cout << ans * 2 << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\n\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,X,Y,x[200005],y[200005],f[200005][18],d[200005],wi[200005],D[200005],ans;\nvector<int> v[200005];\nvoid dfs(int x,int y){\n    f[x][0]=y,d[x]=d[y]+1;\n    for(int i=0;i<17;++i)f[x][i+1]=f[f[x][i]][i];\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint lca(int x,int y){\n    if(d[x]<d[y])swap(x,y);\n    for(int i=17;i>=0;--i)if(d[f[x][i]]>=d[y])x=f[x][i];\n    if(x==y) return x;\n    for(int i=17;i>=0;--i)if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\nvoid dfs2(int x,int y){\n    D[x]=D[y]+1;\n    if(D[x]>d[x]) return;\n    if(D[x]==d[x]){\n        ans=max(ans,d[x]*2);\n        return;\n    }\n    if(wi[x])ans=orz;\n    else ans=max(ans,d[x]*2);\n    for(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs2(v[x][i],x);\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&X,&Y);\n    for(int i=1;i<n;++i)scanf(\"%d%d\",x+i,y+i);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    d[0]=-1;\n    dfs(Y,0);\n    for(int i=1;i<=n;++i)v[i].clear();\n    for(int i=1;i<n;++i){\n        int o=d[x[i]]+d[y[i]]-d[lca(x[i],y[i])]*2;\n        if(o>2)wi[x[i]]=wi[y[i]]=1;\n        else v[x[i]].pb(y[i]),v[y[i]].pb(x[i]);\n    }\n    D[0]=-1;\n    dfs2(X,0);\n    if(ans==orz)puts(\"-1\");\n    else printf(\"%d\\n\",ans);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 200010\nusing namespace std;\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1],e2[MAXN<<1];\n\nint n,x1,x2;\nint g[MAXN],nume;\nint g2[MAXN],nume2;\nint dep[MAXN],size[MAXN],son[MAXN],top[MAXN],pre[MAXN],w[MAXN],pt[MAXN],numw;\nint pre2[MAXN],h[MAXN],dep2[MAXN];\nbool flag;\nint ans;\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid addEdge2(int u,int v){\n\te2[nume2]=edge(v,g2[u]);\n\tg2[u]=nume2++;\n}\n\nvoid dfs(int x,int p){\n\tsize[x]=1; son[x]=0;\n\tpre[x]=p;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdep[e[i].to]=dep[x]+1;\n\t\t\tdfs(e[i].to,x);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t\tif(size[e[i].to]>size[son[x]])\n\t\t\t\tson[x]=e[i].to;\n\t\t}\n}\n\nvoid dfs2(int x,int p){\n\tpt[w[x]=++numw]=x;\n\tif(son[x]){\n\t\ttop[son[x]]=top[x];\n\t\tdfs2(son[x],x);\n\t}\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to!=p && e[i].to!=son[x]){\n\t\t\ttop[e[i].to]=e[i].to;\n\t\t\tdfs2(e[i].to,x);\n\t\t}\n}\n\nint getLCA(int x,int y){\n\twhile(top[x]^top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tx=pre[top[x]];\n\t}\n\treturn dep[x]<dep[y]?x:y;\n}\n\nint getDis(int x,int y){\n\treturn dep[x]+dep[y]-2*dep[getLCA(x,y)];\n}\n\nint goUp(int x,int d){\n\twhile(dep[x]-dep[top[x]]+1<d){\n\t\td-=dep[x]-dep[top[x]]+1;\n\t\tx=pre[top[x]];\n\t}\n\treturn pt[w[x]-d];\n}\n\nint step(int x,int y){\n\tint lca=getLCA(x,y);\n\tif(lca!=x) return pre[x];\n\treturn goUp(y,dep[y]-dep[x]-1);\n}\n\nvoid dfs3(int x,int p){\n\tpre2[x]=p;\n\tfor(int i=g2[x];~i;i=e2[i].next)\n\t\tif(e2[i].to^p){\n\t\t\tint y=e2[i].to;\n\t\t\tint dis=getDis(x,y);\n\t\t\tif(y==h[x] || x==h[x]) continue;\n\t\t\tif(dis>=3) flag=1;\n\t\t\th[y]=step(h[x],y);\n\t\t\tdep2[y]=dep2[x]+1;\n\t\t\tdfs3(y,x);\n\t\t}\n\tint res=getDis(h[x],x)*2+dep2[x]*2;\n\tans=max(ans,res);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tmemset(g2,-1,sizeof g2);\n\tscanf(\"%d%d%d\",&n,&x1,&x2);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge2(u,v);\n\t\taddEdge2(v,u);\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\ttop[1]=1;\n\tdfs2(1,0);\n\th[x1]=x2;\n\tdfs3(x1,0);\n\tif(flag) puts(\"-1\");\n\telse printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int maxn=2e5+5;\nint n,X,Y,tot;\nint a[maxn],b[maxn],dep[maxn],fa[maxn][20];\nint head[maxn],des[maxn<<1],nxt[maxn<<1];\nint mark[maxn],q[maxn],mint[maxn],vis[maxn];\nvector<int>e[maxn];\nvoid adde(int x,int y){\n\tdes[++tot]=y;nxt[tot]=head[x];head[x]=tot;\n}\nvoid dfs(int x){\n\tRep(p,x)if(des[p]!=fa[x][0]){\n\t\tdep[des[p]]=dep[x]+1;\n\t\tfa[des[p]][0]=x;\n\t\trep(i,1,19)fa[des[p]][i]=fa[fa[des[p]][i-1]][i-1];\n\t\tdfs(des[p]);\n\t}\n}\nint lca(int x,int y){\n\tif(dep[x]<dep[y])swap(x,y);\n\tper(i,19,0)if(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\tif(x==y)return x;\n\tper(i,19,0)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n\treturn fa[x][0];\n}\nint dis(int x,int y){\n\treturn dep[x]+dep[y]-2*dep[lca(x,y)];\n}\nvoid bfs(){\n\tint h=0,t=0,maxi=0;\n\tq[t++]=X;mint[X]=0;vis[X]=1;\n\twhile(h!=t){\n\t\tint x=q[h++];\n\t\tmaxi=max(maxi,dep[x]-1);\n\t\tif(mark[x]){\n\t\t\tputs(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\trep2(i,0,SZ(e[x])){\n\t\t\tint y=e[x][i];\n\t\t\tif(!vis[y]&&dep[y]-1>mint[x]+1)q[t++]=y,mint[y]=mint[x]+1,vis[y]=1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maxi<<1);\n}\nint main(){\n\tread(n);read(X);read(Y);\n\trep(i,1,n-1)read(a[i]),read(b[i]);\n\trep(i,1,n-1){\n\t\tint x,y;read(x);read(y);\n\t\tadde(x,y);adde(y,x);\n\t}\n\tdep[Y]=1;dfs(Y);\n\trep(i,1,n-1){\n\t\tif(dis(a[i],b[i])>2)mark[a[i]]=mark[b[i]]=1;\n\t\telse e[a[i]].pb(b[i]),e[b[i]].pb(a[i]);\n\t}\n\tbfs();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct lca_finder{\n    int size, lg;\n    vector<vector<int> > lca;\n    vector<int> depths;\n    lca_finder(vector<int> & parents, vector<int> & dep){\n        // root should have -1 as parent\n        size = parents.size();\n        depths = dep;\n        lg = log2(size) + 2;\n        lca.assign(lg, vector<int>(size));\n        for(int e = 0; e < size; e++)\n            lca[0][e] = parents[e];\n        build();\n    }\n    void build(){\n        for(int e = 1; e < lg; e++)\n            for(int f = 0; f < size; f++)\n                if(lca[e-1][f] != -1)\n                    lca[e][f] = lca[e-1][lca[e-1][f]];\n    }\n    int get_lca(int u, int v){\n        if(depths[u] < depths[v]) swap(u, v);\n        for(int e = lg - 1; e >= 0; e--)\n            if((depths[u] - depths[v]) & (1 << e))\n                u = lca[e][u];\n        if(u == v) return u;\n        for(int e = lg - 1; e >= 0; e--)\n            if(lca[e][u] != lca[e][v]){\n                u = lca[e][u];\n                v = lca[e][v];\n            }\n        return lca[0][u];\n    }\n};\nconst int maxn = 200200;\nvector<int> red[maxn], blue[maxn];\nint dist_blue[maxn], good[maxn], parent[maxn];\nvoid dfs(int cur, int par){\n\tparent[cur] = par;\n\tfor(int nxt : blue[cur]){\n\t\tif(nxt == par) continue;\n\t\tdist_blue[nxt] = dist_blue[cur] + 1;\n\t\tdfs(nxt, cur);\n\t}\n}\nint mx;\nvoid loop(){\n\tcout << -1 << endl;\n\texit(0);\n}\nvoid run(int cur, int par, int i){\n\tif(dist_blue[cur] <= i) mx = max(mx, dist_blue[cur] * 2);\n\telse {\n\t\tif(good[cur]) loop();\n\t\tfor(int nxt : red[cur]){\n\t\t\tif(nxt == par) continue;\n\t\t\trun(nxt, cur, i + 1);\n\t\t}\n\t}\n}\nint main(){\n\tint n, X, Y; cin >> n >> X >> Y; X--; Y--;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tred[a].push_back(b);\n\t\tred[b].push_back(a);\n\t}\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tblue[a].push_back(b);\n\t\tblue[b].push_back(a);\n\t}\n\tdfs(Y, -1);\n\tvector<int> _parent(n), _depth(n);\n\tfor(int i = 0; i < n; i++){\n\t\t_parent[i] = parent[i];\n\t\t_depth[i] = dist_blue[i];\n\t}\n\tlca_finder lc(_parent, _depth);\n\tauto get_blue_distance = [&](int u, int v){\n\t\treturn dist_blue[u] + dist_blue[v] - 2 * dist_blue[lc.get_lca(u, v)];\n\t};\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j : red[i]){\n\t\t\tif(get_blue_distance(i, j) >= 3){\n\t\t\t\tgood[i] = 1;\n\t\t\t\tgood[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\trun(X, -1, 0);\n\tcout << mx + 2 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 400005\nusing namespace std;\nint n,u,v,fa[N],fst[N],to[N],nxt[N],l,dep[N],dis[N],Ans,f[N],q[N];\nstruct T\n{\n\tint x,y;\n}a[N],b[N];\nvector<int>e[N];\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nvoid dfs(int x)\n{\n\tfor (int i=fst[x];i;i=nxt[i])\n\t\tif (to[i]!=fa[x])\n\t\t{\n\t\t\tfa[to[i]]=x;\n\t\t\tdep[to[i]]=dep[x]+1;\n\t\t\tdfs(to[i]);\n\t\t}\n}\nint Gdis(int x,int y)\n{\n\tif (x==y) return 0;\n\tif (fa[x]==y||fa[y]==x) return 1;\n\tif (fa[x]==fa[y]||fa[fa[x]]==y||fa[fa[y]]==x) return 2;\n\treturn 3;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&u,&v);\n\t//if (u==v){puts(\"0\");,return 0;}\n\tfor (int i=1;i<n;i++)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&b[i].x,&b[i].y);\n\t\tlink(b[i].x,b[i].y);\n\t}\n\tdfs(v);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint tmp=Gdis(a[i].x,a[i].y);\n\t\tif (tmp==1)\n\t\t{\n\t\t\te[a[i].x].push_back(a[i].y);\n\t\t\te[a[i].y].push_back(a[i].x);\n\t\t}\n\t\telse if (tmp==2)\n\t\t{\n\t\t\tif (fa[a[i].x]!=v||fa[a[i].y]!=v)\n\t\t\t{\n\t\t\t\te[a[i].x].push_back(a[i].y);\n\t\t\t\te[a[i].y].push_back(a[i].x);\n\t\t\t}\n\t\t}\n\t\telse f[a[i].x]=f[a[i].y]=1;\n\t}\n\tmemset(dis,0x3f,sizeof dis);\n\tint l=0,r=1;\n\tq[1]=u;dis[u]=0;\n\twhile(l<r)\n\t{\n\t\tint t=q[++l];\n\t\t//cout<<t<<' '<<dis[t]<<endl;\n\t\tif (f[t]==1){puts(\"-1\");return 0;}\n\t\telse Ans=max(Ans,dep[t]*2);\n\t\tfor (int i=0;i<e[t].size();i++)\n\t\t\tif (dis[e[t][i]]>dis[t]+1&&dis[t]+1<dep[e[t][i]])\n\t\t\t{\n\t\t\t\tdis[e[t][i]]=dis[t]+1;\n\t\t\t\tq[++r]=e[t][i];\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stweight++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int lg = 20;\nvector<int> red[N];\nvector<int> blue[N];\nint h[N];\nint par[lg + 5][N];\nint n, x, y;\nbool winPos[N];\nint disR[N];\nint disB[N];\n\n\nvoid dfs(int v = 0, int p = -1)\n{\n    for (int u : blue[v])\n    {\n        if (u != p)\n        {\n            par[0][u] = v;\n            h[u] = h[v] + 1;\n            dfs(u, v);\n        }\n    }\n}\n\nvoid pre()\n{\n    for (int k = 1; k < lg; k++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            par[k][i] = par[k - 1][ par[k - 1][i] ];\n        }\n    }\n}\n\nint lca(int v, int u)\n{\n    if(h[v] > h[u])\n    {\n        swap(v, u);\n    }\n    for (int i = 0; i < lg; i++)\n    {\n        if (h[u] - h[v] >> i & 1)\n        {\n            u = par[i][u];\n        }\n    }\n    for (int i = lg - 1; i >= 0; i--)\n    {\n        if(par[i][v] != par[i][u])\n        {\n            v = par[i][v], u = par[i][u];\n        }\n    }\n    return v == u ? v : par[0][v];\n}\n\nvoid dfs1(int v, int par = -1)\n{\n    if (disR[v] >= disB[v])\n    {\n        return;\n    }\n    for (auto u: red[v])\n    {\n        if (u != par)\n        {\n            disR[u] = disR[v] + 1;\n            dfs1(u, v);\n        }\n    }\n}\n\nvoid dfs2(int v, int par = -1)\n{\n    for (auto u: blue[v])\n    {\n        if (u != par)\n        {\n            disB[u] = disB[v] + 1;\n            dfs2(u, v);\n        }\n    }\n}\n\n\n\nint main()\n{\n    cin >> n >> x >> y;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        red[u - 1].push_back(v - 1);\n        red[v - 1].push_back(u - 1);\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        blue[u - 1].push_back(v - 1);\n        blue[v - 1].push_back(u - 1);\n    }\n    dfs();\n    pre();\n    for (int i = 0; i < n; i++)\n    {\n        for (auto u: red[i])\n        {\n            int tmp = lca(u, i);\n            if (h[u] - h[tmp] + h[i] - h[tmp] > 2)\n            {\n                winPos[i] = true;\n                winPos[u] = true;\n            }\n        }\n    }\n    memset(disR, 127, sizeof disR);\n    disR[x - 1] = 0;\n    dfs2(y - 1);\n    dfs1(x - 1);\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (winPos[i] && disR[i] <= disB[i])\n        {\n            cout << -1 << endl;\n            exit(0);\n        }\n        if (disR[i] < N)\n        {\n            //cout << endl;\n            //cout << i << \" \" << disB[i] << endl;\n            ans = max(ans, disB[i] * 2);\n        }\n    }\n    cout << ans << endl;\n\n\n\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nnamespace tree {\nstruct Edge {\n//\tint cost;\n//\tint id;\n};\nint n;\nvector<Edge> edges;\nvector<vector<pair<int, int>>> adj;\nvoid makeTree(int _n) {\n\tn = _n;\n\tadj = vector<vector<pair<int, int>>>(n + 1);\n}\ntemplate <typename... T>\nint addEdge(int from, int to, const T&... e) {\n\tint id = edges.size();\n\tadj[from].emplace_back(to, id);\n\tadj[to].emplace_back(from, id);\n\tedges.push_back({e...});\n\treturn id;\n}\nvector<int> depth, pv, pe, pre, endpre, preseq, siz;\nint logn;\nvector<vector<int>> anc;\nstruct Jump {\n\tint sum;\n\tvoid init(int v) {\n\t\tEdge& e = edges[pe[v]];\n\t\tsum = 1;\n\t}\n\tvoid combine(const Jump& x, const Jump& a) { // a is ancestor of x\n\t\tsum = x.sum + a.sum;\n\t}\n};\nvector<vector<Jump>> jump;\nvoid dfs(int x, int p = -1) {\n\tsiz[x] = 1;\n\tpre[x] = preseq.size();\n\tpreseq.push_back(x);\n\tfor (auto& e : adj[x]) {\n\t\tint y = e.first, eid = e.second;\n\t\tif (y == p) continue;\n\t\tdepth[y] = depth[x] + 1;\n\t\tpv[y] = x;\n\t\tpe[y] = eid;\n\t\tdfs(y, x);\n\t\tsiz[x] += siz[y];\n\t}\n\tendpre[x] = (int)preseq.size() - 1; // This is the last vertex in the subtree of x\n}\nvoid init(int root = 1) {\n\tsiz = vector<int>(n + 1);\n\tdepth = vector<int>(n + 1);\n\tpv = vector<int>(n + 1, -1);\n\tpe = vector<int>(n + 1, -1);\n\tpre = vector<int>(n + 1, -1);\n\tendpre = vector<int>(n + 1, -1);\n\tpreseq.clear();\n\tdfs(root);\n\tlogn = 31 - __builtin_clz(n);\n\tanc = vector<vector<int>>(n + 1, vector<int>(logn + 1));\n\tfor (int i = 1; i <= n; ++i) anc[i][0] = pv[i];\n\tfor (int p = 1; p <= logn; ++p)\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tanc[i][p] = anc[i][p - 1] == -1 ? -1 : anc[anc[i][p - 1]][p - 1];\n//\tjump = vector<vector<Jump>>(n + 1, vector<Jump>(logn + 1));\n//\tfor (int i = 1; i <= n; ++i)\n//\t\tif (anc[i][0] != -1) jump[i][0].init(i);\n//\tfor (int p = 1; p <= logn; ++p)\n//\t\tfor (int i = 1; i <= n; ++i)\n//\t\t\tif (anc[i][p] != -1)\n//\t\t\t\tjump[i][p].combine(jump[i][p - 1], jump[anc[i][p - 1]][p - 1]);\n}\nbool isAnc(int a, int b) {\n\treturn pre[a] <= pre[b] && endpre[a] >= endpre[b];\n}\nint getChildTowards(int a, int sub) {\n\tint dh = depth[sub] - depth[a] - 1;\n\tfor (int p = logn; p >= 0; --p)\n\t\tif (dh & (1 << p)) sub = anc[sub][p];\n\treturn sub;\n}\nint getLca(int a, int b) {\n\tif (isAnc(a, b)) return a;\n\tif (isAnc(b, a)) return b;\n\tfor (int p = logn; p >= 0; --p)\n\t\tif (anc[a][p] != -1 && !isAnc(anc[a][p], b))\n\t\t\ta = anc[a][p];\n\ta = anc[a][0];\n\treturn a;\n}\n// Jump up from a to ancestor, running f on each 2^k-block in order.\nvoid jumpUp(int a, int ancestor, function<void(Jump&)> f) {\n\tassert(isAnc(ancestor, a));\n\tint up = depth[a] - depth[ancestor];\n\tfor (int p = logn; p >= 0; --p)\n\t\tif (up & (1 << p)) {\n\t\t\tf(jump[a][p]);\n\t\t\ta = anc[a][p];\n\t\t}\n}\nvector<int> chainRoot, chainBottom;\nvoid dfsSiz(int x, int p = -1) {\n\tfor (auto it = adj[x].begin(); it != adj[x].end(); ++it)\n\t\tif (it->first == p) {\n\t\t\tadj[x].erase(it);\n\t\t\tbreak;\n\t\t}\n\tsiz[x] = 1;\n\tfor (auto& e : adj[x]) {\n\t\tint y = e.first;\n\t\tdfsSiz(y, x);\n\t\tsiz[x] += siz[y];\n\t\tif (siz[y] > siz[adj[x][0].first]) swap(e, adj[x][0]);\n\t}\n}\nvoid dfsHld(int x, int hldroot) {\n\tchainRoot[x] = hldroot;\n\tchainBottom[hldroot] = x;\n\tfor (auto& e : adj[x]) {\n\t\tint y = e.first;\n\t\tdfsHld(y, y == adj[x][0].first ? hldroot : y);\n\t}\n}\nstruct Chain {\n\tvector<int> vs;\n\t// Bottom vertex and top vertex of chain\n\tvoid init(int bot, int top) {\n\t\tvs.clear();\n\t\tfor (int x = bot; x != pv[top]; x = pv[x])\n\t\t\tvs.push_back(x);\n\t}\n};\nvector<Chain> chains;\n// Move upwards from x to y (ancestor)\n// A segment consists of vertices on a heavy path. pre[x] stores the position in the\n// heavy-light segment tree of the edge (x, parent[x]).\n// Smaller pre -> higher up in tree (lower depth)\n// Apply f(Chain, vertex_bottom, vertex_top) on some prefix of the chain\nvoid moveUp(int x, int y, function<void(Chain&, int, int)> f) {\n\tfor (;;) {\n\t\tint z = chainRoot[x];\n\t\tbool isLastChain = z == chainRoot[y];\n\t\tf(chains[chainRoot[x]], x, isLastChain ? y : z);\n\t\tif (isLastChain) break;\n\t\tx = pv[z];\n\t}\n}\n// Chains are contiguous substrings of preSeq array.\n// Or, we also have a struct Chain in each chainRoot.\nvoid initHld(int root = 1) {\n\tsiz = vector<int>(n + 1);\n\tdfsSiz(root); // Make adj[x][0] the largest subtree\n\tinit(root); // Now pre and endpre is on the hld sequence\n\tchainRoot = vector<int>(n + 1);\n\tchainBottom = vector<int>(n + 1);\n\tdfsHld(root, root);\n\tchains = vector<Chain>(n + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (chainRoot[i] != i) continue;\n\t\tchains[i].init(chainBottom[i], i);\n\t}\n}\n}; // namespace tree\nusing namespace tree;\nint getDist(int a, int b) {\n\tint c = getLca(a, b);\n\treturn depth[a] + depth[b] - 2 * depth[c];\n}\nvector<int> EX[200005];\nint maxt;\nvoid go(int x, int p = -1, int h = 0) {\n\tif (depth[x] <= h) return;\n\tmaxt = max(maxt, depth[x]);\n\tfor (int y : EX[x]) {\n\t\tif (y == p) continue;\n\t\tif (getDist(x, y) > 2) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tgo(y, x, h + 1);\n\t}\n}\nint main() {\n\tint n, x, y;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tmakeTree(n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tEX[a].push_back(b);\n\t\tEX[b].push_back(a);\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\taddEdge(a, b);\n\t}\n\tinit(y);\n\tgo(x);\n\tprintf(\"%d\\n\", 2 * maxt);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)) f=ch=='-'?-1:f,ch=getchar();\n\twhile (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\n\nconst int N=200005;\nconst int LGN=18;\nconst int E=N<<1;\n\nstruct tree\n{\n\tint tov[E],nxt[E];\n\tint last[N];\n\tint tot;\n\n\tinline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n}t[2];\n\nint LOG[N],depth[N];\nint anc[N][LGN];\nint n,srcx,srcy,ans;\n\nvoid dfs(int x)\n{\n\tfor (int i=t[1].last[x],y;i;i=t[1].nxt[i])\n\t\tif ((y=t[1].tov[i])!=anc[x][0]) depth[y]=depth[anc[y][0]=x]+1,dfs(y);\n}\n\nvoid pre()\n{\n\tLOG[1]=0;\n\tfor (int i=2;i<=n;++i) LOG[i]=LOG[i-1]+(1<<LOG[i-1]+1==i);\n\tfor (int i=1;i<=LOG[n];++i)\n\t\tfor (int x=1;x<=n;++x)\n\t\t\tanc[x][i]=anc[anc[x][i-1]][i-1];\n}\n\ninline int adjust(int x,int h)\n{\n\tfor (int i=LOG[depth[x]];i>=0;--i) if (depth[anc[x][i]]>=h) x=anc[x][i];\n\treturn x;\n}\n\ninline int lca(int x,int y)\n{\n\tif (depth[x]>depth[y]) swap(x,y);\n\ty=adjust(y,depth[x]);\n\tif (x==y) return x;\n\tfor (int i=LOG[depth[x]];i>=0;--i) if (anc[x][i]!=anc[y][i]) x=anc[x][i],y=anc[y][i];\n\treturn anc[x][0];\n}\n\ninline int dist(int x,int y){return depth[x]+depth[y]-(depth[lca(x,y)]<<1);}\n\nvoid calc(int x,int fa=0,int cur=0)\n{\n\tif (cur>=depth[x]-1) return;\n\tans=max(ans,depth[x]-1<<1);\n\tfor (int i=t[0].last[x],y;~ans&&i;i=t[0].nxt[i])\n\t\tif ((y=t[0].tov[i])!=fa)\n\t\t{\n\t\t\tif (dist(x,y)>2) ans=-1;\n\t\t\telse calc(y,x,cur+1);\n\t\t}\n}\n\nint main()\n{\n\t//freopen(\"sugigma.in\",\"r\",stdin),freopen(\"sugigma.out\",\"w\",stdout);\n\tn=read(),srcx=read(),srcy=read();\n\tfor (int s=0;s<2;++s)\n\t\tfor (int i=1,x,y;i<n;++i)\n\t\t\tx=read(),y=read(),t[s].insert(x,y),t[s].insert(y,x);\n\tdepth[srcy]=1,dfs(srcy),pre(),ans=0,calc(srcx);\n\tprintf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\t   c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nvector<int> to[2][MAXN];\nint fa[MAXN][20],dep[MAXN];\nint N,X,Y,ans;\nbool flag = 0;\nint lca(int u,int v) {\n    if(dep[u] < dep[v]) swap(u,v);\n    int l = 18;\n    while(dep[u] > dep[v]) {\n        if(dep[fa[u][l]] >= dep[v]) {\n            u = fa[u][l];\n        }\n        --l;\n    }\n    if(u == v) return u;\n    l = 18;\n    while(fa[u][0] != fa[v][0]) {\n        if(fa[u][l] != fa[v][l]) {\n            u = fa[u][l];\n            v = fa[v][l];\n        }\n        --l;\n    }\n    return fa[u][0];\n}\nint dist(int u,int v) {\n    return dep[u] + dep[v] - 2 * dep[lca(u,v)];\n}\nvoid dfs(int u) {\n    for(auto t : to[1][u]) {\n        if(t != fa[u][0]) {\n            dep[t] = dep[u] + 1;\n            fa[t][0] = u;\n            dfs(t);\n        }\n    }\n}\nvoid dfs1(int u,int f) {\n    if(u == Y) return;\n    ans = max(ans,dep[u] - 1);\n    for(auto t : to[0][u]) {\n        if(t == f) continue;\n        if(dist(u,t) > 2) flag = 1;\n        dfs1(t,u);\n    }\n}\nvoid Solve() {\n    read(N);read(X);read(Y);\n    int a,b;\n    for(int i = 1 ; i < N ; ++i) {\n        read(a);read(b);\n        to[0][a].pb(b);to[0][b].pb(a);\n    }\n    for(int i = 1 ; i < N ; ++i) {\n        read(a);read(b);\n        to[1][a].pb(b);to[1][b].pb(a);\n    }\n    dep[Y] = 1;\n    dfs(Y);\n    for(int j = 1 ; j <= 19 ; ++j) {\n        for(int i = 1 ; i <= N ; ++i) {\n            fa[i][j] = fa[fa[i][j - 1]][j - 1];\n        }\n    }\n    dfs1(X,0);\n    if(flag) {puts(\"-1\");}\n    else {out(2 * ans);enter;}\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint ea[200010],eb[200010];\nbool ya[200010];\nstruct tree{\n\tint fir[200010],dis[400010],nxt[400010],id,fa[200010],dep[200010];\n\tvoid link(int a,int b){nxt[++id]=fir[a],fir[a]=id,dis[id]=b;}\n\tvoid dfs(int x,int*Bd=0){\n\t\tif(Bd&&dep[x]>=Bd[x]){return;}\n\t\tfor(int i=fir[x];i;i=nxt[i]){\n\t\t\tif(fa[x]==dis[i])continue;\n\t\t\tfa[dis[i]]=x;\n\t\t\tdep[dis[i]]=dep[x]+1;\n\t\t\tdfs(dis[i],Bd);\n\t\t}\n\t}\n}A,B;\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),sa=gi(),sb=gi(),a,b;\n\tfor(int i=1;i<n;++i)ea[i]=gi(),eb[i]=gi();\n\tfor(int i=1;i<n;++i)a=gi(),b=gi(),B.link(a,b),B.link(b,a);\n\tB.dfs(sb);\n\tfor(int i=1;i<n;++i)\n\t\tif(B.fa[ea[i]]==eb[i]||\n\t\t   B.fa[eb[i]]==ea[i]||\n\t\t   B.fa[B.fa[ea[i]]]==eb[i]||\n\t\t   B.fa[B.fa[eb[i]]]==ea[i]||\n\t\t   B.fa[ea[i]]==B.fa[eb[i]])\n\t\t\tA.link(ea[i],eb[i]),A.link(eb[i],ea[i]);\n\t\telse ya[ea[i]]=ya[eb[i]]=1;\n\tmemset(A.dep,-1,sizeof A.dep);A.dep[sa]=0,A.dfs(sa,B.dep);\n\tfor(int i=1;i<=n;++i)if(~A.dep[i]&&ya[i]&&A.dep[i]<B.dep[i])return puts(\"-1\"),0;\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)if(~A.dep[i])ans=std::max(ans,B.dep[i]);\n\tprintf(\"%d\\n\",ans*2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 200010;\n\nvi g[2][maxn];\nint dep[maxn], par[maxn]; //sugim\n\nvoid dfs(int v, int p, int d) { //on sugim\n\tdep[v] = d;\n\tpar[v] = p;\n\tfor (int to : g[1][v]) if (to != p) {\n\t\tdfs(to, v, d + 1);\n\t}\n}\n\nbool far(int a, int b) { //on sugim, 3\n\tif (dep[a] > dep[b]) swap(a, b);\n\tif (a == b || par[b] == a || par[a] == par[b] || (par[b] != -1 && par[par[b]] == a)) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\nconst int INF = 1e8;\n\nint DFS(int v, int p, int d) { //on sigma\n\tint res = (dep[v] - d) * 2;\n\tfor (int to : g[0][v]) if (to != p) {\n\t\tif (dep[to] > d+1) {\n\t\t\tres = max(res, DFS(to, v, d + 1) + 2);\n\t\t}\n\t\tif (far(v, to)) {\n\t\t\tres = max(res, INF);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N, X, Y;\n\tcin >> N >> X >> Y; --X; --Y;\n\n\trep(t, 2) {\n\t\trep(i, N-1) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tg[t][a].pb(b); g[t][b].pb(a);\n\t\t}\n\t}\n\n\tdfs(Y, -1, 0);\n\tint ans = DFS(X, -1, 0);\n\tif (ans >= INF) ans = -1;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N=200005;\nstruct qq\n{\n\tint x,y,last;\n}e[N];int num,last[N];\nint X[N],Y[N];\nvoid init (int x,int y)\n{\n\tnum++;\n\te[num].x=x;e[num].y=y;\n\te[num].last=last[x];\n\tlast[x]=num;\n}\nint n,xx,yy;\nint L[N],R[N],dep[N],fa[N];\nvoid dfs (int x)\n{\n\tL[x]=++num;\n\tfor (int u=last[x];u!=-1;u=e[u].last)\n\t{\n\t\tint y=e[u].y;\n\t\tif (y==fa[x]) continue;\n\t\tfa[y]=x;dep[y]=dep[x]+1;\n\t\tdfs(y);\n\t}\n\tR[x]=num;\n}\nbool ok[N];\nvector<int> vec[N];\nbool vis[N];\nint d[N];\nvoid bfs ()\n{\n\tmemset(d,127,sizeof(d));\n\tmemset(vis,false,sizeof(vis));\n\tvis[xx]=true;d[xx]=0;\n\tqueue<int> q;q.push(xx);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t//\tprintf(\"%d\\n\",x);\n\t\tint siz=vec[x].size();\n\t\tfor (int i=0;i<siz;i++)\n\t\t{\n\t\t\tint y=vec[x][i];\n\t\t\tif (vis[y]) continue;\n\t\t\tif (d[y]>d[x]+1)\n\t\t\t{\n\t\t\t\td[y]=d[x]+1;\n\t\t\t\tif (d[y]<dep[y]) \n\t\t\t\t{\n\t\t\t\t\tvis[y]=true;\n\t\t\t\t\tq.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nbool check (int x,int y)//这两个点是否可以由同一个点到达 \n{\n\tif (dep[x]>dep[y]) swap(x,y);\n\tif (L[x]<=L[y]&&L[y]<=R[x])//在他子树里面\n\t\treturn dep[y]-dep[x]>2;\n\tif (fa[x]==fa[y]) return false;\n\treturn true;\n}\nint main()\n{\n\tnum=0;memset(last,-1,sizeof(last));\n\tscanf(\"%d%d%d\",&n,&xx,&yy);\n\tfor (int u=1;u<n;u++) scanf(\"%d%d\",&X[u],&Y[u]);\n\tfor (int u=1;u<n;u++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tinit(x,y);init(y,x);\n\t}\n\tnum=0;dfs(yy);\n\t/*for (int u=1;u<=n;u++) printf(\"%d \",dep[u]);\n\tprintf(\"\\n\");*/\n\tmemset(ok,false,sizeof(ok));\n\tfor (int u=1;u<n;u++)\n\t{\n\t\tif (check(X[u],Y[u]))\t{ok[X[u]]=true;ok[Y[u]]=true;}\n\t\telse vec[X[u]].push_back(Y[u]),vec[Y[u]].push_back(X[u]);\n\t}\n\tbfs();\n\tint ans=0;\n\tfor (int u=1;u<=n;u++)\n\t{\n\t\tif (ok[u]&&vis[u])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (vis[u])\tans=max(ans,dep[u]*2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define maxn 200005\nusing namespace std;\nint n,x,y,dep[maxn],fa[maxn],l[maxn],r[maxn],cnt,u1[maxn],v1[maxn],dist[maxn],ans;\nbool vis[maxn],islong[maxn];\nstruct node { int v; node *nxt; } edge[maxn*4],*head[2][maxn],*ncnt;\nqueue<int> q;\nvoid addedge(int x,int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[x][u];\n\thead[x][u]=ncnt;\n}\nvoid dfs(int u)\n{\n\tl[u]=++cnt;\n\tfor(node *p=head[1][u];p;p=p->nxt)\n\t{\n\t\tint v=p->v;\n\t\tif(v==fa[u]) continue;\n\t\tfa[v]=u,dep[v]=dep[u]+1;\n\t\tdfs(v);\n\t}\n\tr[u]=++cnt;\n}\nbool check(int x,int y)\n{\n\tif(l[x]>l[y]) swap(x,y);\n\tif(l[x]<=l[y]&&r[y]<=r[x]) return dep[y]-dep[x]>2;\n\telse return fa[x]!=fa[y];\n}\nvoid bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tvis[x]=true; q.push(x);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front(); q.pop();\n\t\tfor(node *p=head[0][u];p;p=p->nxt)\n\t\t{\n\t\t\tint v=p->v;\n\t\t\tif(vis[v]) continue;\n\t\t\tdist[v]=dist[u]+1;\n\t\t\tif(dist[v]<dep[v]) { vis[v]=true; q.push(v); }\n\t\t}\n\t}\n}\nvoid read(int &x)\n{\n\tchar ch=getchar(); x=0;\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n}\nint main()\n{\n\twhile(~scanf(\"%d%d%d\",&n,&x,&y))\n\t{\n\t\tans=0;\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(islong,0,sizeof(islong));\n\t\tmemset(head,0,sizeof(head));\n\t\tncnt=&edge[0];\n\t\tfor(int i=1;i<n;i++) { read(u1[i]); read(v1[i]); }//scanf(\"%d%d\",&u1[i],&v1[i]);\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tread(u); read(v);//scanf(\"%d%d\",&u,&v);\n\t\t\taddedge(1,u,v); addedge(1,v,u);\n\t\t}\n\t\tfa[y]=dep[y]=0; dfs(y);\n\t\tfor(int i=1;i<n;i++)\n\t\t\tif(check(u1[i],v1[i])) islong[u1[i]]=islong[v1[i]]=true;\n\t\t\telse { addedge(0,u1[i],v1[i]); addedge(0,v1[i],u1[i]); }\n\t\tdist[x]=0; bfs();\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n&&ans!=-1;i++)\n\t\t\tif(vis[i]&&islong[i]) ans=-1;\n\t\t\telse if(vis[i]) ans=max(ans,dep[i]*2);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "Text",
    "code": "-1\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define tree_valtype int\n\ntypedef struct tree_edge_sub tree_edge;\n\ntypedef struct {\n\tint num;\n\tint nearnum;\n\ttree_edge *near;\n}tree_vertex_sub;\n\nstruct tree_edge_sub{\n\ttree_vertex_sub *v;\n\tint w;\n\ttree_edge *next;\n};\n\ntypedef struct tree_v_sub tree_vertex;\n\nstruct tree_v_sub{\n\tint num;\n\ttree_valtype val;\n\ttree_vertex *parent;\n\tint pareweight;\n\tint chilnum;\n\ttree_vertex **children;\n\tint *chilweight;\n};\n\ntypedef struct {\n\tint N;\n\tint root;\n\ttree_vertex_sub **v_s;\n\ttree_vertex **v;\n\ttree_vertex **sorted_v;\n}tree;\n\n//頂点数N, 根の番号root, 各頂点の初期値ini_valの木を作る\ntree *make_tree(int N, int root, tree_valtype ini_val){\n\tint i;\n\ttree *t = (tree *)malloc(sizeof(tree));\n\tt->N = N;\n\tt->root = root;\n\tt->v_s = (tree_vertex_sub **)malloc(sizeof(tree_vertex_sub *) * N);\n\tt->v = (tree_vertex **)malloc(sizeof(tree_vertex *) * N);\n\tt->sorted_v = (tree_vertex **)malloc(sizeof(tree_vertex *) * N);\n\ttree_vertex *parent_in_law = (tree_vertex *)malloc(sizeof(tree_vertex));\n\tparent_in_law->num = -1;\n\tparent_in_law->val = ini_val;\n\tparent_in_law->parent = NULL;\n\tparent_in_law->pareweight = -1;\n\tparent_in_law->chilnum = 0;\n\tparent_in_law->children = NULL;\n\tparent_in_law->chilweight = NULL;\n\tfor(i = 0; i < N; i++){\n\t\t(t->v_s)[i] = (tree_vertex_sub *)malloc(sizeof(tree_vertex_sub));\n\t\t(t->v_s)[i]->num = i;\n\t\t(t->v_s)[i]->nearnum = 0;\n\t\t(t->v_s)[i]->near = NULL;\n\t\t(t->v)[i] = (tree_vertex *)malloc(sizeof(tree_vertex));\n\t\t(t->v)[i]->num = i;\n\t\t(t->v)[i]->val = ini_val;\n\t\t(t->v)[i]->parent = parent_in_law;\n\t\t(t->v)[i]->pareweight = -1;\n\t\t(t->v)[i]->chilnum = 0;\n\t\t(t->v)[i]->children = NULL;\n\t\t(t->v)[i]->chilweight = NULL;\n\t\t(t->sorted_v)[i] = NULL;\n\t}\n\treturn t;\n}\n\n//木tの頂点aと頂点bの間に重みwの無向辺を張る (0 <= a, b <= N - 1)\nvoid set_edge_tree(int a, int b, int w, tree *t){\n\ttree_edge *new1 = (tree_edge *)malloc(sizeof(tree_edge));\n\tnew1->v = (t->v_s)[b];\n\tnew1->w = w;\n\tnew1->next = (t->v_s)[a]->near;\n\t(t->v_s)[a]->near = new1;\n\t(t->v_s)[a]->nearnum++;\n\n\ttree_edge *new2 = (tree_edge *)malloc(sizeof(tree_edge));\n\tnew2->v = (t->v_s)[a];\n\tnew2->w = w;\n\tnew2->next = (t->v_s)[b]->near;\n\t(t->v_s)[b]->near = new2;\n\t(t->v_s)[b]->nearnum++;\n}\n\n//set_edge_tree後に呼び出す\nvoid build_tree(tree *t){\n\tint i, j;\n\ttree_vertex_sub **v_s = t->v_s;\n\ttree_vertex **v = t->v;\n\ttree_vertex **sorted_v = t->sorted_v;\n\tsorted_v[0] = v[t->root];\n\ttree_vertex *nowv;\n\ttree_edge *nowe;\n\tfor(i = 0, j = 1; j - i > 0; i++){\n\t\tnowv = sorted_v[i];\n\t\tif(i == 0){\n\t\t\tv_s[nowv->num]->nearnum++;\n\t\t}\n\t\tnowv->children = (tree_vertex **)malloc(sizeof(tree_vertex *) * (v_s[nowv->num]->nearnum - 1));\n\t\tnowv->chilweight = (int *)malloc(sizeof(int) * (v_s[nowv->num]->nearnum - 1));\n\t\tif(i == 0){\n\t\t\tv_s[nowv->num]->nearnum--;\n\t\t}\n\t\tfor(nowe = v_s[nowv->num]->near; nowe != NULL; nowe = nowe->next){\n\t\t\tif(nowe->v->num != nowv->parent->num){\n\t\t\t\t(nowv->children)[nowv->chilnum] = v[nowe->v->num];\n\t\t\t\t(nowv->chilweight)[nowv->chilnum] = nowe->w;\n\t\t\t\tnowv->chilnum++;\n\t\t\t\tv[nowe->v->num]->parent = nowv;\n\t\t\t\tv[nowe->v->num]->pareweight = nowe->w;\n\t\t\t\tsorted_v[j] = v[nowe->v->num];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ntypedef struct {\n\ttree_vertex **array;\n\tint N;\n}stack;\n\nstack *make_stack(int maxN){\n\tstack *s = (stack *)malloc(sizeof(stack));\n\ts->array = (tree_vertex **)malloc(sizeof(tree_vertex *) * maxN);\n\ts->N = 0;\n\treturn s;\n}\n\nint element_num_stack(stack *s){\n\treturn s->N;\n}\n\nvoid add_data_stack(tree_vertex *val, stack *s){\n\ts->array[s->N] = val;\n\ts->N++;\n}\n\ntree_vertex *take_data_stack(stack *s){\n\tif(s->N == 0){\n\t\tprintf(\"no data in the stack\\n\");\n\t}\n\ts->N--;\n\treturn s->array[s->N];\n}\n\ntree_vertex *look_data_stack(stack *s){\n\tif(s->N == 0){\n\t\tprintf(\"no data in the stack\\n\");\n\t}\n\telse{\n\t\treturn s->array[s->N - 1];\n\t}\n}\n\nvoid flush_stack(stack *s){\n\ts->N = 0;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint main(){\n\tint N, X, Y, a, b, i, j;\n\tscanf(\"%d%d%d\", &N, &X, &Y);\n\tX--;\n\tY--;\n\ttree *tr = make_tree(N, X, 0);\n\ttree *tb = make_tree(N, Y, 0);\n\tfor(i = 1; i < N; i++){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tset_edge_tree(a - 1, b - 1, 1, tr);\n\t}\n\tfor(i = 1; i < N; i++){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tset_edge_tree(a - 1, b - 1, 1, tb);\n\t}\n\tbuild_tree(tr);\n\tbuild_tree(tb);\n\ttree_vertex **vr = (tree_vertex **)malloc(sizeof(tree_vertex *) * N);\n\ttree_vertex **vb = (tree_vertex **)malloc(sizeof(tree_vertex *) * N);\n\tfor(i = 0; i < N; i++){\n\t\tvr[tr->sorted_v[i]->num] = tr->sorted_v[i];\n\t\tvb[tb->sorted_v[i]->num] = tb->sorted_v[i];\n\t}\n\ttree_vertex *nowv, *parev;\n\tfor(i = 1; i < N; i++){\n\t\tnowv = tr->sorted_v[i];\n\t\tnowv->val = nowv->parent->val + 1;\n\t\tnowv = tb->sorted_v[i];\n\t\tnowv->val = nowv->parent->val + 1;\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tprintf(\"vb[%d]->val = %d\\n\", i, vb[i]->val);\n\t}\n\tprintf(\"test3\\n\");\n*/\tint *escape = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\tescape[i] = 0;\n\t}\n\tint hnv, hpv;\n\tfor(i = 1; i < N; i++){\n\t\tnowv = tr->sorted_v[i];\n\t\tparev = nowv->parent;\n\t\thnv = vb[nowv->num]->val;\n\t\thpv = vb[parev->num]->val;\n//\t\tprintf(\"nowv->num = %d\\n\", nowv->num);\n//\t\tprintf(\"parev->num = %d\\n\", parev->num);\n//\t\tprintf(\"hnv = %d\\n\", hnv);\n//\t\tprintf(\"hpv = %d\\n\", hpv);\n\t\tif(hnv == hpv){\n//\t\t\tprintf(\"test3.2\\n\");\n\t\t\tif(vb[nowv->num]->parent->num == vb[parev->num]->parent->num){\n\t\t\t\tescape[parev->num]++;\n\t\t\t}\n\t\t}\n\t\telse if(hnv < hpv){\n\t\t\tif(hpv == hnv + 1){\n\t\t\t\tif(vb[parev->num]->parent->num == vb[nowv->num]->num){\n\t\t\t\t\tescape[parev->num]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(hpv == hnv + 2){\n\t\t\t\tif(vb[parev->num]->parent->parent->num == vb[nowv->num]->num){\n\t\t\t\t\tescape[parev->num]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(hnv == hpv + 1){\n//\t\t\t\tprintf(\"test3.5\\n\");\n\t\t\t\tif(vb[nowv->num]->parent->num == vb[parev->num]->num){\n\t\t\t\t\tescape[parev->num]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(hnv == hpv + 2){\n\t\t\t\tif(vb[nowv->num]->parent->parent->num == vb[parev->num]->num){\n\t\t\t\t\tescape[parev->num]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i = 0; i < N; i++){\n\t\tif(vr[i]->chilnum == escape[i]){\n\t\t\tescape[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tescape[i] = 1;\n\t\t}\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tprintf(\"escape[%d] = %d\\n\", i, escape[i]);\n\t}\n*/\tstack *s = make_stack(N);\n\tadd_data_stack(tr->sorted_v[0], s);\n\tint ans = 0;\n\twhile(element_num_stack(s) > 0){\n\t\tnowv = take_data_stack(s);\n//\t\tprintf(\"nowv->num = %d\\n\", nowv->num);\n\t\tans = max(ans, vb[nowv->num]->val);\n//\t\tprintf(\"ans = %d\\n\", ans);\n\t\tif(nowv->val < vb[nowv->num]->val){\n\t\t\tif(escape[nowv->num] == 1){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j = 0; j < nowv->chilnum; j++){\n\t\t\t\t\tadd_data_stack(nowv->children[j], s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", 2 * ans);\n\treturn 0;\n}"
  },
  {
    "language": "Pascal",
    "code": "begin\nend."
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        static TaskE.Vertex[] dest;\n        static int[] next;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskE.Vertex[] vs = new TaskE.Vertex[n];\n            for (int i = 0; i < n; ++i) vs[i] = new TaskE.Vertex();\n            TaskE.Vertex us = vs[in.nextInt() - 1];\n            TaskE.Vertex root = vs[in.nextInt() - 1];\n            dest = new TaskE.Vertex[4 * (n - 1)];\n            next = new int[4 * (n - 1)];\n            int ptr = 0;\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = vs[in.nextInt() - 1];\n                TaskE.Vertex b = vs[in.nextInt() - 1];\n                next[ptr] = a.firstUs;\n                dest[ptr] = b;\n                a.firstUs = ptr++;\n                next[ptr] = b.firstUs;\n                dest[ptr] = a;\n                b.firstUs = ptr++;\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = vs[in.nextInt() - 1];\n                TaskE.Vertex b = vs[in.nextInt() - 1];\n                next[ptr] = a.firstThey;\n                dest[ptr] = b;\n                a.firstThey = ptr++;\n                next[ptr] = b.firstThey;\n                dest[ptr] = a;\n                b.firstThey = ptr++;\n            }\n            root.fillWhenThey(0);\n            us.fillWhenUs(0);\n\n            int res = 0;\n            for (TaskE.Vertex v : vs)\n                if (v.whenUs >= 0) {\n                    boolean golden = false;\n                    int tmp = v.firstUs;\n                    while (tmp >= 0) {\n                        TaskE.Vertex u = dest[tmp];\n                        golden = true;\n                        if (v == u.parentThey) golden = false;\n                        if (u == v.parentThey) golden = false;\n                        if (u.parentThey != null && v == u.parentThey.parentThey) golden = false;\n                        if (v.parentThey != null && u == v.parentThey.parentThey) golden = false;\n                        if (u.parentThey != null && u.parentThey == v.parentThey) golden = false;\n                        if (golden) break;\n                        tmp = next[tmp];\n                    }\n                    if (golden) {\n                        out.println(-1);\n                        return;\n                    } else {\n                        res = Math.max(res, 2 * v.whenThey);\n                    }\n                }\n            out.println(res);\n        }\n\n        static class Vertex {\n            int whenThey = -1;\n            int whenUs = -1;\n            int firstUs = -1;\n            int firstThey = -1;\n            TaskE.Vertex parentThey;\n\n            public void fillWhenThey(int val) {\n                whenThey = val;\n                int tmp = firstThey;\n                while (tmp >= 0) {\n                    TaskE.Vertex v = dest[tmp];\n                    if (v.whenThey < 0) v.fillWhenThey(val + 1);\n                    else parentThey = v;\n                    tmp = next[tmp];\n                }\n            }\n\n            public void fillWhenUs(int val) {\n                if (val >= whenThey) return;\n                whenUs = val;\n                int tmp = firstUs;\n                while (tmp >= 0) {\n                    TaskE.Vertex v = dest[tmp];\n                    if (v.whenUs < 0) v.fillWhenUs(val + 1);\n                    tmp = next[tmp];\n                }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), x = ni()-1, y = ni()-1;\n\t\tint[][] gx = ng(n);\n\t\tint[][] gy = ng(n);\n\t\tint[][] psx = parents3(gx, x);\n\t\tint[][] psy = parents3(gy, y);\n\t\tint[] parx = psx[0], depx = psx[2];\n\t\tint[] pary = psy[0], depy = psy[2];\n\t\tint[][] spary = logstepParents(pary);\n\t\tboolean[] safe = new boolean[n];\n\t\t// Aで距離1, Bで距離3以上なら両端はセーフ\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i != x){\n\t\t\t\tint la = parx[i], lb = i;\n\t\t\t\tint lca = lca2(la, lb, spary, depy);\n\t\t\t\tif((depx[la] < depy[la] || depx[lb] < depy[lb]) && depy[la] + depy[lb] - 2*depy[lca] >= 3){\n\t\t\t\t\tsafe[parx[i]] = true;\n\t\t\t\t\tsafe[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// dA < dBとなっている場所を通っていける場所\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tq.add(x);\n\t\tboolean[] ved = new boolean[n];\n\t\tved[x] = true;\n\t\twhile(!q.isEmpty()){\n\t\t\tint cur = q.poll();\n\t\t\tif(depx[cur] < depy[cur]){\n\t\t\t\tfor(int e : gx[cur]){\n\t\t\t\t\tif(!ved[e] && depx[e] <= depy[e]){\n\t\t\t\t\t\tved[e] = true;\n\t\t\t\t\t\tq.add(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxdy = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ved[i]){\n\t\t\t\tmaxdy = Math.max(maxdy, depy[i]);\n\t\t\t\tif(safe[i]){\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(maxdy*2);\n\t}\n\t\n\tpublic static int lca2(int a, int b, int[][] spar, int[] depth) {\n\t\tif (depth[a] < depth[b]) {\n\t\t\tb = ancestor(b, depth[b] - depth[a], spar);\n\t\t} else if (depth[a] > depth[b]) {\n\t\t\ta = ancestor(a, depth[a] - depth[b], spar);\n\t\t}\n\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tfor(int d = 31-Integer.numberOfLeadingZeros(depth[a]);d >= 0;d--){\n\t\t\tif(spar[d][a] != spar[d][b]){\n\t\t\t\ta = spar[d][a];\n\t\t\t\tb = spar[d][b];\n\t\t\t}\n\t\t}\n\t\treturn spar[0][a];\n\t}\n\n\tprotected static int ancestor(int a, int m, int[][] spar) {\n\t\tfor(;m > 0 && a != -1;m &= m-1)a = spar[Integer.numberOfTrailingZeros(m)][a];\n\t\treturn a;\n\t}\n\n\tpublic static int[][] logstepParents(int[] par) {\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\t\n\tstatic int[][] ng(int n)\n\t{\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\treturn g;\n\t}\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), x = ni()-1, y = ni()-1;\n\t\tint[][] gx = ng(n);\n\t\tint[][] gy = ng(n);\n\t\tint[][] psx = parents3(gx, x);\n\t\tint[][] psy = parents3(gy, y);\n\t\tint[] parx = psx[0], depx = psx[2];\n\t\tint[] pary = psy[0], depy = psy[2];\n\t\tint[][] spary = logstepParents(pary);\n\t\tboolean[] safe = new boolean[n];\n\t\t// Aで距離1, Bで距離3以上なら両端はセーフ\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i != x){\n\t\t\t\tint la = parx[i], lb = i;\n\t\t\t\tint lca = lca2(la, lb, spary, depy);\n\t\t\t\tif((depx[la] < depy[la] || depx[lb] < depy[lb]) && depy[la] + depy[lb] - 2*depy[lca] >= 3){\n\t\t\t\t\tsafe[parx[i]] = true;\n\t\t\t\t\tsafe[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// dA < dBとなっている場所を通っていける場所\n\t\tint[] q = new int[n];\n\t\tint p = 0;\n\t\tq[p++] = x;\n\t\tboolean[] ved = new boolean[n];\n\t\tved[x] = true;\n\t\tfor(int z = 0;z < p;z++){\n\t\t\tint cur = q[z];\n\t\t\tif(depx[cur] < depy[cur]){\n\t\t\t\tfor(int e : gx[cur]){\n\t\t\t\t\tif(!ved[e] && depx[e] <= depy[e]){\n\t\t\t\t\t\tved[e] = true;\n\t\t\t\t\t\tq[p++] = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxdy = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ved[i]){\n\t\t\t\tmaxdy = Math.max(maxdy, depy[i]);\n\t\t\t\tif(safe[i]){\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(maxdy*2);\n\t}\n\t\n\tpublic static int lca2(int a, int b, int[][] spar, int[] depth) {\n\t\tif (depth[a] < depth[b]) {\n\t\t\tb = ancestor(b, depth[b] - depth[a], spar);\n\t\t} else if (depth[a] > depth[b]) {\n\t\t\ta = ancestor(a, depth[a] - depth[b], spar);\n\t\t}\n\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tfor(int d = 31-Integer.numberOfLeadingZeros(depth[a]);d >= 0;d--){\n\t\t\tif(spar[d][a] != spar[d][b]){\n\t\t\t\ta = spar[d][a];\n\t\t\t\tb = spar[d][b];\n\t\t\t}\n\t\t}\n\t\treturn spar[0][a];\n\t}\n\n\tprotected static int ancestor(int a, int m, int[][] spar) {\n\t\tfor(;m > 0 && a != -1;m &= m-1)a = spar[Integer.numberOfTrailingZeros(m)][a];\n\t\treturn a;\n\t}\n\n\tpublic static int[][] logstepParents(int[] par) {\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\t\n\tstatic int[][] ng(int n)\n\t{\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\treturn g;\n\t}\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskE.Vertex[] vs = new TaskE.Vertex[n];\n            for (int i = 0; i < n; ++i) vs[i] = new TaskE.Vertex();\n            TaskE.Vertex us = vs[in.nextInt() - 1];\n            TaskE.Vertex root = vs[in.nextInt() - 1];\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = vs[in.nextInt() - 1];\n                TaskE.Vertex b = vs[in.nextInt() - 1];\n                a.adjUs.add(b);\n                b.adjUs.add(a);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = vs[in.nextInt() - 1];\n                TaskE.Vertex b = vs[in.nextInt() - 1];\n                a.adjThey.add(b);\n                b.adjThey.add(a);\n            }\n            root.fillWhenThey(0);\n            us.fillWhenUs(0);\n\n            int res = 0;\n            for (TaskE.Vertex v : vs)\n                if (v.whenUs >= 0) {\n                    boolean golden = false;\n                    for (TaskE.Vertex u : v.adjUs) {\n                        golden = true;\n                        if (v == u.parentThey) golden = false;\n                        if (u == v.parentThey) golden = false;\n                        if (u.parentThey != null && v == u.parentThey.parentThey) golden = false;\n                        if (v.parentThey != null && u == v.parentThey.parentThey) golden = false;\n                        if (u.parentThey != null && u.parentThey == v.parentThey) golden = false;\n                        if (golden) break;\n                    }\n                    if (golden) {\n                        out.println(-1);\n                        return;\n                    } else {\n                        res = Math.max(res, 2 * v.whenThey);\n                    }\n                }\n            out.println(res);\n        }\n\n        static class Vertex {\n            int whenThey = -1;\n            int whenUs = -1;\n            List<TaskE.Vertex> adjUs = new ArrayList<>(1);\n            List<TaskE.Vertex> adjThey = new ArrayList<>(1);\n            TaskE.Vertex parentThey;\n\n            public void fillWhenThey(int val) {\n                whenThey = val;\n                for (TaskE.Vertex v : adjThey)\n                    if (v.whenThey < 0) v.fillWhenThey(val + 1);\n                    else parentThey = v;\n            }\n\n            public void fillWhenUs(int val) {\n                if (val >= whenThey) return;\n                whenUs = val;\n                for (TaskE.Vertex v : adjUs) if (v.whenUs < 0) v.fillWhenUs(val + 1);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        int inf = (int) 1e8;\n\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int n = in.readInt();\n\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            Node x = nodes[in.readInt()];\n            Node y = nodes[in.readInt()];\n\n            List<Query> querys = new ArrayList<>(n);\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.red.add(b);\n                b.red.add(a);\n                Query q = new Query();\n                q.a = a;\n                q.b = b;\n                querys.add(q);\n                a.lcaQueries.add(q);\n                b.lcaQueries.add(q);\n            }\n\n\n\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.blue.add(b);\n                b.blue.add(a);\n            }\n\n            dfsForDepth(y, null, 0);\n            dfsForLca(y, null);\n\n            for (Query q : querys) {\n                if (q.a.depth + q.b.depth - 2 * q.lca.depth >= 3) {\n                    q.a.escape = q.b.escape = true;\n                }\n            }\n\n            int escape = escape(x, null, 0);\n            if (escape == inf) {\n                out.println(-1);\n            } else {\n                out.println(escape * 2);\n            }\n        }\n\n        public void dfsForLca(Node root, Node fa) {\n            root.lca = root;\n            root.visited = true;\n            for (Node node : root.blue) {\n                if (node == fa) {\n                    continue;\n                }\n                dfsForLca(node, root);\n                Node.merge(node, root);\n                root.find().lca = root;\n            }\n\n            for (Query q : root.lcaQueries) {\n                Node other = q.a == root ? q.b : q.a;\n                if (!other.visited) {\n                    continue;\n                }\n                q.lca = other.find().lca;\n            }\n        }\n\n        public int escape(Node root, Node fa, int depth) {\n            if (root.depth <= depth) {\n                return root.depth;\n            }\n            if (root.escape) {\n                return inf;\n            }\n            int max = root.depth;\n            for (Node node : root.red) {\n                if (node == fa) {\n                    continue;\n                }\n                max = Math.max(max, escape(node, root, depth + 1));\n            }\n            return max;\n        }\n\n        public void dfsForDepth(Node root, Node fa, int depth) {\n            root.depth = depth;\n            for (Node node : root.blue) {\n                if (node == fa) {\n                    continue;\n                }\n                dfsForDepth(node, root, depth + 1);\n            }\n        }\n\n    }\n    static class Query {\n        Node a;\n        Node b;\n        Node lca;\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Node {\n        List<Node> red = new ArrayList<>(2);\n        List<Node> blue = new ArrayList<>(2);\n        List<Query> lcaQueries = new ArrayList<>(2);\n        boolean escape;\n        int depth;\n        int id;\n        boolean visited = false;\n        Node p = this;\n        int rank;\n        Node lca;\n\n        Node find() {\n            return p == p.p ? p : (p = p.find());\n        }\n\n        static void merge(Node a, Node b) {\n            a = a.find();\n            b = b.find();\n            if (a == b) {\n                return;\n            }\n            if (a.rank == b.rank) {\n                a.rank++;\n            }\n            if (a.rank > b.rank) {\n                b.p = a;\n            } else {\n                a.p = b;\n            }\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        int inf = (int) 1e8;\n\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int n = in.readInt();\n\n            Node[] nodes = new Node[n + 1];\n            LCTNode[] lctNodes = new LCTNode[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                lctNodes[i] = new LCTNode();\n                lctNodes[i].pushUp();\n            }\n\n            Node x = nodes[in.readInt()];\n            Node y = nodes[in.readInt()];\n\n            List<Node[]> edges = new ArrayList<>(n);\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.red.add(b);\n                b.red.add(a);\n                edges.add(new Node[] {a, b});\n            }\n\n\n\n            for (int i = 1; i < n; i++) {\n                int aId = in.readInt();\n                int bId = in.readInt();\n\n                Node a = nodes[aId];\n                Node b = nodes[bId];\n                a.blue.add(b);\n                b.blue.add(a);\n\n                LCTNode.join(lctNodes[aId], lctNodes[bId]);\n            }\n\n            dfsForDepth(y, null, 0);\n\n            for (Node[] edge : edges) {\n                LCTNode.findRoute(lctNodes[edge[0].id], lctNodes[edge[1].id]);\n                LCTNode.splay(lctNodes[edge[0].id]);\n                if (lctNodes[edge[0].id].size - 1 >= 3) {\n                    edge[0].escape = edge[1].escape = true;\n                }\n            }\n\n            int escape = escape(x, null, 0);\n            if (escape == inf) {\n                out.println(-1);\n            } else {\n                out.println(escape * 2);\n            }\n        }\n\n        public int escape(Node root, Node fa, int depth) {\n            if (root.depth <= depth) {\n                return root.depth;\n            }\n            if (root.escape) {\n                return inf;\n            }\n            int max = root.depth;\n            for (Node node : root.red) {\n                if (node == fa) {\n                    continue;\n                }\n                max = Math.max(max, escape(node, root, depth + 1));\n            }\n            return max;\n        }\n\n        public void dfsForDepth(Node root, Node fa, int depth) {\n            root.depth = depth;\n            for (Node node : root.blue) {\n                if (node == fa) {\n                    continue;\n                }\n                dfsForDepth(node, root, depth + 1);\n            }\n        }\n\n    }\n    static class Node {\n        List<Node> red = new ArrayList<>(2);\n        List<Node> blue = new ArrayList<>(2);\n        boolean escape;\n        int depth;\n        int id;\n\n    }\n    static class LCTNode {\n        public static final LCTNode NIL = new LCTNode();\n        LCTNode left = NIL;\n        LCTNode right = NIL;\n        LCTNode father = NIL;\n        LCTNode treeFather = NIL;\n        boolean reverse;\n        int id;\n        int size;\n        static {\n            NIL.left = NIL;\n            NIL.right = NIL;\n            NIL.father = NIL;\n            NIL.treeFather = NIL;\n        }\n\n        public static void access(LCTNode x) {\n            LCTNode last = NIL;\n            while (x != NIL) {\n                splay(x);\n                x.right.father = NIL;\n                x.right.treeFather = x;\n                x.setRight(last);\n                x.pushUp();\n\n                last = x;\n                x = x.treeFather;\n            }\n        }\n\n        public static void makeRoot(LCTNode x) {\n            access(x);\n            splay(x);\n            x.reverse();\n        }\n\n        public static void join(LCTNode y, LCTNode x) {\n            makeRoot(x);\n            x.treeFather = y;\n        }\n\n        public static void findRoute(LCTNode x, LCTNode y) {\n            makeRoot(y);\n            access(x);\n        }\n\n        public static void splay(LCTNode x) {\n            if (x == NIL) {\n                return;\n            }\n            LCTNode y, z;\n            while ((y = x.father) != NIL) {\n                if ((z = y.father) == NIL) {\n                    y.pushDown();\n                    x.pushDown();\n                    if (x == y.left) {\n                        zig(x);\n                    } else {\n                        zag(x);\n                    }\n                } else {\n                    z.pushDown();\n                    y.pushDown();\n                    x.pushDown();\n                    if (x == y.left) {\n                        if (y == z.left) {\n                            zig(y);\n                            zig(x);\n                        } else {\n                            zig(x);\n                            zag(x);\n                        }\n                    } else {\n                        if (y == z.left) {\n                            zag(x);\n                            zig(x);\n                        } else {\n                            zag(y);\n                            zag(x);\n                        }\n                    }\n                }\n            }\n\n            x.pushDown();\n            x.pushUp();\n        }\n\n        public static void zig(LCTNode x) {\n            LCTNode y = x.father;\n            LCTNode z = y.father;\n            LCTNode b = x.right;\n\n            y.setLeft(b);\n            x.setRight(y);\n            z.changeChild(y, x);\n\n            y.pushUp();\n        }\n\n        public static void zag(LCTNode x) {\n            LCTNode y = x.father;\n            LCTNode z = y.father;\n            LCTNode b = x.left;\n\n            y.setRight(b);\n            x.setLeft(y);\n            z.changeChild(y, x);\n\n            y.pushUp();\n        }\n\n        public String toString() {\n            return \"\" + id;\n        }\n\n        public void pushDown() {\n            if (reverse) {\n                reverse = false;\n\n                LCTNode tmpNode = left;\n                left = right;\n                right = tmpNode;\n\n                left.reverse();\n                right.reverse();\n            }\n\n            left.treeFather = treeFather;\n            right.treeFather = treeFather;\n        }\n\n        public void reverse() {\n            reverse = !reverse;\n        }\n\n        public void setLeft(LCTNode x) {\n            left = x;\n            x.father = this;\n        }\n\n        public void setRight(LCTNode x) {\n            right = x;\n            x.father = this;\n        }\n\n        public void changeChild(LCTNode y, LCTNode x) {\n            if (left == y) {\n                setLeft(x);\n            } else {\n                setRight(x);\n            }\n        }\n\n        public void pushUp() {\n            if (this == NIL) {\n                return;\n            }\n            size = 1 + left.size + right.size;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\n\n\n\npublic class Main {\n    private static ArrayList<Integer> [] R,B;\n    private static int n,dfs_time,X,Y;\n    private static boolean [] special;\n    private static int [] depth,dfs_in,dfs_out;\n    private static int [] [] parent;\n\n    private static void init(){\n        R = new ArrayList[n+1];\n        B = new ArrayList[n+1];\n        for (int i = 0;i <= n;i++) R[i] = new ArrayList<>();\n        for (int i = 0;i <= n;i++) B[i] = new ArrayList<>();\n        special = new boolean[n + 1];\n        depth = new int[n+1];\n        dfs_in = new int[n+1];\n        dfs_out = new int[n+1];\n        parent = new int[n+1][20];\n        dfs_time = 0;\n    }\n\n\n    private static void dfs(int u,int p) {\n        depth[u] = depth[p] + 1;\n        dfs_in[u] = dfs_time++;\n        parent[u][0] = p;\n        for (int i = 0;i+1 < 20;i++)\n            parent[u][i + 1] = parent[parent[u][i]][i];\n\n        for (int v : B[u])\n            if (v != p)\n                dfs(v,u);\n        dfs_out[u] = dfs_time - 1;\n    }\n\n    private static boolean inSubTree(int a,int b){\n        return dfs_in[b] <= dfs_in[a] && dfs_in[a] <= dfs_out[b];\n    }\n\n    private static int lca(int a,int b){\n        if(depth[a] > depth[b]) {\n            int t = a;\n            a = b;\n            b = t;\n        }\n        if(inSubTree(b,a)) return a;\n        int k = 20-1;\n        while(a != b){\n            if(depth[a] > depth[b]) {\n                int t = a;\n                a = b;\n                b = t;\n            }\n            while(k>0 && inSubTree(a,parent[b][k])) k--;\n            b = parent[b][k];\n        }\n        return a;\n    }\n\n    private static int getDist(int a,int b) {\n        return depth[a] + depth[b] - 2*depth[lca(a,b)];\n    }\n\n    private static int bfs( ) {\n        Queue<Integer> q = new LinkedList<>();\n        q.add(X);\n        boolean [] vis = new boolean[n+1];\n        vis[X] = true;\n        int ret = 0;\n        for (int d = 0;!q.isEmpty();d++) {\n            for (int L = q.size();L > 0;L--) {\n                int u = q.poll();\n                if (getDist(u,Y) <= d) continue;\n                if(special[u]) return -1;\n                ret = Math.max(ret,2*getDist(u,Y));\n                for (int v : R[u])\n                    if (!vis[v]){\n                        vis[v] = true;\n                        q.add(v);\n                    }\n            }\n        }\n        return ret;\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        IO io = new IO(null, null);\n        n = io.getNextInt();\n        init();\n        X = io.getNextInt();\n        Y = io.getNextInt();\n        for (int i = 1;i < n;i++){\n            int a = io.getNextInt(),b = io.getNextInt();\n            R[a].add(b);\n            R[b].add(a);\n        }\n        for (int i = 1;i < n;i++){\n            int a = io.getNextInt(),b = io.getNextInt();\n            B[a].add(b);\n            B[b].add(a);\n        }\n\n        dfs(Y,0);\n        dfs_out[0] = n-1;\n\n        for (int i = 1;i <= n;i++)\n            for (int v : R[i])\n                if (getDist(v,i) >= 3)\n                    special[v] = special[i] = true;\n\n        int res = bfs();\n        io.println(res);\n        io.close();\n    }\n}\n\n\n\n\n\nclass IO{\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter writer;\n    private String inputFile,outputFile;\n\n    public boolean hasMore() throws IOException{\n        if(st != null && st.hasMoreTokens()) return true;\n        if(br != null && br.ready()) return true;\n        return false;\n    }\n    public String getNext() throws FileNotFoundException, IOException{\n        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String getNextLine() throws FileNotFoundException, IOException{\n        return br.readLine().trim();\n    }\n\n    public int getNextInt() throws FileNotFoundException, IOException{\n        return Integer.parseInt(getNext());\n    }\n    public long getNextLong() throws FileNotFoundException, IOException{\n        return Long.parseLong(getNext());\n    }\n\n    public void print(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\" ,x);\n    }\n    public void println(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\\n\" ,x);\n    }\n    public void print(Object o) throws  IOException{\n        writer.print(o.toString());\n    }\n\n    public void println(Object o) throws  IOException{\n        writer.println(o.toString());\n    }\n    public IO(String x,String y) throws FileNotFoundException, IOException{\n        inputFile = x;\n        outputFile = y;\n        if(x != null) br = new BufferedReader(new FileReader(inputFile));\n        else br = new BufferedReader(new InputStreamReader(System.in));\n        if(y != null) writer = new PrintWriter(new BufferedWriter(new FileWriter(outputFile)));\n        else writer = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n\n    protected void close() throws IOException{\n        br.close();\n        writer.close();\n    }\n    public void outputArr(Object [] A) throws IOException{\n        int L = A.length;\n        for (int i = 0;i < L;i++) {\n            if(i > 0) writer.print(\" \");\n            writer.print(A[i]);\n        }\n        writer.print(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), x = ni()-1, y = ni()-1;\n\t\tint[][] gx = ng(n);\n\t\tint[][] gy = ng(n);\n\t\tint[][] psx = parents3(gx, x);\n\t\tint[][] psy = parents3(gy, y);\n\t\tint[] parx = psx[0], depx = psx[2];\n\t\tint[] pary = psy[0], depy = psy[2];\n\t\tint[][] spary = logstepParents(pary);\n\t\tboolean[] safe = new boolean[n];\n\t\t// Aで距離1, Bで距離3以上なら両端はセーフ\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i != x){\n\t\t\t\tint la = parx[i], lb = i;\n\t\t\t\tint lca = lca2(la, lb, spary, depy);\n\t\t\t\tif((depx[la] < depy[la] || depx[lb] < depy[lb]) && depy[la] + depy[lb] - 2*depy[lca] >= 3){\n\t\t\t\t\tsafe[parx[i]] = true;\n\t\t\t\t\tsafe[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// dA < dBとなっている場所を通っていける場所\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tq.add(x);\n\t\tboolean[] ved = new boolean[n];\n\t\tved[x] = true;\n\t\twhile(!q.isEmpty()){\n\t\t\tint cur = q.poll();\n\t\t\tif(depx[cur] < depy[cur]){\n\t\t\t\tfor(int e : gx[cur]){\n\t\t\t\t\tif(!ved[e] && depx[e] <= depy[e]){\n\t\t\t\t\t\tved[e] = true;\n\t\t\t\t\t\tq.add(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxdy = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(ved[i]){\n\t\t\t\tmaxdy = Math.max(maxdy, depy[i]);\n\t\t\t\tif(safe[i]){\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(maxdy*2);\n\t}\n\t\n\tpublic static int lca2(int a, int b, int[][] spar, int[] depth) {\n\t\tif (depth[a] < depth[b]) {\n\t\t\tb = ancestor(b, depth[b] - depth[a], spar);\n\t\t} else if (depth[a] > depth[b]) {\n\t\t\ta = ancestor(a, depth[a] - depth[b], spar);\n\t\t}\n\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tint sa = a, sb = b;\n\t\tfor (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer\n\t\t\t\t.numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {\n\t\t\tif ((low ^ high) >= t) {\n\t\t\t\tif (spar[k][sa] != spar[k][sb]) {\n\t\t\t\t\tlow |= t;\n\t\t\t\t\tsa = spar[k][sa];\n\t\t\t\t\tsb = spar[k][sb];\n\t\t\t\t} else {\n\t\t\t\t\thigh = low | t - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn spar[0][sa];\n\t}\n\n\tprotected static int ancestor(int a, int m, int[][] spar) {\n\t\tfor (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {\n\t\t\tif ((m & 1) == 1)\n\t\t\t\ta = spar[i][a];\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] logstepParents(int[] par) {\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\t\n\tstatic int[][] ng(int n)\n\t{\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\treturn g;\n\t}\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        int inf = (int) 1e8;\n\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int n = in.readInt();\n\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n            }\n\n            Node x = nodes[in.readInt()];\n            Node y = nodes[in.readInt()];\n\n            List<Node[]> edges = new ArrayList<>(n);\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.red.add(b);\n                b.red.add(a);\n                edges.add(new Node[] {a, b});\n            }\n\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.blue.add(b);\n                b.blue.add(a);\n            }\n\n            dfsForDepth(y, null, 0);\n            List<Node> trace = new ArrayList<>(2 * n);\n            flat(y, trace);\n            SparseTable<Node> st = new SparseTable<>(trace.toArray(), trace.size(), (a, b) -> a.dfn - b.dfn);\n\n            for (Node[] edge : edges) {\n                Node lca = st.query(Math.min(edge[0].dfn, edge[1].dfn), Math.max(edge[0].dfn, edge[1].dfn));\n                int dist = edge[0].depth + edge[1].depth - lca.depth * 2;\n                if (dist >= 3) {\n                    edge[0].escape = edge[1].escape = true;\n                }\n            }\n\n            int escape = escape(x, null, 0);\n            if (escape == inf) {\n                out.println(-1);\n            } else {\n                out.println(escape * 2);\n            }\n        }\n\n        public int escape(Node root, Node fa, int depth) {\n            root.red.remove(fa);\n\n            if (root.depth <= depth) {\n                return root.depth;\n            }\n            if (root.escape) {\n                return inf;\n            }\n            int max = root.depth;\n            for (Node node : root.red) {\n                max = Math.max(max, escape(node, root, depth + 1));\n            }\n            return max;\n        }\n\n        public void dfsForDepth(Node root, Node fa, int depth) {\n            root.blue.remove(fa);\n            root.depth = depth;\n            for (Node node : root.blue) {\n                dfsForDepth(node, root, depth + 1);\n            }\n        }\n\n        public void flat(Node root, List<Node> trace) {\n            root.dfn = trace.size();\n            trace.add(root);\n            for (Node node : root.blue) {\n                flat(node, trace);\n                trace.add(root);\n            }\n        }\n\n    }\n    static class SparseTable<T> {\n        Object[][] st;\n        Comparator<T> comparator;\n        int[] floorLogTable;\n\n        public SparseTable(Object[] data, int length, Comparator<T> comparator) {\n            int m = floorLog2(length);\n            st = new Object[m + 1][length];\n            this.comparator = comparator;\n            for (int i = 0; i < length; i++) {\n                st[0][i] = data[i];\n            }\n            for (int i = 0; i < m; i++) {\n                int interval = 1 << i;\n                for (int j = 0; j < length; j++) {\n                    if (j + interval < length) {\n                        st[i + 1][j] = min((T) st[i][j], (T) st[i][j + interval]);\n                    } else {\n                        st[i + 1][j] = st[i][j];\n                    }\n                }\n            }\n\n            floorLogTable = new int[length + 1];\n            int log = 1;\n            for (int i = 0; i <= length; i++) {\n                if ((1 << log) <= i) {\n                    log++;\n                }\n                floorLogTable[i] = log - 1;\n            }\n        }\n\n        public static int floorLog2(int x) {\n            return 31 - Integer.numberOfLeadingZeros(x);\n        }\n\n        private T min(T a, T b) {\n            return comparator.compare(a, b) <= 0 ? a : b;\n        }\n\n        public T query(int left, int right) {\n            int queryLen = right - left + 1;\n            int bit = floorLogTable[queryLen];\n            // x + 2^bit == right + 1\n            // So x should be right + 1 - 2^bit - left=queryLen - 2^bit\n            return min((T) st[bit][left], (T) st[bit][right + 1 - (1 << bit)]);\n        }\n\n    }\n    static class Node {\n        List<Node> red = new ArrayList<>(2);\n        List<Node> blue = new ArrayList<>(2);\n        boolean escape;\n        int depth;\n        int dfn;\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        int inf = (int) 1e8;\n\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int n = in.readInt();\n\n            Node[] nodes = new Node[n + 1];\n            LCTNode[] lctNodes = new LCTNode[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                lctNodes[i] = new LCTNode();\n                lctNodes[i].pushUp();\n            }\n\n            Node x = nodes[in.readInt()];\n            Node y = nodes[in.readInt()];\n\n            List<Node[]> edges = new ArrayList<>(n);\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.red.add(b);\n                b.red.add(a);\n                edges.add(new Node[] {a, b});\n            }\n\n\n\n            for (int i = 1; i < n; i++) {\n                int aId = in.readInt();\n                int bId = in.readInt();\n\n                Node a = nodes[aId];\n                Node b = nodes[bId];\n                a.blue.add(b);\n                b.blue.add(a);\n\n                LCTNode.join(lctNodes[aId], lctNodes[bId]);\n            }\n\n            dfsForDepth(y, null, 0);\n\n            for (Node[] edge : edges) {\n                LCTNode.findRoute(lctNodes[edge[0].id], lctNodes[edge[1].id]);\n                LCTNode.splay(lctNodes[edge[0].id]);\n                if (lctNodes[edge[0].id].size - 1 >= 3) {\n                    edge[0].escape = edge[1].escape = true;\n                }\n            }\n\n            int escape = escape(x, null, 0);\n            if (escape == inf) {\n                out.println(-1);\n            } else {\n                out.println(escape * 2);\n            }\n        }\n\n        public int escape(Node root, Node fa, int depth) {\n            root.red.remove(fa);\n\n            if (root.depth <= depth) {\n                return root.depth;\n            }\n            if (root.escape) {\n                return inf;\n            }\n            int max = root.depth;\n            for (Node node : root.red) {\n                max = Math.max(max, escape(node, root, depth + 1));\n            }\n            return max;\n        }\n\n        public void dfsForDepth(Node root, Node fa, int depth) {\n            root.blue.remove(fa);\n            root.depth = depth;\n            for (Node node : root.blue) {\n                dfsForDepth(node, root, depth + 1);\n            }\n        }\n\n    }\n    static class Node {\n        List<Node> red = new ArrayList<>(2);\n        List<Node> blue = new ArrayList<>(2);\n        boolean escape;\n        int depth;\n        int id;\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class LCTNode {\n        public static final LCTNode NIL = new LCTNode();\n        LCTNode left = NIL;\n        LCTNode right = NIL;\n        LCTNode father = NIL;\n        LCTNode treeFather = NIL;\n        boolean reverse;\n        int id;\n        int size;\n        static {\n            NIL.left = NIL;\n            NIL.right = NIL;\n            NIL.father = NIL;\n            NIL.treeFather = NIL;\n        }\n\n        public static void access(LCTNode x) {\n            LCTNode last = NIL;\n            while (x != NIL) {\n                splay(x);\n                x.right.father = NIL;\n                x.right.treeFather = x;\n                x.setRight(last);\n                x.pushUp();\n\n                last = x;\n                x = x.treeFather;\n            }\n        }\n\n        public static void makeRoot(LCTNode x) {\n            access(x);\n            splay(x);\n            x.reverse();\n        }\n\n        public static void join(LCTNode y, LCTNode x) {\n            makeRoot(x);\n            x.treeFather = y;\n        }\n\n        public static void findRoute(LCTNode x, LCTNode y) {\n            makeRoot(y);\n            access(x);\n        }\n\n        public static void splay(LCTNode x) {\n            if (x == NIL) {\n                return;\n            }\n            LCTNode y, z;\n            while ((y = x.father) != NIL) {\n                if ((z = y.father) == NIL) {\n                    y.pushDown();\n                    x.pushDown();\n                    if (x == y.left) {\n                        zig(x);\n                    } else {\n                        zag(x);\n                    }\n                } else {\n                    z.pushDown();\n                    y.pushDown();\n                    x.pushDown();\n                    if (x == y.left) {\n                        if (y == z.left) {\n                            zig(y);\n                            zig(x);\n                        } else {\n                            zig(x);\n                            zag(x);\n                        }\n                    } else {\n                        if (y == z.left) {\n                            zag(x);\n                            zig(x);\n                        } else {\n                            zag(y);\n                            zag(x);\n                        }\n                    }\n                }\n            }\n\n            x.pushDown();\n            x.pushUp();\n        }\n\n        public static void zig(LCTNode x) {\n            LCTNode y = x.father;\n            LCTNode z = y.father;\n            LCTNode b = x.right;\n\n            y.setLeft(b);\n            x.setRight(y);\n            z.changeChild(y, x);\n\n            y.pushUp();\n        }\n\n        public static void zag(LCTNode x) {\n            LCTNode y = x.father;\n            LCTNode z = y.father;\n            LCTNode b = x.left;\n\n            y.setRight(b);\n            x.setLeft(y);\n            z.changeChild(y, x);\n\n            y.pushUp();\n        }\n\n        public String toString() {\n            return \"\" + id;\n        }\n\n        public void pushDown() {\n            if (reverse) {\n                reverse = false;\n\n                LCTNode tmpNode = left;\n                left = right;\n                right = tmpNode;\n\n                left.reverse();\n                right.reverse();\n            }\n\n            left.treeFather = treeFather;\n            right.treeFather = treeFather;\n        }\n\n        public void reverse() {\n            reverse = !reverse;\n        }\n\n        public void setLeft(LCTNode x) {\n            left = x;\n            x.father = this;\n        }\n\n        public void setRight(LCTNode x) {\n            right = x;\n            x.father = this;\n        }\n\n        public void changeChild(LCTNode y, LCTNode x) {\n            if (left == y) {\n                setLeft(x);\n            } else {\n                setRight(x);\n            }\n        }\n\n        public void pushUp() {\n            if (this == NIL) {\n                return;\n            }\n            size = 1 + left.size + right.size;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\tboolean eof;\n\n\tList<Integer>[] g1, g2;\n\tint n;\n\n\tstatic final int INF = 1_000_000_000;\n\n\tint[][] bfs(List<Integer>[] g, int root) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tint[] par = new int[n];\n\t\tpar[root] = root;\n\t\tint[] q = new int[n];\n\t\tint head = 0, tail = 0;\n\t\tq[tail++] = root;\n\t\tdist[root] = 0;\n\n\t\twhile (head < tail) {\n\t\t\tint v = q[head++];\n\t\t\tfor (int u : g[v]) {\n\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\tpar[u] = v;\n\t\t\t\t\tq[tail++] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new int[][] { dist, par };\n\t}\n\n\tboolean badEdge(int v, int u, int[] par) {\n\t\treturn (par[v] == u || par[u] == v) || // distance 1\n\t\t\t\t(par[par[v]] == u || par[par[u]] == v || par[v] == par[u]); // distance\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// 2\n\t}\n\n\tvoid solve() throws IOException {\n\t\tn = nextInt();\n\t\tint x = nextInt() - 1;\n\t\tint y = nextInt() - 1;\n\n\t\tg1 = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg1[i] = new ArrayList<>();\n\t\t}\n\n\t\tg2 = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg2[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint v = nextInt() - 1;\n\t\t\tint u = nextInt() - 1;\n\t\t\tg1[v].add(u);\n\t\t\tg1[u].add(v);\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint v = nextInt() - 1;\n\t\t\tint u = nextInt() - 1;\n\t\t\tg2[v].add(u);\n\t\t\tg2[u].add(v);\n\t\t}\n\n\t\tint[][] info1 = bfs(g1, x);\n\t\tint[][] info2 = bfs(g2, y);\n\t\t\n//\t\tSystem.err.println(Arrays.toString(info2[1]));\n\n\t\tboolean[] safeNodes = new boolean[n];\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tfor (int u : g1[v]) {\n\t\t\t\tif (u < v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tSystem.err.println(v + \" \" + u + \" \" + badEdge(v, u, info2[1]));\n\t\t\t\t\n\t\t\t\tif (!badEdge(v, u, info2[1])) {\n\t\t\t\t\tsafeNodes[v] = safeNodes[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tint[] q = new int[n];\n\t\tint head = 0, tail = 0;\n\t\tq[tail++] = x;\n\t\tdist[x] = 0;\n\n\t\tint ans = 0;\n\n\t\twhile (head < tail) {\n\t\t\tint v = q[head++];\n\t\t\tif (safeNodes[v]) {\n\t\t\t\tout.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans = Math.max(ans, info2[0][v]);\n\t\t\tfor (int u : g1[v]) {\n\t\t\t\tif (info1[0][u] >= info2[0][u]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\tq[tail++] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(ans * 2);\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e) {\n\t\t\t\teof = true;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\teof = true;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        static TaskE.Vertex[] dest;\n        static int[] next;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskE.Vertex[] vs = new TaskE.Vertex[n];\n            for (int i = 0; i < n; ++i) vs[i] = new TaskE.Vertex();\n            TaskE.Vertex us = vs[in.nextInt() - 1];\n            TaskE.Vertex root = vs[in.nextInt() - 1];\n            dest = new TaskE.Vertex[4 * (n - 1)];\n            next = new int[4 * (n - 1)];\n            int ptr = 0;\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = vs[in.nextInt() - 1];\n                TaskE.Vertex b = vs[in.nextInt() - 1];\n                next[ptr] = a.firstUs;\n                dest[ptr] = b;\n                a.firstUs = ptr++;\n                next[ptr] = b.firstUs;\n                dest[ptr] = a;\n                b.firstUs = ptr++;\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = vs[in.nextInt() - 1];\n                TaskE.Vertex b = vs[in.nextInt() - 1];\n                next[ptr] = a.firstThey;\n                dest[ptr] = b;\n                a.firstThey = ptr++;\n                next[ptr] = b.firstThey;\n                dest[ptr] = a;\n                b.firstThey = ptr++;\n            }\n            root.fillWhenThey(0);\n            us.fillWhenUs(0);\n\n            int res = 0;\n            for (TaskE.Vertex v : vs)\n                if (v.whenUs >= 0) {\n                    boolean golden = false;\n                    int tmp = v.firstUs;\n                    while (tmp >= 0) {\n                        TaskE.Vertex u = dest[tmp];\n                        golden = true;\n                        if (v == u.parentThey) golden = false;\n                        if (u == v.parentThey) golden = false;\n                        if (u.parentThey != null && v == u.parentThey.parentThey) golden = false;\n                        if (v.parentThey != null && u == v.parentThey.parentThey) golden = false;\n                        if (u.parentThey != null && u.parentThey == v.parentThey) golden = false;\n                        if (golden) break;\n                        tmp = next[tmp];\n                    }\n                    if (golden) {\n                        out.println(-1);\n                        return;\n                    } else {\n                        res = Math.max(res, 2 * v.whenThey);\n                    }\n                }\n            out.println(res);\n        }\n\n        static class Vertex {\n            int whenThey = -1;\n            int whenUs = -1;\n            int firstUs = -1;\n            int firstThey = -1;\n            TaskE.Vertex parentThey;\n\n            public void fillWhenThey(int val) {\n                whenThey = val;\n                int tmp = firstThey;\n                while (tmp >= 0) {\n                    TaskE.Vertex v = dest[tmp];\n                    if (v.whenThey < 0) v.fillWhenThey(val + 1);\n                    else parentThey = v;\n                    tmp = next[tmp];\n                }\n            }\n\n            public void fillWhenUs(int val) {\n                if (val >= whenThey) return;\n                whenUs = val;\n                int tmp = firstUs;\n                while (tmp >= 0) {\n                    TaskE.Vertex v = dest[tmp];\n                    if (v.whenUs < 0) v.fillWhenUs(val + 1);\n                    tmp = next[tmp];\n                }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\n\n\n\npublic class Main {\n    private static ArrayList<Integer> [] R,B;\n    private static int n,dfs_time;\n    private static boolean [] special;\n    private static int [] depth,dfs_in,dfs_out;\n    private static int [] [] parent;\n\n    private static void init(){\n        R = new ArrayList[n+1];\n        B = new ArrayList[n+1];\n        for (int i = 0;i <= n;i++) R[i] = new ArrayList<>();\n        for (int i = 0;i <= n;i++) B[i] = new ArrayList<>();\n        special = new boolean[n + 1];\n        depth = new int[n+1];\n        dfs_in = new int[n+1];\n        dfs_out = new int[n+1];\n        int lg = 0;\n        while ((1 << lg) <= n) lg++;\n        parent = new int[n+1][lg + 1];\n    }\n\n\n    private static void dfs(int u,int p) {\n        depth[u] = depth[p] + 1;\n        dfs_in[u] = dfs_time++;\n        parent[u][0] = p;\n        for (int i = 0;i+1 < parent[u].length;i++)\n            parent[u][i + 1] = parent[parent[u][i]][i];\n\n        for (int v : B[u])\n            if (v != p)\n                dfs(v,u);\n        dfs_out[u] = dfs_time - 1;\n    }\n\n    private static boolean inSubTree(int a,int b){\n        return dfs_in[b] <= dfs_in[a] && dfs_in[a] <= dfs_out[b];\n    }\n\n    private static int lca(int a,int b){\n        if(depth[a] > depth[b]) {\n            int t = a;\n            a = b;\n            b = t;\n        }\n        if(inSubTree(b,a)) return a;\n        int k = parent[0].length - 1;\n        while(a != b){\n            if(depth[a] > depth[b]) {\n                int t = a;\n                a = b;\n                b = t;\n            }\n            while(k>0 && inSubTree(a,parent[b][k])) k--;\n            b = parent[b][k];\n        }\n        return a;\n    }\n\n    private static int getDist(int a,int b) {\n        return depth[a] + depth[b] - 2*depth[lca(a,b)];\n    }\n\n    private static int dfs(int u,int p,int d,int Y) {\n        if (getDist(u,Y) <= d) return 0;\n        if(special[u]) return Integer.MAX_VALUE;\n        int ret = 2*getDist(u,Y);\n        for (int v : R[u])\n            if (v != p){\n               int tmp = dfs(v,u,d+1,Y);\n               ret = Math.max(ret,tmp);\n            }\n        return ret;\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        IO io = new IO(\"in.in\", null);\n        n = io.getNextInt();\n        init();\n        int X = io.getNextInt(),Y = io.getNextInt();\n        for (int i = 1;i < n;i++){\n            int a = io.getNextInt(),b = io.getNextInt();\n            R[a].add(b);\n            R[b].add(a);\n        }\n        for (int i = 1;i < n;i++){\n            int a = io.getNextInt(),b = io.getNextInt();\n            B[a].add(b);\n            B[b].add(a);\n        }\n\n        dfs(Y,0);\n        dfs_out[0] = n-1;\n\n        for (int i = 1;i <= n;i++)\n            for (int v : R[i])\n                if (getDist(v,i) >= 3)\n                    special[v] = special[i] = true;\n\n        int res = dfs(X,0,0,Y);\n        if (res == Integer.MAX_VALUE) res = -1;\n        io.println(res);\n        io.close();\n    }\n}\n\n\n\n\n\nclass IO{\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter writer;\n    private String inputFile,outputFile;\n\n    public boolean hasMore() throws IOException{\n        if(st != null && st.hasMoreTokens()) return true;\n        if(br != null && br.ready()) return true;\n        return false;\n    }\n    public String getNext() throws FileNotFoundException, IOException{\n        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public String getNextLine() throws FileNotFoundException, IOException{\n        return br.readLine().trim();\n    }\n\n    public int getNextInt() throws FileNotFoundException, IOException{\n        return Integer.parseInt(getNext());\n    }\n    public long getNextLong() throws FileNotFoundException, IOException{\n        return Long.parseLong(getNext());\n    }\n\n    public void print(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\" ,x);\n    }\n    public void println(double x,int num_digits) throws  IOException{\n        writer.printf(\"%.\" + num_digits + \"f\\n\" ,x);\n    }\n    public void print(Object o) throws  IOException{\n        writer.print(o.toString());\n    }\n\n    public void println(Object o) throws  IOException{\n        writer.println(o.toString());\n    }\n    public IO(String x,String y) throws FileNotFoundException, IOException{\n        inputFile = x;\n        outputFile = y;\n        if(x != null) br = new BufferedReader(new FileReader(inputFile));\n        else br = new BufferedReader(new InputStreamReader(System.in));\n        if(y != null) writer = new PrintWriter(new BufferedWriter(new FileWriter(outputFile)));\n        else writer = new PrintWriter(new OutputStreamWriter(System.out));\n    }\n\n    protected void close() throws IOException{\n        br.close();\n        writer.close();\n    }\n    public void outputArr(Object [] A) throws IOException{\n        int L = A.length;\n        for (int i = 0;i < L;i++) {\n            if(i > 0) writer.print(\" \");\n            writer.print(A[i]);\n        }\n        writer.print(\"\\n\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc005;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final int INF = 100000000;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int A = in.nextInt()-1;\n        int B = in.nextInt()-1;\n        graphA = buildGraph(in, n, n-1);\n        graphB = buildGraph(in, n, n-1);\n        distFromA = bfs(graphA, A);\n        distFromB = bfs(graphB, B);\n        visited = new boolean[n];\n\n        LCA lca = new LCA(graphB);\n        canWin = new boolean[n];\n        for (int i = 0; i < n ; i++) {\n            if (canWin[i]) {\n                continue;\n            }\n            for (int j : graphA[i]) {\n                if (lca.dist(i, j) >= 3) {\n                    canWin[i] = true;\n                    canWin[j] = true;\n                    break;\n                }\n            }\n        }\n\n        dfs(A);\n\n        out.println(best >= INF ? -1 : best);\n        out.flush();\n    }\n\n    static int best = 0;\n    static boolean[] canWin;\n    static boolean[] visited;\n\n    static void dfs(int now) {\n        if (canWin[now]) {\n            best = INF;\n        }\n        visited[now] = true;\n        best = Math.max(best, distFromB[now] * 2);\n        for (int to : graphA[now]) {\n            if (!visited[to] && distFromA[to] < distFromB[to]) {\n                dfs(to);\n            }\n        }\n    }\n\n    public static class LCA {\n        int[][] graph;\n        int[][] parent;\n        int[] depth;\n\n        public LCA(int[][] graph) {\n            int n = graph.length;\n            this.graph = graph;\n            init(n);\n        }\n\n        void dfs(int now, int from, int dep) {\n            parent[0][now] = from;\n            depth[now] = dep;\n            for (int to : graph[now]) {\n                if (to != from) {\n                    dfs(to, now, dep+1);\n                }\n            }\n        }\n\n        void init(int n) {\n            int log = 1;\n            int nn = n;\n            while (nn >= 1) {\n                nn /= 2;\n                log++;\n            }\n            parent = new int[log+1][n];\n            for (int i = 0 ; i <= log ; i++) {\n                Arrays.fill(parent[i], -1);\n            }\n            depth = new int[n];\n\n            dfs(0, -1, 0);\n\n            for (int k = 0 ; k < log ; k++) {\n                for (int v = 0 ; v < n ; v++) {\n                    if (parent[k][v] < 0) {\n                        parent[k+1][v] = -1;\n                    } else {\n                        parent[k+1][v] = parent[k][parent[k][v]];\n                    }\n                }\n            }\n        }\n\n        int lca(int u, int v) {\n            int loglen = parent.length;\n            if (depth[u] > depth[v]) {\n                int tmp = u;\n                u = v;\n                v = tmp;\n            }\n            for (int k = 0 ; k < loglen ; k++) {\n                if (((depth[v] - depth[u]) >> k) % 2 == 1) {\n                    v = parent[k][v];\n                }\n            }\n            if (u == v) {\n                return u;\n            }\n\n            for (int k = loglen-1 ; k >= 0 ; k--) {\n                if (parent[k][u] != parent[k][v]) {\n                    u = parent[k][u];\n                    v = parent[k][v];\n                }\n            }\n            return parent[0][u];\n        }\n\n        int dist(int x, int y) {\n            int l = lca(x, y);\n            return depth[x] + depth[y] - depth[l] * 2;\n        }\n    }\n\n    static int[] bfs(int[][] graph, int s) {\n        int n = graph.length;\n        int[] que = new int[n];\n        int[] d = new int[n];\n        Arrays.fill(d, INF);\n\n\n        int qh = 0;\n        int qt = 0;\n        que[qh++] = s;\n        d[s] = 0;\n        while (qt < qh) {\n            int now = que[qt++];\n            int tt = d[now]+1;\n            for (int to : graph[now]) {\n                if (d[to] > tt) {\n                    d[to] = tt;\n                    que[qh++] = to;\n                }\n            }\n        }\n        return d;\n    }\n\n    static int[] distFromA;\n    static int[] distFromB;\n\n    static int[][] graphA;\n    static int[][] graphB;\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// package agc.agc005;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    private static final int INF = 100000000;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int A = in.nextInt()-1;\n        int B = in.nextInt()-1;\n        graphA = buildGraph(in, n, n-1);\n        graphB = buildGraph(in, n, n-1);\n        distFromB = new int[n];\n        dfs0(B, -1, 0);\n\n        LCA lca = new LCA(graphB);\n\n        canWin = new boolean[n];\n        for (int i = 0; i < n ; i++) {\n            for (int j : graphA[i]) {\n                if (lca.dist(i, j) >= 3) {\n                    canWin[i] = true;\n                }\n            }\n        }\n        dfs(A);\n\n        out.println(best >= INF ? -1 : best);\n        out.flush();\n    }\n\n    static int best = 0;\n    static boolean[] canWin;\n\n    static void dfs(int now) {\n        if (canWin[now]) {\n            best = INF;\n        }\n        best = Math.max(best, distFromB[now] * 2);\n        for (int to : graphA[now]) {\n            if (distFromB[now] < distFromB[to]) {\n                dfs(to);\n            }\n        }\n    }\n\n\n    public static class LCA {\n        int[][] graph;\n        int[][] parent;\n        int[] depth;\n\n        public LCA(int[][] graph) {\n            int n = graph.length;\n            this.graph = graph;\n            init(n);\n        }\n\n        void dfs(int now, int from, int dep) {\n            parent[0][now] = from;\n            depth[now] = dep;\n            for (int to : graph[now]) {\n                if (to != from) {\n                    dfs(to, now, dep+1);\n                }\n            }\n        }\n\n        void init(int n) {\n            int log = 1;\n            int nn = n;\n            while (nn >= 1) {\n                nn /= 2;\n                log++;\n            }\n            parent = new int[log+1][n];\n            for (int i = 0 ; i <= log ; i++) {\n                Arrays.fill(parent[i], -1);\n            }\n            depth = new int[n];\n\n            dfs(0, -1, 0);\n\n            for (int k = 0 ; k < log ; k++) {\n                for (int v = 0 ; v < n ; v++) {\n                    if (parent[k][v] < 0) {\n                        parent[k+1][v] = -1;\n                    } else {\n                        parent[k+1][v] = parent[k][parent[k][v]];\n                    }\n                }\n            }\n        }\n\n        int lca(int u, int v) {\n            int loglen = parent.length;\n            if (depth[u] > depth[v]) {\n                int tmp = u;\n                u = v;\n                v = tmp;\n            }\n            for (int k = 0 ; k < loglen ; k++) {\n                if (((depth[v] - depth[u]) >> k) % 2 == 1) {\n                    v = parent[k][v];\n                }\n            }\n            if (u == v) {\n                return u;\n            }\n\n            for (int k = loglen-1 ; k >= 0 ; k--) {\n                if (parent[k][u] != parent[k][v]) {\n                    u = parent[k][u];\n                    v = parent[k][v];\n                }\n            }\n            return parent[0][u];\n        }\n\n        int dist(int x, int y) {\n            int l = lca(x, y);\n            return depth[x] + depth[y] - depth[l] * 2;\n        }\n    }\n\n    static void dfs0(int now, int par, int d) {\n        distFromB[now] = d;\n        for (int to : graphB[now]) {\n            if (to == par) {\n                continue;\n            }\n            dfs0(to, now, d+1);\n        }\n    }\n\n    static int[] distFromB;\n\n    static int[][] graphA;\n    static int[][] graphB;\n\n    static int[][] buildGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][] graph = new int[n][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            graph[a][--deg[a]] = b;\n            graph[b][--deg[b]] = a;\n        }\n        return graph;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        int inf = (int) 1e8;\n\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int n = in.readInt();\n\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            Node x = nodes[in.readInt()];\n            Node y = nodes[in.readInt()];\n\n            List<Query> querys = new ArrayList<>(n);\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.red.add(b);\n                b.red.add(a);\n                Query q = new Query();\n                q.a = a;\n                q.b = b;\n                querys.add(q);\n                a.lcaQueries.add(q);\n                b.lcaQueries.add(q);\n            }\n\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.blue.add(b);\n                b.blue.add(a);\n            }\n\n            dfsForDepth(y, null, 0);\n            dfsForLca(y, null);\n\n            for (Query q : querys) {\n                if (q.a.depth + q.b.depth - 2 * q.lca.depth >= 3) {\n                    q.a.escape = q.b.escape = true;\n                }\n            }\n\n            int escape = escape(x, null, 0);\n            if (escape == inf) {\n                out.println(-1);\n            } else {\n                out.println(escape * 2);\n            }\n        }\n\n        public void dfsForLca(Node root, Node fa) {\n            root.blue.remove(fa);\n            root.lca = root;\n            root.visited = true;\n            for (Node node : root.blue) {\n                if (node == fa) {\n                    continue;\n                }\n                dfsForLca(node, root);\n                Node.merge(node, root);\n                root.find().lca = root;\n            }\n\n            for (Query q : root.lcaQueries) {\n                Node other = q.a == root ? q.b : q.a;\n                if (!other.visited) {\n                    continue;\n                }\n                q.lca = other.find().lca;\n            }\n        }\n\n        public int escape(Node root, Node fa, int depth) {\n            root.red.remove(fa);\n            if (root.depth <= depth) {\n                return root.depth;\n            }\n            if (root.escape) {\n                return inf;\n            }\n            int max = root.depth;\n            for (Node node : root.red) {\n                max = Math.max(max, escape(node, root, depth + 1));\n            }\n            return max;\n        }\n\n        public void dfsForDepth(Node root, Node fa, int depth) {\n            root.blue.remove(fa);\n            root.depth = depth;\n            for (Node node : root.blue) {\n                dfsForDepth(node, root, depth + 1);\n            }\n        }\n\n    }\n    static class Query {\n        Node a;\n        Node b;\n        Node lca;\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class Node {\n        List<Node> red = new ArrayList<>();\n        List<Node> blue = new ArrayList<>();\n        List<Query> lcaQueries = new ArrayList<>();\n        boolean escape;\n        int depth;\n        int id;\n        boolean visited = false;\n        Node p = this;\n        int rank;\n        Node lca;\n\n        Node find() {\n            return p == p.p ? p : (p = p.find());\n        }\n\n        static void merge(Node a, Node b) {\n            a = a.find();\n            b = b.find();\n            if (a == b) {\n                return;\n            }\n            if (a.rank == b.rank) {\n                a.rank++;\n            }\n            if (a.rank > b.rank) {\n                b.p = a;\n            } else {\n                a.p = b;\n            }\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), A = Reader.Int() - 1, B = Reader.Int() - 1;\n        var E = new List<int>[2][];\n\n        for (int who = 0; who < 2; who++)\n        {\n            E[who] = new List<int>[N];\n            for (int i = 0; i < N; i++)\n                E[who][i] = new List<int>();\n            for (int i = 0; i < N - 1; i++)\n            {\n                int a = Reader.Int() - 1, b = Reader.Int() - 1;\n                E[who][a].Add(b);\n                E[who][b].Add(a);\n            }\n        }\n        var lca = new LowestCommonAncestor(B, E[1]);\n        var seen = new bool[N];\n        var que = new Queue<int>();\n        que.Enqueue(A);\n        int ans = lca.Depth(A) * 2;\n\n        for (int steps = 1; que.Count > 0; steps++)\n        {\n            var nextQue = new Queue<int>();\n            while (que.Count > 0)\n            {\n                int at = que.Dequeue();\n                foreach (int next in E[0][at])\n                    if (!seen[next])\n                    {\n                        if (lca.Dist(at, next) > 2) { Console.WriteLine(-1); return; }\n                        seen[next] = true;\n                        int nextDepth = lca.Depth(next);\n                        if (nextDepth >= steps) ans = Math.Max(ans, nextDepth * 2);\n                        if (nextDepth > steps) nextQue.Enqueue(next);\n                    }\n            }\n            que = nextQue;\n        }\n\n        Console.WriteLine(ans);\n    }\n\n\n    class LowestCommonAncestor\n    {\n        List<int>[] G;\n        RangeMinQueryIndex Rmq;\n        List<int> Vs = new List<int>();\n        List<int> depth = new List<int>();\n        int[] Id, depthAt;\n\n        public LowestCommonAncestor(int root, List<int>[] G)\n        {\n            this.G = G;\n            Init(root);\n        }\n        public int Get(int a, int b)\n        {\n            int L = Math.Min(Id[a], Id[b]);\n            int R = Math.Max(Id[a], Id[b]) + 1;\n            int i = Rmq.Get(L, R);\n            return Vs[i];\n        }\n        public int Depth(int a) { return depthAt[a]; }\n        public int Dist(int a, int b)\n        {\n            return depthAt[a] + depthAt[b] - depthAt[Get(a, b)] * 2;\n        }\n\n        void Init(int root)\n        {\n            Id = new int[G.Length];\n            depthAt = new int[G.Length];\n            DFS(root, -1, 0);\n            Rmq = new RangeMinQueryIndex(depth.Count);\n            for (int i = 0; i < depth.Count; i++)\n                Rmq.Set(i, depth[i]);\n        }\n        void DFS(int v, int prev, int d)\n        {\n            Id[v] = Vs.Count;\n            Vs.Add(v);\n            depth.Add(d);\n            depthAt[v] = d;\n            foreach (int next in G[v])\n                if (next != prev)\n                {\n                    DFS(next, v, d + 1);\n                    Vs.Add(v);\n                    depth.Add(d);\n                }\n        }\n    }\n\n    class RangeMinQueryIndex\n    {\n        private static readonly int INF = (int)1e9;\n        public readonly int N;\n        private readonly int[] tree;\n        private readonly int[] index;\n\n        public RangeMinQueryIndex(int N)\n        {\n            while (N < 2 || (N & (N - 1)) != 0) { N += N & -N; }\n            this.N = N;\n            tree = new int[N * 2];\n            index = new int[N * 2];\n            for (int i = 0; i < tree.Length; i++) tree[i] = INF;\n        }\n        public void Set(int i, int val)\n        {\n            int id = i;\n            i += N - 1;\n            tree[i] = val;\n            index[i] = id;\n            while (i > 0)\n            {\n                i = (i - 1) / 2;\n                int L = i * 2 + 1, R = i * 2 + 2;\n                if (tree[L] <= tree[R]) { tree[i] = tree[L]; index[i] = index[L]; }\n                else { tree[i] = tree[R]; index[i] = index[R]; }\n            }\n        }\n        // [L, R)\n        public int Get(int L, int R) { int v = -1; return Rec(0, ref v, 0, N, L, R); }\n        private int Rec(int i, ref int val, int currL, int currR, int L, int R)\n        {\n            if (currL >= R || currR <= L) { val = INF; return -1; }\n            if (currL >= L && currR <= R) { val = tree[i]; return index[i]; }\n            int mid = (currL + currR) / 2;\n            int Lv = INF, Rv = INF;\n            int Li = Rec(i * 2 + 1, ref Lv, currL, mid, L, R);\n            int Ri = Rec(i * 2 + 2, ref Rv, mid, currR, L, R);\n            if (Lv <= Rv) { val = Lv; return Li; }\n            val = Rv; return Ri;\n        }\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var a = sc.Integer() - 1;\n            var b = sc.Integer() - 1;\n            var F = new int[n - 1];\n            var T = new int[n - 1];\n            for (int i = 0; i < n - 1; i++)\n            {\n                F[i] = sc.Integer() - 1;\n                T[i] = sc.Integer() - 1;\n            }\n            var H = new HLTreeGraph(n);\n            for (int i = 0; i < n - 1; i++)\n                H.AddEdge(sc.Integer() - 1, sc.Integer() - 1);\n            H.Build(b);\n            var G = Enumerate(n, x => new List<int>());\n            var win = new bool[n];\n            for (int i = 0; i < n - 1; i++)\n            {\n                var f = F[i];\n                var t = T[i];\n                var d = H.Query(f, t);\n                if (d >= 3) win[f] = win[t] = true;\n                //else\n                {\n                    G[f].Add(t);\n                    G[t].Add(f);\n                }\n            }\n            var D = Enumerate(n, x => H.Query(b, x) * 2);\n            var E = Enumerate(n, x => 1000000000);\n            E[a] = 0;\n            var q = new Queue<int>();\n            q.Enqueue(a);\n            while (q.Count > 0)\n            {\n                var p = q.Dequeue();\n                if (win[p])\n                {\n                    IO.Printer.Out.WriteLine(-1);\n                    return;\n                }\n                foreach (var to in G[p])\n                {\n                    var d = E[p] + 2;\n                    if (D[to] > d && E[to] > d)\n                    {\n                        E[to] = d;\n                        q.Enqueue(to);\n                    }\n                }\n            }\n            Debug.WriteLine(D.AsJoinedString());\n            Debug.WriteLine(E.AsJoinedString());\n            var max = 0L;\n            for (int i = 0; i < n; i++)\n                if (E[i] < 1000000) max = Math.Max(max, D[i]);\n            IO.Printer.Out.WriteLine(max);\n        }\n\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region Edge\npublic struct Edge\n{\n    public int from, to;\n    public Edge(int f, int t) : this() { from = f; to = t; }\n}\n#endregion\n\n#region Stack<T>\npublic class FastStack<T>\n{\n    T[] data;\n    int ptr;\n    public FastStack(int size) { data = new T[size]; }\n    public void Push(T item) { data[ptr++] = item; }\n    public T Pop() { return data[--ptr]; }\n    public T Peek() { return data[ptr - 1]; }\n    public bool Any() { return ptr != 0; }\n    public T Last { get { return data[ptr - 1]; } set { data[ptr - 1] = value; } }\n    public int Count { get { return ptr; } }\n}\n#endregion\n#region HLTreeGraph\n\npublic class HLTreeGraph\n{\n    /// <summary>\n    /// 縮約前の頂点の数\n    /// </summary>\n    int N;\n    /// <summary>\n    /// 縮約後の頂点の数\n    /// </summary>\n    int M;\n    /// <summary>\n    /// 縮約前のグラフ\n    /// </summary>\n    List<Edge>[] G;\n    /// <summary>\n    /// チェインの集合\n    /// </summary>\n    List<Chain> H = new List<Chain>();\n\n    int[] subTreeSize;\n    int[] par;\n    int[] pos;\n\n    /// <summary>\n    /// 元の木上の深さ\n    /// </summary>\n    public int[] d;\n\n\n    /// <summary>\n    ///uが属するチェイン\n    /// </summary>\n    Chain[] go;\n    public HLTreeGraph(int n)\n    {\n        N = n;\n        G = Enumerate(n, x => new List<Edge>());\n        subTreeSize = new int[n];\n        pos = new int[n];\n        d = new int[n];\n        par = new int[n];\n        go = new Chain[n];\n    }\n    public void AddEdge(int f, int t)\n    {\n        G[f].Add(new Edge(f, t));\n        G[t].Add(new Edge(t, f));\n    }\n    #region impl\n    public void Build(int root)\n    {\n        ComputeSubTreeSize(root);\n        Decomposite(new Edge(-1, root), -1, 0);\n        M = H.Count;\n    }\n    public void ComputeSubTreeSize(int root)\n    {\n        const long X = 1000000000;\n        var stack = new FastStack<long>(N + 1);\n        stack.Push(root * X);\n        par[root] = -1;\n        d[root] = 0;\n\n        while (stack.Any())\n        {\n            var val = stack.Peek();\n            var u = (int)(val / X);\n            var it = (int)(val % X);\n\n            if (it == G[u].Count)\n            {\n                stack.Pop();\n                subTreeSize[u]++;\n                if (par[u] >= 0) subTreeSize[par[u]] += subTreeSize[u];\n            }\n            else\n            {\n                var to = G[u][it].to;\n                stack.Last++;\n                if (to == par[u]) continue;\n\n                par[to] = u;\n                d[to] = d[u] + 1;\n                stack.Push(to * X);\n            }\n        }\n\n    }\n    public void Decomposite(Edge light, int prevId, int lv)\n    {\n        var chain = new Chain() { light = light, id = H.Count, parId = prevId, level = lv };\n        H.Add(chain);\n        var prev = light.from;\n        var cur = light.to;\n        while (cur != prev)\n        {\n            var next = cur;\n            var max = 0;\n            go[cur] = chain;\n            pos[cur] = chain.heavy.Count;\n            foreach (var to in G[cur])\n            {\n                var t = to.to;\n                if (t != prev) max = Math.Max(max, subTreeSize[t]);\n            }\n            foreach (var to in G[cur])\n            {\n                var t = to.to;\n                if (t == prev) continue;\n                if (max == subTreeSize[t])\n                {\n                    //Debug.WriteLine(\"{0}->{1}\", cur, t);\n                    max = 1 << 30;\n                    next = t;\n                    chain.heavy.Add(to);\n                }\n                else Decomposite(to, chain.id, lv + 1);\n            }\n            prev = cur;\n            cur = next;\n        }\n        chain.init(this);\n\n    }\n    #endregion\n\n\n\n    /// <summary>\n    /// (u,v)に関するクエリを処理する\n    /// </summary>\n    public long Query(int u, int v)\n    {\n        long ans = 0;\n        ans += d[u];\n        ans += d[v];\n        while (go[u].id != go[v].id)\n        {\n            if (go[u].level > go[v].level)\n                u = go[u].light.from;\n            else\n                v = go[v].light.from;\n        }\n        if (pos[u] < pos[v])\n            ans += -2 * d[u];\n        else ans += -2 * d[v];\n\n        return ans;\n    }\n\n    static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n\n}\npublic class Chain\n{\n    /// <summary>\n    /// light edge\n    /// </summary>\n    public Edge light;\n    /// <summary>\n    /// heavy edgeの集合\n    /// </summary>\n    public List<Edge> heavy = new List<Edge>();\n    /// <summary>\n    /// 親のチェインの番号\n    /// </summary>\n    public int parId;\n    /// <summary>\n    /// 縮約後の木での深さ\n    /// </summary>\n    public int level;\n    public int id;\n    //public RangeAddFenwickTree seg;\n    public void init(HLTreeGraph G)\n    {\n        //seg = new RangeAddFenwickTree(heavy.Count + 2);\n    }\n    public override string ToString()\n    {\n        var s = new List<int>();\n        s.Add(light.from);\n        s.Add(light.to);\n        foreach (var e in heavy)\n            s.Add(e.to);\n        return string.Join(\"->\", s);\n    }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int(), A = Reader.Int() - 1, B = Reader.Int() - 1;\n        var E = new List<int>[2][];\n\n        for (int who = 0; who < 2; who++)\n        {\n            E[who] = new List<int>[N];\n            for (int i = 0; i < N; i++)\n                E[who][i] = new List<int>();\n            for (int i = 0; i < N - 1; i++)\n            {\n                int a = Reader.Int() - 1, b = Reader.Int() - 1;\n                E[who][a].Add(b);\n                E[who][b].Add(a);\n            }\n        }\n        var lca = new LowestCommonAncestor(B, E[1]);\n        var seen = new bool[N];\n        var que = new Queue<int>();\n        que.Enqueue(A);\n        int ans = 2;\n\n        for (int steps = 0; que.Count > 0; steps++)\n        {\n            int at = que.Dequeue();\n            ans = Math.Max(ans, lca.Depth(at) * 2);\n            foreach (int next in E[0][at])\n            {\n                if (lca.Dist(at, next) > 2) { Console.WriteLine(-1); return; }\n                if (lca.Depth(next) > steps && !seen[next])\n                {\n                    seen[next] = true;\n                    que.Enqueue(next);\n                }\n            }\n        }\n\n        Console.WriteLine(ans);\n    }\n\n\n    class LowestCommonAncestor\n    {\n        List<int>[] G;\n        RangeMinQueryIndex Rmq;\n        List<int> Vs = new List<int>();\n        List<int> depth = new List<int>();\n        int[] Id, depthAt;\n\n        public LowestCommonAncestor(int root, List<int>[] G)\n        {\n            this.G = G;\n            Init(root);\n        }\n        public int Get(int a, int b)\n        {\n            int L = Math.Min(Id[a], Id[b]);\n            int R = Math.Max(Id[a], Id[b]) + 1;\n            int i = Rmq.Get(L, R);\n            return Vs[i];\n        }\n        public int Depth(int a) { return depthAt[a]; }\n        public int Dist(int a, int b)\n        {\n            return Depth(a) + Depth(b) - Depth(Get(a, b)) * 2;\n        }\n\n        void Init(int root)\n        {\n            Id = new int[G.Length];\n            depthAt = new int[G.Length];\n            DFS(root, -1, 0);\n            Rmq = new RangeMinQueryIndex(depth.Count);\n            for (int i = 0; i < depth.Count; i++)\n                Rmq.Set(i, depth[i]);\n        }\n        void DFS(int v, int prev, int d)\n        {\n            Id[v] = Vs.Count;\n            Vs.Add(v);\n            depth.Add(d);\n            depthAt[v] = d;\n            foreach (int next in G[v])\n                if (next != prev)\n                {\n                    DFS(next, v, d + 1);\n                    Vs.Add(v);\n                    depth.Add(d);\n                }\n        }\n    }\n\n    class RangeMinQueryIndex\n    {\n        private static readonly int INF = (int)1e9;\n        public readonly int N;\n        private readonly int[] tree;\n        private readonly int[] index;\n\n        public RangeMinQueryIndex(int N)\n        {\n            while (N < 2 || (N & (N - 1)) != 0) { N += N & -N; }\n            this.N = N;\n            tree = new int[N * 2];\n            index = new int[N * 2];\n            for (int i = 0; i < tree.Length; i++) tree[i] = INF;\n        }\n        public void Set(int i, int val)\n        {\n            int id = i;\n            i += N - 1;\n            tree[i] = val;\n            index[i] = id;\n            while (i > 0)\n            {\n                i = (i - 1) / 2;\n                int L = i * 2 + 1, R = i * 2 + 2;\n                if (tree[L] <= tree[R]) { tree[i] = tree[L]; index[i] = index[L]; }\n                else { tree[i] = tree[R]; index[i] = index[R]; }\n            }\n        }\n        // [L, R)\n        public int Get(int L, int R) { int v = -1; return Rec(0, ref v, 0, N, L, R); }\n        private int Rec(int i, ref int val, int currL, int currR, int L, int R)\n        {\n            if (currL >= R || currR <= L) { val = INF; return -1; }\n            if (currL >= L && currR <= R) { val = tree[i]; return index[i]; }\n            int mid = (currL + currR) / 2;\n            int Lv = INF, Rv = INF;\n            int Li = Rec(i * 2 + 1, ref Lv, currL, mid, L, R);\n            int Ri = Rec(i * 2 + 2, ref Rv, mid, currR, L, R);\n            if (Lv <= Rv) { val = Lv; return Li; }\n            val = Rv; return Ri;\n        }\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var a = sc.Integer() - 1;\n            var b = sc.Integer() - 1;\n            var F = new int[n - 1];\n            var T = new int[n - 1];\n            for (int i = 0; i < n - 1; i++)\n            {\n                F[i] = sc.Integer() - 1;\n                T[i] = sc.Integer() - 1;\n            }\n            var H = new HLTreeGraph(n);\n            for (int i = 0; i < n - 1; i++)\n                H.AddEdge(sc.Integer() - 1, sc.Integer() - 1);\n            H.Build(b);\n            var G = Enumerate(n, x => new List<int>());\n            var win = new bool[n];\n            for (int i = 0; i < n - 1; i++)\n            {\n                var f = F[i];\n                var t = T[i];\n                var d = H.Query(f, t);\n                if (d >= 3) win[f] = win[t] = true;\n                else\n                {\n                    G[f].Add(t);\n                    G[t].Add(f);\n                }\n            }\n            var D = Enumerate(n, x => H.Query(b, x) * 2);\n            var E = Enumerate(n, x => 1000000000);\n            E[a] = -1;\n            var q = new Queue<int>();\n            q.Enqueue(a);\n            while (q.Count > 0)\n            {\n                var p = q.Dequeue();\n                if (win[p])\n                {\n                    IO.Printer.Out.WriteLine(-1);\n                    return;\n                }\n                foreach (var to in G[p])\n                {\n                    var d = E[p] + 2;\n                    if (D[to] > d && E[to] > d)\n                    {\n                        E[to] = d;\n                        q.Enqueue(to);\n                    }\n                }\n            }\n            var max = 0L;\n            for (int i = 0; i < n; i++)\n                if (E[i] < 1000000) max = Math.Max(max, D[i]);\n            IO.Printer.Out.WriteLine(max);\n        }\n\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region Edge\npublic struct Edge\n{\n    public int from, to;\n    public Edge(int f, int t) : this() { from = f; to = t; }\n}\n#endregion\n\n#region Stack<T>\npublic class FastStack<T>\n{\n    T[] data;\n    int ptr;\n    public FastStack(int size) { data = new T[size]; }\n    public void Push(T item) { data[ptr++] = item; }\n    public T Pop() { return data[--ptr]; }\n    public T Peek() { return data[ptr - 1]; }\n    public bool Any() { return ptr != 0; }\n    public T Last { get { return data[ptr - 1]; } set { data[ptr - 1] = value; } }\n    public int Count { get { return ptr; } }\n}\n#endregion\n#region HLTreeGraph\n\npublic class HLTreeGraph\n{\n    /// <summary>\n    /// 縮約前の頂点の数\n    /// </summary>\n    int N;\n    /// <summary>\n    /// 縮約後の頂点の数\n    /// </summary>\n    int M;\n    /// <summary>\n    /// 縮約前のグラフ\n    /// </summary>\n    List<Edge>[] G;\n    /// <summary>\n    /// チェインの集合\n    /// </summary>\n    List<Chain> H = new List<Chain>();\n\n    int[] subTreeSize;\n    int[] par;\n    int[] pos;\n\n    /// <summary>\n    /// 元の木上の深さ\n    /// </summary>\n    public int[] d;\n\n\n    /// <summary>\n    ///uが属するチェイン\n    /// </summary>\n    Chain[] go;\n    public HLTreeGraph(int n)\n    {\n        N = n;\n        G = Enumerate(n, x => new List<Edge>());\n        subTreeSize = new int[n];\n        pos = new int[n];\n        d = new int[n];\n        par = new int[n];\n        go = new Chain[n];\n    }\n    public void AddEdge(int f, int t)\n    {\n        G[f].Add(new Edge(f, t));\n        G[t].Add(new Edge(t, f));\n    }\n    #region impl\n    public void Build(int root)\n    {\n        ComputeSubTreeSize(root);\n        Decomposite(new Edge(-1, root), -1, 0);\n        M = H.Count;\n    }\n    public void ComputeSubTreeSize(int root)\n    {\n        const long X = 1000000000;\n        var stack = new FastStack<long>(N + 1);\n        stack.Push(root * X);\n        par[root] = -1;\n        d[root] = 0;\n\n        while (stack.Any())\n        {\n            var val = stack.Peek();\n            var u = (int)(val / X);\n            var it = (int)(val % X);\n\n            if (it == G[u].Count)\n            {\n                stack.Pop();\n                subTreeSize[u]++;\n                if (par[u] >= 0) subTreeSize[par[u]] += subTreeSize[u];\n            }\n            else\n            {\n                var to = G[u][it].to;\n                stack.Last++;\n                if (to == par[u]) continue;\n\n                par[to] = u;\n                d[to] = d[u] + 1;\n                stack.Push(to * X);\n            }\n        }\n\n    }\n    public void Decomposite(Edge light, int prevId, int lv)\n    {\n        var chain = new Chain() { light = light, id = H.Count, parId = prevId, level = lv };\n        H.Add(chain);\n        var prev = light.from;\n        var cur = light.to;\n        while (cur != prev)\n        {\n            var next = cur;\n            var max = 0;\n            go[cur] = chain;\n            pos[cur] = chain.heavy.Count;\n            foreach (var to in G[cur])\n            {\n                var t = to.to;\n                if (t != prev) max = Math.Max(max, subTreeSize[t]);\n            }\n            foreach (var to in G[cur])\n            {\n                var t = to.to;\n                if (t == prev) continue;\n                if (max == subTreeSize[t])\n                {\n                    //Debug.WriteLine(\"{0}->{1}\", cur, t);\n                    max = 1 << 30;\n                    next = t;\n                    chain.heavy.Add(to);\n                }\n                else Decomposite(to, chain.id, lv + 1);\n            }\n            prev = cur;\n            cur = next;\n        }\n        chain.init(this);\n\n    }\n    #endregion\n\n\n\n    /// <summary>\n    /// (u,v)に関するクエリを処理する\n    /// </summary>\n    public long Query(int u, int v)\n    {\n        long ans = 0;\n        ans += d[u];\n        ans += d[v];\n        while (go[u].id != go[v].id)\n        {\n            if (go[u].level > go[v].level)\n                u = go[u].light.from;\n            else\n                v = go[v].light.from;\n        }\n        if (pos[u] < pos[v])\n            ans += -2 * d[u];\n        else ans += -2 * d[v];\n\n        return ans;\n    }\n\n    static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n\n}\npublic class Chain\n{\n    /// <summary>\n    /// light edge\n    /// </summary>\n    public Edge light;\n    /// <summary>\n    /// heavy edgeの集合\n    /// </summary>\n    public List<Edge> heavy = new List<Edge>();\n    /// <summary>\n    /// 親のチェインの番号\n    /// </summary>\n    public int parId;\n    /// <summary>\n    /// 縮約後の木での深さ\n    /// </summary>\n    public int level;\n    public int id;\n    //public RangeAddFenwickTree seg;\n    public void init(HLTreeGraph G)\n    {\n        //seg = new RangeAddFenwickTree(heavy.Count + 2);\n    }\n    public override string ToString()\n    {\n        var s = new List<int>();\n        s.Add(light.from);\n        s.Add(light.to);\n        foreach (var e in heavy)\n            s.Add(e.to);\n        return string.Join(\"->\", s);\n    }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    List<int>[] G;\n    int[] depth;\n    int[] parent;\n    bool[] b;\n    int ans;\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N,X;\n        {\n            string[] str = Console.ReadLine().Split(' ');\n            N = int.Parse(str[0]);\n            X = int.Parse(str[1])-1;\n            int Y = int.Parse(str[2])-1;\n            G = new List<int>[N];\n            for(int i=0;i<N;i++){\n                G[i] = new List<int>();\n            }\n            for(int i=0;i<N-1;i++){\n                str = Console.ReadLine().Split(' ');\n                int a = int.Parse(str[0])-1;\n                int b = int.Parse(str[1])-1;\n                G[a].Add(b);\n                G[b].Add(a);\n            }\n            List<int>[] T = new List<int>[N];\n            for(int i=0;i<N;i++){\n                T[i] = new List<int>();\n            }\n            for(int i=0;i<N-1;i++){\n                str = Console.ReadLine().Split(' ');\n                int a = int.Parse(str[0])-1;\n                int b = int.Parse(str[1])-1;\n                T[a].Add(b);\n                T[b].Add(a);\n            }\n            Tree Tr = new Tree(T);\n            depth = Tr.GetDepth(Y);\n            parent = Tr.GetParent(Y);\n        }\n        b = new bool[N];\n        ans = 0;\n        dfs(X,0);\n        if(ans != -1){\n            ans *= 2;\n        }\n        sb.Append(ans+\"\\n\");\n    }\n    void dfs(int v,int d){\n        b[v] = true;\n        if(depth[v] < d){\n            return;\n        }\n        if(ans != -1 && ans < depth[v]){\n            ans = depth[v];\n        }\n        if(depth[v] > d){\n            if(check(v)){\n                ans = -1;\n                return;\n            }\n            for(int i=0;i<G[v].Count;i++){\n                int t = G[v][i];\n                if(!b[t]){\n                    dfs(t,d+1);\n                }\n            }\n        }\n    }\n    bool check(int v){\n        for(int i=0;i<G[v].Count;i++){\n            int t = G[v][i];\n            if(parent[v] == parent[t] || (parent[v] != -1 && parent[parent[v]] == t) || (parent[t] != -1 && parent[parent[t]] == v) || parent[t] == v || parent[v] == t){\n                ;         \n            }\n            else{\n                return true;\n            }\n        }\n        return false;\n    }\n}\npublic class Tree{\n    List<int>[] T;\n    bool[] b;\n    int N;\n    int temp1;\n    int temp2;\n    int[] depth;\n    int[] parent;\n    public int center1;\n    public int center2;\n    public int diamater;\n    public Tree(List<int>[] G){\n        T = G;\n        N = G.Length;\n    } \n    void calcLongestPath(int v){\n        b = new bool[N];\n        temp1 = 0;\n        temp2 = 0;\n        dfs1(v,0);\n    }\n    public int LongestPathDistance(int v){\n        calcLongestPath(v);\n        return temp1;\n    }\n    public int LongestPath(int v){\n        calcLongestPath(v);\n        return temp2;\n    }\n    public void Diamater(){\n        int x1 = LongestPath(0);\n        int x2 = LongestPath(x1);\n        diamater = temp1;\n    }\n    public void Center(){\n        int x1 = LongestPath(0);\n        int x2 = LongestPath(x1);\n        diamater = temp1;\n        if(diamater % 2 == 0){\n            center1 = Search(x1,x2,diamater/2);\n            center2 = -1;\n        }\n        else{\n            center1 = Search(x1,x2,diamater/2);\n            center2 = Search(x1,x2,diamater/2+1);\n        }\n    }\n    public int Search(int s,int t,int l){\n        b = new bool[N];\n        dfs2(s,t,0,l);\n        return temp1;\n    }\n    public int[] GetDepth(int p){\n        b = new bool[N];\n        depth = new int[N];\n        dfs3(p,0);\n        return depth;\n    }\n    public int[] GetParent(int p){\n        b = new bool[N];\n        parent = new int[N];\n        dfs4(p,-1);\n        return parent;\n    }\n    void dfs1(int v,int l){\n        b[v] = true;\n        for(int i=0;i<T[v].Count;i++){\n            int t = T[v][i];\n            if(!b[t]){\n                dfs1(t,l+1);\n            }\n        }\n        if(l >= temp1){\n            temp1 = l;\n            temp2 = v;\n        }\n    }\n    bool dfs2(int v,int o,int l,int d){\n        b[v] = true;\n        bool x = v == o;\n        for(int i=0;i<T[v].Count;i++){\n            int t = T[v][i];\n            if(!b[t]){\n                x |= dfs2(t,o,l+1,d);\n            }\n        }\n        if(x && l == d){\n            temp1 = v;\n        }\n        return x;\n    }\n    void dfs3(int v,int d){\n        b[v] = true;\n        depth[v] = d;\n        for(int i=0;i<T[v].Count;i++){\n            int t = T[v][i];\n            if(!b[t]){\n                dfs3(t,d+1);\n            }\n        }\n    }\n    void dfs4(int v,int p){\n        b[v] = true;\n        parent[v] = p;\n        for(int i=0;i<T[v].Count;i++){\n            int t = T[v][i];\n            if(!b[t]){\n                dfs4(t,v);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = NextInt(), A = NextInt() - 1, B = NextInt() - 1;\n        var E = new List<int>[2][];\n\n        for (int who = 0; who < 2; who++)\n        {\n            E[who] = new List<int>[N];\n            for (int i = 0; i < N; i++)\n                E[who][i] = new List<int>();\n            for (int i = 0; i < N - 1; i++)\n            {\n                int a = NextInt() - 1, b = NextInt() - 1;\n                E[who][a].Add(b);\n                E[who][b].Add(a);\n            }\n        }\n        var lca = new LowestCommonAncestor(B, E[1]);\n        var seen = new bool[N];\n        var que = new Queue<int>();\n        que.Enqueue(A);\n        int ans = lca.Depth(A) * 2;\n\n        for (int steps = 1; que.Count > 0; steps++)\n        {\n            var nextQue = new Queue<int>();\n            while (que.Count > 0)\n            {\n                int at = que.Dequeue();\n                foreach (int next in E[0][at])\n                    if (!seen[next])\n                    {\n                        if (lca.Dist(at, next) > 2) { Console.WriteLine(-1); return; }\n                        seen[next] = true;\n                        int nextDepth = lca.Depth(next);\n                        if (nextDepth >= steps) ans = Math.Max(ans, nextDepth * 2);\n                        if (nextDepth > steps) nextQue.Enqueue(next);\n                    }\n            }\n            que = nextQue;\n        }\n\n        Console.WriteLine(ans);\n    }\n\n    TextReader _reader = Console.In;\n    int NextInt()\n    {\n        int c;\n        while ((c = _reader.Read()) < '0' || c > '9') { }\n        int res = c - '0';\n        while ((c = _reader.Read()) >= '0' && c <= '9') res = res * 10 + c - '0';\n        return res;\n    }\n\n    class LowestCommonAncestor\n    {\n        List<int>[] G;\n        RangeMinQueryIndex Rmq;\n        List<int> Vs = new List<int>();\n        List<int> depth = new List<int>();\n        int[] Id, depthAt;\n\n        public LowestCommonAncestor(int root, List<int>[] G)\n        {\n            this.G = G;\n            Init(root);\n        }\n        public int Get(int a, int b)\n        {\n            int L = Math.Min(Id[a], Id[b]);\n            int R = Math.Max(Id[a], Id[b]) + 1;\n            int i = Rmq.Get(L, R);\n            return Vs[i];\n        }\n        public int Depth(int a) { return depthAt[a]; }\n        public int Dist(int a, int b)\n        {\n            return depthAt[a] + depthAt[b] - depthAt[Get(a, b)] * 2;\n        }\n\n        void Init(int root)\n        {\n            Id = new int[G.Length];\n            depthAt = new int[G.Length];\n            DFS(root, -1, 0);\n            Rmq = new RangeMinQueryIndex(depth.Count);\n            for (int i = 0; i < depth.Count; i++)\n                Rmq.Set(i, depth[i]);\n        }\n        void DFS(int v, int prev, int d)\n        {\n            Id[v] = Vs.Count;\n            Vs.Add(v);\n            depth.Add(d);\n            depthAt[v] = d;\n            foreach (int next in G[v])\n                if (next != prev)\n                {\n                    DFS(next, v, d + 1);\n                    Vs.Add(v);\n                    depth.Add(d);\n                }\n        }\n    }\n\n    class RangeMinQueryIndex\n    {\n        private static readonly int INF = (int)1e9;\n        public readonly int N;\n        private readonly int[] tree;\n        private readonly int[] index;\n\n        public RangeMinQueryIndex(int N)\n        {\n            while (N < 2 || (N & (N - 1)) != 0) { N += N & -N; }\n            this.N = N;\n            tree = new int[N * 2];\n            index = new int[N * 2];\n            for (int i = 0; i < tree.Length; i++) tree[i] = INF;\n        }\n        public void Set(int i, int val)\n        {\n            int id = i;\n            i += N - 1;\n            tree[i] = val;\n            index[i] = id;\n            while (i > 0)\n            {\n                i = (i - 1) / 2;\n                int L = i * 2 + 1, R = i * 2 + 2;\n                if (tree[L] <= tree[R]) { tree[i] = tree[L]; index[i] = index[L]; }\n                else { tree[i] = tree[R]; index[i] = index[R]; }\n            }\n        }\n        // [L, R)\n        public int Get(int L, int R) { int v = -1; return Rec(0, ref v, 0, N, L, R); }\n        private int Rec(int i, ref int val, int currL, int currR, int L, int R)\n        {\n            if (currL >= R || currR <= L) { val = INF; return -1; }\n            if (currL >= L && currR <= R) { val = tree[i]; return index[i]; }\n            int mid = (currL + currR) / 2;\n            int Lv = INF, Rv = INF;\n            int Li = Rec(i * 2 + 1, ref Lv, currL, mid, L, R);\n            int Ri = Rec(i * 2 + 2, ref Rv, mid, currR, L, R);\n            if (Lv <= Rv) { val = Lv; return Li; }\n            val = Rv; return Ri;\n        }\n    }\n\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7 # 998244353\ninput=lambda:sys.stdin.readline().rstrip()\ndef resolve():\n    n,x,y=map(int,input().split())\n    x-=1; y-=1\n    E1=[[] for _ in range(n)]\n    E2=[[] for _ in range(n)]\n    for _ in range(n-1):\n        u,v=map(int,input().split())\n        u-=1; v-=1\n        E1[u].append(v)\n        E1[v].append(u)\n    for _ in range(n-1):\n        u,v=map(int,input().split())\n        u-=1; v-=1\n        E2[u].append(v)\n        E2[v].append(u)\n\n    # E2 において、y-rooted tree とみて、depth,par を計算\n    par=[None]*n # x の必勝頂点を判定するのに必要\n    par[y]=y\n    depth2=[None]*n\n    depth2[y]=0\n    Q=[y]\n    while(Q):\n        v=Q.pop()\n        for nv in E2[v]:\n            if(depth2[nv] is not None): continue\n            depth2[nv]=depth2[v]+1\n            par[nv]=v\n            Q.append(nv)\n\n    # E1の辺で、E2での距離が 3 以上のものは必勝\n    win=[0]*n\n    for v in range(n):\n        for nv in E1[v]:\n            if(par[v]==nv or par[nv]==v or par[v]==par[nv] or par[par[v]]==nv or par[par[nv]]==v): continue\n            win[nv]=win[v]=1\n\n    # E1 において、x-rooted tree とみて探索\n    # depth1 < depth2 -> 以降も探索できる\n    # depth1 = depth2 -> そこで捕まる\n    ans=depth2[x]\n    depth1=[None]*n\n    depth1[x]=0\n    Q=[x]\n    while(Q):\n        v=Q.pop()\n        if(win[v]): # 探索できる状態 & 必勝頂点にいれば勝ち\n            print(-1)\n            return\n        for nv in E1[v]:\n            if(depth1[nv] is not None): continue\n            depth1[nv]=depth1[v]+1\n            ans=max(ans,depth2[nv])\n            if(depth1[nv]<depth2[nv]): Q.append(nv)\n\n    print(2*ans)\nresolve()"
  }
]