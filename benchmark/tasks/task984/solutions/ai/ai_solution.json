[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 200005\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* redGraph[MAX_N];\nNode* blueGraph[MAX_N];\nbool visited[MAX_N];\n\nvoid addEdge(Node** graph, int u, int v) {\n    Node* newNode = malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = graph[u];\n    graph[u] = newNode;\n}\n\nint dfs(int sigma, int sugim, bool isRedTurn) {\n    if (sigma == sugim) return 0;\n    \n    visited[sigma] = true;\n    visited[sugim] = true;\n    \n    if (isRedTurn) {\n        for (Node* curr = redGraph[sigma]; curr != NULL; curr = curr->next) {\n            if (!visited[curr->vertex]) {\n                for (Node* sugiNext = blueGraph[sugim]; sugiNext != NULL; sugiNext = sugiNext->next) {\n                    if (!visited[sugiNext->vertex]) {\n                        int result = dfs(curr->vertex, sugiNext->vertex, false);\n                        if (result != -1) return result + 1;\n                    }\n                }\n            }\n        }\n    } else {\n        for (Node* curr = blueGraph[sugim]; curr != NULL; curr = curr->next) {\n            if (!visited[curr->vertex]) {\n                for (Node* sigmaNext = redGraph[sigma]; sigmaNext != NULL; sigmaNext = sigmaNext->next) {\n                    if (!visited[sigmaNext->vertex]) {\n                        int result = dfs(sigmaNext->vertex, curr->vertex, true);\n                        if (result != -1) return result + 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int N, X, Y;\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    \n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(redGraph, u, v);\n        addEdge(redGraph, v, u);\n    }\n    \n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(blueGraph, u, v);\n        addEdge(blueGraph, v, u);\n    }\n    \n    memset(visited, 0, sizeof(visited));\n    int turns = dfs(X, Y, true);\n    \n    if (turns == -1) {\n        printf(\"Impossible\\n\");\n    } else {\n        printf(\"%d\\n\", turns);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* red_adj[MAX_N + 1];\nNode* blue_adj[MAX_N + 1];\nint sigma_dist[MAX_N + 1];\nint sugim_dist[MAX_N + 1];\nint queue[MAX_N];\nint front, rear;\n\nvoid add_edge(Node* adj[], int u, int v) {\n    Node* new_node = (Node*)malloc(sizeof(Node));\n    new_node->vertex = v;\n    new_node->next = adj[u];\n    adj[u] = new_node;\n}\n\nvoid bfs(Node* adj[], int start, int dist[]) {\n    memset(dist, -1, (MAX_N + 1) * sizeof(int));\n    front = rear = 0;\n    queue[rear++] = start;\n    dist[start] = 0;\n    while (front < rear) {\n        int u = queue[front++];\n        for (Node* node = adj[u]; node != NULL; node = node->next) {\n            int v = node->vertex;\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n}\n\nint main() {\n    int N, X, Y;\n    scanf(\"%d %d %d\", &N, &X, &Y);\n    \n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(red_adj, u, v);\n        add_edge(red_adj, v, u);\n    }\n    \n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(blue_adj, u, v);\n        add_edge(blue_adj, v, u);\n    }\n    \n    bfs(red_adj, X, sigma_dist);\n    bfs(blue_adj, Y, sugim_dist);\n    \n    int min_turns = -1;\n    for (int i = 1; i <= N; i++) {\n        if (sigma_dist[i] == sugim_dist[i] && sigma_dist[i] != -1) {\n            if (min_turns == -1 || sigma_dist[i] < min_turns) {\n                min_turns = sigma_dist[i];\n            }\n        }\n    }\n    \n    if (min_turns != -1) {\n        printf(\"%d\\n\", min_turns);\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> red_adj[MAXN], blue_adj[MAXN];\nint dist_sigma[MAXN], dist_sugim[MAXN];\n\nvoid bfs(int start, vector<int> adj[], int dist[]) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n}\n\nint main() {\n    int N, X, Y;\n    cin >> N >> X >> Y;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        red_adj[u].push_back(v);\n        red_adj[v].push_back(u);\n    }\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        blue_adj[u].push_back(v);\n        blue_adj[v].push_back(u);\n    }\n\n    memset(dist_sigma, -1, sizeof(dist_sigma));\n    memset(dist_sugim, -1, sizeof(dist_sugim));\n\n    bfs(X, red_adj, dist_sigma);\n    bfs(Y, blue_adj, dist_sugim);\n\n    int min_turns = -1;\n    for (int u = 1; u <= N; ++u) {\n        if (dist_sigma[u] != -1 && dist_sugim[u] != -1) {\n            if (dist_sigma[u] == dist_sugim[u]) {\n                min_turns = dist_sigma[u];\n                break;\n            }\n        }\n    }\n\n    cout << min_turns << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GameOnGraph {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int X = scanner.nextInt();\n        int Y = scanner.nextInt();\n\n        List<List<Integer>> redAdj = new ArrayList<>();\n        List<List<Integer>> blueAdj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            redAdj.add(new ArrayList<>());\n            blueAdj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            redAdj.get(u).add(v);\n            redAdj.get(v).add(u);\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            blueAdj.get(u).add(v);\n            blueAdj.get(v).add(u);\n        }\n\n        int[] sigmaDist = new int[N + 1];\n        Arrays.fill(sigmaDist, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(X);\n        sigmaDist[X] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : redAdj.get(u)) {\n                if (sigmaDist[v] == -1) {\n                    sigmaDist[v] = sigmaDist[u] + 1;\n                    queue.add(v);\n                }\n            }\n        }\n\n        int[] sugimDist = new int[N + 1];\n        Arrays.fill(sugimDist, -1);\n        queue = new LinkedList<>();\n        queue.add(Y);\n        sugimDist[Y] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : blueAdj.get(u)) {\n                if (sugimDist[v] == -1) {\n                    sugimDist[v] = sugimDist[u] + 1;\n                    queue.add(v);\n                }\n            }\n        }\n\n        int minTurns = Integer.MAX_VALUE;\n        for (int i = 1; i <= N; i++) {\n            if (sigmaDist[i] != -1 && sugimDist[i] != -1) {\n                if (sigmaDist[i] == sugimDist[i]) {\n                    minTurns = Math.min(minTurns, sigmaDist[i]);\n                }\n            }\n        }\n\n        if (minTurns != Integer.MAX_VALUE) {\n            System.out.println(minTurns);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:35:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SigmaSugimGraph {\n    static class Edge {\n        int to;\n        char color;\n        \n        Edge(int to, char color) {\n            this.to = to;\n            this.color = color;\n        }\n    }\n    \n    static List<List<Edge>> graph;\n    static int N, X, Y;\n    \n    public static int[] solve(int n, int x, int y, int[][] redEdges, int[][] blueEdges) {\n        graph = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : redEdges) {\n            graph.get(edge[0]).add(new Edge(edge[1], 'R'));\n            graph.get(edge[1]).add(new Edge(edge[0], 'R'));\n        }\n        \n        for (int[] edge : blueEdges) {\n            graph.get(edge[0]).add(new Edge(edge[1], 'B'));\n            graph.get(edge[1]).add(new Edge(edge[0], 'B'));\n        }\n        \n        N = n;\n        X = x;\n        Y = y;\n        \n        int[][] distances = new int[2][n + 1];\n        char[] colors = {'R', 'B'};\n        \n        for (int i = 0; i < 2; i++) {\n            bfs(colors[i], distances[i]);\n        }\n        \n        int minTurns = Integer.MAX_VALUE;\n        for (int v = 1; v <= n; v++) {\n            if (distances[0][v] != -1 && distances[1][v] != -1) {\n                minTurns = Math.min(minTurns, distances[0][v] + distances[1][v]);\n            }\n        }\n        \n        return minTurns == Integer.MAX_VALUE ? \n            new int[]{0, -1} : \n            new int[]{1, minTurns};\n    }\n    \n    static void bfs(char color, int[] distances) {\n        Arrays.fill(distances, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        \n        int start = color == 'R' ? X : Y;\n        queue.offer(start);\n        distances[start] = 0;\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            \n            for (Edge edge : graph.get(current)) {\n                if (edge.color == color && distances[edge.to] == -1) {\n                    distances[edge.to] = distances[current] + 1;\n                    queue.offer(edge.to);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:35:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> red_graph[MAXN];\nvector<int> blue_graph[MAXN];\nint n, x, y;\n\nbool can_meet(int start_x, int start_y) {\n    vector<bool> visited_red(n+1, false);\n    vector<bool> visited_blue(n+1, false);\n    queue<pair<int,int>> q;\n    q.push({start_x, start_y});\n    visited_red[start_x] = true;\n    visited_blue[start_y] = true;\n    int turns = 0;\n\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; i++) {\n            auto [curr_x, curr_y] = q.front();\n            q.pop();\n\n            if (curr_x == curr_y) return turns;\n\n            // Sigma's move (red edges)\n            for (int next_x : red_graph[curr_x]) {\n                if (!visited_red[next_x]) {\n                    // Sugim's move (blue edges)\n                    for (int next_y : blue_graph[curr_y]) {\n                        if (!visited_blue[next_y]) {\n                            q.push({next_x, next_y});\n                            visited_red[next_x] = true;\n                            visited_blue[next_y] = true;\n                        }\n                    }\n                }\n            }\n        }\n        turns++;\n    }\n\n    return -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> n >> x >> y;\n\n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        cin >> u >> v;\n        red_graph[u].push_back(v);\n        red_graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < n-1; i++) {\n        int u, v;\n        cin >> u >> v;\n        blue_graph[u].push_back(v);\n        blue_graph[v].push_back(u);\n    }\n\n    int result = can_meet(x, y);\n    if (result == -1) {\n        cout << \"IMPOSSIBLE\" << endl;\n    } else {\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:35:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef sigma_sugim_game(N, red_edges, blue_edges, X, Y):\n    def bfs(start, graph):\n        queue = deque([(start, 0)])\n        distances = [-1] * N\n        distances[start] = 0\n        \n        while queue:\n            node, dist = queue.popleft()\n            for neighbor in graph[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = dist + 1\n                    queue.append((neighbor, dist + 1))\n        return distances\n    \n    # Create adjacency lists for both trees\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n    \n    for u, v in red_edges:\n        red_graph[u].append(v)\n        red_graph[v].append(u)\n    \n    for u, v in blue_edges:\n        blue_graph[u].append(v)\n        blue_graph[v].append(u)\n    \n    # Calculate distances from X in red tree and Y in blue tree\n    sigma_distances = bfs(X, red_graph)\n    sugim_distances = bfs(Y, blue_graph)\n    \n    min_turns = float('inf')\n    possible_game_ends = False\n    \n    # Find the minimal number of turns where they could meet\n    for node in range(N):\n        if sigma_distances[node] != -1 and sugim_distances[node] != -1:\n            possible_game_ends = True\n            turns = max(sigma_distances[node], sugim_distances[node])\n            min_turns = min(min_turns, turns)\n    \n    return min_turns if possible_game_ends else -1\n\n# Example usage:\nN = 5\nred_edges = [(0, 1), (1, 2), (2, 3), (3, 4)]\nblue_edges = [(0, 1), (1, 3), (3, 4), (0, 2)]\nX = 0\nY = 4\nprint(sigma_sugim_game(N, red_edges, blue_edges, X, Y))  # Output depends on the inputs",
    "timestamp": "2025-08-13 16:05:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class GraphGame {\n\n    public static void main(String[] args) {\n        // Example usage:\n        int N = 5;\n        int[][] redEdges = {{1, 2}, {2, 3}, {3, 4}, {3, 5}};\n        int[][] blueEdges = {{1, 4}, {4, 2}, {2, 5}, {5, 3}};\n        int X = 1;\n        int Y = 5;\n        \n        System.out.println(findGameTurns(N, redEdges, blueEdges, X, Y));\n    }\n\n    public static int findGameTurns(int N, int[][] redEdges, int[][] blueEdges, int X, int Y) {\n        List<Integer>[] redGraph = new ArrayList[N + 1];\n        List<Integer>[] blueGraph = new ArrayList[N + 1];\n        for (int i = 0; i <= N; i++) {\n            redGraph[i] = new ArrayList<>();\n            blueGraph[i] = new ArrayList<>();\n        }\n        for (int[] edge : redEdges) {\n            redGraph[edge[0]].add(edge[1]);\n            redGraph[edge[1]].add(edge[0]);\n        }\n        for (int[] edge : blueEdges) {\n            blueGraph[edge[0]].add(edge[1]);\n            blueGraph[edge[1]].add(edge[0]);\n        }\n\n        return bfs(redGraph, blueGraph, X, Y);\n    }\n\n    private static int bfs(List<Integer>[] redGraph, List<Integer>[] blueGraph, int startX, int startY) {\n        Set<String> visited = new HashSet<>();\n        List<int[]> queue = new ArrayList<>();\n        queue.add(new int[]{startX, startY, 0});\n\n        while (!queue.isEmpty()) {\n            int[] state = queue.remove(0);\n            int sigmaPos = state[0];\n            int sugimPos = state[1];\n            int turns = state[2];\n\n            if (sigmaPos == sugimPos) {\n                return turns;\n            }\n\n            String key = sigmaPos + \",\" + sugimPos;\n            if (visited.contains(key)) continue;\n            visited.add(key);\n\n            for (int nextSigmaPos : redGraph[sigmaPos]) {\n                queue.add(new int[]{nextSigmaPos, sugimPos, turns + 1});\n            }\n            \n            for (int nextSugimPos : blueGraph[sugimPos]) {\n                queue.add(new int[]{sigmaPos, nextSugimPos, turns + 1});\n            }\n        }\n        \n        return -1;  // Should never happen with valid trees\n    }\n}",
    "timestamp": "2025-08-13 16:05:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 100000\n\ntypedef struct Edge {\n    int to;\n    struct Edge* next;\n} Edge;\n\ntypedef struct Graph {\n    Edge* edges[MAXN];\n} Graph;\n\nvoid addEdge(Graph* graph, int u, int v) {\n    Edge* edge = (Edge*)malloc(sizeof(Edge));\n    edge->to = v;\n    edge->next = graph->edges[u];\n    graph->edges[u] = edge;\n}\n\nvoid initializeGraph(Graph* graph, int n) {\n    for (int i = 0; i < n; i++) {\n        graph->edges[i] = NULL;\n    }\n}\n\nbool visitedRed[MAXN], visitedBlue[MAXN];\n\nbool dfs(Graph* graph, int current, int target, bool* visited) {\n    if (current == target) return true;\n    visited[current] = true;\n    for (Edge* edge = graph->edges[current]; edge != NULL; edge = edge->next) {\n        if (!visited[edge->to]) {\n            if (dfs(graph, edge->to, target, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint countSteps(Graph* redGraph, Graph* blueGraph, int x, int y, int n) {\n    int steps = 0;\n    while (!visitedRed[y] || !visitedBlue[x]) {\n        visitedRed[x] = true;\n        visitedBlue[y] = true;\n        if (!visitedRed[y]) {\n            x = dfs(redGraph, x, y, visitedRed) ? y : x;\n        }\n        if (!visitedBlue[x]) {\n            y = dfs(blueGraph, y, x, visitedBlue) ? x : y;\n        }\n        steps++;\n    }\n    return steps;\n}\n\nint main() {\n    int n, x, y, u, v;\n    scanf(\"%d %d %d\", &n, &x, &y);\n\n    Graph redGraph, blueGraph;\n    initializeGraph(&redGraph, n);\n    initializeGraph(&blueGraph, n);\n\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d %d\", &u, &v);\n        addEdge(&redGraph, u - 1, v - 1);\n        addEdge(&redGraph, v - 1, u - 1);\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d %d\", &u, &v);\n        addEdge(&blueGraph, u - 1, v - 1);\n        addEdge(&blueGraph, v - 1, u - 1);\n    }\n\n    for (int i = 0; i < n; i++) {\n        visitedRed[i] = false;\n        visitedBlue[i] = false;\n    }\n\n    int steps = countSteps(&redGraph, &blueGraph, x - 1, y - 1, n);\n    printf(\"The game will end in %d turns.\\n\", steps);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:06:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to perform BFS and calculate distance from a start node\nvector<int> bfs_distance(const vector<vector<int>>& graph, int start) {\n    int n = graph.size();\n    vector<int> dist(n, -1);\n    queue<int> q;\n    dist[start] = 0;\n    q.push(start);\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int neighbor : graph[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return dist;\n}\n\nint main() {\n    int n, x, y;\n    cin >> n >> x >> y;\n    --x; --y;  // Decrement to make indices 0-based\n    \n    vector<vector<int>> red_graph(n), blue_graph(n);\n\n    // Read red edges\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;  // Decrement to make indices 0-based\n        red_graph[u].push_back(v);\n        red_graph[v].push_back(u);\n    }\n\n    // Read blue edges\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;  // Decrement to make indices 0-based\n        blue_graph[u].push_back(v);\n        blue_graph[v].push_back(u);\n    }\n\n    // Calculate distances for Sigma and Sugim using BFS\n    vector<int> sigma_dist = bfs_distance(red_graph, x);\n    vector<int> sugim_dist = bfs_distance(blue_graph, y);\n\n    // Calculate the minimum number of turns required\n    int min_turns = n * 2; // some large number\n    for (int i = 0; i < n; ++i) {\n        if (sigma_dist[i] != -1 && sugim_dist[i] != -1) {\n            int max_turns = max(sigma_dist[i], sugim_dist[i]);\n            min_turns = min(min_turns, 2 * max_turns);\n        }\n    }\n\n    cout << min_turns << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:06:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_graph_game(N, red_edges, blue_edges, X, Y):\n    red_graph = defaultdict(list)\n    blue_graph = defaultdict(list)\n    \n    for u, v in red_edges:\n        red_graph[u].append(v)\n        red_graph[v].append(u)\n    \n    for u, v in blue_edges:\n        blue_graph[u].append(v)\n        blue_graph[v].append(u)\n    \n    def bfs(start, graph):\n        dist = {start: 0}\n        queue = deque([start])\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in dist:\n                    dist[neighbor] = dist[node] + 1\n                    queue.append(neighbor)\n        \n        return dist\n    \n    red_dist_x = bfs(X, red_graph)\n    blue_dist_y = bfs(Y, blue_graph)\n    \n    min_turns = float('inf')\n    \n    for node in range(1, N+1):\n        if node in red_dist_x and node in blue_dist_y:\n            turns = red_dist_x[node] + blue_dist_y[node]\n            min_turns = min(min_turns, turns)\n    \n    return min_turns if min_turns != float('inf') else -1\n\ndef main():\n    N, X, Y = map(int, input().split())\n    red_edges = []\n    blue_edges = []\n    \n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        red_edges.append((u, v))\n    \n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        blue_edges.append((u, v))\n    \n    result = solve_graph_game(N, red_edges, blue_edges, X, Y)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 16:06:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, X, Y = map(int, input[ptr:ptr+3])\n    ptr +=3\n\n    red_adj = [[] for _ in range(N+1)]\n    blue_adj = [[] for _ in range(N+1)]\n\n    for _ in range(N-1):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr +=2\n        red_adj[u].append(v)\n        red_adj[v].append(u)\n\n    for _ in range(N-1):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr +=2\n        blue_adj[u].append(v)\n        blue_adj[v].append(u)\n\n    # BFS for Sigma (red edges)\n    sigma_dist = [-1]*(N+1)\n    q = deque()\n    q.append(X)\n    sigma_dist[X] = 0\n    while q:\n        u = q.popleft()\n        for v in red_adj[u]:\n            if sigma_dist[v] == -1:\n                sigma_dist[v] = sigma_dist[u] + 1\n                q.append(v)\n\n    # BFS for Sugim (blue edges)\n    sugim_dist = [-1]*(N+1)\n    q = deque()\n    q.append(Y)\n    sugim_dist[Y] = 0\n    while q:\n        u = q.popleft()\n        for v in blue_adj[u]:\n            if sugim_dist[v] == -1:\n                sugim_dist[v] = sugim_dist[u] + 1\n                q.append(v)\n\n    min_turns = float('inf')\n    for v in range(1, N+1):\n        if sigma_dist[v] == sugim_dist[v] and sigma_dist[v] != -1:\n            min_turns = min(min_turns, sigma_dist[v])\n\n    if min_turns != float('inf'):\n        print(min_turns)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 16:10:53"
  }
]