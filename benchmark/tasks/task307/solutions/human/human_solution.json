[
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.{NumericRange, Queue}\nimport scala.collection.mutable\nimport scala.io.StdIn.readLine\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    val N, M = sc.nextInt\n    val uf = new IUnionFind(N)\n    var citySet = mutable.Set[Int]()\n    for (_ <- Range(0, M)) {\n      val x, y = sc.nextInt - 1\n      citySet += x\n      citySet += y\n      uf.union(x, y)\n    }\n    var city = 0\n    var village = 0\n    for (i <- Range(0, N)) (if (uf.root(i) == i) {\n      village += 1\n      if (citySet.contains(i)) (city += 1)\n    })\n    village -= city\n    println(math.abs(city - village))\n\n  }\n\n  def gcd(i: Long, j: Long): Long = {\n    if (i < j) (gcd(j, i)) else (if (j == 0) (i) else (gcd(j, i % j)))\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n    solve(sc)\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n  val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n  val towns = Array.tabulate(n){_ ⇒ new UnionFindTree}\n  val isMerged = Array.tabulate(n){_ ⇒ false}\n  for (_ ← 0 until m){\n    val Array(a, b) = readLine.trim.split(' ').map(_.toInt - 1)\n    towns(a).merge(towns(b))\n    isMerged(a) = true\n    isMerged(b) = true\n  }\n  println(\n    towns.count(_.isTop).let{city ⇒ isMerged.count(!_).let{town ⇒\n      math.abs(city - town * 2)\n    }}\n  )\n  class UnionFindTree{\n    private var mParent: Option[UnionFindTree] = None\n    private def parent: UnionFindTree = {\n      mParent.map{_.parent} match {\n        case Some(p) ⇒\n          p.also{it ⇒ mParent = Some(it)}\n        case None ⇒ this\n      }\n    }\n    def merge(that: UnionFindTree): Unit = {\n      if (!isSameUnion(that)) {\n        this.parent.mParent = Some(that.parent)\n      }\n    }\n    def isSameUnion(that: UnionFindTree): Boolean = {\n      this.parent == that.parent\n    }\n    def isTop: Boolean = mParent.isEmpty\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nclass UnionFind {\n  public:\n    std::vector<int> par;\n    std::vector<int> rank;\n    std::vector<int> size;\n\n    UnionFind(int N) : par(N), rank(N), size(N) {        \n        for (int i = 0; i < N; i++) {\n            par[i]  = i;\n            rank[i] = 0;\n            size[i] = 1;\n        }\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) { return; }\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            size[y] += size[x];\n        } else {\n            par[y] = x;\n            size[x] += size[y];\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }       \n    }\n\n    bool same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n};\n\nint main()\n{\n    int N, M;\n    std::cin >> N >> M;\n\n    UnionFind uf(N);\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        uf.unite(a - 1, b - 1);\n    }\n    \n    int city = 0;\n    int town = 0;\n    std::vector<bool> used(N, false);\n    \n    for (int i = 0; i < N; i++) {\n        int x = uf.find(i);\n        if (used[x]) { continue; }\n\n        used[x] = true;\n        if (uf.size[x] == 1) {\n            town++;\n        } else {\n            city++;\n        }\n    }\n\n    int diff = town - city;\n    std::cout << (diff < 0 ? -diff : diff) << std::endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\n#define LL long long\n#define Fi first\n#define Se second\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<int,int> PII;\n\nint N,M;\nint flg[1010];\nPII V[1010];\nint cnt1;\nint cnt2;\nint main(){\n    cin>>N>>M;\n    cnt2=N;\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        flg[a]=1;\n        flg[b]=1;\n        V[i].Fi=max(a,b);\n        V[i].Se=min(a,b);\n    }\n    //sort(V,V+M);\n    rep(i,M){\n        bool was=false;\n        rep(j,i){\n            if(V[i].Fi==V[j].Fi||V[i].Se==V[j].Fi){ was=true; break; }\n            if(V[i].Fi==V[j].Se||V[i].Se==V[j].Se){ was=true; break; }\n        }\n        if(!was)cnt1++;\n    }\n    //cout<<cnt1<<endl;\n    FOR(i,1,N){\n        if(flg[i]!=0)cnt2--;\n    }\n    cout<<abs(cnt1-cnt2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n\nstruct UnionFind {\n\tvector<int> data;\n\tvoid init(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x != y) {\n\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\n\nint main() {\n\tint N; int M;\n\twhile(~scanf(\"%d%d\", &N, &M)) {\n\t\tUnionFind uf; uf.init(N);\n\t\trep(i, M) {\n\t\t\tint a; int b;\n\t\t\tscanf(\"%d%d\", &a, &b), -- a, -- b;\n\t\t\tuf.unionSet(a, b);\n\t\t}\n\t\tint x = 0, y = 0;\n\t\trep(i, N) if(uf.root(i) == i) {\n\t\t\t(uf.size(i) == 1 ? x : y) += 1;\n\t\t}\n\t\tint ans = abs(x - y);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,m,a[2],x,y;\nvector<int>v[1001];\nbool used[1001];\nint dfs(int p){\n  int res=1;\n  used[p]=1;\n  r(i,v[p].size()){\n    if(!used[v[p][i]]){\n      res+=dfs(v[p][i]);\n    }\n  }\n  return res;\n}\nint main(){\n  cin>>n>>m;\n  r(i,m){\n    cin>>x>>y;\n    x--,y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n)if(!used[i])a[dfs(i)>=2]++;\n  cout<<abs(a[0]-a[1])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\nusing namespace std;\n\nstruct UF{\n    vector<int> par;\n    vector<int> sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n, 1);\n        rep(i, 0, n) par[i] = i;\n    }\n    int find(int x){\n        if(x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y){\n        x = find(x); y = find(y);\n        if(x == y) return;\n        if(sz[x] < sz[y]) swap(x, y);\n        sz[x] += sz[y];\n        par[y] = x;\n    }\n};\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n    UF uf;\n    uf.init(n);\n    rep(i, 0, m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        uf.unite(a, b);\n    }\n    int cnt = 0;\n    set<int> st;\n    rep(i, 0, n){\n        st.insert(uf.find(i));\n        if(uf.sz[uf.find(i)] == 1) cnt++;\n    }\n    // cout << cnt << ' ' << st.size() << endl;\n    cout << abs(st.size() - 2*cnt) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n \n// #define int long long\n#define GET_MACRO(a, b, c, d, NAME, ...) NAME\n#define REP1(n) REP2(i_, n)\n#define REP2(i, n) REP3(i, 0, n)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (long long i = (a); i < (long long)(b); i += (long long)(s))\n#define RREP1(n) RREP2(i_, n)\n#define RREP2(i, n) RREP3(i, 0, n)\n#define RREP3(i, a, b) RREP4(i, a, b, 1)\n#define RREP4(i, a, b, s) for (long long i = (b) - 1; i >= (long long)(a);  i -= (long long)(s))\n#define rep(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define rrep(...) GET_MACRO(__VA_ARGS__, RREP4, RREP3, RREP2, RREP1)(__VA_ARGS__)\n#define fs first\n#define sc second\n#define all(c) std::begin(c), std::end(c)\n#define pcnt(x) __builtin_popcountll(x)\n#define each(x, c) for (auto &&x : c)\n#define endl \"\\n\"\n#define y0 y0_\n#define y1 y1_\n#define yn yn_\n \n#define TMP_T template<typename T>\n#define TMP_TU template<typename T, typename U>\n#define TMP_Ts template<typename ...T>\n#define TMP_NTs template<size_t N, typename ...T>\n#define TMP_CT template<bool C, typename T = void>\n \n#ifndef DEBUG\n#define cerr no_output\nstruct NoOutput : ostream {\n  TMP_T ostream &operator<<(const T &){ return *this; }\n} no_output;\n#endif\n \nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nTMP_T using PQL = priority_queue<T, vector<T>, greater<T>>;\nTMP_T using PQG = priority_queue<T>;\nTMP_CT using enable_if_t = typename enable_if<C, T>::type;\n \nconst ll LLINF = 1e18 + 10;\n#ifndef int\nconst int INF = 1e9 + 10;\n#else\nconst int INF = LLINF;\n#endif\n \nconst int dx[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[] = {0, -1, 0, 1, -1, -1, 1, 1};\n \nTMP_T inline constexpr T sq(T x){ return x * x; }\nTMP_TU inline T& chmin(T &x, U y){ if (x > y) x = y; return x; }\nTMP_TU inline T& chmax(T &x, U y){ if (x < y) x = y; return x; }\n \nTMP_NTs enable_if_t<(N >= sizeof...(T))> input_tuple(istream &, tuple<T...> &){}\nTMP_NTs enable_if_t<(N < sizeof...(T))> input_tuple(istream &is, tuple<T...> &x){ is >> get<N>(x); input_tuple<N + 1, T...>(is, x); }\nTMP_Ts ostream &operator>>(istream &is, tuple<T...> &x){ input_tuple<0, T...>(is, x); return is; }\nTMP_TU ostream &operator>>(istream &is, pair<T, U> &x){ return is >> x.first >> x.second; }\nTMP_NTs enable_if_t<(N >= sizeof...(T))> print_tuple(ostream &, const tuple<T...> &){}\nTMP_NTs enable_if_t<(N < sizeof...(T))> print_tuple(ostream &os, const tuple<T...> &x){ os << (N > 0 ? \" \" : \"\") << get<N>(x); print_tuple<N + 1, T...>(os, x); }\nTMP_Ts ostream &operator<<(ostream &os, const tuple<T...> &x){ print_tuple<0, T...>(os, x); return os; }\nTMP_TU ostream &operator<<(ostream &os, const pair<T, U> &x){ return os << x.first << \" \" << x.second; }\n \n#undef TMP_T\n#undef TMP_TU\n#undef TMP_Ts\n#undef TMP_NTs\n#undef TMP_CT\n\nll gcd(ll a, ll b){ return b ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntuple<ll, ll, ll> extgcd(ll a, ll b){\n  if (b){\n    ll g, x, y;\n    tie(g, x, y) = extgcd(b, a % b);\n    return make_tuple(g, y, x - a / b * y);\n  }\n  return make_tuple(a, 1, 0);\n}\nll invmod(ll a, ll m = 1000000007){\n  ll g, x;\n  tie(g, x, ignore) = extgcd(a, m);\n  return g == 1 ? (x + m) % m : 0;\n}\n\ninline ll in(){ ll x; cin >> x; return x; }\n \nstruct prepare {\n  prepare(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(12);\n  }\n} prepare_;\n/* }}} */\n/* union_find.cpp {{{ */\nclass UnionFind {\npublic:\n  UnionFind(int n = 0): cnt(n), par(n, -1){}\n  int root(int x) const { return par[x] < 0 ? x : par[x] = root(par[x]); }\n  bool same(int x, int y) const { return root(x) == root(y); }\n  int size(int x) const { return -par[root(x)]; }\n  int count() const { return cnt; }\n  bool merge(int x, int y){\n    if ((x = root(x)) == (y = root(y))) return false;\n    if (par[x] > par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n    cnt--;\n    return true;\n  }\nprivate:\n  int cnt;\n  mutable vector<int> par;\n};\n/* }}} */\n\nint c[1000];\n\nsigned main()\n{\n  int n, m;\n  cin >> n >> m;\n  UnionFind uf(n);\n  rep(m) uf.merge(in() - 1, in() - 1);\n  rep(i, n) c[uf.root(i)]++;\n  int s = 0;\n  rep(i, n){\n    if (c[i] == 1) s++;\n    else if (c[i] > 1) s--;\n  }\n  cout << abs(s) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * c.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n\nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\n\n/* typedef */\n\nstruct UFT {\n  int links[MAX_N], ranks[MAX_N], sizes[MAX_N];\n\n  void clear(int n) {\n    for (int i = 0; i < n; i++) links[i] = i, ranks[i] = sizes[i] = 1;\n  }\n  UFT() {}\n  UFT(int n) { clear(n); }\n\n  int root(int i) {\n    int i0 = i;\n    while (links[i0] != i0) i0 = links[i0];\n    return (links[i] = i0);\n  }\n\n  int rank(int i) { return ranks[root(i)]; }\n  int size(int i) { return sizes[root(i)]; }\n  bool same(int i, int j) { return root(i) == root(j); }\n\n  int merge(int i0, int i1) {\n    int r0 = root(i0), r1 = root(i1), mr;\n    if (r0 == r1) return r0;\n    if (ranks[r0] == ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      ranks[r0]++;\n      mr = r0;\n    }\n    else if (ranks[r0] > ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      mr = r0;\n    }\n    else {\n      links[r0] = r1;\n      sizes[r1] += sizes[r0];\n      mr = r1;\n    }\n    return mr;\n  }\n};\n\n/* global variables */\n\nUFT uft;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  uft.clear(n);\n\n  for (int i = 0; i < m; i++) {\n    int ai, bi;\n    cin >> ai >> bi;\n    ai--, bi--;\n    uft.merge(ai, bi);\n  }\n\n  int cn = 0, vn = 0;\n  for (int i = 0; i < n; i++) {\n    int ri = uft.root(i);\n    if (ri == i) {\n      if (uft.size(i) > 1) cn++;\n      else vn++;\n    }\n  }\n\n  printf(\"%d\\n\", abs(cn - vn));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nclass UF {\n\tpublic:\n\tstatic const int ufmax=100052;\n\tint ufpar[ufmax],ufrank[ufmax],ufcnt[ufmax];\n\tUF() { init();}\n\tvoid init(){int i; rep(i,ufmax) { ufpar[i]=i; ufrank[i]=0; ufcnt[i]=1; } }\n\tint find(int x) {\treturn (ufpar[x]==x)?(x):(ufpar[x] = find(ufpar[x]));}\n\tint operator[](int x) {return find(x);}\n\tint count(int x) {return ufcnt[find(x)];}\n\tvoid unite(int x,int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(ufrank[x]<ufrank[y]) ufpar[x]=y, ufcnt[y]+=ufcnt[x];\n\t\telse {ufpar[y]=x; ufcnt[x]+=ufcnt[y]; if(ufrank[x]==ufrank[y]) ufrank[x]++;}\n\t}\n};\n\n\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m;\n\tUF uf;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tuf.unite(a,b);\n\t}\n\tset<int> se;\n\tint a,b=0;\n\trep(i,n){\n\t\tse.insert(uf[i]);\n\t\tif(i==uf[i]) b++;\n\t}\n\ta=se.size();\n\tcout<<abs(a-b)<<endl;\n\t// cout<<abs((int)se.size()-(n-(int)se.size()))<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 100\nusing namespace std;\n\nint parent[pro+1];\n\nint find(int n){\n\tif(n==parent[n])return n;\n\telse find(parent[n]);\n}\n\nint main(){\n\tint n,m,city=0,town=0;\n\tcin>>n>>m;\n\tbool check[n+1];\n\tint a,b;\n\tloop(i,1,n+1)parent[i]=i;\n\trep(i,m){\n\t\tcin>>a>>b;\n\t\tint top=find(a);\n\t\tparent[b]=top;\n\t}\n\tvector<int> vec[n+1];\n\tloop(i,1,n+1){\n\t\tvec[parent[i]].push_back(i);\n\t}\n\tloop(i,1,n+1){\n\t\tif(vec[i].size()==0)continue;\n\t\tif(vec[i].size()==1)town++;\n\t\telse city++;\n\t}\n\tcout<<abs(city-town)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nclass UF {\n\tpublic:\n\tstatic const int ufmax=100052;\n\tint ufpar[ufmax],ufrank[ufmax],ufcnt[ufmax];\n\tUF() { init();}\n\tvoid init(){int i; rep(i,ufmax) { ufpar[i]=i; ufrank[i]=0; ufcnt[i]=1; } }\n\tint find(int x) {\treturn (ufpar[x]==x)?(x):(ufpar[x] = find(ufpar[x]));}\n\tint operator[](int x) {return find(x);}\n\tint count(int x) {return ufcnt[find(x)];}\n\tvoid unite(int x,int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(ufrank[x]<ufrank[y]) ufpar[x]=y, ufcnt[y]+=ufcnt[x];\n\t\telse {ufpar[y]=x; ufcnt[x]+=ufcnt[y]; if(ufrank[x]==ufrank[y]) ufrank[x]++;}\n\t}\n};\n\n\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m;\n\tUF uf;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tuf.unite(a,b);\n\t}\n\tset<int> se;\n\tint a,b=0;\n\trep(i,n){\n\t\tif(i==uf[i]) b++;\n\t\telse se.insert(uf[i]);\n\t}\n\ta=se.size();\n\tcout<<abs(a-b)<<endl;\n\t// cout<<abs((int)se.size()-(n-(int)se.size()))<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nvector<int> G[1001];\nbool used[1001];\nint cnt=0;\nint ans=0;\n\nvoid dfs(int v){\n\tcnt++;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]]){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!used[i]){\n\t\t\tcnt=0;\n\t\t\tdfs(i);\n\t\t\tif(cnt==1)ans++;\n\t\t\telse ans--;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",abs(ans));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <utility>\n#define rep(i,l,n) for(lint i=l;i<n;i++)\n#define rer(i,l,n) for(lint i=l;i<=n;i++)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int> vi;\ntypedef vector<lint> vli;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint par[10000];\nint _rank[10000];\n\t//n????´???§?????????\nvoid init(int n){\n\trep(i,0,n){\n\t\tpar[i]=i; _rank[i]=0;\n\t}\n}\n\t//??¨??????????±???????\nint find(int x){\n\tif(par[x]==x) return x;\n\telse return par[x]=find(par[x]);\n}\n\t//x??¨y????±??????????????????????\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\tif(_rank[x]<_rank[y]) par[x]=y;\n\telse{\n\t\tpar[x]=y;\n\t\tif(_rank[x]==_rank[y]) _rank[x]++;\n\t}\n}\n\t//x??¨y???????????????????±????????????????\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tinit(n+1);\n\tvi d(n+1,0);\n\tint a,b,city=0,mura=n;\n\trep(i,0,m){\n\t\tcin>>a>>b;\n\t\t/*if(d[a]==0 && d[b]==0) city++;\n\t\tif(d[a] && d[b]) city--;*/\n\t\tunite(a,b);\n\t\tif(d[a]==0){\n\t\t\td[a]=1; mura--;\n\t\t}\n\t\tif(d[b]==0){\n\t\t\td[b]=1; mura--;\n\t\t}\n\t}\n\tvi ct(n+1);\n\trep(i,1,n+1){\n\t\tint tmp=find(i);\n\t\t//o(tmp);\n\t\tif(ct[tmp]==0){\n\t\t\tct[tmp]=1;\n\t\t\tcity++;\n\t\t}\n\t}\n\to((int)abs(city-2*mura));\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<set>\nusing namespace std;\nclass UnionFind{\nprivate:\n\tvector<int> par, rank;\npublic:\n\tint find(int x){\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tUnionFind(int n) :par(n), rank(n, 0){\n\t\tiota(par.begin(), par.end(), 0);\n\t}\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)return false;\n\t\tif (rank[x] < rank[y])par[x] = y;\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\n};\nstruct init{\n\tinit(){\n\t\tcin.tie(0); ios::sync_with_stdio(false);\n\t}\n}________init;\nint main() {\n\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tint  N, M;\n\twhile (cin >> N >> M){\n\t\tUnionFind uf(N);\n\t\twhile (M--){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tuf.unite(a, b);\n\t\t}\n\t\tset<int> cnt;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tif (i != uf.find(i))cnt.insert(uf.find(i));\n\t\t}\n\t\tint sz1 = (int)cnt.size();\n\t\tint sz2 = 0;\n\t\tfor (int i = 0; i < N; i++){\n\t\t\tif (i == uf.find(i) && cnt.count(i) == 0)sz2++;\n\t\t}\n\t\tcout << abs(sz1 - sz2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\nclass union_find{\n\tstd::vector<int> parent;\npublic:\n\tint root(int a){return parent[a]==a?a:(parent[a]=root(parent[a]));}\n\tunion_find(int n):parent(n+1){for(int i=1;i<=n;i++)parent[i]=i;}\n\tint same(int a,int b){return root(a)==root(b);}\n\tint unite(int a,int b){\n\t\tint x=root(a),y=root(b);//if(x==y)return 0;\n\t\tparent[x]=y;\n\t\treturn 1;\n\t}\n\tint calc(){\n\t\tstd::map<int,int> m;\n\t\tfor(int i=1;i<parent.size();i++)m[root(i)]++;\n\t\tint r=0;\n\t\tfor(auto &e:m)r+=e.second>1?1:-1;\n\t\treturn abs(r);\n\t}\n};\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tunion_find uf(n);\n\tint a,b;\n\tfor(;m--;uf.unite(a,b))scanf(\"%d%d\",&a,&b);\n\tprintf(\"%d\\n\",uf.calc());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n    int N, M; cin >> N >> M;\n    int C = N + 1;\n    vector<int> T(N);\n    for (int i = 0; i < N; i++) T[i] = i + 1;\n\n    for (int i = 0; i < M; i++) {\n        int x, y; cin >> x >> y;\n        x = T[x-1], y = T[y-1];\n        for (auto &j : T) {\n            if (j == x || j == y) j = C;\n        }\n        C++;\n    }\n\n    set<int> u, l;\n    for (auto i : T) {\n        if (i > N) u.insert(i);\n        else l.insert(i);\n    }\n\n    cout << abs((int)u.size() - (int)l.size()) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\nusing namespace std;\n\nstruct UF{\n    vector<int> par;\n    vector<int> sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n, 1);\n        rep(i, 0, n) par[i] = i;\n    }\n    int find(int x){\n        if(x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y){\n        x = find(x); y = find(y);\n        if(x == y) return;\n        if(sz[x] < sz[y]) swap(x, y);\n        sz[x] += sz[y];\n        par[y] = x;\n    }\n};\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n    UF uf;\n    uf.init(n);\n    rep(i, 0, m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        uf.unite(a, b);\n    }\n    int cnt = 0;\n    set<int> st;\n    rep(i, 0, n){\n        st.insert(uf.find(i));\n        if(uf.sz[uf.find(i)] == 1) cnt++;\n    }\n    cout << cnt << ' ' << st.size() << endl;\n    cout << abs(st.size() - 2*cnt) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nclass UnionFind{\n\nprivate:\n    vector<int> rank,p;\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n    }\n\n  public:\n      UnionFind(){};\n      UnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        for(int i = 0; i < size; i++){\n          makeSet(i);\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void unite(int x, int y){\n      link(find(x), find(y));\n    }\n\n    int find(int x){\n      if(x != p[x]) p[x] = find(p[x]);\n      return p[x];\n    }\n\nprivate:\n    void link(int x, int y){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n      }else{\n        p[x] = y;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\nsigned main(void) {\n    int n,m;\n    cin >> n >> m;\n\n    UnionFind uf(n);\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        a--;\n        b--;\n        uf.unite(a,b);\n    }\n    vi a(n);\n    rep(i,n)a[uf.find(i)]++;\n    //rep(i,n)cout << \" \" << a[i];cout << endl;\n    int s = 0, t = 0;\n    rep(i,n){\n        if(a[i] == 1)s++;\n        if(a[i] > 1)t++;\n    }\n    cout << abs(s-t) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint group[1010];\nint parent(int i){\n\tif(i==group[i])\treturn i;\n\telse return group[i]=parent(group[i]);\n}\nvoid merge(int i,int j){\n\ti=parent(i);\tj=parent(j);\n\tgroup[i]=group[j];\n}\n\nint main(){\n\tint n;\tcin>>n;\n\tint m;\tcin>>m;\n\tfor(int i=1;i<=n;i++)\tgroup[i]=i;\n\tfor(int j=0;j<m;j++){\n\t\tint a,b;\tcin>>a>>b;\n\t\tmerge(a,b);\n\t}\n\tmap<int,int> kind;\n\tfor(int i=1;i<=n;i++)\tkind[parent(i)]++;\n\tint village=0,city=0;\n\tfor(auto it:kind){\n\t\tif(it.second==1)\tvillage++;\n\t\telse \tcity++;\n\t}\n\tcout<<abs(village-city)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(int__)(k);i++)\n#define all(v) v.begin(),v.end()\n\nstruct UnionFind{\n    int n;\n    vector<int> p;\n    UnionFind(int nn) : n(nn+1){\n        p.resize(n);\n        rep(i, n) p[i] = i;\n    }\n    int root(int x){\n        if(p[x] == x) return x;\n        else return p[x] = root(p[x]);\n    }\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x != y) p[y] = x;\n    }\n    bool query(int x, int y){\n        return root(x) == root(y);\n    }\n};\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    int N, M; cin >> N >> M;\n    UnionFind ut(N);\n    set<int> c;\n    rep(i, M){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        if(a != b){\n            c.insert(a);\n            c.insert(b);\n        }\n        ut.unite(a, b);\n    }\n    set<int> s;\n    rep(i, N){\n        int r = ut.root(i);\n        if(r != i) s.insert(ut.root(i));\n    }\n    int city = s.size();\n    int vil = N - c.size();\n    cout << abs(vil - city) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct UnionFind{\n  vector<int>parent,sizes;\n  UnionFind(int n):parent(n),sizes(n,1){\n    for(int i=0;i<n;++i)parent[i]=i;\n  }\n  int find(int x){\n    return x==parent[x]?x:parent[x]=find(parent[x]);\n  }\n  void unite(int x,int y){\n    if((x=find(x))==(y=find(y)))return;\n    if(sizes[x]>sizes[y])swap(x,y);\n    parent[y]=x;\n    sizes[x]+=sizes[y];\n    sizes[y]=0;\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  int size(int x){\n    return sizes[find(x)];\n  }\n};\nmain(){\n  int n,m,a,b,x=0,y=0;\n  cin>>n>>m;\n  UnionFind UF(n);\n  for(int i=0;i++<m;UF.unite(--a,--b))cin>>a>>b;\n  for(int i=0;i<n;++i)UF.sizes[i]>1?x++:UF.sizes[i]-1?:y++;\n  cout<<abs(x-y)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<iomanip>\n\nusing namespace std;\n\nint N, M;\nint data[1001][1001];\nint check[1001];\n\nint grp = 1;\n\nint back(int cur) {\n\tint cnt = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (data[cur][i] == -1) {\n\t\t\tif (!check[i]) {\n\t\t\t\tcheck[i] = true;\n\t\t\t\tdata[cur][i] = data[i][cur] = grp;\n\t\t\t\tcnt += back(i);\n\t\t\t}\n\t\t\tdata[cur][i] = data[i][cur] = grp;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint a, b;\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < M; ++i){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tdata[a][b] = data[b][a] = -1;\n\t}\n\tint shi = 0;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tif (check[i]) continue;\n\t\tcheck[i] = 1;\n\t\tint res = back(i);\n\t\tif (res > 1) {\n\t\t\tgrp++;\n\t\t\tshi += res;\n\t\t}\n\t}\n\tgrp--;\n\tprintf(\"%d\\n\", abs((N - shi) - grp));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    int a,b;\n    vector<int> frg(n,0);\n    int vi=n,city=0;\n    for(int i=0;i<m;i++){\n        cin >> a >> b;\n        if(frg[a-1]*frg[b-1]==0){\n            if(frg[a-1]==0)vi--;\n            if(frg[b-1]==0)vi--;\n            if(frg[a-1]==0&&frg[b-1]==0)city++;\n            frg[a-1]=frg[b-1]=1;\n        }else{\n            city--;\n        }\n    }\n    cout << abs(city-vi) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstruct unionfind{\n\tint par[1000],sz[1000];\n\tvoid init(int N){rep(i,N) par[i]=i;}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tpar[y]=x;\n\t\tsz[x]+=sz[y];\n\t}\n}UF;\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\tUF.init(N);\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tUF.unite(a,b);\n\t}\n\tint x=0;\n\trep(i,N) if(UF.find(i)==i){\n\t\tif(UF.sz[i]==1) x++;\n\t\telse x--;\n\t}\n\tcout<<abs(x)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n\nclass UnionFind{\npublic:\n    UnionFind(int N):parent(N), rank(N,0), size(N,1){\n        for(int i=0;i<N;++i) parent[i]=i;\n    }\n    int find(int x){\n        return x==parent[x]?x:parent[x]=find(parent[x]);\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    void unite(int x,int y){\n        x=find(x), y=find(y);\n        if(x==y) return;\n        if(rank[x]==rank[y]) parent[y]=x, rank[x]++;\n        else{\n            if(rank[x]<rank[y]) std::swap(x,y);\n            parent[y]=x;\n        }\n        size[x]+=size[y];\n        size[y]=0;\n    }\n    int getParentSize(int x){\n        return size[find(x)];\n    }\n    int getSize(int x){\n        return size[x];\n    }\nprivate:\n    std::vector<int> parent, rank, size;\n};\n\n#include<cmath>\n#include<iostream>\nusing namespace std;\nint main(){\n    int N,M;\n    cin>>N>>M;\n    UnionFind UF(N);\n    for(int i=0;i<M;++i){\n        int a,b;\n        cin>>a>>b;\n        UF.unite(--a,--b);\n    }\n    int x=0,y=0;\n    for(int i=0;i<N;++i) UF.getSize(i)>1?x++:UF.getSize(i)-1?:y++;\n    cout<<abs(x-y)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\nconst int MAX_N = 1010;\n\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid init(int n){\n  for (int i = 0; i < n; i++){\n    Par[i] = i;\n    Rank[i] = 0;\n  }\n  return ;\n}\n\nint find(int x){\n  if (Par[x] == x){\n    return x;\n  }else{\n    return Par[x] = find(Par[x]);\n  }\n  \n}\n\nvoid unit(int x, int y){\n  x = find(x);\n  y = find(y);\n  if (x == y)return ;\n\n  if (Rank[x] < Rank[y]){\n    Par[x] = y;\n  }else{\n    Par[y] = x;\n    if (Rank[x] == Rank[y])Rank[x]++;\n  }\n}\n\nbool same(int x, int y){\n  return find(x) == find(y);\n}\n\nint N,M;\nint deg[MAX_N];\nint main(){\n  cin >> N >> M;\n  init(N);\n  for (int i = 0; i < M; i++){\n    int a,b;\n    cin >> a >> b;\n    a--;\n    b--;\n    unit(a, b);\n    deg[a]++;\n    deg[b]++;\n  }\n  int village = 0;\n  set<int> city;\n  \n  for (int i = 0; i < N; i++){\n    if (deg[i]){\n      int x = find(i);\n      city.insert(x);\n    }else{\n      village++;\n    }\n    \n  }\n  //  cerr << village << \" \" << city.size() << endl;\n  cout << abs(village - (int)city.size()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nstruct Unionfind {\n  vector<int> size;\n  vector<int> par;\n  \n  Unionfind( int n ) :  size(n, 1), par(n) {\n    iota( par.begin() , par.end() , 0 );\n  }\n  \n  int find( int x ) {\n    if ( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n  \n  bool unite( int x , int y ) {\n    x = find(x);\n    y = find(y);\n    if ( x == y ) return false;\n    \n    if ( size[y] < size[x] ) swap( x , y );\n    \n    par[x] = y;\n    size[y] += size[x];\n    \n    return true;\n  }\n  \n  bool same( int x , int y ) {\n    return find(x) == find(y);\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  Unionfind uf(n);\n  int x, y;\n  REP(i,q) {\n    cin >> x >> y;\n    uf.unite(x-1, y-1);\n  }\n  set<int> sum,ci;\n  REP(i,n){\n    if(uf.find(i)==i) sum.insert(i);\n    else ci.insert(uf.find(i));\n  }\n  cout << abs(int(sum.size())-2*int(ci.size())) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,n) for(int i = 0 ;i < (n); i++) \n\nclass UF {\npublic:\n\tint n; vector<int> a;\n\tUF(int n) : n(n), a(n, -1) {}\n\tint find(int x) {\n\t\treturn a[x] < 0 ? x : (a[x] = find(a[x]));\n\t}\n\tbool unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return false;\n\t\tif (a[x] > a[y]) swap(x, y);\n\t\ta[x] += a[y];\n\t\ta[y] = x;\n\t\tn--;\n\t\treturn true;\n\t}\n\tint size(int x) {\n\t\treturn -a[find(x)];\n\t}\n};\n\nint main() {\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tUF uf(n);\n\tFOR(i, m) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\ta--; b--;\n\t\tuf.unite(a, b);\n\t}\n\tint ans = 0;\n\tFOR(i, n) if (uf.find(i) == i) {\n\t\tif (uf.size(i) == 1) ans++;\n\t\telse ans--;\n\t}\n\tcout << abs(ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvector<long long int>UF;\n\nlong long int pearent( long long int now ) {\n\tif( UF[now] == now ) {\n\t\treturn now;\n\t} else {\n\t\treturn UF[now] = pearent( UF[now] );\n\t}\n}\n\nvoid merge( long long int x, long long int y ) {\n\tUF[pearent( x )] = UF[pearent( y )];\n}\n\nint main() {\n\tlong long int N, M;\n\tcin >> N >> M;\n\tUF = vector<long long int>( N );\n\tvector<bool>qwe( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tUF[i] = i;\n\t}\n\tfor( size_t i = 0; i < M; i++ ) {\n\t\tlong long int a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tqwe[a] = 1;\n\t\tqwe[b] = 1;\n\t\tmerge( a, b );\n\t}\n\tlong long int ans = 0;\n\tlong long int num = 0;\n\tfor( size_t i = 0; i < N; i++ ) {\n\n\t\tif( UF[i] == i ) {\n\t\t\tans++;\n\t\t\tif( qwe[i] == false ) {\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << abs( (ans - num) - num ) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nclass UnionFind {\npublic:\n  vector<int> par, rank;\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(rank[x] < rank[y]) swap(x,y);\n    par[x] += par[y];\n    par[y] = x;\n    if(rank[x]==rank[y]) rank[x]++;\n  }\n  inline bool same(int x, int y){ return find(x) == find(y); }\n  inline int size(int x){ return -par[find(x)]; }\n};\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  UnionFind uf(n);\n  rep(i,m){\n    int s,t;\n    cin>>s>>t;\n    s--;t--;\n    uf.unite(s,t);\n  }\n\n  int ans = 0;\n  rep(i,n){\n    if(uf.size(i)==1) ans++;\n    else if(uf.par[i]<0) ans--;\n  }\n  cout << abs(ans) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\n#define LL long long\n#define Fi first\n#define Se second\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<int,int> PII;\n\nint N,M;\nint flg[1010];\nPII V[1010];\nint cnt1;\nint cnt2;\nint main(){\n    cin>>N>>M;\n    cnt2=N;\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        if(flg[a]==0)flg[a]=1;\n        else if(flg[a])flg[a]=2;\n        if(flg[b]==0)flg[b]=1;\n        else if(flg[b])flg[b]=2;\n        V[i].Fi=max(a,b);\n        V[i].Se=min(a,b);\n    }\n    sort(V,V+M);\n    rep(i,M){\n        bool was=false;\n        rep(j,i){\n            if(V[i].Fi==V[j].Fi||V[i].Se==V[j].Fi){ was=true; break; }\n            if(V[i].Fi==V[j].Se||V[i].Se==V[j].Se){ was=true; break; }\n        }\n        if(!was)cnt1++;\n    }\n    FOR(i,1,N){\n        //cout<<i<<\" \"<<flg[i]<<endl;\n        if(flg[i])cnt2--;\n    }\n    cout<<abs(cnt1-cnt2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nvector<int> G[1003];\nint N,M;\nbool visited[1003];\n\nvoid dfs(int v,int &cnt) {\n    if(visited[v]) return;\n\n    cnt++;\n    visited[v]=true;\n    for(auto u:G[v]) {\n        if(visited[u]) continue;\n        dfs(u,cnt);\n    }\n\n}\n\nint main() {\n    cin>>N>>M;\n    rep(i,M) {\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    int ans=0;\n    rep(i,N) {\n        if(visited[i]) continue;\n        int cnt=0;\n        dfs(i,cnt);\n        if(cnt==1) ans++;\n        else ans--;\n    }\n    cout<<abs(ans)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <set>\nusing namespace std;\nclass UnionFind{\n    public:\n    vector<int> par; //親は何番ですか\n    vector<int> size; //集合の要素数を得る\n\n    UnionFind(int n) : par(n),size(n,1){\n        for(int i = 0; i < n; i++){\n            par[i] = i; //最初の親は自分自身\n        }\n    }\n    void init(int n){\n        par.resize(n); \n        size.assign(n,1);\n        for(int i = 0; i < n; i++){\n            par[i] = i; //最初の親は自分自身\n        }\n    }\n\n    int root(int x){ //根の検索を再帰的にやります\n        if(par[x] == x) return x; //自分が根なら自分が根だと返す\n        return par[x] = root(par[x]); //そうでないならxの親はxの親の親\n    }\n\n    bool unite(int x, int y){ //併合します\n        x = root(x); //xの根\n        y = root(y); //yの根\n        if(x == y) return false; //根が同じならもう併合済み\n        //併合するときは\"小さい方\"を\"大きい方\"に併合させる\n        if(size[x] < size[y]) swap(x,y); \n        size[x] += size[y];\n        par[y] = x; //併合するので親を変える\n        return true;\n    }\n\n    bool isSame(int x,int y){ //2つの頂点が同じ集合に属するか\n        return root(x) == root(y);\n    }\n    \n    int getSize(int x){ //集合の要素の大きさを返します\n        return size[root(x)];\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n,m;\n    cin >> n >> m;\n    UnionFind uf(n);\n    for(int i = 0; i < m; i++){\n        int a,b;\n        cin >> a >> b;\n        a--; b--;\n        if(!(uf.isSame(a,b))) uf.unite(a,b);\n    }\n    int cnt = 0;\n    set<int> st;\n    for(int i = 0; i < n; i++){\n        int k = uf.root(i);\n        if(uf.getSize(i) == 1) cnt++;\n        else st.insert(k);\n    }\n    int sz = st.size();\n    cout << abs(sz-cnt) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct UnionFind{\n    vector<int> p;\n    int n;\n    UnionFind(int s) : n(s){\n        p.resize(n);\n        for(int i = 0; i < n; i++)  p[i] = i;\n    }\n\n    int findSet(int x){\n        if(p[x] != x){\n            p[x] = findSet(p[x]);\n        }\n        return p[x];\n    }\n\n    void unite(int x, int y){\n        x = findSet(x), y = findSet(y);\n        if(x == y)  return;\n        p[x] = y;\n    }\n};\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    UnionFind uf(n);\n    int a, b;\n    while(m-- > 0){\n        cin >> a >> b;\n        uf.unite(--a, --b);\n    }\n    int cnt[1000] = {};\n    for(int i = 0; i < n; i++)  cnt[uf.findSet(i)]++;\n    int ans = 0;\n    for(int i = 0; i < n; i++)  ans += (cnt[i]>0)*(2*(cnt[i]>1)-1);\n    cout << abs(ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 10000\nusing namespace std;\n\nint parent[pro+1];\n\nint find(int n){\n\tif(n==parent[n])return n;\n\telse find(parent[n]);\n}\n\nint main(){\n\tint n,m,city=0,town=0;\n\tcin>>n>>m;\n\tbool check[n+1];\n\tint a,b;\n\tloop(i,1,n+1)parent[i]=i;\n\trep(i,m){\n\t\tcin>>a>>b;\n\t\tint top=find(a);\n\t\tparent[b]=top;\n\t}\n\tvector<int> vec[pro+1];\n\tloop(i,1,n+1){\n\t\tvec[parent[i]].push_back(i);\n\t}\n\tloop(i,1,n+1){\n\t\tif(vec[i].size()==0)continue;\n\t\tif(vec[i].size()==1)town++;\n\t\telse city++;\n\t}\n\tcout<<abs(city-town)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\nusing namespace std;\n\nstruct UF{\n    vector<int> par;\n    vector<int> sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n, 1);\n        rep(i, 0, n) par[i] = i;\n    }\n    int find(int x){\n        if(x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y){\n        x = find(x); y = find(y);\n        if(x == y) return;\n        if(sz[x] < sz[y]) swap(x, y);\n        sz[x] += sz[y];\n        par[y] = x;\n    }\n};\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n    UF uf;\n    uf.init(n);\n    set<int> vil;\n    rep(i, 0, m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        uf.unite(a, b);\n        vil.insert(a);\n        vil.insert(b);\n    }\n    int cnt = n - vil.size();\n    set<int> st;\n    rep(i, 0, n){\n        st.insert(uf.find(i));\n    }\n    // cout << cnt << ' ' << st.size() << endl;\n    cout << abs(st.size() - 2*cnt) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 10000\nusing namespace std;\n\nint abs(int n){\n\tif(n>0)return n;\n\telse return -1*n;\n}\n\nint main(){\n\tint vi, town, info;\n\twhile(cin >> vi >> info){\n\t\ttown = 1;\n\t\tint check[1005] = {0};\n\t\trep(i,info){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tif(check[a] == check[b] && check[a] == 0){\n\t\t\t\tcheck[a] = town;\n\t\t\t\tcheck[b] = town;\n\t\t\t\ttown++;\n\t\t\t}else if(check[a] == 0 && check[b] != 0 ){\n\t\t\t\t\tcheck[a] = check[b];\n\t\t\t}else if(check[a] != 0 && check[b] == 0){\n\t\t\t\t\tcheck[b] = check[a];\n\t\t\t}else if(check[a] != check[b]){\n\t\t\t\tfor(int i = 1; i <= vi; i++){\n\t\t\t\t\tif(check[i] == check[a]) check[i] = check[b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0, c = 0;\n\t\tfor(int i = 1; i <= vi; i++){\n\t\t\tif(check[i] > 0){\n\t\t\t\tc++;\n\t\t\t\tfor(int j = i + 1; j <= vi; j++){\n\t\t\t\t\tif(check[j] == check[i]) check[j] = -1;\n\t\t\t\t}\n\t\t\t}else if(check[i] == 0){\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tcout << abs(c - m) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool u[1010];\nvector<int> v[1010];\nint dfs(int x,bool f) {\n  u[x]=1;\n  for(int i=0; i<v[x].size(); i++) {\n    if(!u[v[x][i]]) f=0,dfs(v[x][i],f);\n  }\n  return f;\n}\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  for(int i=0,x,y; i<m; i++) {\n    cin >> x >> y;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int x=0,y=0;\n  for(int i=1; i<=n; i++) {\n    if(!u[i]) dfs(i,1)?x++:y++;\n  }\n  cout << abs(x-y) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nint main(){\n\n  int n,m,c[1001]={},flag[1001]={},r0=0,r1=0;\n  cin>>n>>m;\n  for(int i=1,a,b;i<=m;i++){\n    cin>>a>>b;\n    if(!c[a]){\n      if(!c[b]){\n      c[a]=i;\n      c[b]=i;\n      }\n      else c[a]=c[b];\n    }\n    else {\n      if(!c[b]){\n        c[b]=c[a];\n      } else {\n        for(int j=1;j<=n;j++) if(c[j]==c[b]) c[j]=c[a];\n      }\n    }\n  }\n  for(int i=1;i<=n;i++){\n    if(!c[i]) r1++;\n    else if(!flag[c[i]]){\n      flag[c[i]]=1;\n      r0++;\n    }\n  }\n  cout<<abs(r0-r1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 10000\nusing namespace std;\n\nint parent[pro+1];\n\nint find(int n){\n\tif(n==parent[n])return n;\n\telse find(parent[n]);\n}\n\nint abs(int n){\n\tif(n>0)return n;\n\telse return -1*n;\n}\n\nint main(){\n\tint n,m,city=0,town=0;\n\tcin>>n>>m;\n\tint a,b;\n\tloop(i,1,n+1)parent[i]=i;\n\trep(i,m){\n\t\tcin>>a>>b;\n\t\tparent[b]=find(a);\n\t}\n\tvector<int> vec[pro+1];\n\tloop(i,1,n+1){\n\t\tvec[parent[i]].push_back(i);\n\t}\n\tloop(i,1,n+1){\n\t\tif(vec[i].size()==1)town++;\n\t\tif(vec[i].size()>1) city++;\n\t}\n\tcout<<abs(city-town)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n#define ALL(c) (c).begin(), (c).end()\n#define REP(i,n) for(ll i=0; i < (n); ++i)\nusing ll = long long;\nusing vl = vector<ll>;\n\nstruct union_find{\n\tvl v;\n\tunion_find(ll n) : v(n, -1){}\n\tll find(ll x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(ll x, ll y){\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y];\n\t\tv[y] = x;\n\t}\n\tbool same(ll x, ll y){\n\t\treturn find(x) == find(y);\n\t}\n\tll size(ll x) { return -v[find(x)]; }\n};\n\nint main(){\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcout << fixed << setprecision(8);\n\n\tll n, m; cin >> n >> m;\n\tvl a(m), b(m);\n\tREP(i, m) cin >> a[i] >> b[i];\n\n\tunion_find uf(n);\n\tREP(i, m) uf.unite(a[i]-1, b[i]-1);\n\t\n\tll cntm = 0;\n\tll cnts = 0;\n\tREP(i, n){\n\t\tif (uf.size(i) == 1){\n\t\t\tcntm++;\n\t\t}\n\t\telse{\n\t\t\tif (uf.find(i) == i){\n\t\t\t\tcnts++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << abs(cntm - cnts) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\nstatic const int MAX_N = 1005;\n\n\nclass UF {\npublic:\n    int n, par[MAX_N];\n\n    void init(int pn) {\n        n = pn;\n        for (int i = 1; i <= n; ++i) {\n            par[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (x == par[x]) return x;\n\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n\n        par[x] = y;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nUF uf;\nint n, m;\n\nint temp[MAX_N];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m;\n    uf.init(n);\n\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        uf.unite(a, b);\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        int t = uf.find(i);\n        temp[t]++;\n    }\n\n    int city = 0, mura = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (1 < temp[i]) city++;\n        else if (temp[i] == 1) mura++;\n    }\n\n    cout << abs(mura - city) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nclass UF {\n\tpublic:\n\tstatic const int ufmax=100052;\n\tint ufpar[ufmax],ufrank[ufmax],ufcnt[ufmax];\n\tUF() { init();}\n\tvoid init(){int i; rep(i,ufmax) { ufpar[i]=i; ufrank[i]=0; ufcnt[i]=1; } }\n\tint find(int x) {\treturn (ufpar[x]==x)?(x):(ufpar[x] = find(ufpar[x]));}\n\tint operator[](int x) {return find(x);}\n\tint count(int x) {return ufcnt[find(x)];}\n\tvoid unite(int x,int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(ufrank[x]<ufrank[y]) ufpar[x]=y, ufcnt[y]+=ufcnt[x];\n\t\telse {ufpar[y]=x; ufcnt[x]+=ufcnt[y]; if(ufrank[x]==ufrank[y]) ufrank[x]++;}\n\t}\n};\n\n\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m;\n\tUF uf;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tuf.unite(a,b);\n\t}\n\tset<int> se;\n\tint a,b=0;\n\trep(i,n){\n\t\tif(i==uf[i]) b++;\n\t\telse se.insert(uf[i]);\n\t}\n\ta=se.size();\n\tb-=a;\n\tcout<<abs(a-b)<<endl;\n\t// cout<<a<<\" \"<<b<<endl;\n\t// cout<<abs((int)se.size()-(n-(int)se.size()))<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nint main(void){\n    int n, m; cin >> n >> m;\n\n    UnionFind uf(n);\n    set<int> used;\n    rep(loop, m){\n        int a, b; cin >> a >> b;\n        a--, b--;\n        used.insert(a), used.insert(b);\n\n        uf.unionSet(a, b);\n    }\n\n    set<int> roots;\n    rep(i, n){\n        if(used.find(i) == end(used)) continue;\n        roots.insert(uf.root(i));\n    }\n\n    int res = abs(n - (int)used.size() - (int)roots.size());\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nstruct UF{\n    int N;\n    vint par,sz;\n    void init(int n){\n        N=n;\n        par.resize(N);\n        sz.resize(N);\n        for(int i=0;i<N;i++)par[i]=i,sz[i]=1;\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\nint N,M;\nUF uf;\nsigned main(){\n    cin>>N>>M;\n    uf.init(N);\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        uf.unite(a,b);\n    }\n\n    int x=0,y=0;\n    rep(i,N)if(uf.find(i)==i){\n        if(uf.sz[uf.find(i)]==1)y++;\n        else x++;\n    }\n\n    cout<<abs(x-y)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint n,m,a[2],x,y;\nvector<int>v[1001];\nbool used[1001];\nint dfs(int p){\n  int res=1;\n  used[p]=1;\n  r(i,v[p].size()){\n    if(!used[v[p][i]]){\n      res+=dfs(v[p][i]);\n    }\n  }\n  return res;\n}\nint main(){\n  cin>>n>>m;\n  r(i,m){\n    cin>>x>>y;\n    x--,y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  r(i,n)if(!used[i])a[dfs(i)>=2]++;\n  cout<<abs(a[0]-a[1])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*   _/                _/                 _/_/_/   _/\n  _/_/_/_/   _/_/   _/_/_/_/   _/_/    _/       _/_/\n   _/     _/    _/   _/     _/    _/  _/_/_/     _/\n  _/     _/    _/   _/     _/    _/  _/    _/   _/\n   _/_/   _/_/       _/_/   _/_/      _/_/     _/ */\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\nusing namespace std;\nusing ll=long long;\nconst int MOD=1e9+7;\nconst double pi=3.14159265358979323846;\nconst int inf=2e9;\nconst ll INF=1e18;\nusing P=pair<int,int>;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint n,m,par[1005]={},ans=0,a,b;\nint find(int x) {\n  if(par[x]==x) {\n    return x;\n  }\n  return par[x]=find(par[x]);\n}\nbool same(int x,int y) {\n  return par[x]==par[y];\n}\nvoid unit(int x,int y) {\n  x=find(x),y=find(y);\n  if(x!=y) {\n    par[x]=y;\n  }\n}\nint main() {\n  cin.tie(0),cout.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  for(int i=1; i<=1000; i++) {\n    par[i]=i;\n  }\n  for(int i=0; i<m; i++) {\n    cin >> a >> b;\n    unit(a,b);\n  }\n  map<int,int> ma;\n  for(int i=1; i<=n; i++) {\n    ma[find(i)]++;\n  }\n  for(auto p:ma) {\n    if(p.second==1) {\n      ans++;\n    }\n    else {\n      ans--;\n    }\n  }\n  cout << abs(ans) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\nint main(){\n\n  int n,m,c[1001]={},flag[1001]={},r0=0,r1=0;\n  cin>>n>>m;\n  for(int i=1,a,b;i<=m;i++){\n    cin>>a>>b;\n    if(!c[a]&&!c[b]){\n      c[a]=i;\n      c[b]=i;\n    }\n    if(c[a]&&!c[b]) c[b]=c[a];\n    if(c[b]&&!c[a]) c[a]=c[b];\n    if(c[a]&&c[b]){\n      int tmp=c[b];\n      for(int j=1;j<=n;j++) if(c[j]==tmp) c[j]=c[a];\n    }\n  }\n  for(int i=1;i<=n;i++){\n    if(!c[i]) r1++;\n    else if(!flag[c[i]]){\n      flag[c[i]]=1;\n      r0++;\n    }\n  }\n  cout<<abs(r0-r1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n, m;\nint u[1000];\n\nint find(int i){\n  return u[i] == i ? i : u[i] = find(u[i]);\n}\nvoid unite(int a, int b){\n  u[find(a)] = find(b);\n}\n\nint main(){\n  cin >> n >> m;\n  rep(i, n){\n    u[i] = i;\n  }\n  rep(i, m){\n    int a, b;\n    cin >> a >> b;\n    unite(a - 1, b - 1);\n  }\n  map<int, int> x;\n  rep(i, n){\n    ++x[find(i)];\n  }\n  int p = 0;\n  for(auto& v: x){\n    if(v.second > 1){\n      ++p;\n    }\n    else{\n      --p;\n    }\n  }\n  cout << abs(p) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int size)\n  {\n    data.assign(size, -1);\n  }\n  int Find(int k)\n  {\n    if(data[k] < 0) return(k);\n    return(data[k] = Find(data[k]));\n  }\n  void unite(int x, int y)\n  {\n    x = Find(x);\n    y = Find(y);\n    if(x == y) return;\n    data[x] += data[y];\n    data[y] = x;\n  }\n  int Size(int k)\n  {\n    return(-data[Find(k)]);\n  }\n};\nint main()\n{\n  int N, M;\n  cin >> N >> M;\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int A, B;\n    cin >> A >> B;\n    --A, --B;\n    tree.unite(A, B);\n  }\n  int mura = 0;\n  int used[1000] = {};\n  for(int i = 0; i < N; i++) {\n    int K = tree.Find(i);\n    if(used[K]++) continue;\n    if(tree.Size(K) == 1) ++mura;\n    else --mura;\n  }\n  cout << abs(mura) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 10000\nusing namespace std;\n\nint parent[pro+1];\n\nint find(int n){\n\tif(n==parent[n])return n;\n\telse find(parent[n]);\n}\n\nint abs(int n){\n\tif(n>0)return n;\n\telse return -1*n;\n}\n\nint main(){\n\tint n,m,city=0,town=0;\n\tcin>>n>>m;\n\tint a,b;\n\trep(i,n)parent[i]=i;\n\trep(i,m){\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tparent[b]=parent[a]=find(a);\n\t}\n\tvector<int> vec[n];\n\trep(i,n){\n\t\tvec[find(i)].push_back(i);\n\t}\n\trep(i,n){\n\t\tif(vec[i].size()==1)town++;\n\t\tif(vec[i].size()>1) city++;\n\t}\n\tcout<<abs(city-town)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint group[1010];\nint parent(int i){\n\tif(i==group[i])\treturn i;\n\telse return group[i]=parent(group[i]);\n}\nvoid merge(int i,int j){\n\ti=parent(i);\tj=parent(j);\n\tgroup[i]=group[j];\n}\n\nint main(){\n\tint n;\tcin>>n;\n\tint m;\tcin>>m;\n\tfor(int i=1;i<=n;i++)\tgroup[i]=i;\n\tfor(int j=0;j<m;j++){\n\t\tint a,b;\tcin>>a>>b;\n\t\tmerge(a,b);\n\t}\n\tmap<int,int> kind;\n\tfor(int i=1;i<=n;i++)\tkind[parent(i)]++;\n\tint village=0,city=0;\n\tfor(auto it:kind){\n\t\tif(it.second==1)\tvillage++;\n\t\telse \tcity++;\n\t}\n\tcout<<abs(village-city)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint N, M;\nvector< vector< int > > adj;\nvector< bool > vis;\n\nvoid dfs(int v, int& cnt) {\n\tif (vis[v]) return;\n\tvis[v] = true;\n\t++cnt;\n\tfor (int u : adj[v]) dfs(u, cnt);\n}\n\nint main() {\n\tcin >> N >> M;\n\t\n\tadj.assign(N, vector< int >());\n\t\n\tfor_(i,0,M) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\t\n\tint A = 0, B = 0;\n\tvis.assign(N, false);\n\t\n\tfor_(v,0,N) {\n\t\tif (vis[v]) continue;\n\t\tint cnt = 0;\n\t\tdfs(v, cnt);\n\t\tif (cnt == 1) ++A;\n\t\telse ++B;\n\t}\n\t\n\tcout << abs(B - A) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 10000\nusing namespace std;\n\nint abs(int n){\n\tif(n>0)return n;\n\telse return -1*n;\n}\n\nint main(){\n\tint vi, town, info;\n\twhile(cin >> vi >> info){\n\t\ttown = 1;\n\t\tint check[1005] = {0};\n\t\trep(i,info){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tif(check[a] == check[b] && check[a] == 0){\n\t\t\t\tcheck[a] = check[b] = town;\n\t\t\t\ttown++;\n\t\t\t}else if(check[a] == 0 && check[b] != 0 ){\n\t\t\t\t\tcheck[a] = check[b];\n\t\t\t}else if(check[a] != 0 && check[b] == 0){\n\t\t\t\t\tcheck[b] = check[a];\n\t\t\t}else if(check[a] != check[b]){\n\t\t\t\tfor(int i = 1; i <= vi; i++){\n\t\t\t\t\tif(check[i] == check[a]) check[i] = check[b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0, c = 0;\n\t\tfor(int i = 1; i <= vi; i++){\n\t\t\tif(check[i] != 0 && check[i] != -1){\n\t\t\t\tc++;\n\t\t\t\tfor(int j = i + 1; j <= vi; j++){\n\t\t\t\t\tif(check[j] == check[i]) check[j] = -1;\n\t\t\t\t}\n\t\t\t}else if(check[i] == 0){\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tcout << abs(c - m) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\nstatic const int MAX_N = 10000;\ntypedef pair<int,int> PII;\n\nint par[MAX_N];\nint rank[MAX_N];\nint t[MAX_N];\nint temp[MAX_N];\nint n,m;\nint city;\n\nclass UF{\n    public:\n        void init(int n){\n            rep(i,n){\n                par[i]=i;\n                rank[i]=0;\n            }\n        }\n\n        int find(int x){\n            if(par[x]==x)return x;\n            return par[x]=find(par[x]);\n        }\n        void unite(int x,int y){\n            x=find(x);\n            y=find(y);\n            if(x==y)return;\n            if(rank[x]<rank[y])par[x]=y;\n            else {\n                par[y]=x;\n                if(rank[x]==rank[y])rank[x]++;\n            }\n        }\n\n        bool same(int x,int y){\n            return (find(x)==find(y));\n        }\n};\n\nint main(){\n    cin>>n>>m;\n    UF uf;\n    int val=n;\n    uf.init(n);\n    rep(i,m){\n        int a,b;\n        cin>>a>>b;\n        if(!t[a])val--;\n        if(!t[b])val--;\n        t[a]=t[b]=1;\n        uf.unite(a,b);\n    }\n    rep(i,n+1){\n        if(t[i]){\n            int p=uf.find(i);\n            if(!temp[p])city++;\n            temp[uf.find(i)]=1;\n        }\n    }\n    cout<<abs(val-city)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tUnionFind uf(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tuf.unionSet(a, b);\n\t}\n\tset<int>aset;\n\tint ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint num = uf.size(i);\n\t\tint root = uf.root(i);\n\t\tif (aset.find(root) == aset.end()) {\n\t\t\tif (num == 1)ans++;\n\t\t\telse ans--;\n\t\t\taset.emplace(root);\n\t\t}\n\t}\n\tcout << (abs(ans)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstruct unionfind{\n\tint par[1000],sz[1000];\n\tvoid init(int N){rep(i,N) par[i]=i,sz[i]=1;}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tpar[y]=x;\n\t\tsz[x]+=sz[y];\n\t}\n}UF;\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\tUF.init(N);\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tUF.unite(a,b);\n\t}\n\tint x=0;\n\trep(i,N) if(UF.find(i)==i){\n\t\tif(UF.sz[i]==1) x++;\n\t\telse x--;\n\t}\n\tcout<<abs(x)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N;\nint boss[1000],height[1000];\nbool is_Integrated[1000];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\n\nint main(){\n\n\tint N,M;\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tis_Integrated[i] = false;\n\t}\n\n\tint a,b;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tunite(a,b);\n\t\tis_Integrated[a] = true;\n\t\tis_Integrated[b] = true;\n\t}\n\n\tint city_num = 0,village_num = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(is_Integrated[i] == true && get_boss(i) == i){\n\t\t\tcity_num++;\n\t\t}else if(is_Integrated[i] == false){\n\t\t\tvillage_num++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",abs(city_num-village_num));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<28;\n\nstruct union_find {\n  vector<int> rank_;\n  vector<int> size_;\n  vector<int> rid_;\n\n  union_find(int n) { rank_.resize(n); rid_.assign(n, -1); size_.resize(n, 1); }\n\n  void unite(int u, int v) {\n    u = root(u), v = root(v);\n    if(u == v) { return; }\n    size_[u] = size_[v] = size_[u] + size_[v];\n    if(rank_[u] < rank_[v]) { rid_[u] = v; }\n    else { rid_[v] = u; if(rank_[u] == rank_[v]) { rank_[u]++; } }\n  }\n\n  bool same(int u, int v) { return root(u) == root(v); }\n  int root(int x) { if(rid_[x] < 0) return x; else return rid_[x] = root(rid_[x]); }\n  int operator[](int x) { return root(x); }\n  int size_of(int x) { return size_[x]; }\n  \n};\n\nint main() {\n\n  int N, M; cin >> N >> M;\n\n  union_find uf(N);\n\n  rep(i, M) {\n    int s, t; cin >> s >> t; s--, t--;\n    uf.unite(s, t);\n  }\n\n  int vils = 0;\n  set<int> cities;\n\n  rep(i, N) {\n    if(uf.size_of(i) == 1) { vils ++; }\n    else { cities.insert(uf[i]); }\n  }\n\n  cout << abs(vils - (int)cities.size()) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntemplate<int N>\nstruct UF {\n    int ig[N];\n    vector<int> gi[N];\n    int gn;\n    void init(int n = N) {\n        for (int i = 0; i < n; i++) {\n            ig[i] = i;\n            gi[i] = {i};\n        }\n        gn = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        gn--;\n        int x = ig[a], y = ig[b];\n        if ((int)gi[x].size() < (int)gi[y].size()) swap(x, y);\n        for (int j: gi[y]) {\n            ig[j] = x;\n        }\n        gi[x].insert(gi[x].begin(), gi[y].begin(), gi[y].end());\n        gi[y].clear();\n    }\n    bool same(int a, int b) {\n        return ig[a] == ig[b];\n    }\n};\nconst int MN = 1010;\nUF<MN> uf;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    uf.init(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        uf.merge(a, b);\n    }\n    int A = 0, B = 0;\n    for (int i = 0; i < n; i++) {\n        if (uf.gi[i].size() == 0) continue;\n        if (uf.gi[i].size() == 1) B++;\n        else A++;\n    }\n    printf(\"%d\\n\", abs(A-B));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 10000\nusing namespace std;\n\nint abs(int n){\n\tif(n>0)return n;\n\telse return -1*n;\n}\n\nint main(){\n\tint vi, town, info;\n\twhile(cin >> vi >> info){\n\t\ttown = 1;\n\t\tint check[1005] = {0};\n\t\trep(i,info){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tif(check[a] == check[b] && check[a] == 0){\n\t\t\t\tcheck[a] = check[b] = town;\n\t\t\t\ttown++;\n\t\t\t}else if( (check[a] != check[b]) && (check[a] == 0 || check[b] == 0) ){\n\t\t\t\tif(check[a] == 0){\n\t\t\t\t\tcheck[a] = check[b];\n\t\t\t\t}else{\n\t\t\t\t\tcheck[b] = check[a];\n\t\t\t\t}\n\t\t\t}else if(check[a] != check[b]){\n\t\t\t\tfor(int i = 0; i < 1000; i++){\n\t\t\t\t\tif(check[i] == check[a]) check[i] = check[b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint m = 0, c = 0;\n\t\tfor(int i = 1; i <= vi; i++){\n\t\t\tif(check[i] != 0 && check[i] != -1){\n\t\t\t\tc++;\n\t\t\t\tfor(int j = i + 1; j <= vi; j++){\n\t\t\t\t\tif(check[j] == check[i]) check[j] = -1;\n\t\t\t\t}\n\t\t\t}else if(check[i] == 0){\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tcout << abs(c - m) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nint dat[125252];\nvoid init(){\n  REP(i,125252)dat[i]=-1;\n}\nint root(int x){\n  return dat[x]<0 ? x : (dat[x]=root(dat[x]));\n}\nvoid unite(int x,int y){\n  x=root(x);\n  y=root(y);\n  if(x!=y){\n    if(dat[x]>dat[y])swap(x,y);\n    dat[x] += dat[y];\n    dat[y] = x;\n  }\n}\nbool same(int x,int y){\n  return root(x)==root(y);\n}\nint size(int x){\n  return -dat[x];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n\n  init();\n  while(m--){\n    int a,b;\n    cin>>a>>b;\n    --a; --b;\n    unite(a,b);\n  }\n  int res = 0;\n  REP(i,n){\n    if(i!=root(i))continue;\n    if(size(i)==1)--res;\n    else ++res;\n  }\n  cout<<abs(res)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int size)\n  {\n    data.assign(size, -1);\n  }\n  int Find(int k)\n  {\n    if(data[k] < 0) return(k);\n    return(data[k] = Find(data[k]));\n  }\n  void unite(int x, int y)\n  {\n    x = Find(x);\n    y = Find(y);\n    if(x == y) return;\n    data[x] += data[y];\n    data[y] = x;\n  }\n  int Size(int k)\n  {\n    return(-data[Find(k)]);\n  }\n};\nint main()\n{\n  int N, M;\n  cin >> N >> M;\n  UnionFind tree(N);\n  for(int i = 0; i < M; i++) {\n    int A, B;\n    cin >> A >> B;\n    --A, --B;\n    tree.unite(A, B);\n  }\n  int mura = 0;\n  int used[100] = {};\n  for(int i = 0; i < N; i++) {\n    int K = tree.Find(i);\n    if(used[K]++) continue;\n    if(tree.Size(K) == 1) ++mura;\n    else --mura;\n  }\n  cout << abs(mura) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pro 10000\nusing namespace std;\n\nint parent[pro+1];\n\nint find(int n){\n\tif(n==parent[n])return n;\n\telse find(parent[n]);\n}\n\nint abs(int n){\n\tif(n>0)return n;\n\telse return -1*n;\n}\n\nint main(){\n\tint n,m,city=0,town=0;\n\tcin>>n>>m;\n\tint a,b;\n\tloop(i,1,n+1)parent[i]=i;\n\trep(i,m){\n\t\tcin>>a>>b;\n\t\tparent[b]=find(a);\n\t}\n\tvector<int> vec[pro+1];\n\tloop(i,1,n+1){\n\t\tvec[find(parent[i])].push_back(i);\n\t}\n\tloop(i,1,n+1){\n\t\tif(vec[i].size()==1)town++;\n\t\tif(vec[i].size()>1) city++;\n\t}\n\tcout<<abs(city-town)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nstruct Unionfind {\n  vector<int> size;\n  vector<int> par;\n  \n  Unionfind( int n ) :  size(n, 1), par(n) {\n    iota( par.begin() , par.end() , 0 );\n  }\n  \n  int find( int x ) {\n    if ( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n  \n  bool unite( int x , int y ) {\n    x = find(x);\n    y = find(y);\n    if ( x == y ) return false;\n    \n    if ( size[y] < size[x] ) swap( x , y );\n    \n    par[x] = y;\n    size[y] += size[x];\n    \n    return true;\n  }\n  \n  bool same( int x , int y ) {\n    return find(x) == find(y);\n  }\n};\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  Unionfind uf(n);\n  int x, y;\n  REP(i,q) {\n    cin >> x >> y;\n    uf.unite(x-1, y-1);\n  }\n  set<int> sum,ci;\n  REP(i,n){\n    if(uf.find(i)==i) sum.insert(i);\n    else ci.insert(uf.find(i));\n  }\n  cout << abs(int(sum.size())-2*int(ci.size())) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,s,e) for(int (i)=(s);(i)<(int)(e);(i)++)\n#define REP(i,e) FOR(i,0,e)\n#define RFOR(i,e,s) for(int (i)=(e)-1;(i)>=(int)(s);(i)--)\n#define RREP(i,e) RFOR(i,e,0)\n\n#define all(o) (o).begin(), (o).end()\n#define psb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef priority_queue<int> PQI;\ntypedef priority_queue<PII> PQII;\n\ntypedef struct edge_def {\n  int from;\n  int to;\n  int cost;\n\n  edge_def(int _from, int _to, int _cost) {\n    from = _from;\n    to   = _to;\n    cost = _cost;\n  };\n} edge;\n\nconst int INF = 1e9;\nconst int V = 1000;   //??????????????§??°\nconst int E = 100;  //???????????§??°\nint nv, ne;        //?????????????????°\nint usd[V];        //?¢??????????????????§????????¨\nvector<edge> es[V];  //dijkstra??¨(es[i].from == i)\n\nint dfs(int k) {\n  int res = 1;\n  usd[k] = 1;\n  REP(i,(int)es[k].size()) {\n    int nxt = es[k][i].to;\n    if (!usd[nxt]) res += dfs(nxt);\n  }\n  return res;\n}\n\nint main() {\n  scanf(\"%d%d \", &nv, &ne);\n  REP(i,nv) es[i].clear();\n  REP(i,ne) {\n    int a, b;\n    scanf(\"%d%d \", &a, &b);\n    a--; b--;\n    es[a].psb(edge(a,b,1));\n    es[b].psb(edge(b,a,1));\n  }\n\n  memset(usd, 0, sizeof(usd));\n  int prf=0, vlg=0;\n  REP(i,nv) {\n    if (!usd[i]) {\n      if (dfs(i)>1)\n        vlg++;\n      else\n        prf++;\n    }\n  }\n\n  printf(\"%d\\n\", abs(prf-vlg));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(int__)(k);i++)\n#define all(v) v.begin(),v.end()\n\nstruct UnionFind{\n    int n;\n    vector<int> p;\n    UnionFind(int nn) : n(nn+1){\n        p.resize(n);\n        rep(i, n) p[i] = i;\n    }\n    int root(int x){\n        if(p[x] == x) return x;\n        else return p[x] = root(p[x]);\n    }\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x != y) p[y] = x;\n    }\n    bool query(int x, int y){\n        return root(x) == root(y);\n    }\n};\n\n\nint main(){\n    int N, M; cin >> N >> M;\n    UnionFind ut(N);\n    set<int> absorbed;\n    rep(i, M){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        absorbed.insert(a);\n        absorbed.insert(b);\n        ut.unite(a, b);\n    }\n    set<int> city;\n    rep(i, N){\n        if(ut.root(i) != i) city.insert(ut.root(i));\n    }\n    int villedge = N - absorbed.size();\n    cout << abs(villedge - (int)city.size()) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint p[1000];\nint root(int x){\n\treturn p[x] < 0 ? x : p[x] = root(p[x]);\n}\n\nint main(){\n\tint n, m; cin >> n >> m;\n\tint c = 0, v = n;\n\trep(i, n) p[i] = -1;\n\trep(i, m){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tint ra = root(a), rb = root(b);\n\t\tif(ra == rb) continue;\n\t\tif(p[ra] == -1 && p[rb] == -1) c++, v -= 2;\n\t\tif(p[ra] != -1 && p[rb] != -1) c--;\n\t\tif(p[ra] != -1 && p[rb] == -1 || p[ra] == -1 && p[rb] != -1) v--;\n\t\tp[ra] += p[rb];\n\t\tp[rb] = ra;\n\t}\n\tcout << abs(c - v) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\n#define LL long long\n#define Fi first\n#define Se second\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\ntypedef pair<int,int> PII;\n\nint N,M;\nint flg[1010];\nPII V[1010];\nint cnt1;\nint cnt2;\nint main(){\n    cin>>N>>M;\n    cnt2=N;\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        flg[a]=1;\n        flg[b]=1;\n        V[i].Fi=max(a,b);\n        V[i].Se=min(a,b);\n    }\n    sort(V,V+M);\n    rep(i,M){\n        bool was=false;\n        rep(j,i){\n            if(V[i].Fi==V[j].Fi||V[i].Se==V[j].Fi){ was=true; break; }\n            if(V[i].Fi==V[j].Se||V[i].Se==V[j].Se){ was=true; break; }\n        }\n        if(!was)cnt1++;\n    }\n    //cout<<cnt1<<endl;\n    FOR(i,1,N){\n        if(flg[i])cnt2--;\n    }\n    cout<<abs(cnt1-cnt2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<=b;++i)\nusing namespace std;\nstatic const LL INF = 1LL<<61LL;\nstatic const int MAX_N = 10000;\ntypedef pair<int,int> PII;\n\nPII P[MAX_N];\nint par[MAX_N];\nint rank[MAX_N];\nint city[MAX_N];\nint t[MAX_N];\nint temp[MAX_N];\nint n,m;\nint ans;\n\nclass UF{\n    public:\n        void init(int n){\n            rep(i,n){\n                par[i]=i;\n                rank[i]=0;\n            }\n        }\n\n        int find(int x){\n            if(par[x]==x){\n                return x;\n            }\n            return par[x]=find(par[x]);\n        }\n        void unite(int x,int y){\n            x=find(x);\n            y=find(y);\n            if(x==y)return;\n            if(rank[x]<rank[y])par[x]=y;\n            else {\n                par[y]=x;\n                if(rank[x]==rank[y])rank[x]++;\n            }\n        }\n\n        bool same(int x,int y){\n            return (find(x)==find(y));\n        }\n};\n\nint main(){\n    cin>>n>>m;\n    UF uf;\n    int V=n;\n    uf.init(n);\n    rep(i,m){\n        int a,b;\n        cin>>a>>b;\n        if(!t[a])V--;\n        if(!t[b])V--;\n        t[a]=t[b]=1;\n        uf.unite(a,b);\n    }\n    int val=0;\n    rep(i,n+1){\n        if(t[i])temp[uf.find(i)]=1;\n    }\n    rep(i,n+1){\n        if(temp[i])val++;\n    }\n    ans=abs(val-V);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    vector<vector<int>> G(n);\n    rep(i,m){\n        int a,b;\n        cin >>a >>b;\n        --a;\n        --b;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n\n    int ans = 0;\n    vector<bool> vis(n);\n    rep(i,n)if(!vis[i]){\n        int cc = 0;\n        queue<int> que;\n        que.push(i);\n        vis[i] = true;\n        ++cc;\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(int e:G[v]){\n                if(!vis[e]){\n                    que.push(e);\n                    vis[e] = true;\n                    ++cc;\n                }\n            }\n        }\n\n        if(cc==1) ++ans;\n        else --ans;\n    }\n    cout << abs(ans) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvi in(n);\n\trep(i,n)in[i]=i;\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tint d=in[b];\n\t\tin[b]=in[a];\n\t\trep(i,n)if(d==in[i])in[i]=in[a];\n\t}\n\tvi q(n,0);\n\trep(i,n)q[in[i]]++;\n\tint co1=0,co2=0;\n\trep(i,n)if(q[i]==1)co1++;\n\telse if(q[i]>1)co2++;\n\tcout<<abs(co2-co1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct UnionFind{\n  vector<int>parent,sizes;\n  UnionFind(int n):parent(n),sizes(n,1){\n    for(int i=0;i<n;++i)parent[i]=i;\n  }\n  int find(int x){\n    if(x==parent[x])return x;\n    return parent[x]=find(parent[x]);\n  }\n  void unite(int x,int y){\n    x=find(x),y=find(y);\n    if(x==y)return;\n    if(sizes[x]>sizes[y])swap(x,y);\n    parent[y]=x;\n    sizes[x]+=sizes[y];\n    sizes[y]=0;\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  int size(int x){\n    return sizes[find(x)];\n  }\n};\nmain(){\n  int n,m,a,b,x=0,y=0;\n  cin>>n>>m;\n  UnionFind UF(n);\n  for(int i=0;i++<m;UF.unite(--a,--b))cin>>a>>b;\n  for(int i=0;i<n;++i)UF.sizes[i]>1?x++:UF.sizes[i]-1?:y++;\n  cout<<abs(x-y)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n#define ALL(c) (c).begin(), (c).end()\n#define REP(i,n) for(ll i=0; i < (n); ++i)\nusing ll = long long;\nusing vl = vector<ll>;\n\nstruct union_find{\n\tvl v;\n\tunion_find(ll n) : v(n, -1){}\n\tll find(ll x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(ll x, ll y){\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y];\n\t\tv[y] = x;\n\t}\n\tbool same(ll x, ll y){\n\t\treturn find(x) == find(y);\n\t}\n\tll size(ll x) { return -v[find(x)]; }\n};\n\nint main(){\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcout << fixed << setprecision(8);\n\n\tll n, m; cin >> n >> m;\n\tvl a(n), b(n);\n\tREP(i, m) cin >> a[i] >> b[i];\n\n\tunion_find uf(n);\n\tREP(i, m) uf.unite(a[i]-1, b[i]-1);\n\t\n\tll cntm = 0;\n\tll cnts = 0;\n\tREP(i, n){\n\t\tif (uf.size(i) == 1){\n\t\t\tcntm++;\n\t\t}\n\t\telse{\n\t\t\tif (uf.find(i) == i){\n\t\t\t\tcnts++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << abs(cntm - cnts) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nstruct UnionFind{\n    vector<int> r, p;\n    UnionFind() {}\n    UnionFind(int size) { init(size); }\n    void init(int size) {\n        r.resize(size, 0);\n        p.resize(size, 0);\n        for ( int i = 0; i < size; i++ ) r[i] = 1,p[i] = i;\n    }\n    int find(int x) {\n        return (x == p[x] ? x : p[x] = find(p[x]));\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if ( x == y ) return;\n        if( r[x] < r[y] ) swap(x, y);\n        r[x] += r[y];\n        p[y] = x;\n    }\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n\n    UnionFind uf(N);\n    Rep(i, M) {\n        int a, b;\n        cin >> a >> b;\n        uf.unite(--a, --b);\n    }\n\n    bool used[1001] = {0};\n    int v = 0, c = 0;\n    Rep(i, N) {\n        bool flag = false;\n        if ( used[i] ) continue;\n        Rep(j, N) {\n            if ( i == j ) continue;\n            if ( uf.same(i, j) ) {\n                if ( !flag ) c++;\n                flag = true;\n                used[i] = used[j] = true;\n            }\n        }\n    }\n\n    Rep(i, N) if ( !used[i] ) v++;\n    //cout << v << \" \" << c << endl;\n    cout << abs(v - c) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct UF {\n    vi data;\n    void init(int n)\n    {\n        data.resize(n);\n        fill(all(data), -1);\n    }\n    int root(int x)\n    {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    void unite(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (size(x) < size(y)) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n    }\n    bool same(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    int size(int x)\n    {\n        return -data[x];\n    }\n    bool is_root(int x)\n    {\n        return x == root(x);\n    }\n};\n\nUF uf;\n\nint main()\n{\n    omajinai;\n\n    int N, M; cin >> N >> M;\n\n    uf.init(N + 1);\n\n    rep1(i, M) {\n        int a, b; cin >> a >> b;\n        uf.unite(a, b);\n    }\n\n    int city = 0, village = 0;\n\n    rep1(i, N) {\n        if (uf.is_root(i)) {\n            (uf.size(i) > 1 ? city : village)++;\n        }\n    }\n\n    cout << abs(city - village) << endl;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.List\nimport Data.Vector.Unboxed (Vector, (!), (//))\nimport qualified Data.Vector.Unboxed as V\nimport Data.Vector.Unboxed.Mutable (IOVector, STVector)\nimport qualified Data.Vector.Unboxed.Mutable as VM\n\nmain :: IO ()\nmain = do\n  [n, m] <- f\n  solve n <$> replicateM m f >>= print\n  where\n    f = map read <$> words <$> getLine\n\nsolve :: Int -> [[Int]] -> Int\nsolve n vss = abs . uncurry subtract . foldl' f (0, 0) $ [1..n]\n  where\n    f (c, v) i\n      | tr ! i == (-1) = (c, v+1)\n      | tr ! i < (-1) = (c+1, v)\n      | otherwise = (c, v)\n    tr = runST $ do\n      tr <- VM.replicate (n+1) (-1) :: ST s (STVector s Int)\n      forM_ vss $ \\[x, y] -> do\n        unite tr x y\n      V.freeze tr\n\nroot :: STVector s Int -> Int -> ST s (Int, Int)\nroot tr i = do\n  p <- VM.read tr i\n  if p < 0\n    then return (p, i)\n    else do\n      (c, p') <- root tr p\n      VM.write tr i p'\n      return (c, p')\n\nunite :: STVector s Int -> Int -> Int -> ST s ()\nunite tr i j = do\n  (ci, pi) <- root tr i\n  (cj, pj) <- root tr j\n  unless (pi == pj) $ do\n    if ci < cj\n      then do\n        VM.write tr pj pi\n        VM.write tr pi (ci + cj)\n      else do\n        VM.write tr pi pj\n        VM.write tr pj (ci + cj)\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1576: Community Integration\n// 2017.10.23 bal4u@uu\n\n#include <stdio.h>\n\n#define ABS(a) ((a)>=0?(a):-(a))\n\n#define MAX 1001\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\nint f[MAX];\n\nint main() \n{\n\tint n, m, i, a, b;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; i++) make_set(i);\n\twhile (m-- > 0) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tunion_set(a, b);\n\t}\n\tfor (i = 1; i <= n; i++) f[find_set(i)]++;\n\tfor (a = b = 0, i = 1; i <= n; i++) {\n\t\tif (f[i] == 1) a++; else if (f[i] > 1) b++;\n\t}\n\tprintf(\"%d\\n\", ABS(a-b));\n\treturn 0; \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int p[1010]={0};\n  int d[1010]={0};\n  int i,a,b,c=0,v=0,n,m;\n  scanf(\"%d %d\",&n,&m);\n  while(m--){\n    scanf(\"%d %d\",&a,&b);\n    for(;p[a];a=p[a]);\n    for(;p[b];b=p[b]);\n    if(a==b)continue;\n    if(d[a]> d[b])p[b]=a;\n    if(d[a]<=d[b])p[a]=b;\n    if(d[a]==d[b])d[b]++;\n  }\n  for(i=1;i<=n;i++){\n    //printf(\"%d %d %d\\n\",i,p[i],d[i]);\n    if(p[i])continue;\n    d[i]?c++:v++;\n  }\n  printf(\"%d\\n\",abs(c-v));    \n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tUnionFindTree uft = new UnionFindTree(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t    uft.unite(sc.nextInt() - 1, sc.nextInt() - 1);\n\t\t}\n\t\tHashSet<Integer> cities = new HashSet<>();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t    int x = uft.find(i);\n\t\t    if (i != x) {\n\t\t        cities.add(x);\n\t\t    } else {\n\t\t        count++;\n\t\t    }\n\t\t}\n\t\tint cityCount = cities.size();\n\t\tint vilCount = count - cityCount;\n\t\tSystem.out.println(Math.abs(cityCount - vilCount));\n\t}\n\t\n\tstatic class UnionFindTree {\n\t    int[] parents;\n\t    \n\t    public UnionFindTree(int size) {\n\t        parents = new int[size];\n\t        for (int i = 0; i < size; i++) {\n\t            parents[i] = i;\n\t        }\n\t    }\n\t    \n\t    public int find(int x) {\n\t        if (parents[x] == x) {\n\t            return x;\n\t        } else {\n\t            return parents[x] = find(parents[x]);\n\t        }\n\t    }\n\t    \n\t    public void unite(int x, int y) {\n\t        int xx = find(x);\n\t        int yy = find(y);\n\t        if (xx == yy) {\n\t            return;\n\t        }\n\t        parents[xx] = yy;\n\t    }\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1157().doIt();\n    }\n    class aoj1157{\n    \tclass UnionFind{\n    \t\tint [] par,rank;\n    \t\tint num;\n    \t\tpublic UnionFind(int n){\n    \t\t\tpar = new int[n];\n    \t\t\trank = new int[n];\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tpar[i] = i;\n    \t\t\t\trank[i] = 0;\n    \t\t\t}\n    \t\t\tnum = n;\n    \t\t}\n    \t\tint find(int x){\n    \t\t\tif(par[x] == x)return x;\n    \t\t\telse return par[x] = find(par[x]);\n    \t\t}\n    \t\tvoid unite(int x,int y){\n    \t\t\tx = find(x);\n    \t\t\ty = find(y);\n    \t\t\tif(x == y)return;\n    \t\t\tif(rank[x] < rank[y])par[x] = y;\n    \t\t\telse{\n    \t\t\t\tpar[y] = x;\n    \t\t\t\tif(rank[x] == rank[y])rank[x]++;\n    \t\t\t}\n    \t\t\tnum--;\n    \t\t}\n    \t\tboolean same(int x,int y){\n    \t\t\treturn find(x) == find(y);\n    \t\t}\n    \t}\n        void doIt(){\n        \tint n = sc.nextInt();\n        \tint m = sc.nextInt();\n        \tint num[] = new int[n+1];\n        \tUnionFind uf = new UnionFind(n+1);\n        \tfor(int i = 0;i < m;i++){\n        \t\tint s = sc.nextInt();\n        \t\tint g = sc.nextInt();\n        \t\tuf.unite(s,g);\n        \t}\n        \tfor(int i = 1;i < n+1;i++){\n        \t\tnum[uf.find(i)]++;\n        \t}\n        \tint S = 0;\n        \tint V = 0;\n        \tfor(int i = 1;i < n+1;i++){\n        \t\tif(num[i] == 1)V++;\n        \t\telse if(num[i] > 1)S++;\n        \t}\n        \tSystem.out.println(Math.abs(V-S));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main{\n\tint N,M;\n\tint[] union,rank;\n\tboolean[] used;\n\n\tpublic boolean same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tpublic int find(int x){\n\t\tif(union[x] == x)return x;\n\t\treturn union[x] = find(union[x]);\n\t}\n\n\tpublic void unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif(x == y)return;\n\n\t\tif(x < y){\n\t\t\tunion[y] = x;\n\t\t\trank[x] += rank[y];\n\t\t}else{\n\t\t\tunion[x] = y;\n\t\t\trank[y] += rank[x];\n\t\t}\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\n\t\tunion = new int[N];\n\t\trank = new int[N];\n\t\tused = new boolean[N];\n\t\tfor(int i = 0;i < N;i++)union[i] = i;\n\t\tArrays.fill(rank, 1);\n\n\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tint a = nextInt()-1;\n\t\t\tint b = nextInt()-1;\n\n\t\t\tunite(a,b);\n\t\t}\n\n\t\tint big = 0;\n\t\tint small = 0;\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tint root = find(i);\n\t\t\tif(used[root])continue;\n\t\t\tused[root] = true;\n\n\t\t\tif(rank[root] == 1)small++;\n\t\t\telse big++;\n\t\t}\n\n\t\tout.println(Math.abs(big-small));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\ng = {}\nm.times do\n    i, j = gets.split.map(&:to_i)\n    (g[i] ||= Set.new) << j\n    (g[j] ||= Set.new)  << i\nend\n\ncomponent = {}\nc = 0\n(1..n).each do |i|\n    next if !g[i] || component[i]\n    queue = [i]\n    component[i] = c\n    until queue.empty?\n        j = queue.shift\n        g[j].each do |k|\n            if ! component[k]\n                component[k] = c\n                queue << k\n            end\n        end\n    end\n    c += 1\nend\n\np (c - ((1..n).to_a - component.keys).size).abs\n\n"
  },
  {
    "language": "Ruby",
    "code": "n, m = gets.chomp.split.map(&:to_i)\nparent = (0...n).to_a\nm.times{\n    a, b = gets.chomp.split.map{|x| x.to_i - 1}\n    pa = a\n    pa = parent[pa] while pa != parent[pa]\n    pb = b\n    pb = parent[pb] while pb != parent[pb]\n    x, y = [pa, pb].minmax\n    parent[y] = x\n}\nn.times{|a|\n    pa = a\n    pa = parent[pa] while pa != parent[pa]\n    parent[a] = pa    \n}\nh = Hash.new(0)\nparent.each{|p| h[p] += 1}\nshi = mura = 0\nh.each{|k, v|\n    if v == 1\n        mura += 1\n    else\n        shi += 1\n    end\n}\nputs (shi - mura).abs\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"strconv\"\n    \"os\"\n    \"strings\"\n    \"math\"\n)\n\nvar rdr = bufio.NewReaderSize(os.Stdin, 1000000)\n\nfunc readLine() string {\n    buf := make([]byte, 0, 1000000)\n    for {\n        l, p, e := rdr.ReadLine()\n        if e != nil {\n            panic(e)\n        }\n        buf = append(buf, l...)\n        if !p {\n            break\n        }\n    }\n    return string(buf)\n}\n\nfunc toInt(str string) int  {\n    n, _ := strconv.Atoi(str)\n    return n\n}\n\nfunc abs(a int) int {\n    return int(math.Abs(float64(a)))\n}\n\nfunc getPar(x int, parent[1000]int) int {\n    if parent[x] == x {\n        return x\n    } else {\n        parent[x] = getPar(parent[x], parent)\n        return parent[x]\n    }\n}\n\nfunc main() {\n    nm := strings.Split(readLine(), \" \")\n    n := toInt(nm[0])\n    m := toInt(nm[1])\n    var parent [1000]int\n    for i := 0;i < n; i++ {\n        parent[i] = i\n    }\n\n\n    for i := 0; i < m; i++ {\n        ab := strings.Split(readLine(), \" \")\n        pa := getPar(toInt(ab[0]) - 1, parent)\n        pb := getPar(toInt(ab[1]) - 1, parent)\n        parent[pb] = pa\n    }\n\n    cities := make(map[int]int)\n    villageCnt := 0\n    for i := 0;i < n; i ++ {\n        pi := getPar(i, parent)\n        if i != pi {\n            cities[pi] = 1\n        } else {\n            villageCnt ++\n        }\n    }\n    cityCnt := len(cities)\n    fmt.Println(abs(cityCnt * 2 - villageCnt))\n}\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport array\n\n\nclass UnionFind(object):\n\n    def __init__(self, number_of_nodes, typecode=\"L\"):\n        self.typecode = typecode\n        self.par = array.array(typecode, range(number_of_nodes))\n        self.rank = array.array(typecode, (0 for i in range(number_of_nodes)))\n\n    def root(self, node):\n        if self.par[node] == node:\n            return node\n        else:\n            r = self.root(self.par[node])\n            self.par[node] = r\n            return r\n\n    def in_the_same_set(self, node1, node2):\n        return self.root(node1) == self.root(node2)\n\n    def unite(self, node1, node2):\n        x = self.root(node1)\n        y = self.root(node2)\n        if x == y:\n            pass\n        elif self.rank[x] < self.rank[y]:\n            self.par[x] = y\n        else:\n            self.par[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n\ndef main():\n    n, m = map(int, input().split())\n    uf = UnionFind(n, \"I\")\n    for _ in range(m):\n        a, b = map(lambda x: int(x) - 1, input().split())\n        uf.unite(a, b)\n    city_representatives = set()\n    num_cities_and_villages = 0\n    for i in range(n):\n        rep = uf.root(i)\n        if i == rep:\n            num_cities_and_villages += 1\n        else:\n            city_representatives.add(rep)\n    num_cities = len(city_representatives)\n    answer = abs(num_cities_and_villages - 2 * num_cities)\n    print(answer)\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# AOJ 1576: Community Integration\n# Python3 2018.7.13 bal4u\n\n# UNION-FIND library\nclass UnionSet:\n\tdef __init__(self, nmax):\n\t\tself.size = [1]*nmax\n\t\tself.id = [i for i in range(nmax+1)]\n\tdef root(self, i):\n\t\twhile i != self.id[i]:\n\t\t\tself.id[i] = self.id[self.id[i]]\n\t\t\ti = self.id[i]\n\t\treturn i\n\tdef connected(self, p, q): return self.root(p) == self.root(q)\n\tdef unite(self, p, q):\n\t\ti, j = self.root(p), self.root(q)\n\t\tif i == j: return\n\t\tif self.size[i] < self.size[j]:\n\t\t\tself.id[i] = j\n\t\t\tself.size[j] += self.size[i]\n\t\telse:\n\t\t\tself.id[j] = i\n\t\t\tself.size[i] += self.size[j]\n# UNION-FIND library\n\nN, M = map(int, input().split())\nu = UnionSet(N+1)\nf = [0]*(N+1)\nfor i in range(M):\n\ta, b = map(int, input().split())\n\tu.unite(a, b)\nfor i in range(1, N+1): f[u.root(i)] += 1\na = b = 0\nfor i in range(1, N+1):\n\tif f[i] == 1: a += 1\n\telif f[i] > 1: b += 1\nprint(abs(a-b))\n"
  },
  {
    "language": "Python",
    "code": "[m,n] = map(int,input().split())\n\ndef find(v,cs):\n    for c in cities:\n        if v in c:\n            return (True,c)\n    return (False,set([v]))\n\ncities = []\nfor _ in range(n):\n    [a,b] = map(int,input().split())\n\n    (ra,fa) = find(a,cities)\n    (rb,fb) = find(b,cities)\n\n    mg = fa | fb\n\n    if ra:\n        cities.remove(fa)\n    else:\n        m = m - 1\n    if rb:\n        if fa != fb:\n            cities.remove(fb)\n    else:\n        m = m - 1\n    cities.append(mg)\n\nprint(abs(m-len(cities)))\n\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\nparent = [i for i in range(n)]\n\ndef get_par(x):\n    if x == parent[x]:return x\n    parent[x] = get_par(parent[x])\n    return parent[x]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    pa, pb = get_par(a), get_par(b)\n    parent[pb] = pa\n\ncity_dic = set()\nvillage_cnt = 0\nfor i in range(n):\n    pi = get_par(i)\n    if i == pi:village_cnt += 1\n    else:city_dic.add(pi)\n\nprint(abs(2 * len(city_dic) - village_cnt))\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, input().split())\nq = []\nfor _ in range(m):\n    a, b = map(int, input().split())\n    i, j = -1, -1\n    for k in range(len(q)):\n        if i == -1:\n            if a in q[k]:\n                i = k\n        if j == -1:\n            if b in q[k]:\n                j = k\n        if i >= 0 and j >= 0:\n            break\n    if i >= 0:\n        if j >= 0:\n            if i != j:\n                q[i] |= q[j]\n                q.pop(j)\n        else:\n            q[i].add(b)\n    elif j >= 0:\n        q[j].add(a)\n    else:\n        q.append(set([a, b]))\nprint(abs(n - sum([len(i) for i in q]) - len(q)))\n"
  },
  {
    "language": "Python",
    "code": "[m,n] = map(int,input().split())\n\ndef find(v,cs):\n    for c in cities:\n        if v in c:\n            return (True,c)\n    return (False,set([v]))\n\ncities = []\nfor _ in range(n):\n    [a,b] = map(int,input().split())\n\n    (ra,fa) = find(a,cities)\n    (rb,fb) = find(b,cities)\n\n    mg = fa | fb\n\n    print(fa)\n\n    if ra:\n        cities.remove(fa)\n    else:\n        m = m - 1\n    if rb:\n        if fa != fb:\n            cities.remove(fb)\n    else:\n        m = m - 1\n    cities.append(mg)\n\nprint(abs(m-len(cities)))\n\n"
  }
]