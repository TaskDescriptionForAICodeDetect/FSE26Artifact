[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint parent[100001];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSets(int a, int b) {\n    int rootA = find(a);\n    int rootB = find(b);\n    if (rootA != rootB) {\n        parent[rootB] = rootA;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        unionSets(a, b);\n    }\n\n    int municipalities = 0;\n    for (int i = 1; i <= N; i++) {\n        if (parent[i] == i) {\n            municipalities++;\n        }\n    }\n\n    printf(\"%d\\n\", abs(N - municipalities));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_set(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        parent[rootY] = rootX;\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    parent.resize(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        parent[i] = i;\n    }\n    \n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        union_set(a, b);\n    }\n    \n    int municipalities = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (parent[i] == i) {\n            municipalities++;\n        }\n    }\n    \n    cout << abs(N - municipalities) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class VillageMerger {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        UnionFind uf = new UnionFind(N);\n        \n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            uf.union(a, b);\n        }\n        \n        int municipalities = uf.count();\n        int difference = Math.abs(N - municipalities);\n        System.out.println(difference);\n    }\n    \n    static class UnionFind {\n        private int[] parent;\n        private int[] rank;\n        private int count;\n        \n        public UnionFind(int size) {\n            parent = new int[size + 1];\n            rank = new int[size + 1];\n            count = size;\n            \n            for (int i = 1; i <= size; i++) {\n                parent[i] = i;\n                rank[i] = 1;\n            }\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n                count--;\n            }\n        }\n        \n        public int count() {\n            return count;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:01:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class VillageMerger {\n    static int[] parent;\n    static int[] rank;\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return;\n        \n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n\n    public static int solve(int N, int[][] merges) {\n        parent = new int[N + 1];\n        rank = new int[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n        \n        for (int[] merge : merges) {\n            union(merge[0], merge[1]);\n        }\n        \n        Set<Integer> municipalities = new HashSet<>();\n        for (int i = 1; i <= N; i++) {\n            municipalities.add(find(i));\n        }\n        \n        return Math.abs(N - municipalities.size());\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        int[][] merges = new int[M][2];\n        for (int i = 0; i < M; i++) {\n            merges[i][0] = scanner.nextInt();\n            merges[i][1] = scanner.nextInt();\n        }\n        \n        System.out.println(solve(N, merges));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:02:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100001\n\nint parent[MAX_N];\nint rank[MAX_N];\n\nvoid makeSet(int n) {\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint findSet(int x) {\n    if (parent[x] != x) {\n        parent[x] = findSet(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int rootX = findSet(x);\n    int rootY = findSet(y);\n    \n    if (rootX == rootY) return;\n    \n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    makeSet(N);\n    \n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        unionSet(a, b);\n    }\n    \n    int municipalities = 0;\n    for (int i = 1; i <= N; i++) {\n        if (parent[i] == i) {\n            municipalities++;\n        }\n    }\n    \n    printf(\"%d\\n\", abs(N - municipalities));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n + 1);\n        rank.resize(n + 1, 0);\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) return;\n\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    UnionFind uf(N);\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        uf.unite(a, b);\n    }\n\n    int municipalities = 0;\n    vector<bool> counted(N + 1, false);\n\n    for (int i = 1; i <= N; i++) {\n        int root = uf.find(i);\n        if (!counted[root]) {\n            municipalities++;\n            counted[root] = true;\n        }\n    }\n\n    cout << abs(N - municipalities) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_parent(village, parent):\n    if parent[village] != village:\n        parent[village] = find_parent(parent[village], parent)\n    return parent[village]\n\ndef union(village1, village2, parent, rank):\n    root1 = find_parent(village1, parent)\n    root2 = find_parent(village2, parent)\n    \n    if root1 != root2:\n        if rank[root1] > rank[root2]:\n            parent[root2] = root1\n        elif rank[root1] < rank[root2]:\n            parent[root1] = root2\n        else:\n            parent[root2] = root1\n            rank[root1] += 1\n\ndef calculate_difference(N, merge_pairs):\n    parent = [i for i in range(N + 1)]\n    rank = [0] * (N + 1)\n    \n    for village1, village2 in merge_pairs:\n        union(village1, village2, parent, rank)\n    \n    municipality_count = sum(1 for i in range(1, N + 1) if parent[i] == i)\n    \n    return abs(N - municipality_count)\n\n# Example usage:\nN = 5\nmerge_pairs = [(1, 2), (2, 3), (4, 5)]\nprint(calculate_difference(N, merge_pairs))",
    "timestamp": "2025-08-13 04:35:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class VillageMerger {\n    public static void main(String[] args) {\n        int N = 5; // Example number of villages\n        List<int[]> mergePairs = Arrays.asList(\n            new int[]{1, 2},\n            new int[]{3, 4},\n            new int[]{4, 5}\n        );\n\n        System.out.println(findVillageMunicipalityDifference(N, mergePairs));\n    }\n\n    private static int findVillageMunicipalityDifference(int N, List<int[]> mergePairs) {\n        UnionFind unionFind = new UnionFind(N);\n        for (int[] pair : mergePairs) {\n            unionFind.union(pair[0], pair[1]);\n        }\n       \n        Set<Integer> municipalities = new HashSet<>();\n        for (int i = 1; i <= N; i++) {\n            municipalities.add(unionFind.find(i));\n        }\n\n        return Math.abs(N - municipalities.size());\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int n) {\n        parent = new int[n + 1];\n        rank = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    public void union(int u, int v) {\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            if (rank[pu] > rank[pv]) {\n                parent[pv] = pu;\n            } else if (rank[pu] < rank[pv]) {\n                parent[pu] = pv;\n            } else {\n                parent[pv] = pu;\n                rank[pu]++;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 04:35:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_N 1000\n\nint parent[MAX_N + 1];\nint rank[MAX_N + 1];\n\n// Find function for the union-find data structure\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\n// Union function for the union-find data structure\nvoid union_sets(int a, int b) {\n    int rootA = find(a);\n    int rootB = find(b);\n    if (rootA != rootB) {\n        if (rank[rootA] > rank[rootB]) {\n            parent[rootB] = rootA;\n        } else if (rank[rootA] < rank[rootB]) {\n            parent[rootA] = rootB;\n        } else {\n            parent[rootB] = rootA;\n            rank[rootA]++;\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Initialize the union-find structure\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    // Read the pairs and merge the corresponding sets\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        union_sets(u, v);\n    }\n\n    // Find the number of unique municipalities\n    int numMunicipalities = 0;\n    for (int i = 1; i <= N; i++) {\n        if (find(i) == i) {\n            numMunicipalities++;\n        }\n    }\n\n    // Calculate the absolute difference\n    int result = (N > numMunicipalities) ? (N - numMunicipalities) : (numMunicipalities - N);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:35:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_municipalities(N, mergers):\n    # Initialize parent array for disjoint set union\n    parent = list(range(N + 1))\n    \n    # Find function for disjoint set\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    # Union function for disjoint set\n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n    \n    # Perform mergers\n    for a, b in mergers:\n        union(a, b)\n    \n    # Count unique municipalities\n    municipalities = set(find(i) for i in range(1, N + 1))\n    \n    # Return absolute difference\n    return abs(N - len(municipalities))\n\n# Example usage\nN = 5\nmergers = [(1, 2), (2, 3), (4, 5)]\nprint(count_municipalities(N, mergers))",
    "timestamp": "2025-08-13 04:35:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_parent(parent, i):\n    if parent[i] != i:\n        parent[i] = find_parent(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, i, j):\n    i_root = find_parent(parent, i)\n    j_root = find_parent(parent, j)\n    if i_root == j_root:\n        return\n    if rank[i_root] < rank[j_root]:\n        parent[i_root] = j_root\n    else:\n        parent[j_root] = i_root\n        if rank[i_root] == rank[j_root]:\n            rank[i_root] += 1\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    parent = [i for i in range(N + 1)]\n    rank = [0] * (N + 1)\n    \n    for _ in range(M):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        union(parent, rank, a, b)\n    \n    municipalities = set()\n    for i in range(1, N + 1):\n        municipalities.add(find_parent(parent, i))\n    \n    num_municipalities = len(municipalities)\n    print(abs(N - num_municipalities))\n\nsolve()",
    "timestamp": "2025-08-13 04:36:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n, 1), count(n) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unify(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            count--;\n        }\n    }\n\n    int getCount() const {\n        return count;\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    int count;\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    UnionFind uf(N);\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        uf.unify(u - 1, v - 1);\n    }\n\n    int municipalities = uf.getCount();\n    int result = abs(N - municipalities);\n    \n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:20:28"
  }
]