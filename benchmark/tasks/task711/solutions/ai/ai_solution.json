[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\ntypedef struct {\n    int V;\n    Node** adjList;\n} Graph;\n\nGraph* createGraph(int V) {\n    Graph* graph = malloc(sizeof(Graph));\n    graph->V = V;\n    graph->adjList = malloc(V * sizeof(Node*));\n    for (int i = 0; i < V; i++)\n        graph->adjList[i] = NULL;\n    return graph;\n}\n\nvoid addEdge(Graph* graph, int src, int dest) {\n    Node* newNode = malloc(sizeof(Node));\n    newNode->vertex = dest;\n    newNode->next = graph->adjList[src];\n    graph->adjList[src] = newNode;\n\n    newNode = malloc(sizeof(Node));\n    newNode->vertex = src;\n    newNode->next = graph->adjList[dest];\n    graph->adjList[dest] = newNode;\n}\n\nvoid dfs(Graph* graph, int v, int* visited, int* parent) {\n    visited[v] = 1;\n    for (Node* curr = graph->adjList[v]; curr; curr = curr->next) {\n        if (!visited[curr->vertex]) {\n            parent[curr->vertex] = v;\n            dfs(graph, curr->vertex, visited, parent);\n        }\n    }\n}\n\nint modInverse(int a, int m) {\n    int m0 = m, t, q;\n    int x0 = 0, x1 = 1;\n\n    if (m == 1) return 0;\n\n    while (a > 1) {\n        q = a / m;\n        t = m;\n        m = a % m, a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nint solve(int N, int edges[][2], int edgeCount) {\n    Graph* graph = createGraph(N);\n    for (int i = 0; i < edgeCount; i++)\n        addEdge(graph, edges[i][0], edges[i][1]);\n\n    int* visited = calloc(N, sizeof(int));\n    int* parent = calloc(N, sizeof(int));\n    for (int i = 0; i < N; i++)\n        parent[i] = i;\n\n    dfs(graph, 0, visited, parent);\n\n    int* color = malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++)\n        color[i] = rand() % 2;\n\n    int black_count = 0;\n    for (int i = 0; i < N; i++)\n        if (color[i] == 1)\n            black_count++;\n\n    if (black_count == 0)\n        return 0;\n\n    int* black_vertices = malloc(black_count * sizeof(int));\n    int idx = 0;\n    for (int i = 0; i < N; i++)\n        if (color[i] == 1)\n            black_vertices[idx++] = i;\n\n    int lca = black_vertices[0];\n    for (int i = 1; i < black_count; i++) {\n        int curr = black_vertices[i];\n        while (lca != curr) {\n            if (lca > curr)\n                lca = parent[lca];\n            else\n                curr = parent[curr];\n        }\n    }\n\n    int white_count = 0;\n    int curr = lca;\n    while (curr != parent[curr]) {\n        if (color[curr] == 0)\n            white_count++;\n        curr = parent[curr];\n    }\n\n    int prob_num = white_count;\n    int prob_den = 1;\n    for (int i = 0; i < N; i++)\n        prob_den *= 2;\n\n    int modInv = modInverse(prob_den, MOD);\n    int result = (prob_num * modInv) % MOD;\n\n    free(color);\n    free(black_vertices);\n    free(visited);\n    free(parent);\n    \n    return result;\n}",
    "timestamp": "2025-08-05 22:40:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAXN 200005\n\ntypedef long long ll;\n\nll inv(ll a, ll mod) {\n    ll res = 1;\n    ll exp = mod - 2;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        exp /= 2;\n    }\n    return res;\n}\n\nll size[MAXN], depth[MAXN], parent[MAXN];\nll sum_depth[MAXN], sum_size[MAXN];\nll fact[MAXN], inv_fact[MAXN];\nll *adj[MAXN];\nll cnt[MAXN], deg[MAXN];\n\nvoid dfs(ll u, ll p) {\n    size[u] = 1;\n    depth[u] = (p == -1) ? 0 : depth[p] + 1;\n    parent[u] = p;\n    sum_depth[u] = depth[u];\n    sum_size[u] = 1;\n    for (ll i = 0; i < deg[u]; ++i) {\n        ll v = adj[u][i];\n        if (v != p) {\n            dfs(v, u);\n            size[u] += size[v];\n            sum_depth[u] = (sum_depth[u] + sum_depth[v]) % MOD;\n            sum_size[u] = (sum_size[u] + sum_size[v]) % MOD;\n        }\n    }\n}\n\nll comb(ll n, ll k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    ll N;\n    scanf(\"%lld\", &N);\n\n    fact[0] = inv_fact[0] = 1;\n    for (ll i = 1; i <= N; ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n        inv_fact[i] = inv(fact[i], MOD);\n    }\n\n    for (ll i = 0; i < N; ++i) {\n        deg[i] = 0;\n        adj[i] = NULL;\n    }\n\n    for (ll i = 0; i < N - 1; ++i) {\n        ll u, v;\n        scanf(\"%lld %lld\", &u, &v);\n        u--; v--;\n        deg[u]++;\n        deg[v]++;\n    }\n\n    for (ll i = 0; i < N; ++i) {\n        adj[i] = (ll *)malloc(deg[i] * sizeof(ll));\n        cnt[i] = 0;\n    }\n\n    ll *temp_deg = (ll *)calloc(N, sizeof(ll));\n    for (ll i = 0; i < N - 1; ++i) {\n        ll u, v;\n        scanf(\"%lld %lld\", &u, &v);\n        u--; v--;\n        adj[u][temp_deg[u]++] = v;\n        adj[v][temp_deg[v]++] = u;\n    }\n    free(temp_deg);\n\n    dfs(0, -1);\n\n    ll total = 0;\n    for (ll u = 0; u < N; ++u) {\n        ll prob = (MOD + 1 - inv(1LL << size[u], MOD)) % MOD;\n        prob = (prob * inv(2, MOD)) % MOD;\n        ll contribution = (sum_size[u] - size[u] + MOD) % MOD;\n        total = (total + prob * contribution) % MOD;\n    }\n\n    ll denominator = inv(2, MOD);\n    denominator = inv(denominator, MOD);\n    ll numerator = total;\n    ll inv_denominator = inv(denominator, MOD);\n    ll result = numerator * inv_denominator % MOD;\n\n    printf(\"%lld\\n\", result);\n\n    for (ll i = 0; i < N; ++i) {\n        free(adj[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int inv2 = (MOD + 1) / 2;\n\nlong long power(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> parent(N + 1), depth(N + 1);\n    function<void(int, int)> dfs = [&](int u, int p) {\n        parent[u] = p;\n        for (int v : adj[u]) {\n            if (v != p) {\n                depth[v] = depth[u] + 1;\n                dfs(v, u);\n            }\n        }\n    };\n    dfs(1, 0);\n\n    long long total = 0;\n    for (int u = 1; u <= N; ++u) {\n        for (int v = u + 1; v <= N; ++v) {\n            int a = u, b = v;\n            while (a != b) {\n                if (depth[a] > depth[b]) a = parent[a];\n                else b = parent[b];\n            }\n            int lca = a;\n            int dist = depth[u] + depth[v] - 2 * depth[lca];\n            long long prob = power(inv2, dist + 1);\n            total = (total + prob) % MOD;\n        }\n    }\n\n    long long ans = (1LL * N * inv2 % MOD - total) % MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:40:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n    static List<Integer>[] tree;\n    static long[] inv;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        tree = new ArrayList[N + 1];\n        for (int i = 0; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            tree[u].add(v);\n            tree[v].add(u);\n        }\n\n        inv = new long[N + 2];\n        inv[1] = 1;\n        for (int i = 2; i <= N + 1; i++) {\n            inv[i] = MOD - MOD / i * inv[MOD % i] % MOD;\n        }\n\n        long[] pow2 = new long[N + 1];\n        pow2[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            pow2[i] = pow2[i - 1] * 2 % MOD;\n        }\n\n        long res = 0;\n        for (int u = 1; u <= N; u++) {\n            int degree = tree[u].size();\n            long term = (pow2[degree] - 1 - degree) % MOD;\n            term = term * inv[pow2[degree]] % MOD;\n            term = term * inv[2] % MOD;\n            res = (res + term) % MOD;\n        }\n        res = (res * pow2[N]) % MOD;\n        res = (res * inv(pow2[N])) % MOD;\n        System.out.println((res + MOD) % MOD);\n    }\n\n    static long inv(long x) {\n        return pow(x, MOD - 2);\n    }\n\n    static long pow(long x, long n) {\n        long res = 1;\n        while (n > 0) {\n            if (n % 2 == 1) {\n                res = res * x % MOD;\n            }\n            x = x * x % MOD;\n            n /= 2;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 22:41:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int MOD = 1_000_000_007;\n    private List<List<Integer>> graph;\n    private int[] color;\n    private int[] parent;\n    private int[] subtreeSize;\n    private boolean[] inSubtree;\n\n    public int expectedHoleyness(int N, int[][] edges) {\n        graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        color = new int[N];\n        parent = new int[N];\n        subtreeSize = new int[N];\n        inSubtree = new boolean[N];\n        \n        Random rand = new Random();\n        for (int i = 0; i < N; i++) {\n            color[i] = rand.nextInt(2);\n        }\n        \n        int root = findRoot();\n        dfs(root, -1);\n        \n        List<Integer> blackVertices = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            if (color[i] == 1) {\n                blackVertices.add(i);\n            }\n        }\n        \n        if (blackVertices.isEmpty()) {\n            return 0;\n        }\n        \n        int[] lca = findLCA(blackVertices);\n        \n        int holeyness = calculateHoleyness(lca[0]);\n        \n        return calculateModularInverse(holeyness, N);\n    }\n    \n    private int findRoot() {\n        return 0;\n    }\n    \n    private void dfs(int node, int parentNode) {\n        parent[node] = parentNode;\n        subtreeSize[node] = 1;\n        \n        for (int child : graph.get(node)) {\n            if (child != parentNode) {\n                dfs(child, node);\n                subtreeSize[node] += subtreeSize[child];\n            }\n        }\n    }\n    \n    private int[] findLCA(List<Integer> vertices) {\n        int[] ancestorSet = new int[vertices.size()];\n        for (int i = 0; i < vertices.size(); i++) {\n            ancestorSet[i] = vertices.get(i);\n        }\n        \n        while (ancestorSet.length > 1) {\n            List<Integer> newAncestorSet = new ArrayList<>();\n            for (int i = 0; i < ancestorSet.length; i += 2) {\n                if (i + 1 < ancestorSet.length) {\n                    int lca = findLowestCommonAncestor(ancestorSet[i], ancestorSet[i+1]);\n                    newAncestorSet.add(lca);\n                } else {\n                    newAncestorSet.add(ancestorSet[i]);\n                }\n            }\n            ancestorSet = newAncestorSet.stream().mapToInt(Integer::intValue).toArray();\n        }\n        \n        return new int[]{ancestorSet[0], 0};\n    }\n    \n    private int findLowestCommonAncestor(int u, int v) {\n        Set<Integer> ancestorsU = new HashSet<>();\n        while (u != -1) {\n            ancestorsU.add(u);\n            u = parent[u];\n        }\n        \n        while (v != -1) {\n            if (ancestorsU.contains(v)) {\n                return v;\n            }\n            v = parent[v];\n        }\n        \n        return -1;\n    }\n    \n    private int calculateHoleyness(int subtreeRoot) {\n        markSubtree(subtreeRoot);\n        \n        int whiteInSubtree = 0;\n        for (int i = 0; i < color.length; i++) {\n            if (inSubtree[i] && color[i] == 0) {\n                whiteInSubtree++;\n            }\n        }\n        \n        return whiteInSubtree;\n    }\n    \n    private void markSubtree(int node) {\n        inSubtree[node] = true;\n        \n        for (int child : graph.get(node)) {\n            if (child != parent[node]) {\n                markSubtree(child);\n            }\n        }\n    }\n    \n    private int calculateModularInverse(int holeyness, int totalNodes) {\n        long expected = (long) holeyness * (1L << (totalNodes - 1));\n        return (int) (expected % MOD);\n    }\n}",
    "timestamp": "2025-08-05 22:41:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    vector<vector<int>> graph;\n    vector<int> color;\n    int n;\n\n    int modInverse(int a, int m) {\n        int m0 = m;\n        int y = 0, x = 1;\n        \n        if (m == 1)\n            return 0;\n        \n        while (a > 1) {\n            int q = a / m;\n            int t = m;\n            \n            m = a % m;\n            a = t;\n            t = y;\n            \n            y = x - q * y;\n            x = t;\n        }\n        \n        if (x < 0)\n            x += m0;\n        \n        return x;\n    }\n\n    pair<int, int> dfs(int node, int parent) {\n        int subtree_black = (color[node] == 1);\n        int white_count = 0;\n        \n        for (int child : graph[node]) {\n            if (child == parent) continue;\n            \n            auto [child_black, child_white] = dfs(child, node);\n            \n            if (child_black) {\n                subtree_black |= 1;\n                white_count += child_white;\n            }\n        }\n        \n        return {subtree_black, subtree_black ? white_count + (color[node] == 0) : 0};\n    }\n\n    int solve(vector<vector<int>>& edges) {\n        n = edges.size() + 1;\n        graph.resize(n);\n        color.resize(n, 0);\n        \n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        int black_vertex_count = 0;\n        for (int i = 0; i < n; i++) {\n            color[i] = rand() % 2;\n            black_vertex_count += color[i];\n        }\n        \n        if (black_vertex_count == 0) return 0;\n        \n        int total_white = 0;\n        for (int root = 0; root < n; root++) {\n            auto [subtree_black, white_subtree] = dfs(root, -1);\n            total_white += white_subtree;\n        }\n        \n        int expected_white = total_white / (1 << n);\n        int x = 1 << n;\n        int y = expected_white;\n        \n        int inv = modInverse(x, MOD);\n        return (1LL * y * inv) % MOD;\n    }\n};",
    "timestamp": "2025-08-05 22:41:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef mul_inv(a, b):\n    b0, x0, x1 = b, 0, 1\n    if b == 1:\n        return 1\n    while a > 1:\n        q = a // b\n        a, b = b, a % b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0:\n        x1 += b0\n    return x1\n\ndef num_black(tot_vertices):\n    return pow(2, tot_vertices, MOD)\n\ndef expected_holeyness(T, N):\n    dp = [[0, 0] for _ in range(N)]  \n    size = [0] * N\n    adj = [[] for _ in range(N)]\n    \n    for u, v in T:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    def dfs(u, parent):\n        size[u] = 1\n        tot_black_u = 1\n        tot_white_u = 1\n        for v in adj[u]:\n            if v == parent:\n                continue\n            dfs(v, u)\n            size[u] += size[v]\n            tot_black_u = (tot_black_u * num_black(size[v])) % MOD\n            tot_white_u = (tot_white_u * (1 - num_black(size[v]) + MOD)) % MOD\n        \n        dp[u][0] = (tot_black_u - tot_white_u + MOD) % MOD\n        dp[u][1] = (tot_black_u * (size[u] - 1) - dp[u][0] * (size[u] - 1)) % MOD\n\n    dfs(0, -1)\n\n    num_black_vertices = (num_black(N) - 1 + MOD) % MOD\n    e_holeyness = dp[0][1]\n\n    e_holeyness = e_holeyness * mul_inv(num_black_vertices, MOD) % MOD\n\n    return e_holeyness\n\ndef holeyness_modulo(T, N):\n    return expected_holeyness(T, N)\n\n# To use, call holeyness_modulo with T as the list of edges and N as the number of vertices\n# Example use:\n# T = [(0, 1), (1, 2)]\n# N = 3\n# print(holeyness_modulo(T, N))",
    "timestamp": "2025-08-13 12:02:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class PaintingTree {\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int N = Integer.parseInt(br.readLine().trim());\n        List<Integer>[] graph = new List[N];\n        for (int i = 0; i < N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken()) - 1;\n            int v = Integer.parseInt(st.nextToken()) - 1;\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        pw.println(calculateExpectedHoleyness(graph, N));\n        pw.flush();\n    }\n\n    private static long calculateExpectedHoleyness(List<Integer>[] graph, int N) {\n        if (N == 0) return 0;\n        long twoPowerN = powMod(2, N, MOD);\n        long[] dp = new long[N];\n        long[] size = new long[N];\n        boolean[] visited = new boolean[N];\n\n        dfs(0, -1, graph, dp, size, visited);\n        long result = multiplyMod(dp[0], modInverse(twoPowerN, MOD), MOD);\n        return result;\n    }\n\n    private static void dfs(int node, int parent, List<Integer>[] graph, long[] dp, long[] size, boolean[] visited) {\n        visited[node] = true;\n        size[node] = 1;\n        dp[node] = 0;\n\n        for (int neighbor : graph[node]) {\n            if (neighbor != parent) {\n                dfs(neighbor, node, graph, dp, size, visited);\n                size[node] += size[neighbor];\n\n                long subtreeContribution = (2 * dp[neighbor] + size[neighbor] * (N - size[neighbor])) % MOD;\n                dp[node] = (dp[node] + subtreeContribution) % MOD;\n            }\n        }\n        dp[node] = (dp[node] + N * size[node] % MOD) % MOD;\n    }\n\n    private static long multiplyMod(long a, long b, long mod) {\n        return (a * b) % mod;\n    }\n\n    private static long powMod(long a, long b, long mod) {\n        long result = 1;\n        a = a % mod;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                result = (result * a) % mod;\n            }\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return result;\n    }\n\n    private static long modInverse(long a, long mod) {\n        return powMod(a, mod - 2, mod);\n    }\n}",
    "timestamp": "2025-08-13 12:02:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MOD 1000000007\n\nlong long modInverse(long long a, long long m) {\n    long long m0 = m, t, q;\n    long long x0 = 0, x1 = 1;\n\n    if(m == 1) return 0;\n    \n    while(a > 1) {\n        q = a / m;\n        t = m;\n        \n        m = a % m, a = t;\n        t = x0;\n        \n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n\n    if(x1 < 0) x1 += m0;\n\n    return x1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    long long expected_holeyness = 0;\n    \n    for(int i = 1; i <= N; i++) {\n        expected_holeyness = (expected_holeyness + ((1LL << (i - 1)) % MOD)) % MOD;\n    }\n\n    long long x = (1LL << N) % MOD;\n    long long y = expected_holeyness;\n    \n    // We need a modular inverse of x modulo MOD\n    long long z = (y * modInverse(x, MOD)) % MOD;\n    \n    printf(\"%lld\\n\", z);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1000000007;\n\nfunction modInverse(a, m) {\n    let m0 = m, t, q;\n    let x0 = 0, x1 = 1;\n    if (m === 1) return 0;\n    while (a > 1) {\n        q = Math.floor(a / m);\n        t = m;\n        m = a % m;\n        a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nfunction expectedHoleyness(tree) {\n    const N = tree.length;\n    const fact = [1];\n    const invFact = [1];\n\n    for (let i = 1; i <= N; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n\n    invFact[N] = modInverse(fact[N], MOD);\n    for (let i = N - 1; i > 0; i--) {\n        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;\n    }\n\n    invFact[0] = invFact[1];\n    \n    function binomial(n, k) {\n        if (n < k) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n\n    const pow2 = [1];\n    for (let i = 1; i <= N; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n\n    let expectedHoleyness = 0;\n    for (let k = 1; k < N; k++) {\n        const contribution = binomial(N - 1, k - 1) * pow2[k] % MOD * pow2[N - k] % MOD * k % MOD;\n        expectedHoleyness = (expectedHoleyness + contribution) % MOD;\n    }\n\n    expectedHoleyness = (expectedHoleyness * modInverse(pow2[N], MOD)) % MOD;\n    return expectedHoleyness;\n}\n\n// Example usage with a simple tree structure\n// const tree = [[1, 2], [0], [0]];\n// console.log(expectedHoleyness(tree));",
    "timestamp": "2025-08-13 12:02:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom math import log2, ceil\n\nclass Solution:\n    def expectedHoleyness(self, N: int, edges: List[Tuple[int, int]]) -> int:\n        MOD = 10**9 + 7\n        \n        # Build adjacency list representation of tree\n        graph = [[] for _ in range(N)]\n        for u, v in edges:\n            graph[u-1].append(v-1)\n            graph[v-1].append(u-1)\n        \n        # Find lowest common ancestor and subtree depths\n        parent = [0] * N\n        depth = [0] * N\n        \n        def dfs_depth(node, prev, curr_depth):\n            parent[node] = prev\n            depth[node] = curr_depth\n            for child in graph[node]:\n                if child != prev:\n                    dfs_depth(child, node, curr_depth + 1)\n        \n        dfs_depth(0, -1, 0)\n        \n        # Calculate expected holeyness\n        def calculate_expected_holeyness():\n            total_prob = 0\n            total_white_vertices = 0\n            \n            # Iterate through all possible black vertex subsets\n            for subset in range(1, 1 << N):\n                # Find vertices in this subset\n                black_vertices = [i for i in range(N) if subset & (1 << i)]\n                \n                # Find LCA and subtree containing all black vertices\n                def find_lca(vertices):\n                    if not vertices:\n                        return -1\n                    lca = vertices[0]\n                    for v in vertices[1:]:\n                        while depth[lca] > depth[v]:\n                            lca = parent[lca]\n                        while depth[v] > depth[lca]:\n                            v = parent[v]\n                        while lca != v:\n                            lca = parent[lca]\n                            v = parent[v]\n                    return lca\n                \n                lca = find_lca(black_vertices)\n                \n                # Count white vertices in subtree\n                white_count = 0\n                prob = 1\n                for v in range(N):\n                    # Check if vertex is in subtree and white\n                    curr = v\n                    is_in_subtree = False\n                    while curr != -1:\n                        if curr == lca:\n                            is_in_subtree = True\n                            break\n                        curr = parent[curr]\n                    \n                    if is_in_subtree and not (subset & (1 << v)):\n                        white_count += 1\n                        prob *= 0.5\n                \n                total_prob += prob\n                total_white_vertices += white_count * prob\n            \n            return total_white_vertices\n        \n        # Find modular multiplicative inverse\n        def mod_inverse(a, m):\n            def extended_gcd(a, b):\n                if a == 0:\n                    return b, 0, 1\n                gcd, x1, y1 = extended_gcd(b % a, a)\n                x = y1 - (b // a) * x1\n                y = x1\n                return gcd, x, y\n            \n            _, x, _ = extended_gcd(a, m)\n            return x % m\n        \n        expected = calculate_expected_holeyness()\n        x = 2**N\n        y = int(expected * x)\n        \n        return (y * mod_inverse(x, MOD)) % MOD",
    "timestamp": "2025-08-13 12:03:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveHoleyness(N, edges) {\n    const MOD = 1e9 + 7;\n    const adj = Array.from({ length: N }, () => []);\n    \n    for (const [u, v] of edges) {\n        adj[u-1].push(v-1);\n        adj[v-1].push(u-1);\n    }\n    \n    function findLCA(u, path) {\n        const visited = new Set();\n        const stack = [[u, [u]]];\n        \n        while (stack.length) {\n            const [node, currPath] = stack.pop();\n            \n            if (visited.has(node)) continue;\n            visited.add(node);\n            \n            if (path.includes(node)) return node;\n            \n            for (const neighbor of adj[node]) {\n                if (!visited.has(neighbor)) {\n                    stack.push([neighbor, [...currPath, neighbor]]);\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    function modInverse(a, m) {\n        function extendedEuclid(a, b) {\n            if (b === 0) return [a, 1, 0];\n            const [gcd, x, y] = extendedEuclid(b, a % b);\n            return [gcd, y, x - Math.floor(a / b) * y];\n        }\n        \n        const [gcd, x] = extendedEuclid(a, m);\n        return (x % m + m) % m;\n    }\n    \n    let totalHoleyness = 0;\n    let totalProbability = 0;\n    \n    for (let mask = 1; mask < (1 << N); mask++) {\n        const blackNodes = [];\n        for (let i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                blackNodes.push(i);\n            }\n        }\n        \n        if (blackNodes.length === 0) continue;\n        \n        let lca = blackNodes[0];\n        for (let i = 1; i < blackNodes.length; i++) {\n            lca = findLCA(lca, blackNodes.slice(0, i+1));\n        }\n        \n        const subtreeNodes = new Set();\n        const queue = [lca];\n        const visited = new Set([lca]);\n        \n        while (queue.length) {\n            const node = queue.shift();\n            subtreeNodes.add(node);\n            \n            for (const neighbor of adj[node]) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        let whiteCount = 0;\n        for (const node of subtreeNodes) {\n            if (!(mask & (1 << node))) {\n                whiteCount++;\n            }\n        }\n        \n        const prob = Math.pow(0.5, N);\n        totalHoleyness += whiteCount * prob;\n        totalProbability += prob;\n    }\n    \n    const expectedHoleyness = totalHoleyness / totalProbability;\n    const denominator = Math.round(1 / (expectedHoleyness / Math.floor(expectedHoleyness)));\n    const numerator = Math.round(expectedHoleyness * denominator);\n    \n    const result = modInverse(denominator, MOD);\n    return (numerator * result) % MOD;\n}",
    "timestamp": "2025-08-13 12:03:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr += 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    parent = [0]*(N+1)\n    depth = [0]*(N+1)\n    stack = [1]\n    parent[1] = 0\n    # BFS to set up parent and depth\n    while stack:\n        u = stack.pop()\n        for v in adj[u]:\n            if v != parent[u]:\n                parent[v] = u\n                depth[v] = depth[u] + 1\n                stack.append(v)\n    \n    # Precompute log2 and binary lifting tables for LCA\n    LOG = 20\n    up = [[0]*(N+1) for _ in range(LOG)]\n    up[0] = parent[:]\n    for k in range(1, LOG):\n        for v in range(1, N+1):\n            up[k][v] = up[k-1][up[k-1][v]]\n    \n    def lca(u, v):\n        if depth[u] < depth[v]:\n            u, v = v, u\n        # Bring u up to depth of v\n        for k in range(LOG-1, -1, -1):\n            if depth[u] - (1 << k) >= depth[v]:\n                u = up[k][u]\n        if u == v:\n            return u\n        for k in range(LOG-1, -1, -1):\n            if up[k][u] != up[k][v]:\n                u = up[k][u]\n                v = up[k][v]\n        return parent[u]\n    \n    # The expected value is sum over all vertices u of (probability that u is in S and white)\n    # The probability that u is in S is the probability that there are at least two black vertices in different subtrees of u, or u is black.\n    # Alternatively, it's 1 - P(all black nodes are in one subtree of u) - P(no black nodes)\n    # For white vertices, we multiply by 1/2.\n    \n    inv2 = (MOD + 1) // 2  # 1/2 mod MOD\n    inv2_pows = [1]*(N+2)\n    for i in range(1, N+2):\n        inv2_pows[i] = inv2_pows[i-1] * inv2 % MOD\n    \n    total = 0\n    for u in range(1, N+1):\n        # Compute P(u is in S)\n        # P(u is in S) = 1 - P(all black nodes are in subtrees of u not including u) - P(no black nodes)\n        # P(no black nodes) = (1/2)^N\n        # P(all black nodes are in subtrees of u not including u) = sum over children v of (P(all black nodes are in subtree of v))\n        # But u itself could be black.\n        # So better approach: P(u is in S) = 1 - P(all black nodes are in subtrees of u not including u) - P(no black nodes)\n        # P(all black nodes are in subtrees of u not including u) = product over children v of (P(all black nodes are in subtree of v))\n        # But u itself is not considered here.\n        # So for u, the condition is that at least two different children's subtrees have black nodes, or u is black.\n        # So P(u in S) = 1 - (sum over children v of P(black nodes only in subtree of v)) - P(no black nodes)\n        # But sum over children v of P(black nodes only in subtree of v) is sum over children v of (P(all black nodes are in subtree of v) - P(no black nodes))\n        # So P(u in S) = 1 - (sum over children v of (P(all black nodes are in subtree of v)) - (deg(u) * P(no black nodes))) - P(no black nodes)\n        # Wait, no. The correct formula is:\n        # P(u in S) = 1 - P(all black nodes are in at most one child subtree) - P(no black nodes)\n        # P(all black nodes are in at most one child subtree) = sum over children v of P(all black nodes are in subtree of v) - (deg(u)-1)*P(no black nodes)\n        # So P(u in S) = 1 - (sum over children v of P(all black nodes are in subtree of v) - (deg(u)-1)*P(no black nodes)) - P(no black nodes)\n        # = 1 - sum over children v of P(all black nodes are in subtree of v) + (deg(u)-1)*P(no black nodes) - P(no black nodes)\n        # = 1 - sum over children v of P(all black nodes are in subtree of v) + (deg(u)-2)*P(no black nodes)\n        \n        # Compute size of subtree rooted at u (including u)\n        # Precompute sizes\n        size = [0]*(N+1)\n        stack = [(u, False)]\n        while stack:\n            node, processed = stack.pop()\n            if not processed:\n                stack.append((node, True))\n                for v in adj[node]:\n                    if v != parent[node]:\n                        stack.append((v, False))\n            else:\n                size[node] = 1\n                for v in adj[node]:\n                    if v != parent[node]:\n                        size[node] += size[v]\n        \n        # P(all black nodes are in subtree of v) = (1/2)^{N - size[v]}\n        # P(no black nodes) = (1/2)^N\n        sum_p = 0\n        deg = 0\n        for v in adj[u]:\n            if v != parent[u]:\n                deg += 1\n                sv = size[v]\n                term = inv2_pows[N - sv]\n                sum_p = (sum_p + term) % MOD\n        term_no_black = inv2_pows[N]\n        p_in_S = (1 - sum_p + (deg - 1) * term_no_black) % MOD\n        # For white vertices, multiply by 1/2\n        if True:  # u is white (contributes only if white)\n            contribution = p_in_S * inv2 % MOD\n            total = (total + contribution) % MOD\n    \n    # Output total as fraction y/x mod MOD, where x is 2^N (since each term has a 1/2^{something})\n    # So total = y / 2^N mod MOD => y = total * 2^N mod MOD\n    pow2_N = pow(2, N, MOD)\n    y = total * pow2_N % MOD\n    print(y)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:04:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction modInv(a, mod) {\n    let b = mod, x = 0, y = 1;\n    while (a > 1) {\n        let q = Math.floor(a / b);\n        [a, b] = [b, a % b];\n        [x, y] = [y - q * x, x];\n    }\n    return y < 0 ? y + mod : y;\n}\n\nfunction solve() {\n    const N = parseInt(readline());\n    const adj = Array.from({ length: N + 1 }, () => []);\n    for (let i = 0; i < N - 1; i++) {\n        const [u, v] = readline().split(' ').map(Number);\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n\n    const parent = Array(N + 1).fill(0);\n    const depth = Array(N + 1).fill(0);\n    const size = Array(N + 1).fill(0);\n    const stack = [[1, 0]];\n    while (stack.length) {\n        const [u, p] = stack.pop();\n        parent[u] = p;\n        for (const v of adj[u]) {\n            if (v !== p) {\n                depth[v] = depth[u] + 1;\n                stack.push([v, u]);\n            }\n        }\n    }\n\n    let total = 0;\n    for (let u = 1; u <= N; u++) {\n        let prob = 1;\n        let sum = 0;\n        for (const v of adj[u]) {\n            if (v !== parent[u]) {\n                const cnt = Math.pow(2, N - 1 - size[v], MOD);\n                sum = (sum + cnt) % MOD;\n            }\n        }\n        const cntParent = Math.pow(2, N - 1 - (N - size[u]), MOD);\n        sum = (sum + cntParent) % MOD;\n        prob = (prob * (1 - sum * modInv(Math.pow(2, N), MOD) % MOD + MOD)) % MOD;\n        total = (total + prob) % MOD;\n    }\n\n    const numerator = (Math.pow(2, N) - 1 - total + MOD) % MOD;\n    const denominator = Math.pow(2, N) % MOD;\n    const invDenominator = modInv(denominator, MOD);\n    const result = (numerator * invDenominator) % MOD;\n    console.log(result);\n}\n\n// Assuming readline is available for input, e.g., in a coding competition environment\n// For local testing, replace readline with appropriate input handling\nsolve();",
    "timestamp": "2025-08-13 12:04:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nusing namespace std;\n\nvector<vector<int>> tree;\nint N;\n\nint dfs(int u, int parent, vector<int>& subtreeSize) {\n    subtreeSize[u] = 1;\n    for (int v : tree[u]) {\n        if (v != parent) {\n            subtreeSize[u] += dfs(v, u, subtreeSize);\n        }\n    }\n    return subtreeSize[u];\n}\n\nint modInverse(int a, int m) {\n    int m0 = m, y = 0, x = 1;\n    while (a > 1) {\n        int q = a / m;\n        int t = m;\n        m = a % m, a = t;\n        t = y;\n        y = x - q * y;\n        x = t;\n    }\n    if (x < 0) x += m0;\n    return x;\n}\n\nint expectedHoleyness() {\n    vector<int> subtreeSize(N);\n    dfs(0, -1, subtreeSize);\n\n    int totalWays = 1;\n    for (int i = 0; i < N; ++i) {\n        totalWays = 2LL * totalWays % MOD;\n    }\n\n    long long expectedWhite = 0;\n    for (int i = 0; i < N; ++i) {\n        int whiteInSubtree = subtreeSize[i] - 1;\n        expectedWhite = (expectedWhite + whiteInSubtree) % MOD;\n    }\n\n    int x = totalWays;\n    int y = expectedWhite;\n    int z = modInverse(x, MOD);\n    \n    return (1LL * y * z % MOD);\n}\n\nint main() {\n    cin >> N;\n    tree.resize(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n    }\n    \n    cout << expectedHoleyness() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:06:46"
  }
]