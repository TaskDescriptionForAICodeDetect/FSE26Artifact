[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nlong long int a, b, c;\n\n\ntemplate <typename D, typename T = D, typename L = T>\nclass Tree {\npublic:\n\tTree( long long int size = 0, D InitialValueArg = D() ) {\n\t\tlong long int n = 1LL;\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t\twhile( n <= size ) {\n\t\t\tn <<= 1LL;\n\t\t\taddOneLine( n );\n\t\t}\n\t\tInitialValue = InitialValueArg;\n\t\tData.resize( n, InitialValue );\n\t\tfor( size_t i = 0; i < Data.size(); i++ ) {\n\t\t\tupdate( i, Data[i] );\n\t\t}\n\t\tMaxSize = n;\n\t\tNowIndex = 0LL;\n\t}\n\n\tvirtual T preprocessing( D a ) {\n\t\treturn T( a );\n\t}\n\n\tvirtual T treeupdate( T a, T b ) {\n\t\treturn a;\n\t}\n\n\tvirtual L lazyupdate( L parent, L me ) {\n\t\treturn parent;\n\t}\n\n\tvirtual T fromlazytotreenode( L lazy, T nownode ) {\n\t\treturn nownode;\n\t}\n\n\tvoid update( long long int idx, D data ) {\n\t\tcalcLazyUpdate( idx, idx + 1 );\n\t\tData[idx] = data;\n\n\t\tupdateTreeNodeidx( idx, preprocessing( data ) );\n\t}\n\n\tvoid rangeupdate( long long int idxl, long long int idxr, L data ) {\n\n\t}\n\n\tvoid show() {\n\t\tfor( auto x : CalcTree ) {\n\t\t\tfor( auto y : x ) {\n\t\t\t\tcout << y << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tvoid push( D data ) {\n\t\tif( NowIndex == MaxSize ) {\n\t\t\tMaxSize <<= 1LL;\n\t\t\taddOneLine( MaxSize );\n\t\t\tvector<D>Datamemo( MaxSize, InitialValue );\n\t\t\tcopy( Data.begin(), Data.end(), Datamemo.begin() );\n\t\t\tfor( long long int i = 0; i < Datamemo.size(); i++ ) {\n\t\t\t\tupdate( i, Datamemo[i] );\n\t\t\t}\n\t\t}\n\t\tData[NowIndex] = data;\n\t\tupdate( NowIndex, data );\n\t\tNowIndex++;\n\t}\n\n\tT range( long long int l, long long int r ) {\n\t\tcalcLazyUpdate( l, r );\n\t\treturn rangeProcessing( 0, l, r, 0, 0, MaxSize );\n\t}\n\n\tlong long int t() {\n\t\treturn 10;\n\t}\n\nprivate:\n\n\t//??????????????????\n\tstruct TreeNode {\n\t\tT Ndata;\n\n\t\t//?????¶?????????\n\t\tstruct {\n\t\t\tlong long int Lnum;\n\t\t\tL Ldata;\n\t\t};\n\t};\n\tvector<vector<TreeNode>> CalcTree;\n\tvector<D> Data;\n\tlong long int MaxSize;\n\tlong long int NowIndex;\n\tD InitialValue;\n\n\tvoid addOneLine( long long int n ) {\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t}\n\n\tT rangeProcessing( long long int d, long long int a, long long int b, long long int k, long long int l, long long int r ) {\n\t\tif( !( r <= a || b <= l ) && d < CalcTree.size() ) {\n\t\t\tif( a <= l&&r <= b ) {\n\t\t\t\treturn CalcTree[d][k].Ndata;\n\t\t\t} else {\n\t\t\t\treturn treeupdate( rangeProcessing( d + 1, a, b, k * 2, l, ( l + r ) / 2 ), rangeProcessing( d + 1, a, b, k * 2 + 1, ( l + r ) / 2, r ) );\n\t\t\t}\n\t\t}\n\t\treturn InitialValue;\n\t}\n\n\tvoid calcLazyUpdate( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\t\tif( i < CalcTree.size() - 1 ) {\n\t\t\tCalcTree[i + 1][nowidx * 2].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2].Ldata );\n\t\t\tCalcTree[i + 1][nowidx * 2 + 1].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2 + 1].Ldata );\n\t\t\tCalcTree[i][nowidx].Ldata = L();\n\t\t\tlong long int nextidxplus = 1LL << ( CalcTree.size() - i - 1 );\n\t\t\tnowidx *= 2;\n\t\t\tif( idxr <= nowidx + nextidxplus ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx );\n\t\t\t} else if( nowidx + nextidxplus <= idxl ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx + 1 );\n\t\t\t} else {\n\t\t\t\tcalcLazyUpdate( nowidx + nextidxplus, idxr, i + 1, nowidx + 1 );\n\t\t\t\tcalcLazyUpdate( idxl, nowidx + nextidxplus, i + 1, nowidx );\n\t\t\t}\n\t\t} else {\n\t\t\tT nextT = fromlazytotreenode( CalcTree[i][nowidx].Ldata, CalcTree[i][nowidx].Ndata );\n\t\t\tif( nextT != CalcTree[i][nowidx].Ndata ) {\n\t\t\t\tupdateTreeNodeidx( nowidx, nextT );\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid updateTreeNodeidx( long long int idx, T TreeNodeData ) {\n\t\t( *( CalcTree.rbegin() ) )[idx].Ndata = preprocessing( TreeNodeData );\n\t\tfor( auto ite = CalcTree.rbegin(); ite + 1 < CalcTree.rend(); ) {\n\t\t\tidx >>= 1LL;\n\t\t\tT updatedata = treeupdate( ( *ite )[idx * 2].Ndata, ( *ite )[idx * 2 + 1].Ndata );\n\t\t\tite++;\n\t\t\tif( ( *ite )[idx].Ndata != updatedata ) {\n\t\t\t\t( *ite )[idx].Ndata = updatedata;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long int addrangeLazy( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\n\t}\n};\n\nclass segtree : public Tree<long long int> {\npublic:\n\tsegtree( long long int a, long long int b ):Tree( a, b ) {\n\n\t}\n\tlong long int treeupdate( long long int a, long long int b ) {\n\t\treturn ( a + b ) % c;\n\t}\n};\n\n\n\nint main() {\n\twhile( cin >> a >> b >> c, a || b || c ) {\n\t\tsegtree x( b - a + 1, 0 );\n\t\tvector<string>D( b - a + 1 );\n\t\tfor( long long int i = a; i <= b; i++ ) {\n\t\t\tD[i - a] = to_string( i );\n\t\t}\n\t\tsort( D.begin(), D.end() );\n\t\tvector<long long int >Dx( b - a + 1 );\n\t\tfor( long long int i = 0; i < b - a + 1; i++ ) {\n\t\t\tDx[i] = stoll( D[i] );\n\t\t\tx.update( Dx[i] - a, x.range( 0, i ) + 1 );\n\t\t}\n\t\tcout << x.range( 0, b - a + 2 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\ntypedef long long ll;\n\nstring itos(int x){\n  string res;\n  while(x)res+=x%10+'0',x/=10;\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nll dp[N][11];\n\nint main(){\n  \n  ll a,b,p;\n\n  cin>>a>>b>>p;\n\n  vector<string> v;\n  \n  for(int i=a;i<=b;i++) v.push_back(itos(i));\n  \n  ll n=b-a+1;\n  \n  sort(v.begin(),v.end());\n  \n  v.push_back(\"\");\n  \n  memset(dp,0,sizeof(dp));\n  \n  for(int i=0;i<n;i++) dp[i][v[i].size()]=1;\n  \n  for(int i=0;i<n;i++){\n    \n    ll A=0;\n    for(int j=0;j<v[i].size();j++) A=(A+dp[i][j])%p;\n    dp[i][v[i].size()]=(dp[i][v[i].size()]+A)%p;\n    \n    for(int j=0;j<11;j++){\n      \n      if(v[i+1].size()==j) dp[i+1][j]=(dp[i+1][j]+(dp[i][j]*2)%p)%p;\n      else dp[i+1][j]=(dp[i+1][j]+dp[i][j])%p;\n      \n    }\n    \n  }\n  \n  ll ans=0;\n  \n  for(int i=0;i<11;i++){\n    cout<<dp[n][i]<<endl;\n    ans=(ans+dp[n][i])%p;\n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_BIT\n#define ___Class_BIT\n\n// ------ Includes ------ //\n#include <vector>\n#pragma warning(disable : 4146)\n\n// ------ Class ------ //\ntemplate <typename Type>\nclass BIT {\nprivate:\n\tunsigned size_; std::vector<Type> v;\n\tType sum(unsigned r) {\n\t\tType ret = 0;\n\t\twhile (r > 0) {\n\t\t\tret += v[r];\n\t\t\tr -= r & (-r);\n\t\t}\n\t\treturn ret;\n\t}\npublic:\n\tBIT() {};\n\tBIT(unsigned size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(unsigned i, Type x) {\n\t\ti++;\n\t\twhile (i <= size_) {\n\t\t\tv[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tinline Type sum(unsigned l, unsigned r) {\n\t\treturn sum(r) - sum(l);\n\t}\n\tbool operator[](unsigned x) {\n\t\treturn sum(x, x + 1);\n\t}\n};\n\n#endif\n\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint A, B, M;\nint main() {\n\twhile (cin >> A >> B >> M, A) {\n\t\tvector<string> v(B - A + 1);\n\t\tfor (int i = A; i <= B; i++) v[i - A] = to_string(i);\n\t\tsort(v.begin(), v.end());\n\t\tvector<int> pos(B - A + 1);\n\t\tfor (int i = 0; i < v.size(); i++) pos[stoi(v[i]) - A] = i;\n\t\tBIT<long long> Q(B - A + 1);\n\t\tfor (int i = A; i <= B; i++) Q.add(pos[i - A], (Q.sum(0, pos[i - A]) + 1) % M);\n\t\tcout << Q.sum(0, B - A + 1) % M << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int a,b,p;\n  while(cin>>a>>b>>p,a){\n    int l=b-a+1;\n\n    vector<int> dp(l,0);\n    map<int, int> sm;\n    for(int i=a;i<=b;i++){\n      sm[i]=0;\n      dp[i-a]=1;\n\n      string s=to_string(i);\n      if(s.size()==to_string(i-1).size()){\n        sm[i]+=sm[i-1];\n        sm[i]%=p;\n\n        dp[i-a]+=sm[i-1];\n        dp[i-a]%=p;\n      }\n\n      while(s.size()>1){\n        s.pop_back();\n        dp[i-a]+=sm[stoll(s)];\n        dp[i-a]%=p;\n      }\n\n      sm[i]+=dp[i-a];\n      sm[i]%=p;\n    }\n\n    int ans=0;\n    for(int d:dp) ans+=d,ans%=p;\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint keta(int n){\n\tint ret = 0;\n\twhile(n){\n\t\tret++;\n\t\tn /= 10;\n\t}\n\treturn ret;\n}\n\nint flor(int n){\n\tint ke = keta(n),tmp = 1;\n\tfor(int i = 0;i < keta(n) - 1;i++) tmp *= 10;\n\treturn tmp;\n}\n\nsigned main(){\n\tint a,b,p;\n\twhile(cin >> a >> b >> p,a){\n\t\tint dp[150000] = {};\n\t\tif(a >= 11112){\n\t\t\tif(keta(a) != keta(b)){\n\t\t\t\tint tmp = flor(b),x = 1,y = 1;\n\t\t\t\tfor(int i = a;i < tmp;i++) x = x * 2 % p;\n\t\t\t\tfor(int i = tmp;i <= b;i++) y = y * 2 % p;\n\t\t\t\tcout << x + y - 2 << endl;\n\t\t\t}else{\n\t\t\t\tint x = 1;\n\t\t\t\tfor(int i = a;i <= b;i++) x = x * 2 % p;\n\t\t\t\tcout << x - 1 << endl;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = a;i <= b;i++){\n\t\t\tdp[i] = (dp[i - 1] * 2 - dp[flor(i) - 1] + p) % p;\n\t\t\tint tmp = i / 10;\n\t\t\twhile(tmp){\n\t\t\t\tdp[i] = (dp[i] + dp[tmp] - dp[flor(tmp) - 1] + p) % p;\n\t\t\t\ttmp /= 10;\n\t\t\t}\n\t\t\tdp[i]++;\n\t\t}\n\t\tcout << dp[b] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring tos(ll a){\n  string res;\n  while(a)res+=a%10,a/=10;\n  reverse(res.begin(),res.end());\n  return  res;\n}\n\nll dp[100001][11];\nint main(){\n  ll a,b,p;\n  while(cin>>a>>b>>p,a){\n    vector<string> v;\n    for(ll i=a;i<=b;i++)v.push_back(tos(i));\n    sort(v.begin(),v.end());\n    memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    for(int i=0;i<v.size();i++)\n      for(int j=0;j<11;j++){\n\tif(j<=v[i].size())dp[i+1][v[i].size()]=(dp[i+1][v[i].size()]+dp[i][j])%p;\n\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%p;\n      }\n    ll s=0;\n    for(int i=1;i<11;i++)s+=dp[v.size()][i];\n    cout<<s%p<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nint dp[200001];\n\nint sc(int r,int mo){\n\tint h=0;\n\tif(9<r)h+=dp[9];\n\tif(99<r)h+=dp[99];\n\tif(999<r)h+=dp[999];\n\tif(9999<r)h+=dp[9999];\n\tif(99999<r)h+=dp[99999];\n//\tif(9<h)h+=dp[9];\n\th+=dp[r];\n\th%=mo;\n\t//cout<<r<<\" \"<<h<<endl;\n\treturn h;\n}\n   signed main(){\n int a,b,p;\n   \twhile(1){\n   \tcin>>a>>b>>p;\n   \t\tfor(int i=0;i<=200000;i++)dp[i]=0;\n   \t\tif(p==0) return 0;\n   \t\tstring sa=itos(a);\n   \t\tstring sb=itos(b);\n   \t\tif(sa.length()==sb.length()){\n   \t\t\tint r=beki(2,b-a+1,p);\n   \t\t\tr+=(p-1);\n   \t\t\tcout<<r%p<<endl;\n   \t\t\tcontinue;\n   \t\t}\n   \t\t\n   \t\tif(b>=200000){\n   \t\t\t\n   \t\t\tint aa=a;\n   \t\t\twhile(itos(aa).length()==sa.length())aa++;\n   \t\t\tint r=beki(2,b-aa+1,p)+beki(2,aa-a,p);\n   \t\t\tr+=(2*p-2);\n   \t\t\tr%=p;\n   \t\t\tcout<<r<<endl;\n   \t\t\tcontinue;\n   \t\t\t\n   \t\t}\n   \t\tdp[1]=1%p;\n   \t\tdp[0]=0%p;\n   \t\tfor(int i=2;i<=b;i++){\n   \t\t\tif(i==10 ){\n   \t\t\t\tdp[i]=2%p;\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\tif(i==100 ){\n   \t\t\t\tdp[i]=4%p;\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\tif(i==1000 ){\n   \t\t\t\tdp[i]=8%p;\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\tif(i==10000 ){\n   \t\t\t\tdp[i]=16%p;\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\tif(i==100000 ){\n   \t\t\t\tdp[i]=32%p;\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\t\n   \t\t\tdp[i]=2*dp[i-1]+1;\n   \t\t\tdp[i]%=p;\n   \t\t\tint ii=i/10;\n   \t\t\twhile(ii>0){\n   \t\t\t\tdp[i]+=dp[ii];\n   \t\t\t\tdp[i]%=p;\n   \t\t\t\tii/=10;\n   \t\t\t}\n   \t\t\t\n   \t\t//\tif(b==10) cout<<i<<\" \"<<dp[i]<<endl;\n   \t\t}\n   \t\tcout<<(-sc(a-1,p)+p+sc(b,p))%p<<endl;\n\n   \t}\n\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2326>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n/*\n 1-index\n \n add : x に valを加算\n sum : [1,x] の総和を出力\n */\nll MOD;\nstruct BIT {\n    ll N;\n    vector<ll> bit;\n    BIT(ll N):N(N) {\n        /* BITは[1..N]で扱う */\n        bit.resize(N + 1, 0);\n    }\n    \n    void add(int x, ll val){\n        val %=MOD;\n        while (x <= N) {\n            (bit[x] += val)%=MOD;\n            x += x & -x;\n        }\n    }\n    \n    ll sum(int x){\n        ll ret = 0;\n        while (x) {\n            (ret += bit[x])%=MOD;\n            x &= (x - 1);\n        }\n        return (ret);\n    }\n};\nll solve(ll A,ll B,ll P){\n    ll res = 0;\n    MOD = P;\n    vector<string> S(B-A+1);\n    for(ll x = A; x <= B;x++) S[x-A] = to_string(x);\n    sort(S.begin(),S.end());\n    BIT bit(B-A+2);\n    for(int i = 0; i < S.size(); i++){\n        ll x = atoll(S[i].c_str()) - (A-1);\n        ll Sum = 0;\n        if(x!=1) Sum = bit.sum(x-1);\n        bit.add(x,Sum+1);\n    }\n    \n    res = bit.sum(B-A+2);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll A,B,P;\n    while(cin>>A>>B>>P,A|B|P){\n        cout << solve(A,B,P) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\nll a,b,p;\nvoid addm(ll &x,ll y){\n\tx+=y;\n\tx%=p;\n}\nint d(ll x){\n\tint ret=0;\n\twhile(x) x/=10,ret++;\n\treturn ret;\n}\nll power(ll base,ll ex){\n\tll ret=1,po=base;\n\twhile(ex){\n\t\tif(ex%2) ret=ret*po%p;\n\t\tpo=po*po%p;\n\t\tex/=2;\n\t}\n\treturn ret;\n}\nll bit[1000002];\nll sum(int x){\n\tll s=0;\n\twhile(x>0){\n\t\taddm(s,bit[x]);\n\t\tx-=(x&-x);\n\t}\n\treturn s;\n}\nvoid add(int x,ll ad){\n\twhile(x<=b){\n\t\taddm(bit[x],ad);\n\t\tx+=(x&-x);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>a>>b>>p;\n\t\tif(a==0) break;\n\t\tif(b>=1e6){\n\t\t\tif(d(a)<d(b)){\n\t\t\t\tll p10=1;\n\t\t\t\twhile(p10<=a) p10*=10;\n\t\t\t\tcout<<(power(2,b-p10+1)+power(2,p10-a)-2+p*2)%p<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<(power(2,b-a+1)-1+p)%p<<endl;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}else{\n\t\t\trep(i,b+1) bit[i]=0;\n\t\t\tfor(int i=a;i<=b;i++){\n\t\t\t\tint p10=1;\n\t\t\t\tint pp=1;\n\t\t\t\trep(j,d(i)-1) pp*=10;\n\t\t\t\tll ad=0;\n\t\t\t\twhile(p10<=i){\n\t\t\t\t\tad+=sum(i/pp)-sum(p10-1);\n//\t\t\t\t\tshow(i/pp);\n//\t\t\t\t\tshow(ad);\n\t\t\t\t\tp10*=10;\n\t\t\t\t\tpp/=10;\n\t\t\t\t}\n\t\t\t\tad=(ad%p+p+1)%p;\n//\t\t\t\tshow(ad);\n\t\t\t\tadd(i,ad);\n//\t\t\t\tprintf(\"sum[%d]=%d\\n\",i,sum(i));\n\t\t\t}\n\t\t\tcout<<sum(b)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nint dp[1<<20];\nvector<string> lex;\nint n,p;\n\nint add(int k,int a){\n\tk+=n-1;\n\tdp[k]=(dp[k]+a)%p;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tdp[k]=(dp[k*2+1]+dp[k*2+2])%p;\n\t}\n}\n\nint query(int a,int b,int k=0,int l=0,int r=n){\n\tif(r<=a || b<=l)return 0;\n\tif(a<=l && r<=b)return dp[k];\n\tint vl=query(a,b,k*2+1,l,(l+r)/2);\n\tint vr=query(a,b,k*2+2,(l+r)/2,r);\n\treturn (vl+vr)%p;\n}\n\nint main(void){\n\tint a,b;\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&a,&b,&p);\n\t\tif(a+b+p==0)break;\n\t\tlex.clear();\n\t\tmemset(dp,0,sizeof(dp));\n\t\tn=1;\n\t\twhile(n<=b-a+1)n*=2;\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tstringstream stream;\n\t\t\tstream << i;\n\t\t\tstring s;\n\t\t\tstream >> s;\n\t\t\tlex.push_back(s);\n\t\t}\n\t\tsort(lex.begin(),lex.end());\n\t\tfor(int i=0;i<lex.size();i++){\n\t\t\tstringstream stream;\n\t\t\tstream << lex[i];\n\t\t\tint num;\n\t\t\tstream >> num;\n\t\t\tnum-=a;\n\t\t\tint plus=query(0,num);\n\t\t\tadd(num,(plus+1)%p);\n\t\t}\n\t\tprintf(\"%d\\n\",dp[0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint N, P;\nint dp[100001];\n\nvoid add(int p, int v){\n\tfor(int i=p;i<=N;i+=i&-i) dp[i] = (dp[i]+v)%P;\n}\n\nint sum(int p){\n\tint res = 0;\n\tfor(int i=p;i;i-=i&-i) res = (res+dp[i])%P;\n\treturn res;\n}\n\nstring itos(int t){\n\tostringstream oss;\n\toss << t;\n\treturn oss.str();\n}\n\nint main(){\n\tint A, B;\n\twhile(cin >> A >> B >> P && A){\n\t\tN = B-A+1;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tvector< pair<string, int> > vp;\n\t\tfor(int i=A;i<=B;i++) vp.push_back(make_pair(itos(i), i));\n\t\tsort(vp.begin(), vp.end());\n\t\tfor(int i=0;i<vp.size();i++){\n\t\t\tint idx = vp[i].second-A+1;\n\t\t\tadd(idx, sum(idx-1)+1);\n\t\t}\n\t\tcout << sum(N) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nll A,B,P;\nll dp[100002];\n\nll loc(int num){\n\treturn num-A;\n}\n\nll get_digit_max(ll num){\n\n\tll ret = 10;\n\n\twhile(ret <= num)ret *= 10;\n\n\treturn ret-1;\n}\n\nll uniformity[270000],partial[270000];\nll N;\n\nvoid init(ll first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid add_and_updateNodes(ll left,ll right,ll value,ll node_id,ll node_left,ll node_right){\n\n\tif(right < node_left || left > node_right)return;\n\telse if(left <= node_left && right >= node_right){\n\t\tuniformity[node_id] += value;\n\t\tuniformity[node_id] %= P;\n\t}else{\n\t\tpartial[node_id] += (min(right,node_right)-max(left,node_left)+1)*value;\n\t\tadd_and_updateNodes(left,right,value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tadd_and_updateNodes(left,right,value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nll getSum(ll left,ll right,ll node_id,ll node_left,ll node_right){\n\tif(right < node_left || left > node_right)return 0;\n\telse if(left <= node_left && right >= node_right){\n\t\treturn ((node_right-node_left+1)*uniformity[node_id]+partial[node_id])%P;\n\t}else{\n\t\tll sum = (min(right,node_right)-max(left,node_left)+1)*uniformity[node_id];\n\t\tsum += getSum(left,right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tsum += getSum(left,right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn sum%P;\n\t}\n}\n\n\nvoid func(){\n\n\tN = 1;\n\n\tll first_N = B-A+1;\n\n\tinit(first_N);\n\n\tfor(int i = 0; i <= 2*N-2; i++){\n\t\tuniformity[i] = 0;\n\t\tpartial[i] = 0;\n\t}\n\n\tadd_and_updateNodes(loc(A),loc(B),1,0,0,N-1);\n\n\tll left,right,add;\n\tbool FLG;\n\n\n\tfor(int i = A; i <= B; i++){\n\n\t\tleft = i;\n\t\tFLG = true;\n\n\t\tadd = getSum(loc(i),loc(i),0,0,N-1);\n\n\t\twhile(FLG){\n\t\t\tright = get_digit_max(left);\n\t\t\tif(right >= B){\n\t\t\t\tright = B;\n\t\t\t\tFLG = false;\n\t\t\t}\n\n\t\t\tif(left == i){\n\n\t\t\t\tif(left == right){\n\t\t\t\t\t//Do nothing\n\t\t\t\t}else{\n\t\t\t\t\tadd_and_updateNodes(loc(left+1),loc(right),add,0,0,N-1);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tadd_and_updateNodes(loc(left),loc(right),add,0,0,N-1);\n\t\t\t}\n\t\t\tleft *= 10;\n\t\t\tif(left > B)break;\n\t\t}\n\t}\n\n\tll ans = getSum(loc(A),loc(B),0,0,N-1);\n\n\tprintf(\"%lld\\n\",ans%P);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%lld %lld %lld\",&A,&B,&P);\n\t\tif(A == 0 && B == 0 && P == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int MAX_N = 200000;\n\ntemplate <typename T>\nclass BIT{\n\tprivate:\n\t\tvector<T> bit; //[1, n]\n\tpublic:\n\t\tBIT(){\n\t\t\tbit = vector<T>(MAX_N + 1, 0);\n\t\t}\n\t\tT sum(int i, long long m){\n\t\t\tif(i == 0) return 0;\n\t\t\tassert(1 <= i and i <= MAX_N and \"invalid argument\");\n\t\t\tT s = 0;\n\t\t\twhile(i > 0){\n\t\t\t\t(s += bit[i]) %= m;\n\t\t\t\ti -= i & -i;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tvoid add(int i, int x, long long m){\n\t\t\tassert(1 <= i and i <= MAX_N and \"invalid argument\");\n\t\t\twhile(i <= MAX_N){\n\t\t\t\t(bit[i] += x) %= m;\n\t\t\t\t//bit[i] = max(bit[i], x);\n\t\t\t\ti += i & - i;\n\t\t\t}\n\t\t}\n};\n\nint main(){\n\tlong long a, b, m;\n\twhile(cin >> a >> b >> m, a||b||m){\n\t\tvector<pair<string, int>> p;\n\t\trange(i,a,b + 1){\n\t\t\tp.emplace_back(to_string(i), i - a);\n\t\t}\n\t\tsort(all(p));\n\n\t\tvector<int> ma(p.size());\n\t\trep(i,p.size()){\n\t\t\tma[ p[i].second ] = i;\n\t\t}\n\n\t\t//cout << ma << endl;\n\n\t\tBIT<long long> bit;\n\t\tlong long ans = 0;\n\t\tfor(int i = b; i >= a; i--){\n\t\t\tlong long t = bit.sum(MAX_N, m) - bit.sum( ma[i - a] , m) + 1;\n\t\t\t(ans += t) %= m;\n\t\t\tbit.add(ma[i - a] + 1, t, m);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<sstream>\n#define maxn 100050\nusing namespace std;\n\n  typedef struct yyy\n  {\n      int x;\n      char s[15];\n  }yyy;\n\n  char ch[15];\n  bool cmp(yyy x,yyy y )\n  {\n      int i=0,j=0,lx=strlen(x.s),ly=strlen(y.s);\n      while(i<lx&&i<ly)\n      {\n          if (x.s[i]>y.s[i]) return 0;\n          else if (x.s[i]<y.s[i]) return 1;\n          else i++;\n      }\n       if (lx>ly) return 0;\n       else return 1;\n  }\n\n  yyy A[maxn];\n  int B[maxn];\n  int p,n;\n  long long sum[maxn];\n\n  int lowbit(int x){return x&-x;}\n\n  void add(int x,int v)\n  {\n      while(x<=n)\n      {\n          sum[x]=(sum[x]+v)%p;\n          x+=lowbit(x);\n      }\n  }\n\n  long long getsum(int x)\n  {\n      long long Sum=0;\n      while(x>0)\n      {\n          Sum=(Sum+sum[x])%p;\n          x-=lowbit(x);\n      }\n      return Sum;\n  }\n\n\n  void f(int x,int s)\n  {\n      sprintf(A[x].s,\"%d\",s);\n  }\n\n  int main()\n  {\n      int a,b;\n      int i,x,j;\n      while(cin>>a>>b>>p&&a!=0)\n      {\n\n      memset(A,0,sizeof(A));\n      memset(B,0,sizeof(B));\n      memset(sum,0,sizeof(sum));\n          n=b-a+2;\n           for (i=a;i<=b;i++)\n           {\n               A[i-a+1].x=i-a+1;\n               f(i-a+1,i);\n           }\n\n           sort(A+1,A+b-a+2,cmp);\n           //for (i=1;i<=b-a+1;i++) cout<<A[i].x<<' '<<A[i].s<<endl;\n           for (i=1;i<=b-a+1;i++)\n             B[A[i].x]=i;\n\n           for (i=1;i<=b-a+1;i++)\n             {\n             add(B[i],getsum(B[i]-1)+1);\n             // for (j=1;j<=b-a+1;j++) cout<<sum[j]<<' ';\n              //cout<<endl;\n             }\n           long long Sum=getsum(b-a+1);\n           cout<<Sum<<endl;\n\n      }\n\n\n\n\n      return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<17;\nll mod;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  RSQ2(int n_){\n    n=1;\n    while(n<n_)n*=2; //????´???°n???2???????????????\n    for(int i=0;i<2*n-1;i++)dat[i]=td[i]=0;\n  }\n  \n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]=(dat[k]+(r-l)*x)%mod; \n      td[k]=(td[k]+x)%mod;\n      return dat[k];\n    }\n\n    dat[k]=(dat[k]+(min(r,b)-max(l,a))*x)%mod;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]=(dat[kl]+t)%mod, dat[kr]=(dat[kr]+t)%mod;\n    td[kl]=(td[kl]+td[k])%mod, td[kr]=(td[kr]+td[k])%mod;\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return (vl+vr)%mod;\n  }\n  \n  ll sum(int a,int b){return add(a,b,0);}\n};\n\nstring i2S(ll num){\n  string res;\n  if(num==0)return \"0\";\n  while(num) res=(char)(num%10+'0')+res,num/=10;\n  return res;\n}\n\n\nint main(){\n  while(1){\n  ll A,B;\n  cin>>A>>B>>mod;\n  if(!A&&!B&&!mod)return 0;\n  RSQ2 T(B-A+1);\n  vector<string> num,S;\n  for(ll i=A;i<=B;i++)num.push_back(i2S(i));\n  S = num;\n  sort(num.begin(),num.end());\n  \n  ll ans = 0;\n  T.add(0,T.n,1);\n  for(int i=0;i<S.size();i++){\n    int idx = lower_bound(num.begin(),num.end(),S[i])-num.begin();\n    ll val = T.sum(idx,idx+1);\n    ans=(ans+val)%mod;\n    T.add(idx,T.n,val);\n  }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint a, b; ll p;\nint ten[10];\nll solve(){\n\tif(p==1) return 0;\n\tif(a==b) return 1;\n\tll dp[100002];\n\tfill(dp+1, dp+(b-a)+2, 1);\n\tll s[100002];\n\ts[0]=0; s[1]=1;\n\tint ind[100002]; ind[1]=1;\n\tfor(int i=2; i<=b-a+1; i++){\n\t\tint t=lower_bound(ten, ten+10, a-1+i)-ten;\n\t\tif(t<10 && ten[t]==a-1+i){\n\t\t\tind[i]=i;\n\t\t}else{\n\t\t\tind[i]=ind[i-1];\n\t\t}\n\t\tint x=a-1+i;\n\t\tdp[i]+=(s[i-1]-s[ind[i]-1]+p); dp[i]%=p;\n\t\twhile(1){\n\t\t\tx/=10;\n\t\t\tif(x<a) break;\n\t\t\tdp[i]+=(s[x-a+1]-s[ind[x-a+1]-1]+p); dp[i]%=p;\n\t\t}\n\t\ts[i]=(s[i-1]+dp[i])%p;\n\t}\n\treturn s[b-a+1];\n}\nint main()\n{\n\tten[0]=1; for(int i=1; i<10; i++) ten[i]=ten[i-1]*10;\n\twhile(1){\n\t\tcin>>a>>b>>p;\n\t\tif(a==0) return 0;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nll power(ll x,ll y,ll mod){\n\tll result=1;\n\twhile(y>0){\n\t\tif(y&1) result=result*x%mod;\n\t\tx=x*x%mod;\n        y>>=1;\n\t}\n\treturn result;\n}\n\nll f(int i){\n    return power(10,i,infll);\n}\n\nvoid solve(ll a,ll b,ll p){\n    ll ans=0;\n    unordered_map<ll,ll> dp;\n    dp[a]=1;\n    for(ll x=a; x<=b; ++x){\n        dp[x]=(dp[x]+dp[x-1]+p)%p;\n        ans=(ans+dp[x])%p;\n\n        ll y=x,i=to_string(x).size();\n        dp[y+1]=(dp[y+1]+dp[x])%p;\n        dp[f(i)]=(dp[f(i)]-dp[x]+p)%p;\n        for(;;){\n            y*=10;\n            ++i;\n            if(y>b) break;\n            dp[y]=(dp[y]+dp[x])%p;\n            dp[f(i)]=(dp[f(i)]-dp[x]+p)%p;\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        ll a,b,p;\n        cin >> a >> b >> p;\n        if(a==0 and b==0 and p==0) break;\n        solve(a,b,p);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nlong long int a, b, c;\n\n\ntemplate <typename D, typename T = D, typename L = T>\nclass Tree {\npublic:\n\tTree( long long int size = 0, D InitialValueArg = D() ) {\n\t\tlong long int n = 1LL;\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t\twhile( n <= size ) {\n\t\t\tn <<= 1LL;\n\t\t\taddOneLine( n );\n\t\t}\n\t\tInitialValue = InitialValueArg;\n\t\tData.resize( n, InitialValue );\n\t\tfor( size_t i = 0; i < Data.size(); i++ ) {\n\t\t\tupdate( i, Data[i] );\n\t\t}\n\t\tMaxSize = n;\n\t\tNowIndex = 0LL;\n\t}\n\n\tvirtual T preprocessing( D a ) {\n\t\treturn T( a );\n\t}\n\n\tvirtual T treeupdate( T a, T b ) {\n\t\treturn a;\n\t}\n\n\tvirtual L lazyupdate( L parent, L me ) {\n\t\treturn parent;\n\t}\n\n\tvirtual T fromlazytotreenode( L lazy, T nownode ) {\n\t\treturn nownode;\n\t}\n\n\tvoid update( long long int idx, D data ) {\n\t\t//calcLazyUpdate( idx, idx + 1 );\n\t\tData[idx] = data;\n\n\t\tupdateTreeNodeidx( idx, preprocessing( data ) );\n\t}\n\n\tvoid rangeupdate( long long int idxl, long long int idxr, L data ) {\n\n\t}\n\n\tvoid show() {\n\t\tfor( auto x : CalcTree ) {\n\t\t\tfor( auto y : x ) {\n\t\t\t\tcout << y << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tvoid push( D data ) {\n\t\tif( NowIndex == MaxSize ) {\n\t\t\tMaxSize <<= 1LL;\n\t\t\taddOneLine( MaxSize );\n\t\t\tvector<D>Datamemo( MaxSize, InitialValue );\n\t\t\tcopy( Data.begin(), Data.end(), Datamemo.begin() );\n\t\t\tfor( long long int i = 0; i < Datamemo.size(); i++ ) {\n\t\t\t\tupdate( i, Datamemo[i] );\n\t\t\t}\n\t\t}\n\t\tData[NowIndex] = data;\n\t\tupdate( NowIndex, data );\n\t\tNowIndex++;\n\t}\n\n\tT range( long long int l, long long int r ) {\n\t\tcalcLazyUpdate( l, r );\n\t\treturn rangeProcessing( 0, l, r, 0, 0, MaxSize );\n\t}\n\n\tlong long int t() {\n\t\treturn 10;\n\t}\n\nprivate:\n\n\t//??????????????????\n\tstruct TreeNode {\n\t\tT Ndata;\n\n\t\t//?????¶?????????\n\t\tstruct {\n\t\t\tlong long int Lnum;\n\t\t\tL Ldata;\n\t\t};\n\t};\n\tvector<vector<TreeNode>> CalcTree;\n\tvector<D> Data;\n\tlong long int MaxSize;\n\tlong long int NowIndex;\n\tD InitialValue;\n\n\tvoid addOneLine( long long int n ) {\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t}\n\n\tT rangeProcessing( long long int d, long long int a, long long int b, long long int k, long long int l, long long int r ) {\n\t\tif( !( r <= a || b <= l ) && d < CalcTree.size() ) {\n\t\t\tif( a <= l&&r <= b ) {\n\t\t\t\treturn CalcTree[d][k].Ndata;\n\t\t\t} else {\n\t\t\t\treturn treeupdate( rangeProcessing( d + 1, a, b, k * 2, l, ( l + r ) / 2 ), rangeProcessing( d + 1, a, b, k * 2 + 1, ( l + r ) / 2, r ) );\n\t\t\t}\n\t\t}\n\t\treturn InitialValue;\n\t}\n\n\tvoid calcLazyUpdate( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\t\tif( i < CalcTree.size() - 1 ) {\n\t\t\tCalcTree[i + 1][nowidx * 2].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2].Ldata );\n\t\t\tCalcTree[i + 1][nowidx * 2 + 1].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2 + 1].Ldata );\n\t\t\tCalcTree[i][nowidx].Ldata = L();\n\t\t\tlong long int nextidxplus = 1LL << ( CalcTree.size() - i - 1 );\n\t\t\tnowidx *= 2;\n\t\t\tif( idxr <= nowidx + nextidxplus ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx );\n\t\t\t} else if( nowidx + nextidxplus <= idxl ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx + 1 );\n\t\t\t} else {\n\t\t\t\tcalcLazyUpdate( nowidx + nextidxplus, idxr, i + 1, nowidx + 1 );\n\t\t\t\tcalcLazyUpdate( idxl, nowidx + nextidxplus, i + 1, nowidx );\n\t\t\t}\n\t\t} else {\n\t\t\tT nextT = fromlazytotreenode( CalcTree[i][nowidx].Ldata, CalcTree[i][nowidx].Ndata );\n\t\t\tif( nextT != CalcTree[i][nowidx].Ndata ) {\n\t\t\t\tupdateTreeNodeidx( nowidx, nextT );\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid updateTreeNodeidx( long long int idx, T TreeNodeData ) {\n\t\t( *( CalcTree.rbegin() ) )[idx].Ndata = preprocessing( TreeNodeData );\n\t\tfor( auto ite = CalcTree.rbegin(); ite + 1 < CalcTree.rend(); ) {\n\t\t\tidx >>= 1LL;\n\t\t\tT updatedata = treeupdate( ( *ite )[idx * 2].Ndata, ( *ite )[idx * 2 + 1].Ndata );\n\t\t\tite++;\n\t\t\tif( ( *ite )[idx].Ndata != updatedata ) {\n\t\t\t\t( *ite )[idx].Ndata = updatedata;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long int addrangeLazy( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\n\t}\n};\n\nclass segtree : public Tree<long long int> {\npublic:\n\tsegtree( long long int a, long long int b ):Tree( a, b ) {\n\n\t}\n\tlong long int treeupdate( long long int a, long long int b ) {\n\t\treturn ( a + b ) % c;\n\t}\n};\n\n\n\nint main() {\n\twhile( cin >> a >> b >> c, a || b || c ) {\n\t\tsegtree x( b - a + 1, 0 );\n\t\tvector<string>D( b - a + 1 );\n\t\tfor( long long int i = a; i <= b; i++ ) {\n\t\t\tD[i - a] = to_string( i );\n\t\t}\n\t\tsort( D.begin(), D.end() );\n\t\tvector<long long int >Dx( b - a + 1 );\n\t\tfor( long long int i = 0; i < b - a + 1; i++ ) {\n\t\t\tDx[i] = stoll( D[i] );\n\t\t\tx.update( Dx[i] - a, ( x.range( 0, Dx[i] - a ) + 1 ) );\n\t\t}\n\t\tcout << x.range( 0, b - a + 1 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\ntemplate <typename Base>\nclass BinaryIndexedTree\n{\nprivate:\n    static constexpr int sz(const int n)\n    {\n        int ans = 1;\n        for (; n > ans; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using T = typename Base::T;\n    using AbelGroup = Base;\n    BinaryIndexedTree(const int n) : data_num(n), size(sz(n)), value(size + 1, AbelGroup::id()) { assert(n > 0); }\n    T accumulate(const int a) const  // [0,a]\n    {\n        T sum = AbelGroup::id();\n        for (int ind = a + 1; ind > 0;) { sum = op(sum, value[ind]), ind &= ind - 1; }\n        return sum;\n    }\n    T accumulate(const int l, const int r) const { return (l >= r or r > data_num) ? 0 : op(accumulate(r - 1), AbelGroup::inv(l == 0 ? AbelGroup::id() : accumulate(l - 1))); }\n    void add(const int a, const T& val)\n    {\n        for (int ind = a + 1; ind <= size;) { value[ind] = op(value[ind], val), ind += ind & (-ind); }\n    }\n    void set(const int a, const T& val) { add(a, op(val, AbelGroup::inv(get(a)))); }\n    T get(const int a) const { return accumulate(a, a + 1); }\n    vector<T> data() const\n    {\n        vector<T> ans(data_num);\n        for (int i = 0; i < data_num; i++) { ans[i] = get(i); }\n        return ans;\n    }\n\nprivate:\n    const int data_num;\n    const int size;\n    const AbelGroup op{};\n    vector<T> value;\n};\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const BinaryIndexedTree<T>& bit)\n{\n    const auto v = bit.data();\n    os << \"[\";\n    for (const auto e : v) { os << e << \",\"; }\n    return (os << \"]\" << endl);\n}\n\nll P;\nstruct Sum\n{\n    using T = ll;\n    T operator()(const T& a, const T& b) const { return (a + b) % P; }\n    static T inv(const T& a) { return (P - a) % P; }\n    static constexpr T id() { return 0; }\n};\nint main()\n{\n    while (true) {\n        ll A, B;\n        cin >> A >> B >> P;\n        if (A == 0 and B == 0 and P == 0) { break; }\n        const ll NUM = B - A + 1;\n        auto dig = [](const ll n) {\n            int ans = -1;\n            for (ll num = 1; num <= n; ans++, num *= 10) {}\n            return ans;\n        };\n        const int MAXD = dig(B);\n        auto lower = [&](const ll n, const int di) {\n            ll ans = n;\n            for (int i = 0; i < di - dig(n); i++) { ans *= 10; }\n            return di == dig(n) ? ans + 1 : ans;\n        };\n        auto upper = [&](const int dig) {\n            ll ans = 1;\n            for (int i = 0; i <= dig; i++) { ans *= 10; }\n            return min(ans, B + 1);\n        };\n        BinaryIndexedTree<Sum> bit(NUM);\n        for (int i = NUM - 1; i >= 0; i--) {\n            const ll num = i + A;\n            const int d = dig(num);\n            ll sum = 1;\n            for (int t = d; t <= MAXD; t++) {\n                const ll u = upper(t) - A, l = lower(num, t) - A;\n                (sum += bit.accumulate(l, u)) %= P;\n            }\n            bit.add(i, sum);\n        }\n        cout << bit.accumulate(NUM - 1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstruct Mod\n{\n\tll num;\n\tMod() : num(0) { ; }\n\tMod(ll n) : num(n) { ; }\n\toperator ll() { return num; }\n};\n\nll mod = 1000000007;\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator^(Mod a, ll n)\n{\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { return a * inv(b); }\n\nMod fact(Mod n)\n{\n\tif (n < 0) assert(false);\n\tif (n == 0 || n == 1) return 1;\n\telse return n*fact(n - (Mod)1);\n}\n\nMod nPk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) assert(false);\n\treturn fact(n) / fact(k);\n}\n\nMod nCk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) assert(false);\n\treturn nPk(n, k) / fact(n - k);\n}\n\nMod nHk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) assert(false);\n\treturn nCk(n + k - (Mod)1, k);\n}\n\n\nint main()\n{\n\tll a, b;\n\twhile (cin >> a >> b >> mod, a)\n\t{\n\t\tMod dp[111111];\n\t\tdp[0] = 1;\n\t\tMod ans = 0;\n\t\tfor (ll i = a; i <= b; i++)\n\t\t{\n\t\t\tif (i > a)\n\t\t\t{\n\t\t\t\tdp[i - a] += dp[i - a - 1];\n\t\t\t}\n\t\t\tans += dp[i - a];\n\t\t\tfor (ll j = i; j <= b; j *= 10)\n\t\t\t{\n\t\t\t\tll t = 1;\n\t\t\t\twhile (t <= j) t *= 10;\n\t\t\t\tll l = max(i - a + 1, j - a), r = min(b - a + 1, t - a);\n\t\t\t\tdp[l] += dp[i - a];\n\t\t\t\tdp[r] -= dp[i - a];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string,ll> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nll n, m, p;\nint N;\nll bit[200001];\nvector<P> v;\n\nll sum(int i){\n\tll s = 0;\n\twhile(i > 0){\n        s = (s+bit[i])%p;\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, ll x){\n\twhile(i <= N){\n        bit[i] = (bit[i]+x)%p;\n\t\ti += i&-i;\n\t}\n}\n\nstring to_string(ll x){\n    stringstream ss;\n    ss << x;\n    return ss.str();\n}\n\nvoid solve(){\n    v.clear();\n    memset(bit,0,sizeof(bit));\n    N = m-n+2;\n    for(ll i = n; i <= m; i++){\n        string s = to_string(i);\n        v.push_back(P(s,i-n+2));\n    }\n    sort(v.begin(),v.end());\n    add(1,1);\n    rep(i,v.size()){\n        ll z = v[i].second;\n        add(z,sum(z));\n    }\n    cout << (sum(m-n+2)-1+p)%p << endl;\n}\n\nint main(){\n    while(cin >> n >> m >> p){\n        if(n == 0 && m == 0 && p == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {+0,+1,+0,-1};\nconst static int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nclass BIT {\nprivate:\n  int n;\n  ll* bit;\npublic:\n  BIT(int _n) {\n    n = _n;\n    bit = new ll[n]();\n  }\n  \n  ll sum(int i){\n    ll s = 0;\n    while(i > 0){\n      s += bit[i];\n      i -= i & -i;\n    }\n    return s;\n  }\n  \n  void add(int i, ll x){\n    while(i <= n){\n      bit[i] += x;\n      i += i & -i;\n    }\n  }\n};\n\nint main(){\n  int first_num;\n  int last_num;\n  int mod;\n  while(~scanf(\"%d %d %d\",&first_num,&last_num,&mod)){\n    if(first_num == 0 && last_num == 0 && mod == 0) break;\n    \n    vector<int> order_lexicon;\n    vector<string> nums;\n    \n    for(int start = first_num; start <= last_num; start++){\n      stringstream ss;\n      ss << start;\n      nums.push_back(ss.str());\n    }\n    sort(nums.begin(),nums.end());\n    \n    for(int num_i = 0; num_i < nums.size(); num_i++){\n      order_lexicon.push_back(atoi(nums[num_i].c_str()));\n    }\n    \n    ll res = 0;\n    BIT bit(last_num - first_num + 2);\n    for(int i = 0; i < order_lexicon.size();i++){\n      ll tmp = (bit.sum(order_lexicon[i] - first_num + 1) + 1) % mod;\n      res += tmp;\n      res %= mod;\n      bit.add(order_lexicon[i] - first_num + 1,tmp);\n    }\n    \n    printf(\"%lld\\n\",res % mod);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#define __float128 long double\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\ntemplate<class T>\nstruct BIT{\n\tvector<T> dat;\n\tint n;\n\n\tBIT(int _n){\n\t\tn = _n+10;\n\t\tdat.resize(n);\n\t}\n\n\tvoid add(int x, T val){\n\t\t++x;\n\t\tfor (int i = x; i < n; i += i&-i) dat[i] += val;\n\t}\n\tT sum(int x){\n\t\tT res = 0;\n\t\t++x;\n\t\tfor (int i = x; i > 0; i -= i&-i) res += dat[i];\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tll a, b, p;\n\twhile (cin >> a >> b >> p, a | b | p){\n\t\tll n = b - a + 1;\n\t\tvector<string> v(n);\n\t\trep(i, n) v[i] = to_string(a + i);\n\n\t\tauto sorted = v;\n\t\tsorted.push_back(\"0\");\n\t\tsort(ALL(sorted));\n\n\t\tBIT<ll> dp(n + 1);\n\n\t\tdp.add(0, 1);\n\t\trep(i, n){\n\t\t\tint id = lower_bound(ALL(sorted), v[i]) - sorted.begin();\n\t\t\tdp.add(id, dp.sum(id) % p);\n\t\t}\n\t\tcout << (dp.sum(n) + p - 1) % p << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nlong long A, B, C, N, bit[120000], dp[120000];\npair<string, int>x[120000];\nvoid add(int s, int t) {\n\twhile (s <= N + 1) { bit[s] += t; s += s&-s; }\n}\nlong long sum(int s) {\n\tlong long v = 0;\n\twhile (s >= 1) { v += bit[s]; s -= s&-s; }\n\treturn v;\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 120000; i++) {\n\t\t\tbit[i] = 0; x[i] = make_pair(\"\", 0); dp[i] = 0;\n\t\t}\n\t\tcin >> A >> B >> C; N = B - A + 1; if (C == 0)break;\n\t\tfor (int i = A; i <= B; i++) {\n\t\t\tx[i - A] = make_pair(to_string(i), i);\n\t\t}\n\t\tsort(x, x + N); dp[1] = 1; add(1, 1);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint T = x[i].second - A;\n\t\t\tdp[T + 2] = sum(T + 1); dp[T + 2] %= C;\n\t\t\tadd(T + 2, dp[T + 2]);\n\t\t}\n\t\tlong long res = 0;\n\t\tfor (int i = 2; i <= N + 1; i++)res += dp[i];\n\t\tcout << res%C << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// 1-origin\nstruct BIT{\n    int n, mod;\n    vector<int> v;\n\n    BIT(int _n, int _mod) : n(_n), mod(_mod){\n        v.resize(n+1, 0);\n    }\n\n    void add(int k, int x){\n        while(k <= n){\n            (v[k] += x) %= mod;\n            k += k&-k;\n        }\n    }\n\n    int sum(int k){\n        int ret = 0;\n        while(k > 0){\n            (ret += v[k]) %= mod;\n            k -= k&-k;\n        }\n        return ret;\n    }\n};\n\ntypedef long long ll;\n\nint main(){\n    int a, b, p;\n    while(cin >> a >> b >> p, p){\n        int n = b-a+1;\n        vector<string> vs;\n        for(int i = 0; i < n; i++)  vs.push_back(to_string(a+i));\n        sort(vs.begin(), vs.end());\n        vector<int> rev(n);\n        for(int i = 0; i < n; i++){\n            rev[stoi(vs[i])-a] = i;\n        }\n        ll ans = 0;\n        BIT bit(n, p);\n        for(int i = 0; i < n; i++){\n            ll tmp = bit.sum(rev[i])+1;\n            (ans += tmp) %= p;\n            bit.add(rev[i]+1, tmp);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll P;\nstruct BIT{\n  int n,bit[(1<<17)+2];\n\n  void init(int _n ){\n    memset(bit,0,sizeof(bit));\n    n = _n;\n  }\n\n  void add(int i,int x){\n    while( i <= n ){\n      bit[i] += x;\n      bit[i] %= P;\n      i += i & -i;\n    }\n  }\n\n  int sum(int i){\n    int s = 0;\n    while( i > 0 ) {\n      s += bit[i];\n      s %= P;\n      i -= i & -i;\n    }\n    return s;\n  }\n\n};\nint A,B;\nBIT dp;\nint D[100011];\nstring s[100011];\nint main(){\n\n  while( cin >> A >> B >> P && (A||B||P) ){\n    memset(D,-1,sizeof(D));\n    int N = B-A+1;\n    \n    dp.init(N+1);\n\n    for(int i=A;i<=B;i++){\n      stringstream sin; sin << i;\n      s[i-A] = sin.str();\n    }\n    sort(s,s+N);\n    for(int i=0;i<N;i++){\n      stringstream sin(s[i]);\n      int d; sin >> d;\n      D[d-A] = i;\n    }\n    D[N] = N;\n\n    for(int i=0;i<N;i++){\n      ll num = dp.sum(D[i]);\n      dp.add(D[i]+1,(num+1)%P);\n    }\n    cout << dp.sum(N)%P << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nlong long int a, b, c;\n\n\ntemplate <typename D, typename T = D, typename L = T>\nclass Tree {\npublic:\n\tTree( long long int size = 0, D InitialValueArg = D() ) {\n\t\tlong long int n = 1LL;\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t\twhile( n <= size ) {\n\t\t\tn <<= 1LL;\n\t\t\taddOneLine( n );\n\t\t}\n\t\tInitialValue = InitialValueArg;\n\t\tData.resize( n, InitialValue );\n\t\tfor( size_t i = 0; i < Data.size(); i++ ) {\n\t\t\tupdate( i, Data[i] );\n\t\t}\n\t\tMaxSize = n;\n\t\tNowIndex = 0LL;\n\t}\n\n\tvirtual T preprocessing( D a ) {\n\t\treturn T( a );\n\t}\n\n\tvirtual T treeupdate( T a, T b ) {\n\t\treturn a;\n\t}\n\n\tvirtual L lazyupdate( L parent, L me ) {\n\t\treturn parent;\n\t}\n\n\tvirtual T fromlazytotreenode( L lazy, T nownode ) {\n\t\treturn nownode;\n\t}\n\n\tvoid update( long long int idx, D data ) {\n\t\tcalcLazyUpdate( idx, idx + 1 );\n\t\tData[idx] = data;\n\n\t\tupdateTreeNodeidx( idx, preprocessing( data ) );\n\t}\n\n\tvoid rangeupdate( long long int idxl, long long int idxr, L data ) {\n\n\t}\n\n\tvoid show() {\n\t\tfor( auto x : CalcTree ) {\n\t\t\tfor( auto y : x ) {\n\t\t\t\tcout << y << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tvoid push( D data ) {\n\t\tif( NowIndex == MaxSize ) {\n\t\t\tMaxSize <<= 1LL;\n\t\t\taddOneLine( MaxSize );\n\t\t\tvector<D>Datamemo( MaxSize, InitialValue );\n\t\t\tcopy( Data.begin(), Data.end(), Datamemo.begin() );\n\t\t\tfor( long long int i = 0; i < Datamemo.size(); i++ ) {\n\t\t\t\tupdate( i, Datamemo[i] );\n\t\t\t}\n\t\t}\n\t\tData[NowIndex] = data;\n\t\tupdate( NowIndex, data );\n\t\tNowIndex++;\n\t}\n\n\tT range( long long int l, long long int r ) {\n\t\tcalcLazyUpdate( l, r );\n\t\treturn rangeProcessing( 0, l, r, 0, 0, MaxSize );\n\t}\n\n\tlong long int t() {\n\t\treturn 10;\n\t}\n\nprivate:\n\n\t//??????????????????\n\ttypedef struct TreeNode {\n\t\tT Ndata;\n\n\t\t//?????¶?????????\n\t\tstruct {\n\t\t\tlong long int Lnum;\n\t\t\tL Ldata;\n\t\t};\n\t};\n\tvector<vector<TreeNode>> CalcTree;\n\tvector<D> Data;\n\tlong long int MaxSize;\n\tlong long int NowIndex;\n\tD InitialValue;\n\n\tvoid addOneLine( long long int n ) {\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t}\n\n\tT rangeProcessing( long long int d, long long int a, long long int b, long long int k, long long int l, long long int r ) {\n\t\tif( !( r <= a || b <= l ) && d < CalcTree.size() ) {\n\t\t\tif( a <= l&&r <= b ) {\n\t\t\t\treturn CalcTree[d][k].Ndata;\n\t\t\t} else {\n\t\t\t\treturn treeupdate( rangeProcessing( d + 1, a, b, k * 2, l, ( l + r ) / 2 ), rangeProcessing( d + 1, a, b, k * 2 + 1, ( l + r ) / 2, r ) );\n\t\t\t}\n\t\t}\n\t\treturn InitialValue;\n\t}\n\n\tvoid calcLazyUpdate( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\t\tif( i < CalcTree.size() - 1 ) {\n\t\t\tCalcTree[i + 1][nowidx * 2].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2].Ldata );\n\t\t\tCalcTree[i + 1][nowidx * 2 + 1].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2 + 1].Ldata );\n\t\t\tCalcTree[i][nowidx].Ldata = L();\n\t\t\tlong long int nextidxplus = 1LL << ( CalcTree.size() - i - 1 );\n\t\t\tnowidx *= 2;\n\t\t\tif( idxr <= nowidx + nextidxplus ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx );\n\t\t\t} else if( nowidx + nextidxplus <= idxl ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx + 1 );\n\t\t\t} else {\n\t\t\t\tcalcLazyUpdate( nowidx + nextidxplus, idxr, i + 1, nowidx + 1 );\n\t\t\t\tcalcLazyUpdate( idxl, nowidx + nextidxplus, i + 1, nowidx );\n\t\t\t}\n\t\t} else {\n\t\t\tT nextT = fromlazytotreenode( CalcTree[i][nowidx].Ldata, CalcTree[i][nowidx].Ndata );\n\t\t\tif( nextT != CalcTree[i][nowidx].Ndata ) {\n\t\t\t\tupdateTreeNodeidx( nowidx, nextT );\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid updateTreeNodeidx( long long int idx, T TreeNodeData ) {\n\t\t( *( CalcTree.rbegin() ) )[idx].Ndata = preprocessing( TreeNodeData );\n\t\tfor( auto ite = CalcTree.rbegin(); ite + 1 < CalcTree.rend(); ) {\n\t\t\tidx >>= 1LL;\n\t\t\tT updatedata = treeupdate( ( *ite )[idx * 2].Ndata, ( *ite )[idx * 2 + 1].Ndata );\n\t\t\tite++;\n\t\t\tif( ( *ite )[idx].Ndata != updatedata ) {\n\t\t\t\t( *ite )[idx].Ndata = updatedata;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long int addrangeLazy( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\n\t}\n};\n\nclass segtree : public Tree<long long int> {\npublic:\n\tsegtree( long long int a, long long int b ):Tree( a, b ) {\n\n\t}\n\tlong long int treeupdate( long long int a, long long int b ) {\n\t\treturn ( a + b ) % c;\n\t}\n};\n\n\n\nint main() {\n\twhile( cin >> a >> b >> c, a || b || c ) {\n\t\tsegtree x( b - a + 1, 0 );\n\t\tvector<string>D( b - a + 1 );\n\t\tfor( size_t i = a; i <= b; i++ ) {\n\t\t\tD[i - a] = to_string( i );\n\t\t}\n\t\tsort( D.begin(), D.end() );\n\t\tvector<long long int >Dx( b - a + 1 );\n\t\tfor( size_t i = 0; i < b - a + 1; i++ ) {\n\t\t\tDx[i] = stoll( D[i] );\n\t\t\tx.update( Dx[i] - a, x.range( 0, i ) + 1 );\n\t\t}\n\t\tcout << x.range( 0, b - a + 2 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dp[100100], sum[100100], t[10];\n\nint main() {\n  int a, b, p, res;\n  t[0] = 1;\n  rep (i, 9) t[i + 1] = t[i] * 10;\n  while (true) {\n    cin >> a >> b >> p;\n    if (a == 0 && b == 0 && p == 0) break;\n    res = 0;\n    rep (i, b - a + 1) {\n      dp[i] = 1;\n      int m = (a + i) / 10;\n      while (a <= m && m <= b) {\n\tdp[i] += sum[m - a];\n\tdp[i] %= p;\n\tm /= 10;\n      }\n      rep (j, 10) if (a + i == t[j]) {\n\tsum[i] = dp[i];\n\tgoto end;\n      }\n      dp[i] += i > 0 ? sum[i - 1] : 0;\n      dp[i] %= p;\n      sum[i] = i > 0 ? sum[i - 1] + dp[i] : dp[i];\n      sum[i] %= p;\n    end:;\n      res += dp[i];\n      res %= p;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint a, b, p;\n\twhile (cin >> a >> b >> p, a) {\n\t\tvi memo(b - a + 1);\n\t\tll prev = 0;\n\t\trep(i, b - a + 1) {\n\t\t\tll next = 0;\n\t\t\tint pos = i + a;\n\t\t\twhile (pos % 10 == 0) {\n\t\t\t\tpos /= 10;\n\t\t\t\tif (pos >= a)next += memo[pos - a];\n\t\t\t}\n\t\t\tif (pos == 1)prev = 0;\n\t\t\tprev += next;\n\t\t\tnext = prev + 1;\n\t\t\tnext %= p;\n\t\t\tmemo[i] = next;\n\t\t\tprev += next;\n\t\t\tprev %= p;\n\t\t}\n\t\tll sum = 0;\n\t\trep(i, b - a + 1)sum += memo[i];\n\t\tsum %= p;\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<string, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define MAX_N 100010\n\nll p;\n\nstruct BIT{\n  ll bit[MAX_N];\n\n  void init(){\n    memset(bit,0,sizeof(bit));\n  }\n\n  ll sum(int i){\n    ll s=0;\n    while(i>0){\n      s=(s+bit[i])%p;\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(int i,ll v){\n    while(i<=MAX_N){\n      bit[i]=(bit[i]+v)%p;\n      i+=i&-i;\n    }\n  }\n};\n\nll a,b,n;\nll idx[100010];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>a>>b>>p;\n    if(a==0&&b==0&&p==0)break;\n    vector<P> ss;\n    n=b-a+1;\n    ss.resize(n);\n    rep(i,n){\n      ss[i]=P(to_string(i+a),i);\n    }\n    sort(all(ss));\n    rep(i,n){\n      idx[ss[i].se]=i;\n    }\n    BIT dp;\n    dp.init();\n    rep(i,n){\n      ll tmp=dp.sum(idx[i]+1)%p;\n      dp.add(idx[i]+1,(tmp+1)%p);\n    }\n    cout<<dp.sum(n+1)%p<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr int  MAX_N = (1 << 17);\n\nclass BIT {\n  public:\n    ll bit[MAX_N + 1], n;\n  \n    BIT()\n    {\n        n = MAX_N + 1;\n        for (int i = 0; i < n; i++) {\n            bit[i] = 0;\n        }\n    }\n\n    ll sum(int i, int P)\n    {\n        int s = 0;\n        while (i > 0) {\n            s = (s + bit[i]) % P;\n            i -= i & -i;\n        }\n        return s;\n    }\n  \n    void add(int i, int x, int P)\n    {\n        while (i <= n) {\n            bit[i] = (bit[i] + x) % P;\n            i += i & -i;\n        }\n    }\n};\n\nint main()\n{\n    int A, B, P;\n    while (cin >> A >> B >> P, A > 0) {\n        vector<string> str_num;\n        for (int i = A; i <= B; i++) {\n            str_num.emplace_back(to_string(i));\n        }\n\n        sort(str_num.begin(), str_num.end());                \n        \n        BIT b;\n        ll res = 0;\n        for (const auto& s : str_num) {\n            int v = stoi(s) - A + 1;\n            res = (res + b.sum(v, P) + 1) % P;\n            b.add(v, b.sum(v, P) + 1, P);\n        }\n        cout << res << endl;\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nint bottom(int n){\n    int res = 1;\n    while(res * 10 <= n){\n        res *= 10;\n    }\n    return res;\n}\n\nint slow(int A, int B, int P){\n    map<int, int> dp;\n    map<int, int> sum[12];\n    int ans = 0;\n    for(int i = A; i <= B; i++){\n        dp[i] = 1;\n        dp[i] = (dp[i] + sum[ to_string(i).size() ][i - 1]) % P;\n        /*\n        for(int k = bottom(i); k < i; k++){\n            dp[i] = (dp[i] + dp[k]) % P;\n        }\n        */\n        for(int k = i / 10; k > 0; k /= 10){\n            dp[i] = (dp[i] + sum[to_string(k).size()][k]) % P;\n        }\n        sum[to_string(i).size()][i] = (sum[ to_string(i).size() ][i - 1] + dp[i]) % P;\n        ans = (ans + dp[i]) % P;\n    }\n    return ans;\n}\nint main(){\n    LL A, B, P;\n    while(cin >> A >> B >> P && A > 0){\n        cout << slow(A, B, P) << endl;\n        /*\n        const int N = B - A + 1;\n        // [A, border - 1], [border, border * 10 - 1], ... [border * 10^n, B] \n        LL border = 10;\n        while(border - 1 < A){\n            border *= 10;\n        }\n        if(border > B){\n            LL ans = 1;\n            REP(i, N) ans = ans * 2 % P;\n        }else if(B < 10 * A){\n            const int N1 = border - A;\n            const int N2 = B - border + 1;\n            LL ans1 = 1, ans2 = 1;\n            REP(i, N1) ans1 = ans1 * 2 % P;\n            REP(i, N2) ans2 = ans2 * 2 % P;\n            cout << (ans1 + ans2 + P - 2) % P << endl;\n        }else{\n        }\n        */\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nstruct BIT\n{\n  vector<int> data;\n  BIT(int n):data(n+1, 0){}\n  int sum(int k, int P)\n  {\n    int ret = 0;\n    while(k > 0) {\n      ret = (ret + data[k]) % P;\n      k -= k & -k;\n    }\n    return ret;\n  }\n  void add(int k, int x, int P)\n  {\n    while(k < data.size()) {\n      data[k] = (data[k] + x) % P;\n      k += k & -k;\n    }\n  }\n};\n\nvector<string> lex;\nvector<int> idx;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int A, B, P;\n  while(cin >> A >> B >> P, A) {\n    int n = B - A;\n    BIT bit(n+1);\n    lex.clear(); lex.resize(n+1);\n    idx.clear(); idx.resize(n+1);\n    for(int i = A; i <= B; i++) lex[i-A] = to_string(i);\n    sort(all(lex));\n    for(int i = 0; i <= n; i++) idx[stoi(lex[i])-A] = i;\n    for(int i = 0; i <= n; i++) {\n      int sum = bit.sum(idx[i], P);\n      bit.add(idx[i]+1, (sum + 1) % P, P);\n    }      \n    cout << bit.sum(n+1, P) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef long long ll;\nll P(int a, int b){return (((ll)a)<<32)+b;}\nint check(int i){\n    for(;i>1;i/=10)if(i%10!=0)return 0;\n    return 1;\n}\nint st(int i){\n    int tmp = 1;\n    for(;tmp*10<=i;tmp*=10);\n    return tmp;\n}\nint main(){\n    int A, B;\n    ll MOD;\n    while(cin>>A>>B>>MOD, A){\n        map<ll, ll> mp;\n        ll ans = 0LL;\n        for(int i=A;i<=B;i++){\n            ll tmp = 1LL;\n            if(!check(i)){\n                tmp = (tmp + mp[P(st(i),i-1)])%MOD;\n            }\n            for(int j=i/10;j;j/=10){\n                tmp = (tmp + mp[P(st(j),j)])%MOD;\n            }\n            ans = (ans+tmp)%MOD;\n            if(check(i)){\n                mp[P(i, i)] = tmp;\n            }\n            else{\n                mp[P(st(i), i)] = (mp[P(st(i), i-1)] + tmp) % MOD;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll P;\nstruct BIT{\n  int n,bit[(1<<17)+2];\n\n  void init(int _n ){\n    memset(bit,0,sizeof(bit));\n    n = _n;\n  }\n\n  void add(int i,int x){\n    while( i <= n ){\n      bit[i] += x;\n      bit[i] %= P;\n      i += i & -i;\n    }\n  }\n\n  int sum(int i){\n    int s = 0;\n    while( i > 0 ) {\n      s += bit[i];\n      s %= P;\n      i -= i & -i;\n    }\n    return s;\n  }\n\n};\nint A,B;\nBIT dp;\nint D[100011];\nstring s[100011];\nint main(){\n\n  while( cin >> A >> B >> P && (A||B||P) ){\n    memset(D,-1,sizeof(D));\n    int N = B-A+1;\n    \n    dp.init(N+1);\n\n    for(int i=A;i<=B;i++){\n      stringstream sin; sin << i;\n      s[i-A] = sin.str();\n    }\n    sort(s,s+N);\n    for(int i=0;i<N;i++){\n      stringstream sin(s[i]);\n      int d; sin >> d;\n      D[d-A] = i;\n    }\n    D[N] = N;\n\n    for(int i=0;i<=N;i++){\n      ll num = dp.sum(D[i]);\n      dp.add(D[i]+1,(num+1)%P);\n    }\n    cout << (dp.sum(N+1)+P-dp.sum(N))%P << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint keta(int n){\n\tint ret = 0;\n\twhile(n){\n\t\tret++;\n\t\tn /= 10;\n\t}\n\treturn ret;\n}\n\nint flor(int n){\n\tint ke = keta(n),tmp = 1;\n\tfor(int i = 0;i < keta(n) - 1;i++) tmp *= 10;\n\treturn tmp;\n}\n\nsigned main(){\n\tint a,b,p;\n\twhile(cin >> a >> b >> p,a){\n\t\tint dp[150000] = {};\n\t\tif(a >= 11112){\n\t\t\tif(keta(a) != keta(b)){\n\t\t\t\tint tmp = flor(b),x = 1,y = 1;\n\t\t\t\tfor(int i = a;i < tmp;i++) x = x * 2 % p;\n\t\t\t\tfor(int i = tmp;i <= b;i++) y = y * 2 % p;\n\t\t\t\tcout << (x + y + p - 2) % p << endl;\n\t\t\t}else{\n\t\t\t\tint x = 1;\n\t\t\t\tfor(int i = a;i <= b;i++) x = x * 2 % p;\n\t\t\t\tcout << (x + p - 1) % p << endl;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = a;i <= b;i++){\n\t\t\tdp[i] = (dp[i - 1] * 2 - dp[flor(i) - 1] + p) % p;\n\t\t\tint tmp = i / 10;\n\t\t\twhile(tmp){\n\t\t\t\tdp[i] = (dp[i] + dp[tmp] - dp[flor(tmp) - 1] + p) % p;\n\t\t\t\ttmp /= 10;\n\t\t\t}\n\t\t\tdp[i] = (dp[i] + 1) % p;\n\t\t}\n\t\tcout << dp[b] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\ntemplate <typename MonoidType, typename OperatorType, class SegFunc>\nstruct LazySegmentTree {\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    void build(int m, const vector<MonoidType> &v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = SegFunc::combine(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = SegFunc::update(node[k], SegFunc::accumulate(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = SegFunc::lazy_update(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = SegFunc::lazy_update(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = SegFunc::lazy_update(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = SegFunc::combine(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return SegFunc::combine(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v(a >= mod ? a % mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\n\nsigned main() {\n    int A, B, P;\n    static int M;\n    while(cin >> A >> B >> P, A || B || P) {\n        int range = B - A + 1;\n        M = P;\n        struct SegFunc {\n            static int update(int a, int b) { return (a + b) % M; }\n            static int combine(int a, int b) { return (a + b) % M; }\n            static int lazy_update(int a, int b) { return (a + b) % M; }\n            static int accumulate(int a, int x) { return (a * x) % M; }\n        };\n\n        /*\n        LazySegmentTree<int, int> seg(range + 10, 0, 0,\n                                 [&](int a, int b) { return (a + b) % P; },\n                                 [&](int a, int b) { return (a + b) % P; },\n                                 [&](int a, int b) { return (a + b) % P; },\n                                 [&](int a, int x) { return (a * x) % P; });\n        */\n\n        LazySegmentTree<int, int, SegFunc> seg(range + 10, 0, 0);\n        \n        seg.update(0, range, 1);\n        for(int i=0; i<range; i++) {\n            int val = A + i, d = 0, t = val;\n            int ten = 1;\n            while(t) d++, ten *= 10, t /= 10;\n            d = max(d, 1LL);\n\n            int add = seg.query(i, i+1);\n            bool first = true;\n            for(; val <= B; val *= 10, d++, ten *= 10) {\n                int lb = val + first, ub = ten;\n\n                lb -= A, ub -= A;\n                ub = min(ub, range);\n\n                seg.update(lb, ub, add);\n                first = false;\n            }\n        }\n        cout << seg.query(0, range) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    \n    while(1){\n        \n        long long a, b, p; cin >> a >> b >> p;\n        if(!a) break;\n        //count [a, b]\n        long long n = b - a + 1;\n        vector<vector<long long> > dp(n + 1, vector<long long> (n + 1, 0));\n        dp[0][0] = 1LL;\n\n        for(long long i = 0; i < n; i++){\n            for(long long j = 0; j <= n; j++){\n                \n                //cout << i << endl;\n                //入れない\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= p;\n                //cout << \"dp[\" << i + 1 << \"][\" << j << \"] = \" << dp[i + 1][j] << endl;\n                \n\n                //辞書順が保たれるなら、入れる\n                long long num_i = i + a;\n                long long num_j = j + a - 1;\n                string str_i = to_string(num_i);\n                string str_j = to_string(num_j);\n\n                if(str_i > str_j){\n                    dp[i + 1][i + 1] += dp[i][j];\n                    dp[i + 1][i + 1] %= p;\n                    //cout << \"dp[\" << i + 1 << \"][\" << i << \"] = \" << dp[i + 1][i] << endl;\n                }\n            }\n        }\n\n        long long ans = 0LL;\n        for(int i = 0; i <= n; i++){\n            ans += dp[n][i];\n            ans %= p;\n        }\n\n        cout << ans -  1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define MAX 1100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nll A,B,MOD;\nll dp[MAX];\n\ninline\nint toIndex(ll a){ return a-A+1; }\n\nint main()\n{\n  while(cin >> A >> B >> MOD,A|B|MOD)\n    {\n      ll range = B-A+5;\n      rep(i,MAX)dp[i] = 0;\n      dp[1] = 1;//1-indexed\n      dp[toIndex(B+1)] = -1;\n\n      REP(cur,A,B+1)\n\t{\n\t  if(cur != A)dp[toIndex(cur)] = (dp[toIndex(cur)] + dp[toIndex(cur-1)]) % MOD;\n\t  ll sp = cur;\n\t  while(sp <= B)\n\t    {\n\t      int digit = (int)log10(sp) + 1;\n\t      ll p10 = 1LL;\n\t      rep(i,digit)p10 *= 10LL;\n\t      ll nsp = (sp == cur?cur+1LL:sp);\n\t      p10 = min(p10,B+1);\n\n\t      //cout << cur << \"-th :\"  << \" sp = \" << sp << \" nsp = \" << nsp << \" p10 = \" << p10 << endl; \n\t      dp[toIndex(nsp)]  = (dp[toIndex(nsp)]  + dp[toIndex(cur)]) % MOD;\n\t      dp[toIndex(p10)] = (dp[toIndex(p10)] + MOD- dp[toIndex(cur)]) % MOD;\n\t      sp = sp*10;\n\t    }\n\n\t}\n      ll ans = 0;\n      REP(i,A,B+1)\n\t{\n\t  ans = (dp[toIndex(i)] + ans) % MOD;\n\t  //cout << \"dp[\" << toIndex(i) << \"] = \" << dp[toIndex(i)] << \"\\n\";\n\t}\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nconst int RMAX = 200010;\nll BIT[RMAX];\n\nvoid add(int pos, ll x){\n  while (pos < RMAX){\n    BIT[pos] += x;\n    pos += -pos & pos;\n  }\n}\n\nll sum(int pos){\n  ll res = 0;\n  while (pos > 0){\n    res += BIT[pos];\n    pos -= -pos & pos;\n  }\n  return res;\n}\nint main(){\n  ios::sync_with_stdio(false);\n  ll A, B, P;\n  while (cin >> A>> B >> P && A + B + P){\n    memset(BIT, 0, sizeof(BIT));\n    vector<string> numbers;\n    for (ll i = A; i <= B; i++) numbers.push_back(to_string(i));\n    sort(ALL(numbers));\n\n    ll res = 0;\n\n    REP(i, numbers.size()){\n      ll offset = atoi(numbers[i].c_str()) - A;\n      ll dp_value = (sum(offset + 1) + 1) % P;\n      add(offset + 1, dp_value);\n      \n      res += dp_value;\n      res %= P;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint mod;\npair<double,int> v[131072];\nint bit[131072];\nint sum(int a,int b){\n\tif(a==0){\n\t\tint ret=0;\n\t\tfor(b;b>=0;b=(b&(b+1))-1)ret=(ret+bit[b])%mod;\n\t\treturn ret;\n\t}return (sum(0,b)-sum(0,a-1)+mod)%mod;\n}\nvoid add(int a,int b){\n\tfor(;a<131072;a|=a+1)bit[a]=(bit[a]+b)%mod;\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),c){\n\t\tmod=c;\n\t\tb++;\n\t\tfor(int i=a;i<b;i++){\n\t\t\tdouble now=(double)i;\n\t\t\tint keta=-1;\n\t\t\tint t=i;\n\t\t\twhile(t){\n\t\t\t\tnow*=0.1;\n\t\t\t\tketa++;\n\t\t\t\tt/=10;\n\t\t\t}\n\t\t\tnow+=keta*(1e-11);\n\t\t\tv[i-a]=make_pair(now,i-a);\n\t\t}\n\t\tstd::sort(v,v+b-a);\n\t\tfor(int i=0;i<131072;i++)bit[i]=0;\n\t\tfor(int i=0;i<b-a;i++){\n\t\t\tadd(v[i].second,sum(0,v[i].second)+1);\n\t\t}\n\t\tprintf(\"%d\\n\",sum(0,131071));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    \n    while(1){\n        \n        long long a, b, p; cin >> a >> b >> p;\n        if(!a) break;\n        //count [a, b]\n        long long n = b - a + 1;\n        vector<vector<long long> > dp(2, vector<long long> (n + 1, 0));\n        dp[0][0] = 1LL;\n        int now = 0;\n        int next = 1;\n\n        for(long long i = 0; i < n; i++){\n            \n            for(int j = 0; j <= n; j++) dp[next][j] = 0LL;\n            \n            for(long long j = 0; j <= n; j++){\n                \n            \n\n                //cout << i << endl;\n                //入れない\n                dp[next][j] += dp[now][j];\n                dp[next][j] %= p;\n                //cout << \"dp[\" << i + 1 << \"][\" << j << \"] = \" << dp[i + 1][j] << endl;\n                \n\n                //辞書順が保たれるなら、入れる\n                long long num_i = i + a;\n                long long num_j = j + a - 1;\n                string str_i = to_string(num_i);\n                string str_j = to_string(num_j);\n\n                if(str_i > str_j){\n                    dp[next][i + 1] += dp[now][j];\n                    dp[next][i + 1] %= p;\n                    //cout << \"dp[\" << i + 1 << \"][\" << i << \"] = \" << dp[i + 1][i] << endl;\n                }\n            }\n\n            swap(now, next);\n        }\n\n        long long ans = 0LL;\n        for(int i = 0; i <= n; i++){\n            ans += dp[now][i];\n            ans %= p;\n        }\n\n        cout << ans -  1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint M;\n\ntemplate<class T>\nclass FenwickTree{\n\tvector<T> a;\npublic:\n\tFenwickTree(int n):a(n){}\n\tT sum(int i,int j)const{\n\t\tif(i==0){\n\t\t\tT s=0;\n\t\t\tfor(;j>=0;j=(j&(j+1))-1) s=(s+a[j])%M;\n\t\t\treturn s;\n\t\t}\n\t\treturn ((sum(0,j)-sum(0,i-1))%M+M)%M;\n\t}\n\tvoid add(int i,T v){\n\t\tfor(;i<a.size();i|=i+1) a[i]=(a[i]+v)%M;\n\t}\n\tvoid clear(){ rep(i,a.size()) a[i]=0; }\n};\n\nbool lex(int a,int b){\n\tchar s[16],t[16];\n\tsprintf(s,\"%d\",a);\n\tsprintf(t,\"%d\",b);\n\treturn strcmp(s,t)<0;\n}\n\nint main(){\n\tint n,seq[100000];\n\tFenwickTree<int> F(100001);\n\n\tfor(int a,b;scanf(\"%d%d%d\",&a,&b,&M),a;){\n\t\tn=b-a+1;\n\t\trep(i,n) seq[i]=a+i;\n\t\tsort(seq,seq+n,lex);\n\n\t\tF.clear();\n\t\trep(i,n) F.add(seq[i]-a,F.sum(0,seq[i]-a)+1);\n\n\t\tprintf(\"%d\\n\",F.sum(0,n-1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint p;\n\nclass BIT{\npublic:\n    int n; vector<int> bit;\n    void add(int i,int x){\n        i++;\n        while(i < n) bit[i] = (bit[i]+x)%p, i += i & -i;\n    }\n    int sum(int i){\n        i++;\n        int s = 0;\n        while(i > 0) s = (s+bit[i])%p, i -= i & -i;\n        return s;\n    }\n    BIT(int sz){\n        n = sz+1, bit.resize(n,0);\n    }\n};\n\nint dp[100005];\n\nint main()\n{\n    while(1){\n        int a,b;\n        cin >> a >> b >> p;\n        if(a == 0) break;\n        vector<string> s(b-a+1);\n        int n = b-a+1;\n        for(int i=a;i<=b;i++){\n            string t;\n            int nw = i;\n            while(nw){\n                t.push_back((char)('0'+nw%10));\n                nw /= 10;\n            }\n            reverse(all(t));\n            s[i-a] = t;\n        }\n        sort(all(s));\n        vector<int> num(n);\n        rep(i,n){\n            dp[i] = 0, num[i] = stoi(s[i]);\n        }\n        BIT bt(n);\n        rep(i,n){\n            int res = bt.sum(num[i]-a);\n            res = (res+1)%p;\n            bt.add(num[i]-a,res);\n        }\n        cout << bt.sum(n-1) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass BIT {\nprivate:\n\tint size;\n\tvector<long long> bit;\n\tint mod;\n\npublic:\n\tBIT(int n, int m):size(n), bit(n + 1, 0), mod(m) {}\n\n\tvoid add(int i, int x) {\n\t\twhile(i <= size) {\n\t\t\tbit[i] += x;\n\t\t\tbit[i] %= mod;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\n\tlong long sum(int i) const {\n\t\tlong long s = 0;\n\t\twhile(i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s % mod;\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int a, b, p; cin >> a >> b >> p && a;) {\n\t\tconst int num = b - a + 2;\n\n\t\tvector<string> order;\n\t\torder.reserve(num);\n\n\t\tfor(int i = a; i <= b; ++i) {\n\t\t\torder.emplace_back(to_string(i));\n\t\t}\n\n\t\tsort(order.begin(), order.end());\n\n\t\tBIT bit(num, p);\n\t\tbit.add(1, 1);\n\n\t\tfor(const auto &s : order) {\n\t\t\tconst int index = stoi(s) - a + 2;\n\t\t\tconst auto tmp = bit.sum(index - 1);\n\t\t\tbit.add(index, tmp);\n\t\t}\n\n\t\tcout << (bit.sum(num) - 1 + p) % p << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define MAX 1100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nll A,B,MOD;\nll dp[MAX];\n\ninline\nint toIndex(ll a){ return a-A+1; }\n\nint main()\n{\n  while(cin >> A >> B >> MOD,A|B|MOD)\n    {\n      ll range = B-A+5;\n      rep(i,range)dp[i] = 0;\n      dp[1] = 1;//1-indexed\n      dp[toIndex(B+1)] = -1;\n\n      REP(cur,A,B+1)\n\t{\n\t  if(cur != A)dp[toIndex(cur)] = (dp[toIndex(cur)] + dp[toIndex(cur-1)]) % MOD;\n\t  ll sp = cur;\n\t  while(sp <= B)\n\t    {\n\t      int digit = (int)log10(sp) + 1;\n\t      ll p10 = 1LL;\n\t      rep(i,digit)p10 *= 10LL;\n\t      ll nsp = (sp == cur?cur+1LL:sp);\n\t      p10 = min(p10,B+1);\n\n\t      dp[toIndex(nsp)]  = (dp[toIndex(nsp)]  + dp[toIndex(cur)]) % MOD;\n\t      dp[toIndex(p10)] = (dp[toIndex(p10)] + MOD - dp[toIndex(cur)]) % MOD;\n\t      sp = sp*10;\n\t    }\n\n\t}\n\n      ll ans = 0;\n      REP(i,A,B+1)ans = (dp[toIndex(i)] + ans) % MOD;\n\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nint a, b, p;\nint seg_tree[seg_size * 2];\nint seg_find(int now, int n_l, int n_r, int w_l, int w_r) {\n    if (w_l <= n_l && n_r <= w_r) return seg_tree[now];\n    if (w_r <= n_l || n_r <= w_l) return 0;\n    return seg_find(now * 2, n_l, (n_l + n_r) / 2, w_l, w_r)\n        + seg_find(now * 2 + 1, (n_l + n_r) / 2, n_r, w_l, w_r);\n}\nvoid seg_set(int now) {\n    seg_tree[now] = seg_tree[now * 2] + seg_tree[now * 2 + 1];\n    if (now > 1)seg_set(now / 2);\n}\nvoid solve(){\n    while (true) {\n        REP(i, seg_size * 2) {\n            seg_tree[i] = 0;\n        }\n        cin >> a >> b >> p;\n        if (a == 0) return;\n        vector<string> inputs;\n        for (int i = a; i <= b; ++i) {\n            inputs.push_back(to_string(i));\n        }\n        sort(ALL(inputs));\n        seg_tree[(seg_size)] += 1;\n        seg_set(seg_size / 2);\n        int ans = 0;\n        for (int i = 0; i < inputs.size(); ++i) {\n            int hoge = stoll(inputs[i]) - a + 1LL;\n            seg_tree[seg_size + hoge] = seg_find(1, 0, seg_size, 0, hoge) % p;\n            ans += seg_tree[seg_size + hoge];\n            seg_set((seg_size + hoge) / 2);\n        }\n        cout << ans % p << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1 << 17;\nll seg[2 * N];\nll A, B, P;\n\nvoid init(){ memset(seg, 0, sizeof(seg)); }\nvoid update(int x, ll v){\n  x += N - 1;\n  seg[x] = v % P;\n  while (x > 0){\n    x = (x - 1) >> 1;\n    seg[x] = seg[x + x + 1] + seg[x + x + 2];\n    seg[x] %= P;\n  }\n}\nll sum(int a, int b, int x=0, int l=0, int r=N){\n  if (r <= a || b <= l) return 0;\n  if (a <= l && r <= b) return seg[x];\n  ll lr = sum(a, b, x + x + 1, l, (l + r) >> 1);\n  ll rr = sum(a, b, x + x + 2, (l + r) >> 1, r);\n  return (lr + rr) % P;\n}\n\nll rten(ll x){\n  ll r = 1;\n  while (r * 10 <= x) r *= 10;\n  return r;\n}\n\nint main()\n{\n  while (cin >> A >> B >> P, A){\n    init();\n    update(0, 1);\n    for (ll x = A + 1; x <= B; x++){\n      ll s = sum(max(rten(x) - A, 0ll), x - A) + 1;\n      for (ll y = x / 10; y >= A; y /= 10){\n        s += sum(max(rten(y) - A, 0ll), y - A + 1);\n        s %= P;\n      }\n      update(x - A, s);\n    }\n    cout << sum(0, N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint bit[100100];\nint N, P;\n\nvoid add(int k, int x)\n{\n    for (; k <= N + 1; k += k & -k){\n        bit[k] = (bit[k] + x) % P;\n    }\n}\n\nint sum(int k)\n{\n    int ret = 0;\n    for (; k; k &= (k - 1)){\n        ret = (ret + bit[k]) % P;\n    }\n    return (ret);\n}\n\nbool radix(int a, int b)\n{\n    if ((int)log10(a) == (int)log10(b)) return (a < b);\n    return (to_string(a) < to_string(b));\n}\n\nint main()\n{\n    int A, B;\n    int v[100000];\n\n    while (scanf(\"%d %d %d\", &A, &B, &P) && A){\n       memset(bit, 0, sizeof(bit));\n       N = B - A + 1;\n       add(N + 1, 1);\n\n       for (int i = 0; i < N; i++){\n           v[i] = A + i;\n        }\n\n       sort(v, v + N, radix);\n\n       for (int i = N - 1; i >= 0; i--){\n           int nv = (sum(N + 1) - sum(v[i] - A) + P) % P;\n           add(v[i] - A + 1, nv);\n       }\n\n       printf(\"%d\\n\", sum(N));\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sst stringstream\n#define sz size()\n#define vc vector\ntypedef vc<int> vi;\ntypedef vc<ll> vl;\ntypedef vc<string> vs;\n\n#define MAXN (1<<17)\n\nll bit[MAXN+1],n=MAXN;\n\nvoid init(){\n\tfill(bit,bit+n+1,0);\n}\n\nll sum(ll i){\n\tll s=0;\n\twhile(i){\n\t\ts+=bit[i];\n\t\ti-=i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i,ll x){\n\twhile(i<=n){\n\t\tbit[i]+=x;\n\t\ti+=i&-i;\n\t}\n}\n\nint A,B,P,a[100010],N;\nstring s[100010];\n\nbool comp(int a,int b){\n\treturn s[a-A]<s[b-A];\n}\n\nint main(){\n\twhile(cin>>A>>B>>P && A){\n\t\tinit();\n\t\tN=B-A+1;\n\t\trep2(i,A,B+1){\n\t\t\ta[i-A]=i;\n\t\t\tsst ss;\n\t\t\tss<<i;\n\t\t\ts[i-A]=ss.str();\n\t\t}\n\t\tsort(a,a+N,comp);\n\t\tll ans=0;\n\t\trep(i,N){\n\t\t\tll res=(1+sum(a[i]-A+1))%P;\n\t\t\tans=(ans+res)%P;\n\t\t\tadd(a[i]-A+1,res);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a + b.num); }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a*b.num); }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tMod sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tMod lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tMod adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint a, b; ll p;\nint ten[10];\nll solve(){\n\tif(a==b) return 1;\n\tll dp[100002];\n\tfill(dp+1, dp+(b-a)+2, 1);\n\tll s[100002];\n\ts[0]=0; s[1]=1;\n\tint ind[100002]; ind[1]=1;\n\tfor(int i=2; i<=b-a+1; i++){\n\t\tint t=lower_bound(ten, ten+10, a-1+i)-ten;\n\t\tif(t<10 && ten[t]==a-1+i){\n\t\t\tind[i]=i;\n\t\t}else{\n\t\t\tind[i]=ind[i-1];\n\t\t}\n\t\tint x=a-1+i;\n\t\tdp[i]+=(s[i-1]-s[ind[i]-1]+p); dp[i]%=p;\n\t\twhile(1){\n\t\t\tx/=10;\n\t\t\tif(x<a) break;\n\t\t\tdp[i]+=(s[x-a+1]-s[ind[x-a+1]-1]+p); dp[i]%=p;\n\t\t}\n\t\ts[i]=(s[i-1]+dp[i])%p;\n\t}\n\treturn s[b-a+1];\n}\nint main()\n{\n\tten[0]=1; for(int i=1; i<10; i++) ten[i]=ten[i-1]*10;\n\twhile(1){\n\t\tcin>>a>>b>>p;\n\t\tif(a==0) return 0;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <sstream>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntemplate<class T> T getAs(){ T v; std::cin >> v; return v; }\ninline int getInt(){ return getAs<int>(); }\n\nusing namespace std;\n\nstring to_str(int a){ stringstream ss; ss << a; return ss.str(); }\n\nint mod;\n\ntemplate<class T>\nclass BIT{\n  vector<T> data;\n  size_t n;\npublic:\n  BIT(size_t nn) : data(vector<int>(nn + 1)), n(nn) {}\n\n  T sum(int i){\n    T s = (T)0;\n    i++;\n    while(i > 0){\n      s += data[i]; s %= mod;\n      i -= i & -i;\n    }\n    return s;\n  }\n\n  void add(int i, T x){\n    i++;\n    while(i <= (int)n){\n      data[i] += x; data[i] %= mod;\n      i += i & -i;\n    }\n  }\n};\n\nint main(){\n  while(true){\n    int a = getInt();\n    int b = getInt();\n    int p = getInt(); mod = p;\n\n    if(a + b + p == 0) break;\n\n    vector<string> v(b - a + 1);\n    vector<int> num(b - a + 1);\n    BIT<int> bit(b - a + 2);\n\n    REP(i, b - a + 1) v[i] = to_str(a + i);\n    sort(v.begin(), v.end());\n    REP(i, b - a + 1) num[i] = atoi(v[i].c_str());\n\n    bit.add(0, 1);\n    REP(i, b - a + 1){\n      bit.add(num[i] - a + 1, bit.sum(num[i] - a));\n    }\n\n    cout << (p + bit.sum(b - a + 1) - 1) % p << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a + b.num); }\nMod operator+(const Mod a, const long long int  b) { return b+a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a*b.num); }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<17) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tlong long int sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tlong long int lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tseg[k].sum %= mod;\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n\tseg[k].sum %= mod;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tlong long int adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\ntemplate <typename Base>\nclass BinaryIndexedTree\n{\nprivate:\n    static constexpr int sz(const int n)\n    {\n        int ans = 1;\n        for (; n > ans; ans <<= 1) {}\n        return ans;\n    }\n\npublic:\n    using T = typename Base::T;\n    using AbelGroup = Base;\n    BinaryIndexedTree(const int n) : data_num(n), size(sz(n)), value(size + 1, AbelGroup::id()) { assert(n > 0); }\n    T accumulate(const int a) const  // [0,a]\n    {\n        T sum = AbelGroup::id();\n        for (int ind = a + 1; ind > 0;) { sum = op(sum, value[ind]), ind &= ind - 1; }\n        return sum;\n    }\n    T accumulate(const int l, const int r) const { return (l >= r or r > data_num) ? 0 : op(accumulate(r - 1), AbelGroup::inv(l == 0 ? AbelGroup::id() : accumulate(l - 1))); }\n    void add(const int a, const T& val)\n    {\n        for (int ind = a + 1; ind <= size;) { value[ind] = op(value[ind], val), ind += ind & (-ind); }\n    }\n    void set(const int a, const T& val) { add(a, op(val, AbelGroup::inv(get(a)))); }\n    T get(const int a) const { return accumulate(a, a + 1); }\n    vector<T> data() const\n    {\n        vector<T> ans(data_num);\n        for (int i = 0; i < data_num; i++) { ans[i] = get(i); }\n        return ans;\n    }\n\nprivate:\n    const int data_num;\n    const int size;\n    const AbelGroup op{};\n    vector<T> value;\n};\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const BinaryIndexedTree<T>& bit)\n{\n    const auto v = bit.data();\n    os << \"[\";\n    for (const auto e : v) { os << e << \",\"; }\n    return (os << \"]\" << endl);\n}\n\nll P;\nstruct Sum\n{\n    using T = ll;\n    T operator()(const T& a, const T& b) const { return (a + b) % P; }\n    static T inv(const T& a) { return (P - a) % P; }\n    static constexpr T id() { return 0; }\n};\nint main()\n{\n    while (true) {\n        ll A, B;\n        cin >> A >> B >> P;\n        if (A == 0 and B == 0 and P == 0) { break; }\n        const ll NUM = B - A + 1;\n        auto dig = [](const ll n) {\n            int ans = -1;\n            for (ll num = 1; num <= n; ans++, num *= 10) {}\n            return ans;\n        };\n        const int MAXD = dig(B);\n        auto lower = [&](const ll n, const int di) {\n            ll ans = n;\n            for (int i = 0; i < di - dig(n); i++) { ans *= 10; }\n            return di == dig(n) ? ans + 1 : ans;\n        };\n        auto upper = [&](const int dig) {\n            ll ans = 1;\n            for (int i = 0; i <= dig; i++) { ans *= 10; }\n            return min(ans, B + 1);\n        };\n        BinaryIndexedTree<Sum> bit(NUM);\n        for (int i = NUM - 1; i >= 0; i--) {\n            const ll num = i + A;\n            const int d = dig(num);\n            ll sum = 1;\n            for (int t = d; t <= MAXD; t++) {\n                const ll u = upper(t) - A, l = lower(num, t) - A;\n                (sum += bit.accumulate(l, u)) %= P;\n            }\n            bit.add(i, sum);\n        }\n        cout << bit.accumulate(NUM - 1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\n\ntemplate<typename T>\nstruct BIT {\n    vector<T> bit;\n    int sz;\n\n    BIT(int n) : sz(n+1), bit(n+1) {}\n\n    void add(int i, T x) {\n        i += 1;\n        while (i < sz) { bit[i] += x; i += i & -i; }\n    }\n\n    T sum(int i) {\n        i += 1; T s = 0;\n        while (i > 0) { s += bit[i]; i -= i & -i; }\n        return s;\n    }\n};\n\n\nlong long mod;\n\nstruct modint {\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (int k = 0; ; ++k) {\n        int A, B, P;\n        cin >> A >> B >> P;\n        if (P == 0) {\n            break;\n        }\n\n        vector<string> ss;\n        for (int x = A; x <= B; ++x) {\n            ss.emplace_back(to_string(x));\n        }\n        sort(ss.begin(), ss.end());\n\n        mod = P;\n        using Int = modint;\n\n        BIT<Int> bit(B-A+1);\n        for (string& s : ss) {\n            int x = stoi(s);\n            bit.add(x-A, bit.sum(x-A)+1);\n        }\n\n        cout << bit.sum(B-A) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1 << 17;\nll seg[2 * N];\nll A, B, P;\n\nvoid init(){ memset(seg, 0, sizeof(seg)); }\nvoid update(int x, ll v){\n  x += N - 1;\n  seg[x] = v % P;\n  while (x > 0){\n    x = (x - 1) >> 1;\n    seg[x] = seg[x + x + 1] + seg[x + x + 2];\n    seg[x] %= P;\n  }\n}\ninline ll sum(int a, int b, int x=0, int l=0, int r=N){\n  if (r <= a || b <= l) return 0;\n  if (a <= l && r <= b) return seg[x];\n  ll lr = sum(a, b, x + x + 1, l, (l + r) >> 1);\n  ll rr = sum(a, b, x + x + 2, (l + r) >> 1, r);\n  return (lr + rr) % P;\n}\n\ninline ll rten(ll x){\n  ll r = 1;\n  while (r * 10 <= x) r *= 10;\n  return r;\n}\n\nint main()\n{\n  while (cin >> A >> B >> P, A){\n    init();\n    update(0, 1);\n    for (ll x = A + 1; x <= B; x++){\n      ll s = sum(max(rten(x) - A, 0ll), x - A) + 1;\n      for (ll y = x / 10; y >= A; y /= 10){\n        s += sum(max(rten(y) - A, 0ll), y - A + 1);\n        s %= P;\n      }\n      update(x - A, s);\n    }\n    cout << sum(0, N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/04/25  Problem: AOJ 2326 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2326  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\ntemplate<typename type>\nstruct BIT { // 1-index\n\tint N;\n\tint nn;\n\tvector<type> data;\n\tBIT(int n) {\n\t\tN = n + 1;\n\t\tdata = vector<type>(n + 1, 0);\n\t\tnn = 1;\n\t\twhile (nn * 2 <= N)nn *= 2;\n\t}\n\tvoid add(int i, type w) { // a[i] += w\n\t\tfor (int x = i; x <= N; x += x & -x) {\n\t\t\tdata[x] += w;\n\t\t}\n\t}\n\ttype sum(int i) { // iまでの和 [1,i]\n\t\ttype ret = 0;\n\t\tfor (int x = i; x > 0; x -= x & -x) {\n\t\t\tret += data[x];\n\t\t}\n\t\treturn ret;\n\t}\n\t// [l, r]\n\ttype sum(int l, int r) {\n\t\tif (l > r) return 0;\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n};\n\n\nLL N;\n\nLL ans = 0LL;\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tLL a, b, p;\n\twhile (cin >> a >> b >> p, a || b || p) {\n\t\tBIT<LL> bit(b + 1);\n\t\tvector<string>vs;\n\t\tFOR(i, a, b + 1) {\n\t\t\tvs.push_back(to_string(i));\n\t\t}\n\n\t\tSORT(vs);\n\n\t\tVL tps(SZ(vs));\n\t\tFOR(i, 0, SZ(vs)) {\n\t\t\t//debug(stoll(vs[i]) - a);\n\t\t\ttps[stoll(vs[i])-a] = i;\n\t\t}\n\t\tFOR(i, 0, SZ(vs)) {\n\t\t\tLL val = bit.sum(tps[i]);\n\t\t\tbit.add(tps[i] + 1, (val + 1) % p);\n\t\t}\n\t\tans = bit.sum(b - a + 1) % p;\n\t\tcout << ans << \"\\n\";\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cctype>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string::const_iterator State;\nclass ParseError {};\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint main(){\n    string s;\n    cin >> s;\n    while(3 < s.size()){\n        int f = s.size();\n        for(int i=1; i < s.size()-3; i++){\n            string mew = s.substr(i, 3);\n            if(mew == \"mew\") s = s.substr(0, i) + s.substr(i+3);\n        }\n        if(f == s.size()) break;\n    }\n    if(s.size() == 3 && s == \"mew\") cout << \"Cat\" << endl;\n    else cout << \"Rabit\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll A, B, P;\n\n// 1-indexed\nclass BIT{\nprivate:\n    vector<ll> bit;\n    \npublic:\n    BIT(int n){\n        bit.resize(n+1);\n    }\n    \n    ll sum(int i){\n        ll s = 0;\n        while(i > 0){\n            s = (s + bit[i]) % P;\n            i -= i&-i;\n        }\n        return s;\n    }\n    \n    void add(int i, ll v){\n        while(i <= bit.size()){\n            bit[i] = (bit[i] + v) % P;\n            i += i&-i;\n        }\n    }\n};\n\nstring ltos(ll a){\n    string res = \"\";\n    while(a){\n        res += a%10 + '0';\n        a /= 10;\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n\nvoid solve(){\n    int D = B - A + 1;\n    \n    vector<pair<string, int>> vec;\n    for(ll i=0; i<D; i++)\n        vec.push_back(make_pair(ltos(A+i), i));\n    sort(vec.begin(), vec.end());\n    \n    vector<int> lexorders(D);\n    for(int i=0; i<D; i++)\n        lexorders[vec[i].second] = i;\n    \n    vector<ll> dp(D);\n    ll ans = 0;\n    \n    BIT bit = BIT(D);\n    for(int i=0; i<D; i++){\n        dp[i] = (1 + bit.sum(lexorders[i])) % P;\n        ans = (ans + dp[i]) % P;\n        bit.add(lexorders[i]+1, dp[i]);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> A >> B >> P, A|B|P)\n        solve();\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll P;\nstruct BIT{\n  int n,bit[(1<<17)+2];\n\n  void init(int _n ){\n    memset(bit,0,sizeof(bit));\n    n = _n;\n  }\n\n  void add(int i,int x){\n    while( i <= n ){\n      bit[i] += x;\n      bit[i] %= P;\n      i += i & -i;\n    }\n  }\n\n  int sum(int i){\n    int s = 0;\n    while( i > 0 ) {\n      s += bit[i];\n      s %= P;\n      i -= i & -i;\n    }\n    return s;\n  }\n\n};\nint A,B;\nBIT dp;\nint D[100011];\nstring s[100011];\nint main(){\n\n  while( cin >> A >> B >> P && (A||B||P) ){\n    memset(D,-1,sizeof(D));\n    int N = B-A+1;\n    \n    dp.init(N+1);\n\n    for(int i=A;i<=B;i++){\n      stringstream sin; sin << i;\n      s[i-A] = sin.str();\n    }\n    sort(s,s+N);\n    for(int i=0;i<N;i++){\n      stringstream sin(s[i]);\n      int d; sin >> d;\n      D[d-A] = i;\n    }\n    D[N] = N;\n\n    for(int i=0;i<N;i++){\n      ll num = dp.sum(D[i]);\n      dp.add(D[i]+1,(num+1)%P);\n    }\n    cout << (dp.sum(N)+1LL)%P << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct node{\n    int val,sum;\n    node *to[10];\n\n    node(){\n        val=sum=0;\n        rep(i,10)to[i]=NULL;\n    }\n};\n\nint A,B,P;\n\nvoid insert(node *t,string &s,int i,int v){\n    if(i==s.size()){\n        t->val=v;\n        t->sum=(t->sum+v)%P;\n        return;\n    }\n\n    int c=s[i]-'0';\n    if(t->to[c]==NULL){\n        t->to[c]=new node();\n    }\n    t->sum=(t->sum-t->to[c]->sum+P)%P;\n    insert(t->to[c],s,i+1,v);\n    t->sum=(t->sum+t->to[c]->sum)%P;\n}\n\nint query(node *t,string &s,int i){\n    int ret=0;\n    int c=s[i]-'0';\n    for(int j=0;j<c;j++)if(t->to[j]!=NULL)ret=(ret+t->to[j]->sum)%P;\n    ret=(ret+t->val)%P;\n    if(t->to[c]!=NULL)ret=(ret+query(t->to[c],s,i+1))%P;\n    return ret;\n}\n\nvoid del(node *t){\n    rep(i,10)if(t->to[i]!=NULL)del(t->to[i]);\n    delete t;\n}\n\nsigned main(){\n    while(cin>>A>>B>>P,A||B||P){\n        int ans=0;\n        node *root=new node();\n        for(int i=A;i<=B;i++){\n            stringstream ss;\n            ss<<i;\n            string s=ss.str();\n            int tmp=(query(root,s,0)+1)%P;\n            ans=(ans+tmp)%P;\n            insert(root,s,0,tmp);\n        }\n        cout<<ans<<endl;\n\n        del(root);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define MAX 1100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nll A,B,MOD;\nll dp[MAX];\n\ninline\nint toIndex(ll a){ return a-A+1; }\n\nint main()\n{\n  while(cin >> A >> B >> MOD,A|B|MOD)\n    {\n      ll range = B-A+5;\n      rep(i,MAX)dp[i] = 0;\n      dp[1] = 1;//1-indexed\n      dp[toIndex(B+1)] = -1;\n\n      REP(cur,A,B+1)\n\t{\n\t  if(cur != A)dp[toIndex(cur)] = (dp[toIndex(cur)] + dp[toIndex(cur-1)]) % MOD;\n\t  ll sp = cur;\n\t  while(sp <= B)\n\t    {\n\t      int digit = (int)log10(sp) + 1;\n\t      ll p10 = 1LL;\n\t      rep(i,digit)p10 *= 10LL;\n\t      ll nsp = (sp == cur?cur+1LL:sp);\n\t      p10 = min(p10,B+1);\n\n\t      //cout << cur << \"-th :\"  << \" sp = \" << sp << \" nsp = \" << nsp << \" p10 = \" << p10 << endl; \n\t      dp[toIndex(nsp)]  = (dp[toIndex(nsp)]  + dp[toIndex(cur)]) % MOD;\n\t      dp[toIndex(p10)] = (dp[toIndex(p10)] - dp[toIndex(cur)]) % MOD;\n\t      sp = sp*10;\n\t    }\n\n\t}\n      ll ans = 0;\n      REP(i,A,B+1)\n\t{\n\t  ans = (dp[toIndex(i)] + ans) % MOD;\n\t  //cout << \"dp[\" << toIndex(i) << \"] = \" << dp[toIndex(i)] << \"\\n\";\n\t}\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nlong long A, B, C, N, bit[120000], dp[120000];\npair<string, int>x[120000];\nvoid add(int s, int t) {\n\twhile (s <= N + 1) { bit[s] += t; s += s&-s; }\n}\nlong long sum(int s) {\n\tlong long v = 0;\n\twhile (s >= 1) { v += bit[s]; s -= s&-s; }\n\treturn v;\n}\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 120000; i++) {\n\t\t\tbit[i] = 0; x[i] = make_pair(\"\", 0); dp[i] = 0;\n\t\t}\n\t\tcin >> A >> B >> C; N = B - A + 1; if (C == 0)break;\n\t\tfor (int i = A; i <= B; i++) {\n\t\t\tx[i - A] = make_pair(to_string(i), i);\n\t\t}\n\t\tsort(x, x + N); dp[1] = 1; add(1, 1);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint T = x[i].second - A;\n\t\t\tdp[T + 2] = sum(T + 1); dp[T + 2] %= C;\n\t\t\tadd(T + 2, dp[T + 2]);\n\t\t}\n\t\tlong long res = 0;\n\t\tfor (int i = 2; i <= N + 1; i++)res += dp[i];\n\t\tcout << res%C << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef long long ll;\ntypedef pair<string, ll> psi;\n\nll p;\n\ntemplate <class T>\nstruct fenwick_tree {\n  vector<T> x;\n  fenwick_tree(int n) : x(n, 0) { }\n  T sum(int i, int j) {\n    if (i == 0) {\n      T S = 0;\n      for (j; j >= 0; j = (j & (j + 1)) - 1) S = (S+x[j])%p;\n      return S;\n    } else return sum(0, j) - sum(0, i-1);\n  }\n  void add(int k, T a) {\n    for (; k < x.size(); k |= k+1) x[k] = (x[k]+a)%p;\n  }\n};\n\nint main() {\n  ll a, b;\n  while(cin>>a>>b>>p,a||b||p) {\n    vector<psi> v;\n    for (ll i=a; i<=b; ++i) {\n      char tmp[30];\n      sprintf(tmp, \"%lld\", i);\n      v.push_back(psi(string(tmp), i-a));\n    }\n    sort(ALL(v));\n    int table[b-a+1];\n    REP(i, v.size()) {\n      table[v[i].second] = i;\n    }\n    int n = b-a+1;\n    // REP(i, b-a+1)\n    //   cout << table[i] << \" \";\n    // cout << endl;\n\n    fenwick_tree<ll> dp(n);\n    REP(i, n) {\n      //cout << dp.sum(0, table[i]) + 1 << \" \";\n      dp.add(table[i], dp.sum(0, table[i]) + 1);\n    }\n    //cout << endl;\n    cout << dp.sum(0, n-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint digit(ll n) {\n  int res = 0;\n  while(n) {\n    n /= 10;\n    res++;\n  }\n  return res;\n}\nvoid update(ll a, ll b, ll p, ll val, vector<ll> &v, vector<ll> &su) {\n  int d = digit(val);\n  int mad = digit(b);\n  ll l = val, r = 1;\n  for(int i=0;i<d;++i) {\n    r *= 10;\n  }\n  for(int i=d;i<=mad;++i) {\n    if(i == d) {\n      ll tmpl = min(b+3, l+1);\n      ll tmpr = min(b+3, r);\n      v[val-a] += su[tmpl-a] + p - su[tmpr-a];\n      v[val-a] %= p;\n    } else {\n      ll tmpl = min(b+3, l);\n      ll tmpr = min(b+3, r);\n      v[val-a] += su[tmpl-a] + p - su[tmpr-a];\n      v[val-a] %= p;\n    }\n    l *= 10;\n    r *= 10;\n  }\n  v[val-a]++;\n  su[val-a] = (su[val-a+1] + v[val-a]) % p;\n}\nbool solve() {\n  ll a, b, p; cin >> a >> b >> p;\n  if(a == 0) return false;\n  vector<ll> v(b-a+10);\n  vector<ll> su(b-a+10);\n  su[b-a] = 1;\n  for(ll val=b-1;val>=a;--val) {\n    update(a, b, p, val, v, su);\n  }\n  cout << su[0] % p << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    if(!solve()) break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline ll rten(ll x){\n  ll r = 1;\n  while (r * 10 <= x) r *= 10;\n  return r;\n}\n\nll sum[100100];\n\nint main()\n{\n  ll A, B, P;\n  while (cin >> A >> B >> P, A){\n    memset(sum, 0, sizeof(sum));\n    sum[1] = 1;\n    for (ll x = A + 1; x <= B; x++){\n      ll s = (sum[x - A] + P - sum[max(rten(x) - A, 0ll)] + 1) % P;\n      for (ll y = x / 10; y >= A; y /= 10){\n        s += sum[y - A + 1] - sum[max(rten(y) - A, 0ll)];\n        s %= P;\n      }\n      sum[x - A + 1] = sum[x - A] + s;\n      sum[x - A + 1] %= P;\n    }\n    cout << sum[B - A + 1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nstd::string ToString(int x) {\n\tstd::stringstream buffer;\n\tstd::string result;\n\tbuffer << x;\n\tbuffer >> result;\n\treturn result;\n}\n\nconst int N = 100000 + 10;\n\nstd::string to_string[N];\nint elements[N], a, b, MOD;\n\nbool compare(int x, int y) {\n\treturn to_string[x] < to_string[y];\n}\n\nint rank[N], order[N], value[N];\n\nint lowbit(int x) {\n\treturn x & -x;\n}\n\nvoid add(int x, int delta) {\n\tfor (; x < N; x += lowbit(x)) {\n\t\t(value[x] += delta) %= MOD;\n\t}\n}\n\nint get(int x) {\n\tint result = 0;\n\tfor (; x > 0; x -= lowbit(x)) {\n\t\t(result += value[x]) %= MOD;\n\t}\n\treturn result;\n}\n\nint main() {\n\twhile (scanf(\"%d%d%d\", &a, &b, &MOD) != EOF) {\n\t\tif (a == 0 && b == 0 && MOD == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t// printf(\"%d %d %d\\n\", a, b, MOD);\n\t\tint n = b - a + 1;\n\t\tfor (int i = a; i <= b; ++ i) {\n\t\t\telements[i - a + 1] = i;\n\t\t\tto_string[i - a + 1] = ToString(i);\n\t\t\torder[i - a + 1] = i - a + 1;\n\t\t}\n\t\tstd::sort(order + 1, order + n + 1, compare);\n\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\trank[order[i]] = i;\n\t\t}\n\t\t\n\t\tmemset(value, 0, sizeof(value));\n\t\tint answer = 0;\n\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\tint temp = get(rank[i]) + 1;\n\t\t\t(answer += temp) %= MOD;\n\t\t\tadd(rank[i], temp);\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nclass BinaryIndexedTree {\n\nprivate:\n\tvector<T> data;\n\npublic:\n\tBinaryIndexedTree(int N) : data(N + 1) { }\n\t// calculate sum of a[0, i)\n\tT sum(int i){\n\t\tT s = T();\n\t\tfor(; i > 0; i -= i & -i){ s += data[i]; }\n\t\treturn s;\n\t}\n\t// add x to a[i]\n\tvoid add(int i, const T &x){\n\t\tfor(++i; i < data.size(); i += i & -i){ data[i] += x; }\n\t}\n\n};\n\nstruct LexicalCompare {\n\tbool operator()(int a, int b) const {\n\t\tchar abuf[16] = { 0 }, bbuf[16] = { 0 };\n\t\tint alen = 0, blen = 0;\n\t\twhile(a > 0){ abuf[alen++] = '0' + (a % 10); a /= 10; }\n\t\twhile(b > 0){ bbuf[blen++] = '0' + (b % 10); b /= 10; }\n\t\treverse(abuf, abuf + alen);\n\t\treverse(bbuf, bbuf + blen);\n\t\tfor(int i = 0; i < 16; ++i){\n\t\t\tif(abuf[i] < bbuf[i]){ return true; }\n\t\t\tif(abuf[i] > bbuf[i]){ return false; }\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tll A, B, P;\n\t\tcin >> A >> B >> P;\n\t\tif(A == 0 && B == 0 && P == 0){ break; }\n\t\tvector<int> lexical_order(B - A + 1);\n\t\tfor(int i = A; i <= B; ++i){ lexical_order[i - A] = i; }\n\t\tsort(lexical_order.begin(), lexical_order.end(), LexicalCompare());\n\t\tint N = lexical_order.size();\n\t\tBinaryIndexedTree<ll> bit(N);\n\t\tvector<ll> dp(N);\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tdp[i] = (bit.sum(lexical_order[i] - A) + 1) % P;\n\t\t\tbit.add(lexical_order[i] - A, dp[i]);\n\t\t}\n\t\tll answer = accumulate(dp.begin(), dp.end(), 0ll) % P;\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a + b.num); }\nMod operator+(const Mod a, const long long int  b) { return b+a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a*b.num); }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tMod sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tMod lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tMod adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint l,r,p;\n\nstruct RSQ{\n  int n=(1<<18),data[(1<<19)];\n  RSQ(){memset(data,0,sizeof(data));}\n  void add(int i,int v){\n    i++;\n    while(i<=n){\n      data[i]+=v%p;\n      i+=i&-i;\n    }\n  }\n  int sum(int i){\n    int res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n      res%=p;\n    }\n    return res;\n  }\n};\n\nsigned main(){\n  while(cin>>l>>r>>p,l){\n    RSQ R;\n    vector<string>v;\n    for(int i=l;i<=r;i++){\n      stringstream s; s<<i;\n      v.push_back(s.str());\n    }\n    sort(v.begin(),v.end());\n    for(int i=0;i<v.size();i++){\n      int x=stoi(v[i]);\n      R.add(x-l,(R.sum(x-l)+1)%p);\n    }\n    cout<<R.sum(r-l+1)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint A, B, P, N;\nvector<string> vecS;\nvector<int> vec;\nint dp[100005];\n\nint bit[100005];\n\nvoid init(){\n\tfor(int i = 1; i <= N; i++) bit[i] = 0;\n}\n\nint query(int i)\n{\n\tint sum = 0;\n\twhile(i > 0){\n\t\tsum += bit[i];\n\t\tsum %= P;\n\t\ti -= i&(-i);\n\t}\n\treturn sum;\n}\n\nvoid add(int i, int val)\n{\n\twhile(i <= N){\n\t\tbit[i] += val;\n\t\tbit[i] %= P;\n\t\ti += i&(-i);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> A >> B >> P;\n\t\tif(A == 0 && B == 0 && P == 0) break;\n\t\t\n\t\tvecS.clear();\n\t\tfor(int i = A; i <= B; i++){\n\t\t\tvecS.push_back( to_string(i) );\n\t\t}\n\t\tsort(vecS.begin(), vecS.end());\n\t\t\n\t\tvec.clear();\n\t\tfor(int i = 0; i < vecS.size(); i++){\n\t\t\tvec.push_back( atoi(vecS[i].c_str()) );\n\t\t}\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tvec[i] -= (A-1);\n\t\t}\n\t\tN = B - A + 1;\n\t\t\n\t\tinit();\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tdp[i] = query(vec[i]) + 1;\n\t\t\tadd(vec[i], dp[i]);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tans += dp[i];\n\t\t\tans %= P;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nll mod;\nvi sum;\n\n// [l, r)\ninline ll calc(int l, int r){\n    return SUB(sum[l], sum[r], mod);\n}\n\nint main(void){\n    for(ll a, b; cin >> a >> b >> mod, a;){\n        ll n = b - a;\n        vi dp(n + 1);\n        sum = vi(n + 2);\n\n        dp[n] = sum[n] = 1;\n        rrep(i, n){\n            ll ca = a + i;\n            ll upper = 1;\n            while(upper <= ca) upper *= 10;\n\n            dp[i] = 1;\n\n            ll p = 1;\n            rep(loop, 10){\n                if(loop != 0) p *= 10;\n\n                if(ca % (p * 10) / p == 9 or ca / p == 0) continue;\n                ll na = (ca + p) / p * p;\n                ll nb = (ca + 10 * p) / (10 * p) * (10 * p);\n\n                if(na > b) continue;\n                na -= a; nb -= a;\n                chmin(nb, n + 1);\n\n                dp[i] = ADD(dp[i], calc(na, nb), mod);\n            }\n\n            p = 10;\n            rep(loop, 10){\n                ll na = ca * p;\n                ll nb = upper * p;\n\n                if(na > b) continue;\n                na -= a; nb -= a;\n                chmin(nb, n + 1);\n\n                dp[i] = ADD(dp[i], calc(na, nb), mod);\n\n                p *= 10;\n            }\n\n            sum[i] = ADD(sum[i + 1], dp[i], mod);\n        }\n\n        cout << sum[0] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nint bottom(int n){\n    int res = 1;\n    while(res * 10 <= n){\n        res *= 10;\n    }\n    return res;\n}\n\nint slow(int A, int B, int P){\n    map<int, int> dp;\n    map<int, int> sum[12];\n    int ans = 0;\n    for(int i = A; i <= B; i++){\n        dp[i] = 1;\n        dp[i] = (dp[i] + sum[ to_string(i).size() ][i - 1]) % P;\n        /*\n        for(int k = bottom(i); k < i; k++){\n            dp[i] = (dp[i] + dp[k]) % P;\n        }\n        */\n        for(int k = i / 10; k > 0; k /= 10){\n            dp[i] = (dp[i] + sum[to_string(k).size()][k]) % P;\n        }\n        sum[to_string(i).size()][i] = (sum[ to_string(i).size() ][i - 1] + dp[i]) % P;\n        ans = (ans + dp[i]) % P;\n    }\n    return ans;\n}\nint main(){\n    LL A, B, P;\n    while(cin >> A >> B >> P && A > 0){\n        cout << slow(A, B, P) << endl;\n        /*\n        const int N = B - A + 1;\n        // [A, border - 1], [border, border * 10 - 1], ... [border * 10^n, B] \n        LL border = 10;\n        while(border - 1 < A){\n            border *= 10;\n        }\n        if(border > B){\n            LL ans = 1;\n            REP(i, N) ans = ans * 2 % P;\n        }else if(B < 10 * A){\n            const int N1 = border - A;\n            const int N2 = B - border + 1;\n            LL ans1 = 1, ans2 = 1;\n            REP(i, N1) ans1 = ans1 * 2 % P;\n            REP(i, N2) ans2 = ans2 * 2 % P;\n            cout << (ans1 + ans2 + P - 2) % P << endl;\n        }else{\n        }\n        */\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\ntypedef long long ll;\n\nstring itos(int x){\n  string res;\n  while(x)res+=x%10+'0',x/=10;\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nll dp[N][11];\n\nint main(){\n\n  while(1){\n    \n    ll a,b,p;\n\n    cin>>a>>b>>p;\n\n    if(!a&&!b&&!p) break;\n    \n    vector<string> v;\n  \n    for(int i=a;i<=b;i++) v.push_back(itos(i));\n  \n    ll n=b-a+1;\n  \n    sort(v.begin(),v.end());\n  \n    v.push_back(\"\");\n  \n    memset(dp,0,sizeof(dp));\n  \n    for(int i=0;i<n;i++) dp[i][v[i].size()]=1;\n  \n    for(int i=0;i<n;i++){\n    \n      ll A=0;\n      for(int j=0;j<v[i].size();j++) A=(A+dp[i][j])%p;\n      dp[i][v[i].size()]=(dp[i][v[i].size()]+A)%p;\n    \n      for(int j=0;j<11;j++){\n      \n\tif(v[i+1].size()==j) dp[i+1][j]=(dp[i+1][j]+(dp[i][j]*2)%p)%p;\n\telse dp[i+1][j]=(dp[i+1][j]+dp[i][j])%p;\n      \n      }\n    \n    }\n  \n    ll ans=0;\n  \n    for(int i=0;i<11;i++){\n      cout<<dp[n][i]<<endl;\n      ans=(ans+dp[n][i])%p;\n    }\n  \n    cout<<ans<<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli inf = 1e9;\n\nlli solve(lli a, lli b, lli p){\n    vector<lli> dp(b-a+2, 0);\n    lli res = 0;\n    for(lli i=0; i<b-a+1; i++){\n        dp[i+1] = (dp[i+1]+dp[i])%p;\n        dp[i] = (dp[i]+1)%p;\n        res = (res+dp[i])%p;\n        lli low=1, up=10;\n        for(; low<=inf; low*=10, up*=10){\n            if(a+i >= up) continue;\n            if(a+i >= low){\n                dp[i+1] = (dp[i+1] +dp[i])%p;\n                if(up <= b) dp[up-a] = (dp[up-a] -dp[i] +p)%p;\n            }else{\n                lli lim = a+i;\n                while(lim < low) lim*=10;\n                if(lim <= b) dp[lim-a] = (dp[lim-a] +dp[i])%p;\n                if(up <= b) dp[up-a] = (dp[up-a] -dp[i] +p)%p;\n            }\n        }\n        \n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int a,b,p;\n        cin >> a >> b >> p;\n        if(a==0) break;\n        cout << solve(a,b,p) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nint a, b, p;\n\ntemplate<typename T>\nstruct FenwickTree {\n\tFenwickTree(size_t n = 0): n(n), val(n + 1){}\t\n\t\n\tvoid add(int k, T x){\n\t\t++k;\n\t\twhile (k <= n){\n\t\t\tval[k] = (val[k] + x) % p;\n\t\t\tk += k & -k;\n\t\t}\n\t}\n\n\tT sum(int k){\n\t\tT res = 0;\n\t\twhile (k > 0){\n\t\t\tres = (res + val[k]) % p;\n\t\t\tk -= k & -k;\n\t\t}\n\t\treturn res;\n\t}\n\nprivate:\n\tsize_t n;\n\tvector<T> val;\n};\n\nusing pr = pair<string, int>;\n\nint main()\n{\n\twhile (cin >> a >> b >> p, a){\n\t\tvector<pr> v;\n\t\tloop(i, a, b + 1){\n\t\t\tv.eb(to_string(i), i - a + 1);\n\t\t}\n\t\tsort(v);\n\t\tFenwickTree<int> t(b - a + 10);\n\t\tt.add(0, 1);\n\t\tint res = 0;\n\t\tfor (pr &a : v){\n\t\t\tres = (res + t.sum(a.se)) % p;\n\t\t\tt.add(a.se, t.sum(a.se));\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<set>\n#include<string>\n#include<sstream>\nusing namespace std;\ntypedef set<string>S;\nconst int SIZE=1<<17;\nint Bit[SIZE],P;\nint Sum(int i)\n{\n\tint s=0;\n\tfor(;i;i^=(i&-i))\n\t\ts=(s+Bit[i])%P;\n\treturn s;\n}\nvoid Add(int i, int v)\n{\n\tfor(;i<SIZE;i+=(i&-i))\n\t\tBit[i]=(Bit[i]+v)%P;\n}\nint main()\n{\n\tint A,B,i,r,x,v;\n\tstringstream ss;\n\twhile(scanf(\"%d%d%d\",&A,&B,&P),A)\n\t{\n\t\tS s;\n\t\tmemset(Bit,r=0,sizeof(Bit));\n\t\tfor(i=A;i<=B;++i)\n\t\t{\n\t\t\tss.str(\"\");\n\t\t\tss<<i;\n\t\t\ts.insert(ss.str());\n\t\t}\n\t\tfor(S::iterator ite=s.begin();ite!=s.end();++ite)\n\t\t{\n\t\t\tx=atoi(ite->c_str());\n\t\t\ti=x-A+1;\n\t\t\tv=Sum(i)+1;\n\t\t\tAdd(i,v);\n\t\t\tr=(r+v)%P;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD_add(i,j) i=(i+j)%P\n#define MOD_sub(i,j) i=(i-j+P)%P\n#define\tdp(i) DP[i-A]\n#define int long long\nusing namespace std;\nconst int N = 100005;\nint A, B, P, DP[N], ANS;\ninline int tenPow(int x) {\n\tint cnt = 0;\n\twhile (x > 0)\n\t\tx /= 10, cnt++;\n\treturn pow(10, cnt-1);\n}\ninline void updateDP(int x) {\n\tint newVal = dp(x), t = x;\n\twhile (t < B) {\n\t\tMOD_add(dp(t+(t==x)), newVal);\n\t\tt *= 10;\n\t\tMOD_sub(dp(min(tenPow(t), B)), newVal);\n\t}\n}\nsigned main() {\n\twhile (cin >> A >> B >> P, A | B | P) {\n\t\tmemset(DP, 0, sizeof(DP)), DP[0] = 1, ANS = 0, B++;\n\t\tfor (int i = A; i < B; i++) {\n\t\t\tif (i > A)\n\t\t\t\tMOD_add(dp(i),dp(i-1));\n\t\t\tupdateDP(i);\n\t\t\tMOD_add(ANS, dp(i));\n\t\t}\n\t\tcout << ANS << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define MAX 1100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nll A,B,MOD;\nll dp[MAX];\n\ninline\nint toIndex(ll a){ return a-A+1; }\n\nint main()\n{\n  while(cin >> A >> B >> MOD,A|B|MOD)\n    {\n      ll range = B-A+5;\n      rep(i,range)dp[i] = 0;\n      dp[1] = 1;//1-indexed\n      dp[toIndex(B+1)] = -1;\n\n      REP(cur,A,B+1)\n\t{\n\t  if(cur != A)dp[toIndex(cur)] = (dp[toIndex(cur)] + dp[toIndex(cur-1)]) % MOD;\n\t  ll sp = cur;\n\t  while(sp <= B)\n\t    {\n\t      int digit = (int)log10(sp) + 1;\n\t      ll p10 = 1;\n\t      rep(i,digit)p10 *= 10LL;\n\t      ll nsp = max(sp,cur+1LL);\n\t      //ll nsp = (sp == cur?cur+1LL:sp);\n\t      p10 = min(p10,B+1);\n\n\t      //cout << cur << \"-th :\"  << \" sp = \" << sp << \" nsp = \" << nsp << \" p10 = \" << p10 << endl; \n\t      dp[toIndex(nsp)]  = (dp[toIndex(nsp)]  + dp[toIndex(cur)]) % MOD;\n\t      dp[toIndex(p10)] = (dp[toIndex(p10)] - dp[toIndex(cur)]) % MOD;\n\t      sp = sp*10;\n\t    }\n\n\t}\n      ll ans = 0;\n      REP(i,A,B+1)\n\t{\n\t  ans = (dp[toIndex(i)] + ans) % MOD;\n\t  //cout << \"dp[\" << toIndex(i) << \"] = \" << dp[toIndex(i)] << \"\\n\";\n\t}\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <queue>\nusing namespace std;\n#define MP(x,y) make_pair(x,y)\n#define FI first\n#define SE second\n\nconst int MAXN = 110;\nint len=0,ans_s;\nchar str[MAXN],st[MAXN];\nlong long ans,pos;\n\nlong long trans_stoi(int l,int r)\n{\n\tlong long res=0;\n\tfor (int i=l;i<r;i++)\n\t\tres=res*10+str[i]-'0';\n\treturn res;\n}\n\nvoid trans_itos(long long x)\n{\n\tint num=0;\n\tint tmp[MAXN];\n\twhile (x)\n\t{\n\t\ttmp[num++]=x%10;\n\t\tx/=10;\n\t}\n\tfor (int i=0;i<num;i++)\n\t\tst[i]=tmp[num-i-1]+'0';\n\tst[num]='\\0';\n}\n\nlong long cal(long long ans)\n{\n\tint num=1;\n\tlong long mul=9,p=1,res=0;\n\twhile (ans>p*10)\n\t{\n\t\tres+=num*mul;\n\t\tnum++;\n\t\tmul*=10;\n\t\tp*=10;\n\t}\n\tres+=(ans-p)*num;\n\treturn res;\n}\n\nint main()\n{\n\tfreopen(\"/home/caesar11/0425/d.in\",\"r\",stdin);\n\tstr[0]=' ';\n\twhile (scanf(\"%s\",str+1)!=-1)\n\t{\n\t\tif (str[1]=='#') break;\n\t\tans=1LL<<60;\n\t\tlen=strlen(str)-1;\n//\n\t\tfor (int s=1;s<=len;s++)\n\t\t\tfor (int l=s;l<=20&&s+l-1<=len;l++)\n\t\t\t{\n\t\t\t\tlong long tmp=trans_stoi(s,s+l)+1;\n\t\t\t\tlong long tt=tmp-1;\n\t\t\t\ttrans_itos(tmp);\n\t\t\t\tint flag=1;\n\t\t\t\tint p=s+l,q=p+strlen(st)-1;\n\t\t\t\twhile (flag)\n\t\t\t\t{\n\t\t\t\t\tif (q>len) break;\n\t\t\t\t\tfor (int i=p,j=0;i<=q;i++,j++)\n\t\t\t\t\t\tif (str[i]!=st[j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (!flag) break;\n\t\t\t\t\ttmp++;\n\t\t\t\t\ttrans_itos(tmp);\n\t\t\t\t\tp=q+1,q=p+strlen(st)-1;\n\t\t\t\t}\n\t\t\t\tif (!flag) continue;\n\t\t\t\tfor (int i=p,j=0;i<=len;i++,j++)\n\t\t\t\t\tif (str[i]!=st[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (tt-1==0) \n\t\t\t\telse trans_itos(tt-1);\n\t\t\t\tfor (int i=s-1,j=strlen(st)-1;i>0;i--,j--)\n\t\t\t\t\tif (str[i]!=st[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tif (ans>tt)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s==1) ans=tt;\n\t\t\t\t\t\telse ans=tt-1;\n\t\t\t\t\t\tpos=s-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (len<=20)\n\t\t{\n\t\t\tfor (int i=1;i<=len;i++)\n\t\t\t{\n\t\t\t\tlong long tmp=0;\n\t\t\t\tfor (int j=1;j<=len;j++)\n\t\t\t\t{\n\t\t\t\t\tint t=i+j-1;\n\t\t\t\t\ttmp=tmp*10+str[t<=len?t:t-len]-'0';\n\t\t\t\t}\n\t\t\t\tif (ans>tmp)\n\t\t\t\t{\n\t\t\t\t\tans=tmp;\n\t\t\t\t\tpos=i-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%lld\\n\",ans);\n\t\tprintf(\"%lld\\n\",cal(ans+1)-ans_s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tMod sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tlong long int lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tMod adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll a,b,p;\n\nll solve() {\n\tll n=b-a+1;\n\tvector<ll> dp(n,1);\n\tunordered_map<ll,ll> preff;\n\tll sum=0;\n\tfor(ll i=n-1; i>=0; i--) {\n\t\tll tmp1=a+i;\n\t\tstring tmp2=to_string(tmp1);\n\t\tdp[i]+=sum;\n\t\tstring buf=\"\";\n\t\tREP(j,tmp2.size()) {\n\t\t\tfor(char c='0'; c<tmp2[j]; c++) {\n\t\t\t\tif(preff.count(stol(buf+c))) {\n\t\t\t\t\tdp[i]-=preff[stol(buf+c)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf+=tmp2[j];\n\t\t}\n\t\tdp[i]=(dp[i]%p+p)%p;\n\t\twhile(tmp1>0) {\n\t\t\tpreff[tmp1]+=dp[i];\n\t\t\tpreff[tmp1]%=p;\n\t\t\ttmp1/=10;\n\t\t}\n\t\tsum+=dp[i];\n\t\tsum%=p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>a>>b>>p;\n\t\tif(a==0&&b==0&&p==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint A, B, P, sum[100002];\n\nvoid add(int k, int x)\n{\n  for(++k; k < 100002; k += k & -k) (sum[k] += x) %= P;\n}\nint query(int k)\n{\n  int ret = 0;\n  for(++k; k > 0; k -= k & -k) (ret += sum[k]) %= P;\n  return(ret);\n}\n\nint main()\n{\n  while(cin >> A >> B >> P, A) {\n    vector< string > d;\n    for(int i = A; i <= B; i++) {\n      stringstream sss; sss << i;\n      d.push_back(sss.str());\n    }\n    sort(d.begin(), d.end());\n    for(int i = 0; i < d.size(); i++) {\n      int val = stoi(d[i]);\n      add(val - A, (query(val - A) + 1) % P);\n    }\n    cout << query(B - A) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<17;\n\nll mod;\nclass BIT2{\npublic:\n  int n;\n  ll bit0[MAX_N+1],bit1[MAX_N+1];//1????????????\n\n  BIT2(){n = MAX_N;memset(bit0,0,sizeof(bit0));memset(bit1,0,sizeof(bit1));}\n  BIT2(int n){this->n=n;memset(bit0,0,sizeof(bit0));memset(bit1,0,sizeof(bit1));}\n  \n  ll sum(ll *b,int i){\n    ll s=0;\n    while(i>0){\n      s=(s+b[i])%mod;\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(ll *b,int i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v)%mod;\n      i+=i&-i;\n    }\n  }\n\n  //[a,b]???x?????????(1<=a)\n  void add (int a,int b,ll x){\n    add(bit0,a,-x*(a-1));\n    add(bit1,a,x);\n    add(bit0,b+1,x*b);\n    add(bit1,b+1,-x);\n  }\n\n  //[a,b]???sum?????????(1<=a)\n  ll sum(int a,int b){\n    ll res=0;\n    res+=sum(bit0,b)+sum(bit1,b)*b;\n    res-=sum(bit0,a-1)+sum(bit1,a-1)*(a-1);\n    return (res+mod)%mod;    \n  }\n};\n\nstring i2S(ll num){\n  string res;\n  if(num==0)return \"0\";\n  while(num) res+=(char)(num%10+'0'),num/=10;\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint main(){\n  while(1){\n    ll A,B;\n    cin>>A>>B>>mod;\n    if(!A&&!B&&!mod)return 0;\n    vector<string> num;\n    for(ll i=A;i<=B;i++)num.push_back(i2S(i));\n    sort(num.begin(),num.end());\n  \n    ll ans = 0, n = B-A+2;\n    BIT2 T(n);\n    T.add(1,n,1);\n    \n    for(ll i=A;i<=B;i++){\n      int idx = lower_bound(num.begin(),num.end(),i2S(i))-num.begin()+1;\n      ll val = T.sum(idx,idx);\n      ans=(ans+val)%mod;\n      T.add(idx,n,val);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_BIT\n#define ___Class_BIT\n\n// ------ Includes ------ //\n#include <vector>\n#pragma warning(disable : 4146)\n\n// ------ Class ------ //\ntemplate <typename Type>\nclass BIT {\nprivate:\n\tunsigned size_; std::vector<Type> v;\n\tType sum(unsigned r) {\n\t\tType ret = 0;\n\t\twhile (r > 0) {\n\t\t\tret += v[r];\n\t\t\tr -= r & (-r);\n\t\t}\n\t\treturn ret;\n\t}\npublic:\n\tBIT() {};\n\tBIT(unsigned size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(unsigned i, Type x) {\n\t\ti++;\n\t\twhile (i <= size_) {\n\t\t\tv[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tinline Type sum(unsigned l, unsigned r) {\n\t\treturn sum(r) - sum(l);\n\t}\n\tbool operator[](unsigned x) {\n\t\treturn sum(x, x + 1);\n\t}\n};\n\n#endif\n\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint A, B, M;\nint main() {\n\twhile (cin >> A >> B >> M, A) {\n\t\tvector<string> v(B - A + 1);\n\t\tfor (int i = A; i <= B; i++) v[i - A] = to_string(i);\n\t\tsort(v.begin(), v.end());\n\t\tmap<int, int> pos;\n\t\tfor (int i = 0; i < v.size(); i++) pos[stoi(v[i])] = i;\n\t\tBIT<long long> Q(B - A + 1);\n\t\tfor (int i = A; i <= B; i++) Q.add(pos[i], (Q.sum(0, pos[i]) + 1) % M);\n\t\tcout << Q.sum(0, B - A + 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n\nlong long P;\nint bit[100010];\n\nvoid add(int x,long long v){\n\tx++;\n\tfor(int i = x ; i < 100010 ; i += i&-i){\n\t\tbit[i] += v;\n\t\tbit[i] %= P;\n\t}\n}\nint get(int x){\n\tx++;\n\tlong long ans = 0;\n\tfor(int i = x ; i > 0 ; i -= i&-i){\n\t\tans += bit[i];\n\t\tans %= P;\n\t}\n\treturn ans;\n}\nlong long pow2[100010]={};\n\nint solve(int A,int B,long long P){\n\tint ok = 0;\n\tfor(int i = 1 ; i < (1<<(B-A+1)) ; i++){\n\t\tif( i != 1 ) continue;\n\t\tvector<int> ans;\n\t\tvector<string> ans2;\n\t\tfor(int j = A ; j <= B ; j++){\n\t\t\tif( i >> (j-A) & 1 ){\n\t\t\t\tans.push_back(j);\n\t\t\t\tstringstream ss;\n\t\t\t\tss << j;\n\t\t\t\tans2.push_back(ss.str());\n\t\t\t}\n\t\t}\n\t\tint f = 1;\n\t\tsort(ans.begin(),ans.end());\n\t\tsort(ans2.begin(),ans2.end());\t\t\t\n\t\tfor(int j = 0 ; j < ans.size() ; j++){\n\t\t\tstringstream ss(ans2[j]);\n\t\t\tint c;\n\t\t\tss >> c;\n\t\t\tif( c != ans[j] ) f = 0;\n\t\t}\n\t\tif( f ) ok++;\n\t}\n\treturn ok % P;\n}\nint solver2(long long A,long long B,long long P){\n\tfor(int i = 0 ; i < 100010 ; i++)\n\t\tbit[i] = 0;\n\tpow2[0] = 1 % P;\n\tfor(int i = 1 ; i < 100010 ; i++)\n\t\tpow2[i] = (pow2[i-1]*2ll)%P;\n\t\n\tvector<string> v;\n\tfor(long long i = A ; i <= B ; i++){\n\t\tstringstream ss;\n\t\tss << i;\n\t\tv.push_back(ss.str());\n\t}\n\tsort(v.begin(),v.end());\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < v.size() ; i++){\n\t\tstringstream ss(v[i]);\n\t\tlong long k;\n\t\tss >> k;\n\t\tlong long w = k - A;\n\t\tadd(w,get(w)+1);\n\t}\n\treturn get(100005);\n}\n\nint main(){\n\tlong long A,B;\n\n\twhile(cin >> A >> B >> P && A){\n\t\tcout << solver2(A,B,P)%P << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\ntypedef long long ll;\n\nstring itos(int x){\n  string res;\n  while(x)res+=x%10+'0',x/=10;\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nll dp[N][11];\n\nint main(){\n\n  while(1){\n    \n    ll a,b,p;\n\n    cin>>a>>b>>p;\n\n    if(!a&&!b&&!p) break;\n    \n    vector<string> v;\n  \n    for(int i=a;i<=b;i++) v.push_back(itos(i));\n  \n    ll n=b-a+1;\n  \n    sort(v.begin(),v.end());\n  \n    v.push_back(\"\");\n  \n    memset(dp,0,sizeof(dp));\n  \n    for(int i=0;i<n;i++) dp[i][v[i].size()]=1;\n  \n    for(int i=0;i<n;i++){\n    \n      ll A=0;\n      for(int j=0;j<v[i].size();j++) A=(A+dp[i][j])%p;\n      dp[i][v[i].size()]=(dp[i][v[i].size()]+A)%p;\n    \n      for(int j=0;j<11;j++){\n      \n\tif(v[i+1].size()==j) dp[i+1][j]=(dp[i+1][j]+(dp[i][j]*2)%p)%p;\n\telse dp[i+1][j]=(dp[i+1][j]+dp[i][j])%p;\n      \n      }\n    \n    }\n  \n    ll ans=0;\n  \n    for(int i=0;i<11;i++) ans=(ans+dp[n][i])%p;\n  \n    cout<<ans<<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<17;\n\nll mod;\nclass BIT2{\npublic:\n  int n;\n  ll bit0[MAX_N+1],bit1[MAX_N+1];//1????????????\n\n  BIT2(){n = MAX_N;memset(bit0,0,sizeof(bit0));memset(bit1,0,sizeof(bit1));}\n  BIT2(int n){this->n=n;memset(bit0,0,sizeof(bit0));memset(bit1,0,sizeof(bit1));}\n  \n  ll sum(ll *b,int i){\n    ll s=0;\n    while(i>0){\n      s=(s+b[i])%mod;\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(ll *b,int i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v)%mod;\n      i+=i&-i;\n    }\n  }\n\n  //[a,b]???x?????????(1<=a)\n  void add (int a,int b,ll x){\n    add(bit0,a,-x*(a-1));\n    add(bit1,a,x);\n    add(bit0,b+1,x*b);\n    add(bit1,b+1,-x);\n  }\n\n  //[a,b]???sum?????????(1<=a)\n  ll sum(int a,int b){\n    ll res=0;\n    res+=sum(bit0,b)+sum(bit1,b)*b;\n    res-=sum(bit0,a-1)+sum(bit1,a-1)*(a-1);\n    return (res+mod)%mod;    \n  }\n};\n\nstring i2S(ll num){\n  string res;\n  if(num==0)return \"0\";\n  while(num) res=(char)(num%10+'0')+res,num/=10;\n  return res;\n}\n\nint main(){\n  while(1){\n    ll A,B;\n    cin>>A>>B>>mod;\n    if(!A&&!B&&!mod)return 0;\n    vector<string> num;\n    for(ll i=A;i<=B;i++)num.push_back(i2S(i));\n    sort(num.begin(),num.end());\n  \n    ll ans = 0, n = B-A+2;\n    BIT2 T(n);\n    T.add(1,n,1);\n    \n    for(ll i=A;i<=B;i++){\n      int idx = lower_bound(num.begin(),num.end(),i2S(i))-num.begin()+1;\n      ll val = T.sum(idx,idx);\n      ans=(ans+val)%mod;\n      T.add(idx,n,val);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\n\nll p;\n\nstruct FenwickTree{\n  int n;\n  vl bit;\n  FenwickTree(int x = 0):n(x){bit = vl(x+1,0);}\n\n  inline void add(int i, ll x){\n    i++;\n    while(i <= n){\n      (bit[i] += x) %= p;\n      i += i & -i;\n    }\n  }\n\n  inline ll sum(int i){\n    i++;\n    ll res = 0;\n    while(i > 0){\n      (res += bit[i]) %= p;\n      i -= i & -i;\n    }\n    return res;\n  }\n\n  inline ll partial_sum(int l, int r){\n    return (sum(r-1) - sum(l-1) + p) % p;\n  }\n};\n\ninline string LLtoS(ll a){\n  stringstream ss;\n  ss << a;\n  return ss.str();\n}\n\ninline ll StoLL(string s){\n  stringstream ss(s);\n  ll res; ss >> res;\n  return res;\n}\n\nint main(){\n  ll a,b;\n  while(cin >> a >> b >> p, a){\n    FenwickTree bit(b-a+2);\n    for(ll x=a;x<=b;x++){\n      string s = LLtoS(x);\n      ll l=1, sum = 1, r = 0;\n      for(int i=0;i<(int)s.size();i++){\n\tr = r*10 + (ll)(s[i]-'0');\n\tif(a<=r){\n\t  (sum += bit.partial_sum(max(l,a)-a,min(r,b)-a+1)) %= p;\n\t}\n\tl*=10;\n      }\n      bit.add(x-a,sum);\n    }\n    cout << bit.partial_sum(0,b-a+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAX = 100100;\nll dp[MAX];\nll sum[MAX];\nll ten[15];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\tten[0] = 1;\n\tfor (int i = 1; i < 15; i++)\n\t\tten[i] = ten[i - 1] * 10;\n\tint A, B, P;\n\twhile (cin >> A >> B >> P) {\n\t\tif (A == 0 && B == 0 && P == 0) break;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = B; i >= A; i--) {\n\t\t\tdp[i - A] = 1;\n\t\t\tfor (int j = 1; j < 6; j++) {\n\t\t\t\tll mini = i*ten[j];\n\t\t\t\tif (mini > B) continue;\n\t\t\t\tll maxi = 0;\n\t\t\t\twhile (mini >= ten[maxi])\n\t\t\t\t\tmaxi++;\n\t\t\t\tmaxi = ten[maxi];\n\t\t\t\tmaxi = min<ll>(maxi, B + 1);\n\t\t\t\tdp[i - A] += sum[mini-A] - sum[maxi-A];\n\t\t\t}\n\t\t\tfor (int k = 9; k >= 0; k--) {\n\t\t\t\tif (i < ten[k] || (i / ten[k]) % 10 == 9) continue;\n\t\t\t\tll mini = (i / ten[k] + 1) * ten[k];\n\t\t\t\tll maxi = (i / ten[k + 1] + 1)*ten[k + 1];\n\t\t\t\tif (mini > B) continue;\n\t\t\t\tif (maxi > B) maxi = B + 1;\n\t\t\t\t//cout << i << \" \" << k << \" \" << mini << \" \" << maxi << endl;\n\t\t\t\tdp[i - A] += sum[mini-A] - sum[maxi-A];\n\t\t\t}\n\t\t\tdp[i - A] = (dp[i - A] % P + P) % P;\n\t\t\tsum[i - A] = (sum[i - A + 1] + dp[i-A]) % P;\n\t\t\t//cout << i << \" \" << dp[i - A] << endl;\n\t\t}\n\t\tcout << sum[0] << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <iostream>\nusing namespace std;\nusing ll = long long int;\n\nconst int MAXB = 100010;\nll A, B, P, dp[MAXB + 10], base[15];\n\nll add_dp(ll ub, ll digit, ll isOp) {\n  // [lb, ub]\n  if(isOp) ub--;\n  ll lb = base[digit];\n\n  if(lb > ub) return 0;\n  if(B < lb or ub < A) return 0;\n  ll mi = max(A, lb), ma = min(B, ub);\n  ll idxMi = mi - A + 1, idxMa = ma - A + 1;\n\n  // fprintf(stderr, \"lb = %lld, ub = %lld, digit = %lld, mi = %lld, ma = %lld\\n\", lb, ub, digit, mi, ma);\n  return (dp[idxMa] - dp[idxMi - 1] + P) % P;\n}\n\nll solve() {\n  fill(dp, dp + MAXB, 0);\n\n  ll width = B - A + 1;\n  for(int i=0; i<width; i++) {\n    dp[i+1] = 1;\n    ll num = A + i;\n    string s = to_string(num);\n    ll ub = 0;\n\n    for(size_t k=0; k<s.length(); k++) {\n      ub = ub * 10 + (s[k] - '0');\n      (dp[i+1] += add_dp(ub, k+1, k+1 == s.length())) %= P;\n    }\n\n    (dp[i+1] += dp[i]) %= P;\n  }\n  return dp[width];\n}\n\nint main() {\n  base[1] = 1;\n  for(int i=2; i<15; i++) {\n    base[i] = base[i-1] * 10;\n  }\n  \n  while(cin >> A >> B >> P, A) {\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<string,int> P;\n\nll A, B, MOD;\nll n;\nll bit[1000000];\n\nll sum(int i){\n  ll res = 0;\n  while(i > 0){\n    res += bit[i];\n    res %= MOD;\n    i -= i & -i;\n  }\n  return res;\n}\n\nvoid add(int i, int x){\n  while(i <= n){\n    bit[i] += x;\n    bit[i] %= MOD;\n    i += i & -i;\n  }\n}\n\nstring itos(ll x){\n  stringstream ss;\n  ss << x;\n  return ss.str();\n}\n\nint main(){\n  while(cin >> A >> B >> MOD, A || B || MOD){\n    vector<P> v;\n    for(ll i = A; i <= B; i++){\n      v.push_back(P(itos(i), i - A + 1));\n    }\n    sort(v.begin(), v.end());\n\n    n = B - A + 1;\n    memset(bit, 0, sizeof(bit));\n\n    for(int i = 0; i < v.size(); i++){\n      ll tmp = sum(v[i].second);\n      add(v[i].second, tmp + 1);\n    }\n\n    cout << sum(n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main()\n{\n    while (true) {\n        ll A, B, P;\n        cin >> A >> B >> P;\n        if (A == 0 and B == 0 and P == 0) { break; }\n        const ll NUM = B - A + 1;\n        auto dig = [](const ll n) {\n            int ans = -1;\n            for (ll num = 1; num <= n; ans++, num *= 10) {}\n            return ans;\n        };\n        const int MAXD = dig(B);\n        auto lower = [](const ll n, const int dig) {\n            ll ans = n;\n            for (int i = 0; i < dig; i++) { ans *= 10; }\n            return dig == 0 ? ans + 1 : ans;\n        };\n        auto upper = [&](const int dig) {\n            ll ans = 1;\n            for (int i = 0; i <= dig; i++) { ans *= 10; }\n            return min(ans, B + 1);\n        };\n        vector<ll> dp(NUM, 0);\n        vector<ll> accum(NUM, 0);\n        auto accumulate = [&](const int l, const int r) { return (l >= r or r > NUM) ? 0LL : (accum[l] + P - (r == NUM ? 0 : accum[r])) % P; };\n        for (int i = NUM - 1; i >= 0; i--) {\n            const ll num = i + A;\n            const int d = dig(num);\n            ll sum = 1;\n            for (int t = d; t <= MAXD; t++) {\n                const ll u = upper(t) - A, l = lower(num, t - d) - A;\n                (sum += accumulate(l, u)) %= P;\n            }\n            dp[i] = sum, accum[i] = ((i == NUM - 1 ? 0 : accum[i + 1]) + sum) % P;\n        }\n        cout << accum[0] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate <class T>\nclass BIT\n{\nprivate :\n    vector<T> bit;\n    int n;\npublic :\n    T sum(int, T);\n    void add (int, T, T);\n\n    BIT (int i) {\n        n = i;\n        bit.resize(i + 1);\n    }\n};\n\ntemplate <typename T>\nT BIT<T>::sum (int i, T K) {\n    T s = (T)(0);\n    while (i) {\n        s += bit[i];\n        s %= K;\n        i -= i & -i;\n    }\n\n    return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add (int i, T x, T K) {\n    while (i <= n) {\n        bit[i] += x;\n        bit[i] %= K;\n        i += i & -i;\n    }\n}\n\nint main() {\n    ll A, B, P;\n    while (cin >> A >> B >> P, A || B || P) {\n        vector<string> vs;\n        for (int i = A; i <= B; i++) {\n            stringstream ss;\n            ss << i;\n            string s;\n            ss >> s;\n            vs.push_back(s);\n        }\n\n        sort(vs.begin(), vs.end());\n\n        BIT<ll> b(B - A + 1);\n        for (int i = 0; i < vs.size(); i++) {\n            stringstream ss;\n            ss << vs[i];\n            ll v;\n            ss >> v;\n            ll sum = b.sum((int)(v-A), P);\n            b.add((int)(v-A+1LL), sum + 1LL, P);\n        }\n\n        cout << b.sum(B - A + 2LL, P) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint bit[100100];\nint N, P;\n\nvoid add(int k, int x)\n{\n    for (; k <= N + 1; k += k & -k){\n        bit[k] = (bit[k] + x) % P;\n    }\n}\n\nint sum(int k)\n{\n    int ret = 0;\n    for (; k; k &= (k - 1)){\n        ret = (ret + bit[k]) % P;\n    }\n    return (ret);\n}\n\nbool radix(int a, int b)\n{\n    return (to_string(a) < to_string(b));\n}\n\nint main()\n{\n    int A, B;\n\n    while (scanf(\"%d %d %d\", &A, &B, &P) && A){\n       memset(bit, 0, sizeof(bit));\n       N = B - A + 1;\n       add(N + 1, 1);\n\n       vector<int> v(N);\n       for (int i = 0; i < N; i++){\n           v[i] = A + i;\n        }\n\n       sort(v.begin(), v.end(), radix);\n\n       for (int i = N - 1; i >= 0; i--){\n           int nv = (sum(N + 1) - sum(v[i] - A) + P) % P;\n           add(v[i] - A + 1, nv);\n       }\n\n       printf(\"%d\\n\", sum(N));\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a + b.num); }\nMod operator+(const Mod a, const long long int  b) { return b+a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a*b.num); }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<17) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tlong long int sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tlong long int lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tseg[k].sum %= mod;\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n\tseg[k].sum %= mod;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tint adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint mod;\nint add(int a,int b){return (a+b)%mod;}\n\nint A,B;\nint t[1000005][11],size;\nint u[100005];\nint v[100005],vs;\n\nvoid Add(int i,int x){\n  while(i<100005){\n    u[i]=add(u[i],x);\n    i+=(i&-i);\n  }\n}\n\nint Sum(int i){\n  int res=0;\n  while(i){\n    res=add(res,u[i]);\n    i-=(i&-i);\n  }\n  return res;\n}\n\nvoid dfs(int pos,int depth=0){\n  if(t[pos][10]>0)v[vs++]=t[pos][10];\n  for(int i=0;i<10;i++)\n    if(t[pos][i]!=-1)\n      dfs(t[pos][i],depth+1);\n}\n\nvoid func(int key){\n  int a=key;\n  vector<int> vec;\n  while(a>0){\n    vec.push_back(a%10);\n    a/=10;\n  }\n  reverse(vec.begin(),vec.end());\n  int pos=0,depth=0;\n  while(depth<(int)vec.size()){    \n    if(t[pos][vec[depth]]==-1)t[pos][vec[depth]]=size++;    \n    pos=t[pos][vec[depth++]];\n  }\n  t[pos][10]=key;\n}\n\nvoid init(){\n  size=1;\n  vs=1;\n  memset(u, 0,sizeof(u));\n  memset(t,-1,sizeof(t));\n}\n\nint main(){\n  while(1){\n    cin>>A>>B>>mod;\n    if(A==0&&B==0&&mod==0)break;\n    init();\n    for(int i=A;i<=B;i++)func(i);\n    dfs(0);\n    for(int i=1;i<vs;i++){\n      int num=v[i]-A+1;      \n      int sum=add(Sum(num),1);\n      Add(num,sum);\n    }\n    cout<< Sum(100002) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct SegTree{\n    int n; vector<ll> dat;\n    ll mod;\n    //初期化\n    SegTree(int _n, ll _mod){\n        n=1;\n        while(n<_n) n*=2;\n        dat=vector<ll>(2*n-1,0);\n\n        mod = _mod;\n    }\n    //k番目(0-indexed)の値をaに変更\n    void update(int k, ll a){\n        k+=n-1;\n        dat[k]=a;\n        //更新\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=(dat[2*k+1]+dat[2*k+2])%mod;\n        }\n    }\n    //内部的に投げられるクエリ\n    ll _query(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l) return 0;\n\n        if(a<=l && r<=b) return dat[k];\n\n        ll vl=_query(a,b,2*k+1,l,(l+r)/2);\n        ll vr=_query(a,b,2*k+2,(l+r)/2,r);\n        return (vl+vr)%mod;\n    }\n    //[a,b)\n    ll query(int a, int b){\n        return _query(a,b,0,0,n);\n    }\n};\n\nusing P = pair<string, int>;\n\nint main(){\n    int a,b,p;\n    while(cin >>a >>b >>p,a){\n        int n = b-a+1;\n        SegTree st(n+1,p);\n\n        vector<P> v;\n        for(int i=1; i<=b-a+1; ++i){\n            int val = a+i-1;\n            v.pb({to_string(val), i});\n        }\n        sort(all(v));\n\n        st.update(0,1);\n        rep(i,v.size()){\n            int idx = v[i].se;\n            st.update(idx, st.query(0,idx));\n        }\n\n        cout << st.query(1,n+1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass BIT {\nprivate:\n\tint size;\n\tvector<long long> bit;\n\tint mod;\n\npublic:\n\tBIT(int n, int m):size(n), bit(n + 1, 0), mod(m) {}\n\n\tvoid add(int i, int x) {\n\t\twhile(i <= size) {\n\t\t\tbit[i] += x;\n\t\t\tbit[i] %= mod;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\n\tlong long sum(int i) const {\n\t\tlong long s = 0;\n\t\twhile(i > 0) {\n\t\t\ts += bit[i];\n\t\t\ts %= mod;\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int a, b, p; cin >> a >> b >> p && a;) {\n\t\tconst int num = b - a + 2;\n\n\t\tvector<string> order;\n\t\torder.reserve(num);\n\n\t\tfor(int i = a; i <= b; ++i) {\n\t\t\torder.emplace_back(to_string(i));\n\t\t}\n\n\t\tsort(order.begin(), order.end());\n\n\t\tBIT bit(num, p);\n\t\tbit.add(1, 1);\n\n\t\tfor(const auto &s : order) {\n\t\t\tconst int index = stoi(s) - a + 2;\n\t\t\tconst auto tmp = bit.sum(index - 1);\n\t\t\tbit.add(index, tmp);\n\t\t}\n\n\t\tcout << bit.sum(num) - 1 << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint bit[100100];\nint N, P;\n\nvoid add(int k, int x)\n{\n    for (; k <= N + 1; k += k & -k){\n        bit[k] = (bit[k] + x) % P;\n    }\n}\n\nint sum(int k)\n{\n    int ret = 0;\n    for (; k; k &= (k - 1)){\n        ret = (ret + bit[k]) % P;\n    }\n    return (ret);\n}\n\nbool radix(int a, int b)\n{\n    return (to_string(a) < to_string(b));\n}\n\nint main()\n{\n    int A, B;\n\n    while (scanf(\"%d %d %d\", &A, &B, &P) && A){\n       memset(bit, 0, sizeof(bit));\n       N = B - A + 1;\n       add(N + 1, 1);\n\n       vector<int> v(N);\n       for (int i = 0; i < N; i++){\n           v[i] = A + i;\n        }\n\n       sort(v.begin(), v.end(), radix);\n\n       for (int i = N - 1; i >= 0; i--){\n           int nv = (sum(N + 1) - sum(v[i] - A) + P) % P;\n           add(v[i] - A + 1, nv);\n       }\n\n       printf(\"%d\\n\", sum(N));\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>\nclass Fenwick{\npublic:\n  vector<T> data;\n  int n;\n  Fenwick(){};\n  Fenwick(int tn){\n    data.resize(tn,0);\n    n = tn;\n  }\n  T read(int idx,int tidx,ll mod){\n    T sum = 0;\n    if (idx == 0){\n      while(tidx > 0){\n\tsum=(sum+data[tidx])%mod;\n\ttidx-=(tidx&-tidx);\n      }\n      return sum;\n    }else return (read(0,tidx,mod)-read(0,idx-1,mod)+mod)%mod;\n  }\n  void update(int idx,T val,ll mod){\n    while(idx <= n){\n      data[idx]=(data[idx]+val)%mod;\n      idx+=(idx & -idx);\n    }\n  }\n};\n\nmain(){\n  ll a,b,p;\n  while(cin>>a>>b>>p && p){\n    Fenwick<ll> dp(b-a+2);\n    vector<int> num(b-a+1);\n    vector<string> all;\n    for(ll i=a;i<=b;i++){\n      string tmp=\"\";\n      ll now = i;\n      while(now)tmp=tmp+string(1,'0'+now%10),now/=10;\n      reverse(tmp.begin(),tmp.end());\n      all.push_back(tmp);\n    }\n\n    sort(all.begin(),all.end());\n    for(int i=0;i<all.size();i++){\n      ll tmp = 0;\n      for(int j=0;j < all[i].size();j++){\n\ttmp=tmp*10+all[i][j]-'0';\n      }\n      num[tmp-a]=i+1;\n    }\n    for(ll i=a;i <= b;i++){\n      int now = num[i-a];\n      ll tmp = (dp.read(0,now-1,p)+1)%p;//+1 is itself\n      dp.update(now,tmp,p);\n    }\n    cout << dp.read(0,b-a+1,p) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    \n    while(1){\n        \n        long long a, b, p; cin >> a >> b >> p;\n        if(!a) break;\n        //count [a, b]\n        long long n = b - a + 1;\n        vector<vector<long long> > dp(n + 1, vector<long long> (n, 0));\n        dp[0][0] = 1LL;\n\n        for(long long i = 0; i < n; i++){\n            for(long long j = 0; j <= n; j++){\n                \n                //cout << i << endl;\n                //入れない\n                dp[i + 1][j] += dp[i][j];\n                dp[i + 1][j] %= p;\n                //cout << \"dp[\" << i + 1 << \"][\" << j << \"] = \" << dp[i + 1][j] << endl;\n                \n\n                //辞書順が保たれるなら、入れる\n                long long num_i = i + a;\n                long long num_j = j + a - 1;\n                string str_i = to_string(num_i);\n                string str_j = to_string(num_j);\n\n                if(str_i > str_j){\n                    dp[i + 1][i + 1] += dp[i][j];\n                    dp[i + 1][i + 1] %= p;\n                    //cout << \"dp[\" << i + 1 << \"][\" << i << \"] = \" << dp[i + 1][i] << endl;\n                }\n            }\n        }\n\n        long long ans = 0LL;\n        for(int i = 0; i <= n; i++){\n            ans += dp[n][i];\n            ans %= p;\n        }\n\n        cout << ans -  1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tMod sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tMod lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tMod adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint MOD;\n\nclass Bit\n{\n    int n;\n    vector<int> data;\npublic:\n    Bit(int n){ // コンストラクタ\n        this->n = n;\n        data.assign(n+1, 0);\n    }\n    void add(int k, int x){ // k番目の要素にxを加算する\n        ++ k;\n        while(k <= n){\n            data[k] += x;\n            data[k] %= MOD;\n            k += k & -k;\n        }\n    }\n    int sum(int k){ // 区間[0,k]の総和を返す\n        ++ k;\n        int ret = 0;\n        while(k > 0){\n            ret += data[k];\n            ret %= MOD;\n            k -= k & -k;\n        }\n        return ret;\n    }\n    int sum(int a, int b){ // 区間[a,b]の総和を返す\n        int ret = sum(b) - sum(a-1);\n        ret = (ret % MOD + MOD) % MOD;\n        return ret;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int a, b;\n        cin >> a >> b >> MOD;\n        if(a == 0)\n            return 0;\n\n        vector<string> s(b-a+1);\n        for(int i=0; i<b-a+1; ++i){\n            ostringstream oss;\n            oss << (a + i);\n            s[i] = oss.str();\n        }\n        sort(s.begin(), s.end());\n\n        Bit x(b-a+1);\n        for(int i=0; i<b-a+1; ++i){\n            istringstream iss(s[i]);\n            int k;\n            iss >> k;\n            x.add(k-a, x.sum(k-a-1) + 1);\n        }\n\n        cout << x.sum(0, b-a) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nll P;\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\nint main()\n{\n\tll A, B;\n\twhile (cin >> A >> B >> P, A | B | P) {\n\t\tvector<string> se(B - A + 1);\n\t\tfor (ll i = A; i <= B; i++) {\n\t\t\tll tmp = i;\n\t\t\twhile (tmp) {\n\t\t\t\tse[i - A].push_back('0' + (tmp % 10ll));\n\t\t\t\ttmp /= 10ll;\n\t\t\t}\n\t\t\treverse(se[i - A].begin(), se[i - A].end());\n\t\t}\n\t\tsort(se.begin(), se.end());\n\t\tvector<ll> S(B - A + 1);\n\t\tfor (ll i = 0; i <= B - A; i++) {\n\t\t\tS[i] = stoll(se[i]);\n\t\t}\n\t\tvector<ll> dp(B - A + 1);\n\t\tSegmentTree<ll> st(B - A + 1, 0, [](ll l, ll r) { return (l + r) % P; });\n\t\tfor (ll i = 0; i <= B - A; i++) {\n\t\t\tdp[i] = (st.Find(0, S[i] - A) + 1) % P;\n\t\t\tst.Update(S[i] - A, dp[i]);\n\t\t}\n\t\tll res = 0;\n\t\tfor (ll i = 0; i <= B - A; i++) {\n\t\t\tres = (res + dp[i]) % P;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T> class BinaryIndexedTree {\n  vector<T> vec;\n  const ll n, mod;\n\npublic:\n  BinaryIndexedTree(T _n, ll mod) : vec(_n + 1), n(_n), mod(mod) {}\n\n  T query(ll x) {\n    T ret = 0;\n    for(ll i = x; i > 0; i -= i & (-i)) (ret += vec[i]) %= mod;\n    return ret;\n  }\n\n  void update(ll x, T k) {\n    for(ll i = x; i <= n; i += i & (-i)) (vec[i] += k) %= mod;\n  }\n};\n\nint main(void) {\n  ll A, B, P;\n  while(cin >> A >> B >> P, B++, A && B && P) {\n    vector<pair<string, ll>> s(B - A);\n    REP(i, 0, B - A) s[i] = pair<string, ll>(to_string(i + A), i);\n    sort(s.begin(), s.end());\n\n    ll ans = 0;\n    BinaryIndexedTree<ll> bit(B - A + 1, P);\n    bit.update(1, 1);\n    REP(i, 0, B - A) {\n      ll x = s[i].second + 2;\n      bit.update(x, bit.query(x));\n    }\n    cout << (bit.query(B - A + 1) - 1 + P) % P << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct FenwickTree {\n  ll data[101000];\n  void add(int index, ll v) {\n    for (index += 3; index <= 100100; index += index & -index) {\n      data[index] += v;\n    }\n  }\n  ll sum(int index) {\n    ll ret = 0;\n    for (index += 3; index > 0; index -= index & -index) {\n      ret += data[index];\n    }\n    return ret;\n  }\n};\n\nstruct Number {\n  ll num;\n  char str[15];\n  Number() {;}\n  Number(ll num) : num(num) {\n    sprintf(str, \"%lld\", num);\n  }\n  bool operator<(const Number &rhs) const {\n    return strcmp(str, rhs.str) < 0;\n  }\n};\n\nNumber numbers[100100];\nFenwickTree ftree;\nll P;\n\nint main() {\n  ll A, B;\n  while (scanf(\"%lld %lld %lld\", &A, &B, &P), A|B|P) {\n    int n = B - A + 1;\n    MEMSET(ftree.data, 0);\n    REP(i, n) {\n      numbers[i] = Number(A + i);\n    }\n    sort(numbers, numbers + n);\n    ll ans = 0;\n    REP(i, n) {\n      ll v = (ftree.sum(numbers[i].num - A) + 1) % P;\n      ans = (ans + v) % P;\n      ftree.add(numbers[i].num - A, v);\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nll mod_pow(ll x, ll n, ll p) {\n    ll res = 1;\n    while(n > 0) {\n        if(n & 1) {\n            res = (res * x) % p;\n        }\n        x = (x * x) % p;\n        n >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nclass fenwick_tree {\npublic:\n    fenwick_tree(int n) : n(n), dat(n, 0) {}\n\n    void add(int i, T value) {\n        for(; i<n; i |= i + 1) {\n            dat[i] += value;\n        }\n    }\n\n    T sum(int i, ll M) const {\n        T res = 0;\n        for(; i>=0; i = (i & (i+1)) - 1) {\n            (res += dat[i]) %= M;\n        }\n        return res;\n    }\n\n    T sum(int l, int r, ll M) const {\n        return sum(r-1, M) - sum(l-1, M);\n    }\n\nprivate:\n    const int n;\n    std::vector<T> dat;\n};\n\nint main() {\n    ll A, B, P;\n    while(cin >> A >> B >> P, A) {\n        const ll L = B - A + 1;\n        vector<string> s(L);\n        for(ll i=A; i<=B; ++i) {\n            s[i-A] = to_string(i);\n        }\n        sort(s.begin(), s.end());\n        fenwick_tree<ll> bit(L);\n        ll res = 0;\n        for(int i=0; i<L; ++i) {\n            ll r = stol(s[i]) - A;\n            ll t = bit.sum(0, r, P);\n            assert(t >= 0);\n            (res += t + 1) %= P;\n            bit.add(r, t + 1);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct SegTree{\n    int n; vector<ll> dat;\n    ll mod;\n    //初期化\n    SegTree(int _n, ll _mod){\n        n=1;\n        while(n<_n) n*=2;\n        dat=vector<ll>(2*n-1,0);\n\n        mod = _mod;\n    }\n    //k番目(0-indexed)の値をaに変更\n    void update(int k, ll a){\n        k+=n-1;\n        dat[k]=a;\n        //更新\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=(dat[2*k+1]+dat[2*k+2])%mod;\n        }\n    }\n    //内部的に投げられるクエリ\n    ll _query(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l) return 0;\n\n        if(a<=l && r<=b) return dat[k];\n\n        ll vl=_query(a,b,2*k+1,l,(l+r)/2);\n        ll vr=_query(a,b,2*k+2,(l+r)/2,r);\n        return (vl+vr)%mod;\n    }\n    //[a,b)\n    ll query(int a, int b){\n        return _query(a,b,0,0,n);\n    }\n};\n\nusing P = pair<string, int>;\n\nint main(){\n    int a,b,p;\n    while(cin >>a >>b >>p,a){\n        int n = b-a+1;\n        SegTree st(n,p);\n\n        vector<P> v;\n        for(int i=1; i<=b-a+1; ++i){\n            int val = a+i-1;\n            v.pb({to_string(val), i});\n        }\n        sort(all(v));\n\n        st.update(0,1);\n        rep(i,v.size()){\n            int idx = v[i].se;\n            st.update(idx, st.query(0,idx));\n        }\n\n        cout << st.query(1,n+1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll A, B, P;\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<int> node;\n \npublic:\n    SegmentTree() {\n        int sz = 100010;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = (node[2*i+1] + node[2*i+2]) % P;\n    }\n \n    void update(int x, int val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = (node[2*x+1] + node[2*x+2]) % P;\n        }\n    }\n    // hannkaikukann \n    int getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n \n        int vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        int vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr) % P;\n    }\n};\n\ntypedef pair<string, ll> sl;\nll ans;\n\nvoid solve() {\n    vector<sl> v;\n    ans = 0;\n    SegmentTree seg;\n    for(ll i = A; i <= B; i++) {\n        string S = to_string(i);\n        ll j = i - A;\n        v.push_back({S, j});\n    }\n    sort(v.begin(), v.end());\n    for(auto tmp : v) {\n        int idx = tmp.second;\n        ll val = seg.getsum(0, idx);\n        //cerr << idx << \" \" << val << endl;\n        seg.update(idx, val + 1);\n    }\n    cout << seg.getsum(0, B - A + 1) << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> A >> B >> P) {\n        if(P == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nlong long int a, b, c;\n\n\ntemplate <typename D, typename T = D, typename L = T>\nclass Tree {\npublic:\n\tTree( long long int size = 0, D InitialValueArg = D() ) {\n\t\tlong long int n = 1LL;\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t\twhile( n <= size ) {\n\t\t\tn <<= 1LL;\n\t\t\taddOneLine( n );\n\t\t}\n\t\tInitialValue = InitialValueArg;\n\t\tData.resize( n, InitialValue );\n\t\tfor( size_t i = 0; i < Data.size(); i++ ) {\n\t\t\tupdate( i, Data[i] );\n\t\t}\n\t\tMaxSize = n;\n\t\tNowIndex = 0LL;\n\t}\n\n\tvirtual T preprocessing( D a ) {\n\t\treturn T( a );\n\t}\n\n\tvirtual T treeupdate( T a, T b ) {\n\t\treturn a;\n\t}\n\n\tvirtual L lazyupdate( L parent, L me ) {\n\t\treturn parent;\n\t}\n\n\tvirtual T fromlazytotreenode( L lazy, T nownode ) {\n\t\treturn nownode;\n\t}\n\n\tvoid update( long long int idx, D data ) {\n\t\tcalcLazyUpdate( idx, idx + 1 );\n\t\tData[idx] = data;\n\n\t\tupdateTreeNodeidx( idx, preprocessing( data ) );\n\t}\n\n\tvoid rangeupdate( long long int idxl, long long int idxr, L data ) {\n\n\t}\n\n\tvoid show() {\n\t\tfor( auto x : CalcTree ) {\n\t\t\tfor( auto y : x ) {\n\t\t\t\tcout << y << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\tvoid push( D data ) {\n\t\tif( NowIndex == MaxSize ) {\n\t\t\tMaxSize <<= 1LL;\n\t\t\taddOneLine( MaxSize );\n\t\t\tvector<D>Datamemo( MaxSize, InitialValue );\n\t\t\tcopy( Data.begin(), Data.end(), Datamemo.begin() );\n\t\t\tfor( long long int i = 0; i < Datamemo.size(); i++ ) {\n\t\t\t\tupdate( i, Datamemo[i] );\n\t\t\t}\n\t\t}\n\t\tData[NowIndex] = data;\n\t\tupdate( NowIndex, data );\n\t\tNowIndex++;\n\t}\n\n\tT range( long long int l, long long int r ) {\n\t\tcalcLazyUpdate( l, r );\n\t\treturn rangeProcessing( 0, l, r, 0, 0, MaxSize );\n\t}\n\n\tlong long int t() {\n\t\treturn 10;\n\t}\n\nprivate:\n\n\t//??????????????????\n\tstruct TreeNode {\n\t\tT Ndata;\n\n\t\t//?????¶?????????\n\t\tstruct {\n\t\t\tlong long int Lnum;\n\t\t\tL Ldata;\n\t\t};\n\t};\n\tvector<vector<TreeNode>> CalcTree;\n\tvector<D> Data;\n\tlong long int MaxSize;\n\tlong long int NowIndex;\n\tD InitialValue;\n\n\tvoid addOneLine( long long int n ) {\n\t\tCalcTree.emplace_back( vector<TreeNode>( n ) );\n\t}\n\n\tT rangeProcessing( long long int d, long long int a, long long int b, long long int k, long long int l, long long int r ) {\n\t\tif( !( r <= a || b <= l ) && d < CalcTree.size() ) {\n\t\t\tif( a <= l&&r <= b ) {\n\t\t\t\treturn CalcTree[d][k].Ndata;\n\t\t\t} else {\n\t\t\t\treturn treeupdate( rangeProcessing( d + 1, a, b, k * 2, l, ( l + r ) / 2 ), rangeProcessing( d + 1, a, b, k * 2 + 1, ( l + r ) / 2, r ) );\n\t\t\t}\n\t\t}\n\t\treturn InitialValue;\n\t}\n\n\tvoid calcLazyUpdate( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\t\tif( i < CalcTree.size() - 1 ) {\n\t\t\tCalcTree[i + 1][nowidx * 2].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2].Ldata );\n\t\t\tCalcTree[i + 1][nowidx * 2 + 1].Ldata = lazyupdate( CalcTree[i][nowidx].Ldata, CalcTree[i + 1][nowidx * 2 + 1].Ldata );\n\t\t\tCalcTree[i][nowidx].Ldata = L();\n\t\t\tlong long int nextidxplus = 1LL << ( CalcTree.size() - i - 1 );\n\t\t\tnowidx *= 2;\n\t\t\tif( idxr <= nowidx + nextidxplus ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx );\n\t\t\t} else if( nowidx + nextidxplus <= idxl ) {\n\t\t\t\tcalcLazyUpdate( idxl, idxr, i + 1, nowidx + 1 );\n\t\t\t} else {\n\t\t\t\tcalcLazyUpdate( nowidx + nextidxplus, idxr, i + 1, nowidx + 1 );\n\t\t\t\tcalcLazyUpdate( idxl, nowidx + nextidxplus, i + 1, nowidx );\n\t\t\t}\n\t\t} else {\n\t\t\tT nextT = fromlazytotreenode( CalcTree[i][nowidx].Ldata, CalcTree[i][nowidx].Ndata );\n\t\t\tif( nextT != CalcTree[i][nowidx].Ndata ) {\n\t\t\t\tupdateTreeNodeidx( nowidx, nextT );\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid updateTreeNodeidx( long long int idx, T TreeNodeData ) {\n\t\t( *( CalcTree.rbegin() ) )[idx].Ndata = preprocessing( TreeNodeData );\n\t\tfor( auto ite = CalcTree.rbegin(); ite + 1 < CalcTree.rend(); ) {\n\t\t\tidx >>= 1LL;\n\t\t\tT updatedata = treeupdate( ( *ite )[idx * 2].Ndata, ( *ite )[idx * 2 + 1].Ndata );\n\t\t\tite++;\n\t\t\tif( ( *ite )[idx].Ndata != updatedata ) {\n\t\t\t\t( *ite )[idx].Ndata = updatedata;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long int addrangeLazy( long long int idxl, long long int idxr, long long int i = 0, long long int nowidx = 0 ) {\n\n\t}\n};\n\nclass segtree : public Tree<long long int> {\npublic:\n\tsegtree( long long int a, long long int b ):Tree( a, b ) {\n\n\t}\n\tlong long int treeupdate( long long int a, long long int b ) {\n\t\treturn ( a + b ) % c;\n\t}\n};\n\n\n\nint main() {\n\twhile( cin >> a >> b >> c, a || b || c ) {\n\t\tsegtree x( b - a + 1, 0 );\n\t\tvector<string>D( b - a + 1 );\n\t\tfor( size_t i = a; i <= b; i++ ) {\n\t\t\tD[i - a] = to_string( i );\n\t\t}\n\t\tsort( D.begin(), D.end() );\n\t\tvector<long long int >Dx( b - a + 1 );\n\t\tfor( size_t i = 0; i < b - a + 1; i++ ) {\n\t\t\tDx[i] = stoll( D[i] );\n\t\t\tx.update( Dx[i] - a, x.range( 0, i ) + 1 );\n\t\t}\n\t\tcout << x.range( 0, b - a + 2 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a + b.num); }\nMod operator+(const Mod a, const long long int  b) { return b+a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a*b.num); }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<17) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tMod sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tMod lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tint adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>\nclass Fenwick{\npublic:\n  vector<T> data;\n  int n;\n  Fenwick(){};\n  Fenwick(int tn){\n    data.resize(tn,0);\n    n = tn;\n  }\n  T read(int idx,int tidx,ll mod){\n    T sum = 0;\n    if (idx == 0){\n      while(tidx > 0){\n\tsum=(sum+data[tidx])%mod;\n\ttidx-=(tidx&-tidx);\n      }\n      return sum;\n    }else return (read(0,tidx,mod)-read(0,idx-1,mod)+mod)%mod;\n  }\n  void update(int idx,T val,ll mod){\n    while(idx <= n){\n      data[idx]=(data[idx]+val)%mod;\n      idx+=(idx & -idx);\n    }\n  }\n};\n\nmain(){\n  ll a,b,p;\n  while(cin>>a>>b>>p && p){\n    Fenwick<ll> dp(b-a+2);\n    vector<int> num(b-a+1);\n    vector<string> all;\n    for(ll i=a;i<=b;i++){\n      string tmp=\"\";\n      ll now = i;\n      while(now)tmp=tmp+string(1,'0'+now%10),now/=10;\n      reverse(tmp.begin(),tmp.end());\n      all.push_back(tmp);\n    }\n\n    sort(all.begin(),all.end());\n    for(int i=0;i<all.size();i++){\n      ll tmp = 0;\n      for(int j=0;j < all[i].size();j++){\n\ttmp=tmp*10+all[i][j]-'0';\n      }\n      num[tmp-a]=i+1;\n    }\n    for(ll i=a;i <= b;i++){\n      int now = num[i-a];\n      ll tmp = (dp.read(0,now-1,p)+1)%p;//+1 is itself\n      dp.update(now,tmp,p);\n    }\n    cout << dp.read(0,b-a+1,p) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint bit[100100];\nint N, P;\n\nvoid add(int k, int x)\n{\n    for (; k <= N + 1; k += k & -k){\n        bit[k] = (bit[k] + x) % P;\n    }\n}\n\nint sum(int k)\n{\n    int ret = 0;\n    for (; k; k &= (k - 1)){\n        ret = (ret + bit[k]) % P;\n    }\n    return (ret);\n}\n\nint main()\n{\n    int A, B;\n    string v[100000];\n\n    while (scanf(\"%d %d %d\", &A, &B, &P) && A){\n        memset(bit, 0, sizeof(bit));\n        N = B - A + 1;\n        add(N + 1, 1);\n        \n        for (int i = 0; i < N; i++){\n            v[i] = to_string(A + i);\n        }\n\n        sort(v, v + N);\n\n        for (int i = N - 1; i >= 0; i--){\n            int pos = stoi(v[i]) - A;\n            int nv = (sum(N + 1) - sum(pos) + P) % P;\n            add(pos + 1, nv);\n        }\n\n       printf(\"%d\\n\", sum(N));\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint t10[10];\nvoid init() {\n\tt10[0] = 1;\n\trep(i, 9) {\n\t\tt10[i + 1] = t10[i] * 10;\n\t}\n}\nint a, b, p;\n\n\nvoid solve() {\n\tint dif = b - a+1;\n\tvector<ll> r(dif + 1, 1);\n\trep(i, dif) {\n\t\tint x = a + i;\n\n\t\tll csum = 0;\n\t\tstring s = to_string(x);\n\t\tint tmp = s.length() - 1;\n\t\t//cout << x << \" \" << tmp << endl;\n\t\tbool f = false;\n\t\twhile (x >= a) {\n\t\t\tint d = t10[tmp] - a;\n\t\t\tif (d < 0)d = 0;\n\t\t\tint l = x - a; if (l < 0)l = 0;\n\t\t\tif (f)l++;\n\t\t\tcsum += r[l] - r[d] + p;\n\t\t\t//cout << r[l] - r[d] << endl;\n\t\t\t//cout << i << \" \" << d << endl;\n\t\t\twhile (csum >= p)csum -= p;\n\t\t\tx /= 10; tmp--; f = true;\n\t\t}\n\t\tr[i + 1] += r[i] + csum;\n\t\twhile (r[i + 1] >= p)r[i + 1] -= p;\n\t}\n\t//rep(i, dif+1)cout << r[i] << endl;\n\tll ans = r[dif] - 1;\n\twhile (ans < 0)ans += p;\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tinit();\n\twhile (cin >> a >> b >> p, a) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct FenwickTree{\n\tvector<ll> data;\n\tFenwickTree(int n):data(n+1){}\n\tvoid Add(int i,int x){\n\t\tfor(i++;i<data.size();i+=i&-i)\n\t\t\tdata[i]+=x;\n\t}\n\tll Sum(int i){\n\t\tll res=0;\n\t\tfor(;i;i-=i&-i)\n\t\t\tres+=data[i];\n\t\treturn res;\n\t}\n\tll Sum(int i,int j){\n\t\treturn Sum(j)-Sum(i);\n\t}\n};\n\nint main()\n{\n\tfor(int a,b,p;cin>>a>>b>>p && a|b|p;){\n\t\tint n=b-a+1;\n\t\tvi xs;\n\t\t{\n\t\t\tvs ss;\n\t\t\trep(i,n){\n\t\t\t\tchar s[11];\n\t\t\t\tsprintf(s,\"%d\",a+i);\n\t\t\t\tss.push_back(s);\n\t\t\t}\n\t\t\tsort(all(ss));\n\t\t\tfor(auto s:ss) xs.push_back(atoi(s.c_str()));\n\t\t}\n\t\t\n\t\tFenwickTree ft(n);\n\t\tfor(int x:xs){\n\t\t\tll sum=ft.Sum(x-a);\n\t\t\tft.Add(x-a,(sum+1)%p);\n\t\t}\n\t\tcout<<ft.Sum(n)%p<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\ntypedef long long int lli;\nconst lli inf = 1e9;\n\nlli modadd(lli a, lli b, lli mod){\n    lli res = (a+b)%mod;\n    while(res<0) res+=mod;\n    return res;\n}\n\nbool numlex(lli a, lli b){\n    if(a > b) return false;\n    return to_string(a) < to_string(b);\n}\n\nlli binsearch(lli a, lli lb, lli ub){\n    if(!numlex(a, ub)) return ub+1;\n    while(lb < ub){\n        lli mid = (lb +ub)/2;\n        if(numlex(a, mid)){\n            ub = mid;\n        }else{\n            lb = mid+1;\n        }\n    }\n    return lb;\n}\n\nlli solve(lli a, lli b, lli p){\n    vector<lli> dp(b-a+2, 0);\n    lli res = 0;\n    for(lli i=0; i<b-a+1; i++){\n        dp[i+1] += dp[i];\n        dp[i]++;\n        res = modadd(res, dp[i], p);\n        lli low=1, up=10;\n        for(; low<=inf; low*=10, up*=10){\n            if(up < a || low > b) continue;\n            lli ret = binsearch(a+i, low, up-1);\n            if(ret == up) continue;\n            if(ret <= b) dp[ret-a] = modadd(dp[ret-a], dp[i], p);\n            if(up <= b) dp[up-a] = modadd(dp[up-a], -dp[i], p);\n        }\n        \n    }\n    return res;\n\n}\n\nint main(){\n    while(1){\n        int a,b,p;\n        cin >> a >> b >> p;\n        if(a==0) break;\n        cout << solve(a,b,p) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\n#include <sstream>\n#define FI first\n#define SE second\nusing namespace std;\nconst double EPS = 1e-8;\nconst int MAXN = 500005;\nconst int INF = 1111111111;\nstruct Node{\n    string str;\n    int id;\n    bool operator<(const Node &a)const {\n        return str<a.str;\n    }\n}node[MAXN];\nlong long tree[MAXN];\nint n;\nlong long ans[MAXN];\nint a,b,MOD;\nint lowbit(int x) {\n    return x&(-x);\n}\nvoid update (int x,long long add) {\n    while (x<=n) {\n        tree[x] = (tree[x]+add)%MOD;\n        x += lowbit(x);\n    }\n}\nlong  query(int x) {\n    long ret = 0;\n    while (x > 0) {\n        ret = (ret +tree[x])%MOD;\n        x -= lowbit(x);\n    }\n    return ret;\n}\nint main() {\n    //freopen(\"/home/qitaishui/in.txt\",\"r\",stdin);\n\n    while (scanf(\"%d%d%d\",&a,&b,&MOD)&&(MOD)) {\n        n = 1;\n        for (int i = a; i <= b; ++i) {\n            node[n].id = n;\n            //int tmp = i;\n            stringstream st;\n            st<<i;\n            st>>node[n].str;\n\n            ++n;\n            //cout<<node[n++].str<<endl;\n        }\n        --n;\n        memset(tree,0,sizeof(tree));\n        sort (node+1,node+n+1);\n        long long su = 0;\n        memset(ans,0,sizeof(ans));\n        for (int i = 1; i <= n; ++i) {\n\n            ans[i] = (su+query(node[i].id) + 1)%MOD;\n            //su =  (su+ans[i])%MOD;\n            update(node[i].id,ans[i]);\n            //cout<<i<<endl;\n        }\n        long long ret = 0;\n        for (int i = 1; i <= n; ++i) {\n            ret = (ret+ans[i])%MOD;\n        }\n        cout<<ret<<\"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nint dp[200001];\n\nint sc(int r,int mo){\n\tint h=0;\n\tif(9<r)h+=dp[9];\n\tif(99<r)h+=dp[99];\n\tif(999<r)h+=dp[999];\n\tif(9999<r)h+=dp[9999];\n\tif(99999<r)h+=dp[99999];\n//\tif(9<h)h+=dp[9];\n\th+=dp[r];\n\th%=mo;\n//\tcout<<r<<\" \"<<h<<endl;\n\treturn h;\n}\n   signed main(){\n int a,b,p;\n   \twhile(1){\n   \tcin>>a>>b>>p;\n   \t\tfor(int i=0;i<=200000;i++)dp[i]=0;\n   \t\tif(p==0) return 0;\n   \t\tstring sa=itos(a);\n   \t\tstring sb=itos(b);\n   \t\tif(sa.length()==sb.length()){\n   \t\t\tint r=beki(2,b-a+1,p);\n   \t\t\tr+=(p-1);\n   \t\t\tcout<<r%p<<endl;\n   \t\t\tcontinue;\n   \t\t}\n   \t\t\n   \t\tif(b>=200000){\n   \t\t\t\n   \t\t\tint aa=a;\n   \t\t\twhile(itos(aa).length()==sa.length())aa++;\n   \t\t\tint r=beki(2,b-aa+1,p)+beki(2,aa-a,p);\n   \t\t\tr+=(2*p-2);\n   \t\t\tr%=p;\n   \t\t\tcout<<r<<endl;\n   \t\t\tcontinue;\n   \t\t\t\n   \t\t}\n   \t\t\n   \t\tfor(int i=1;i<=b;i++){\n   \t\t\tif(i<a){\n   \t\t\tdp[i]=0;\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\tif(i==a){\n   \t\t\t\tdp[i]=1%p;\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\tif( i==10 ||i==100 ||i==1000 ||i==10000||i==100000  ){\n   \t\t\t\tif(i==10){\n   \t\t\t\t\tdp[10]=1+dp[1];\n   \t\t\t\t\tdp[10]%=p;\n   \t\t\t\t}\n   \t\t\t\tif(i==100){\n   \t\t\t\t\tdp[100]=1+dp[10]+dp[1];\n   \t\t\t\t\tdp[100]%=p;\n   \t\t\t\t}\n   \t\t\t\tif(i==1000){\n   \t\t\t\t\tdp[1000]=1+dp[10]+dp[100]+dp[1];\n   \t\t\t\t\tdp[1000]%=p;\n   \t\t\t\t}\n   \t\t\t\tif(i==10000){\n   \t\t\t\t\tdp[10000]=1+dp[1]+dp[10]+dp[100]+dp[1000];\n   \t\t\t\t\tdp[10000]%=p;\n   \t\t\t\t}\n   \t\t\t\tif(i==100000){\n   \t\t\t\t\tdp[100000]=1+dp[1]+dp[10]+dp[100]+dp[1000]+dp[10000];\n   \t\t\t\t\tdp[100000]%=p;\n   \t\t\t\t}\n   \t\t\t\tcontinue;\n   \t\t\t}\n   \t\t\t\n   \t\t\tdp[i]=2*dp[i-1]+1;\n   \t\t\tdp[i]%=p;\n   \t\t\tint ii=i/10;\n   \t\t\twhile(ii>0){\n   \t\t\t\tdp[i]+=dp[ii];\n   \t\t\t\tdp[i]%=p;\n   \t\t\t\tii/=10;\n   \t\t\t}\n   \t\t\t\n   \t\t//\tif(b==10) cout<<i<<\" \"<<dp[i]<<endl;\n   \t\t}\n   \t\tcout<<(sc(b,p))%p<<endl;\n\n   \t}\n\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a + b.num); }\nMod operator+(const Mod a, const long long int  b) { return b+a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a*b.num); }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tlong long int sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tlong long int lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tseg[k].sum %= mod;\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k].lazy %= mod;\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t\tseg[2 * k+1].lazy %= mod;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n\tseg[k].sum %= mod;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tseg[k].lazy %= mod;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nlong long int get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tif (!A)break;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tlong long int adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass BIT {\nprivate:\n\tint size;\n\tvector<long long> bit;\n\tint mod;\n\npublic:\n\tBIT(int n, int m):size(n), bit(n + 1, 0), mod(m) {}\n\n\tvoid add(int i, int x) {\n\t\twhile(i <= size) {\n\t\t\tbit[i] += x;\n\t\t\tbit[i] %= mod;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\n\tlong long sum(int i) const {\n\t\tlong long s = 0;\n\t\twhile(i > 0) {\n\t\t\ts += bit[i];\n\t\t\ts %= mod;\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int a, b, p; cin >> a >> b >> p && a;) {\n\t\tconst int num = b - a + 2;\n\n\t\tvector<string> order;\n\t\torder.reserve(num);\n\n\t\tfor(int i = a; i <= b; ++i) {\n\t\t\torder.emplace_back(to_string(i));\n\t\t}\n\n\t\tsort(order.begin(), order.end());\n\n\t\tBIT bit(num, p);\n\t\tbit.add(1, 1);\n\n\t\tfor(const auto &s : order) {\n\t\t\tconst int index = stoi(s) - a + 2;\n\t\t\tconst auto tmp = bit.sum(index - 1);\n\t\t\tbit.add(index, tmp);\n\t\t}\n\n\t\tcout << (bit.sum(num) - 1 + p) % p << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint a, b, P;\nint bit[100010];\nint sum(int i){\n\tint res = 0;\n\tfor(; i; i -= i & -i) (res += bit[i]) %= P;\n\treturn res;\n}\nvoid add(int i, int x){\n\tfor(; i < 100010; i += i & -i) (bit[i] += x) %= P;\n}\n\nint main(){\n\twhile(cin >> a >> b >> P, a){\n\t\tmemset(bit, 0, sizeof(bit));\n\t\tvector<string> v;\n\t\tfor(int i = a; i <= b; i++){\n\t\t\tchar buf[20];\n\t\t\tsprintf(buf, \"%d\", i);\n\t\t\tv.pb(buf);\n\t\t}\n\t\tsort(all(v));\n\t\t\n\t\tint ans = 0;\n\t\trep(i, v.size()){\n\t\t\tint d, t;\n\t\t\tsscanf(v[i].c_str(), \"%d\", &d);\n\t\t\td -= a - 1;\n\t\t\tt = sum(d) + 1;\n\t\t\t(ans += t) %= P;\n\t\t\tadd(d, t);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define SZ(v) ((int)v.size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define POPCNT(n) (__builtin_popcount(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\ntemplate <typename T>\nstruct BinaryIndexedTree {\n    int n;\n    vector<T> d;\n\n    BinaryIndexedTree(int n): n(n), d(n + 1, 0) {}\n\n    // a[1] + ... + a[k] (1-indexed)\n    T sum(int k, int p)\n    {\n        T res = 0;\n        while (k > 0) {\n            (res += d[k]) %= p;\n            k -= k & -k;\n        }\n        return res;\n    }\n\n    // a[l] + ... + a[r] (1-indexed)\n    T sum(int l, int r, int p)\n    {\n        return sum(r, p) - sum(l - 1, p);\n    }\n\n    // a[k] += x (1-indexed)\n    void add(int k, T x, int p)\n    {\n        while (k <= n) {\n            (d[k] += x) %= p;\n            k += k & -k;\n        }\n    }\n};\ntemplate <typename T> using BIT = BinaryIndexedTree<T>;\n\nvoid solve(int a, int b, int p) {\n    const int n = b - a + 1;\n    vector<int> v(n);\n    iota(ALL(v), a);\n    sort(ALL(v), [&](int x, int y) {\n        return to_string(x) < to_string(y);\n    });\n    BIT<int> bit(n);\n    vector<int> dp(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        dp[i + 1] = (bit.sum(v[i] - a, p) + 1) % p;\n        bit.add(v[i] - a + 1, dp[i + 1], p);\n    }\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        (ans += dp[i + 1]) %= p;\n    }\n    cout << ans << endl;\n}\n\nvoid _main() {\n    int A, B, P;\n    while (cin >> A >> B >> P, A) {\n        solve(A, B, P);\n    }\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        if (strchr(argv[1], 'i'))\n            freopen(\"input.txt\", \"r\", stdin);\n        if (strchr(argv[1], 'o'))\n            freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long A, B, P, sum[100005];\n\nvoid add(int k, int x)\n{\n  for(++k; k < 100005; k += k & -k) (sum[k] += x) %= P;\n}\nint query(int k)\n{\n  int ret = 0;\n  for(++k; k > 0; k -= k & -k) (ret += sum[k]) %= P;\n  return(ret);\n}\n\nint main()\n{\n  while(cin >> A >> B >> P, A) {\n    vector< string > d;\n    for(int i = A; i <= B; i++) {\n      stringstream sss; sss << i;\n      d.push_back(sss.str());\n    }\n    sort(d.begin(), d.end());\n    for(int i = 0; i < d.size(); i++) {\n      int val = stoi(d[i]);\n      add(val - A, (query(val - A) + 1) % P);\n    }\n    cout << query(B - A) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<17;\n\nll mod;\nclass BIT2{\npublic:\n  int n;\n  ll bit0[MAX_N+1],bit1[MAX_N+1];//1????????????\n\n  BIT2(){n = MAX_N;memset(bit0,0,sizeof(bit0));memset(bit1,0,sizeof(bit1));}\n  BIT2(int n){this->n=n;memset(bit0,0,sizeof(bit0));memset(bit1,0,sizeof(bit1));}\n  \n  ll sum(ll *b,int i){\n    ll s=0;\n    while(i>0){\n      s=(s+b[i])%mod;\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(ll *b,int i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v)%mod;\n      i+=i&-i;\n    }\n  }\n\n  //[a,b]???x?????????(1<=a)\n  void add (int a,int b,ll x){\n    add(bit0,a,-x*(a-1));\n    add(bit1,a,x);\n    add(bit0,b+1,x*b);\n    add(bit1,b+1,-x);\n  }\n\n  //[a,b]???sum?????????(1<=a)\n  ll sum(int a,int b){\n    ll res=0;\n    res+=sum(bit0,b)+sum(bit1,b)*b;\n    res-=sum(bit0,a-1)+sum(bit1,a-1)*(a-1);\n    return (res+mod)%mod;    \n  }\n};\n\nstring i2S(ll num){\n  string res;\n  if(num==0)return \"0\";\n  while(num) res=(char)(num%10+'0')+res,num/=10;\n  return res;\n}\n\nint main(){\n  while(1){\n    ll A,B;\n    cin>>A>>B>>mod;\n    if(!A&&!B&&!mod)return 0;\n    vector<string> num;\n    for(ll i=A;i<=B;i++)num.push_back(i2S(i));\n    sort(num.begin(),num.end());\n  \n    ll ans = 0, n = B-A+2;\n    BIT2 T(n);\n    T.add(1,n,1);\n    \n    for(ll i=A;i<=B;i++){\n      int idx = lower_bound(num.begin(),num.end(),i2S(i))-num.begin()+1;\n      ll val = T.sum(idx,idx);\n      ans=(ans+val)%mod;\n      T.add(idx,n,val);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nll solve(ll a,ll b,ll p){\n    b++;\n    vector<ll> sumv;\n    sumv.push_back(0);\n    auto sum=[&](ll l,ll r){\n        l=max(l,a);\n        return r<=l ? 0LL : (sumv[r-a]+p-sumv[l-a])%p;\n    };\n    for(ll x=a;x<b;x++){\n        ll v=sum(a,x)+1;\n        ll ten=10;\n        for(int i=1;i<10;i++){\n            ll y=x/ten;\n            ll z=1;\n            while(z<=y) z*=10;\n            v=(v+p-sum(y+1,z))%p;\n            ten*=10;\n        }\n        sumv.push_back(v+sumv.back());\n    }\n    return sum(a,b);\n}\nint main(){\n    ll a,b,p;\n    while(cin>>a>>b>>p,a){\n        cout<<solve(a,b,p)<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/**邂玲ウ募?譫撰シ?\n*/\n#include<bits/stdc++.h>\n#define MAXN 105000\n#define PI acos(-1.0)\n#define MOD 1000000007\n#define REP(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,t) for(int i=s; i<=t; i++)\n#define mem(a,b)  memset(a,b,sizeof(a))\n#define show(x) { cerr<<\">>>\"<<#x<<\" = \"<<x<<endl; }\n#define show2(x,y) { cerr<<\">>>\"<<#x<<\"=\"<<x<<\"  \"<<#y<<\" = \"<<y<<endl; }\nusing namespace std;\n\nlong long sum[MAXN];\n//sum[i]陦ィ遉コ[i,B]貊。雜ウ鬚俶э逧?クェ謨ー?井ク榊桁蜷ォ遨コ髮?シ?\nlong long cal(long long a)\n{\n    long long ret = 9;\n    while(a > 0)\n    {\n        ret = ret*10 + 9;\n        a = a / 10;\n    }\n    ret = ret / 10;\n    return ret*10;\n}\n\nint main()\n{\n    //freopen(\"E:\\\\acm\\\\input.txt\",\"r\",stdin);\n    //freopen(\"E:\\\\acm\\\\output.txt\",\"w\",stdout);\n     long long A,B,P;\n     while(cin>>A>>B>>P)\n     {\n         if(A == 0 && B == 0 && P == 0) break;\n         long long ans = 0;\n         for(long long i = B; i >= A; i--)\n         {\n             long long mx = cal(i);\n             long long tmp = 0;\n             if(i == mx / 10)\n             {\n                 tmp = i*10 > B ? 0 : sum[i*10 - A]; //show2(i,tmp);\n             }\n             else\n             {\n                 tmp = i+1 > B ? 0 : sum[i+1 - A];\n                 tmp += i*10 > B ? 0 : sum[i*10 - A];\n                 tmp -= mx > B ? 0 : sum[(i+1)*10 - A];\n                 tmp = (tmp % P + P) % P; //show2(i,tmp);\n             }\n             sum[i-A] = (2 * tmp + 1) % P;\n             ans = (ans + tmp + 1) % P;   //show2(sum[i-A],ans);\n         }\n         cout<<ans<<endl;\n     }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define lowbit(n)  (n&-n)\nint l,r,m,a[100005],b,c[100005];\nvoid add(int pos,int val)\n{\n    while(pos<=r-l+1)  c[pos]=(c[pos]+val)%m,pos+=lowbit(pos);\n}\nint getsum(int pos)\n{\n    int ans=0;\n    while(pos)  ans=(ans+c[pos])%m,pos-=lowbit(pos);\n    return ans;\n}\nint cmp(int a,int b)\n{\n    char sa[15],sb[15];\n    sprintf(sa,\"%d\",a);\n    sprintf(sb,\"%d\",b);\n    return strcmp(sa,sb)<0;\n}\nint main()\n{\n    int i;\n    while(scanf(\"%d%d%d\",&l,&r,&m)!=EOF&&(l+r+m))\n\t{\n\t\tint t=0;\n        for(i=l;i<=r;i++)\n            a[t++]=i;\n        sort(a,a+t,cmp);\n        memset(c,0,sizeof(c));\n        int sum=0;\n        for(i=0;i<t;i++)\n\t\t{\n            b=getsum(a[i]-l+1)+1;\n            add(a[i]-l+1,b);\n            sum=(sum+b)%m;\n        }\n        printf(\"%d\\n\",sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint M;\n\ntemplate<class T>\nclass FenwickTree{\n\tvector<T> a;\npublic:\n\tFenwickTree(int n):a(n){}\n\tT sum(int i,int j)const{\n\t\tif(i==0){\n\t\t\tT s=0;\n\t\t\tfor(;j>=0;j=(j&(j+1))-1) s=(s+a[j])%M;\n\t\t\treturn s;\n\t\t}\n\t\treturn ((sum(0,j)-sum(0,i-1))%M+M)%M;\n\t}\n\tvoid add(int i,T v){\n\t\tfor(;i<a.size();i|=i+1) a[i]=(a[i]+v)%M;\n\t}\n};\n\nbool lex(int a,int b){\n\tchar s[16],t[16];\n\tsprintf(s,\"%d\",a);\n\tsprintf(t,\"%d\",b);\n\treturn strcmp(s,t)<0;\n}\n\nint main(){\n\tfor(int a,b;scanf(\"%d%d%d\",&a,&b,&M),a;){\n\t\tint n=b-a+1,seq[100000];\n\t\trep(i,n) seq[i]=a+i;\n\t\tsort(seq,seq+n,lex);\n\n\t\tFenwickTree<int> F(b-a+1);\n\t\trep(i,n) F.add(seq[i]-a,F.sum(0,seq[i]-a)+1);\n\n\t\tprintf(\"%d\\n\",F.sum(0,n-1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n\nll bit[100002];\nll memo[100001];\nint n;\nll p;\n\nll sum(int i) {\n    ll s = 0;\n    while(i > 0) {\n        s += bit[i];\n        s %= p;\n        i -= i & -i;\n    }\n    return s;\n}\n\nvoid add(int i,ll x) {\n    while(i <= n) {\n        bit [i] += x;\n        bit[i] %= p;\n        i += i & -i;\n    }\n}\n\nint main() {\n    ll a,b;\n    stringstream ss;\n    while(cin>>a>>b>>p, a|b|p) {\n//        cout<<\"hoge\"<<endl;\n        vector<pair<string,ll> > vs;\n\n        memset(bit, 0, sizeof(bit));\n        n = b-a+1;\n        for(int i=0; i<n; ++i) {\n            memo[i] = 1;\n//            add(i+1,1);\n        }\n\n//        cout<<\"added\"<<endl;\n        for(ll i=a; i<=b; ++i) {\n//            cout<<i<<endl;\n            ss << i;\n            vs.push_back(make_pair(ss.str(),i-a));\n            ss.str(\"\");\n        }\n\n        sort(vs.begin(), vs.end());\n//        cout<<\"sorted\"<<endl;\n\n        for(int i=0; i<vs.size(); ++i) {\n            int idx = vs[i].second;\n            ll hoge = sum(idx+1);\n            memo[idx] += hoge;\n            add(idx+1,hoge+1);\n        }\n\n        ll ans = 0;\n        for(ll i=a; i<=b; ++i) {\n//            cout<<i<<\" \"<<memo[i-a]<<endl;\n            ans += memo[i-a];\n            ans %= p;\n        }\n\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nconst LL MOD = 1000000007LL;\nLL dp[100001];\nint main() {\n\tLL A, B, P;\n\twhile (cin >> A >> B >> P, A) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0] = 1;\n\t\tLL ans = 0;\n\t\tfor (LL i = A; i <= B; i++) {\n\t\t\tif (i > A) (dp[i - A] += dp[i - A - 1]) %= P;\n\t\t\t(ans += dp[i - A]) %= P;\n\t\t\tfor (LL j = i; j <= B; j *= 10) {\n\t\t\t\tLL ten = 1;\n\t\t\t\twhile (ten <= j) ten *= 10;\n\t\t\t\tLL x = max(i - A + 1, j - A), y = min(B - A + 1, ten - A);\n\t\t\t\t(dp[x] += dp[i - A]) %= P;\n\t\t\t\tdp[y] = (dp[y] - dp[i - A] + P) % P;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int A,B,P;cin>>A>>B>>P,A;){\n    vector<int> as{0};\n    for(int i=A;i<=B;i++){\n      int pt=1;\n      while(pt*10LL<=i){\n\tpt*=10;\n      }\n      int c=1;\n      for(int j=i;j>=A;j/=10,pt/=10){\n\tint cs=(as[max(0,j-1-(A-1))]-as[max(0,pt-1-(A-1))]+P)%P;\n\tc=(c+cs)%P;\n\tif(j!=i){\n\t  int cc=(as[j-(A-1)]-as[j-1-(A-1)]+P)%P;\n\t  c=(c+cc)%P;\n\t}\n      }\n      c=(c+as.back())%P;\n      as.push_back(c);\n    }\n    cout<<as.back()<<endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\ntemplate <class T>\nclass BIT\n{\nprivate :\n    vector<T> bit;\n    int n;\npublic :\n    T sum(int, T);\n    void add (int, T, T);\n\n    BIT (int i) {\n        n = i;\n        bit.resize(i + 1);\n    }\n};\n\ntemplate <typename T>\nT BIT<T>::sum (int i, T K) {\n    T s = (T)(0);\n    while (i) {\n        s += bit[i];\n        s %= K;\n        i -= i & -i;\n    }\n\n    return s;\n}\n\ntemplate <typename T>\nvoid BIT<T>::add (int i, T x, T K) {\n    while (i <= n) {\n        bit[i] += x;\n        bit[i] %= K;\n        i += i & -i;\n    }\n}\n\nint main() {\n    ll A, B, P;\n    while (cin >> A >> B >> P, A || B || P) {\n        vector<string> vs;\n        for (int i = A; i <= B; i++) {\n            stringstream ss;\n            ss << i;\n            string s;\n            ss >> s;\n            vs.push_back(s);\n        }\n\n        sort(vs.begin(), vs.end());\n\n        BIT<ll> b(B - A + 1);\n        for (int i = 0; i < vs.size(); i++) {\n            stringstream ss;\n            ss << vs[i];\n            ll v;\n            ss >> v;\n            ll sum = b.sum((int)(v-A), P);\n            b.add((int)(v-A+1LL), sum + 1LL, P);\n        }\n\n        cout << b.sum(B - A + 1LL, P) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long A, B, P, sum[100002];\n\nvoid add(int k, int x)\n{\n  for(++k; k < 100002; k += k & -k) (sum[k] += x) %= P;\n}\nint query(int k)\n{\n  int ret = 0;\n  for(++k; k > 0; k -= k & -k) (ret += sum[k]) %= P;\n  return(ret);\n}\n\nint main()\n{\n  while(cin >> A >> B >> P, A) {\n    memset(sum, 0, sizeof(sum));\n    vector< string > d;\n    for(int i = A; i <= B; i++) {\n      stringstream sss; sss << i;\n      d.push_back(sss.str());\n    }\n    sort(d.begin(), d.end());\n    for(int i = 0; i < d.size(); i++) {\n      int val = stoi(d[i]);\n      add(val - A, (query(val - A) + 1) % P);\n    }\n    cout << query(B - A) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nll A, B, mod;\nll toll(string str) {\n\tstringstream ss; ss << str;\n\tll res; ss >> res;\n\treturn res;\n}\nstring toS(ll n) {\n\tstringstream ss; ss << n;\n\tstring res; ss >> res;\n\treturn res;\n}\n\nll add(ll a, ll b) {\n\tif (a + b > mod) return a + b - mod;\n\treturn a + b;\n}\nll mul(ll a, ll b) {\n\treturn a * b % mod;\n}\nmap<ll, ll> m;\nll dp(string nstr) {\n\tll n = toll(nstr);\n\tif (n > B) return 0;\n\tif (m.count(n)) return m[n];\n\tll res = 0;\n\tres = add(res, dp(nstr+\"0\"));\n\tif ( nstr.size() == toS(n+1).size() ) {\n\t\tres = add(res, dp(toS(n+1)));\n\t}\n\tres = add(mul(res, 2), 1);\n\treturn m[n] = res;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile ( cin >> A >> B >> mod, A || B || mod ) {\n\t\tm.clear();\n\t\tll ans = 0;\n\t\tans = dp(toS(A));\n\t\t// FOR(i, A, B+1) {\n\t\t// \tans = add(ans, dp(toS(i)));\n\t\t// }\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_BIT\n#define ___Class_BIT\n\n// ------ Includes ------ //\n#include <vector>\n#pragma warning(disable : 4146)\n\n// ------ Class ------ //\ntemplate <typename Type>\nclass BIT {\nprivate:\n\tunsigned size_; std::vector<Type> v;\n\tType sum(unsigned r) {\n\t\tType ret = 0;\n\t\twhile (r > 0) {\n\t\t\tret += v[r];\n\t\t\tr -= r & (-r);\n\t\t}\n\t\treturn ret;\n\t}\npublic:\n\tBIT() {};\n\tBIT(unsigned size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(unsigned i, Type x) {\n\t\ti++;\n\t\twhile (i <= size_) {\n\t\t\tv[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tinline Type sum(unsigned l, unsigned r) {\n\t\treturn sum(r) - sum(l);\n\t}\n\tbool operator[](unsigned x) {\n\t\treturn sum(x, x + 1);\n\t}\n};\n\n#endif\n\n#include <map>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint A, B, M;\nint main() {\n\twhile (cin >> A >> B >> M, A) {\n\t\tvector<string> v(B - A + 1);\n\t\tfor (int i = A; i <= B; i++) v[i - A] = to_string(i);\n\t\tsort(v.begin(), v.end());\n\t\tmap<int, int> pos;\n\t\tfor (int i = 0; i < v.size(); i++) pos[stoi(v[i])] = i;\n\t\tBIT<long long> Q(B - A + 1);\n\t\tfor (int i = A; i <= B; i++) Q.add(pos[i], (Q.sum(0, pos[i]) + 1) % M);\n\t\tcout << Q.sum(0, B - A + 1) % M << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline ll rten(ll x){\n  ll r = 1;\n  while (r * 10 <= x) r *= 10;\n  return r;\n}\n\nll sum[100100];\n\nint main()\n{\n  ll A, B, P;\n  while (cin >> A >> B >> P, A){\n    memset(sum, 0, sizeof(sum));\n    sum[1] = 1;\n    for (ll x = A + 1; x <= B; x++){\n      ll s = (sum[x - A] + P - sum[max(rten(x) - A, 0ll)] + 1) % P;\n      for (ll y = x / 10; y >= A; y /= 10){\n        s += sum[y - A + 1] + P - sum[max(rten(y) - A, 0ll)];\n        s %= P;\n      }\n      sum[x - A + 1] = sum[x - A] + s;\n      sum[x - A + 1] %= P;\n    }\n    cout << sum[B - A + 1] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint bit[100100];\nint N, P;\n\nvoid add(int k, int x)\n{\n    for (; k <= N + 1; k += k & -k){\n        bit[k] = (bit[k] + x) % P;\n    }\n}\n\nint sum(int k)\n{\n    int ret = 0;\n    for (; k; k &= (k - 1)){\n        ret = (ret + bit[k]) % P;\n    }\n    return (ret);\n}\n\nbool radix(int a, int b)\n{\n    return (to_string(a) < to_string(b));\n}\n\nint main()\n{\n    int A, B;\n    int v[100000];\n\n    while (scanf(\"%d %d %d\", &A, &B, &P) && A){\n       memset(bit, 0, sizeof(bit));\n       N = B - A + 1;\n       add(N + 1, 1);\n\n       for (int i = 0; i < N; i++){\n           v[i] = A + i;\n        }\n\n       sort(v, v + N, radix);\n\n       for (int i = N - 1; i >= 0; i--){\n           int nv = (sum(N + 1) - sum(v[i] - A) + P) % P;\n           add(v[i] - A + 1, nv);\n       }\n\n       printf(\"%d\\n\", sum(N));\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nll mod;\n\n\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        //x = y;\n        x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        //return x*y;\n        return (x+y)%mod;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\nvoid solve(ll a,ll b){\n    cin>>mod;\n    SegmentTree<ll> sg(101010,0);\n    for(ll i=0;i<=b-a;++i){\n        ll cur=a+i;\n        ll ret=0;\n        while(cur){\n            if(cur<a)break;\n            ll d=1;\n            while(d<=cur)d*=10;\n            d/=10;\n            d=max(d,a);\n            ret+=sg.get(d-a, cur-a+1);\n            cur/=10;\n        }\n        ++ret;\n        sg.update(i,ret);\n    }\n    cout<<sg.get(0,101010)<<endl;\n}\nint main(){\n    ll a,b;\n    while(cin>>a>>b,a!=0)solve(a,b);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nll mod;\nvi sum;\n\n// [l, r)\ninline ll calc(int l, int r){\n    return SUB(sum[l], sum[r], mod);\n}\n\nint main(void){\n    for(ll a, b; cin >> a >> b >> mod, a;){\n        ll n = b - a;\n        vi dp(n + 1);\n        sum = vi(n + 2);\n\n        dp[n] = sum[n] = 1 % mod;\n        rrep(i, n){\n            ll ca = a + i;\n            ll upper = 1;\n            while(upper <= ca) upper *= 10;\n\n            dp[i] = 1;\n\n            ll p = 1;\n            rep(loop, 10){\n                if(loop != 0) p *= 10;\n\n                if(ca % (p * 10) / p == 9 or ca / p == 0) continue;\n                ll na = (ca + p) / p * p;\n                ll nb = (ca + 10 * p) / (10 * p) * (10 * p);\n\n                if(na > b) continue;\n                na -= a; nb -= a;\n                chmin(nb, n + 1);\n\n                dp[i] = ADD(dp[i], calc(na, nb), mod);\n            }\n\n            p = 10;\n            rep(loop, 10){\n                ll na = ca * p;\n                ll nb = upper * p;\n\n                if(na > b) continue;\n                na -= a; nb -= a;\n                chmin(nb, n + 1);\n\n                dp[i] = ADD(dp[i], calc(na, nb), mod);\n\n                p *= 10;\n            }\n\n            sum[i] = ADD(sum[i + 1], dp[i], mod);\n        }\n\n        cout << sum[0] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0, loop##i = (int)(n); i < loop##i; ++i)\n#define FORE(x, c) for (auto &x : c)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) ((int)(x.size()))\n\n#define dump(x) cerr << #x << \": \" << x << endl\n\ntemplate <class T>\nbool chmin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate <class T>\nbool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\n\nsigned main() {\n\twhile (1) {\n\t\tint A, B, P;\n\t\tcin >> A >> B >> P;\n\t\tif (A == 0 && B == 0 && P == 0) break;\n\t\t\n\t\tint N = B - A;\n\t\tvector<int> dp(N + 2, 0);\n\t\tvector<int> add(N + 2, 0);\n\t\tfor (int i = 0; i <= N; ++i) {\n\t\t\tif (i > 0) (add[i] += add[i - 1]) %= P;\n\t\t\t(dp[i] += add[i] + 1) %= P;\n\n\t\t\tint len = SZ(to_string(i + A));\t\n\t\t\tint R = 1;\n\t\t\tREP(i, len) R *= 10;\n\t\t\tR--;\n\t\t\tR = min(R, B);\n\t\t\tint L = i + A;\n\n\t\t\tif (L > R) continue;\n\t\t\tfor (int j = 0; j < 10; ++j) {\n\t\t\t\tif (max(i + A + 1, L) > B) break;\n\t\t\t\t(add[max(i + A + 1, L) - A] += dp[i]) %= P;\n\t\t\t\tadd[R - A + 1] = (add[R - A + 1] - dp[i] + P) % P;\n\t\t\t\tif (R >= B) break;\n\t\t\t\tL *= 10;\n\t\t\t\tR *= 10;\n\t\t\t\tR += 9;\n\t\t\t\tR = min(R, B);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i <= N; ++i) {\n\t\t\tans += dp[i];\n\t\t  \tans %= P;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int MAX_N = 200000;\n\ntemplate <typename T>\nclass BIT{\n\tprivate:\n\t\tvector<T> bit; //[1, n]\n\tpublic:\n\t\tBIT(){\n\t\t\tbit = vector<T>(MAX_N + 1, 0);\n\t\t}\n\t\tT sum(int i, long long m){\n\t\t\tif(i == 0) return 0;\n\t\t\tassert(1 <= i and i <= MAX_N and \"invalid argument\");\n\t\t\tT s = 0;\n\t\t\twhile(i > 0){\n\t\t\t\t(s += bit[i]) %= m;\n\t\t\t\ti -= i & -i;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tvoid add(int i, int x, long long m){\n\t\t\tassert(1 <= i and i <= MAX_N and \"invalid argument\");\n\t\t\twhile(i <= MAX_N){\n\t\t\t\t(bit[i] += x) %= m;\n\t\t\t\t//bit[i] = max(bit[i], x);\n\t\t\t\ti += i & - i;\n\t\t\t}\n\t\t}\n};\n\nint main(){\n\tlong long a, b, m;\n\twhile(cin >> a >> b >> m, a||b||m){\n\t\tvector<pair<string, int>> p;\n\t\trange(i,a,b + 1){\n\t\t\tp.emplace_back(to_string(i), i - a);\n\t\t}\n\t\tsort(all(p));\n\n\t\tvector<int> ma(p.size());\n\t\trep(i,p.size()){\n\t\t\tma[ p[i].second ] = i;\n\t\t}\n\n\t\t//cout << ma << endl;\n\n\t\tBIT<long long> bit;\n\t\tlong long ans = 0;\n\t\tfor(int i = b; i >= a; i--){\n\t\t\tlong long t = (bit.sum(MAX_N, m) - bit.sum( ma[i - a] , m) + m) % m + 1;\n\t\t\tt %= m;\n\t\t\t(ans += t) %= m;\n\t\t\tbit.add(ma[i - a] + 1, t, m);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stdlib.h>\n\nusing namespace std;\n\nint A, B, P, N;\nvector<string> vecS;\nvector<int> vec;\nint dp[100005];\n\nint bit[100005];\n\nvoid init(){\n\tfor(int i = 1; i <= N; i++) bit[i] = 0;\n}\n\nint query(int i)\n{\n\tint sum = 0;\n\twhile(i > 0){\n\t\tsum += bit[i];\n\t\tsum %= P;\n\t\ti -= i&(-i);\n\t}\n\treturn sum;\n}\n\nvoid add(int i, int val)\n{\n\twhile(i <= N){\n\t\tbit[i] += val;\n\t\tbit[i] %= P;\n\t\ti += i&(-i);\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> A >> B >> P;\n\t\tif(A == 0 && B == 0 && P == 0) break;\n\t\t\n\t\tvecS.clear();\n\t\tfor(int i = A; i <= B; i++){\n\t\t\tvecS.push_back( to_string(i) );\n\t\t}\n\t\tsort(vecS.begin(), vecS.end());\n\t\t\n\t\tvec.clear();\n\t\tfor(int i = 0; i < vecS.size(); i++){\n\t\t\tvec.push_back( atoi(vecS[i].c_str()) );\n\t\t}\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tvec[i] -= (A-1);\n\t\t}\n\t\tN = B - A + 1;\n\t\t\n\t\tinit();\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tdp[i] = query(vec[i]) + 1;\n\t\t\tadd(vec[i], dp[i]);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tans += dp[i];\n\t\t\tans %= P;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nint bottom(int n){\n    int res = 1;\n    while(res * 10 <= n){\n        res *= 10;\n    }\n    return res;\n}\n\nint slow(int A, int B, int P){\n    map<int, int> dp;\n    map<int, int> sum[12];\n    int ans = 0;\n    for(int i = A; i <= B; i++){\n        dp[i] = 1;\n        dp[i] = (dp[i] + sum[ to_string(i).size() ][i - 1]) % P;\n        for(int k = i / 10; k > 0; k /= 10){\n            dp[i] = (dp[i] + sum[to_string(k).size()][k]) % P;\n        }\n        sum[to_string(i).size()][i] = (sum[ to_string(i).size() ][i - 1] + dp[i]) % P;\n        ans = (ans + dp[i]) % P;\n    }\n    return ans;\n}\nint main(){\n    LL A, B, P;\n    while(cin >> A >> B >> P && A > 0){\n        const int N = B - A + 1;\n        // [A, border - 1], [border, border * 10 - 1], ... [border * 10^n, B] \n        LL border = 10;\n        while(border - 1 < A){\n            border *= 10;\n        }\n        if(border > B){\n            LL ans = 1;\n            REP(i, N) ans = ans * 2 % P;\n            cout << (ans + P - 1) % P << endl;\n        }else if(B < 10 * A){\n            const int N1 = border - A;\n            const int N2 = B - border + 1;\n            LL ans1 = 1, ans2 = 1;\n            REP(i, N1) ans1 = ans1 * 2 % P;\n            REP(i, N2) ans2 = ans2 * 2 % P;\n            cout << (ans1 + ans2 + P - 2) % P << endl;\n        }else{\n            cout << slow(A, B, P) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\ntemplate <class T>\nclass BIT\n{\npublic:\n    vector<T> a;\n    int n;\n    BIT(int n) : n(n), a(n + 1) {}\n    BIT() { }\n\n    void add(int i, T x)\n    {\n        ++i;\n        assert(i > 0);\n\n        while (i <= n)\n        {\n            a[i] += x;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    T sum(int i) const\n    {\n        ++i;\n        T res = 0;\n        while (i > 0)\n        {\n            res += a[i];\n            i -= i & -i;\n        }\n        return res;\n    }\n\n    T range_sum(int low, int high) const { return sum(high) - sum(low - 1); }\n    T at(int i) const { return sum(i) - sum(i - 1); }\n    void assign(int i, T x) { add(i, x - at(i)); }\n};\nint main()\n{\n    ll a, b, p;\n    while (cin >> a >> b >> p, p)\n    {\n        vector<string> s;\n        for (ll i = a; i <= b; ++i)\n            s.pb(to_s(i));\n        sort(all(s));\n\n        BIT<ll> dp(b - a + 10);\n        rep(i, s.size())\n        {\n            int k = to_T<ll>(s[i]) - a;\n            dp.add(k, (1 + dp.sum(k)) % p);\n        }\n        cout << dp.sum(dp.n - 1) % p << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nll A, B, mod;\nll toll(string str) {\n\tstringstream ss; ss << str;\n\tll res; ss >> res;\n\treturn res;\n}\nstring toS(ll n) {\n\tstringstream ss; ss << n;\n\tstring res; ss >> res;\n\treturn res;\n}\n\nll add(ll a, ll b) {\n\treturn (a + b) % mod;\n}\nll mul(ll a, ll b) {\n\treturn a * b % mod;\n}\nmap<ll, ll> m;\nll dp(string nstr) {\n\tll n = toll(nstr);\n\tif (n > B) return 0;\n\tif (m.count(n)) return m[n];\n\tll res = 1;\n\tint lastDigit = nstr[nstr.size()-1]-'0';\n\tFOR(i, lastDigit+1, 10) { // change last digit\n\t\tstring nnstr = nstr; nnstr[nnstr.size()-1] = i+'0';\n\t\tres = add(res, dp(nnstr));\n\t}\n\tREP(i, 10) {\n\t\tstring nnstr = nstr; nnstr += i+'0';\n\t\tres = add(res, dp(nnstr));\n\t}\n\treturn m[n] = res;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile ( cin >> A >> B >> mod, A || B || mod ) {\n\t\tll ans = 0;\n\t\tFOR(i, A, B+1) {\n\t\t\tans = add(ans, dp(toS(i)));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int LLI;\nLLI A;\nLLI B;\nLLI P;\nLLI N;\nLLI BIT[114514];\nLLI ten[114];\n\nvoid add(LLI k, LLI x) {\n  k -= A;\n  k++;\n  while (k <= N) {\n    BIT[k] += x;\n    BIT[k] %= P;\n    k += k&-k;\n  }\n}\n\nLLI getsum(LLI k) {\n  LLI ret = 0;\n  k -= A;\n  k++;\n  while (k > 0) {\n    ret += BIT[k];\n    ret %= P;\n    k -= k&-k;\n  }\n  return ret;\n}\n\nint main() {\n  ten[0] = 1;\n  for (int i=1; i<14; i++) {\n    ten[i] = ten[i-1]*10;\n  }\n\n  while (1) {\n    scanf(\"%lld%lld%lld\", &A, &B, &P);\n    if ((A|B|P) == 0) return 0;\n\n    N = B-A+1;\n    fill(BIT, BIT+N+10, 0);\n    LLI ans = 0;\n    for (LLI k=A; k<=B; k++) {\n      add(k, 1);\n      add(k+1, -1);\n      LLI dpk = getsum(k);\n      //printf(\"dp[%lld]: %lld\\n\", k, dpk);\n      ans += dpk;\n      ans %= P;\n\n      LLI k_ = k;\n      int d = 0;\n      while (k_ > 0) {\n        k_ /= 10;\n        d++;\n      }\n      \n      for (LLI i=0; ; i++) {\n        LLI lim = min(ten[d+i]-1, B);\n        add(k*ten[i], dpk);\n        add(lim+1, -dpk);\n        if (lim >= B) break;\n      }\n    }\n\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\nconst int MAX_N=200001;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\n\nll A,B,P;\n// 1baseでs1,...,snの和を計算\nclass BIT{\nprivate:\n  ll bit[MAX_N];\n  int n;\npublic:\n  BIT(int sz){\n    n=sz;\n    memset(bit,0,sizeof(bit));\n  }\n  ll sum(int i){\n    ll s=0;\n    while(i>0){\n      s+=bit[i];\n      s%=P;\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(int i,ll x){\n    while(i<=n){\n      bit[i]+=x;\n      bit[i]%=P;\n      i+=i&-i;\n    }\n  }\n};\n\nll dp[MAX_N];\nint main(){\n  while(cin>>A>>B>>P&&(A|B|P)){\n    memset(dp,0,sizeof(dp));\n    vector<pair<string,ll> > v;\n    for(ll i=A;i<=B;i++){\n      stringstream ss;\n      ss<<i;\n      v.push_back(make_pair(ss.str(),i));\n    }\n    sort(v.begin(),v.end());\n    BIT bit(B-A+1);\n    // 辞書順で小さいものから順番に計算\n    for(int i=0;i<v.size();i++){\n      ll curNum=v[i].second;\n      // 今回の数字以下のものの和を計算\n      dp[i]=(bit.sum(curNum-A+1)+1)%P;\n      bit.add(curNum-A+1,dp[i]);\n    }\n    ll res=0;\n    for(int i=0;i<v.size();i++)\n      res=(res+dp[i])%P;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint bit[100100];\nint N, P;\n\nvoid add(int k, int x)\n{\n    for (; k <= N + 1; k += k & -k){\n        bit[k] = (bit[k] + x) % P;\n    }\n}\n\nint sum(int k)\n{\n    int ret = 0;\n    for (; k; k &= (k - 1)){\n        ret = (ret + bit[k]) % P;\n    }\n    return (ret);\n}\n\nint main()\n{\n    int A, B;\n    string v[100000];\n\n    while (scanf(\"%d %d %d\", &A, &B, &P) && A){\n        memset(bit, 0, sizeof(bit));\n        N = B - A + 1;\n        add(N + 1, 1);\n        \n        for (int i = 0; i < N; i++){\n            v[i] = to_string(A + i);\n        }\n\n        sort(v, v + N);\n\n        for (int i = N - 1; i >= 0; i--){\n            int pos = stoi(v[i]) - A;\n            int nv = (sum(N + 1) - sum(pos) + P) % P;\n            add(pos + 1, nv);\n        }\n\n       printf(\"%d\\n\", sum(N));\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T, int COUNT>\nclass BinaryIndexedTree {\nprivate:\n\tT m_data[COUNT + 1];\npublic:\n\tBinaryIndexedTree(){\n\t\tfill(m_data, m_data + COUNT + 1, T());\n\t}\n\tT sum(int i){\n\t\tT s = T();\n\t\twhile(i > 0){\n\t\t\ts += m_data[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int i, const T &x){\n\t\twhile(i <= COUNT){\n\t\t\tm_data[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\n\n\nstruct LexicalCompare {\n\tbool operator()(ll a, ll b) const {\n\t\tchar abuf[16] = { 0 }, bbuf[16] = { 0 };\n\t\tint alen = 0, blen = 0;\n\t\twhile(a > 0){ abuf[alen++] = '0' + (a % 10); a /= 10; }\n\t\twhile(b > 0){ bbuf[blen++] = '0' + (b % 10); b /= 10; }\n\t\treverse(abuf, abuf + alen);\n\t\treverse(bbuf, bbuf + blen);\n\t\tfor(int i = 0; i < 16; ++i){\n\t\t\tif(abuf[i] < bbuf[i]){ return true; }\n\t\t\tif(abuf[i] > bbuf[i]){ return false; }\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tll A, B, P;\n\t\tcin >> A >> B >> P;\n\t\tif(A == 0 && B == 0 && P == 0){ break; }\n\t\tvector<ll> lexical_order(B - A + 1);\n\t\tfor(ll i = A; i <= B; ++i){ lexical_order[i - A] = i; }\n\t\tsort(lexical_order.begin(), lexical_order.end(), LexicalCompare());\n\t\tint N = lexical_order.size();\n\t\tBinaryIndexedTree<ll, 100001> bit;\n\t\tvector<ll> dp(N);\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tdp[i] = (bit.sum(lexical_order[i] - A) + 1) % P;\n\t\t\tbit.add(lexical_order[i] - A + 1, dp[i]);\n\t\t}\n\t\tll answer = accumulate(dp.begin(), dp.end(), 0ll) % P;\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint a, b; ll p;\nint ten[10];\nll solve(){\n\tif(a==b) return 1;\n\tll dp[100002];\n\tfill(dp+1, dp+(b-a)+2, 1);\n\tll s[100002];\n\ts[0]=0; s[1]=1;\n\tint ind[100002]; ind[1]=1;\n\tfor(int i=2; i<=b-a+1; i++){\n\t\tif(*lower_bound(ten, ten+10, a-1+i)==a-1+i){\n\t\t\tind[i]=i;\n\t\t}else{\n\t\t\tind[i]=ind[i-1];\n\t\t}\n\t\tint x=a-1+i;\n\t\tdp[i]+=(s[i-1]-s[ind[i]-1]+p); dp[i]%=p;\n\t\twhile(1){\n\t\t\tx/=10;\n\t\t\tif(x<a) break;\n\t\t\tdp[i]+=(s[x-a+1]-s[ind[x-a+1]-1]+p); dp[i]%=p;\n\t\t}\n\t\ts[i]=(s[i-1]+dp[i])%p;\n\t}\n\treturn s[b-a+1];\n}\nint main()\n{\n\tten[0]=1; for(int i=1; i<10; i++) ten[i]=ten[i-1]*10;\n\twhile(1){\n\t\tcin>>a>>b>>p;\n\t\tif(a==0) return 0;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\n\nconst int limit=100010;\nll bit[limit];\n\nvoid add(ll i,ll x,ll n,ll p){\n\tfor(i++;i<=n;i+=i&-i)\n\t\tbit[i]+=x,bit[i]%=p;\n}\n\nll sum(ll i,ll n,ll p){\n\tll ret=0LL;\n\tfor(i++;i>0;i-=i&-i)\n\t\tret+=bit[i],ret%=p;\n\treturn ret;\n}\n\n\nint main(void){\n\tll a,b,p;\n\twhile(cin >> a >> b >> p,p){\n\t\tconst ll n=b-a+1;\n\t\tclr(bit,0);\n\n\t\tusing state=tuple<string,int>;\n\t\tvector<state> ary;\n\t\trep(i,n) ary.push_back(state(to_string(a+i),i));\n\t\tsort(_all(ary));\n\t\tll ans=0LL;\n\n\t\tfor(auto &event:ary){\n\t\t\tint idx;\n\t\t\ttie(ignore,idx)=event;\n\t\t\tll cur=(sum(idx,n,p)+1)%p;\n\t\t\tans=(ans+cur)%p;\n\t\t\tadd(idx,cur,n,p);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>\nclass Fenwick{\npublic:\n  vector<T> data;\n  int n;\n  Fenwick(){};\n  Fenwick(int tn){\n    data.resize(tn,0);\n    n = tn;\n  }\n  T read(int idx,int tidx,ll mod){\n    T sum = 0;\n    if (idx == 0){\n      while(tidx > 0){\n\tsum=(sum+data[tidx])%mod;\n\ttidx-=(tidx&-tidx);\n      }\n      return sum;\n    }else return (read(0,tidx,mod)-read(0,idx-1,mod)+mod)%mod;\n  }\n  void update(int idx,T val,ll mod){\n    while(idx <= n){\n      data[idx]=(data[idx]+val)%mod;\n      idx+=(idx & -idx);\n    }\n  }\n};\n\nmain(){\n  ll a,b,p;\n  while(cin>>a>>b>>p && p){\n    Fenwick<ll> dp(100002);\n    vector<int> num(b-a+2);\n    vector<string> all;\n    for(ll i=a;i<=b;i++){\n      string tmp=\"\";\n      ll now = i;\n      while(now)tmp=tmp+string(1,'0'+now%10),now/=10;\n      reverse(tmp.begin(),tmp.end());\n      all.push_back(tmp);\n    }\n    sort(all.begin(),all.end());\n    for(int i=0;i<all.size();i++){\n      ll tmp = atoi(all[i].c_str());\n      num[tmp-a]=i+1;\n    }\n\n    for(ll i=a;i <= b;i++){\n      int now = num[i-a];\n      ll tmp = (dp.read(0,now-1,p)+1)%p;//+1 is itself\n      dp.update(now,tmp,p);\n    }\n    cout << dp.read(0,b-a+1,p) << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\ntypedef long long ll;\n\nstring itos(int x){\n  string res;\n  while(x)res+=x%10+'0',x/=10;\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nll dp[N][11];\n\nint main(){\n\n  while(1){\n    \n    ll a,b,p;\n\n    cin>>a>>b>>p;\n\n    if(!a&&!b&&!p) break;\n    \n    vector<string> v;\n  \n    for(int i=a;i<=b;i++) v.push_back(itos(i));\n  \n    ll n=b-a+1;\n  \n    sort(v.begin(),v.end());\n  \n    v.push_back(\"\");\n  \n    memset(dp,0,sizeof(dp));\n  \n    for(int i=0;i<n;i++) dp[i][v[i].size()]=1;\n  \n    for(int i=0;i<n;i++){\n    \n      ll A=0;\n      for(int j=0;j<v[i].size();j++) A=(A+dp[i][j])%p;\n      dp[i][v[i].size()]=(dp[i][v[i].size()]+A)%p;\n    \n      for(int j=0;j<11;j++){\n      \n\tif(v[i+1].size()==j) dp[i+1][j]=(dp[i+1][j]+(dp[i][j]*2)%p)%p;\n\telse dp[i+1][j]=(dp[i+1][j]+dp[i][j])%p;\n      \n      }\n    \n    }\n  \n    ll ans=0;\n  \n    for(int i=0;i<11;i++) ans=(ans+dp[n][i])%p;\n  \n    cout<<ans<<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct node{\n    int val,sum;\n    node *to[10];\n\n    node(){\n        val=sum=0;\n        rep(i,10)to[i]=NULL;\n    }\n};\n\nint A,B,P;\n\nvoid insert(node *t,string &s,int i,int v){\n    if(i==s.size()){\n        t->val=v;\n        t->sum=(t->sum+v)%P;\n        return;\n    }\n\n    int c=s[i]-'0';\n    if(t->to[c]==NULL){\n        t->to[c]=new node();\n    }\n    t->sum=(t->sum-t->to[c]->sum+P)%P;\n    insert(t->to[c],s,i+1,v);\n    t->sum=(t->sum+t->to[c]->sum)%P;\n}\n\nint query(node *t,string &s,int i){\n    int ret=0;\n    int c=s[i]-'0';\n    for(int j=0;j<c;j++)if(t->to[j]!=NULL)ret=(ret+t->to[j]->sum)%P;\n    ret=(ret+t->val)%P;\n    if(t->to[c]!=NULL)ret=(ret+query(t->to[c],s,i+1))%P;\n    return ret;\n}\n\nsigned main(){\n    while(cin>>A>>B>>P,A||B||P){\n        int ans=0;\n        node *root=new node();\n        for(int i=A;i<=B;i++){\n            stringstream ss;\n            ss<<i;\n            string s=ss.str();\n            int tmp=(query(root,s,0)+1)%P;\n            ans=(ans+tmp)%P;\n            insert(root,s,0,tmp);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\n\n// ????????????T, ?????????T0, ???????????????op????????????????????????\n// ?????´??°op???O(log n)???0-index?????????sum(int j)???O(log n)??§??????\n// ??????op???????????????????????§??????????????°???i-index?????????sum(int i, int j)??????????????????\n\n// 0-indexed, sum????????????????????§??¨?????????\n\nvoid printBit(int a) {cout << a << \" \"; for(; a > 0; a >>= 1) cout << (a & 1); cout << \"#bit\" << endl;}\ntemplate <class T>\nstruct fenwick_tree {\n    /**********************/\n    // ????£???????\n    /**********************/\n    T T0 = 0;\n    T op(T a, T b) { return a + b; }\n    /**********************/\n    // ????£??????????\n    /**********************/\n\n    // x?????????????§???????op=+, invop=1, T=int, T0=0?????´???\n    // i????????????????????°?????????s[i]??¨?????????x[i] = s[i]????????? (???: i=5, s[i]=\"45\", x[i]=9)\n    // 0123456789ABCDEF\n    // 01234567--------\n    // 0123----89AB----\n    // 01--23--89--CD--\n    // 0-2-4-6-8-A-C-E-\n    int n_org;\n    vector<T> x;\n    fenwick_tree(int n_)  { \n        n_org = n_;\n        int n = 1; while (n <= n_) n *= 2;\n        x = vector<T>(n, T0);\n    }\n\n    // ???????????¨???: [0, j]???reduce??????????????????????????¨???\n    // O(log n)\n    T query(int j) {\n        if (j < 0)\n            return T0;\n        T S = T0;\n        for (; j >= 0; j = (j & (j + 1)) - 1)  // j??????C->B->7??¨????§??????????0??????C?????????????????????????????°???????????????????£???¶\n            S = op(S, x[j]); \n        return S;\n    }\n\n    // ??´??°?????¨???: #k???a????????????????????????\n    // O(log n)\n    void update(int k, T a) {\n        if (k < 0)\n            return;\n        for (; k < x.size(); k |= k+1) // k??????C->D->F??¨????§??????????C????????????????????°????????¨???????£???¶\n            x[k] = op(x[k], a); \n    }\n\n    // #k?????¢???????????????\n    // O(log n)\n    T access(int k) {\n        return query(k) - (k ? query(k-1) : 0);\n    }\n    void print(void) {\n        for (int i = 0; i < n_org; i++) \n            cout << access(i) << \" \";\n        cout << endl;\n    }\n    void print_raw(void) {\n        for (int i = 0; i < x.size(); i++) \n            cout << x[i] << \" \";\n        cout << endl;\n    }\n};\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll a, b, mo;\n    while (cin >> a >> b >> mo && a && b && mo) {\n        ll n = b - a + 1;\n        vector<string> w(n); rep(i, n) w[i] = to_string(a+i);\n        sort(all(w));\n        vll lex(n); rep(i, n) lex[i] = stoi(w[i]) - a;\n\n        fenwick_tree<ll> dp(n);\n        rep(i, n) \n            dp.update(lex[i], (dp.query(lex[i]-1)+1)%mo);\n        \n        cout << dp.query(n-1) % mo << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\n\nll a,b,p;\n\nll calc(ll x){\n    return x-a;\n}\n\nll calc2(ll x){\n    ll y = 1;\n    for(int i=0;i<20;i++){\n        if(y>x){\n            break;\n        }\n        y *= 10;\n    }\n    return y;\n}\n\nint main(){\n    while(cin >> a >> b >> p&&a!=0){\n        vector<ll> dp(b-a+2);\n        dp[b-a] = 1;\n        for(ll i=b-1;i>=a;i--){\n            dp[i-a] = 1;\n            ll z = min(b+1,calc2(i));\n            dp[i-a] = (dp[i-a]+dp[i-a+1])%p;\n            dp[i-a] = (dp[i-a]+p-dp[z-a])%p;            \n            ll x = i;\n            for(int j=1;j<20;j++){\n                x*=10;\n                if(x>b)break;\n                ll y = min(b+1,calc2(x));\n                dp[i-a] = (dp[i-a]+dp[x-a])%p;\n                dp[i-a] = (dp[i-a]+p-dp[y-a])%p;\n            }\n            dp[i-a] = (dp[i-a]+dp[i-a+1])%p;\n        }\n        cout << dp[0]%p << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint p;\nstruct StarrySky{\n  int n;\n  const int def=1;\n  vector<int> datm,data;\n  StarrySky(){}\n  StarrySky(int n_){init(n_);}\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    datm.clear();\n    datm.resize(n*2-1,def);\n    data.clear();\n    data.resize(n*2-1,0);\n  }\n  void add(int a,int b,int x,int k,int l,int r){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      (data[k]+=x)%=p;\n      return;\n    }\n    add(a,b,x,k*2+1,l,(l+r)/2);\n    add(a,b,x,k*2+2,(l+r)/2,r);\n    datm[k]=max(datm[k*2+1]+data[k*2+1],datm[k*2+2]+data[k*2+2]);\n  }\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return def;\n    if(a<=l&&r<=b) return datm[k]+data[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr)+data[k];\n  }\n  void add(int a,int b,int x){\n    add(a,b,x,0,0,n);\n  }\n  int query(int a,int b){\n    return query(a,b,0,0,n)%p;\n  }\n};\nsigned main(){\n  int a,b;\n  while(cin>>a>>b>>p,a||b||p){\n    int n=b-a+1;\n    //cout<<n<<endl;\n    StarrySky ss(n);\n    vector<string> vs(n);\n    for(int i=0;i<n;i++) vs[i]=to_string(a+i);\n    sort(vs.begin(),vs.end());\n    map<string,int> ms;\n    for(int i=0;i<n;i++) ms[vs[i]]=i;\n    int ans=0;\n    for(int i=0;i<n;i++){\n      int k=ms[to_string(a+i)];\n      int x=ss.query(k,k+1);\n      ss.add(k+1,n,x);\n      //cout<<a+i<<\" \"<<k<<\":\"<<x<<endl;\n      (ans+=x)%=p;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n/*\nverified on 2017/02/24\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_E\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a + b.num); }\nMod operator+(const Mod a, const long long int  b) { return b+a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a*b.num); }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tMod sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tMod lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tint adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\tint keta= (to_string(now).size());\n\t\t\twhile (1) {\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = now * 10;\n\t\t\t\tketa++;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass BIT {\nprivate:\n\tint size;\n\tvector<int> bit;\n\tint mod;\n\npublic:\n\tBIT(int n, int m):size(n), bit(n + 1, 0), mod(m) {}\n\n\tvoid add(int i, int x) {\n\t\twhile(i <= size) {\n\t\t\tbit[i] += x;\n\t\t\tbit[i] %= mod;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\n\tint sum(int i) const {\n\t\tlong long s = 0;\n\t\twhile(i > 0) {\n\t\t\ts += bit[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s % mod;\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int a, b, p; cin >> a >> b >> p && a;) {\n\t\tconst int num = b - a + 2;\n\n\t\tvector<string> order;\n\t\torder.reserve(num);\n\n\t\tfor(int i = a; i <= b; ++i) {\n\t\t\torder.emplace_back(to_string(i));\n\t\t}\n\n\t\tsort(order.begin(), order.end());\n\n\t\tBIT bit(num, p);\n\t\tbit.add(1, 1);\n\n\t\tfor(const auto &s : order) {\n\t\t\tconst int index = stoi(s) - a + 2;\n\t\t\tconst auto tmp = bit.sum(index - 1);\n\t\t\tbit.add(index, tmp);\n\t\t}\n\n\t\tcout << (bit.sum(num) - 1 + p) % p << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nint MOD;\nclass BIT{\n\tpublic:\n\t//[1,i]\n\tint n;\n\tvi bit;\n//\tint bit[MAZ_N+1];\n\tBIT(int size){\n\t\tn=size;\n\t\tbit=vi(n+1);\n\t}\n\tDef query(int i){//sum\n\t\tDef s=0;\n\t\twhile(i>0){\n\t\t\t(s+=bit[i])%=MOD;\n\t\t\ti-=i&-i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int i,Def x){\n\t\twhile(i<=n){\n\t\t\t(bit[i]+=x)%=MOD;\n\t\t\ti+=i&-i;\n\t\t}\n\t}\n};\nint stolong(string s){\n\tint a=0;\n\trep(i,s.size()){\n\t\ta*=10;\n\t\ta+=s[i]-'0';\n\t}\n\treturn a;\n}\nsigned main(){\n\tint l,r;\n\twhile(cin>>l>>r>>MOD,l){\n\t\tint sa=r-l+1;\n\t\tBIT bit(sa);\n\t\trep(i,sa){\n\t\t\tint t=l+i;\n\t\t\tint sum=1;\n\t\t\tint w=t;\n\t\t\twhile(w){\n\t\t\t\tstring q=to_string(w);\n\t\t\t\tstring s=\"1\"+string(q.size()-1,'0');\n\t\t\t\tint ne=stolong(s);\n\t\t\t\tif(w<l)break;\n\t\t\t\t(sum+=bit.query(w-l+1)-bit.query(max(l,ne)-l)+MOD)%=MOD;\n\t\t\t\tw/=10;\n\t\t\t}\n//\t\t\tcout<<i<<\" \"<<t<<\" \"<<sum<<endl;\n\t\t\tbit.add(i+1,sum);\n\t\t}\n\t\tcout<<bit.query(sa)<<endl;\n\t\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long A, B, P, sum[100002];\n\nvoid add(int k, int x)\n{\n  for(++k; k < 100002; k += k & -k) (sum[k] += x) %= P;\n}\nint query(int k)\n{\n  int ret = 0;\n  for(++k; k > 0; k -= k & -k) (ret += sum[k]) %= P;\n  return(ret);\n}\n\nint main()\n{\n  while(cin >> A >> B >> P, A) {\n    memset(sum, 0, sizeof(sum));\n    vector< string > d;\n    for(int i = A; i <= B; i++) {\n      stringstream sss; sss << i;\n      d.push_back(sss.str());\n    }\n    sort(d.begin(), d.end());\n    for(int i = 0; i < d.size(); i++) {\n      int val = stoi(d[i]);\n      add(val - A, (query(val - A) + 1) % P);\n    }\n    cout << query(B - A) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint M;\n\ntemplate<class T>\nclass FenwickTree{\n\tvector<T> a;\npublic:\n\tFenwickTree(int n):a(n){}\n\tT sum(int i,int j)const{\n\t\tif(i==0){\n\t\t\tT s=0;\n\t\t\tfor(;j>=0;j=(j&(j+1))-1) s=(s+a[j])%M;\n\t\t\treturn s;\n\t\t}\n\t\treturn ((sum(0,j)-sum(0,i-1))%M+M)%M;\n\t}\n\tvoid add(int i,T v){\n\t\tfor(;i<a.size();i|=i+1) a[i]=(a[i]+v)%M;\n\t}\n};\n\nint ofset;\nchar s[100001][16];\nbool lex(int a,int b){\n\treturn strcmp(s[a-ofset],s[b-ofset])<0;\n}\n\nint main(){\n\tfor(int a,b;scanf(\"%d%d%d\",&a,&b,&M),a;){\n\t\tofset=a;\n\t\tint n=b-a+1,seq[100000];\n\t\trep(i,n){\n\t\t\tseq[i]=a+i;\n\t\t\tsprintf(s[i],\"%d\",a+i);\n\t\t}\n\t\tsort(seq,seq+n,lex);\n\n\t\tFenwickTree<int> F(b-a+1);\n\t\trep(i,n) F.add(seq[i]-a,F.sum(0,seq[i]-a)+1);\n\n\t\tprintf(\"%d\\n\",F.sum(0,n-1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\ntemplate<class T>\nclass Fenwick{\npublic:\n  vector<T> data;\n  int n;\n  Fenwick(){};\n  Fenwick(int tn){\n    data.resize(tn,0);\n    n = tn;\n  }\n  T read(int idx,int tidx,ll mod){\n    T sum = 0;\n    if (idx == 0){\n      while(tidx > 0){\n\tsum=(sum+data[tidx])%mod;\n\ttidx-=(tidx&-tidx);\n      }\n      return sum;\n    }else return (read(0,tidx,mod)-read(0,idx-1,mod)+mod)%mod;\n  }\n  void update(int idx,T val,ll mod){\n    while(idx <= n){\n      data[idx]=(data[idx]+val)%mod;\n      idx+=(idx & -idx);\n    }\n  }\n};\n\nmain(){\n  ll a,b,p;\n  while(cin>>a>>b>>p && p){\n    Fenwick<ll> dp(b+b-a+2);\n    vector<int> num(b-a+1);\n    vector<string> all;\n    for(ll i=a;i<=b;i++){\n      string tmp=\"\";\n      ll now = i;\n      while(now)tmp=tmp+string(1,'0'+now%10),now/=10;\n      reverse(tmp.begin(),tmp.end());\n      all.push_back(tmp);\n    }\n\n    sort(all.begin(),all.end());\n    for(int i=0;i<all.size();i++){\n      ll tmp = 0;\n      for(int j=0;j < all[i].size();j++){\n\ttmp=tmp*10+all[i][j]-'0';\n      }\n      num[tmp-a]=i+1;\n    }\n    for(ll i=a;i <= b;i++){\n      int now = num[i-a];\n      ll tmp = (dp.read(0,now-1,p)+1)%p;//+1 is itself\n      dp.update(now,tmp,p);\n    }\n    cout << dp.read(0,b-a+1,p) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T, int COUNT>\nclass BinaryIndexedTree {\nprivate:\n\tT m_data[COUNT + 1];\npublic:\n\tBinaryIndexedTree(){\n\t\tfill(m_data, m_data + COUNT + 1, T());\n\t}\n\tT sum(int i){\n\t\tT s = T();\n\t\twhile(i > 0){\n\t\t\ts += m_data[i];\n\t\t\ti -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tvoid add(int i, const T &x){\n\t\twhile(i <= COUNT){\n\t\t\tm_data[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n};\n\n\nstruct LexicalCompare {\n\tbool operator()(int a, int b) const {\n\t\tchar abuf[16] = { 0 }, bbuf[16] = { 0 };\n\t\tint alen = 0, blen = 0;\n\t\twhile(a > 0){ abuf[alen++] = '0' + (a % 10); a /= 10; }\n\t\twhile(b > 0){ bbuf[blen++] = '0' + (b % 10); b /= 10; }\n\t\treverse(abuf, abuf + alen);\n\t\treverse(bbuf, bbuf + blen);\n\t\tfor(int i = 0; i < 16; ++i){\n\t\t\tif(abuf[i] < bbuf[i]){ return true; }\n\t\t\tif(abuf[i] > bbuf[i]){ return false; }\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main(){\n\twhile(true){\n\t\tll A, B, P;\n\t\tcin >> A >> B >> P;\n\t\tif(A == 0 && B == 0 && P == 0){ break; }\n\t\tvector<int> lexical_order(B - A + 1);\n\t\tfor(int i = A; i <= B; ++i){ lexical_order[i - A] = i; }\n\t\tsort(lexical_order.begin(), lexical_order.end(), LexicalCompare());\n\t\tint N = lexical_order.size();\n\t\tBinaryIndexedTree<ll, 100001> bit;\n\t\tvector<ll> dp(N);\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tdp[i] = (bit.sum(lexical_order[i] - A) + 1) % P;\n\t\t\tbit.add(lexical_order[i] - A + 1, dp[i]);\n\t\t}\n\t\tll answer = accumulate(dp.begin(), dp.end(), 0ll) % P;\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n\n\nint mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\n#define Seg_Max_N (1<<18) \n// update(l,r,v) := [l,r]の区間に対してvを一様に足す. k,a,bは飾り\n\nstruct NODE {\n\tMod sum;//更新された値. この値を参照する時は評価が完全に完了しているようにする.\n\tMod lazy;\t//遅延されている値を保存している\n\tNODE() {\n\t\tsum = lazy = 0;\n\t}\n};\n\nNODE seg[2 * Seg_Max_N];\n\n// inlineつけないと大変なことになるよ!(遅い)\ninline void lazy_evaluate_node(int k, int a, int b) {\n\tseg[k].sum += seg[k].lazy * (b - a + 1);\n\tif (k < Seg_Max_N) { // 2*k(左の子番号) < 2*N (節点の数) のイメージで. 末端ノードじゃなきゃ伝搬するのと等価.\n\t\tseg[2 * k].lazy += seg[k].lazy;\t//次は君が伝搬してね☆って感じ.\n\t\tseg[2 * k + 1].lazy += seg[k].lazy;\n\t}\n\tseg[k].lazy = 0;\n}\n\ninline void update_node(int k) { // kの子が既に評価されていることが前提. 末端以外のときしか呼び出さないような位置に書くのでif文要らない.\n\tseg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;\n}\n\n// update(l,r,v) := [l,r]を更新する. 区間は1-indexed.\nvoid update(int l, int r, int v, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); \t// とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn;\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\tseg[k].lazy += v;\n\t\tlazy_evaluate_node(k, a, b); //一回遅延評価しとかないと都合悪いので.\n\t\treturn;\n\t}\n\n\tint m = (a + b) / 2;\n\tupdate(l, r, v, 2 * k, a, m);\n\tupdate(l, r, v, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n}\n\n// get(l,r) := [l,r]に対するクエリの答えを得る. 区間は1-indexed.\nint get(int l, int r, int k = 1, int a = 1, int b = Seg_Max_N) {\n\tif (l < 0 || r<0)assert(false);\n\tlazy_evaluate_node(k, a, b); // とりあえず辿ったノードは都合がいいので伝搬しとけ精神.\n\n\tif (b < l || r < a) //[a,b]と[l,r]が交差している場合\n\t\treturn 0;\n\n\tif (l <= a && b <= r) { // [l,r]が[a,b]を完全に含んでいる場合\n\t\treturn seg[k].sum;\n\t}\n\n\tint m = (a + b) / 2;\n\tMod vl = get(l, r, 2 * k, a, m);\n\tMod vr = get(l, r, 2 * k + 1, m + 1, b);\n\tupdate_node(k);\n\treturn vl + vr;\n}\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 2 * Seg_Max_N; ++i) {\n\t\t\tseg[i].lazy = 0;\n\t\t\tseg[i].sum = 0;\n\t\t}\n\t\tlong long int A, B, P; cin >> A >> B >> P;\n\t\tmod = P;\n\t\tupdate(1, B - A+1,1);\n\n\t\tfor (int id = 0; id < B - A; ++id) {\n\t\t\tlong long int num = id + A;\n\t\t\tMod adp = get(id+1, id+1);\n\t\t\tlong long int now = num;\n\t\t\twhile (1) {\n\t\t\t\tint keta = (to_string(now).size());\n\t\t\t\tlong long int amin = now;\n\t\t\t\tlong long int amax = min(powint(10, keta) - 1, B);\n\t\t\t\tif (amin > amax)break;\n\t\t\t\tif (amin == num)amin++;\n\t\t\t\t\n\t\t\t\tupdate(amin-A+1, amax - A+1, adp);\n\t\t\t\tnow = (now) * 10;\n\t\t\t}\n\t\t}\n\t\tMod ans = get(1, B - A + 1);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\n\nll a,b,p;\n\nll calc(ll x){\n    return x-a;\n}\n\nll calc2(ll x){\n    ll y = 1;\n    for(int i=0;i<20;i++){\n        if(y>x){\n            break;\n        }\n        y *= 10;\n    }\n    return y;\n}\n\nint main(){\n    while(cin >> a >> b >> p&&a!=0){\n        vector<ll> dp(b-a+2);\n        dp[b-a] = 1;\n        for(ll i=b-1;i>=a;i--){\n            dp[i-a] = 1;\n            ll z = min(b+1,calc2(i));\n            dp[i-a] = (dp[i-a]+dp[i-a+1])%p;\n            dp[i-a] = (dp[i-a]+p-dp[z-a])%p;            \n            ll x = i;\n            for(int j=1;j<20;j++){\n                x*=10;\n                if(x>b)break;\n                ll y = min(b+1,calc2(x));\n                dp[i-a] = (dp[i-a]+dp[x-a])%p;\n                dp[i-a] = (dp[i-a]+p-dp[y-a])%p;\n            }\n            dp[i-a] = (dp[i-a]+dp[i-a+1])%p;\n        }\n        cout << dp[0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint M;\n\ntemplate<class T>\nclass FenwickTree{\n\tvector<T> a;\npublic:\n\tFenwickTree(int n):a(n){}\n\tT sum(int i,int j)const{\n\t\tif(i==0){\n\t\t\tT s=0;\n\t\t\tfor(;j>=0;j=(j&(j+1))-1) s=(s+a[j])%M;\n\t\t\treturn s;\n\t\t}\n\t\treturn (sum(0,j)-sum(0,i-1)+M)%M;\n\t}\n\tvoid add(int i,T v){\n\t\tfor(;i<a.size();i|=i+1) a[i]=(a[i]+v)%M;\n\t}\n};\n\nint ofset;\nchar s[100001][16];\nbool lex(int a,int b){\n\treturn strcmp(s[a-ofset],s[b-ofset])<0;\n}\n\nint main(){\n\tfor(int a,b;scanf(\"%d%d%d\",&a,&b,&M),a;){\n\t\tint n=b-a+1,seq[100000];\n\t\tofset=a;\n\t\trep(i,n){\n\t\t\tseq[i]=a+i;\n\t\t\tsprintf(s[i],\"%d\",seq[i]);\n\t\t}\n\t\tsort(seq,seq+n,lex);\n\n\t\tFenwickTree<int> F(b-a+1);\n\t\trep(i,n) F.add(seq[i]-a,F.sum(0,seq[i]-a)+1);\n\n\t\tprintf(\"%d\\n\",F.sum(0,n-1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<17;\nll mod;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  RSQ2(int n_){\n    n=1;\n    while(n<n_)n*=2; //????´???°n???2???????????????\n    for(int i=0;i<2*n-1;i++)dat[i]=td[i]=0;\n  }\n  \n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]=(dat[k]+(r-l)*x)%mod; \n      td[k]=(td[k]+x)%mod;\n      return dat[k];\n    }\n\n    dat[k]=(dat[k]+(min(r,b)-max(l,a))*x)%mod;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]=(dat[kl]+t)%mod, dat[kr]=(dat[kr]+t)%mod;\n    td[kl]=(td[kl]+td[k])%mod, td[kr]=(td[kr]+td[k])%mod;\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return (vl+vr)%mod;\n  }\n  \n  ll sum(int a,int b){return add(a,b,0);}\n};\n\nstring i2S(ll num){\n  string res;\n  if(num==0)return \"0\";\n  while(num) res=(char)(num%10+'0')+res,num/=10;\n  return res;\n}\n\n\nint main(){\n  while(1){\n  ll A,B;\n  cin>>A>>B>>mod;\n  if(!A&&!B&&!mod)return 0;\n  RSQ2 T(B-A+1);\n  vector<string> num;\n  for(ll i=A;i<=B;i++)num.push_back(i2S(i));\n  sort(num.begin(),num.end());\n  \n  ll ans = 0;\n  T.add(0,T.n,1);\n  for(ll i=A;i<=B;i++){\n    int idx = lower_bound(num.begin(),num.end(),i2S(i))-num.begin();\n    ll val = T.sum(idx,idx+1);\n    ans=(ans+val)%mod;\n    T.add(idx,T.n,val);\n  }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint bit[100100];\nint N, P;\n\nvoid add(int k, int x)\n{\n    for (; k <= N + 1; k += k & -k){\n        bit[k] = (bit[k] + x) % P;\n    }\n}\n\nint sum(int k)\n{\n    int ret = 0;\n    for (; k; k &= (k - 1)){\n        ret = (ret + bit[k]) % P;\n    }\n    return (ret);\n}\n\nbool radix(int a, int b)\n{\n    return (to_string(a) < to_string(b));\n}\n\nint main()\n{\n    int A, B;\n    int v[100000];\n\n    while (scanf(\"%d %d %d\", &A, &B, &P) && A){\n       memset(bit, 0, sizeof(bit));\n       N = B - A + 1;\n       add(N + 1, 1);\n\n       for (int i = 0; i < N; i++){\n           v[i] = A + i;\n        }\n\n       sort(v, v + N, radix);\n\n       for (int i = N - 1; i >= 0; i--){\n           int nv = (sum(N + 1) - sum(v[i] - A) + P) % P;\n           add(v[i] - A + 1, nv);\n       }\n\n       printf(\"%d\\n\", sum(N));\n    }\n\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{\n    I(){\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n    }\n}cww;\n\ntypedef long long LL;\nnamespace BIT_{\n    const int SZ=300000;\n    LL mem[SZ];\n};\n\nclass BIT{\nprivate:LL *t;int n;int mod;\npublic:\n    BIT(int n,int  mod):t(BIT_::mem),n(n),mod(mod){\n        fill(t,t+BIT_::SZ,0);\n    }\n    LL sum(int i){\n        LL s=0;\n        while(i>0){\n            s+=t[i];\n            i-=i&-i;\n        }\n        return s%mod;\n    }\n    LL sum(int lb,int ub){\n        return (mod+sum(ub)-sum(lb-1))%mod;\n    }\n    void add(int i,LL x){\n        while(i<=n){\n            (t[i]+=x)%=mod;\n            i+=i&-i;\n        }\n    }\n};\n\nint main(){\n    for(int A,B,P;cin>>A>>B>>P,A+B+P;){\n        int D=B-A;\n        BIT bit(D+10,P);\n        using T=tuple<int,int,string>;\n        vector<T> num(D+1);\n        for(int i=0;i<=D;i++){\n            num[i]=T(i,-1,to_string(A+i));\n        }\n        sort(num.begin(),num.end(),[&](T &l,T &r){return get<2>(l)<get<2>(r);});\n        for(int i=0;i<=D;i++){\n            int id=get<0>(num[i]);\n            num[i]=T(id,i+1,string());\n        }\n        sort(num.begin(),num.end());\n        \n        for(auto &it:num){\n            int id=get<1>(it);\n            bit.add(id,bit.sum(id-1)+1);\n        }\n        cout<<bit.sum(D+5)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cmath>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define MAX 1100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nll A,B,MOD;\nll dp[MAX];\n\ninline\nint toIndex(ll a){ return a-A+1; }\n\nint main()\n{\n  while(cin >> A >> B >> MOD,A|B|MOD)\n    {\n      ll range = B-A+5;\n      rep(i,range)dp[i] = 0;\n      dp[1] = 1;//1-indexed\n      dp[toIndex(B+1)] = -1;\n\n      REP(cur,A,B+1)\n\t{\n\t  if(cur != A)dp[toIndex(cur)] = (dp[toIndex(cur)] + dp[toIndex(cur-1)]) % MOD;\n\t  ll sp = cur;\n\t  while(sp <= B)\n\t    {\n\t      int digit = (int)log10(sp) + 1;\n\t      ll p10 = 1;\n\t      rep(i,digit)p10 *= 10LL;\n\t      \n\t      ll nsp = (sp == cur?cur+1LL:sp);\n\t      p10 = min(p10,B+1);\n\n\t      //cout << cur << \"-th :\"  << \" sp = \" << sp << \" nsp = \" << nsp << \" p10 = \" << p10 << endl; \n\t      dp[toIndex(nsp)]  = (dp[toIndex(nsp)]  + dp[toIndex(cur)]) % MOD;\n\t      dp[toIndex(p10)] = (dp[toIndex(p10)] - dp[toIndex(cur)]) % MOD;\n\t      sp = sp*10;\n\t    }\n\n\t}\n      ll ans = 0;\n      REP(i,A,B+1)\n\t{\n\t  ans = (dp[toIndex(i)] + ans) % MOD;\n\t  //cout << \"dp[\" << toIndex(i) << \"] = \" << dp[toIndex(i)] << \"\\n\";\n\t}\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nconst int N = 100000 + 10;\n\nchar string[N][20];\nint rank[N], order[N], dp[N];\nint MOD, s;\n\nbool cmp(int a, int b) {\n\treturn strcmp(string[a], string[b]) < 0;\n}\n\nint sum[N];\n\nint lowbit(int x) {\n\treturn x & -x;\n}\n\nint get_sum(int x) {\n\tint result = 0;\n\twhile (x) {\n\t\t(result += sum[x]) %= MOD;\n\t\tx -= lowbit(x);\n\t}\n\treturn result;\n}\n\nvoid insert(int x, int v) {\n\twhile (x <= s) {\n\t\t(sum[x] += v) %= MOD;\n\t\tx += lowbit(x);\n\t}\n}\n\nint main() {\n\tint a, b;\n\twhile (scanf(\"%d%d%d\", &a, &b, &MOD) != EOF) {\n\t\tif (a + b + MOD == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tfor (int i = a; i <= b; ++ i) {\n\t\t\tstd::stringstream buffer;\n\t\t\tbuffer << i;\n\t\t\tbuffer >> string[i - a + 1];\n\t\t}\n\t\ts = b - a + 1;\n\t\tfor (int i = 1; i <= s; ++ i) {\n\t\t\torder[i] = i;\n\t\t}\n\t\tstd::sort(order + 1, order + s + 1, cmp);\n\t\tfor (int i = 1; i <= s; ++ i) {\n\t\t\trank[order[i]] = i;\n\t\t}\n\t\t\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 1; i <= s; ++ i) {\n\t\t\tdp[i] = (get_sum(rank[i] - 1) + 1) % MOD;\n\t\t\tinsert(rank[i], dp[i]);\n\t\t}\n\t\tint answer = 0;\n\t\tfor (int i = 1; i <= s; ++ i) {\n\t\t\t(answer += dp[i]) %= MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\n\nll p;\n\nstruct FenwickTree{\n  int n;\n  vl bit;\n  FenwickTree(int x = 0):n(x){bit = vl(x+1,0);}\n\n  inline void add(int i, ll x){\n    i++;\n    while(i <= n){\n      (bit[i] += x) %= p;\n      i += i & -i;\n    }\n  }\n\n  inline ll sum(int i){\n    i++;\n    ll res = 0;\n    while(i > 0){\n      (res += bit[i]) %= p;\n      i -= i & -i;\n    }\n    return res;\n  }\n\n  inline ll partial_sum(int l, int r){\n    return (sum(r-1) - sum(l-1) + p) % p;\n  }\n};\n\ninline string LLtoS(ll a){\n  stringstream ss;\n  ss << a;\n  return ss.str();\n}\n\ninline ll StoLL(string s){\n  stringstream ss(s);\n  ll res; ss >> res;\n  return res;\n}\n\nint main(){\n  ll a,b;\n  while(cin >> a >> b >> p, a){\n    FenwickTree bit(b-a+1);\n    for(ll x=a;x<=b;x++){\n      string s = LLtoS(x);\n      ll l=1, sum = 1, r = 0;\n      for(int i=0;i<(int)s.size();i++){\n\tr = r*10 + (ll)(s[i]-'0');\n\tif(a<=r && l<=b){\n\t  l = max(l,a); r = min(r,b);\n\t  (sum += bit.partial_sum(l-a,r-a+1)) %= p;\n\t}\n\tl*=10;\n      }\n      bit.add(x-a,sum);\n    }\n    cout << bit.partial_sum(0,b-a+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nLL A, B, P;\n\nint dig(LL x){\n  int res = 0;\n  while(x > 0) x /= 10, ++res;\n  return res;\n}\n\nLL f(LL x){\n  int d = dig(x);\n  LL res = 1;\n  while(d>0) res *= 10, --d;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>A>>B>>P,A){\n\tLL D = B - A;\n\tLL dp[100010][2];\n\tfill((LL*)dp, (LL*)dp+100010*2, 0);\n\tdp[D][0] = 1;\n\tdp[D][1] = 1;\n\tfor(int i=D-1;i>=0;--i){\n\t  LL x = A + i;\n\t  dp[i][0] = 1;\n\t  if(dig(x) == dig(x+1))\n\t\tdp[i][0] = (dp[i][0] + dp[i+1][1]) % P;\n\n\t  for(LL tmp=x*10;tmp<=B;tmp*=10){\n\t\tdp[i][0] += dp[tmp-A][1];\n\t\tdp[i][0] %= P;\n\t  }\n\t  if(dig(x) == dig(x+1))\n\t\tdp[i][1] = (dp[i][0] + dp[i+1][1]) % P;\n\t  else\n\t\tdp[i][1] = dp[i][0];\n\t}\n\tLL ans = 0;\n\tREP(i,D+1) ans = (ans + dp[i][0]) % P;\n\tcout << ans << endl;\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2326: Number Sorting\n// 2017.11.27 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nlong long dp[100002];\nlong long a, b, p;\n\nlong long tbl[12] = { 0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, \n100000000LL, 1000000000LL, 10000000000LL };\n\nlong long bsch(long long x)\n{\n\tint m, l = 0, r = 12;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (tbl[m] == x) return x;\n        if (tbl[m] < x) l = m + 1; else r = m;\n    }\n\treturn tbl[l-1];\n}\n\nvoid calc(long long n)\n{\n    long long k, v = dp[n-a], m = n;\n\n\twhile (m < b) {\n\t\tif (m == n) { dp[m-a+1] += v; if (dp[m-a+1] >= p) dp[m-a+1] -= p; }\n\t\telse        { dp[m-a  ] += v; if (dp[m-a]   >= p) dp[m-a  ] -= p; }\n        m *= 10;\n\t\tk = bsch(m); if (k > b) k = b;\n\t\tk -= a, dp[k] -= v; if (dp[k] < 0) dp[k] += p;\n    }\n}\n\nint main()\n{\n\tlong long i, ans;\n\n\twhile (scanf(\"%lld%lld%lld\", &a, &b, &p) && p > 0) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t    b++;\n\t\tdp[0] = 1, calc(a), ans = dp[0];\n\t\tfor (i = a+1; i < b; i++) {\n\t\t\tdp[i-a] += dp[i-a-1]; if (dp[i-a] >= p) dp[i-a] -= p;\n\t\t\tcalc(i);\n\t        ans += dp[i-a]; if (ans >= p) ans -= p;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2326: Number Sorting\n// 2017.11.27 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nlong long dp[100002];\nlong long a, b, p;\n\nlong long tbl[12] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, \n100000000LL, 1000000000LL, 10000000000LL, 100000000000LL };\n\nlong long bsch(long long x)\n{\n\tint m, l = 0, r = 12;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (tbl[m] == x) return x;\n        if (tbl[m] < x) l = m + 1; else r = m;\n    }\n\treturn tbl[l-1];\n}\n\nvoid calc(long long n)\n{\n    long long k, v = dp[n-a], m = n;\n\n\twhile (m < b) {\n\t\tif (m == n) { dp[m-a+1] += v; if (dp[m-a+1] >= p) dp[m-a+1] -= p; }\n\t\telse        { dp[m-a  ] += v; if (dp[m-a]   >= p) dp[m-a  ] -= p; }\n        m *= 10;\n\t\tk = bsch(m); if (k > b) k = b;\n\t\tk -= a, dp[k] -= v; if (dp[k] < 0) dp[k] += p;\n    }\n}\n\nint main()\n{\n\tlong long i, ii, ans;\n\n\twhile (scanf(\"%lld%lld%lld\", &a, &b, &p) && p > 0) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t    b++;\n\t\tdp[0] = 1, calc(a);\n\t\tans = dp[0]; if (ans >= p) ans -= p;\n\t\tfor (ii = 1, i = a+1; i < b; i++, ii++) {\n\t\t\tdp[ii] += dp[ii-1]; if (dp[ii] >= p) dp[ii] -= p;\n\t\t\tcalc(i);\n\t        ans += dp[ii]; if (ans >= p) ans -= p;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "class SumBinaryIndexedTree(val size: Int, val modulo: Long) {\n    private val array: LongArray = LongArray(size){0L}\n    fun increase(position: Int, value: Long): Unit {\n        if (position < size) {\n            array[position] = (array[position] + value) % modulo\n            increase(position + ((position + 1) and position.inv()), value)\n        }\n    }\n    operator fun get(position: Int): Long {\n        return if (position < 0) 0L else (array[position] + get(position - ((position + 1) and position.inv()))) % modulo\n    }\n\n}\nfun main(args: Array<String>?): Unit {\n    while(true) {\n        val (a, b, p) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (a == 0) return\n        val numbers = (a .. b).map(Any::toString)\n        val lexical = numbers.indices.sortedBy { numbers[it] }\n        val bit = SumBinaryIndexedTree(numbers.size, p.toLong())\n        var result = 0L\n        for (i in lexical) {\n            val prev = bit[i] + 1L\n            result = (result + prev) % p\n            bit.increase(i, prev)\n        }\n        println(result)\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tlong a = sc.nextLong();\n\t\t\tlong b = sc.nextLong();\n\t\t\tlong p = sc.nextLong();\n\t\t\tif (a == 0 && b == 0 && p == 0)\n\t\t\t\tbreak;\n\t\t\tlong[] dp = new long[111111];\n\t\t\tdp[0] = 1;\n\t\t\tlong ans = 0;\n\t\t\tfor (long i = a; i <= b; i++) {\n\t\t\t\tif (i > a) {\n\t\t\t\t\tdp[(int) (i - a)] += dp[(int) (i - a - 1)];\n\t\t\t\t}\n\t\t\t\tans += dp[(int) (i - a)];\n\t\t\t\tans %= p;\n\t\t\t\tfor (long j = i; j <= b; j *= 10) {\n\t\t\t\t\tlong t = 1;\n\t\t\t\t\twhile (t <= j)\n\t\t\t\t\t\tt *= 10;\n\t\t\t\t\tlong l = Math.max(i - a + 1, j - a), r = Math.min(b - a + 1, t - a);\n\t\t\t\t\tdp[(int) l] += dp[(int) (i - a)];\n\t\t\t\t\tdp[(int) r] -= dp[(int) (i - a)];\n\t\t\t\t\tdp[(int) l] %= p;\n\t\t\t\t\tdp[(int) r] %= p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            for (; ; )\n            {\n                var a = ri;\n                var b = ri;\n                var P = rl;\n                if (a == 0) return;\n                solve(a, b, P);\n            }\n        }\n        void naive(int l, int r, long P) {\n            var dp = new long[r + 1];\n            for (int i = l; i <= r; i++)\n                dp[i] = 1;\n            for (int i = 1; i <= r; i++)\n                for (int j = i + 1; j <= r; j++)\n                    if ((string.CompareOrdinal(i.ToString(), j.ToString())) < 0)\n                        dp[j] = (dp[i] + dp[j]) % P;\n            Console.WriteLine(dp.Sum());\n\n        }\n        void solve(long l, long r, long P) {\n            var dp = new HashMap<long, long>();\n            var ep = new HashMap<long, long>();\n            long ans = 0L;\n            for (long i = l; i <= r; i++)\n            {\n\n                dp[i] += (1 + ep[i]) % P;\n                //Debug.WriteLine($\"{i} {dp[i]}\");\n                ans = (ans + dp[i]) % P;\n                if (!i.ToString().All(x => x == '9'))\n                    ep[i + 1] = (ep[i + 1] + ep[i] + dp[i]) % P;\n                for (int k = 0, pow = 10; k < 6; k++, pow *= 10)\n                    ep[i * pow] = (ep[i * pow] + dp[i]) % P;\n            }\n            Console.WriteLine(ans);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n\n\n#region HashMap<K,V>\npublic class HashMap<K, V>: Dictionary<K, V>\n//where V : new()\n{\n    public HashMap() : base() { }\n    public HashMap(int cap) : base(cap) { }\n    new public V this[K i] {\n        get {\n            V v;\n            return TryGetValue(i, out v) ? v :\n                base[i] = default(V);\n            //base[i] = new V();\n        }\n        set { base[i] = value; }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "class FenwickTree\n    def initialize(n)\n        @size = n \n        @ary = [0] * (n + 1)\n    end \n\n    def add(i, x)\n        return if i > @size\n        @ary[i] += x\n        add(i + (i & -i), x)\n    end \n\n    def sum(i)\n        return 0 if i == 0\n        @ary[i] + sum(i - (i & -i))\n    end \n\n    attr_reader :size\nend\n\nloop do\n    a, b, mod = gets.split.map(&:to_i)\n    break if a == 0\n    tree = FenwickTree.new(b - a + 1)\n    (a..b).map(&:to_s).sort.each do |s| \n        i = s.to_i - a + 1 \n        tree.add(i, (1 + tree.sum(i - 1)) % mod)\n    end \n    p tree.sum(b - a + 1) % mod \nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    A, B, P = map(int, readline().split())\n    if A == B == P == 0:\n        return False\n    N = (B - A + 1)\n    data = [0]*(N+1)\n    def get(k):\n        s = 0\n        while k:\n            s += data[k]\n            k -= k & -k\n        return s % P\n    *V, = range(A, B+1)\n    V.sort(key = str)\n    for v in V:\n        k = v+1 - A\n        x = get(k) + 1\n        while k <= N:\n            data[k] += x\n            k += k & -k\n    write(\"%d\\n\" % (get(N) % P))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\nclass BIT():\n    def __init__(self, n, p):\n        self.p = p\n        i = 1\n        while 2**i <= n:\n            i += 1\n        self.H = i\n        self.N = 2**i\n        self.A = [0] * self.N\n\n    def find(self, i):\n        r = 0\n        while i:\n            r += self.A[i]\n            r %= self.p\n            i -= i & (i-1) ^ i\n        return r\n\n    def update(self, i, x):\n        while i < self.N:\n            self.A[i] += x\n            self.A[i] %= self.p\n            i += i & (i-1) ^ i\n\n    def total(self):\n        return self.find(self.N-1)\n\n    def query(self, a, b):\n        return self.find(b-1) - self.find(a-1)\n\ndef main():\n    rr = []\n\n    def f(a,b,p):\n        aa = list(range(a,b+1))\n        sa = sorted(map(str,aa))\n        l = len(aa)\n        d = {}\n        for s,i in zip(sa, range(l)):\n            d[int(s)] = i\n\n        seg = BIT(l+2, p)\n        for c in aa:\n            t = seg.find(d[c]+1)\n            seg.update(d[c]+1, (t+1) % p)\n\n        return seg.total() % p\n\n    while 1:\n        n,m,l = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,l))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "s = [0] * 100100\ndp = [0] * 100100\nt = [10**i for i in range(10)]\n\t\nwhile 1:\n\ta,b,p = map(int,raw_input().split())\n\tif a == b == p == 0: break\n\tans = 0\n\tfor i in range(b - a + 1):\n\t\tdp[i] = 1\n\t\tm = (a + i) / 10\n\t\twhile a <= m and m <= b:\n\t\t\tdp[i] += s[m - a]\n\t\t\tdp[i] %= p\n\t\t\tm /= 10\n\t\tfor j in range(10):\n\t\t\tif a + i == t[j]:\n\t\t\t\ts[i] = dp[i]\n\t\t\t\tbreak\n\t\telse:\n\t\t\tdp[i] += s[i - 1] if i > 0 else 0\n\t\t\tdp[i] %= p\n\t\t\ts[i] = s[i - 1] + dp[i] if i > 0 else dp[i]\n\t\t\ts[i] %= p\n\t\tans += dp[i]\n\t\tans %= p\n\tprint ans"
  }
]