[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef struct {\n    int to;\n    char type;\n} Edge;\n\ntypedef struct {\n    Edge *edges;\n    int size;\n    int capacity;\n} AdjList;\n\nAdjList *adj;\nint *nat_dist;\nint *len_dist;\nint *visited;\n\nvoid add_edge(AdjList *list, int to, char type) {\n    if (list->size == list->capacity) {\n        list->capacity = list->capacity == 0 ? 4 : list->capacity * 2;\n        list->edges = realloc(list->edges, list->capacity * sizeof(Edge));\n    }\n    list->edges[list->size].to = to;\n    list->edges[list->size].type = type;\n    list->size++;\n}\n\nvoid bfs(int start, int *dist, int n, int is_nat) {\n    for (int i = 0; i <= n; i++) {\n        dist[i] = -1;\n    }\n    int *queue = malloc((n + 1) * sizeof(int));\n    int front = 0, rear = 0;\n    dist[start] = 0;\n    queue[rear++] = start;\n    while (front < rear) {\n        int u = queue[front++];\n        for (int i = 0; i < adj[u].size; i++) {\n            Edge e = adj[u].edges[i];\n            if (is_nat && e.type == 'L') continue;\n            if (dist[e.to] == -1) {\n                dist[e.to] = dist[u] + 1;\n                queue[rear++] = e.to;\n            }\n        }\n    }\n    free(queue);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    adj = calloc(n + 1, sizeof(AdjList));\n    nat_dist = malloc((n + 1) * sizeof(int));\n    len_dist = malloc((n + 1) * sizeof(int));\n    visited = malloc((n + 1) * sizeof(int));\n\n    int nat_start, len_start;\n    scanf(\"%d %d\", &nat_start, &len_start);\n\n    int summer_door = -1;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        char type[2];\n        scanf(\"%d %d %s\", &a, &b, type);\n        add_edge(&adj[a], b, type[0]);\n        add_edge(&adj[b], a, type[0]);\n        if (a == 0 || b == 0) {\n            summer_door = a == 0 ? b : a;\n        }\n    }\n\n    bfs(nat_start, nat_dist, n, 1);\n    bfs(len_start, len_dist, n, 0);\n\n    int min_doors = INT_MAX;\n    for (int u = 1; u <= n; u++) {\n        for (int i = 0; i < adj[u].size; i++) {\n            Edge e = adj[u].edges[i];\n            if (e.to == 0) {\n                if (len_dist[u] != -1) {\n                    if (nat_dist[u] != -1) {\n                        if (nat_dist[u] < min_doors) {\n                            min_doors = nat_dist[u];\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", min_doors == INT_MAX ? -1 : min_doors);\n\n    for (int i = 0; i <= n; i++) {\n        if (adj[i].edges) free(adj[i].edges);\n    }\n    free(adj);\n    free(nat_dist);\n    free(len_dist);\n    free(visited);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    char type;\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin >> n >> m;\n    int s_n, s_l;\n    cin >> s_n >> s_l;\n\n    vector<vector<Edge>> adj(n + 1);\n    int summer_door = -1;\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        char t;\n        cin >> u >> v >> t;\n        adj[u].push_back({v, t});\n        adj[v].push_back({u, t});\n        if (u == 0 || v == 0) {\n            summer_door = (u == 0) ? v : u;\n        }\n    }\n\n    vector<int> dist_n(n + 1, INT_MAX);\n    queue<int> q_n;\n    dist_n[s_n] = 0;\n    q_n.push(s_n);\n    while (!q_n.empty()) {\n        int u = q_n.front();\n        q_n.pop();\n        for (const Edge& e : adj[u]) {\n            if (e.type != 'N') continue;\n            if (dist_n[e.to] > dist_n[u] + 1) {\n                dist_n[e.to] = dist_n[u] + 1;\n                q_n.push(e.to);\n            }\n        }\n    }\n\n    vector<int> dist_l(n + 1, INT_MAX);\n    queue<int> q_l;\n    dist_l[s_l] = 0;\n    q_l.push(s_l);\n    while (!q_l.empty()) {\n        int u = q_l.front();\n        q_l.pop();\n        for (const Edge& e : adj[u]) {\n            if (dist_l[e.to] > dist_l[u] + 1) {\n                dist_l[e.to] = dist_l[u] + 1;\n                q_l.push(e.to);\n            }\n        }\n    }\n\n    if (dist_l[summer_door] == 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int min_doors = INT_MAX;\n    for (const Edge& e : adj[summer_door]) {\n        int room = e.to;\n        if (room == 0) continue;\n        if (dist_n[room] != INT_MAX && dist_l[room] != INT_MAX) {\n            min_doors = min(min_doors, dist_n[room] + dist_l[room]);\n        }\n    }\n\n    cout << min_doors << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Edge {\n        int to;\n        char type;\n        Edge(int to, char type) {\n            this.to = to;\n            this.type = type;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n\n        st = new StringTokenizer(br.readLine());\n        int natStart = Integer.parseInt(st.nextToken());\n        int lenStart = Integer.parseInt(st.nextToken());\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        int summerDoor = -1;\n        for (int i = 0; i < m; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            char type = st.nextToken().charAt(0);\n            adj.get(u).add(new Edge(v, type));\n            adj.get(v).add(new Edge(u, type));\n            if (u == 0 || v == 0) {\n                summerDoor = (u == 0) ? v : u;\n            }\n        }\n\n        int[] distNat = new int[n + 1];\n        Arrays.fill(distNat, -1);\n        Queue<Integer> qNat = new LinkedList<>();\n        qNat.add(natStart);\n        distNat[natStart] = 0;\n\n        while (!qNat.isEmpty()) {\n            int u = qNat.poll();\n            for (Edge e : adj.get(u)) {\n                if (e.type == 'L') continue;\n                if (distNat[e.to] == -1) {\n                    distNat[e.to] = distNat[u] + 1;\n                    qNat.add(e.to);\n                }\n            }\n        }\n\n        int[] distLen = new int[n + 1];\n        Arrays.fill(distLen, -1);\n        Queue<Integer> qLen = new LinkedList<>();\n        qLen.add(lenStart);\n        distLen[lenStart] = 0;\n\n        while (!qLen.isEmpty()) {\n            int u = qLen.poll();\n            for (Edge e : adj.get(u)) {\n                if (distLen[e.to] == -1) {\n                    distLen[e.to] = distLen[u] + 1;\n                    qLen.add(e.to);\n                }\n            }\n        }\n\n        int minDoors = Integer.MAX_VALUE;\n        for (Edge e : adj.get(summerDoor)) {\n            if (e.to == 0) continue;\n            if (distNat[e.to] != -1 && distLen[e.to] != -1) {\n                minDoors = Math.min(minDoors, distNat[e.to]);\n            }\n        }\n\n        if (distLen[summerDoor] != -1) {\n            minDoors = 0;\n        }\n\n        System.out.println(minDoors == Integer.MAX_VALUE ? -1 : minDoors);\n    }\n}",
    "timestamp": "2025-08-05 21:14:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class DoorToSummer {\n    static class Door {\n        int room1, room2;\n        char type;\n        Door(int r1, int r2, char t) {\n            room1 = r1;\n            room2 = r2;\n            type = t;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        \n        st = new StringTokenizer(br.readLine());\n        int natsume = Integer.parseInt(st.nextToken());\n        int lennon = Integer.parseInt(st.nextToken());\n        \n        List<List<Door>> graph = new ArrayList<>(n + 1);\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            st = new StringTokenizer(br.readLine());\n            int r1 = Integer.parseInt(st.nextToken());\n            int r2 = Integer.parseInt(st.nextToken());\n            char type = st.nextToken().charAt(0);\n            \n            graph.get(r1).add(new Door(r1, r2, type));\n            graph.get(r2).add(new Door(r2, r1, type));\n        }\n        \n        System.out.println(bfs(n, natsume, lennon, graph));\n    }\n    \n    static int bfs(int n, int natsume, int lennon, List<List<Door>> graph) {\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[n + 1][n + 1];\n        queue.offer(new int[]{natsume, lennon, 0});\n        visited[natsume][lennon] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int nRoom = current[0];\n            int lRoom = current[1];\n            int doorOpened = current[2];\n            \n            if (lRoom == 0) return doorOpened;\n            \n            for (Door door : graph.get(lRoom)) {\n                int nextLRoom = door.room2;\n                \n                if (door.type == 'L') {\n                    if (!visited[nRoom][nextLRoom]) {\n                        queue.offer(new int[]{nRoom, nextLRoom, doorOpened});\n                        visited[nRoom][nextLRoom] = true;\n                    }\n                } else {\n                    for (Door nDoor : graph.get(nRoom)) {\n                        int nextNRoom = nDoor.room2;\n                        \n                        if (nDoor.type == 'N' && nextNRoom == door.room1) {\n                            if (!visited[nextNRoom][nextLRoom]) {\n                                queue.offer(new int[]{nextNRoom, nextLRoom, doorOpened + 1});\n                                visited[nextNRoom][nextLRoom] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 21:14:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_ROOMS 100001\n#define MAX_DOORS 100001\n\ntypedef struct {\n    int to;\n    char type;\n} Edge;\n\nEdge graph[MAX_ROOMS][MAX_DOORS];\nint graph_size[MAX_ROOMS];\nint dist[MAX_ROOMS][2];\nbool visited[MAX_ROOMS][2];\n\nvoid dijkstra(int start_natsume, int start_lennon) {\n    for (int i = 0; i < MAX_ROOMS; i++) {\n        dist[i][0] = dist[i][1] = INT_MAX;\n        visited[i][0] = visited[i][1] = false;\n    }\n    \n    dist[start_natsume][0] = 0;\n    dist[start_lennon][1] = 0;\n    \n    for (int _ = 0; _ < MAX_ROOMS; _++) {\n        int min_dist = INT_MAX;\n        int curr_room = -1;\n        int curr_type = -1;\n        \n        for (int room = 0; room < MAX_ROOMS; room++) {\n            for (int type = 0; type < 2; type++) {\n                if (!visited[room][type] && dist[room][type] < min_dist) {\n                    min_dist = dist[room][type];\n                    curr_room = room;\n                    curr_type = type;\n                }\n            }\n        }\n        \n        if (curr_room == -1) break;\n        \n        visited[curr_room][curr_type] = true;\n        \n        for (int i = 0; i < graph_size[curr_room]; i++) {\n            Edge* edge = &graph[curr_room][i];\n            \n            if (curr_type == 0) {  // Natsume\n                if (edge->type == 'N') {\n                    if (dist[curr_room][curr_type] + 1 < dist[edge->to][curr_type]) {\n                        dist[edge->to][curr_type] = dist[curr_room][curr_type] + 1;\n                    }\n                }\n                if (edge->type == 'L') {\n                    if (dist[curr_room][curr_type] < dist[edge->to][1]) {\n                        dist[edge->to][1] = dist[curr_room][curr_type];\n                    }\n                }\n            } else {  // Lennon\n                if (edge->type == 'L') {\n                    if (dist[curr_room][curr_type] + 1 < dist[edge->to][curr_type]) {\n                        dist[edge->to][curr_type] = dist[curr_room][curr_type] + 1;\n                    }\n                }\n                if (edge->type == 'N') {\n                    if (dist[curr_room][curr_type] < dist[edge->to][0]) {\n                        dist[edge->to][0] = dist[curr_room][curr_type];\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    int start_natsume, start_lennon;\n    scanf(\"%d %d\", &start_natsume, &start_lennon);\n    \n    for (int i = 0; i < m; i++) {\n        int u, v;\n        char type;\n        scanf(\"%d %d %c\", &u, &v, &type);\n        \n        graph[u][graph_size[u]].to = v;\n        graph[u][graph_size[u]].type = type;\n        graph_size[u]++;\n        \n        graph[v][graph_size[v]].to = u;\n        graph[v][graph_size[v]].type = type;\n        graph_size[v]++;\n    }\n    \n    dijkstra(start_natsume, start_lennon);\n    \n    printf(\"%d\\n\", dist[0][1]);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Door {\n    int from, to;\n    char type;\n};\n\nint findMinDoorsToSummer(int n, int natsume_start, int lennon_start, vector<Door>& doors) {\n    vector<vector<pair<int, char>>> graph(n + 1);\n    for (auto& door : doors) {\n        graph[door.from].push_back({door.to, door.type});\n        graph[door.to].push_back({door.from, door.type});\n    }\n\n    vector<vector<int>> dist(n + 1, vector<int>(2, INT_MAX));\n    dist[natsume_start][0] = 0;\n    dist[lennon_start][1] = 0;\n\n    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;\n    pq.push({0, natsume_start, 0});\n    pq.push({0, lennon_start, 1});\n\n    while (!pq.empty()) {\n        auto [d, u, who] = pq.top();\n        pq.pop();\n\n        if (d > dist[u][who]) continue;\n\n        for (auto& [v, door_type] : graph[u]) {\n            int new_d = d;\n            if (who == 0 && door_type == 'L') continue;\n            if (who == 1 && door_type == 'N') new_d++;\n\n            if (new_d < dist[v][who]) {\n                dist[v][who] = new_d;\n                pq.push({new_d, v, who});\n            }\n        }\n    }\n\n    return dist[0][1];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int natsume_start, lennon_start;\n    cin >> natsume_start >> lennon_start;\n\n    vector<Door> doors(m);\n    for (int i = 0; i < m; i++) {\n        cin >> doors[i].from >> doors[i].to >> doors[i].type;\n    }\n\n    int result = findMinDoorsToSummer(n, natsume_start, lennon_start, doors);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque, defaultdict\n\ndef minimum_doors_to_open(n, m, start_positions, doors):\n    natsume_start, lennon_start = start_positions\n    room_graph = defaultdict(list)\n    \n    for door in doors:\n        room1, room2, door_type = door\n        room_graph[room1].append((room2, door_type))\n        room_graph[room2].append((room1, door_type))\n    \n    queue = deque([(natsume_start, lennon_start, 0)])\n    visited = set()\n    visited.add((natsume_start, lennon_start))\n    \n    while queue:\n        natsume_pos, lennon_pos, doors_opened = queue.popleft()\n        \n        if lennon_pos == 0:\n            return doors_opened\n        \n        for next_room, door_type in room_graph[lennon_pos]:\n            if door_type == 'L':\n                if (natsume_pos, next_room) not in visited:\n                    visited.add((natsume_pos, next_room))\n                    queue.append((natsume_pos, next_room, doors_opened))\n        \n        if natsume_pos == lennon_pos: \n            for next_room, door_type in room_graph[natsume_pos]:\n                if door_type == 'N':\n                    if (next_room, lennon_pos) not in visited:\n                        visited.add((next_room, lennon_pos))\n                        queue.append((next_room, lennon_pos, doors_opened + 1))\n    \n    return -1\n\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nstart_positions = tuple(map(int, input().split()))\ndoors = [input().split() for _ in range(m)]\ndoors = [(int(room1), int(room2), door_type) for room1, room2, door_type in doors]\n\nprint(minimum_doors_to_open(n, m, start_positions, doors))",
    "timestamp": "2025-08-13 05:33:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TheDoorToSummer {\n    static class Edge {\n        int to, type;\n        Edge(int to, int type) { this.to = to; this.type = type; }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        int natsumeStart = sc.nextInt();\n        int lennonStart = sc.nextInt();\n        \n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            char type = sc.next().charAt(0);\n            int doorType = (type == 'N') ? 0 : 1;  // Normal door: 0, Small door: 1\n            graph.get(u).add(new Edge(v, doorType));\n            graph.get(v).add(new Edge(u, doorType));\n        }\n        \n        System.out.println(bfs(n, natsumeStart, lennonStart, graph));\n    }\n    \n    private static int bfs(int n, int natsumeStart, int lennonStart, List<List<Edge>> graph) {\n        int[] dist = new int[n + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1])); \n        pq.offer(new int[]{ natsumeStart, 0 });\n        dist[natsumeStart] = 0;\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int room = current[0];\n            int doorsOpened = current[1];\n            \n            if (room == 0) {\n                return doorsOpened;\n            }\n            \n            for (Edge edge : graph.get(room)) {\n                int nextRoom = edge.to;\n                int nextDoorsOpened = doorsOpened + edge.type;\n                \n                if (edge.type == 1) {  // Small door\n                    if (room == lennonStart && dist[nextRoom] > nextDoorsOpened) {\n                        dist[nextRoom] = nextDoorsOpened;\n                        pq.offer(new int[]{ nextRoom, nextDoorsOpened });\n                    }\n                } else {  // Normal door\n                    if (dist[nextRoom] > nextDoorsOpened) {\n                        dist[nextRoom] = nextDoorsOpened;\n                        pq.offer(new int[]{ nextRoom, nextDoorsOpened });\n                    }\n                }\n            }\n        }\n        return -1; // If the solution is not found, but according to problem guarantees this shouldn't happen.\n    }\n}",
    "timestamp": "2025-08-13 05:33:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_ROOMS 100001\n\ntypedef struct {\n    int room;\n    int open;\n} Node;\n\ntypedef struct {\n    Node *nodes;\n    int front, back, size;\n} Queue;\n\nQueue* createQueue(int max) {\n    Queue *q = (Queue *)malloc(sizeof(Queue));\n    q->nodes = (Node *)malloc(max * sizeof(Node));\n    q->front = q->back = q->size = 0;\n    return q;\n}\n\nvoid enqueue(Queue *queue, int room, int open) {\n    queue->nodes[queue->back].room = room;\n    queue->nodes[queue->back].open = open;\n    queue->back = (queue->back + 1) % MAX_ROOMS;\n    queue->size++;\n}\n\nNode dequeue(Queue *queue) {\n    Node node = queue->nodes[queue->front];\n    queue->front = (queue->front + 1) % MAX_ROOMS;\n    queue->size--;\n    return node;\n}\n\nint isEmpty(Queue *queue) {\n    return queue->size == 0;\n}\n\ntypedef struct Edge {\n    int to;\n    char type;\n    struct Edge *next;\n} Edge;\n\nEdge *edges[MAX_ROOMS];\n\nvoid addEdge(int from, int to, char type) {\n    Edge *edge = (Edge *)malloc(sizeof(Edge));\n    edge->to = to;\n    edge->type = type;\n    edge->next = edges[from];\n    edges[from] = edge;\n}\n\nint minDoorsToOpen(int n, int m, int startNatsume, int startLennon) {\n    int distance[MAX_ROOMS];\n    for (int i = 0; i <= n; i++) {\n        distance[i] = INT_MAX;\n    }\n    distance[startLennon] = 0;\n\n    Queue *queue = createQueue(n + 1);\n    enqueue(queue, startLennon, 0);\n\n    while (!isEmpty(queue)) {\n        Node current = dequeue(queue);\n        if (current.open > distance[current.room]) {\n            continue;\n        }\n\n        for (Edge *edge = edges[current.room]; edge; edge = edge->next) {\n            int neighbor = edge->to;\n            int newOpen = current.open;\n            if (edge->type == 'N') {\n                newOpen++;\n            }\n\n            if (distance[neighbor] > newOpen) {\n                distance[neighbor] = newOpen;\n                enqueue(queue, neighbor, newOpen);\n            }\n        }\n    }\n\n    int result = distance[0];\n    if (distance[startNatsume] < result) {\n        result = distance[startNatsume];\n    }\n    free(queue->nodes);\n    free(queue);\n\n    return result;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int startNatsume, startLennon;\n    scanf(\"%d %d\", &startNatsume, &startLennon);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        char type;\n        scanf(\"%d %d %c\", &u, &v, &type);\n        addEdge(u, v, type);\n        addEdge(v, u, type);\n    }\n\n    printf(\"%d\\n\", minDoorsToOpen(n, m, startNatsume, startLennon));\n    return 0;\n}",
    "timestamp": "2025-08-13 05:34:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_door_to_summer():\n    n, m = map(int, input().split())\n    natsume_room, lennon_room = map(int, input().split())\n    \n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v, door_type = input().split()\n        u, v = int(u), int(v)\n        graph[u].append((v, door_type))\n        graph[v].append((u, door_type))\n    \n    def bfs():\n        visited = set()\n        queue = deque([(natsume_room, lennon_room, 0)])\n        \n        while queue:\n            natsume_pos, lennon_pos, doors_opened = queue.popleft()\n            \n            if lennon_pos == 0:\n                return doors_opened\n            \n            state = (natsume_pos, lennon_pos)\n            if state in visited:\n                continue\n            visited.add(state)\n            \n            for u, v, door_type in get_possible_moves(natsume_pos, lennon_pos):\n                if door_type == 'N':\n                    queue.append((v, lennon_pos, doors_opened + 1))\n                else:\n                    queue.append((natsume_pos, v, doors_opened))\n        \n        return -1\n    \n    def get_possible_moves(natsume_pos, lennon_pos):\n        moves = []\n        for u in [natsume_pos, lennon_pos]:\n            for v, door_type in graph[u]:\n                if u == natsume_pos and door_type == 'N':\n                    moves.append((u, v, door_type))\n                elif u == lennon_pos and door_type == 'L':\n                    moves.append((u, v, door_type))\n        return moves\n    \n    print(bfs())\n\nsolve_door_to_summer()",
    "timestamp": "2025-08-13 05:34:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, m = map(int, input[ptr:ptr+2])\n    ptr +=2\n    s_n, s_l = map(int, input[ptr:ptr+2])\n    ptr +=2\n    \n    adj = [[] for _ in range(n+1)]\n    door_to_summer = None\n    \n    for _ in range(m):\n        u, v, typ = input[ptr], input[ptr+1], input[ptr+2]\n        ptr +=3\n        u = int(u)\n        v = int(v)\n        if u == 0 or v == 0:\n            door_to_summer = (u if v == 0 else v, typ)\n            continue\n        adj[u].append((v, typ))\n        adj[v].append((u, typ))\n    \n    summer_room, summer_type = door_to_summer\n    \n    # BFS for Lennon's reachable rooms without Natsume's help\n    lennon_visited = [False] * (n+1)\n    q = deque()\n    q.append(s_l)\n    lennon_visited[s_l] = True\n    \n    while q:\n        u = q.popleft()\n        for (v, typ) in adj[u]:\n            if not lennon_visited[v] and typ in ['L', 'N']:\n                lennon_visited[v] = True\n                q.append(v)\n    \n    if summer_room == s_l and summer_type == 'L':\n        print(0)\n        return\n    \n    if lennon_visited[summer_room] and summer_type == 'L':\n        print(0)\n        return\n    \n    # BFS for Natsume's reachable rooms\n    natsume_visited = [False] * (n+1)\n    q = deque()\n    q.append(s_n)\n    natsume_visited[s_n] = True\n    \n    while q:\n        u = q.popleft()\n        for (v, typ) in adj[u]:\n            if not natsume_visited[v] and typ == 'N':\n                natsume_visited[v] = True\n                q.append(v)\n    \n    # Check if Natsume can reach the summer room and open the door\n    if summer_type == 'N' and natsume_visited[summer_room]:\n        print(1)\n        return\n    \n    # BFS for Lennon's reachable rooms with Natsume's help (opening 'N' doors)\n    # We need to find the minimal number of 'N' doors Natsume needs to open\n    # such that Lennon can reach the summer room\n    \n    # The idea is to find the minimal number of 'N' doors on the path from s_l to summer_room\n    # where those 'N' doors are reachable by Natsume\n    \n    # We can model this as a BFS where Lennon can move through 'L' and 'N' edges,\n    # but 'N' edges contribute to the cost if Natsume can reach the 'N' door's room\n    \n    INF = float('inf')\n    dist = [INF] * (n+1)\n    dist[s_l] = 0\n    q = deque()\n    q.append(s_l)\n    \n    while q:\n        u = q.popleft()\n        for (v, typ) in adj[u]:\n            new_dist = dist[u]\n            if typ == 'N':\n                if natsume_visited[u] or natsume_visited[v]:\n                    new_dist +=1\n                else:\n                    continue  # can't pass through 'N' door unless Natsume opens it\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                q.append(v)\n    \n    if dist[summer_room] != INF and summer_type == 'N' and natsume_visited[summer_room]:\n        print(dist[summer_room] +1)\n    elif dist[summer_room] != INF and summer_type == 'L':\n        print(dist[summer_room])\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 05:34:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int target;\n    char type;\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    int natsume_start, lennon_start;\n    cin >> natsume_start >> lennon_start;\n\n    vector<vector<Edge>> adjacencyList(n + 1);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        char type;\n        cin >> u >> v >> type;\n        adjacencyList[u].push_back({v, type});\n        adjacencyList[v].push_back({u, type});\n    }\n\n    // BFS to find the minimum number of N doors to open for both Natsume and Lennon\n    vector<vector<int>> dist(n + 1, vector<int>(2, numeric_limits<int>::max()));\n    queue<pair<int, int>> bfsQueue;\n\n    // Initialize with Natsume's position\n    dist[natsume_start][0] = 0;\n    bfsQueue.push({natsume_start, 0});\n\n    // Initialize with Lennon's position (as if Lennon navigates through L doors)\n    dist[lennon_start][1] = 0;\n    bfsQueue.push({lennon_start, 1});\n\n    while (!bfsQueue.empty()) {\n        int current = bfsQueue.front().first;\n        int isLennon = bfsQueue.front().second;  // 0 if Natsume, 1 if Lennon\n        bfsQueue.pop();\n\n        for (const auto& edge : adjacencyList[current]) {\n            int next = edge.target;\n            char type = edge.type;\n\n            if (isLennon && type == 'L' && dist[next][1] > dist[current][1]) {\n                dist[next][1] = dist[current][1];\n                bfsQueue.push({next, 1});\n            }\n\n            if (!isLennon && type == 'N' && dist[next][0] > dist[current][0] + 1) {\n                dist[next][0] = dist[current][0] + 1;\n                bfsQueue.push({next, 0});\n            }\n        }\n    }\n\n    // The goal is to find the path from Natsume to the \"Door to Summer\" (0) minimizing N doors opened\n    int result = numeric_limits<int>::max();\n\n    // Check if both Natsume and Lennon can reach room 0\n    if (dist[0][0] != numeric_limits<int>::max() && dist[0][1] != numeric_limits<int>::max()) {\n        result = dist[0][0];\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:25:51"
  }
]