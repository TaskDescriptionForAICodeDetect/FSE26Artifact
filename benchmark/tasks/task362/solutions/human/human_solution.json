[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int dst,weight;\n  bool type[2]; // 0 -> hito, 1 -> nyanko\n  Edge(int dst=-1,int weight=0,bool a=false,bool b=false) : dst(dst), weight(weight) {\n    type[0] = a, type[1] = b;\n  }\n};\n\nconst int MAX_V = 100100;\nint V,E,Natsume,Lennon;\nvector<Edge> G[MAX_V];\nint par[MAX_V],rank[MAX_V];\n\ninline void init(int n=MAX_V){ rep(i,n) par[i] = i, rank[i] = 0; }\n\nint find(int x) {\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) {\n    if( rank[x] > rank[y] ) par[y] = x;\n    else {\n      par[x] = y;\n      if( par[x] == par[y] ) ++rank[y];\n    }\n  }\n}\n\nvoid draw(int sp,int type){\n  deque<int> deq;\n  deq.push_back(sp);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()){\n      int next = G[cur][i].dst;\n      if( !G[cur][i].type[type] ) continue;\n      if( find(cur) != find(next) ) {\n        unit(cur,next);\n        deq.push_back(next);\n      }\n    }\n  }\n}\n\nconst int IINF = INT_MAX;\nint mindist[3][MAX_V]; // 0-> Natsume, 1-> Summer, 2-> Lennon\n\nvoid calc(int stype,vector<int> &sp){\n  rep(i,V) mindist[stype][i] = IINF;\n  deque<int> deq;\n  rep(i,sp.size()) {\n    mindist[stype][sp[i]] = 0;\n    deq.push_back(sp[i]);\n  }\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,G[cur].size()){\n      int next = G[cur][i].dst;\n      if( !G[cur][i].type[0] ) continue;\n      if( mindist[stype][next] > mindist[stype][cur] + 1 ){\n        mindist[stype][next] = mindist[stype][cur] + 1;\n        deq.push_back(next);\n      }\n    }\n  }\n}\n\nvoid compute(){\n  draw(0,1);\n  draw(Lennon,1);\n  if( find(0) == find(Lennon) ) { puts(\"0\"); return; }\n  vector<int> sp;\n  sp.push_back(Natsume);\n  calc(0,sp);\n  sp.clear();\n\n  rep(i,V) if( find(0) == find(i) ) sp.push_back(i);\n  calc(1,sp);\n  sp.clear();\n\n  rep(i,V) if( find(Lennon) == find(i) ) sp.push_back(i);\n  calc(2,sp);\n  \n  int mini = IINF;\n  rep(i,V) if( mindist[0][i] != IINF && mindist[1][i] != IINF && mindist[2][i] != IINF ) {\n    mini = min(mini,mindist[0][i]+mindist[1][i]+mindist[2][i]);\n  }\n\n  cout << mini << endl;\n\n}\n\nint main(int argc,char** argv){\n  int T;\n  cin >> T;\n  while( T-- ) {\n    cin >> V >> E;\n    cin >> Natsume >> Lennon;\n    ++V;\n    rep(i,V) G[i].clear();\n    init(V);\n    rep(_,E){\n      int s,t;\n      char c;\n      cin >> s >> t >> c;\n      if( c == 'N' ) {\n        G[s].push_back(Edge(t,1,true,false));\n        G[t].push_back(Edge(s,1,true,false));\n      } else {\n        G[s].push_back(Edge(t,0,false,true));\n        G[t].push_back(Edge(s,0,false,true));\n      }\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n#include<tuple>\n\nusing namespace std;\n\n#define reep(i, s, n) for(int i=s;i<(int)n;i++)\n#define rep(i, n) for(int i=0;i<(int)n;i++)\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define all(v) v.begin(), v.end()\n#define tyd typedef\n#define vc vector\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\nconst int INF = 1<<28;\t\n\nint T, n, m, nat, len;\n\nstruct UnionFind{\n\tvector<int> d;\n\tUnionFind(int n):d(n, -1){}\n\tbool unite(int x, int y){\n\t\tif((x = root(x)) != (y = root(y))){\n\t\t\tif(d[y] < d[x]) swap(x, y);\n\t\t\td[x] += d[y]; d[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x){return d[x] < 0 ? x : d[x] = root(d[x]);}\n};\n\nvi bfs(const vector<vi> &g, vi s){\n\tvi dp(n+1, INF);\n\tqueue<int> q;\n\tfor(int u : s){\n\t\tq.push(u);\n\t\tdp[u] = 0;\n\t}\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int v : g[u])if(dp[u]+1 < dp[v]){\n\t\t\tq.push(v);\n\t\t\tdp[v] = dp[u] + 1;\n\t\t}\n\t}\n\treturn dp;\n}\n\n\nint main(){\n\tcin >> T;\n\twhile(T--){\n\t\tcin >> n >> m >> nat >> len;\n\t\tvector<vi> g(n+1);\n\t\tUnionFind uf(n+1);\n\t\tREP(i, m){\n\t\t\tint u, v; char c;\n\t\t\tcin >> u >> v >> c;\n\t\t\tif(c == 'N'){\n\t\t\t\tg[u].pb(v);\n\t\t\t\tg[v].pb(u);\n\t\t\t}else{\n\t\t\t\tuf.unite(u, v);\n\t\t\t}\n\t\t}\n\t\tif(uf.root(0) == uf.root(len)){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tvi s1, s2;\n\t\tREP(i, n+1) if(uf.root(i) == uf.root(len)) s1.pb(i);\n\t\tREP(i, n+1) if(uf.root(i) == uf.root(0)) s2.pb(i);\n\t\tauto d1 = bfs(g, s1);\n\t\tauto d2 = bfs(g, s2);\n\t\tauto d3 = bfs(g, vi({nat}));\n\t\tREP(i, n)if(uf.root(i) == 0){\n\t\t\td1[i] = d1[0];\n\t\t\td2[i] = d2[0];\n\t\t\td3[i] = d3[0];\n\t\t}\n//\t\tcout << \"uf: \" ;REP(i, n+1) cout << uf.root(i) << \", \"; cout << endl;\n//\t\tcout << \"d1: \" ;REP(i, n+1) cout << d1[i] << \", \"; cout << endl;\n//\t\tcout << \"d2: \" ; REP(i, n+1) cout << d2[i] << \", \"; cout << endl;\n//\t\tcout << \"d3: \" ; REP(i, n+1) cout << d3[i] << \", \"; cout << endl;\n\t\tint ans = INF;\n\t\tREP(i, n) ans = min(ans, d1[i] + d2[i] + d3[i]);\n\t\tif(ans < INF) printf(\"%d\\n\", ans);\n\t\telse puts(\"-1\");\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, w;\n};\n\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<int, int> Pair;\n\nconst int INF = 1<<28;\n\nint n, m, N, L;\nGraph g;\n\nvector<int> dijkstra1(int src, int u) {\n  vector<int> cost(n, INF);\n  priority_queue<Pair, vector<Pair>, greater<Pair> > que;\n  cost[src] = 0;\n  que.push(Pair(0, src));\n  while(que.size()) {\n    const Pair s = que.top(); que.pop();\n    if(cost[s.second] < s.first) continue;\n    for(int i = 0; i < g[s.second].size(); ++i) {\n      const Edge &e = g[s.second][i];\n      if(e.w <= u); else continue;\n      const Pair t(s.first + e.w, e.v);\n      if(cost[t.second] <= t.first) continue;\n      cost[t.second] = t.first;\n      que.push(t);\n    }\n  }\n  return cost;\n}\n\nstruct State {\n  int v, f, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint dijkstra2() {\n  vector<int> fromL = dijkstra1(L, 1);\n  vector<int> fromS = dijkstra1(0, 0);\n  vector<vector<int> > cost(n, vector<int>(2, INF));\n  priority_queue<State> que;\n  cost[N][0] = 0;\n  que.push((State){N, 0, 0});\n  while(que.size()) {\n    const State s = que.top(); que.pop();\n    if(cost[s.v][s.f] < s.cost) continue;\n    if(s.f == 0) {\n      do {\n\tconst State t = {s.v, 1, s.cost + fromL[s.v]};\n\tif(cost[t.v][t.f] <= t.cost) break;\n\tcost[t.v][t.f] = t.cost;\n\tque.push(t);\n      } while(0);\n    }\n    for(int i = 0; i < g[s.v].size(); ++i) {\n      const Edge &e = g[s.v][i];\n      if(e.w == 0) continue;\n      const State t = {e.v, s.f, s.cost + e.w};\n      if(cost[t.v][t.f] <= t.cost) continue;\n      cost[t.v][t.f] = t.cost;\n      que.push(t);\n    }\n  }\n  int res = INF;\n  for(int i = 0; i < n; ++i) {\n    res = min(res, cost[i][1] + fromS[i]);\n  }\n  return res;\n}\n\nint main() {\n  int T; cin >> T;\n  while(T--) {\n    cin >> n >> m;\n    ++n;\n    cin >> N >> L;\n    g = Graph(n);\n    for(int i = 0; i < m; ++i) {\n      int a, b; char c;\n      cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c == 'N'});\n      g[b].push_back((Edge){a, c == 'N'});\n    }\n    cout << dijkstra2() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n  int v, w;\n};\n\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<int, int> Pair;\n\nconst int INF = 1<<28;\n\nint n, m, N, L;\nGraph g;\n\nvector<int> dijkstra1(int src, int u) {\n  vector<int> cost(n, INF);\n  priority_queue<Pair, vector<Pair>, greater<Pair> > que;\n  cost[src] = 0;\n  que.push(Pair(0, src));\n  while(que.size()) {\n    const Pair s = que.top(); que.pop();\n    if(cost[s.second] < s.first) continue;\n    for(int i = 0; i < g[s.second].size(); ++i) {\n      const Edge &e = g[s.second][i];\n      if(e.w <= u); else continue;\n      const Pair t(s.first + e.w, e.v);\n      if(cost[t.second] <= t.first) continue;\n      cost[t.second] = t.first;\n      que.push(t);\n    }\n  }\n  return cost;\n}\n\nstruct State {\n  int v, f, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nint dijkstra2() {\n  vector<int> fromL = dijkstra1(L, 1);\n  vector<int> fromS = dijkstra1(0, 0);\n  if(fromL[0] == 0) return 0;\n  vector<vector<int> > cost(n, vector<int>(2, INF));\n  priority_queue<State> que;\n  cost[N][0] = 0;\n  que.push((State){N, 0, 0});\n  while(que.size()) {\n    const State s = que.top(); que.pop();\n    if(cost[s.v][s.f] < s.cost) continue;\n    if(s.f == 0) do {\n\tconst State t = {s.v, 1, s.cost + fromL[s.v]};\n\tif(cost[t.v][t.f] <= t.cost) continue;\n\tcost[t.v][t.f] = t.cost;\n\tque.push(t);\n      } while(0);\n    for(int i = 0; i < g[s.v].size(); ++i) {\n      const Edge &e = g[s.v][i];\n      if(e.w == 0) continue;\n      const State t = {e.v, s.f, s.cost + e.w};\n      if(cost[t.v][t.f] <= t.cost) continue;\n      cost[t.v][t.f] = t.cost;\n      que.push(t);\n    }\n  }\n  int res = INF;\n  for(int i = 0; i < n; ++i) {\n    res = min(res, cost[i][1] + fromS[i]);\n  }\n  return res;\n}\n\nint main() {\n  int T; cin >> T;\n  while(T--) {\n    cin >> n >> m;\n    ++n;\n    cin >> N >> L;\n    g = Graph(n);\n    for(int i = 0; i < m; ++i) {\n      int a, b; char c;\n      cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c == 'N'});\n      g[b].push_back((Edge){a, c == 'N'});\n    }\n    cout << dijkstra2() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Edge {\n  int dst,weight;\n  bool type[2]; // 0 -> hito, 1 -> nyanko\n  Edge(int dst=-1,int weight=0,bool a=false,bool b=false) : dst(dst), weight(weight) {\n    type[0] = a, type[1] = b;\n  }\n};\n\nconst int MAX_V = 100100;\nint V,E,Natsume,Lennon;\nvector<Edge> G[MAX_V];\nint par[MAX_V],rank[MAX_V];\n\ninline void init(int n=MAX_V){ rep(i,n) par[i] = i, rank[i] = 0; }\n\nint find(int x) {\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) {\n    if( rank[x] > rank[y] ) par[y] = x;\n    else {\n      par[x] = y;\n      if( par[x] == par[y] ) ++rank[y];\n    }\n  }\n}\n\nvoid draw(int sp,int type){\n  deque<int> deq;\n  deq.push_back(sp);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()){\n      int next = G[cur][i].dst;\n      if( !G[cur][i].type[type] ) continue;\n      if( find(cur) != find(next) ) {\n        unit(cur,next);\n        deq.push_back(next);\n      }\n    }\n  }\n}\n\nconst int IINF = INT_MAX;\nint mindist[3][MAX_V]; // 0-> Natsume, 1-> Summer, 2-> Lennon\n\nvoid calc(int stype,vector<int> &sp){\n  rep(i,V) mindist[stype][i] = IINF;\n  deque<int> deq;\n  rep(i,sp.size()) {\n    mindist[stype][sp[i]] = 0;\n    deq.push_back(sp[i]);\n  }\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,G[cur].size()){\n      int next = G[cur][i].dst;\n      if( !G[cur][i].type[0] ) continue;\n      if( mindist[stype][next] > mindist[stype][cur] + 1 ){\n        mindist[stype][next] = mindist[stype][cur] + 1;\n        deq.push_back(next);\n      }\n    }\n  }\n}\n\nvoid compute(){\n  draw(0,1);\n  draw(Lennon,1);\n  if( find(0) == find(Lennon) ) { puts(\"0\"); return; }\n  vector<int> sp;\n  sp.push_back(Natsume);\n  calc(0,sp);\n  sp.clear();\n\n  rep(i,V) if( find(0) == find(i) ) sp.push_back(i);\n  calc(1,sp);\n  sp.clear();\n\n  rep(i,V) if( find(Lennon) == find(i) ) sp.push_back(i);\n  calc(2,sp);\n  \n  int mini = IINF;\n  rep(i,V) if( mindist[0][i] != IINF && mindist[1][i] != IINF && mindist[2][i] != IINF ) {\n    mini = min(mini,mindist[0][i]+mindist[1][i]+mindist[2][i]);\n  }\n\n  cout << mini << endl;\n\n}\n\nint main(int argc,char** argv){\n  int T;\n  cin >> T;\n  while( T-- ) {\n    cin >> V >> E;\n    cin >> Natsume >> Lennon;\n    ++V;\n    rep(i,V) G[i].clear();\n    init(V);\n    rep(_,E){\n      int s,t;\n      char c;\n      cin >> s >> t >> c;\n      if( c == 'N' ) {\n        G[s].push_back(Edge(t,1,true,false));\n        G[t].push_back(Edge(s,1,true,false));\n      } else {\n        G[s].push_back(Edge(t,0,false,true));\n        G[t].push_back(Edge(s,0,false,true));\n      }\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint N, M, hs, cs;\n\nvoid dfs(int n, set<int> &S, vector< vector<int> > &es){\n  S.insert(n);\n  for(int next : es[n]) if(S.find(next) == S.end()) dfs(next, S, es);\n}\n\nvoid bfs(vector< vector<int> > &es, queue<int> &open, vector<int> &closed){\n  while(!open.empty()){\n    int now = open.front(), cost = closed[now]; open.pop();\n    for(int next : es[now]){\n      if(closed[next] > cost + 1){\n        closed[next] = cost + 1;\n        open.push(next);\n      }\n    }\n  }\n}\n\nint main() {\n  int T; cin >>T;\n  while(T--){\n    cin >>N >>M >>hs >>cs;\n    N++;\n    vector< vector<int> > hes(N), ces(N);\n    REP(i, M){\n      int a, b; char c; cin >>a >>b >>c;\n      if(c == 'N') { hes[a].push_back(b); hes[b].push_back(a); }\n      else { ces[a].push_back(b); ces[b].push_back(a); }\n    }\n\n    set<int> X, Y;\n    dfs(cs, X, ces); dfs(0, Y, ces);\n\n    vector<int> A, B, C, ac(N, INF), bc(N, INF), cc(N, INF);\n    queue<int> aq, bq, cq;\n    aq.push(hs); ac[hs] = 0;\n    for(int n : X) { bq.push(n); bc[n] = 0; }\n    for(int n : Y) { cq.push(n); cc[n] = 0; }\n    bfs(hes, aq, ac);\n    bfs(hes, bq, bc);\n    bfs(hes, cq, cc);\n\n    int ans = INF;\n    REP(i, N) ans = min(ans, ac[i] + bc[i] + cc[i]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint nmemo[100001];\nint nlmemo[100001];\nint nsmemo[100001];\nint lmemo[100001];\nint smemo[100001];\n\nvoid make_memo(const vector<vector<int> > &door, int *memo, const vector<int> &start){\n  queue<int> q;\n  FOR(it, start){ memo[*it] = 0; q.push(*it); }\n  while(q.size()){\n    int pos = q.front(); q.pop(); int cnt = memo[pos];\n    FOR(it, door[pos]) if(memo[*it] == -1){\n      memo[*it] = cnt + 1; q.push(*it);\n    }\n  }\n}\n\nint main(){\n  int c; scanf(\"%d\", &c);\n  while(c --> 0){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    \n    int natsume, lenon;\n    scanf(\"%d%d\", &natsume, &lenon);\n\n    vector<vector<int> > ndoor(n+1);\n    vector<vector<int> > ldoor(n+1);\n\n    REP(i, m){\n      int a, b; char p;\n      scanf(\"%d%d %c\", &a, &b, &p);\n      if(p == 'N'){\n\tndoor[a].push_back(b);\n\tndoor[b].push_back(a);\n      }else{\n\tldoor[a].push_back(b);\n\tldoor[b].push_back(a);\n      }\n    }\n\n    REP(i, n+1) nsmemo[i] = nlmemo[i] = nmemo[i] = lmemo[i] = smemo[i] = -1;\n\n    make_memo(ndoor, nmemo, vector<int>(1, natsume));\n    make_memo(ldoor, lmemo, vector<int>(1, lenon));\n    make_memo(ldoor, smemo, vector<int>(1, 0));\n\n    vector<int> l; REP(i, n+1) if(lmemo[i] != -1) l.push_back(i);\n    vector<int> s; REP(i, n+1) if(smemo[i] != -1) s.push_back(i);\n    make_memo(ndoor, nlmemo, l);\n    make_memo(ndoor, nsmemo, s);\n\n    int ans = INT_MAX;\n    REP(i, n+1) if(nmemo[i] != -1 && nsmemo[i] != -1 && nlmemo[i] != -1)\n      ans = min(ans, nmemo[i] + nsmemo[i] + nlmemo[i]);\n\n    print(ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct Edge {\n  int dst;\n  char c;\n};\n\ntypedef vector<vector<Edge> > G;\nconst int N = 100005;\nbool visited[N];\n\nvoid bfs(const G &g, int s, vector<int> &v) {\n  int n = g.size();\n  REP(i,n) visited[i] = 0;\n  queue<int> Q; Q.push(s);\n  visited[s] = 1;\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    v.push_back(now);\n    FOR(it, g[now]) {\n      if (it->c == 'N') continue;\n      int dst = it->dst;\n      if (!visited[dst]) {\n        visited[dst] = 1;\n        Q.push(dst);\n      }\n    }\n  }\n}\n\nvoid bfs2(const G &g, const vector<int> &v, int *dist) {\n  int n = g.size();\n  REP(i,n) dist[i] = INF;\n  queue<int> Q;\n  FOR(it, v) {\n    Q.push(*it);\n    dist[*it] = 0;\n  }\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    FOR(it, g[now]) {\n      if (it->c == 'L') continue;\n      int dst = it->dst;\n      if (dist[dst] == INF) {\n        dist[dst] = dist[now] + 1;\n        Q.push(dst);\n      }\n    }\n  }\n}\n\nint dist1[N];\nint dist2[N];\nint dist3[N];\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    int n, m;\n    cin >> n >> m;\n    int ns, ls;\n    cin >> ns >> ls;\n    G g(n+1);\n    REP(i,m) {\n      char c;\n      int a,b;\n      cin >> a >> b >> c;\n      g[a].push_back((Edge){b,c});\n      g[b].push_back((Edge){a,c});\n    }\n    vector<int> vA;             // レノンがいる場所から自由にいける場所\n    vector<int> vB;             // 夏への扉から自由にいける場所\n    bfs(g,ls,vA);\n    bfs(g,0,vB);\n    bfs2(g,vA,dist1);\n    bfs2(g,vB,dist2);\n    bfs2(g,vector<int>(1,ns),dist3);\n    int ans = INF;\n    REP(i,n+1) {\n      //cout << dist1[i] << \" \" << dist2[i] << \" \" << dist3[i] << endl;\n      ans = min(ans, dist1[i]+dist2[i]+dist3[i]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass union_find{\n\tvector<int> a;\npublic:\n\tunion_find(int n):a(n,-1){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){ a[x]+=a[y]; a[y]=x; }\n\t}\n};\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint n,m,natsume,renon; scanf(\"%d%d%d%d\",&n,&m,&natsume,&renon);\n\t\tstatic vector<int> G[100001]; // Natsume graph\n\t\tunion_find U(n+1);\n\t\trep(i,m){\n\t\t\tint u,v;\n\t\t\tchar c; scanf(\"%d%d %c\",&u,&v,&c);\n\t\t\tif(c=='N'){\n\t\t\t\tG[u].push_back(v);\n\t\t\t\tG[v].push_back(u);\n\t\t\t}\n\t\t\telse U.unite(u,v);\n\t\t}\n\n\t\tif(U.find(renon)==U.find(0)){ puts(\"0\"); continue; }\n\n\t\tstatic int d1[100001]; // d1[u] := dist(Natsume,u)\n\t\trep(u,n+1) d1[u]=INF;\n\t\t{\n\t\t\tint head=0,tail=0;\n\t\t\tstatic int Q[100001];\n\t\t\td1[natsume]=0;\n\t\t\tQ[tail++]=natsume;\n\t\t\twhile(head<tail){\n\t\t\t\tint u=Q[head++];\n\t\t\t\trep(i,G[u].size()){\n\t\t\t\t\tint v=G[u][i];\n\t\t\t\t\tif(d1[v]==INF) d1[v]=d1[u]+1, Q[tail++]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic int d2[100001]; // d2[u] := dist(Renon,u)\n\t\trep(u,n+1) d2[u]=INF;\n\t\t{\n\t\t\tint head=0,tail=0;\n\t\t\tstatic int Q[100001];\n\t\t\trep(u,n+1) if(U.find(u)==U.find(renon)) d2[u]=0, Q[tail++]=u;\n\t\t\twhile(head<tail){\n\t\t\t\tint u=Q[head++];\n\t\t\t\trep(i,G[u].size()){\n\t\t\t\t\tint v=G[u][i];\n\t\t\t\t\tif(d2[v]==INF) d2[v]=d2[u]+1, Q[tail++]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic int d3[100001]; // d3[u] := dist(summer,u)\n\t\trep(u,n+1) d3[u]=INF;\n\t\t{\n\t\t\tint head=0,tail=0;\n\t\t\tstatic int Q[100001];\n\t\t\trep(u,n+1) if(U.find(u)==U.find(0)) d3[u]=0, Q[tail++]=u;\n\t\t\twhile(head<tail){\n\t\t\t\tint u=Q[head++];\n\t\t\t\trep(i,G[u].size()){\n\t\t\t\t\tint v=G[u][i];\n\t\t\t\t\tif(d3[v]==INF) d3[v]=d3[u]+1, Q[tail++]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=INF;\n\t\trep(u,n+1) ans=min(ans,d1[u]+d2[u]+d3[u]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint N, M, hs, cs;\n\nvoid dfs(int n, set<int> &S, vector< vector<int> > &es){\n  S.insert(n);\n  for(int next : es[n]) if(S.find(next) == S.end()) dfs(next, S, es);\n}\n\nvoid bfs(vector< vector<int> > &es, queue<int> &open, vector<int> &closed){\n  while(!open.empty()){\n    int now = open.front(), cost = closed[now]; open.pop();\n    for(int next : es[now]){\n      if(closed[next] > cost + 1){\n        closed[next] = cost + 1;\n        open.push(next);\n      }\n    }\n  }\n}\n\nint main() {\n  int T; cin >>T;\n  while(T--){\n    cin >>N >>M >>hs >>cs;\n    N++;\n    vector< vector<int> > hes(N), ces(N);\n    REP(i, M){\n      int a, b; char c; cin >>a >>b >>c;\n      if(c == 'N') { hes[a].push_back(b); hes[b].push_back(a); }\n      else { ces[a].push_back(b); ces[b].push_back(a); }\n    }\n\n    set<int> X, Y;\n    dfs(cs, X, ces); dfs(0, Y, ces);\n    if(X == Y) { cout <<0 <<endl; continue; }\n\n    vector<int> A, B, C, ac(N, INF), bc(N, INF), cc(N, INF);\n    queue<int> aq, bq, cq;\n    aq.push(hs); ac[hs] = 0;\n    for(int n : X) { bq.push(n); bc[n] = 0; }\n    for(int n : Y) { cq.push(n); cc[n] = 0; }\n    bfs(hes, aq, ac);\n    bfs(hes, bq, bc);\n    bfs(hes, cq, cc);\n\n    int ans = INF;\n    REP(i, N) ans = min(ans, ac[i] + bc[i] + cc[i]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nvector<vector<int> > h_edges, c_edges;\n\nvoid dfs1(set<int> &ss,int start) {\n    queue<int> q; q.push(start); ss.insert(start);\n    while(!q.empty()) {\n        int ns = q.front(); q.pop();\n        for(int i=0; i<c_edges[ns].size(); ++i)\n            if(ss.find(c_edges[ns][i]) == ss.end()) {\n                q.push(c_edges[ns][i]);\n                ss.insert(c_edges[ns][i]);\n            }\n    }\n}\n\nvoid bfs(queue<int> &q,vector<int> &dist) {\n    while(!q.empty()) {\n        int ns = q.front(); q.pop();\n        for(int i=0; i<h_edges[ns].size(); ++i) {\n            if(dist[h_edges[ns][i]] > dist[ns]+1) {\n                dist[h_edges[ns][i]] = dist[ns]+1;\n                q.push(h_edges[ns][i]);\n            }\n        }\n    }\n}\n\nint main() {\n    int n,m,tc,a,b,h_start,c_start;\n    string s;\n    cin>>tc;\n\n    while(tc--) {\n        cin>>n>>m;\n        cin>>h_start>>c_start;\n        h_edges.clear(); c_edges.clear();\n        h_edges.resize(n+1); c_edges.resize(n+1);\n\n        for(int i=0; i<m; ++i) {\n            cin>>a>>b>>s;\n            if(s == \"N\") {\n                h_edges[a].push_back(b);\n                h_edges[b].push_back(a);\n            }else{\n                c_edges[a].push_back(b);\n                c_edges[b].push_back(a);\n            }\n        }\n\n        set<int> canReach,fromGoal;\n        // dfs1\n        dfs1(canReach, c_start);\n        dfs1(fromGoal, 0);\n\n        if(canReach.find(0) != canReach.end()) {\n            cout<<0<<endl;\n            continue;\n        }\n\n        queue<int> q;\n        vector<int> d1(n+1,1<<29), d2(n+1, 1<<29), d3(n+1, 1<<29);\n        d1[h_start] = 0; q.push(h_start);\n        bfs(q,d1);\n\n//        cout<<canReach.size()<<endl;\n        for(set<int>::iterator it = canReach.begin();\n            it != canReach.end(); ++it) {\n            q.push(*it); d2[*it] = 0;\n        }\n        bfs(q,d2);\n\n        for(set<int>::iterator it = fromGoal.begin();\n            it != fromGoal.end(); ++it) {\n            q.push(*it); d3[*it] = 0;\n        }\n        bfs(q,d3);\n\n        int ans = 1<<29;\n        for(int i=0; i<=n; ++i) {\n//            cout<<i<<\" -> \"<<d1[i]<<\",\"<<d2[i]<<\",\"<<d3[i]<<endl;\n            ans = min(ans, d1[i]+d2[i]+d3[i]);\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint nmemo[100001];\nint nlmemo[100001];\nint nsmemo[100001];\nint lmemo[100001];\nint smemo[100001];\n\nvoid make_memo(const vector<vector<int> > &door, int *memo, const vector<int> &start){\n  queue<int> q;\n  FOR(it, start){ memo[*it] = 0; q.push(*it); }\n  while(q.size()){\n    int pos = q.front(); q.pop(); int cnt = memo[pos];\n    FOR(it, door[pos]) if(memo[*it] == -1){\n      memo[*it] = cnt + 1; q.push(*it);\n    }\n  }\n}\n\nint main(){\n  int c; scanf(\"%d\", &c);\n  while(c --> 0){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    \n    int natsume, lenon;\n    scanf(\"%d%d\", &natsume, &lenon);\n\n    vector<vector<int> > ndoor(n+1);\n    vector<vector<int> > ldoor(n+1);\n\n    REP(i, m){\n      int a, b; char p;\n      scanf(\"%d%d %c\", &a, &b, &p);\n      if(p == 'N'){\n\tndoor[a].push_back(b);\n\tndoor[b].push_back(a);\n      }else{\n\tldoor[a].push_back(b);\n\tldoor[b].push_back(a);\n      }\n    }\n\n    REP(i, n+1) nsmemo[i] = nlmemo[i] = nmemo[i] = lmemo[i] = smemo[i] = -1;\n\n    make_memo(ndoor, nmemo, vector<int>(1, natsume));\n    make_memo(ldoor, lmemo, vector<int>(1, lenon));\n    make_memo(ldoor, smemo, vector<int>(1, 0));\n\n    if(lmemo[0] != -1){\n      print(0);\n    }else{\n      vector<int> l; REP(i, n+1) if(lmemo[i] != -1) l.push_back(i);\n      vector<int> s; REP(i, n+1) if(smemo[i] != -1) s.push_back(i);\n      make_memo(ndoor, nlmemo, l);\n      make_memo(ndoor, nsmemo, s);\n      \n      int ans = INT_MAX;\n      REP(i, n+1) if(nmemo[i] != -1 && nsmemo[i] != -1 && nlmemo[i] != -1)\n\tans = min(ans, nmemo[i] + nsmemo[i] + nlmemo[i]);\n      \n      print(ans);\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct Edge {\n  int v, w;\n};\n \ntypedef vector<vector<Edge> > Graph;\ntypedef pair<int, int> Pair;\n \nconst int INF = 1<<28;\n \nint n, m, N, L;\nGraph g;\n \nvector<int> dijkstra(int src) {\n  vector<int> cost(n, INF);\n  priority_queue<Pair, vector<Pair>, greater<Pair> > que;\n  cost[src] = 0;\n  que.push(Pair(0, src));\n  while(que.size()) {\n    const Pair s = que.top(); que.pop();\n    if(cost[s.second] < s.first) continue;\n    for(int i = 0; i < g[s.second].size(); ++i) {\n      const Edge &e = g[s.second][i];\n      if(s.first && !e.w) continue; //\n      const Pair t(s.first + e.w, e.v);\n      if(cost[t.second] <= t.first) continue;\n      cost[t.second] = t.first;\n      que.push(t);\n    }\n  }\n  return cost;\n}\n \nstruct State {\n  int v, f, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n \nint main() {\n  int T; cin >> T;\n  while(T--) {\n    cin >> n >> m;\n    ++n;\n    cin >> N >> L;\n    g = Graph(n);\n    for(int i = 0; i < m; ++i) {\n      int a, b; char c;\n      cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c == 'N'});\n      g[b].push_back((Edge){a, c == 'N'});\n    }\n    vector<int> fromN = dijkstra(N);\n    vector<int> fromL = dijkstra(L);\n    vector<int> fromS = dijkstra(0);\n    if(fromL[0] == 0) {\n      cout << 0 << endl;\n      continue;\n    }\n    int res = INF;\n    for(int i = 0; i < n; ++i) {\n      res = min(res, fromN[i] + fromL[i] + fromS[i]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nvoid catMove(const vector<vector<int> >& edges, int start, vector<bool>& move)\n{\n    int n = edges.size();\n    move.assign(n, false);\n    move[start] = true;\n    queue<int> q;\n    q.push(start);\n\n    while(!q.empty()){\n        int s = q.front();\n        q.pop();\n        for(unsigned i=0; i<edges[s].size(); ++i){\n            int t = edges[s][i];\n            if(!move[t]){\n                move[t] = true;\n                q.push(t);\n            }\n        }\n    }\n}\n\nvoid humanMove(const vector<vector<int> >& edges, const vector<bool>& start, vector<int>& cost)\n{\n    int n = edges.size();\n    cost.assign(n, INF);\n    queue<int> q;\n    for(int i=0; i<n; ++i){\n        if(start[i]){\n            cost[i] = 0;\n            q.push(i);\n        }\n    }\n\n    while(!q.empty()){\n        int s = q.front();\n        q.pop();\n        for(unsigned i=0; i<edges[s].size(); ++i){\n            int t = edges[s][i];\n            if(cost[t] == INF){\n                cost[t] = cost[s] + 1;\n                q.push(t);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int d;\n    cin >> d;\n\n    while(--d >= 0){\n        int n, m, sh, sc;\n        cin >> n >> m >> sh >> sc;\n\n        vector<vector<int> > edgesH(n+1), edgesC(n+1);\n        for(int i=0; i<m; ++i){\n            int a, b;\n            char c;\n            cin >> a >> b >> c;\n\n            if(c == 'N'){\n                edgesH[a].push_back(b);\n                edgesH[b].push_back(a);\n            }else{\n                edgesC[a].push_back(b);\n                edgesC[b].push_back(a);\n            }\n        }\n\n        vector<bool> move1, move2;\n        catMove(edgesC, 0, move1);\n        catMove(edgesC, sc, move2);\n\n        vector<bool> move3(n+1);\n        move3[sh] = true;\n\n        vector<int> cost1, cost2, cost3;\n        humanMove(edgesH, move1, cost1);\n        humanMove(edgesH, move2, cost2);\n        humanMove(edgesH, move3, cost3);\n\n        int ret = INF;\n        for(int i=0; i<=n; ++i)\n            ret = min(ret, cost1[i] + cost2[i] + cost3[i]);\n        cout << ret << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nvoid catMove(const vector<vector<int> >& edges, int start, vector<bool>& move)\n{\n    int n = edges.size();\n    move.assign(n, false);\n    move[start] = true;\n    queue<int> q;\n    q.push(start);\n\n    while(!q.empty()){\n        int s = q.front();\n        q.pop();\n        for(unsigned i=0; i<edges[s].size(); ++i){\n            int t = edges[s][i];\n            if(!move[t]){\n                move[t] = true;\n                q.push(t);\n            }\n        }\n    }\n}\n\nvoid humanMove(const vector<vector<int> >& edges, const vector<bool>& start, vector<int>& cost)\n{\n    int n = edges.size();\n    cost.assign(n, INF);\n    queue<int> q;\n    for(int i=0; i<n; ++i){\n        if(start[i]){\n            cost[i] = 0;\n            q.push(i);\n        }\n    }\n\n    while(!q.empty()){\n        int s = q.front();\n        q.pop();\n        for(unsigned i=0; i<edges[s].size(); ++i){\n            int t = edges[s][i];\n            if(cost[t] == INF){\n                cost[t] = cost[s] + 1;\n                q.push(t);\n            }\n        }\n    }\n}\n\nint main()\n{\n    int d;\n    cin >> d;\n\n    while(--d >= 0){\n        int n, m, sh, sc;\n        cin >> n >> m >> sh >> sc;\n\n        vector<vector<int> > edgesH(n+1), edgesC(n+1);\n        for(int i=0; i<m; ++i){\n            int a, b;\n            char c;\n            cin >> a >> b >> c;\n\n            if(c == 'N'){\n                edgesH[a].push_back(b);\n                edgesH[b].push_back(a);\n            }else{\n                edgesC[a].push_back(b);\n                edgesC[b].push_back(a);\n            }\n        }\n\n        vector<bool> move1, move2;\n        catMove(edgesC, 0, move1);\n        catMove(edgesC, sc, move2);\n\n        vector<bool> move3(n+1);\n        move3[sh] = true;\n\n        if(move1[sc]){\n            cout << 0 << endl;\n            continue;\n        }\n\n        vector<int> cost1, cost2, cost3;\n        humanMove(edgesH, move1, cost1);\n        humanMove(edgesH, move2, cost2);\n        humanMove(edgesH, move3, cost3);\n\n        int ret = INF;\n        for(int i=0; i<=n; ++i)\n            ret = min(ret, cost1[i] + cost2[i] + cost3[i]);\n        cout << ret << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nconst int N = 100000;\nconst int inf = ( 1 << 21);\n\n\nclass Edge{\npublic:\n  int next,c;\n};\n\nclass state{\npublic:\n  int now,c;\n  bool operator<(const state & a)const{\n    return c > a.c;\n  }\n};\n\nvoid dijkstra(vector<int>&ini,int n,vector<Edge> *edge,int *cost){\n  rep(i,n)cost[i]=inf;\n  \n  priority_queue<state>  Q;\n  rep(i,ini.size()){\n    Q.push((state){ini[i],0});\n  }\n  \n  while(!Q.empty()){\n    state now = Q.top();Q.pop();\n    if (cost[now.now] != inf)continue;\n    cost[now.now]=now.c;\n    rep(i,edge[now.now].size()){\n      int next=edge[now.now][i].next,nec=now.c+edge[now.now][i].c;\n      Q.push((state){next,nec});\n    }\n  }\n}\n\nvector<Edge> Ledge[N],Nedge[N];\nint Lcost[N],Scost[N],Ncost[N];\nint LBFS[N],SBFS[N];\n\ntemplate<class T> void op(T &in,int n){rep(i,n)cout<<in[i]<<' ';cout << endl;}\n\nint solve(int n,int L,int S,int N){\n  vector<int> ini;\n  ini.push_back(L);\n  dijkstra(ini,n,Ledge,LBFS);\n  //  op(LBFS,n);\n  if (LBFS[S] != inf)return 0;//natune is not needed\n  ini.clear();\n\n  \n\n  ini.push_back(S);\n  dijkstra(ini,n,Ledge,SBFS);\n  ini.clear();\n\n  //  op(SBFS,n);\n\n\n  vector<int> Lini,Nini,Sini;\n  Nini.push_back(N);\n  rep(i,n){\n    if (LBFS[i] != inf)Lini.push_back(i);\n    if (SBFS[i] != inf)Sini.push_back(i);\n  }\n\n  dijkstra(Lini,n,Nedge,Lcost);\n  dijkstra(Sini,n,Nedge,Scost);\n  dijkstra(Nini,n,Nedge,Ncost);\n\n  \n  int ans = inf;\n  rep(i,n){\n    //if (LBFS[i] == inf && SBFS[i] == inf)\n      ans=min(ans,Ncost[i]+Scost[i]+Lcost[i]);\n  }\n  return ans;\n}\n\n\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    int n,m;\n    cin>>n >>m;\n    n++;\n    rep(i,n)Nedge[i].clear(),Ledge[i].clear();\n    int S = 0,L,N;\n    cin>>N>>L;\n\n    rep(i,m){\n      int f,t;\n      char k;\n      cin>>f>>t>>k;\n      if (k == 'L'){\n\tLedge[f].pb((Edge){t,1});\n\tLedge[t].pb((Edge){f,1});\n      }else if (k == 'N'){\n\tNedge[f].pb((Edge){t,1});\n\tNedge[t].pb((Edge){f,1});\n      }\n    }\n    cout << solve(n,L,S,N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#include <numeric>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <array>\n#include <string>\n#include <stack>\n#include <cassert>\n#include <memory>\n#include <random>\n\n\nint main() {\n\tint t; std::cin >> t;\n\tfor (; t > 0; --t) {\n\t\tint n, m; std::cin >> n >> m;\n\t\tint human_start, cat_start; std::cin >> human_start >> cat_start;\n\t\tstd::vector<std::vector<int>> rooms(n + 1), for_cat(n + 1);\n\t\tfor (auto i = 0; i < m; ++i) {\n\t\t\tint a, b; std::string type; std::cin >> a >> b >> type;\n\t\t\tif (type == \"N\") {\n\t\t\t\trooms[a].push_back(b);\n\t\t\t\trooms[b].push_back(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor_cat[a].push_back(b);\n\t\t\t\tfor_cat[b].push_back(a);\n\t\t\t}\n\t\t}\n\t\tstd::queue<int> queue;\n\t\tstd::vector<bool> can_move_from_start(n + 1, false), can_move_to_goal(n + 1, false);\n\t\tcan_move_from_start[cat_start] = true; queue.push(cat_start);\n\t\twhile (!queue.empty()) {\n\t\t\tconst auto top = queue.front(); queue.pop();\n\t\t\tfor (const auto next : for_cat[top]) if (!can_move_from_start[next]) {\n\t\t\t\tcan_move_from_start[next] = true;\n\t\t\t\tqueue.push(next);\n\t\t\t}\n\t\t}\n\t\tcan_move_to_goal[0] = true; queue.push(0);\n\t\twhile (!queue.empty()) {\n\t\t\tconst auto top = queue.front(); queue.pop();\n\t\t\tfor (const auto next : for_cat[top]) if (!can_move_to_goal[next]) {\n\t\t\t\tcan_move_to_goal[next] = true;\n\t\t\t\tqueue.push(next);\n\t\t\t}\n\t\t}\n\t\tstd::vector<int> from_start(n + 1, INT_MAX), to_goal(n + 1, INT_MAX), from_cat(n + 1, INT_MAX);\n\t\tfor (auto i = 0; i < can_move_to_goal.size(); ++i) if (can_move_to_goal[i]) {\n\t\t\tto_goal[i] = 0; queue.push(i);\n\t\t}\n\t\twhile (!queue.empty()) {\n\t\t\tconst auto top = queue.front(); queue.pop();\n\t\t\tfor (const auto next : rooms[top]) if (to_goal[next] == INT_MAX) {\n\t\t\t\tto_goal[next] = to_goal[top] + 1;\n\t\t\t\tqueue.push(next);\n\t\t\t}\n\t\t}\n\t\tfrom_start[human_start] = 0; queue.push(human_start);\n\t\twhile (!queue.empty()) {\n\t\t\tconst auto top = queue.front(); queue.pop();\n\t\t\tfor (const auto next : rooms[top]) if (from_start[next] == INT_MAX) {\n\t\t\t\tfrom_start[next] = from_start[top] + 1;\n\t\t\t\tqueue.push(next);\n\t\t\t}\n\t\t}\n\t\tfor (auto i = 0; i < can_move_from_start.size(); ++i) if (can_move_from_start[i]) {\n\t\t\tfrom_cat[i] = 0; queue.push(i);\n\t\t}\n\t\twhile (!queue.empty()) {\n\t\t\tconst auto top = queue.front(); queue.pop();\n\t\t\tfor (const auto next : rooms[top]) if (from_cat[next] == INT_MAX) {\n\t\t\t\tfrom_cat[next] = from_cat[top] + 1;\n\t\t\t\tqueue.push(next);\n\t\t\t}\n\t\t}\n\t\tint min_open = INT_MAX;\n\t\tfor (auto i = 0; i < n + 1; ++i) {\n\t\t\tif (from_start[i] == INT_MAX || to_goal[i] == INT_MAX || from_cat[i] == INT_MAX) continue;\n\t\t\tif (can_move_from_start[i] && can_move_to_goal[i]) {\n\t\t\t\tmin_open = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin_open = std::min(min_open, from_start[i] + to_goal[i] + from_cat[i]);\n\t\t}\n\t\tstd::cout << min_open << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct Edge {\n  int v, w;\n};\n \ntypedef vector<vector<Edge> > Graph;\ntypedef pair<int, int> Pair;\n \nconst int INF = 1<<28;\n \nint n, m, N, L;\nGraph g;\n \nvector<int> dijkstra(int src, int scost) {\n  vector<int> cost(n, INF);\n  priority_queue<Pair, vector<Pair>, greater<Pair> > que;\n  cost[src] = scost;\n  que.push(Pair(scost, src));\n  while(que.size()) {\n    const Pair s = que.top(); que.pop();\n    if(cost[s.second] < s.first) continue;\n    for(int i = 0; i < g[s.second].size(); ++i) {\n      const Edge &e = g[s.second][i];\n      if(s.first && !e.w) continue; //\n      const Pair t(s.first + e.w, e.v);\n      if(cost[t.second] <= t.first) continue;\n      cost[t.second] = t.first;\n      que.push(t);\n    }\n  }\n  return cost;\n}\n \nstruct State {\n  int v, f, cost;\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n \nint main() {\n  int T; cin >> T;\n  while(T--) {\n    cin >> n >> m;\n    ++n;\n    cin >> N >> L;\n    g = Graph(n);\n    for(int i = 0; i < m; ++i) {\n      int a, b; char c;\n      cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c == 'N'});\n      g[b].push_back((Edge){a, c == 'N'});\n    }\n    vector<int> fromN = dijkstra(N, 1);\n    vector<int> fromL = dijkstra(L, 0);\n    vector<int> fromS = dijkstra(0, 0);\n    if(fromL[0] == 0) {\n      cout << 0 << endl;\n      continue;\n    }\n    int res = INF;\n    for(int i = 0; i < n; ++i) {\n      res = min(res, fromN[i] + fromL[i] + fromS[i] - 1);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\nconst int N = 100005;\nconst int inf = ( 1 << 21);\n\n\nclass Edge{\npublic:\n  int next,c;\n};\n\nclass state{\npublic:\n  int now,c;\n  bool operator<(const state & a)const{\n    return c > a.c;\n  }\n};\n\nvoid dijkstra(vector<int>&ini,int n,vector<Edge> *edge,int *cost){\n  rep(i,n)cost[i]=inf;\n  \n  priority_queue<state>  Q;\n  rep(i,ini.size()){\n    Q.push((state){ini[i],0});\n  }\n  \n  while(!Q.empty()){\n    state now = Q.top();Q.pop();\n    if (cost[now.now] != inf)continue;\n    cost[now.now]=now.c;\n    rep(i,edge[now.now].size()){\n      int next=edge[now.now][i].next,nec=now.c+edge[now.now][i].c;\n      Q.push((state){next,nec});\n    }\n  }\n}\n\nvector<Edge> Ledge[N],Nedge[N];\nint Lcost[N],Scost[N],Ncost[N];\nint LBFS[N],SBFS[N];\n\ntemplate<class T> void op(T &in,int n){rep(i,n)cout<<in[i]<<' ';cout << endl;}\n\nint solve(int n,int L,int S,int N){\n  vector<int> ini;\n  ini.push_back(L);\n  dijkstra(ini,n,Ledge,LBFS);\n  //  op(LBFS,n);\n  if (LBFS[S] != inf)return 0;//natune is not needed\n  ini.clear();\n\n  \n\n  ini.push_back(S);\n  dijkstra(ini,n,Ledge,SBFS);\n  ini.clear();\n\n  //  op(SBFS,n);\n\n\n  vector<int> Lini,Nini,Sini;\n  Nini.push_back(N);\n  rep(i,n){\n    if (LBFS[i] != inf)Lini.push_back(i);\n    if (SBFS[i] != inf)Sini.push_back(i);\n  }\n\n  dijkstra(Lini,n,Nedge,Lcost);\n  dijkstra(Sini,n,Nedge,Scost);\n  dijkstra(Nini,n,Nedge,Ncost);\n\n  \n  int ans = inf;\n  rep(i,n){\n    //if (LBFS[i] == inf && SBFS[i] == inf)\n      ans=min(ans,Ncost[i]+Scost[i]+Lcost[i]);\n  }\n  return ans;\n}\n\n\nmain(){\n  int te;\n  cin>>te;\n  while(te--){\n    int n,m;\n    cin>>n >>m;\n    n++;\n    rep(i,n)Nedge[i].clear(),Ledge[i].clear();\n    int S = 0,L,N;\n    cin>>N>>L;\n\n    rep(i,m){\n      int f,t;\n      char k;\n      cin>>f>>t>>k;\n      if (k == 'L'){\n\tLedge[f].pb((Edge){t,1});\n\tLedge[t].pb((Edge){f,1});\n      }else if (k == 'N'){\n\tNedge[f].pb((Edge){t,1});\n\tNedge[t].pb((Edge){f,1});\n      }\n    }\n    cout << solve(n,L,S,N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef vector<int> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Node {\n  int state;\n  int from;\n  int cost;\n  Node(int state, int from, int cost) :\n    state(state), from(from), cost(cost) {;}\n  bool operator<(const Node &rhs) const {\n    return cost > rhs.cost;\n  }\n};\n\nint natume;\nint lennon;\nint n, m;\nGraph mainG;\nGraph nekoG;\nbool end[100010];\nint dist[100010];\nbool visit[2][100010];\n\nint main() {\n  int test;\n  scanf(\"%d\", &test);\n  while (test--) {\n    MEMSET(dist, 0x0f);\n    MEMSET(end, false);\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%d %d\", &natume, &lennon);\n    mainG = Graph(n + 1);\n    nekoG = Graph(n + 1);\n    REP(i, m) {\n      int f, t;\n      char c;\n      scanf(\"%d %d %c\", &f, &t, &c);\n      if (c == 'N') {\n        mainG[f].push_back(t);\n        mainG[t].push_back(f);\n      } else {\n        nekoG[f].push_back(t);\n        nekoG[t].push_back(f);\n      }\n    }\n\n    // clac end\n    {\n      queue<int> que;\n      que.push(lennon);\n      end[lennon] = true;\n      while (!que.empty()) {\n        int from = que.front();\n        que.pop();\n        FORIT(it, nekoG[from]) {\n          int to = *it;\n          if (end[to]) { continue; }\n          end[to] = true;\n          que.push(to);\n        }\n      }\n    }\n    if (end[0]) {\n      puts(\"0\");\n      continue;\n    }\n\n    // calc dist\n    {\n      queue<pair<int, int> > que;\n      que.push(make_pair(natume, 0));\n      MEMSET(visit, false);\n      while (!que.empty()) {\n        int from = que.front().first;\n        int cost = que.front().second;\n        que.pop();\n        if (visit[0][from]) { continue; }\n        visit[0][from] = true;\n        dist[from] = cost;\n        FORIT(it, mainG[from]) {\n          int to = *it;\n          if (visit[0][to]) { continue; }\n          que.push(make_pair(to, cost + 1));\n        }\n      }\n    }\n\n\n    priority_queue<Node> pque;\n    // push pque\n    {\n      queue<int> que;\n      que.push(0);\n      MEMSET(visit, false);\n      visit[0][0] = true;\n      while (!que.empty()) {\n        int from = que.front();\n        que.pop();\n        pque.push(Node(0, from, 0));\n        FORIT(it, nekoG[from]) {\n          int to = *it;\n          if (visit[0][to]) { continue; }\n          visit[0][to] = true;\n          que.push(to);\n        }\n      }\n    }\n\n    // calc ans\n    MEMSET(visit, false);\n    while (!pque.empty()) {\n      int state = pque.top().state;\n      int from = pque.top().from;\n      int cost = pque.top().cost;\n      pque.pop();\n      if (visit[state][from]) { continue; }\n      visit[state][from] = true;\n      if (state == 1 && end[from]) {\n        printf(\"%d\\n\", cost);\n        break;\n      }\n      FORIT(it, mainG[from]) {\n        int to = *it;\n        if (visit[state][to]) { continue; }\n        int ncost = cost + 1;\n        pque.push(Node(state, to, ncost));\n      }\n      if (state == 0) {\n        pque.push(Node(1, from, cost + dist[from]));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nvector<int> g[110000];\nvector<int> g2[110000];\nchar in[4];\nint v1[110000];\nint v2[110000];\nint A[110000];\nint B[110000];\nint C[110000];\nint main(){\n\tint T;scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\tint c,d;scanf(\"%d%d\",&c,&d);\n\t\tfor(int i=0;i<a+1;i++)g[i].clear();\n\t\tfor(int i=0;i<a+1;i++)g2[i].clear();\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d%s\",&p,&q,in);\n\t\t\tif(in[0]=='N'){\n\t\t\t\tg[p].push_back(q);\n\t\t\t\tg[q].push_back(p);\n\t\t\t}else{\n\t\t\t\tg2[p].push_back(q);\n\t\t\t\tg2[q].push_back(p);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a+1;i++)v1[i]=v2[i]=0;\n\t\tqueue<int>Q;\n\t\tQ.push(0);\n\t\tv1[0]=1;\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<g2[at].size();i++)if(!v1[g2[at][i]]){\n\t\t\t\tv1[g2[at][i]]=1;\n\t\t\t\tQ.push(g2[at][i]);\n\t\t\t}\n\t\t}\n\t\tv2[d]=1;\n\t\tQ.push(d);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<g2[at].size();i++)if(!v2[g2[at][i]]){\n\t\t\t\tv2[g2[at][i]]=1;\n\t\t\t\tQ.push(g2[at][i]);\n\t\t\t}\n\t\t}\n\t\tif(v1[d]){\n\t\t\tprintf(\"0\\n\");continue;\n\t\t}\n\t\tfor(int i=0;i<a+1;i++)A[i]=B[i]=C[i]=99999999;\n\t\tA[c]=0;\n\t\tQ.push(c);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(A[g[at][i]]>9999999){\n\t\t\t\t\tA[g[at][i]]=A[at]+1;\n\t\t\t\t\tQ.push(g[at][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a+1;i++)if(v1[i]){\n\t\t\tQ.push(i);\n\t\t\tB[i]=0;\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(B[g[at][i]]>9999999){\n\t\t\t\t\tB[g[at][i]]=B[at]+1;\n\t\t\t\t\tQ.push(g[at][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a+1;i++)if(v2[i]){\n\t\t\tQ.push(i);\n\t\t\tC[i]=0;\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(C[g[at][i]]>9999999){\n\t\t\t\t\tC[g[at][i]]=C[at]+1;\n\t\t\t\t\tQ.push(g[at][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<a+1;i++)ret=min(ret,A[i]+B[i]+C[i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct Edge {\n  int dst;\n  char c;\n};\n\ntypedef vector<vector<Edge> > G;\nconst int N = 100005;\nbool visited[N];\n\nvoid bfs(const G &g, int s, vector<int> &v) {\n  int n = g.size();\n  REP(i,n) visited[i] = 0;\n  queue<int> Q; Q.push(s);\n  visited[s] = 1;\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    v.push_back(now);\n    FOR(it, g[now]) {\n      if (it->c == 'N') continue;\n      int dst = it->dst;\n      if (!visited[dst]) {\n        visited[dst] = 1;\n        Q.push(dst);\n      }\n    }\n  }\n}\n\nvoid bfs2(const G &g, const vector<int> &v, int *dist) {\n  int n = g.size();\n  REP(i,n) dist[i] = INF;\n  queue<int> Q;\n  FOR(it, v) {\n    Q.push(*it);\n    dist[*it] = 0;\n  }\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    FOR(it, g[now]) {\n      if (it->c == 'L') continue;\n      int dst = it->dst;\n      if (dist[dst] == INF) {\n        dist[dst] = dist[now] + 1;\n        Q.push(dst);\n      }\n    }\n  }\n}\n\nint dist1[N];\nint dist2[N];\nint dist3[N];\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    int n, m;\n    cin >> n >> m;\n    int ns, ls;\n    cin >> ns >> ls;\n    G g(n+1);\n    REP(i,m) {\n      char c;\n      int a,b;\n      cin >> a >> b >> c;\n      g[a].push_back((Edge){b,c});\n      g[b].push_back((Edge){a,c});\n    }\n    vector<int> vA;             // レノンがいる場所から自由にいける場所\n    vector<int> vB;             // 夏への扉から自由にいける場所\n    bfs(g,ls,vA);\n    bfs(g,0,vB);\n    if (find(ALL(vA),0) != vA.end()) {\n      cout << 0 << endl;\n      continue;\n    }\n    bfs2(g,vA,dist1);\n    bfs2(g,vB,dist2);\n    bfs2(g,vector<int>(1,ns),dist3);\n    int ans = INF;\n    REP(i,n+1) {\n      //cout << dist1[i] << \" \" << dist2[i] << \" \" << dist3[i] << endl;\n      ans = min(ans, dist1[i]+dist2[i]+dist3[i]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nenum Type{\n\tbase_human,\n\tbase_cat,\n\tbase_can_area,\n};\n\nstruct Info{\n\tInfo(int arg_room_id,int arg_sum_cost){\n\t\troom_id = arg_room_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint room_id,sum_cost;\n};\n\nint goal;\nint num_room,num_door;\nint min_dist[3][NUM];\nint height[NUM],boss[NUM];\nvector<int> human_G[NUM],cat_G[NUM];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same_group(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\t//既に同じグループなら何もしない\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i <= num_room; i++){ //★0が「夏への扉」の先★\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i <= num_room; i++){\n\t\thuman_G[i].clear();\n\t\tcat_G[i].clear();\n\t}\n\n\tscanf(\"%d %d\",&num_room,&num_door);\n\n\tinit();\n\n\tint start_human,start_cat;\n\tscanf(\"%d %d\",&start_human,&start_cat);\n\n\tint from,to;\n\tchar buf[2];\n\n\tfor(int loop = 0; loop < num_door; loop++){\n\t\tscanf(\"%d %d %s\",&from,&to,buf);\n\n\t\tif(buf[0] == 'N'){ //人間用\n\n\t\t\thuman_G[from].push_back(to);\n\t\t\thuman_G[to].push_back(from);\n\n\t\t}else{ //猫用\n\n\t\t\tunite(from,to);\n\n\t\t\tcat_G[from].push_back(to);\n\t\t\tcat_G[to].push_back(from);\n\t\t}\n\t}\n\n\t//最初から自力ゴール可能な領域にいる場合\n\tif(is_same_group(goal,start_cat)){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * 人間がある部屋に移動する際の最小コストは猫の動きに無関係\n\t */\n\tfor(int i = 0; i <= num_room; i++)min_dist[base_human][i] = BIG_NUM;\n\n\tpriority_queue<Info> Q;\n\tmin_dist[base_human][start_human] = 0;\n\tQ.push(Info(start_human,0));\n\n\tint next_room,next_cost;\n\n\t//人間がある部屋に移動する最短コストを求める(通過できないので、猫用のエッジは無視)\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[base_human][Q.top().room_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\tnext_cost = Q.top().sum_cost+1;\n\n\t\t\tfor(int i = 0; i < human_G[Q.top().room_id].size(); i++){\n\n\t\t\t\tnext_room = human_G[Q.top().room_id][i];\n\n\t\t\t\tif(min_dist[base_human][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_human][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\t//[猫の初期稼働範囲]への、人間が到達する最短コストを逆算で求める\n\tfor(int i = 0; i <= num_room; i++)min_dist[base_cat][i] = BIG_NUM;\n\n\tmin_dist[base_cat][start_cat] = 0;\n\tQ.push(Info(start_cat,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[base_cat][Q.top().room_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\tif(Q.top().sum_cost == 0){ //★★start地点から移動可能な範囲のみ、猫扉で移動(猫が可能な限り動いた方が最適)★★\n\n\t\t\t\t//猫用エッジ\n\t\t\t\tfor(int i = 0; i < cat_G[Q.top().room_id].size(); i++){\n\t\t\t\t\tnext_room = cat_G[Q.top().room_id][i];\n\n\t\t\t\t\tif(is_same_group(start_cat,next_room)){ //猫がstart地点から自力で辿り着ける部屋\n\n\t\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(min_dist[base_cat][next_room] > next_cost){\n\t\t\t\t\t\tmin_dist[base_cat][next_room] = next_cost;\n\t\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//人間用エッジ\n\t\t\tfor(int i = 0; i < human_G[Q.top().room_id].size(); i++){\n\n\t\t\t\tnext_room = human_G[Q.top().room_id][i];\n\n\t\t\t\tif(is_same_group(start_cat,next_room)){ //猫がstart地点から自力で辿り着ける部屋\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t}\n\n\t\t\t\tif(min_dist[base_cat][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_cat][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\t//[猫が自力でゴールできる領域]への最短コストを求める\n\tfor(int i = 0; i <= num_room; i++)min_dist[base_can_area][i] = BIG_NUM;\n\n\tmin_dist[base_can_area][goal] = 0;\n\tQ.push(Info(goal,0));\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().sum_cost > min_dist[base_can_area][Q.top().room_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\tif(Q.top().sum_cost == 0){ //★★猫が自力でゴール可能な範囲のみ、猫扉で移動(猫が可能な限り動いた方が最適)★★\n\n\t\t\t\t//猫用エッジ\n\t\t\t\tfor(int i = 0; i < cat_G[Q.top().room_id].size(); i++){\n\t\t\t\t\tnext_room = cat_G[Q.top().room_id][i];\n\n\t\t\t\t\tif(is_same_group(goal,next_room)){ //猫が自力でゴール可の部屋\n\n\t\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(min_dist[base_can_area][next_room] > next_cost){\n\t\t\t\t\t\tmin_dist[base_can_area][next_room] = next_cost;\n\t\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//人間用エッジ\n\t\t\tfor(int i = 0; i < human_G[Q.top().room_id].size(); i++){\n\n\t\t\t\tnext_room = human_G[Q.top().room_id][i];\n\n\t\t\t\tif(is_same_group(goal,next_room)){ //猫が自力でゴール可の部屋\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t}\n\n\t\t\t\tif(min_dist[base_can_area][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_can_area][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\tfor(int i = 0; i <= num_room; i++){\n\t\tif(min_dist[base_human][i] == BIG_NUM || min_dist[base_cat][i] == BIG_NUM || min_dist[base_can_area][i] == BIG_NUM)continue;\n\t\tans = min(ans,min_dist[base_human][i]+min_dist[base_cat][i]+min_dist[base_can_area][i]);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tint num_case;\n\n\tscanf(\"%d\",&num_case);\n\n\tgoal = 0;\n\n\tfor(int i = 0; i < num_case; i++){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\n\ntypedef int Weight;\nconst Weight INF=99999999;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev=0):src(f),dst(t),weight(c),rev(rev){}\n    bool operator < (const Edge& re)const{ return weight > re.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph &G, int s, int t, Weight cap){\n    G[s].push_back(Edge(s, t, cap, G[t].size()));\n}\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\nvoid bfs(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if(e.weight != 0 && f->weight == 0) continue;\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\n\nint main(void){\n    int t;\n    cin >> t;\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n        int natsume, lennon;\n        cin >> natsume >> lennon;\n        natsume--; lennon--;\n        Graph g(n), lg(n), sg(n);\n        int summer, tosummer = 0;\n        vector<pii> cat;\n        REP(i, m){\n            int x, y; char c;\n            cin >> x >> y >> c;\n            x--; y--;\n\n            if(min(x, y) == -1){\n                summer = max(x, y);\n                if(c == 'N') tosummer = 1; \n                else tosummer = 0;\n                continue;\n            }\n\n            if(c == 'N'){\n                add_edge(g, x ,y, 1);\n                add_edge(g, y, x, 1);\n                add_edge(lg, x ,y, 1);\n                add_edge(lg, y, x, 1);\n                add_edge(sg, x ,y, 1);\n                add_edge(sg, y, x, 1);\n            }else{\n                cat.push_back(pii(x, y));\n                add_edge(lg, x ,y, 0);\n                add_edge(lg, y ,x, 0);\n            }\n        }\n        if(!tosummer){\n            FOR(e, cat){\n                add_edge(sg, (*e).first, (*e).second, 0); \n                add_edge(sg, (*e).second, (*e).first, 0);\n            }\n        }\n        vi dist_g, dist_lg, dist_sg, prev;\n        shortestPath(g, natsume, dist_g, prev);\n        prev.clear();\n        bfs(lg, lennon, dist_lg, prev);\n        prev.clear();\n        bfs(sg, summer, dist_sg, prev);\n        int ans = INF;\n        if(!tosummer && dist_sg[lennon] == 0){\n            cout << 0 << endl;\n            continue;\n        }\n        REP(i, n){\n            //cout << dist_g[i] << \":\" << dist_lg[i] << \":\" << dist_sg[i] << endl;\n            ans = min(ans, dist_g[i] + dist_lg[i] + dist_sg[i] + tosummer);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\n\ntypedef int Weight;\nconst Weight INF=99999999;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev=0):src(f),dst(t),weight(c),rev(rev){}\n    bool operator < (const Edge& re)const{ return weight > re.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph &G, int s, int t, Weight cap){\n    G[s].push_back(Edge(s, t, cap, G[t].size()));\n}\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\nint main(void){\n    int t;\n    cin >> t;\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n        int natsume, lennon;\n        cin >> natsume >> lennon;\n        natsume--; lennon--;\n        Graph g(n), lg(n), sg(n);\n        int summer, tosummer = 0;\n        REP(i, m){\n            int x, y; char c;\n            cin >> x >> y >> c;\n            x--; y--;\n\n            if(min(x, y) == -1){\n                summer = max(x, y);\n                if(c == 'N') tosummer = 1; \n                else tosummer = 0;\n                continue;\n            }\n\n            if(c == 'N'){\n                add_edge(g, x ,y, 1);\n                add_edge(g, y, x, 1);\n                add_edge(lg, x ,y, 1);\n                add_edge(lg, y, x, 1);\n                add_edge(sg, x ,y, 1);\n                add_edge(sg, y, x, 1);\n            }else{\n                add_edge(lg, x ,y, 0);\n                add_edge(lg, y ,x, 0);\n                add_edge(sg, x, y, 0);\n                add_edge(sg, y, x, 0);\n            }\n        }\n        vi dist_g, dist_lg, dist_sg, prev;\n        shortestPath(g, natsume, dist_g, prev);\n        prev.clear();\n        shortestPath(lg, lennon, dist_lg, prev);\n        prev.clear();\n        shortestPath(sg, summer, dist_sg, prev);\n        int ans = INF;\n        REP(i, n){\n            //cout << dist_g[i] << \":\" << dist_lg[i] << \":\" << dist_sg[i] << endl;\n            ans = min(ans, dist_g[i] + dist_lg[i] + dist_sg[i] + tosummer);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint nmemo[100001];\nint nlmemo[100001];\nint nsmemo[100001];\nint lmemo[100001];\nint smemo[100001];\n\nvoid make_memo(const vector<vector<int> > &door, int *memo, vector<int> start){\n  queue<int> q;\n  FOR(it, start){ memo[*it] = 0; q.push(*it); }\n  while(q.size()){\n    int pos = q.front(); q.pop(); int cnt = memo[pos];\n    FOR(it, door[pos]) if(memo[*it] == -1){\n      memo[*it] = cnt + 1; q.push(*it);\n    }\n  }\n}\n\nint main(){\n  int c; scanf(\"%d\", &c);\n  while(c --> 0){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    \n    int natsume, lenon;\n    scanf(\"%d%d\", &natsume, &lenon);\n\n    vector<vector<int> > ndoor(n+1);\n    vector<vector<int> > ldoor(n+1);\n\n    REP(i, m){\n      int a, b; char p;\n      scanf(\"%d%d %c\", &a, &b, &p);\n      if(p == 'N'){\n\tndoor[a].push_back(b);\n\tndoor[b].push_back(a);\n      }else{\n\tldoor[a].push_back(b);\n\tldoor[b].push_back(a);\n      }\n    }\n\n    REP(i, n+1) nsmemo[i] = nlmemo[i] = nmemo[i] = lmemo[i] = smemo[i] = -1;\n\n    make_memo(ndoor, nmemo, vector<int>(1, natsume));\n    make_memo(ldoor, lmemo, vector<int>(1, lenon));\n    make_memo(ldoor, smemo, vector<int>(1, 0));\n\n    vector<int> l; REP(i, n+1) if(lmemo[i] != -1) l.push_back(i);\n    vector<int> s; REP(i, n+1) if(smemo[i] != -1) s.push_back(i);\n    make_memo(ndoor, nlmemo, l);\n    make_memo(ndoor, nsmemo, s);\n\n    int ans = INT_MAX;\n    REP(i, n+1) if(nmemo[i] != -1)\n      ans = min(ans, nmemo[i] + nsmemo[i] + nlmemo[i]);\n\n    print(ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100005\n\nenum Type{\n\tbase_human,\n\tbase_cat,\n\tbase_can_area,\n};\n\nstruct Info{\n\tInfo(int arg_room_id,int arg_sum_cost){\n\t\troom_id = arg_room_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint room_id,sum_cost;\n};\n\nint goal;\nint num_room,num_door;\nint min_dist[3][NUM];\nint height[NUM],boss[NUM];\nvector<int> human_G[NUM],cat_G[NUM];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nint is_same_group(int x,int y){\n\treturn get_boss(x) == get_boss(y);\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\t//既に同じグループなら何もしない\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i <= num_room; i++){ //★0が「夏への扉」の先★\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i <= num_room; i++){\n\t\thuman_G[i].clear();\n\t\tcat_G[i].clear();\n\t}\n\n\tscanf(\"%d %d\",&num_room,&num_door);\n\n\tinit();\n\n\tint start_human,start_cat;\n\tscanf(\"%d %d\",&start_human,&start_cat);\n\n\tint from,to;\n\tchar buf[2];\n\n\tfor(int loop = 0; loop < num_door; loop++){\n\t\tscanf(\"%d %d %s\",&from,&to,buf);\n\n\t\tif(buf[0] == 'N'){ //人間用\n\n\t\t\thuman_G[from].push_back(to);\n\t\t\thuman_G[to].push_back(from);\n\n\t\t}else{ //猫用\n\n\t\t\tunite(from,to);\n\n\t\t\tcat_G[from].push_back(to);\n\t\t\tcat_G[to].push_back(from);\n\t\t}\n\t}\n\n\t//最初から自力ゴール可能な領域にいる場合\n\tif(is_same_group(goal,start_cat)){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\t/*\n\t * 人間がある部屋に移動する際の最小コストは猫の動きに無関係\n\t */\n\tfor(int i = 0; i <= num_room; i++)min_dist[base_human][i] = BIG_NUM;\n\n\tpriority_queue<Info> Q;\n\tmin_dist[base_human][start_human] = 0;\n\tQ.push(Info(start_human,0));\n\n\tint next_room,next_cost;\n\n\t//人間がある部屋に移動する最短コストを求める(通過できないので、猫用のエッジは無視)\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[base_human][Q.top().room_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\tnext_cost = Q.top().sum_cost+1;\n\n\t\t\tfor(int i = 0; i < human_G[Q.top().room_id].size(); i++){\n\n\t\t\t\tnext_room = human_G[Q.top().room_id][i];\n\n\t\t\t\tif(min_dist[base_human][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_human][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\t//[猫の初期稼働範囲]への最短コストを求める\n\tfor(int i = 0; i <= num_room; i++)min_dist[base_cat][i] = BIG_NUM;\n\n\tmin_dist[base_cat][start_cat] = 0;\n\tQ.push(Info(start_cat,0));\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[base_cat][Q.top().room_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\t//猫用エッジ\n\t\t\tfor(int i = 0; i < cat_G[Q.top().room_id].size(); i++){\n\t\t\t\tnext_room = cat_G[Q.top().room_id][i];\n\n\t\t\t\tif(is_same_group(start_cat,next_room)){ //猫がstart地点から自力で辿り着ける部屋\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t}\n\n\t\t\t\tif(min_dist[base_cat][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_cat][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//人間用エッジ\n\t\t\tfor(int i = 0; i < human_G[Q.top().room_id].size(); i++){\n\n\t\t\t\tnext_room = human_G[Q.top().room_id][i];\n\n\t\t\t\tif(is_same_group(start_cat,next_room)){ //猫がstart地点から自力で辿り着ける部屋\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t}\n\n\t\t\t\tif(min_dist[base_cat][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_cat][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\t//[猫が自力でゴールできる領域]への最短コストを求める\n\tfor(int i = 0; i <= num_room; i++)min_dist[base_can_area][i] = BIG_NUM;\n\n\tmin_dist[base_can_area][goal] = 0;\n\tQ.push(Info(goal,0));\n\n\twhile(!Q.empty()){\n\t\tif(Q.top().sum_cost > min_dist[base_can_area][Q.top().room_id]){\n\n\t\t\tQ.pop();\n\n\t\t}else{\n\n\t\t\t//猫用エッジ\n\t\t\tfor(int i = 0; i < cat_G[Q.top().room_id].size(); i++){\n\t\t\t\tnext_room = cat_G[Q.top().room_id][i];\n\n\t\t\t\tif(is_same_group(goal,next_room)){ //猫が自力でゴール可の部屋\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t}\n\n\t\t\t\tif(min_dist[base_can_area][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_can_area][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//人間用エッジ\n\t\t\tfor(int i = 0; i < human_G[Q.top().room_id].size(); i++){\n\n\t\t\t\tnext_room = human_G[Q.top().room_id][i];\n\n\t\t\t\tif(is_same_group(goal,next_room)){ //猫が自力でゴール可の部屋\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost;\n\n\t\t\t\t}else{\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+1;\n\t\t\t\t}\n\n\t\t\t\tif(min_dist[base_can_area][next_room] > next_cost){\n\t\t\t\t\tmin_dist[base_can_area][next_room] = next_cost;\n\t\t\t\t\tQ.push(Info(next_room,next_cost));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\tfor(int i = 0; i <= num_room; i++){\n\t\tif(min_dist[base_human][i] == BIG_NUM || min_dist[base_cat][i] == BIG_NUM || min_dist[base_can_area][i] == BIG_NUM)continue;\n\t\tans = min(ans,min_dist[base_human][i]+min_dist[base_cat][i]+min_dist[base_can_area][i]);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tint num_case;\n\n\tscanf(\"%d\",&num_case);\n\n\tgoal = 0;\n\n\tfor(int i = 0; i < num_case; i++){\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct Edge {\n  int dst;\n  char c;\n};\n\ntypedef vector<vector<Edge> > G;\nconst int N = 100000;\nbool visited[N];\n\nvoid bfs(const G &g, int s, vector<int> &v) {\n  int n = g.size();\n  REP(i,n) visited[i] = 0;\n  queue<int> Q; Q.push(s);\n  visited[s] = 1;\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    v.push_back(now);\n    FOR(it, g[now]) {\n      if (it->c == 'N') continue;\n      int dst = it->dst;\n      if (!visited[dst]) {\n        visited[dst] = 1;\n        Q.push(dst);\n      }\n    }\n  }\n}\n\nvoid bfs2(const G &g, const vector<int> &v, int *dist) {\n  int n = g.size();\n  REP(i,n) dist[i] = INF;\n  queue<int> Q;\n  FOR(it, v) {\n    Q.push(*it);\n    dist[*it] = 0;\n  }\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    FOR(it, g[now]) {\n      if (it->c == 'L') continue;\n      int dst = it->dst;\n      if (dist[dst] == INF) {\n        dist[dst] = dist[now] + 1;\n        Q.push(dst);\n      }\n    }\n  }\n}\n\nint dist1[N];\nint dist2[N];\nint dist3[N];\n\nint main() {\n  int T;\n  cin >> T;\n  while(T--) {\n    int n, m;\n    cin >> n >> m;\n    int ns, ls;\n    cin >> ns >> ls;\n    G g(n+1);\n    REP(i,m) {\n      char c;\n      int a,b;\n      cin >> a >> b >> c;\n      g[a].push_back((Edge){b,c});\n      g[b].push_back((Edge){a,c});\n    }\n    vector<int> vA;             // レノンがいる場所から自由にいける場所\n    vector<int> vB;             // 夏への扉から自由にいける場所\n    bfs(g,ls,vA);\n    bfs(g,0,vB);\n    bfs2(g,vA,dist1);\n    bfs2(g,vB,dist2);\n    bfs2(g,vector<int>(1,ns),dist3);\n    int ans = INF;\n    REP(i,n+1) {\n      ans = min(ans, dist1[i]+dist2[i]+dist3[i]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass union_find{\n\tvector<int> a;\npublic:\n\tunion_find(int n):a(n,-1){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){ a[x]+=a[y]; a[y]=x; }\n\t}\n};\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint n,m,natsume,renon; scanf(\"%d%d%d%d\",&n,&m,&natsume,&renon);\n\n\t\tstatic vector<int> G[100001]; // Natsume graph\n\t\trep(u,n+1) G[u].clear();\n\n\t\tunion_find U(n+1);\n\t\trep(i,m){\n\t\t\tint u,v;\n\t\t\tchar c; scanf(\"%d%d %c\",&u,&v,&c);\n\t\t\tif(c=='N'){\n\t\t\t\tG[u].push_back(v);\n\t\t\t\tG[v].push_back(u);\n\t\t\t}\n\t\t\telse U.unite(u,v);\n\t\t}\n\n\t\tif(U.find(renon)==U.find(0)){ puts(\"0\"); continue; }\n\n\t\tstatic int d1[100001]; // d1[u] := dist(Natsume,u)\n\t\trep(u,n+1) d1[u]=INF;\n\t\t{\n\t\t\tint head=0,tail=0;\n\t\t\tstatic int Q[100001];\n\t\t\td1[natsume]=0;\n\t\t\tQ[tail++]=natsume;\n\t\t\twhile(head<tail){\n\t\t\t\tint u=Q[head++];\n\t\t\t\trep(i,G[u].size()){\n\t\t\t\t\tint v=G[u][i];\n\t\t\t\t\tif(d1[v]==INF) d1[v]=d1[u]+1, Q[tail++]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic int d2[100001]; // d2[u] := dist(Renon,u)\n\t\trep(u,n+1) d2[u]=INF;\n\t\t{\n\t\t\tint head=0,tail=0;\n\t\t\tstatic int Q[100001];\n\t\t\trep(u,n+1) if(U.find(u)==U.find(renon)) d2[u]=0, Q[tail++]=u;\n\t\t\twhile(head<tail){\n\t\t\t\tint u=Q[head++];\n\t\t\t\trep(i,G[u].size()){\n\t\t\t\t\tint v=G[u][i];\n\t\t\t\t\tif(d2[v]==INF) d2[v]=d2[u]+1, Q[tail++]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatic int d3[100001]; // d3[u] := dist(summer,u)\n\t\trep(u,n+1) d3[u]=INF;\n\t\t{\n\t\t\tint head=0,tail=0;\n\t\t\tstatic int Q[100001];\n\t\t\trep(u,n+1) if(U.find(u)==U.find(0)) d3[u]=0, Q[tail++]=u;\n\t\t\twhile(head<tail){\n\t\t\t\tint u=Q[head++];\n\t\t\t\trep(i,G[u].size()){\n\t\t\t\t\tint v=G[u][i];\n\t\t\t\t\tif(d3[v]==INF) d3[v]=d3[u]+1, Q[tail++]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=INF;\n\t\trep(u,n+1) ans=min(ans,d1[u]+d2[u]+d3[u]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint N, M, hs, cs;\n\nvoid dfs(int n, set<int> &S, vector< vector<int> > &es){\n  S.insert(n);\n  for(int next : es[n]) if(S.find(next) == S.end()) dfs(next, S, es);\n}\n\nvoid bfs(vector< vector<int> > &es, queue<int> &open, vector<int> &closed){\n  while(!open.empty()){\n    int now = open.front(), cost = closed[now]; open.pop();\n    for(int next : es[now]){\n      if(closed[next] > cost + 1){\n        closed[next] = cost + 1;\n        open.push(next);\n      }\n    }\n  }\n}\n\nint main() {\n  int T; cin >>T;\n  while(T--){\n    cin >>N >>M >>hs >>cs;\n    N++;\n    vector< vector<int> > hes(N), ces(N);\n    REP(i, M){\n      int a, b; char c; cin >>a >>b >>c;\n      if(c == 'N') { hes[a].push_back(b); hes[b].push_back(a); }\n      else { ces[a].push_back(b); ces[b].push_back(a); }\n    }\n\n    set<int> X, Y;\n    dfs(cs, X, ces); dfs(0, Y, ces);\n\n    vector<int> A, B, C, ac(N, INF), bc(N, INF), cc(N, INF);\n    queue<int> aq, bq, cq;\n    aq.push(hs); ac[hs] = 0;\n    for(int n : X) { bq.push(n); bc[n] = 0; }\n    for(int n : Y) { cq.push(n); cc[n] = 0; }\n    bfs(hes, aq, ac);\n    bfs(hes, bq, bc);\n    bfs(hes, cq, cc);\n\n    int ans = INF;\n    REP(i, N) ans = min(ans, ac[i] + bc[i] + cc[i]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nvector<int>diss(const vector<int> goals, const vector<vector<int>>&edges) {\n\tqueue<int>que;\n\tvector<int>memo(edges.size(),1e8);\n\tfor (auto goal : goals) {\n\t\tmemo[goal]=0;\n\t\tque.push(goal);\n\t}\n\twhile (!que.empty()) {\n\t\tauto now(que.front());\n\t\tque.pop();\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (memo[e] > memo[now] + 1) {\n\t\t\t\tmemo[e]=memo[now]+1;\n\t\t\t\tque.push(e);\n\t\t\t}\n\t\t}\n\t}\n\treturn memo;\n}\n\nint main() {\n\tint Q;cin>>Q;\n\twhile (Q--) {\n\t\tint N,M;cin>>N>>M;\n\t\tvector<vector<int>>edges(N+1);\n\t\tint natu,reno;cin>>natu>>reno;\n\t\tUnionFind uf(N+1);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a,b;char ch;cin>>a>>b>>ch;\n\t\t\tif (ch == 'N') {\n\t\t\t\tedges[a].push_back(b);\n\t\t\t\tedges[b].push_back(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.unionSet(a,b);\n\t\t\t}\n\t\t}\n\t\tvector<int>reno_same;\n\t\tvector<int>goal_same;\n\t\tfor (int i = 0; i <= N; ++i) {\n\t\t\tif(uf.root(i)==uf.root(reno))reno_same.push_back(i);\n\t\t\tif(uf.root(i)==uf.root(0))goal_same.push_back(i);\n\t\t}\n\t\tauto natu_dis(diss(vector<int>{natu}, edges));\n\t\tauto goal_dis(diss(goal_same, edges));\n\t\tauto reno_dis(diss(reno_same,edges));\n\n\t\tint ans=1e9;\n\t\tfor (int i = 0; i <= N; ++i) {\n\t\t\tint sum=natu_dis[i]+goal_dis[i]+reno_dis[i];\n\t\t\tif(ans>sum)ans=sum;\n\t\t}\n\t\tif(uf.root(reno)==uf.root(0))ans=0;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int MOD = 1e9+7;\n\n\ntypedef int Weight;\nconst Weight INF=99999999;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev=0):src(f),dst(t),weight(c),rev(rev){}\n    bool operator < (const Edge& re)const{ return weight > re.weight;}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph &G, int s, int t, Weight cap){\n    G[s].push_back(Edge(s, t, cap, G[t].size()));\n}\nvoid shortestPath(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q;\n    for(Q.push(Edge(-2, s, 0)); !Q.empty();){\n        Edge e = Q.top(); Q.pop();\n        if(prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight){\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\nint main(void){\n    int t;\n    cin >> t;\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n        int natsume, lennon;\n        cin >> natsume >> lennon;\n        natsume--; lennon--;\n        Graph g(n), lg(n), sg(n);\n        int summer, tosummer = 0;\n        vector<pii> cat;\n        REP(i, m){\n            int x, y; char c;\n            cin >> x >> y >> c;\n            x--; y--;\n\n            if(min(x, y) == -1){\n                summer = max(x, y);\n                if(c == 'N') tosummer = 1; \n                else tosummer = 0;\n                continue;\n            }\n\n            if(c == 'N'){\n                add_edge(g, x ,y, 1);\n                add_edge(g, y, x, 1);\n                add_edge(lg, x ,y, 1);\n                add_edge(lg, y, x, 1);\n                add_edge(sg, x ,y, 1);\n                add_edge(sg, y, x, 1);\n            }else{\n                cat.push_back(pii(x, y));\n                add_edge(lg, x ,y, 0);\n                add_edge(lg, y ,x, 0);\n            }\n        }\n        if(!tosummer){\n            FOR(e, cat){\n                add_edge(sg, (*e).first, (*e).second, 0); \n                add_edge(sg, (*e).second, (*e).first, 0);\n            }\n        }\n        vi dist_g, dist_lg, dist_sg, prev;\n        shortestPath(g, natsume, dist_g, prev);\n        prev.clear();\n        shortestPath(lg, lennon, dist_lg, prev);\n        prev.clear();\n        shortestPath(sg, summer, dist_sg, prev);\n        int ans = INF;\n        REP(i, n){\n            //cout << dist_g[i] << \":\" << dist_lg[i] << \":\" << dist_sg[i] << endl;\n            ans = min(ans, dist_g[i] + dist_lg[i] + dist_sg[i] + tosummer);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint nat_m,nat_h[111111],nat_n[111111*2],nat_t[111111*2];\nint nat_c[111111],nat_c_natsu[111111];\nint neko_m,neko_h[111111],neko_n[111111*2],neko_t[111111*2];\nint neko_can[111111],neko_can_natsu[111111];\nint neko_c[111111],neko_c_natsu[111111];\nint q[555555],inq[111111],hd,tl;\nint nat_natsu_c[111111],neko_natsu_c[111111];\n\nint main(void)\n{\n  int n,m,nat,neko,u,v,i,e,p,res,f;\n  char c;\n  f = 0;\n  while(scanf(\"%d%d\",&n,&m) == 2 ) {\n    if( f ) puts(\"\"); f = 1;\n    for(i = 0; i <= n; i++) {\n      nat_h[i] = neko_h[i] = -1;\n      neko_can[i] = neko_can_natsu[i] = 0;\n      neko_c[i] = neko_c_natsu[i] = 1<<21;\n      nat_c[i] = nat_c_natsu[i] = 1<<21;\n    }\n    scanf(\"%d%d\",&nat,&neko);\n#define add_edge1(n,h,t,m,u,v) (n[m]=h[u],h[u]=m,t[m]=v,++m)\n    for( i = 0; i < m; i++ ) {\n      scanf(\"%d%d %c\",&u,&v,&c);\n      if( c == 'N' ) {\n        add_edge1(nat_n,nat_h,nat_t,nat_m,u,v);\n        add_edge1(nat_n,nat_h,nat_t,nat_m,v,u);\n      }\n      if( c == 'L' ) {\n        add_edge1(neko_n,neko_h,neko_t,neko_m,u,v);\n        add_edge1(neko_n,neko_h,neko_t,neko_m,v,u);\n      }\n    }\n    nat_c[nat] = 0;\n    hd = tl = 0;\n    q[tl++] = nat;\n    while( hd != tl ) {\n      p = q[hd++];\n      for( e = nat_h[p]; e != -1; e = nat_n[e] ) {\n        if( nat_c[nat_t[e]] > nat_c[p]+1 ) {\n          nat_c[nat_t[e]] = nat_c[p]+1;\n          q[tl++] = nat_t[e];\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = 0; neko_c_natsu[0] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c_natsu[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c_natsu[neko_t[e]] > neko_c_natsu[p] ) {\n            neko_c_natsu[neko_t[e]] = neko_c_natsu[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c_natsu[nat_t[e]] > neko_c_natsu[p]+1 ) {\n          neko_c_natsu[nat_t[e]] = neko_c_natsu[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = neko; neko_c[neko] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c[neko_t[e]] > neko_c[p] ) {\n            neko_c[neko_t[e]] = neko_c[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c[nat_t[e]] > neko_c[p]+1 ) {\n          neko_c[nat_t[e]] = neko_c[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    res = 1<<21;\n    if( neko_c[0] == 0 ) res = 0;\n    for( i = 0; i <= n; i++ ) {\n      int k = nat_c[i]+neko_c[i]+neko_c_natsu[i];\n      if( res > k ) res = k;\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2193: The Door into Summer\n// 2018.1.7 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100003\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\n//void make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 15000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\nint n;\nint to[MAX][20]; char hi[MAX];\nint goal[MAX], gsz;\nint lpos[MAX], lsz;\nint gdist[MAX], ndist[MAX], ldist[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int *dist, int *start, int sz)\n{\n\tint i, s, d, e;\n\n\tmemset(dist, INF, n << 2);\n\tqsize = 0;\n\tfor (i = 0; i < sz; i++) dist[start[i]] = 0, enq(start[i], 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (d+1 < dist[e]) dist[e] = d+1, enq(e, d+1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint cno, m, npos, i, a, b, c, ans;\n\n\tcno = in();\n\twhile (cno--) {\n\t\tn = in()+1, m = in();\n\n\t\tmemset(hi, 0, n);\n\t\tmemset(rank, 0, n<<2);\t\t\t// union set, <<2 = 4 = sizeof(int)\n\t\tfor (i = 0; i < n; i++) p[i] = i;\n\t\tgsz = lsz = 0;\n\n\t\tnpos = in(), a = in();\t// initial position\n\t\tgoal[gsz++] = 0;\n\t\tlpos[lsz++] = a;\n\n\t\tfor (i = 0; i < m; i++) {\n\t\t\ta = in(), b = in(), c = getchar_unlocked(), getchar_unlocked();\n\t\t\tif (c == 'N') to[a][hi[a]++] = b, to[b][hi[b]++] = a;\n\t\t\telse union_set(a, b);\n\t\t}\n\n\t\ta = find_set(0), b = find_set(lpos[0]);\n\t\tif (find_set(0) == b) { puts(\"0\"); continue; }\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((c = find_set(i)) == a) goal[gsz++] = i;\n\t\t\tif ( c                == b) lpos[lsz++] = i;\n\t\t}\n\n\t\tdijkstra(gdist, goal, gsz);\n\t\tdijkstra(ldist, lpos, lsz);\n\t\tlpos[0] = npos;\n\t\tdijkstra(ndist, lpos, 1);\n\n\t\tans = INF;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\ta = gdist[i]+ndist[i]+ldist[i];\n\t\t\tif (a < ans) ans = a;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint nat_m,nat_h[111111],nat_n[111111*2],nat_t[111111*2];\nint nat_c[111111];\nint neko_m,neko_h[111111],neko_n[111111*2],neko_t[111111*2];\nint neko_c[111111],neko_c_natsu[111111];\nint q[555555],inq[111111],hd,tl;\nint nat_natsu_c[111111],neko_natsu_c[111111];\n\nint main(void)\n{\n  int n,m,nat,neko,u,v,i,e,p,res,T;\n  char c;\n  scanf(\"%d\",&T);\n  while( T-- ) {\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%d%d\",&nat,&neko);\n    nat_m = neko_m = 0;\n    for(i = 0; i <= n; i++) {\n      nat_h[i] = neko_h[i] = -1;\n      neko_c[i] = neko_c_natsu[i] = 1<<21;\n      nat_c[i] = 1<<21;\n    }\n#define add_edge1(n,h,t,m,u,v) (n[m]=h[u],h[u]=m,t[m]=v,++m)\n    for( i = 0; i < m; i++ ) {\n      scanf(\"%d%d %c\",&u,&v,&c);\n      if( c == 'N' ) {\n        add_edge1(nat_n,nat_h,nat_t,nat_m,u,v);\n        add_edge1(nat_n,nat_h,nat_t,nat_m,v,u);\n      }\n      if( c == 'L' ) {\n        add_edge1(neko_n,neko_h,neko_t,neko_m,u,v);\n        add_edge1(neko_n,neko_h,neko_t,neko_m,v,u);\n      }\n    }\n    nat_c[nat] = 0;\n    hd = tl = 0;\n    q[tl++] = nat;\n    while( hd != tl ) {\n      p = q[hd++];\n      for( e = nat_h[p]; e != -1; e = nat_n[e] ) {\n        if( nat_c[nat_t[e]] > nat_c[p]+1 ) {\n          nat_c[nat_t[e]] = nat_c[p]+1;\n          q[tl++] = nat_t[e];\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = 0; neko_c_natsu[0] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c_natsu[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c_natsu[neko_t[e]] > neko_c_natsu[p] ) {\n            neko_c_natsu[neko_t[e]] = neko_c_natsu[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c_natsu[nat_t[e]] > neko_c_natsu[p]+1 ) {\n          neko_c_natsu[nat_t[e]] = neko_c_natsu[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = neko; neko_c[neko] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c[neko_t[e]] > neko_c[p] ) {\n            neko_c[neko_t[e]] = neko_c[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c[nat_t[e]] > neko_c[p]+1 ) {\n          neko_c[nat_t[e]] = neko_c[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    res = 1<<21;\n    if( neko_c[0] == 0 ) res = 0;\n    for( i = 0; i <= n; i++ ) {\n      int k = nat_c[i]+neko_c[i]+neko_c_natsu[i];\n      if( res > k ) res = k;\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint nat_m,nat_h[111111],nat_n[111111*2],nat_t[111111*2];\nint nat_c[111111];\nint neko_m,neko_h[111111],neko_n[111111*2],neko_t[111111*2];\nint neko_can[111111],neko_can_natsu[111111];\nint neko_c[111111],neko_c_natsu[111111];\nint q[555555],inq[111111],hd,tl;\nint nat_natsu_c[111111],neko_natsu_c[111111];\n\nint main(void)\n{\n  int n,m,nat,neko,u,v,i,e,p,res,T;\n  char c;\n  scanf(\"%d\",&T);\n  while( T-- ) {\n    scanf(\"%d%d\",&n,&m);\n    for(i = 0; i <= n; i++) {\n      nat_h[i] = neko_h[i] = -1;\n      neko_can[i] = neko_can_natsu[i] = 0;\n      neko_c[i] = neko_c_natsu[i] = 1<<21;\n      nat_c[i] = 1<<21;\n    }\n    scanf(\"%d%d\",&nat,&neko);\n#define add_edge1(n,h,t,m,u,v) (n[m]=h[u],h[u]=m,t[m]=v,++m)\n    for( i = 0; i < m; i++ ) {\n      scanf(\"%d%d %c\",&u,&v,&c);\n      if( c == 'N' ) {\n        add_edge1(nat_n,nat_h,nat_t,nat_m,u,v);\n        add_edge1(nat_n,nat_h,nat_t,nat_m,v,u);\n      }\n      if( c == 'L' ) {\n        add_edge1(neko_n,neko_h,neko_t,neko_m,u,v);\n        add_edge1(neko_n,neko_h,neko_t,neko_m,v,u);\n      }\n    }\n    nat_c[nat] = 0;\n    hd = tl = 0;\n    q[tl++] = nat;\n    while( hd != tl ) {\n      p = q[hd++];\n      if( hd >= 555555 ) hd = 0;\n      for( e = nat_h[p]; e != -1; e = nat_n[e] ) {\n        if( nat_c[nat_t[e]] > nat_c[p]+1 ) {\n          nat_c[nat_t[e]] = nat_c[p]+1;\n          q[tl++] = nat_t[e];\n          if( tl >= 555555 ) tl = 0;\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = 0; neko_c_natsu[0] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( hd >= 555555 ) hd = 0;\n      if( neko_c_natsu[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c_natsu[neko_t[e]] > neko_c_natsu[p] ) {\n            neko_c_natsu[neko_t[e]] = neko_c_natsu[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n              if( tl >= 555555 ) tl = 0;\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c_natsu[nat_t[e]] > neko_c_natsu[p]+1 ) {\n          neko_c_natsu[nat_t[e]] = neko_c_natsu[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n            if( tl >= 555555 ) tl = 0;\n          }\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = neko; neko_c[neko] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( hd >= 555555 ) hd = 0;\n      if( neko_c[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c[neko_t[e]] > neko_c[p] ) {\n            neko_c[neko_t[e]] = neko_c[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n              if( tl >= 555555 ) tl = 0;\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c[nat_t[e]] > neko_c[p]+1 ) {\n          neko_c[nat_t[e]] = neko_c[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n            if( tl >= 555555 ) tl = 0;\n          }\n        }\n      }\n    }\n    res = 1<<21;\n    if( neko_c[0] == 0 ) res = 0;\n    for( i = 0; i <= n; i++ ) {\n      int k = nat_c[i]+neko_c[i]+neko_c_natsu[i];\n      if( res > k ) res = k;\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2193: The Door into Summer\n// 2018.1.7 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100003\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\n//void make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 150000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\nint n;\nint to[MAX][4]; char hi[MAX];\nint goal[MAX], gsz;\nint lpos[MAX], lsz;\nint gdist[MAX], ndist[MAX], ldist[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int *dist, int *start, int sz)\n{\n\tint i, s, d, e;\n\n\tmemset(dist, INF, n << 2);\n\tqsize = 0;\n\tfor (i = 0; i < sz; i++) dist[start[i]] = 0, enq(start[i], 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (d+1 < dist[e]) dist[e] = d+1, enq(e, d+1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint cno, m, np, lp, i, a, b, c, ans;\n\n\tcno = in();\n\twhile (cno--) {\n\t\tn = in()+1, m = in();\n\n\t\tmemset(hi, 0, n);\n\t\tmemset(rank, 0, n<<2);\t\t\t// union set, <<2 = 4 = sizeof(int)\n\t\tfor (i = 0; i < n; i++) p[i] = i;\n\n\t\tnp = in(), lp = in();\t// initial position\n\t\tfor (i = 0; i < m; i++) {\n\t\t\ta = in(), b = in(), c = getchar_unlocked(), getchar_unlocked();\n\t\t\tif (c == 'N') to[a][hi[a]++] = b, to[b][hi[b]++] = a;\n\t\t\telse union_set(a, b);\n\t\t}\n\n\t\tgsz = lsz = 0, a = find_set(0), b = find_set(lp);\n\t\tif (find_set(0) == b) { puts(\"0\"); continue; }\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif ((c = find_set(i)) == a) goal[gsz++] = i;\n\t\t\tif ( c                == b) lpos[lsz++] = i;\n\t\t}\n\n\t\tdijkstra(gdist, goal, gsz);\n\t\tdijkstra(ldist, lpos, lsz);\n\t\tlpos[0] = np;\n\t\tdijkstra(ndist, lpos, 1);\n\n\t\tans = INF;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\ta = gdist[i]+ndist[i]+ldist[i];\n\t\t\tif (a < ans) ans = a;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint nat_m,nat_h[111111],nat_n[111111*2],nat_t[111111*2];\nint nat_c[111111],nat_c_natsu[111111];\nint neko_m,neko_h[111111],neko_n[111111*2],neko_t[111111*2];\nint neko_can[111111],neko_can_natsu[111111];\nint neko_c[111111],neko_c_natsu[111111];\nint q[555555],inq[111111],hd,tl;\nint nat_natsu_c[111111],neko_natsu_c[111111];\n\nint main(void)\n{\n  int n,m,nat,neko,u,v,i,e,p,res,f;\n  char c;\n  f = 0;\n  while(scanf(\"%d%d\",&n,&m) == 2 ) {\n    //if( f ) puts(\"\"); f = 1;\n    for(i = 0; i <= n; i++) {\n      nat_h[i] = neko_h[i] = -1;\n      neko_can[i] = neko_can_natsu[i] = 0;\n      neko_c[i] = neko_c_natsu[i] = 1<<21;\n      nat_c[i] = nat_c_natsu[i] = 1<<21;\n    }\n    scanf(\"%d%d\",&nat,&neko);\n#define add_edge1(n,h,t,m,u,v) (n[m]=h[u],h[u]=m,t[m]=v,++m)\n    for( i = 0; i < m; i++ ) {\n      scanf(\"%d%d %c\",&u,&v,&c);\n      if( c == 'N' ) {\n        add_edge1(nat_n,nat_h,nat_t,nat_m,u,v);\n        add_edge1(nat_n,nat_h,nat_t,nat_m,v,u);\n      }\n      if( c == 'L' ) {\n        add_edge1(neko_n,neko_h,neko_t,neko_m,u,v);\n        add_edge1(neko_n,neko_h,neko_t,neko_m,v,u);\n      }\n    }\n    nat_c[nat] = 0;\n    hd = tl = 0;\n    q[tl++] = nat;\n    while( hd != tl ) {\n      p = q[hd++];\n      for( e = nat_h[p]; e != -1; e = nat_n[e] ) {\n        if( nat_c[nat_t[e]] > nat_c[p]+1 ) {\n          nat_c[nat_t[e]] = nat_c[p]+1;\n          q[tl++] = nat_t[e];\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = 0; neko_c_natsu[0] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c_natsu[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c_natsu[neko_t[e]] > neko_c_natsu[p] ) {\n            neko_c_natsu[neko_t[e]] = neko_c_natsu[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c_natsu[nat_t[e]] > neko_c_natsu[p]+1 ) {\n          neko_c_natsu[nat_t[e]] = neko_c_natsu[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = neko; neko_c[neko] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c[neko_t[e]] > neko_c[p] ) {\n            neko_c[neko_t[e]] = neko_c[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c[nat_t[e]] > neko_c[p]+1 ) {\n          neko_c[nat_t[e]] = neko_c[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    res = 1<<21;\n    if( neko_c[0] == 0 ) res = 0;\n    for( i = 0; i <= n; i++ ) {\n      int k = nat_c[i]+neko_c[i]+neko_c_natsu[i];\n      if( res > k ) res = k;\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint nat_m,nat_h[111111],nat_n[111111*2],nat_t[111111*2];\nint nat_c[111111],nat_c_natsu[111111];\nint neko_m,neko_h[111111],neko_n[111111*2],neko_t[111111*2];\nint neko_can[111111],neko_can_natsu[111111];\nint neko_c[111111],neko_c_natsu[111111];\nint q[555555],inq[111111],hd,tl;\nint nat_natsu_c[111111],neko_natsu_c[111111];\n\nint main(void)\n{\n  int n,m,nat,neko,u,v,i,e,p,res,T;\n  char c;\n  scanf(\"%d\",&T);\n  while( T-- ) {\n    scanf(\"%d%d\",&n,&m);\n    for(i = 0; i <= n; i++) {\n      nat_h[i] = neko_h[i] = -1;\n      neko_can[i] = neko_can_natsu[i] = 0;\n      neko_c[i] = neko_c_natsu[i] = 1<<21;\n      nat_c[i] = nat_c_natsu[i] = 1<<21;\n    }\n    scanf(\"%d%d\",&nat,&neko);\n#define add_edge1(n,h,t,m,u,v) (n[m]=h[u],h[u]=m,t[m]=v,++m)\n    for( i = 0; i < m; i++ ) {\n      scanf(\"%d%d %c\",&u,&v,&c);\n      if( c == 'N' ) {\n        add_edge1(nat_n,nat_h,nat_t,nat_m,u,v);\n        add_edge1(nat_n,nat_h,nat_t,nat_m,v,u);\n      }\n      if( c == 'L' ) {\n        add_edge1(neko_n,neko_h,neko_t,neko_m,u,v);\n        add_edge1(neko_n,neko_h,neko_t,neko_m,v,u);\n      }\n    }\n    nat_c[nat] = 0;\n    hd = tl = 0;\n    q[tl++] = nat;\n    while( hd != tl ) {\n      p = q[hd++];\n      for( e = nat_h[p]; e != -1; e = nat_n[e] ) {\n        if( nat_c[nat_t[e]] > nat_c[p]+1 ) {\n          nat_c[nat_t[e]] = nat_c[p]+1;\n          q[tl++] = nat_t[e];\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = 0; neko_c_natsu[0] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c_natsu[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c_natsu[neko_t[e]] > neko_c_natsu[p] ) {\n            neko_c_natsu[neko_t[e]] = neko_c_natsu[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c_natsu[nat_t[e]] > neko_c_natsu[p]+1 ) {\n          neko_c_natsu[nat_t[e]] = neko_c_natsu[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    memset(inq,0,sizeof(inq));\n    hd = tl = 0;\n    q[tl++] = neko; neko_c[neko] = 0; inq[neko] = 1;\n    while( hd != tl ) {\n      p = q[hd++]; inq[p] = 0;\n      if( neko_c[p] == 0 ) {\n        for(e = neko_h[p]; e != -1; e = neko_n[e]) {\n          if( neko_c[neko_t[e]] > neko_c[p] ) {\n            neko_c[neko_t[e]] = neko_c[p];\n            if( !inq[neko_t[e]] ) {\n              inq[neko_t[e]] = 1;\n              q[tl++] = neko_t[e];\n            }\n          }\n        }\n      }\n      for(e = nat_h[p]; e != -1; e = nat_n[e]) {\n        if( neko_c[nat_t[e]] > neko_c[p]+1 ) {\n          neko_c[nat_t[e]] = neko_c[p]+1;\n          if( !inq[nat_t[e]] ) {\n            inq[nat_t[e]] = 1;\n            q[tl++] = nat_t[e];\n          }\n        }\n      }\n    }\n    res = 1<<21;\n    if( neko_c[0] == 0 ) res = 0;\n    for( i = 0; i <= n; i++ ) {\n      int k = nat_c[i]+neko_c[i]+neko_c_natsu[i];\n      if( res > k ) res = k;\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString packageName = new Main().getClass().getPackage().getName();\n\t\t\tSystem.setIn(new FileInputStream(\"src/\" + packageName + \"/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/\" + packageName + \"/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile (t --> 0) solve();\n\n\t}\n\tvoid solve() {\n\t\tint n = sc.nextInt() + 1;\n\t\tint m = sc.nextInt();\n\n\t\tint sa = sc.nextInt();\n\t\tint sb = sc.nextInt();\n\n\t\tArrayList<ArrayList<E>> g = new ArrayList<ArrayList<E>>();\n\t\tfor (int i = 0; i < n; i++) g.add(new ArrayList<E>());\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint t = sc.next().charAt(0);\n\t\t\tg.get(a).add(new E(b, t));\n\t\t\tg.get(b).add(new E(a, t));\n\t\t}\n\n\t\tint ans = inf;\n\n\t\tint[] fromGoal = dijk(g, 0, true);\n\t\tint[] fromCat = dijk(g, sb, true);\n\t\tint[] fromMan = dijk(g, sa, false);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, fromGoal[i] + fromCat[i] + fromMan[i]);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tint inf = Integer.MAX_VALUE / 5;\n\n\tint[] dijk(ArrayList<ArrayList<E>> g, int s, boolean strict) {\n\t\tint n = g.size();\n\t\tint[] res = new int[n];\n\t\tfill(res, inf - 1);\n\t\tres[s] = 0;\n\t\tPriorityQueue<Tupple> q = new PriorityQueue<Tupple>();\n\t\tq.add(new Tupple(0, s));\n\t\twhile (!q.isEmpty()) {\n\t\t\tint cost = q.peek().a;\n\t\t\tint here  = q.peek().b;\n\t\t\tq.poll();\n\n\t\t\tif (cost != res[here]) continue;\n\n\t\t\tfor (E e : g.get(here)) {\n\t\t\t\tint ncost = 0;\n\t\t\t\tif (strict)\n\t\t\t\t{\n\t\t\t\t\tif (cost == 0 && e.type == 'L') ncost = 0;\n\t\t\t\t\telse if (cost > 0 && e.type == 'L') ncost = inf;\n\t\t\t\t\telse ncost = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (e.type == 'L') ncost = inf;\n\t\t\t\t\telse ncost = 1;\n\t\t\t\t}\n\t\t\t\tncost += cost;\n\t\t\t\tif (res[e.to] > ncost) {\n\t\t\t\t\tres[e.to] = ncost;\n\t\t\t\t\tq.add(new Tupple(ncost, e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass Tupple implements Comparable<Tupple> {\n\t\tint a, b;\n\n\t\tpublic int compareTo(Tupple o) {\n\t\t\tif (a != o.a) return a < o.a ? -1 : 1;\n\t\t\tif (b != o.b) return b < o.b ? -1 : 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic Tupple(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t}\n\n\tclass E {\n\t\tpublic E(int to, int type) {\n\t\t\tthis.to = to;\n\t\t\tthis.type = type;\n\t\t}\n\t\tint to;\n\t\tint type;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "package aoj2193;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString packageName = new Main().getClass().getPackage().getName();\n\t\t\tSystem.setIn(new FileInputStream(\"src/\" + packageName + \"/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/\" + packageName + \"/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile (t --> 0) solve();\n\n\t}\n\tvoid solve() {\n\t\tint n = sc.nextInt() + 1;\n\t\tint m = sc.nextInt();\n\n\t\tint sa = sc.nextInt();\n\t\tint sb = sc.nextInt();\n\n\t\tArrayList<ArrayList<E>> g = new ArrayList<ArrayList<E>>();\n\t\tfor (int i = 0; i < n; i++) g.add(new ArrayList<E>());\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint t = sc.next().charAt(0);\n\t\t\tg.get(a).add(new E(b, t));\n\t\t\tg.get(b).add(new E(a, t));\n\t\t}\n\n\t\tint ans = inf;\n\n\t\tint[] catOnly = dijk(g, sb, 'L', true);\n\t\tif (catOnly[0] == 0) ans = 0;\n\n\t\tint[] fromGoal = dijk(g, 0, 'L', true);\n\t\tint[] fromCat = dijk(g, sb, 'L', true);\n\t\tint[] fromMan = dijk(g, sa, 'X', false);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, fromGoal[i] + fromCat[i] + fromMan[i]);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tint inf = Integer.MAX_VALUE / 5;\n\n\tint[] dijk(ArrayList<ArrayList<E>> g, int s, int type, boolean strict) {\n\t\tint n = g.size();\n\t\tint[] res = new int[n];\n\t\tfill(res, inf);\n\t\tres[s] = 0;\n\t\tDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint here = q.pollFirst();\n\n\t\t\tfor (E e : g.get(here)) {\n\t\t\t\tint ncost = 0;\n\t\t\t\tif (strict) {\n\t\t\t\t\tif (e.type == type) {\n\t\t\t\t\t\tncost = res[here] + (res[here] > 0 ? inf : 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncost = res[here] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tncost = (res[here]) + (e.type == type ? 0 : 1);\n\t\t\t\t}\n\t\t\t\tif (res[e.to] > ncost) {\n\t\t\t\t\tres[e.to] = ncost;\n\t\t\t\t\tif (e.type == type)\n\t\t\t\t\t\tq.addFirst(e.to);\n\t\t\t\t\telse\n\t\t\t\t\t\tq.addLast(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass E {\n\t\tpublic E(int to, int type) {\n\t\t\tthis.to = to;\n\t\t\tthis.type = type;\n\t\t}\n\t\tint to;\n\t\tint type;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString packageName = new Main().getClass().getPackage().getName();\n\t\t\tSystem.setIn(new FileInputStream(\"src/\" + packageName + \"/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/\" + packageName + \"/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile (t --> 0) solve();\n\n\t}\n\tvoid solve() {\n\t\tint n = sc.nextInt() + 1;\n\t\tint m = sc.nextInt();\n\n\t\tint sa = sc.nextInt();\n\t\tint sb = sc.nextInt();\n\n\t\tArrayList<ArrayList<E>> g = new ArrayList<ArrayList<E>>();\n\t\tfor (int i = 0; i < n; i++) g.add(new ArrayList<E>());\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint t = sc.next().charAt(0);\n\t\t\tg.get(a).add(new E(b, t));\n\t\t\tg.get(b).add(new E(a, t));\n\t\t}\n\n\t\tint ans = inf;\n\n\t\tint[] fromGoal = dijk(g, 0, true);\n\t\tint[] fromCat = dijk(g, sb, true);\n\t\tint[] fromMan = dijk(g, sa, false);\n\n\t\tif (fromCat[0] == 0) ans = 0;\n\t\telse\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tans = min(ans, fromGoal[i] + fromCat[i] + fromMan[i]);\n\t\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tint inf = Integer.MAX_VALUE / 5;\n\n\tint[] dijk(ArrayList<ArrayList<E>> g, int s, boolean strict) {\n\t\tint n = g.size();\n\t\tint[] res = new int[n];\n\t\tfill(res, inf - 1);\n\t\tres[s] = 0;\n\t\tPriorityQueue<Tupple> q = new PriorityQueue<Tupple>();\n\t\tq.add(new Tupple(0, s));\n\t\twhile (!q.isEmpty()) {\n\t\t\tint cost = q.peek().a;\n\t\t\tint here  = q.peek().b;\n\t\t\tq.poll();\n\n\t\t\tif (cost != res[here]) continue;\n\n\t\t\tfor (E e : g.get(here)) {\n\t\t\t\tint ncost = 0;\n\t\t\t\tif (strict)\n\t\t\t\t{\n\t\t\t\t\tif (cost == 0 && e.type == 'L') ncost = 0;\n\t\t\t\t\telse if (cost > 0 && e.type == 'L') ncost = inf;\n\t\t\t\t\telse ncost = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (e.type == 'L') ncost = inf;\n\t\t\t\t\telse ncost = 1;\n\t\t\t\t}\n\t\t\t\tncost += cost;\n\t\t\t\tif (res[e.to] > ncost) {\n\t\t\t\t\tres[e.to] = ncost;\n\t\t\t\t\tq.add(new Tupple(ncost, e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass Tupple implements Comparable<Tupple> {\n\t\tint a, b;\n\n\t\tpublic int compareTo(Tupple o) {\n\t\t\tif (a != o.a) return a < o.a ? -1 : 1;\n\t\t\tif (b != o.b) return b < o.b ? -1 : 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic Tupple(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\n\t}\n\n\tclass E {\n\t\tpublic E(int to, int type) {\n\t\t\tthis.to = to;\n\t\t\tthis.type = type;\n\t\t}\n\t\tint to;\n\t\tint type;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString packageName = new Main().getClass().getPackage().getName();\n\t\t\tSystem.setIn(new FileInputStream(\"src/\" + packageName + \"/input.txt\"));\n\t\t\t// System.setOut(new PrintStream(new FileOutputStream(\"src/\" + packageName + \"/result.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t} catch (NullPointerException e) {\n\t\t}\n\t\tnew Main().run();\n\t}\n\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc;\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile (t --> 0) solve();\n\n\t}\n\tvoid solve() {\n\t\tint n = sc.nextInt() + 1;\n\t\tint m = sc.nextInt();\n\n\t\tint sa = sc.nextInt();\n\t\tint sb = sc.nextInt();\n\n\t\tArrayList<ArrayList<E>> g = new ArrayList<ArrayList<E>>();\n\t\tfor (int i = 0; i < n; i++) g.add(new ArrayList<E>());\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = sc.nextInt();\n\t\t\tint b = sc.nextInt();\n\t\t\tint t = sc.next().charAt(0);\n\t\t\tg.get(a).add(new E(b, t));\n\t\t\tg.get(b).add(new E(a, t));\n\t\t}\n\n\t\tint ans = inf;\n\n\t\tint[] catOnly = dijk(g, sb, 'L', true);\n\t\tif (catOnly[0] == 0) ans = 0;\n\n\t\tint[] fromGoal = dijk(g, 0, 'L', true);\n\t\tint[] fromCat = dijk(g, sb, 'L', true);\n\t\tint[] fromMan = dijk(g, sa, 'X', false);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, fromGoal[i] + fromCat[i] + fromMan[i]);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tint inf = Integer.MAX_VALUE / 5;\n\n\tint[] dijk(ArrayList<ArrayList<E>> g, int s, int type, boolean strict) {\n\t\tint n = g.size();\n\t\tint[] res = new int[n];\n\t\tfill(res, inf);\n\t\tres[s] = 0;\n\t\tDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(s);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint here = q.pollFirst();\n\n\t\t\tfor (E e : g.get(here)) {\n\t\t\t\tint ncost = 0;\n\t\t\t\tif (strict) {\n\t\t\t\t\tif (e.type == type) {\n\t\t\t\t\t\tncost = res[here] + (res[here] > 0 ? inf : 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tncost = res[here] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tncost = (res[here]) + (e.type == type ? 0 : 1);\n\t\t\t\t}\n\t\t\t\tif (res[e.to] > ncost) {\n\t\t\t\t\tres[e.to] = ncost;\n\t\t\t\t\tif (e.type == type)\n\t\t\t\t\t\tq.addFirst(e.to);\n\t\t\t\t\telse\n\t\t\t\t\t\tq.addLast(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass E {\n\t\tpublic E(int to, int type) {\n\t\t\tthis.to = to;\n\t\t\tthis.type = type;\n\t\t}\n\t\tint to;\n\t\tint type;\n\t}\n\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\nINF = 10 ** 9\nL = input()\n\nfor loop in range(L):\n    n, m = map(int, raw_input().split())\n    S, T = map(int, raw_input().split())\n    E = [[] for i in range(n + 1)]\n    for i in range(m):\n        u, v, tp = raw_input().split()\n        u = int(u)\n        v = int(v)\n        E[u].append((v, tp))\n        E[v].append((u, tp))\n    C1 = [INF] * (n + 1)\n    que = deque()\n    que.append((S, 0))\n    while len(que) > 0:\n        p = que.popleft()\n        if C1[p[0]] <= p[1]:\n            continue\n        C1[p[0]] = p[1]\n        for e in E[p[0]]:\n            if e[1] == 'N':\n                que.append((e[0], p[1] + 1))\n    \n    C2 = [INF] * (n + 1)\n    que = deque()\n    que.append((T, 0))\n    while len(que) > 0:\n        p = que.popleft()\n        if C2[p[0]] <= p[1]:\n            continue\n        C2[p[0]] = p[1]\n        for e in E[p[0]]:\n            if e[1] == 'L':\n                que.append((e[0], p[1]))\n    if C2[0] == 0:\n        print 0\n        continue\n    que = deque()\n    for i in range(n + 1):\n        if C2[i] == 0:\n            que.append((i, 0))\n    C2 = [INF] * (n + 1)\n    while len(que) > 0:\n        p = que.popleft()\n        if C2[p[0]] <= p[1]:\n            continue\n        C2[p[0]] = p[1]\n        for e in E[p[0]]:\n            if e[1] == 'N':\n                que.append((e[0], p[1] + 1))\n    \n    C3 = [INF] * (n + 1)\n    que = deque()\n    que.append((0, 0))\n    while len(que) > 0:\n        p = que.popleft()\n        if C3[p[0]] <= p[1]:\n            continue\n        C3[p[0]] = p[1]\n        for e in E[p[0]]:\n            if e[1] == 'L':\n                que.append((e[0], p[1]))\n    que = deque()\n    for i in range(n + 1):\n        if C3[i] == 0:\n            que.append((i, 0))\n    C3 = [INF] * (n + 1)\n    while len(que) > 0:\n        p = que.popleft()\n        if C3[p[0]] <= p[1]:\n            continue\n        C3[p[0]] = p[1]\n        for e in E[p[0]]:\n            if e[1] == 'N':\n                que.append((e[0], p[1] + 1))\n    ans = 10 ** 9\n    for i in range(1, n + 1):\n        ans = min(ans, C1[i] + C2[i] + C3[i])\n    print ans\n"
  }
]