[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAX_N 100005\n\nint A[MAX_N];\nint N;\n\nint max_in_range(int L, int R) {\n    int max_val = INT_MIN;\n    for (int i = L; i <= R; i++) {\n        max_val = (A[i] > max_val) ? A[i] : max_val;\n    }\n    return max_val;\n}\n\nint find_min_index(int X, int V) {\n    for (int j = X; j < N; j++) {\n        if (A[j] >= V) {\n            return j;\n        }\n    }\n    return N + 1;\n}\n\nint main() {\n    int Q;\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    scanf(\"%d\", &Q);\n    \n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        \n        if (type == 1) {\n            int X, V;\n            scanf(\"%d %d\", &X, &V);\n            A[X-1] = V;\n        }\n        else if (type == 2) {\n            int L, R;\n            scanf(\"%d %d\", &L, &R);\n            printf(\"%d\\n\", max_in_range(L-1, R-1));\n        }\n        else if (type == 3) {\n            int X, V;\n            scanf(\"%d %d\", &X, &V);\n            printf(\"%d\\n\", find_min_index(X-1, V));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int max_val;\n    int left;\n    int right;\n} SegmentTreeNode;\n\nSegmentTreeNode segment_tree[4 * MAX_N];\nint A[MAX_N];\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nvoid build_segment_tree(int node, int left, int right) {\n    segment_tree[node].left = left;\n    segment_tree[node].right = right;\n    if (left == right) {\n        segment_tree[node].max_val = A[left];\n        return;\n    }\n    int mid = (left + right) / 2;\n    build_segment_tree(2 * node, left, mid);\n    build_segment_tree(2 * node + 1, mid + 1, right);\n    segment_tree[node].max_val = max(segment_tree[2 * node].max_val, segment_tree[2 * node + 1].max_val);\n}\n\nvoid update_segment_tree(int node, int index, int value) {\n    if (segment_tree[node].left == segment_tree[node].right) {\n        segment_tree[node].max_val = value;\n        return;\n    }\n    int mid = (segment_tree[node].left + segment_tree[node].right) / 2;\n    if (index <= mid) {\n        update_segment_tree(2 * node, index, value);\n    } else {\n        update_segment_tree(2 * node + 1, index, value);\n    }\n    segment_tree[node].max_val = max(segment_tree[2 * node].max_val, segment_tree[2 * node + 1].max_val);\n}\n\nint query_segment_tree(int node, int l, int r) {\n    if (segment_tree[node].right < l || segment_tree[node].left > r) {\n        return INT_MIN;\n    }\n    if (l <= segment_tree[node].left && segment_tree[node].right <= r) {\n        return segment_tree[node].max_val;\n    }\n    return max(query_segment_tree(2 * node, l, r), query_segment_tree(2 * node + 1, l, r));\n}\n\nint find_min_index(int node, int x, int v) {\n    if (segment_tree[node].right < x) {\n        return -1;\n    }\n    if (segment_tree[node].left == segment_tree[node].right) {\n        if (segment_tree[node].max_val >= v) {\n            return segment_tree[node].left;\n        } else {\n            return -1;\n        }\n    }\n    int left_child = 2 * node;\n    int right_child = 2 * node + 1;\n    int res = -1;\n    if (segment_tree[left_child].right >= x && segment_tree[left_child].max_val >= v) {\n        res = find_min_index(left_child, x, v);\n        if (res != -1) {\n            return res;\n        }\n    }\n    if (segment_tree[right_child].max_val >= v) {\n        res = find_min_index(right_child, x, v);\n    }\n    return res;\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    build_segment_tree(1, 0, N - 1);\n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 1) {\n            int X, V;\n            scanf(\"%d %d\", &X, &V);\n            X--;\n            A[X] = V;\n            update_segment_tree(1, X, V);\n        } else if (type == 2) {\n            int L, R;\n            scanf(\"%d %d\", &L, &R);\n            L--; R--;\n            printf(\"%d\\n\", query_segment_tree(1, L, R));\n        } else if (type == 3) {\n            int X, V;\n            scanf(\"%d %d\", &X, &V);\n            X--;\n            int j = find_min_index(1, X, V);\n            if (j == -1) {\n                printf(\"%d\\n\", N + 1);\n            } else {\n                printf(\"%d\\n\", j + 1);\n            }\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    int n;\n    vector<int> max_tree;\n    vector<int> arr;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            max_tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node, start, mid);\n            build(2 * node + 1, mid + 1, end);\n            max_tree[node] = max(max_tree[2 * node], max_tree[2 * node + 1]);\n        }\n    }\n\n    void update(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            arr[idx] = val;\n            max_tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node, start, mid, idx, val);\n            } else {\n                update(2 * node + 1, mid + 1, end, idx, val);\n            }\n            max_tree[node] = max(max_tree[2 * node], max_tree[2 * node + 1]);\n        }\n    }\n\n    int query_max(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return INT_MIN;\n        }\n        if (l <= start && end <= r) {\n            return max_tree[node];\n        }\n        int mid = (start + end) / 2;\n        int left = query_max(2 * node, start, mid, l, r);\n        int right = query_max(2 * node + 1, mid + 1, end, l, r);\n        return max(left, right);\n    }\n\n    int query_first_above(int node, int start, int end, int x, int v) {\n        if (end < x) return n + 1;\n        if (max_tree[node] < v) return n + 1;\n        if (start == end) return start;\n        int mid = (start + end) / 2;\n        int left = query_first_above(2 * node, start, mid, x, v);\n        if (left != n + 1) return left;\n        return query_first_above(2 * node + 1, mid + 1, end, x, v);\n    }\n\npublic:\n    SegmentTree(const vector<int>& input) {\n        arr = input;\n        n = arr.size();\n        max_tree.resize(4 * n);\n        build(1, 0, n - 1);\n    }\n\n    void update(int idx, int val) {\n        update(1, 0, n - 1, idx, val);\n    }\n\n    int query_max(int l, int r) {\n        return query_max(1, 0, n - 1, l, r);\n    }\n\n    int query_first_above(int x, int v) {\n        return query_first_above(1, 0, n - 1, x, v) + 1;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n\n    SegmentTree st(A);\n\n    while (Q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int X, V;\n            cin >> X >> V;\n            st.update(X - 1, V);\n        } else if (type == 2) {\n            int L, R;\n            cin >> L >> R;\n            cout << st.query_max(L - 1, R - 1) << '\\n';\n        } else if (type == 3) {\n            int X, V;\n            cin >> X >> V;\n            int j = st.query_first_above(X - 1, V);\n            cout << j << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass SegmentTree {\n    int[] maxTree;\n    int[] array;\n    int n;\n\n    public SegmentTree(int[] arr) {\n        this.array = arr;\n        this.n = arr.length;\n        this.maxTree = new int[4 * n];\n        buildMaxTree(0, 0, n - 1);\n    }\n\n    private void buildMaxTree(int node, int start, int end) {\n        if (start == end) {\n            maxTree[node] = array[start];\n        } else {\n            int mid = (start + end) / 2;\n            buildMaxTree(2 * node + 1, start, mid);\n            buildMaxTree(2 * node + 2, mid + 1, end);\n            maxTree[node] = Math.max(maxTree[2 * node + 1], maxTree[2 * node + 2]);\n        }\n    }\n\n    public void update(int index, int value) {\n        update(0, 0, n - 1, index, value);\n    }\n\n    private void update(int node, int start, int end, int index, int value) {\n        if (start == end) {\n            array[index] = value;\n            maxTree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (index <= mid) {\n                update(2 * node + 1, start, mid, index, value);\n            } else {\n                update(2 * node + 2, mid + 1, end, index, value);\n            }\n            maxTree[node] = Math.max(maxTree[2 * node + 1], maxTree[2 * node + 2]);\n        }\n    }\n\n    public int queryMax(int l, int r) {\n        return queryMax(0, 0, n - 1, l, r);\n    }\n\n    private int queryMax(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return Integer.MIN_VALUE;\n        }\n        if (l <= start && end <= r) {\n            return maxTree[node];\n        }\n        int mid = (start + end) / 2;\n        int left = queryMax(2 * node + 1, start, mid, l, r);\n        int right = queryMax(2 * node + 2, mid + 1, end, l, r);\n        return Math.max(left, right);\n    }\n\n    public int findFirst(int x, int v) {\n        return findFirst(0, 0, n - 1, x, n - 1, v);\n    }\n\n    private int findFirst(int node, int start, int end, int l, int r, int v) {\n        if (r < start || end < l) {\n            return n + 1;\n        }\n        if (maxTree[node] < v) {\n            return n + 1;\n        }\n        if (start == end) {\n            return start + 1;\n        }\n        int mid = (start + end) / 2;\n        int left = findFirst(2 * node + 1, start, mid, l, r, v);\n        if (left != n + 1) {\n            return left;\n        }\n        return findFirst(2 * node + 2, mid + 1, end, l, r, v);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int Q = Integer.parseInt(st.nextToken());\n        int[] A = new int[N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            A[i] = Integer.parseInt(st.nextToken());\n        }\n        SegmentTree stree = new SegmentTree(A);\n        while (Q-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n            if (type == 1) {\n                int X = Integer.parseInt(st.nextToken()) - 1;\n                int V = Integer.parseInt(st.nextToken());\n                stree.update(X, V);\n            } else if (type == 2) {\n                int L = Integer.parseInt(st.nextToken()) - 1;\n                int R = Integer.parseInt(st.nextToken()) - 1;\n                out.println(stree.queryMax(L, R));\n            } else if (type == 3) {\n                int X = Integer.parseInt(st.nextToken()) - 1;\n                int V = Integer.parseInt(st.nextToken());\n                int res = stree.findFirst(X, V);\n                out.println(res);\n            }\n        }\n        out.flush();\n    }\n}",
    "timestamp": "2025-08-05 22:27:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static class SegmentTree {\n        int[] tree;\n        int[] arr;\n        int n;\n\n        SegmentTree(int[] input) {\n            n = input.length;\n            arr = input.clone();\n            tree = new int[4 * n];\n            build(0, 0, n - 1);\n        }\n\n        void build(int node, int start, int end) {\n            if (start == end) {\n                tree[node] = arr[start];\n                return;\n            }\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n\n        void update(int node, int start, int end, int index, int val) {\n            if (start == end) {\n                arr[index] = val;\n                tree[node] = val;\n                return;\n            }\n            int mid = (start + end) / 2;\n            if (index <= mid)\n                update(2 * node + 1, start, mid, index, val);\n            else\n                update(2 * node + 2, mid + 1, end, index, val);\n            tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n\n        int query(int node, int start, int end, int left, int right) {\n            if (right < start || left > end)\n                return Integer.MIN_VALUE;\n            if (left <= start && end <= right)\n                return tree[node];\n            int mid = (start + end) / 2;\n            int leftMax = query(2 * node + 1, start, mid, left, right);\n            int rightMax = query(2 * node + 2, mid + 1, end, left, right);\n            return Math.max(leftMax, rightMax);\n        }\n\n        int findIndex(int x, int v, int n) {\n            for (int j = x; j < n; j++) {\n                if (arr[j] >= v)\n                    return j;\n            }\n            return n + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++)\n            A[i] = sc.nextInt();\n\n        SegmentTree st = new SegmentTree(A);\n        int Q = sc.nextInt();\n\n        while (Q-- > 0) {\n            int type = sc.nextInt();\n            if (type == 1) {\n                int X = sc.nextInt() - 1;\n                int V = sc.nextInt();\n                st.update(0, 0, N - 1, X, V);\n            } else if (type == 2) {\n                int L = sc.nextInt() - 1;\n                int R = sc.nextInt() - 1;\n                System.out.println(st.query(0, 0, N - 1, L, R));\n            } else {\n                int X = sc.nextInt() - 1;\n                int V = sc.nextInt();\n                System.out.println(st.findIndex(X, V, N) + 1);\n            }\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:27:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    vector<int> arr;\n    int n;\n\n    void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    void update(int node, int start, int end, int index, int val) {\n        if (start == end) {\n            arr[index] = val;\n            tree[node] = val;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (index <= mid)\n            update(2 * node, start, mid, index, val);\n        else\n            update(2 * node + 1, mid + 1, end, index, val);\n        tree[node] = max(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || l > end)\n            return INT_MIN;\n        if (l <= start && end <= r)\n            return tree[node];\n        int mid = (start + end) / 2;\n        int left = query(2 * node, start, mid, l, r);\n        int right = query(2 * node + 1, mid + 1, end, l, r);\n        return max(left, right);\n    }\n\npublic:\n    SegmentTree(vector<int>& input) {\n        arr = input;\n        n = input.size();\n        tree.resize(4 * n);\n        build(1, 0, n - 1);\n    }\n\n    void updateValue(int index, int val) {\n        update(1, 0, n - 1, index, val);\n    }\n\n    int getMax(int l, int r) {\n        return query(1, 0, n - 1, l, r);\n    }\n\n    int findNextGreaterOrEqual(int x, int v) {\n        for (int j = x; j < n; j++) {\n            if (arr[j] >= v)\n                return j;\n        }\n        return n + 1;\n    }\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<int> A(N);\n    for (int i = 0; i < N; i++)\n        cin >> A[i];\n\n    SegmentTree st(A);\n\n    while (Q--) {\n        int type;\n        cin >> type;\n\n        if (type == 1) {\n            int X, V;\n            cin >> X >> V;\n            st.updateValue(X - 1, V);\n        } else if (type == 2) {\n            int L, R;\n            cin >> L >> R;\n            cout << st.getMax(L - 1, R - 1) << endl;\n        } else {\n            int X, V;\n            cin >> X >> V;\n            cout << st.findNextGreaterOrEqual(X - 1, V) + 1 << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:27:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def processQueries(self, N, A, Q, queries):\n        import bisect\n        \n        def replace_index(x, v):\n            nonlocal A\n            A[x] = v\n        \n        def max_in_subarray(l, r):\n            return max(A[l:r + 1])\n        \n        def find_min_index(x, v):\n            for j in range(x, N):\n                if A[j] >= v:\n                    return j\n            return N + 1\n\n        results = []\n\n        for query in queries:\n            if query[0] == 1:\n                _, x, v = query\n                replace_index(x - 1, v)\n            elif query[0] == 2:\n                _, l, r = query\n                results.append(max_in_subarray(l - 1, r - 1))\n            elif query[0] == 3:\n                _, x, v = query\n                results.append(find_min_index(x - 1, v))\n        \n        return results",
    "timestamp": "2025-08-13 10:35:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ArrayProcessor {\n    int[] arr;\n    SegmentTree segmentTree;\n\n    public ArrayProcessor(int[] arr) {\n        this.arr = arr.clone();\n        this.segmentTree = new SegmentTree(this.arr);\n    }\n\n    public void replace(int x, int v) {\n        arr[x] = v;\n        segmentTree.update(x, v);\n    }\n\n    public int maxInRange(int l, int r) {\n        return segmentTree.rangeMaxQuery(l, r);\n    }\n\n    public int findMinimumIndex(int x, int v) {\n        for (int j = x; j < arr.length; j++) {\n            if (arr[j] >= v) {\n                return j;\n            }\n        }\n        return arr.length + 1;\n    }\n\n    static class SegmentTree {\n        int[] tree;\n        int n;\n\n        SegmentTree(int[] arr) {\n            n = arr.length;\n            tree = new int[4 * n];\n            build(arr, 0, 0, n - 1);\n        }\n\n        void build(int[] arr, int node, int start, int end) {\n            if (start == end) {\n                tree[node] = arr[start];\n            } else {\n                int mid = (start + end) / 2;\n                build(arr, 2 * node + 1, start, mid);\n                build(arr, 2 * node + 2, mid + 1, end);\n                tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n\n        void update(int idx, int value) {\n            updateUtil(0, 0, n - 1, idx, value);\n        }\n\n        void updateUtil(int node, int start, int end, int idx, int value) {\n            if (start == end) {\n                tree[node] = value;\n            } else {\n                int mid = (start + end) / 2;\n                if (start <= idx && idx <= mid) {\n                    updateUtil(2 * node + 1, start, mid, idx, value);\n                } else {\n                    updateUtil(2 * node + 2, mid + 1, end, idx, value);\n                }\n                tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);\n            }\n        }\n\n        int rangeMaxQuery(int l, int r) {\n            return rangeMaxQueryUtil(0, 0, n - 1, l, r);\n        }\n\n        int rangeMaxQueryUtil(int node, int start, int end, int l, int r) {\n            if (r < start || end < l) {\n                return Integer.MIN_VALUE;\n            }\n            if (l <= start && end <= r) {\n                return tree[node];\n            }\n            int mid = (start + end) / 2;\n            int p1 = rangeMaxQueryUtil(2 * node + 1, start, mid, l, r);\n            int p2 = rangeMaxQueryUtil(2 * node + 2, mid + 1, end, l, r);\n            return Math.max(p1, p2);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 5};\n        ArrayProcessor processor = new ArrayProcessor(array);\n        \n        // Example Queries\n        processor.replace(2, 6);\n        System.out.println(processor.maxInRange(1, 3)); // Output maximum value in range 1 to 3\n        System.out.println(processor.findMinimumIndex(1, 3)); // Output minimum index j\n    }\n}",
    "timestamp": "2025-08-13 10:35:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAXN 100000\n\nint A[MAXN];\n\nint query1(int X, int V) {\n    A[X] = V;\n    return 0;\n}\n\nint query2(int L, int R) {\n    int maxVal = INT_MIN;\n    for(int i = L; i <= R; i++) {\n        if(A[i] > maxVal) {\n            maxVal = A[i];\n        }\n    }\n    return maxVal;\n}\n\nint query3(int X, int N, int V) {\n    for(int j = X; j < N; j++) {\n        if(A[j] >= V) {\n            return j;\n        }\n    }\n    return N + 1;\n}\n\nint main() {\n    int N, Q, type, X, V, L, R;\n    scanf(\"%d %d\", &N, &Q);\n    \n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    for(int i = 0; i < Q; i++) {\n        scanf(\"%d\", &type);\n        if(type == 1) {\n            scanf(\"%d %d\", &X, &V);\n            query1(X, V);\n        } else if(type == 2) {\n            scanf(\"%d %d\", &L, &R);\n            printf(\"%d\\n\", query2(L, R));\n        } else if(type == 3) {\n            scanf(\"%d %d\", &X, &V);\n            printf(\"%d\\n\", query3(X, N, V));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:35:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.build(arr, 1, 0, self.n - 1)\n\n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n            return\n        \n        mid = (start + end) // 2\n        self.build(arr, 2*node, start, mid)\n        self.build(arr, 2*node+1, mid+1, end)\n        self.tree[node] = max(self.tree[2*node], self.tree[2*node+1])\n\n    def update(self, node, start, end, index, val):\n        if start == end:\n            self.tree[node] = val\n            return\n        \n        mid = (start + end) // 2\n        if index <= mid:\n            self.update(2*node, start, mid, index, val)\n        else:\n            self.update(2*node+1, mid+1, end, index, val)\n        \n        self.tree[node] = max(self.tree[2*node], self.tree[2*node+1])\n\n    def query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return float('-inf')\n        \n        if l <= start and end <= r:\n            return self.tree[node]\n        \n        mid = (start + end) // 2\n        left = self.query(2*node, start, mid, l, r)\n        right = self.query(2*node+1, mid+1, end, l, r)\n        \n        return max(left, right)\n\ndef solve(N, A, Q):\n    st = SegmentTree(A)\n    result = []\n\n    for query in Q:\n        if query[0] == 1:\n            x, v = query[1], query[2]\n            st.update(1, 0, N-1, x-1, v)\n            A[x-1] = v\n        elif query[0] == 2:\n            l, r = query[1], query[2]\n            result.append(st.query(1, 0, N-1, l-1, r-1))\n        else:\n            x, v = query[1], query[2]\n            j = N + 1\n            for i in range(x-1, N):\n                if A[i] >= v:\n                    j = i + 1\n                    break\n            result.append(j)\n\n    return result\n\n# Example usage\nN = 5\nA = [1, 3, 2, 4, 5]\nQ = [[1, 2, 6], [2, 1, 4], [3, 2, 4]]\nprint(solve(N, A, Q))",
    "timestamp": "2025-08-13 10:35:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.size = 1 << (math.ceil(math.log2(self.n)) + 1)\n        self.max_tree = [ -sys.maxsize - 1 ] * (2 * self.size)\n        self.data = data\n        \n        for i in range(self.n):\n            self.max_tree[self.size + i] = data[i]\n        \n        for i in range(self.size - 1, 0, -1):\n            self.max_tree[i] = max(self.max_tree[2 * i], self.max_tree[2 * i + 1])\n    \n    def update(self, pos, value):\n        pos += self.size\n        self.max_tree[pos] = value\n        pos >>= 1\n        while pos >= 1:\n            new_val = max(self.max_tree[2 * pos], self.max_tree[2 * pos + 1])\n            if self.max_tree[pos] == new_val:\n                break\n            self.max_tree[pos] = new_val\n            pos >>= 1\n    \n    def query_max(self, l, r):\n        res = -sys.maxsize - 1\n        l += self.size\n        r += self.size\n        while l <= r:\n            if l % 2 == 1:\n                res = max(res, self.max_tree[l])\n                l += 1\n            if r % 2 == 0:\n                res = max(res, self.max_tree[r])\n                r -= 1\n            l >>= 1\n            r >>= 1\n        return res\n    \n    def find_first_above(self, x, v):\n        pos = x + self.size\n        if self.max_tree[pos] >= v:\n            return x + 1\n        \n        while pos > 1:\n            if pos % 2 == 0 and self.max_tree[pos + 1] >= v:\n                pos += 1\n                break\n            pos >>= 1\n        \n        if pos == 1:\n            return self.n + 1\n        \n        while pos < self.size:\n            if self.max_tree[2 * pos] >= v:\n                pos = 2 * pos\n            else:\n                pos = 2 * pos + 1\n        \n        return (pos - self.size) + 1\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    A = list(map(int, input[ptr:ptr+N]))\n    ptr += N\n    \n    st = SegmentTree(A)\n    \n    for _ in range(Q):\n        query = input[ptr]\n        ptr += 1\n        if query == '1':\n            X = int(input[ptr]) - 1\n            ptr += 1\n            V = int(input[ptr])\n            ptr += 1\n            st.update(X, V)\n            A[X] = V\n        elif query == '2':\n            L = int(input[ptr]) - 1\n            ptr += 1\n            R = int(input[ptr]) - 1\n            ptr += 1\n            print(st.query_max(L, R))\n        elif query == '3':\n            X = int(input[ptr]) - 1\n            ptr += 1\n            V = int(input[ptr])\n            ptr += 1\n            res = st.find_first_above(X, V)\n            print(res if res <= N else N + 1)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:41:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass SegmentTree {\npublic:\n    SegmentTree(const vector<int>& data) {\n        size = data.size();\n        tree.resize(size * 4);\n        build(data, 0, 0, size - 1);\n    }\n\n    void update(int idx, int value, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx <= mid) {\n                update(idx, value, node * 2 + 1, start, mid);\n            } else {\n                update(idx, value, node * 2 + 2, mid + 1, end);\n            }\n            tree[node] = max(tree[node * 2 + 1], tree[node * 2 + 2]);\n        }\n    }\n\n    void update(int idx, int value) {\n        update(idx, value, 0, 0, size - 1);\n    }\n\n    int queryMax(int L, int R, int node, int start, int end) {\n        if (start >= L && end <= R) {\n            return tree[node];\n        }\n        if (end < L || start > R) {\n            return INT_MIN;\n        }\n        int mid = (start + end) / 2;\n        int leftMax = queryMax(L, R, node * 2 + 1, start, mid);\n        int rightMax = queryMax(L, R, node * 2 + 2, mid + 1, end);\n        return max(leftMax, rightMax);\n    }\n\n    int queryMax(int L, int R) {\n        return queryMax(L, R, 0, 0, size - 1);\n    }\n\nprivate:\n    vector<int> tree;\n    int size;\n\n    void build(const vector<int>& data, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = data[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(data, node * 2 + 1, start, mid);\n        build(data, node * 2 + 2, mid + 1, end);\n        tree[node] = max(tree[node * 2 + 1], tree[node * 2 + 2]);\n    }\n};\n\nint findMinIndex(const vector<int>& A, int X, int V) {\n    for (int j = X; j < A.size(); ++j) {\n        if (A[j] >= V) {\n            return j;\n        }\n    }\n    return A.size() + 1;\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n    \n    SegmentTree segmentTree(A);\n    \n    while (Q--) {\n        int type;\n        cin >> type;\n        if (type == 1) {\n            int X, V;\n            cin >> X >> V;\n            segmentTree.update(X, V);\n            A[X] = V;\n        } else if (type == 2) {\n            int L, R;\n            cin >> L >> R;\n            cout << segmentTree.queryMax(L, R) << endl;\n        } else if (type == 3) {\n            int X, V;\n            cin >> X >> V;\n            cout << findMinIndex(A, X, V) << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:00:07"
  }
]