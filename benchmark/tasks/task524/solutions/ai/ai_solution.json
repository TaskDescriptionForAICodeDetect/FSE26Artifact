[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 10\n#define MAX_M 10\n\ntypedef struct {\n    int cylinders[MAX_N];\n    int turns;\n} State;\n\nint isTarget(int* cylinders, int* target, int N) {\n    for (int i = 0; i < N; i++) {\n        if (cylinders[i] != target[i]) return 0;\n    }\n    return 1;\n}\n\nint solve(int N, int M, int* target) {\n    int visited[MAX_M][MAX_M][MAX_M][MAX_M][MAX_M][MAX_M] = {0};\n    State queue[1000000];\n    int front = 0, rear = 0;\n\n    State initial = {{0}, 0};\n    queue[rear++] = initial;\n    \n    while (front < rear) {\n        State current = queue[front++];\n        \n        if (isTarget(current.cylinders, target, N)) {\n            return current.turns;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                // Clockwise\n                State clockwise = current;\n                clockwise.cylinders[i] = (clockwise.cylinders[i] + 1) % M;\n                clockwise.cylinders[j] = (clockwise.cylinders[j] + 1) % M;\n                clockwise.turns++;\n                \n                int key[MAX_N];\n                memcpy(key, clockwise.cylinders, N * sizeof(int));\n                int* k = key;\n                if (!visited[k[0]][k[1]][k[2]][k[3]][k[4]][k[5]]) {\n                    visited[k[0]][k[1]][k[2]][k[3]][k[4]][k[5]] = 1;\n                    queue[rear++] = clockwise;\n                }\n                \n                // Counterclockwise\n                State counterclockwise = current;\n                counterclockwise.cylinders[i] = (counterclockwise.cylinders[i] - 1 + M) % M;\n                counterclockwise.cylinders[j] = (counterclockwise.cylinders[j] - 1 + M) % M;\n                counterclockwise.turns++;\n                \n                memcpy(key, counterclockwise.cylinders, N * sizeof(int));\n                k = key;\n                if (!visited[k[0]][k[1]][k[2]][k[3]][k[4]][k[5]]) {\n                    visited[k[0]][k[1]][k[2]][k[3]][k[4]][k[5]] = 1;\n                    queue[rear++] = counterclockwise;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    int target[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &target[i]);\n    }\n    \n    int result = solve(N, M, target);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    int *T = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &T[i]);\n    }\n\n    int total_turns = 0;\n    for (int i = 0; i < N; i++) {\n        int diff = (T[i] - 0) % M;\n        if (diff < 0) diff += M;\n        if (diff > M - diff) {\n            diff = M - diff;\n        }\n        total_turns += diff;\n    }\n\n    if (total_turns % 2 != 0) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", total_turns / 2);\n    }\n\n    free(T);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:01:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstring vectorToString(const vector<int>& v) {\n    string s;\n    for (int num : v) {\n        s += to_string(num) + \",\";\n    }\n    return s;\n}\n\nint minTurnsToOpenLock(int N, int M, const vector<int>& T) {\n    vector<int> initial(N, 0);\n    if (initial == T) return 0;\n\n    queue<pair<vector<int>, int>> q;\n    q.push({initial, 0});\n    unordered_set<string> visited;\n    visited.insert(vectorToString(initial));\n\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        vector<int> state = current.first;\n        int turns = current.second;\n\n        for (int i = 0; i < N; ++i) {\n            for (int j = i + 1; j < N; ++j) {\n                // Turn both clockwise\n                vector<int> next_state = state;\n                next_state[i] = (next_state[i] + 1) % M;\n                next_state[j] = (next_state[j] + 1) % M;\n                if (next_state == T) return turns + 1;\n                string key = vectorToString(next_state);\n                if (visited.find(key) == visited.end()) {\n                    visited.insert(key);\n                    q.push({next_state, turns + 1});\n                }\n\n                // Turn both counter-clockwise\n                next_state = state;\n                next_state[i] = (next_state[i] - 1 + M) % M;\n                next_state[j] = (next_state[j] - 1 + M) % M;\n                if (next_state == T) return turns + 1;\n                key = vectorToString(next_state);\n                if (visited.find(key) == visited.end()) {\n                    visited.insert(key);\n                    q.push({next_state, turns + 1});\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> T(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> T[i];\n    }\n    cout << minTurnsToOpenLock(N, M, T) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:02:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DialLock {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int[] T = new int[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = scanner.nextInt();\n        }\n        \n        int[] diff = new int[N];\n        for (int i = 0; i < N; i++) {\n            diff[i] = (T[i] - 0) % M;\n        }\n        \n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            if (diff[i] != 0) {\n                int delta = diff[i];\n                res += delta;\n                for (int j = i + 1; j < N; j++) {\n                    diff[j] = (diff[j] - delta) % M;\n                    if (diff[j] < 0) {\n                        diff[j] += M;\n                    }\n                }\n            }\n        }\n        \n        boolean possible = true;\n        for (int num : diff) {\n            if (num != 0) {\n                possible = false;\n                break;\n            }\n        }\n        \n        System.out.println(possible ? res : -1);\n    }\n}",
    "timestamp": "2025-08-05 22:02:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LockOpening {\n    public static int minTurns(int N, int M, int[] T) {\n        int[] start = new int[N];\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(start);\n        \n        Set<String> visited = new HashSet<>();\n        visited.add(Arrays.toString(start));\n        \n        int turns = 0;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            \n            for (int i = 0; i < size; i++) {\n                int[] current = queue.poll();\n                \n                if (Arrays.equals(current, T)) {\n                    return turns;\n                }\n                \n                for (int j = 0; j < N; j++) {\n                    for (int k = j + 1; k < N; k++) {\n                        int[] clockwise = current.clone();\n                        clockwise[j] = (clockwise[j] + 1) % M;\n                        clockwise[k] = (clockwise[k] + 1) % M;\n                        \n                        if (!visited.contains(Arrays.toString(clockwise))) {\n                            queue.offer(clockwise);\n                            visited.add(Arrays.toString(clockwise));\n                        }\n                        \n                        int[] counterClockwise = current.clone();\n                        counterClockwise[j] = (counterClockwise[j] - 1 + M) % M;\n                        counterClockwise[k] = (counterClockwise[k] - 1 + M) % M;\n                        \n                        if (!visited.contains(Arrays.toString(counterClockwise))) {\n                            queue.offer(counterClockwise);\n                            visited.add(Arrays.toString(counterClockwise));\n                        }\n                    }\n                }\n            }\n            \n            turns++;\n        }\n        \n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 22:02:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nint solve(int N, int M, vector<int>& T) {\n    vector<int> start(N, 0);\n    string target = \"\";\n    for (int num : T) target += to_string(num);\n\n    queue<pair<vector<int>, int>> q;\n    q.push({start, 0});\n\n    unordered_set<string> visited;\n    visited.insert(string(N, '0'));\n\n    while (!q.empty()) {\n        auto [current, turns] = q.front();\n        q.pop();\n\n        string currentStr = \"\";\n        for (int num : current) currentStr += to_string(num);\n\n        if (currentStr == target) return turns;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                vector<int> clockwise = current;\n                clockwise[i] = (clockwise[i] + 1) % M;\n                clockwise[j] = (clockwise[j] + 1) % M;\n                string clockStr = \"\";\n                for (int num : clockwise) clockStr += to_string(num);\n                if (visited.find(clockStr) == visited.end()) {\n                    visited.insert(clockStr);\n                    q.push({clockwise, turns + 1});\n                }\n\n                vector<int> counterClockwise = current;\n                counterClockwise[i] = (counterClockwise[i] - 1 + M) % M;\n                counterClockwise[j] = (counterClockwise[j] - 1 + M) % M;\n                string counterStr = \"\";\n                for (int num : counterClockwise) counterStr += to_string(num);\n                if (visited.find(counterStr) == visited.end()) {\n                    visited.insert(counterStr);\n                    q.push({counterClockwise, turns + 1});\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> T(N);\n    for (int i = 0; i < N; i++) cin >> T[i];\n\n    cout << solve(N, M, T) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:02:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_turns_to_unlock(N, M, T):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Check if it is possible\n    if any(t % gcd(M, 2) != 0 for t in T):\n        return -1\n\n    # Calculate the minimum turns\n    turns = 0\n    for t in T:\n        turns += min(t % M, M - t % M)\n\n    return (turns // 2) if turns % 2 == 0 else -1\n\n# Example usage:\nN = 4\nM = 10\nT = [3, 7, 5, 8]\nprint(min_turns_to_unlock(N, M, T))",
    "timestamp": "2025-08-13 08:36:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DialLock {\n\n    public static int minTurnsToUnlock(int N, int M, int[] T) {\n        int[] current = new int[N]; // Initially all cylinders showing 0\n        int minTurns = 0;\n        \n        // Calculate the difference between the target T and current cylinders\n        int[] diff = new int[N];\n        boolean possible = true;\n        \n        for (int i = 0; i < N; i++) {\n            diff[i] = (T[i] - current[i] + M) % M;\n        }\n\n        // Find pairs of cylinders that can be turned together\n        for (int i = 0; i < N; i++) {\n            if (diff[i] == 0) continue;\n\n            boolean turned = false;\n            for (int j = i + 1; j < N; j++) {\n                if (diff[j] == 0) continue;\n\n                int decrease = Math.min(diff[i], M - diff[i]);\n                int increase = Math.min(diff[j], M - diff[j]);\n\n                int turns = Math.min(decrease, increase);\n                \n                diff[i] = (diff[i] - turns + M) % M;\n                diff[j] = (diff[j] - turns + M) % M;\n                \n                minTurns += turns;\n                turned = true;\n                \n                if (diff[i] == 0) {\n                    break;\n                }\n            }\n            \n            if (!turned) {\n                possible = false;\n                break;\n            }\n        }\n\n        for (int d : diff) {\n            if (d != 0) {\n                possible = false;\n                break;\n            }\n        }\n\n        return possible ? minTurns : -1;\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        int N = 4;\n        int M = 10;\n        int[] T = {3, 7, 0, 6};\n        \n        System.out.println(minTurnsToUnlock(N, M, T)); // Output the minimal turns required\n    }\n}",
    "timestamp": "2025-08-13 08:36:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint minTurnsToOpenLock(int N, int M, int* T) {\n    int difference[N];\n    int totalSum = 0;\n    for (int i = 0; i < N; i++) {\n        difference[i] = T[i] % M;\n        totalSum += difference[i];\n    }\n    if (totalSum % 2 != 0) {\n        return -1; // If the sum of differences is odd, returning -1 since it cannot be balanced.\n    }\n    int halfSum = totalSum / 2;\n    int currentSum = 0;\n    int minTurns = 0;\n    for (int i = 0; i < N; i++) {\n        if (currentSum < halfSum) {\n            currentSum += difference[i];\n        } else {\n            currentSum -= difference[i];\n            minTurns++;\n        }\n    }\n    return minTurns;\n}\n\nint main() {\n    int N = 4, M = 10;\n    int T[] = {9, 2, 8, 3};\n    int result = minTurnsToOpenLock(N, M, T);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:36:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_lock(N, M, T):\n    initial_state = tuple([0] * N)\n    target_state = tuple(T)\n    \n    if initial_state == target_state:\n        return 0\n    \n    visited = set([initial_state])\n    queue = deque([(initial_state, 0)])\n    \n    while queue:\n        current_state, turns = queue.popleft()\n        \n        for i in range(N):\n            for j in range(i+1, N):\n                # Clockwise turn\n                next_state_clock = list(current_state)\n                next_state_clock[i] = (next_state_clock[i] + 1) % M\n                next_state_clock[j] = (next_state_clock[j] + 1) % M\n                next_state_clock = tuple(next_state_clock)\n                \n                if next_state_clock == target_state:\n                    return turns + 1\n                \n                if next_state_clock not in visited:\n                    visited.add(next_state_clock)\n                    queue.append((next_state_clock, turns + 1))\n                \n                # Counterclockwise turn\n                next_state_counter = list(current_state)\n                next_state_counter[i] = (next_state_counter[i] - 1 + M) % M\n                next_state_counter[j] = (next_state_counter[j] - 1 + M) % M\n                next_state_counter = tuple(next_state_counter)\n                \n                if next_state_counter == target_state:\n                    return turns + 1\n                \n                if next_state_counter not in visited:\n                    visited.add(next_state_counter)\n                    queue.append((next_state_counter, turns + 1))\n    \n    return -1\n\n# Read input\nN, M = map(int, input().split())\nT = list(map(int, input().split()))\n\n# Solve and print result\nprint(solve_lock(N, M, T))",
    "timestamp": "2025-08-13 08:36:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    T = list(map(int, sys.stdin.readline().split()))\n    \n    if N == 1:\n        print(0 if T[0] == 0 else -1)\n        return\n    \n    # The problem reduces to finding x_i such that x_i ≡ ±d_i mod M for each i,\n    # and the sum of x_i is even (since each operation affects two x_i by ±1).\n    # The minimal sum is sum(min(d_i, M - d_i)), but we need to adjust parity.\n    \n    diffs = []\n    total = 0\n    for num in T:\n        d = num % M\n        diff = min(d, M - d)\n        diffs.append(diff)\n        total += diff\n    \n    # Check if total is even; if not, we need to adjust one of the diffs\n    if total % 2 == 0:\n        print(total // 2)\n    else:\n        # Find the minimal adjustment: changing one diff from d to (M - d)\n        # The adjustment is (M - 2d), but since d is min(d, M-d), M - 2d could be positive or negative.\n        # We need to find the minimal |M - 2d| to add to total.\n        min_adjust = float('inf')\n        for d in diffs:\n            adjust = M - 2 * d\n            if adjust % 2 != 0:\n                continue  # adjust must be odd to change total parity\n            if abs(adjust) < min_adjust:\n                min_adjust = abs(adjust)\n        if min_adjust != float('inf'):\n            print((total + min_adjust) // 2)\n        else:\n            print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 08:36:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct State {\n    vector<int> cylinders;\n    int turns;\n    \n    State(vector<int> c, int t) : cylinders(c), turns(t) {}\n    \n    bool operator==(const State& other) const {\n        return cylinders == other.cylinders;\n    }\n    \n    struct HashFunction {\n        size_t operator()(const State& s) const {\n            size_t hash = 0;\n            for (int num : s.cylinders) {\n                hash = hash * 31 + num;\n            }\n            return hash;\n        }\n    };\n};\n\nint minimumTurns(int N, int M, const vector<int>& T) {\n    vector<int> start(N, 0);\n    State initialState(start, 0);\n    \n    if (initialState.cylinders == T) return 0;\n    \n    queue<State> q;\n    unordered_set<State, State::HashFunction> visited;\n    \n    q.push(initialState);\n    visited.insert(initialState);\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = i + 1; j < N; ++j) {\n                // Turn both cylinders i and j clockwise\n                vector<int> nextClockwise = current.cylinders;\n                nextClockwise[i] = (nextClockwise[i] + 1) % M;\n                nextClockwise[j] = (nextClockwise[j] + 1) % M;\n                State nextStateClockwise(nextClockwise, current.turns + 1);\n                \n                if (nextStateClockwise.cylinders == T) return nextStateClockwise.turns;\n                \n                if (visited.find(nextStateClockwise) == visited.end()) {\n                    visited.insert(nextStateClockwise);\n                    q.push(nextStateClockwise);\n                }\n                \n                // Turn both cylinders i and j counterclockwise\n                vector<int> nextCounterclockwise = current.cylinders;\n                nextCounterclockwise[i] = (nextCounterclockwise[i] - 1 + M) % M;\n                nextCounterclockwise[j] = (nextCounterclockwise[j] - 1 + M) % M;\n                State nextStateCounterclockwise(nextCounterclockwise, current.turns + 1);\n                \n                if (nextStateCounterclockwise.cylinders == T) return nextStateCounterclockwise.turns;\n                \n                if (visited.find(nextStateCounterclockwise) == visited.end()) {\n                    visited.insert(nextStateCounterclockwise);\n                    q.push(nextStateCounterclockwise);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> T(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> T[i];\n    }\n    \n    cout << minimumTurns(N, M, T) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:47:06"
  }
]