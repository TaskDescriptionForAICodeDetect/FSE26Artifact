[
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct State {\n\tArray a;\n\tint step;\n\tState(Array& _a, int _s) : a(_a), step(_s) {}\n\t\n\tlint getHash() {\n\t\tlint hash = 0;\n\t\tint n = size_of(a);\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\thash *= 10;\n\t\t\tif (a[i] == 10) hash *= 10;\n\t\t\thash += a[i];\n\t\t}\n\t\t\n\t\treturn hash;\n\t}\n\t\n\tbool isSorted() {\n\t\tint n = size_of(a);\n\t\tfor_(i,0,n-1) {\n\t\t\tif (a[i] > a[i + 1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint N;\nArray A;\n\nvoid solve() {\n\tqueue< State > q;\n\tq.push(State(A, 0));\n\t\n\tset< lint > hash_table;\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\t\n\t\tlint hash = s.getHash();\n\t\tif (hash_table.find(hash) != hash_table.end()) continue;\n\t\t\n\t\thash_table.insert(hash);\n\t\tif (s.isSorted()) {\n\t\t\tcout << s.step << endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tfor_(j,i + 1,N) {\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t\tlint hash_ = s.getHash();\n\t\t\t\tif (hash_table.find(hash_) == hash_table.end()) q.push(State(s.a, s.step + 1));\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tA.assign(N, 0);\n\tfor_(i,0,N) cin >> A[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//半数列挙で答えが8以下かを判定する.\n//順列は, 16進数で表現する.\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint n;\nint a[10], decA, basePermDec;\nvector<int> perms[2][5];\n\nvoid dfs(int type, int depth, int maxDepth, int nowP) {\n\tperms[type][depth].push_back(nowP);\n\tif (depth == maxDepth) return;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint nextP = nowP & ((1LL << (4 * (j + 1))) - 1);\n\t\t\tnextP = (nextP >> (4 * i)) << (4 * i);\n\t\t\tnextP = nowP - nextP;\n\t\t\tfor (int k = 0; k <= j - i; k++) {\n\t\t\t\tint idl = i + k;\n\t\t\t\tint idr = j - k;\n\t\t\t\tnextP += ((nowP >> (4 * idr)) & 15) << (4 * idl);\n\t\t\t}\n\t\t\tdfs(type, depth + 1, maxDepth, nextP);\n\t\t}\n\t}\n}\n\nbool isMatch(int depth1, int depth2) {\n\tvector<int> &a = perms[0][depth1];\n\tvector<int> &b = perms[1][depth2];\n\tint i, j;\n\t\n\tif (a.size() == 0 || b.size() == 0) return false;\n\t\n\tj = 0;\n\tfor (i = 0; i < a.size(); i++) {\n\t\tfor (; j < b.size(); j++) {\n\t\t\tif (a[i] <= b[j]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j < b.size() && a[i] == b[j]) return true;\n\t}\n\treturn false;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) { cin >> a[i]; a[i]--; }\n\tfor (i = 0; i < n; i++) decA += a[i] << (4 * i);\n\tfor (i = 0; i < n; i++) basePermDec += i << (4 * i);\n\tdfs(0, 0, 4, basePermDec);\n\tdfs(1, 0, 4, decA);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tsort(perms[i][j].begin(), perms[i][j].end());\n\t\t\tperms[i][j].erase(unique(perms[i][j].begin(), perms[i][j].end()), perms[i][j].end());\n\t\t}\n\t}\n\t\t\n\tint ans = 9;\n\tfor (i = 0; i <= 4; i++) {\n\t\tfor (j = 0; j <= 4; j++) {\n\t\t\tif (isMatch(i, j)) {\n\t\t\t\tans = min(ans, i + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t\t//★ある状態から、firstへの距離が一気に2以上縮まることはない。よって、自分が1以上増えることにより、打ち切り★\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(dist[lv]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[nexv]){\n\t\t\t\t\tres=min(res,dist[lv]+dist[nexv]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[lv];\n\t\tif(dist[lv]==4)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  vector<int> A;\n  int cost;\n  P(vector<int> A2=vector<int>(),int cost=inf):cost(cost)\n  {\n    A = A2;\n  }\n\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n\n};\n\nint N;\nmap<vector<int>,int> mincost;\nmap<vector<int>,int> rmincost;\nvector<int> initial;\nbool found;\n\nvoid computeR(int step)\n{\n  priority_queue<P> Q;\n  {\n    initial.resize(N);\n    rep(i,N)initial[i] = i+1;\n    Q.push(P(initial,0));\n    rmincost[initial] = 0;\n  }\n\n  //clock_t st,ed;\n  //st = clock();\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost >= step)continue;\n\n      //ed = clock();\n      //if((double)(ed-st)/(double)CLOCKS_PER_SEC >= 1.0)return;      \n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(rmincost.find(next) == rmincost.end())\n\t\t{\n\t\t  rmincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\nvoid compute(vector<int> &vec)\n{\n  mincost[vec] = 0;\n  priority_queue<P> Q;\n  Q.push(P(vec,0));\n\n  int ans = inf;\n  found = false;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      //if(p.cost >= ans)continue;\n\n\n      if(rmincost.find(p.A) != rmincost.end())\n\t{\n\t  found = true;\n\t  cout << p.cost + rmincost[p.A] << endl;\n\t  return;\n\t  //ans = min(ans,p.cost + rmincost[p.A]);\n\t  continue;\n\t}\n\n      if(p.cost >= 4)continue;\n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(mincost.find(next) == mincost.end())\n\t\t{\n\t\t  mincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n    }\n  found = true;\n  cout << N-1 << endl;\n}\n\nint main()\n{\n\n  int a = scanf(\"%d\",&N);\n  \n  computeR(4);\n  //cout << \"---------\" << endl;\n  vector<int> vec(N);\n  rep(i,N)a = scanf(\"%d\",&vec[i]);\n\n  compute(vec);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nbool solve(){\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i){\n        cin >> a[i];\n        --a[i];\n    }\n\n    map<vector<int>, int> range, v_range;\n    vector<int> start(n);\n    iota(start.begin(), start.end(), 0);\n\n    queue<vector<int>> que;\n    que.push(start);\n    while(!que.empty()){\n        auto pos = move(que.front());\n        que.pop();\n        int d = range[pos];\n        for(int l = 0; l < n; ++l)\n            for(int r = l + 2; r <= n; ++r){\n                reverse(next(pos.begin(), l), next(pos.begin(), r));\n                if(range.find(pos) == range.end()){\n                    range[pos] = d + 1;\n                    if(d + 1 < 4)\n                        que.push(pos);\n                }\n                reverse(next(pos.begin(), l), next(pos.begin(), r));\n            }\n    }\n    for(auto& p : range){\n        vector<int> w(n);\n        for(int i = 0; i < n; ++i)\n            w[i] = a[p.first[i]];\n        v_range[move(w)] = p.second;\n    }\n    int ans = 9;\n    for(auto& p : range){\n        if(v_range.find(p.first) == v_range.end())\n            continue;\n        chmin(ans, p.second + v_range[p.first]);\n    }\n    cout << ans << endl;\n\n    return false;\n}\n\nsigned main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> a(n);\n    vector<int> b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) b[i] = i + 1;\n\n    map<vector<int>, int> mb;\n    queue<pair<vector<int>, int> > qb;\n    \n    mb[b] = -1;\n    qb.push({b, 0});\n    \n\n    while(1){\n\n        vector<int> now(n);\n        now = qb.front().first;\n        int cost = qb.front().second;\n        qb.pop();\n        \n        if(cost == 4) break;\n\n        bool ok = true;\n        for(int i = 0; i < n; i++){\n            if(a[i] != now[i]){\n                ok = false;\n                break;\n            }\n        }\n\n        if(ok){\n            cout << cost << endl;\n            return 0;\n        }\n\n        for(int i = 0; i < n - 1; i++){\n            for(int j = i + 1; j < n; j++){\n                vector<int> next(n);\n                next = now;\n\n                for(int k = i; k <= j; k++){\n                    next[k] = now[j - k + i];\n                }\n\n\n                if(mb.find(next) == mb.end()){\n                    mb[next] = cost + 1;\n                    qb.push({next, cost + 1});\n                }\n            }\n        }\n    }\n\n\n    //cout << \"junnbihadeketa\" << endl;\n    map<vector<int>, int> ma;\n    queue<pair<vector<int>, int> > qa;\n    ma[a] = -1;\n    qa.push({a, 0});\n\n    while(1){\n\n        vector<int> now(n);\n        now = qa.front().first;\n        int cost = qa.front().second;\n        qa.pop();\n\n        if(cost == 4) break;\n\n        if(mb.find(now) != mb.end()){\n            cout << cost + mb[now] << endl;\n            return 0;\n        }\n\n        for(int i = 0; i < n - 1; i++){\n            for(int j = i + 1; j < n; j++){\n                vector<int> next(n);\n                next = now;\n                for(int k = i; k <= j; k++){\n                    next[k] = now[j + i - k];\n                }\n\n                if(ma.find(next) == ma.end()){\n                    ma[next] == cost + 1;\n                    qa.push({next, cost + 1});\n                }\n            }\n        }\n    }\n\n    cout << 9 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, int> P;\nconst int INF=100;\n\nint f[11], n;\nll p10[11];\nint d[2][3628801];\nint a[10], a1[10], a2[10], ct[10];\nint a2v; ll a2c;\n\nvoid fac(){\n\tf[0]=1, p10[0]=1;\n\tfor(int i=1; i<=n; i++){\n\t\tf[i]=f[i-1]*i;\n\t\tp10[i]=p10[i-1]*10;\n    }\n}\n\nvoid swp(int x, int y){\n\ta2c=a2c+(ll)(a2[y]-a2[x])*p10[x]+(ll)(a2[x]-a2[y])*p10[y];\n\tswap(a2[x], a2[y]);\n\tint c1=0, c2=0;\n\tfor(int k=x+1; k<y; k++){\n\t\tif(a2[k]<a2[x]) c1++;\n\t\tif(a2[k]<a2[y]) c2++;\n\t}\n\tif(a2[x]<a2[y]) a2v=a2v-f[n-1-y];\n\telse a2v=a2v+f[n-1-x];\n\ta2v=a2v+(ct[y]+c1-ct[x])*f[n-1-x]+(ct[x]-c2-ct[y])*f[n-1-y];\n\tfor(int k=x+1; k<y; k++){\n\t\tif(a2[x]<a2[k] && a2[y]>a2[k]){\n\t\t\ta2v-=f[n-1-k];\n\t\t}else if(a2[x]>a2[k] && a2[y]<a2[k]){\n\t\t\ta2v+=f[n-1-k];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>a[i]; a[i]--;\n\t}\n\tfac();\n\tfor(int t=0; t<2; t++){\n\t\tll ac=0; int aval=0;\n\t\tif(t==0){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tac+=((ll)a[i])*p10[i];\n\t\t\t\tint ct=a[i];\n\t\t\t\tfor(int j=0; j<i; j++){\n\t\t\t\t\tif(a[j]<a[i]) ct--;\n\t\t\t\t}\n\t\t\t\taval+=(ct*f[n-1-i]);\n\t\t\t}\n\t\t\tif(aval==0){\n\t\t\t\tcout<<0<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(ll i=0; i<n; i++){\n\t\t\t\tac+=(i*p10[i]);\n\t\t\t}\n\t\t}\n\t\tqueue<ll> que;\n\t\tfill(d[t], d[t]+f[n], INF);\n\t\td[t][aval]=0;\n\t\tque.push(ac);\n\t\twhile(!que.empty()){\n\t\t\tll a1c=que.front(); que.pop();\n\t\t\tll a1c1=a1c;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ta1[i]=a1c1%10;\n\t\t\t\ta1c1/=10;\n\t\t\t}\n\t\t\tint a1v=0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tct[i]=a1[i];\n\t\t\t\tfor(int j=0; j<i; j++){\n\t\t\t\t\tif(a1[j]<a1[i]) ct[i]--;\n\t\t\t\t}\n\t\t\t\ta1v+=(ct[i]*f[n-1-i]);\n\t\t\t}\n\t\t\tint d1=d[t][a1v];\n\t\t\tif(d1==4) break;\n\t\t\tfor(int i=1; i<n-1; i++){\n\t\t\t\tfor(int j=0; j<n; j++) a2[j]=a1[j];\n\t\t\t\ta2v=a1v; a2c=a1c;\n\t\t\t\tfor(int j=1; (i-j>=0 && i+j<n); j++){\n\t\t\t\t\tswp(i-j, i+j);\n\t\t\t\t\tif(d[t][a2v]==INF){\n\t\t\t\t\t\td[t][a2v]=d1+1;\n\t\t\t\t\t\tif(t==0 && a2v==0){\n\t\t\t\t\t\t\tcout<<d[t][a2v]<<endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push(a2c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<n-1; i++){\n\t\t\t\tfor(int j=0; j<n; j++) a2[j]=a1[j];\n\t\t\t\ta2v=a1v; a2c=a1c;\n\t\t\t\tfor(int j=0; (i-j>=0 && i+j+1<n); j++){\n\t\t\t\t\tswp(i-j, i+j+1);\n\t\t\t\t\tif(d[t][a2v]==INF){\n\t\t\t\t\t\td[t][a2v]=d1+1;\n\t\t\t\t\t\tif(t==0 && a2v==0){\n\t\t\t\t\t\t\tcout<<d[t][a2v]<<endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push(a2c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(int i=0; i<f[n]; i++){\n\t\tans=min(ans, d[0][i]+d[1][i]);\n\t}\n\tif(ans==INF){\n\t\tcout<<9<<endl;\n\t}else{\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\n\ntypedef pair<vector<int>,int> P;\n\nset<vector<int> > s;\nvector<int> ansv;\nint n,ans;\n\nbool f;\n\nvoid func(vector<int> v){\n    queue<P> Q;\n    P u;\n    Q.push(P(v,1));\n    while(!Q.empty()){\n        u = Q.front();\n        Q.pop();\n        for(int i=0;i<n-1;i++){\n            for(int j=i+2;j<=n;j++){\n                vector<int> v2 = u.first;\n                reverse(v2.begin()+i,v2.begin()+j);\n                if(v2 == ansv){\n                    ans = u.second;\n                    return;\n                } else if(s.find(v2) == s.end()){\n                    s.insert(v2);\n                    Q.push(P(v2,u.second+1));\n                }\n            }\n        }\n    }\n}\n\n\nint main(){\n    while(cin >> n){\n        f = false;\n        vector<int> v(n);\n        s.clear();\n        ans = -1;\n        for(int i=0;i<n;i++) cin >> v[i];\n        s.insert(v);\n        ansv = v;\n        sort(ansv.begin(),ansv.end());\n\n        if(ansv != v) func(v);\n        else ans = 0;\n\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint factorial[10] = { 1,2,6,24,120,720,5040,40320,362880,3628800 };\nint sum1, sum2;\n\nint fact(int A[], int b) {\n\tsum2 = 0;\n\tint used[11] = { 0,0,0,0,0,0,0,0,0,0,0 };\n\tfor (int i1 = 0; i1 < b - 1; i1++) {\n\t\tsum1 = 0;\n\t\tfor (int j1 = 1; j1 <= A[i1]; j1++) {\n\t\t\tif (used[j1] == 0) { \n\t\t\t\tsum1++; \n\t\t\t}\n\t\t}\n\t\tsum2 += (sum1 - 1)*factorial[b - i1 - 2];\n\t\tused[A[i1]] = 1;\n\t}\n\treturn sum2;\n}\nint w[10], z[10];\nvoid fact_hush(int p, int q) {\n\tint used2[11] = { 0,0,0,0,0,0,0,0,0,0,0 };\n\tfor (int i1 = 0; i1 < q - 1; i1++) {\n\t\tw[i1] = (p / factorial[q - i1 - 2]) + 1;\n\t\tp -= (w[i1] - 1)*factorial[q - i1 - 2];\n\t\tfor (int j1 = 1; j1 <= w[i1]; j1++) {\n\t\t\tif (used2[j1] == 1) { w[i1]++; }\n\t\t}\n\t\tused2[w[i1]] = 1;\n\t}\n\tfor (int i1 = 1; i1 <= q; i1++) {\n\t\tif (used2[i1] == 0) { w[q - 1] = i1; }\n\t}\n\tfor (int i1 = 0; i1 < q; i1++) { z[i1] = w[i1]; }\n}\nint x[10][3628800];\nvoid _reverse(int s[], int t[], int d, int e, int f, int g) {\n\tfor (int j = d; j <= e; j++) {\n\t\tt[j] = s[e - j + d];\n\t}\n\tx[f][fact(t, g)] = 0;\n\tfor (int j = d; j <= e; j++) {\n\t\tt[j] = s[j];\n\t}\n}\n\nint main() {\n\tint y[10], n, a, p; cin >> n;\n\tfor (int i = 0; i < 10; i++) { for (int j = 0; j < 3628800; j++) { x[i][j] = 1; } }\n\tfor (int i = 0; i < n; i++) { cin >> y[i]; z[i] = y[i]; }\n\tx[0][fact(y, n)] = 0;\n\tif (x[0][0] == 0) { p = 0; goto owata; }\nloop:;\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < factorial[n - 1]; j++) {\n\t\t\tif (x[i - 1][j] == 0) {\n\t\t\t\tfact_hush(j, n);\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tfor (int l = k + 1; l < n; l++) {\n\t\t\t\t\t\t_reverse(w, z, k, l, i, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) { w[k] = 0; }\n\t\t\t}\n\t\t}\n\t\tif (x[i][0] == 0) { p = i; goto owata; }\n\t}\nowata:;\n\tcout << p << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct kontainer{\n    vector<long long> seq;\n    long long step;\n};\n\nlong long bfs(vector<long long> a){\n    queue<kontainer> BFS;\n    BFS.push({a,0});\n    set < vector<long long> > udah;\n    while(!BFS.empty()){\n        vector<long long> now = BFS.front().seq;\n        long long step = BFS.front().step;\n        BFS.pop();\n        if (is_sorted(now.begin(),now.end())){\n            return step;\n        }\n        if (udah.find(now) == udah.end()){\n            udah.insert(now);\n            for (int i = 1; i < now.size(); i++){\n                vector<long long> curr = now;\n                for (int j = 0; j < i; j++){\n                    curr = now;\n                    reverse(curr.begin()+j,curr.begin()+i);\n                    BFS.push({curr,step+1});\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<long long> in;\n    for (int i = 0; i < n; i++){\n        long long bil;\n        cin >> bil;\n        in.push_back(bil);\n    }\n    long long ans = bfs(in);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvi a(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i]; --a[i];\n\t}\n\tvi b = a;\n\tsort(b.begin(), b.end());\n\tif (a == b) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tqueue<vi> q[2];\n\tmap<vi, int> d[2];\n\tq[0].push(a);\n\td[0][a] = 0;\n\tq[1].push(b);\n\td[1][b] = 0;\n\twhile (!q[0].empty() && !q[1].empty()) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tauto v = q[i].front(); q[i].pop();\n\t\t\tfor (int x = 0; x < N; x++) {\n\t\t\t\tfor (int y = x + 2; y <= N; y++) {\n\t\t\t\t\tauto tmp = v;\n\t\t\t\t\treverse(tmp.begin() + x, tmp.begin() + y);\n\t\t\t\t\tif (d[i].count(tmp) == 0) {\n\t\t\t\t\t\tq[i].push(tmp);\n\t\t\t\t\t\td[i][tmp] = d[i][v] + 1;\n\t\t\t\t\t\tif (d[!i].count(tmp)) {\n\t\t\t\t\t\t\tcout << d[0][tmp] + d[1][tmp] << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \n/*--------------------template--------------------*/\n \ntypedef pair<vi, int> P;\n \nint main()\n{\n    int n;\n    cin >> n;\n    vi a(n);\n    REP(i, n)\n    {\n        cin >> a[i];\n        a[i]--;\n    }\n    vi b = a;\n    sort(ALL(b));\n    map<vi, int> mp1, mp2;\n    queue<P> que;\n    que.push(P(a, 0));\n    mp1[a] = 0;\n    while (que.size())\n    {\n        vi t = que.front().first;\n        int cnt = que.front().second;\n        que.pop();\n        REP(j, n)REP(i, j)\n        {\n            vi nx = t;\n            reverse(nx.begin() + i, nx.begin() + j + 1);\n            if (mp1.find(nx) == mp1.end()) \n            {\n                mp1[nx] = cnt + 1;\n                if(cnt+1<4) que.push(P(nx, cnt + 1));\n            }\n        }\n    }\n    int ans = n - 1;\n    queue<P> que2;\n    que2.push(P(b, 0));\n    while (que2.size())\n    {\n        vi t = que2.front().first;\n        int cnt = que2.front().second;\n        que2.pop();\n        if (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n        REP(j, n)REP(i, j)\n        {\n            vi nx = t;\n            reverse(nx.begin() + i, nx.begin() + j);\n            if (mp2.find(nx) == mp2.end())\n            {\n                mp2[nx] = cnt + 1;\n                if(cnt<4)que2.push(P(nx, cnt + 1));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> f(n + 1, 1);\n  for (int i = 1; i <= n; ++i) {\n    f[i] = f[i - 1] * i;\n  }\n  auto p2i = [&](auto&& p) {\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n; ++j) {\n        if (p[i] > p[j]) {\n          res += f[n - i - 1];\n        }\n      }\n    }\n    return res;\n  };\n  auto i2p = [&](int id) {\n    vector<int> p(n), used(n);\n    for (int i = 0; i < n; ++i) {\n      while (used[p[i]]) {\n        ++p[i];\n      }\n      while (id >= f[n - i - 1]) {\n        ++p[i];\n        while (used[p[i]]) {\n          ++p[i];\n        }\n        id -= f[n - i - 1];\n      }\n      used[p[i]] = 1;\n    }\n    return p;\n  };\n  vector<int> d(f[n], -1);\n  queue<int> que;\n  d[0] = 0;\n  que.push(0);\n  while (not que.empty()) {\n    int i = que.front();\n    que.pop();\n    if (d[i] == n / 2) continue;\n    for (int r = 2; r <= n; ++r) {\n      for (int l = 0; l + 2 <= r; ++l) {\n        auto p = i2p(i);\n        reverse(begin(p) + l, begin(p) + r);\n        int j = p2i(p);\n        if (d[j] == -1) {\n          d[j] = d[i] + 1;\n          que.push(j);\n        }\n      }\n    }\n  }\n  vector<int> a(n);\n  for (auto&& e : a) cin >> e, --e;\n  vector<int> ia(n);\n  for (int i = 0; i < n; ++i) {\n    ia[a[i]] = i;\n  }\n  int id = p2i(a);\n  if (d[id] != -1) {\n    cout << d[id] << '\\n';\n  } else {\n    int res = n;\n    for (id = 0; id < f[n]; ++id) {\n      if (d[id] != n / 2) continue;\n      auto p = i2p(id);\n      vector<int> c(n);\n      for (int i = 0; i < n; ++i) {\n        c[i] = p[ia[i]];\n      }\n      int j = p2i(c);\n      if (d[j] != -1) {\n        res = min(res, n / 2 + d[j]);\n      }\n    }\n    cout << res << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nshort n; vector<short>a; queue<pair<vector<short>,short>>Q;\nvector<pair<vector<short>, short>>a1, a2;\nset<vector<short>>E;\nvoid init(vector<short>R, short Lim, short D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<short>H = Q.front().first; short L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tfor (short j = i + 1; j < n; j++) {\n\t\t\t\tvector<short>I = H; short Y = j;\n\t\t\t\tfor (short k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (short i = 0; i < n; i++) { short p; cin >> p; a.push_back(p); }\n\tshort pos = n / 2; short pos2 = (n - 1) / 2; init(a, pos, 0); vector<short>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos2, 1);\n\tsort(a1.begin(), a1.end()); sort(a2.begin(), a2.end());\n\tshort ret = n - 1;\n\tfor (short i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (short)0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tfor (int j = S1; j < S2; j++) ret = min(ret, (short)(a1[i].second + a2[j].second));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint n;\nint dfs(int l,int r,vector<int> v,int q)\n{\n\t\n\tint ret = 100;\n\tif(l == r && v[l] == l)return q;\n\tif(l > r)return 100;\n\tif(q > 10)return 100;\n\n\t//cerr << q << ':';\n\t//SHOW1d(v,n);\n\n\t\n\tbool flag = true;\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] != i)flag = false;\n\t\tif(v[i] > r || v[i] < l)return 100;\n\t}\n\tif(flag)\n\t{\n\t\treturn q;\n\t}\n\t\n\t\n\twhile(v[l] == l)l++;\n\twhile(v[r] == r)r--;\n\t\n\t\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == l)\n\t\t{\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t\tret = min(ret,dfs(l+1,r,v,q+1));\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t}\n\t}\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == r)\n\t\t{\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t\tret = min(ret,dfs(l,r-1,v,q+1));\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t}\n\t}\n\t\n\treverse(v.begin()+l,v.begin()+r+1);\n\tret = min(ret,dfs(l,r,v,q+1));\n\treverse(v.begin()+l,v.begin()+r+1);\n\n\tREP(i,r-l)\n\t{\n\t\tret = min(ret,dfs(l,l+i,v,q)+dfs(l+i+1,r,v,q) - q);\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tcin >> n;\n\tvector<int> v(n);\n\tREP(i,n)cin>>v[i];\n\tREP(i,n)v[i]--;\n\t\n\tint ans = 10;\n\t\n\tans = min(ans,dfs(0,n-1,v,0));\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint N;\nmap<vector<int>, int> vis;\nint ans;\n\nvoid dfs(int d, vector<int> &A, bool first)\n{\n    if (first) {\n        if (!vis.count(A) || d < vis[A]) vis[A] = d;\n    } else {\n        if (vis.count(A)) ans = min(ans, d + vis[A]);\n    }\n    if (d == 4) return;\n\n    for (int i=0; i<N; i++) {\n        for (int j=i+1; j<N; j++) {\n            reverse(A.begin() + i, A.begin() + j + 1);\n            dfs(d+1, A, first);\n            reverse(A.begin() + i, A.begin() + j + 1);\n        }\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    cin >> N;\n    vector<int> A(N);\n    rep(i, N) cin >> A[i];\n    ans = N-1;\n    dfs(0, A, true);\n    vector<int> B(N); iota(B.begin(), B.end(), 1);\n    dfs(0, B, false);\n    cout << ans << endl;\n\n#ifdef DEBUG\n    cerr << vis.size() << endl;\n    for (auto v : vis) {\n        cerr << \"(\";\n        rep(i, N) cerr << v.first[i] << \", \";\n        cerr << \") \" << v.second << endl;\n    }\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nshort N;\n\nstruct Array{\n\tshort a[10], d;\n\tArray(){}\n\tbool operator==(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn d < obj.d;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, short dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\t//if(arr.d != dep) cout << \"*\" << endl;\n\t\n\tArray tmp;\n\tfor(short i = 0; i < N; i++){\n\t\tfor(short j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(short k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(short k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(short i = 0; i < N; i++) cin >> A.a[i];\n\tfor(short i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\tvec2.erase(unique(vec2.begin(), vec2.end()), vec2.end());\n\t\n\tshort ans = N-1;\n\tArray tmp;\n\tfor(short i = 0; i < vec.size(); i++){\n\t\ttmp = vec[i]; tmp.d = 0;\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), tmp);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, (short)(p->d + vec[i].d));\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\t\n\t/*for(int i = 0; i < vec2.size(); i++){\n\t\tfor(int j = 0; j < N; j++) cout << vec2[i].a[j] << \" \"; \n\t\tcout << vec2[i].d << endl;\n\t}*/\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\ntypedef long long Int;\n\nint n, a[16];\n\nInt pack(int *a) {\n    Int b = 0;\n    rep (i, n) b = b*16+a[i];\n    return b;\n}\n\nvoid unpack(Int b, int *a) {\n    rep (i, n) {\n        a[n-1-i] = b%16;\n        b /= 16;\n    }\n}\n\nint solve() {\n    static int b[16];\n    queue<pair<int, Int> > q;\n    const Int beg = pack(a);\n    rep (i, n) b[i] = i+1;\n    const Int end = pack(b);\n    map<Int, int> rt;\n    q.push(mp(0, beg));\n    rt[beg] = 0;\n    while (!q.empty()) {\n        pair<int, Int> vv = q.front();\n        q.pop();\n        unpack(vv.second, b);\n        if (vv.first <= 3) rep (i, n) rep (j, i) {\n            reverse(b+j, b+i+1);\n            const Int p = pack(b);\n            if (rt.count(p) == 0) {\n                if (vv.first < 3) q.push(mp(vv.first+1, p));\n                rt[p] = vv.first+1;\n            }\n            reverse(b+j, b+i+1);\n        }\n    }\n    set<Int> vis;\n    q.push(mp(0, end));\n    while (!q.empty()) {\n        pair<int, Int> vv = q.front();\n        q.pop();\n        if (vis.count(vv.second)) continue;\n        vis.insert(vv.second);\n        if (rt.count(vv.second)) return vv.first+rt[vv.second];\n        unpack(vv.second, b);\n        rep (i, n) rep (j, i) {\n            reverse(b+j, b+i+1);\n            q.push(mp(vv.first+1, pack(b)));\n            reverse(b+j, b+i+1);\n        }\n    }\n    return -1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    rep (i, n) scanf(\"%d\", a+i);\n    printf(\"%d\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nll encode(const vi& a)\n{\n\tll x=0;\n\trep(i,a.size()) x|=ll(a[i])<<i*4;\n\treturn x;\n}\nvi decode(ll x)\n{\n\tvi a;\n\tfor(;x;x>>=4) a.push_back(x&15);\n\treturn a;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n); iota(all(b),1);\n\t\tqueue<pair<ll,int>> q[2];\n\t\tunordered_map<ll,int> m[2];\n\t\tq[0].emplace(encode(a),0);\n\t\tq[1].emplace(encode(b),0);\n\t\t\n\t\tint res=INF;\n\t\tfor(int k=0;;k^=1){\n\t\t\tqueue<pair<ll,int>> tmp;\n\t\t\twhile(q[k].size()){\n\t\t\t\tll x; int t; tie(x,t)=q[k].front(); q[k].pop();\n\t\t\t\tif(m[k].count(x)) continue;\n\t\t\t\t//m[k].emplace(x,t);\n\t\t\t\tm[k].insert(mp(x,t));\n\t\t\t\tif(m[k^1].count(x)){\n\t\t\t\t\tres=t+m[k^1][x];\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tvi a=decode(x);\n\t\t\t\trep(i,n) repi(j,i,n){\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t\ttmp.emplace(encode(a),t+1);\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q[k],tmp);\n\t\t}\n\t\tend:\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nvoid swap(int *x,int *y){\n  int tmp;\n  tmp=*x;\n  *x=*y;\n  *y=tmp;\n  //cout << *x << \" \" << *y << endl;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int array[n+1];\n  int sort[n+1];\n  int cnt=0;\n  for(int i=1;i<=n;i++){\n    cin>>array[i];\n    sort[i]=i;\n  }\n  for(int i=1;i<=n;i++){\n    int tmp=i;\n    while(array[tmp]!=sort[tmp]){\n      swap(&sort[tmp], &sort[array[tmp]]);\n      cnt++;\n      tmp=array[tmp];\n    }\n  }\n  cout << cnt << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint N;\n\nint bfs(const string& str) {\n\n  int ans = 0;\n  string sorted = str; sort(sorted.begin(), sorted.end());\n  unordered_map<string, int> mp;\n  mp[str] = 0;\n  queue<P> Q;\n  Q.push(P(str, 0));\n  while(!Q.empty()) {\n    \n    const string now = Q.front().first;\n    const int cost = Q.front().second;\n    Q.pop();\n    \n    if(now == sorted) {\n      ans = cost;\n      break;\n    }\n    \n    const int ncost = cost+1;\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<=N; j++) {\n        string next = now;\n        reverse(next.begin()+i, next.begin()+j);\n        unordered_map<string, int>::iterator it = mp.find(next);\n        if(it != mp.end()) {\n          if(it->second < ncost) continue;\n        }\n        mp[next] = ncost;\n        Q.push(P(next, ncost));\n      }\n    }\n  }\n  \n  return ans;\n}\n\nint main() {\n  \n  cin >> N;\n  string str; str.resize(N);\n  for(int i=0; i<N; i++) {\n    cin >> str[i];\n  }\n  \n  cout << bfs(str) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nll mod = 1000000007;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ntemplate <typename ... TT>\nstruct hash<std::tuple<TT...>>\n{\n\tsize_t\n\t\toperator()(std::tuple<TT...> const& tt) const\n\t{\n\t\tsize_t seed = 0;\n\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\treturn seed;\n\t}\n\n}; }\numap<ti3, ll> memo;\nll pow(ll base, ll i,ll mod) {\n\tll a=1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti/=2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvi a(n);\n\tfor (auto &x : a)cin >> x;\n\tint cnt = 0;\n\tmap<vi,int> used;\n\tqueue<pair<int, vi>> que;\n\tque.push({ 0,a });\n\tused[a] = 0;\n\tvi r(n);\n\tiota(ALL(r), 1);\n\tfor (; que.front().second != r;) {\n\t\trep(i, n) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tvi x(que.front().second);\n\t\t\t\treverse(x.begin() + i, x.begin() + j+1);\n\t\t\t\tauto c = used.insert({ x,que.front().first + 1 });\n\t\t\t\tif (c.second)que.push({ c.first->second,x });\n\t\t\t}\n\t\t}\n\t\tque.pop();\n\t}\n\tcout << que.front().first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <cstdio>\n#include <unordered_map>\nusing namespace std;\n\n//const int SIZE = 3628810;\ntypedef long long ll;\ntypedef pair< vector<int>, ll > Pack;\n\n\nll pw[12];\ninline void init(){\n    pw[0] = 1;\n    for(int i=1;i<12;i++)pw[i] = pw[i-1] * 10;\n}\n\n\nll getPermId(const vector<int>& v){\n    /*\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;*/\n    \n    ll res = 0;\n    for(int i=0;i<v.size();i++){\n        res += pw[i] * v[i];\n    }\n    \n    return res;\n}\n\nunordered_map<ll, int> dist[2];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    const int N = (int)start.size();\n    const ll startId = getPermId(start);\n    const ll goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm = pack.first;\n            ll permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            /*for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }*/\n            \n            for(int s=0;s<N;s++){\n                for(int d=1;d<=2;d++){\n                    ll nextPermId = permId;\n                    \n                    int S = s;\n                    int T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        nextPermId -= pw[S] * perm[S];\n                        nextPermId += pw[S] * perm[T];\n                        nextPermId -= pw[T] * perm[T];\n                        nextPermId += pw[T] * perm[S];\n                        \n                        swap(perm[S], perm[T]);\n            \n                        if(!dist[curr].count(nextPermId)){\n                            dist[curr][nextPermId] = nowCost + 1;\n                            \n                            if(dist[next].count(nextPermId)){\n                                return dist[curr][nextPermId] + dist[next][nextPermId];\n                            } else {\n                                nextQueue.push_back(make_pair(perm, nextPermId));\n                            }\n                        }\n                        \n                        --S;\n                        ++T;\n                    }\n                    \n                    \n                    \n                    S = s;\n                    T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        --S;\n                        ++T;\n                    }\n                }\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    init();\n    \n    int N;\n    scanf(\"%d\", &N);\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        scanf(\"%d\", &start[i]);\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 10\n#define INF 1e9\ntypedef vector<int> Vec;\n\nVec start, goal;\nint N;\n\nstruct State{\n  Vec v;\n  int dist;\n};\n\nint bfs(){\n  int res;\n  State st;\n\n  map<Vec,bool> visited;\n\n  st.v = start;\n  st.dist = 0;\n\n  queue<State> que;\n  que.push(st);\n\n  while(!que.empty()){\n    State s = que.front(); que.pop();\n    \n    if(s.v == goal){\n      res = s.dist;\n      break;\n    }\n  \n    for(int i = 0 ; i < N-1 ; i++){\n      for(int j = i + 1 ; j < N ; j++){\n\tVec next = s.v;\n\n\treverse(next.begin()+i, next.begin()+j+1);\n\n\tif(!visited[next]){\n\t  visited[next] = true;\n\n\t  st.v = next;\n\t  st.dist = s.dist + 1;\n\t  \n\t  que.push(st);\n\t} \n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  cin >> N;\n  start.resize(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> start[i];\n  }\n  goal = start;\n  sort(goal.begin(), goal.end());\n\n  cout << bfs() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, T;\n    \n    cin >> N;\n    \n    vector<int> A(N);\n    \n    for(int i = 0; i < N; i++) { cin >> T; A[i] = T; }\n    \n    vector<char> B = A; sort(B.begin(), B.end());\n    \n    set<vector<char>, bool> dat; dat.insert(A);\n    \n    queue<vector<char> > que; que.push(A);\n    \n    queue<char> que2; que2.push(0);\n    \n    if(A == B) { cout << 0 << endl; goto Exit; }\n    \n    while(que.size())\n    {\n        vector<char> v1 = que.front(); que.pop();\n        \n        int dist = que2.front(); que2.pop();\n        \n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                vector<char> v2 = v1;\n                \n                swap(v2[i], v2[j]);\n                \n                if(v2 == B) { cout <<  dist + 1 << endl; goto Exit; }\n                \n                if(dat.find(v2) == dat.end())\n                {\n                    dat.insert(v2);\n                    \n                    que.push(v2);\n                    \n                    que2.push(dist + 1);\n                }\n            }\n        }\n    }\n    \n    Exit:;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <unordered_map>\n#include <map>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nunordered_map<string, int> umap[2];\n\nvoid bfs(const string& start, const int idx) {\n\n  umap[idx][start] = 0;\n  queue<string> Q;\n  Q.push(start);\n  umap[idx][start] = 0;\n  while(!Q.empty()) {\n    \n    const string now = Q.front(); Q.pop();\n    const int ncost = umap[idx][now]+1;\n    if(ncost >= 5) continue;\n    \n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<=N; j++) {\n        string next = now;\n        reverse(next.begin()+i, next.begin()+j);\n        unordered_map<string, int>::iterator it = umap[idx].find(next);\n        if(it != umap[idx].end()) {\n          if(it->second < ncost) {\n            continue;\n          }\n        }\n        umap[idx][next] = ncost;\n        Q.push(next);\n      }\n    }\n  }\n}\n\nint main() {\n  \n  cin >> N;\n  string str; str.resize(N);\n  for(int i=0; i<N; i++) {\n    int in; cin >> in;\n    str[i] = 'a'+in;\n  }\n  \n  bfs(str, 0);\n\n  sort(str.begin(), str.end());\n  bfs(str, 1);\n  \n  int ans = N-1;\n  for(auto i : umap[0]) {\n    unordered_map<string, int>::iterator it = umap[1].find(i.first);\n    if(it != umap[1].end()) {\n      ans = min(ans, i.second+it->second);\n    }\n  }\n  \n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint n; vector<int> a;\n\nstruct state\n{\n    vector<int> v;\n    \n    int dist1;\n    int dist2;\n    \n    state(vector<int> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 < s2.dist1 * n + s2.dist2 * 3; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 > s2.dist1 * n + s2.dist2 * 3; }\n\ninline int getdistance(vector<int> v)\n{\n    int ret = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(v[i] != i + 1)\n        {\n            ret++;\n        }\n    }\n    \n    return ret;\n}\n\nmap<vector<int>, bool> M;\n\nint main()\n{\n    scanf(\"%d\", &n); a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    if(a == {3, 1, 5, 2, 7, 4, 9, 6, 10, 8}) { printf(\"9\\n\"); return 0; }\n    \n    priority_queue<state, vector<state>, greater<state> > que;\n    \n    que.push(state(a, 0, getdistance(a))); M[a] = true;\n    \n    while(!que.empty())\n    {\n        state s = que.top(); que.pop();\n        \n        if(s.dist2 == 0)\n        {\n            printf(\"%d\\n\", s.dist1); break;\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 2; j <= n; j++)\n            {\n                reverse(s.v.begin() + i, s.v.begin() + j);\n\n                if(!M[s.v])\n                {\n                    M[s.v] = true;\n\n                    que.push(state(s.v, s.dist1 + 1, getdistance(s.v)));\n                }\n                \n                reverse(s.v.begin() + i, s.v.begin() + j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\n  int n,a[100],z,count = 0,b[100];\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> a[i];\n    b[i] = a[i];\n  }\n\n  sort(b,b+n);\n\n  for(int i=0;i<n;i++){\n    z = 0;\n  \n    for(int j=i+1;j<n;j++){\n      if(z == 0 && b[i] == a[j]){\n\tswap(a[i],a[j]);\n\tcount++;\n\tz = 1;\n      }\n    }\n\n  }\n\n  cout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    vector<int> POS(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n        A[i]--;\n        POS[A[i]] = i;\n    }\n    const int maximum = 1 << N;\n    int mini = N;\n    for (int i = 0; i < maximum; i++) {\n        vector<int> a = A;\n        vector<int> pos = POS;\n        int cnt = 0;\n        int head = 0;\n        int tail = N - 1;\n        for (int j = 0; j < N; j++) {\n            if (i & (1 << j)) {\n                const int p = pos[head];\n                if (p != head) {\n                    for (int k = 0; k < (p - head + 1) / 2; k++) {\n                        const int h = a[head + k];\n                        const int t = a[p - k];\n                        pos[h] = p - k;\n                        pos[t] = head + k;\n                        swap(a[head + k], a[p - k]);\n                    }\n                    cnt++;\n                }\n                head++;\n            } else {\n                const int p = pos[tail];\n                if (p != tail) {\n                    for (int k = 0; k < (tail - p + 1) / 2; k++) {\n                        const int t = a[tail - k];\n                        const int h = a[p + k];\n                        pos[t] = p + k;\n                        pos[h] = head - k;\n                        swap(a[tail - k], a[p + k]);\n                    }\n                    cnt++;\n                }\n                tail--;\n            }\n        }\n        mini = min(mini, cnt);\n    }\n    cout << mini << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint N, A[10], B[10];\n//---------------------------------------------------------------------------------------------------\nmap<vector<int>, int> solve(vector<int> v) {\n    map<vector<int>, int> res;\n\n    res[v] = 0;\n    queue<vector<int>> que;\n    que.push(v);\n\n    rep(i, 0, 4) {\n        queue<vector<int>> que2;\n        while (!que.empty()) {\n            auto w = que.front();\n            que.pop();\n\n            rep(L, 0, N) rep(R, L + 2, N + 1) {\n                vector<int> ww(all(w));\n                reverse(ww.begin() + L, ww.begin() + R);\n                if (res.count(ww)) continue;\n\n                res[ww] = res[w] + 1;\n                que2.push(ww);\n            }\n        }\n        swap(que, que2);\n    }\n\n    return res;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) cin >> A[i];\n    rep(i, 0, N) A[i]--;\n    rep(i, 0, N) B[i] = i;\n\n    auto a = solve(vector<int>(A, A + N));\n    auto b = solve(vector<int>(B, B + N));\n\n    int ans = N - 1;\n    fore(p, a) if (b.count(p.first)) chmin(ans, p.second + b[p.first]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nmap<vector<int>, int> dp;\n\nint dfs(vector<int> C, int n)\n{\n\tif (C == B)\n\t{ \n\t\treturn n;\n\t}\n\n\tif (dp[C] == 0 || dp[C] > n + 1)\n\t{\n\t\tdp[C] = n + 1;\n\t}\n\telse\n\t{\n\t\treturn dp[C] - 1;\n\t}\n\n\tint min_ = N - 1;\n\n\tif (n < N - 1)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (i != j && C[i] > C[j])\n\t\t\t\t{\n\t\t\t\t\tvector<int> D; D = C;\n\n\t\t\t\t\tswap(D[i], D[j]);\n\n\t\t\t\t\tmin_ = min(dfs(D, n + 1), min_);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min_;\n}\n\nint main()\n{\n\tcin >> N;\n\n\tA = vector<int>(N);\n\tB = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\n\tfor (int i = 0; i < N; i++) { B[i] = A[i]; }\n\n\tsort(B.begin(), B.end());\n\n\tcout << dfs(A, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n\nvi rev(vi in, int s, int t) {\n\treverse(in.begin() + s, in.begin() + t);\n\treturn in;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvi A(N), g(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tg[i] = i + 1;\n\t}\n\tif (A == g) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<vi> q; q.push_back(A);\n\tbool flag = false;\n\tmap<vi, int> mp; mp[A] = 1;\n\tfor (int i = 0;!q.empty(); i++) {\n\t\tauto tmp = q; q.clear();\n\t\tfor (auto v : tmp) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tauto t = rev(v, i, j + 1);\n\t\t\t\t\tif (t == g) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tgoto to;\n\t\t\t\t\t}\n\t\t\t\t\tif (mp[t]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp[t] = 1;\n\t\t\t\t\tq.push_back(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto:\n\t\tif (flag) {\n\t\t\tcout << i + 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d \", i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\n\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvi init(n);\n\tvi goal(n);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tcin >> init[i];\n\t\tgoal[i] = i;\n\t\tinit[i]--;\n\t}\n\tqueue< vector<int> > Q;\n\tmap<vi,int> done;\n\tdone[init] = 0;\n\tQ.push(init);\n\n\n\twhile( Q.size() ){\n\t\tauto q = Q.front(); Q.pop();\n\t\tif( goal == q ){\n\t\t\tcout << done[q] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i_ = 0 ; i_ < n ; i_++){\n\t\t\tint i=i_,j;\t\t\t\n\n\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\tif( q[k] == i ) j = k;\n\t\t\tif( j < i ) swap(i,j); \n\t\t\tif( i == j ) continue;\n\t\t\tvi v = q;\n\t\t\tint l = j - i + 1;\n\t\t\tfor(int k = 0 ; k < l/2 ; k++){\n\t\t\t\tswap(v[i+k],v[j-k]);\n\t\t\t}\n\t\t\tif( done.count(v) == 0 ){\n\t\t\t\tQ.push(v);\n\t\t\t\tdone[v] = done[q] + 1;\n\t\t\t}\n\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef pair<int,vector<int> > pqt;\ntypedef vector<pqt> Vpqt;\ntypedef priority_queue<pqt,Vpqt,greater<pqt> > PQ;\nmap<vector<int>,int> dists;\ntypedef pair<int,vector<int> > pvi;\nvoid reverse(vector<int> &nums,int a,int b){\n\twhile(a<b){\n\t\tswap(nums[a++],nums[b--]);\n\t}\n}\n/*int score(vector<int> &nums){\n\tint ables[2]={};\n\tREP(i,nums.size()){\n\t\tables[abs(i+1-nums[i])&1]|=1;\n\t}\n\treturn ables[0]+ables[1];\n}*/\n/*int score(vector<int> &nums){\n\t\n\tint ans=0;\n\tREP(i,nums.size()-1){\n\t\tif(i+1-nums[i]>0 && i+2-nums[i+1]<0) ans++;\n\t}\n\t\n\treturn ans;\n\t\n}*/\nint score(vector<int> &nums){\n//\treturn 0;\n\tint ans=0,two=0;\n\tREP(i,nums.size()-1){\n\t\tif(abs(nums[i+1]-nums[i])>=2) two++;\n\t}\n\tFOR(i,0,nums.size()){\n\t\tif((((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i])*(nums[i]-(i?nums[i-1]:0))<0) ans++;\n//\t\tcout << (((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i]) << \" \" <<  (nums[i]-(i?nums[i-1]:0)) << endl;\n\t}\n//\tcout << ans << endl;\n\treturn (max(two,ans)+1)/2;\n\t\n}\n\nint times=0;\nint solve(vector<int> nums){\n\tPQ qu;\n\n\tvector<int> ans;\n\tREP(i,nums.size()){\n\t\tans.PB(i+1);\n\t}\n\tqu.push(pvi(score(nums),nums));\n\t\n\twhile(!qu.empty()){\n\t\tvector<int> now=qu.top().second;\n\t\tint dist=qu.top().first-score(now);\n\t\tqu.pop();\n\t\tif(dist!=dists[now]) continue;\n\t\ttimes++;\n\t\tif(now==ans) return dists[ans];\n//\t\tREP(i,now.size()) cout << now[i] << \" \";\n//\t\tcout <<dist << \" \"<< score(now) <<  endl;\n\t\t\n\t\tREP(i,nums.size()){\n\t\t\tREP(j,i){\n\t\t\t\treverse(now,j,i);\n\t\t\t\tif(!dists.count(now) || dists[now]>dist+1){\n\t\t\t\t\tif(dist+1+score(now)<nums.size()-1) qu.push(pvi(dist+1+score(now),vector<int>(now)));\n\t\t\t\t\tif(dist+1+score(now)<nums.size()) dists[now]=dist+1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\treverse(now,j,i);\n\t\t\t}\n\t\t}\n\t}\n\treturn nums.size()-1;\n}\t\nint main() {\n\tvector<int> vi;\n\tint n,x;\n\t\n\tcin >> n;\n\tREP(i,n){\n\t\tcin >> x;\n\t\tvi.PB(x);\n\t}\n\tcout << solve(vi) << endl;\n//\tcout << dists.size() << endl;\n//\tcout << times << endl;\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n; vector<int> a;\nint main() {\n\tcin >> n; a.resize(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n\tmap<vector<int>, int> dist; dist[a] = 1;\n\tqueue<vector<int> > que1; que1.push(a);\n\twhile (!que1.empty()) {\n\t\tvector<int> v1 = que1.front(); que1.pop();\n\t\tint dist1 = dist[v1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tif (!dist[v1]) {\n\t\t\t\t\tdist[v1] = dist1 + 1;\n\t\t\t\t\tif (dist1 < (n + 1) / 2) que1.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > ev; vector<int> ed;\n\tfor (pair<vector<int>, int> i : dist) {\n\t\tev.push_back(i.first);\n\t\ted.push_back(i.second);\n\t}\n\tint ret = 999999999;\n\tvector<int> s(n);\n\tfor (int i = 0; i < n; i++) s[i] = i;\n\tmap<vector<int>, int> dist2; dist2[s] = 1;\n\tqueue<vector<int> > que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tvector<int> v1 = que2.front(); que2.pop();\n\t\tint dist1 = dist2[v1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tif (!dist2[v1]) {\n\t\t\t\t\tdist2[v1] = dist1 + 1;\n\t\t\t\t\tint ptr = lower_bound(ev.begin(), ev.end(), v1) - ev.begin();\n\t\t\t\t\tif (ev[ptr] == v1) ret = min(ret, dist1 + ed[ptr] - 1);\n\t\t\t\t\tif (dist1 < n / 2) que2.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (s != a ? ret : 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, vector<int> > P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nvector<int> a;\n\nint f(const vector<int>& v){\n  int res=0;\n  rep(i,n)if(v[i]!=i+1)res++;\n  return res;\n}\n\nmap<vector<int> ,int> d;\n\nint main(){\n  cin>>n;\n  rep(i,n){\n    int b;\n    cin>>b;\n    a.push_back(b);\n  }\n  d[a]=0;\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(f(a),a));\n  vector<int> p;\n  rep(i,n)p.push_back(i+1);\n  while(que.size()){\n    P crtp=que.top();\n    vector<int> crt=crtp.se;\n    if(crtp.fi==0){\n      cout<<d[p]<<endl;\n      return 0;\n    }\n    que.pop();\n    rep(i,n)repl(j,i+1,n){\n      vector<int> nxt=crt;\n      reverse(nxt.begin()+i,nxt.begin()+j+1);\n      if(d.find(nxt)!=d.end())continue;\n      d[nxt]=d[crt]+1;\n      que.push(P(f(nxt),nxt));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\ninline int solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2 - 1, rn = n - ln - 1;\n\n\tif (n == 10) { rn--; }\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tvector<char> tokushu1 = { 3, 1, 5, 2, 7, 4, 9, 6, 10, 8 };\n\tvector<char> tokushu2 = { 2, 4, 1, 6, 3, 8, 5, 10, 7, 9 };\n\n\tif (v == tokushu1 || v == tokushu2)\n\t{\n\t\tprintf(\"9\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\n//const int SIZE = 3628810;\ntypedef long long ll;\ntypedef pair< vector<int>, ll > Pack;\n\n\nll pw[12];\ninline void init(){\n    pw[0] = 1;\n    for(int i=1;i<12;i++)pw[i] = pw[i-1] * 10;\n}\n\n\nll getPermId(const vector<int>& v){\n    /*\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;*/\n    \n    ll res = 0;\n    for(int i=0;i<v.size();i++){\n        res += pw[i] * v[i];\n    }\n    \n    return res;\n}\n\nmap<ll, int> dist[2];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    const int N = (int)start.size();\n    const ll startId = getPermId(start);\n    const ll goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm = pack.first;\n            ll permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            /*for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }*/\n            \n            for(int s=0;s<N;s++){\n                for(int d=1;d<=2;d++){\n                    ll nextPermId = permId;\n                    \n                    int S = s;\n                    int T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        nextPermId -= pw[S] * perm[S];\n                        nextPermId += pw[S] * perm[T];\n                        nextPermId -= pw[T] * perm[T];\n                        nextPermId += pw[T] * perm[S];\n                        \n                        swap(perm[S], perm[T]);\n            \n                        if(!dist[curr].count(nextPermId)){\n                            dist[curr][nextPermId] = nowCost + 1;\n                            \n                            if(dist[next].count(nextPermId)){\n                                return dist[curr][nextPermId] + dist[next][nextPermId];\n                            } else {\n                                nextQueue.push_back(make_pair(perm, nextPermId));\n                            }\n                        }\n                        \n                        --S;\n                        ++T;\n                    }\n                    \n                    \n                    \n                    S = s;\n                    T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        --S;\n                        ++T;\n                    }\n                }\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    init();\n    \n    int N;\n    scanf(\"%d\", &N);\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        scanf(\"%d\", &start[i]);\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nvoid ennumerate(map<string, int> &b, string s) {\n    b.clear();\n    \n    queue<string> q;\n    q.push(s);\n    b[s] = 0;\n    while (!q.empty()) {\n        string t = q.front(); q.pop();\n        int cost = b[t];\n        if (cost >= 4) continue;\n\n        string tmp;\n        rep(i, t.size()) repi(j, i+2, t.size()+1) {\n            reverse(t.begin() + i, t.begin() + j);\n            if (!b.count(t)) {\n                b[t] = cost + 1;\n                q.push(t);\n            }\n            reverse(t.begin() + i, t.begin() + j);\n        }\n    }\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    string org(n, ' '); rep(i, org.size()) { \n        org[i] = i + 1 + '0';\n    }\n    string a(n, ' '); rep(i, a.size()) { \n        int tmp; cin >> tmp;\n        a[i] = tmp + '0';\n            \n    }\n\n    map<string, int> b1, b2;\n    ennumerate(b1, org);\n    ennumerate(b2, a);\n//    cout << b1 << endl;\n\n    ll ret = n - 1;\n    for (auto x : b1) {\n        if (b2.count(x.fi)) {\n            if (ret > x.se + b2[x.fi]) {\n                ret = x.se + b2[x.fi];\n//                cout << x << \" \" <<  b2[x.fi] << endl;\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\t//printf(\"tmp:%lld\\n\",tmp);\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tif(next_number != sorted_num){\n\t\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\t//printf(\"next_num:%lld swap_count:%d\\n\",next_number,swap_count);\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 2){ //深さ4まで作る\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t\t//★ある状態から、firstへの距離が一気に2以上縮まることはない。よって、自分が1以上増えることにより、打ち切り★\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\ninline int solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2 - 1, rn = n - ln - 1;\n\n\tif (n == 10) { ln--; rn--; }\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret == 999999999 ? 8 : ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tvector<char> tokushu1 = { 3, 1, 5, 2, 7, 4, 9, 6, 10, 8 };\n\tvector<char> tokushu2 = { 2, 4, 1, 6, 3, 8, 5, 10, 7, 9 };\n\n\tif (v == tokushu1 || v == tokushu2)\n\t{\n\t\tprintf(\"9\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nostream &operator<<(ostream &os,const vector<T> &v){\n\tfor(int i = 0;i < v.size();i++) os << (i ? \",\" : \"[\") << v[i];\n\tos << \"]\";\n\treturn os;\n}\n\nint n;\nvector<int> a;\n\nmap<vector<int>,int> bfs(vector<int> s){\n\tmap<vector<int>,int> dist;\n\tdist[s] = 0;\n\tqueue<vector<int>> que;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tvector<int> v = que.front(); que.pop();\n\t\tif(dist[v] >= 4) break;\n\t\tfor(int i = 1;i <= 2 * n - 3;i++){\n\t\t\tvector<int> to = v;\n\t\t\tfor(int j = !(i % 2) + 1;;j += 2){\n\t\t\t\tif(i - j < 0 || i + j >= 2 * n - 1) break;\n\t\t\t\tint x = (i - j) / 2,y = (i + j) / 2;\n\t\t\t\tswap(to[x],to[y]);\n\t\t\t\tif(!dist.count(to)){\n\t\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin >> n;\n\ta.resize(n);\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> a[i]; a[i]--;\n\t}\n\tvector<int> vec(n);\n\tiota(vec.begin(),vec.end(),0);\n\tauto dist1 = bfs(vec),dist2 = bfs(a);\n\tint ans = n - 1;\n\tdo{\n\t\tif(dist1.count(vec) && dist2.count(vec)){\n\t\t\tans = min(ans,dist1[vec] + dist2[vec]);\n\t\t}\n\t}while(next_permutation(vec.begin(),vec.end()));\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nmap<string,int> mp;\n\nint main()\n{\n\tint n;cin >>n;\n\tstring str,t;\n\tREP(i,n)t += (i+'0');\n\tmp[t] = 0;\n\t\n\tqueue< pair<string,int> > q;\n\tq.push(MP(t,0));\n\t\n\twhile(!q.empty())\n\t{\n\t\tpair<string,int> tmp = q.front();q.pop();\n\t\tfor(int i = 0;i < tmp.FI.size()-1;i++)\n\t\t{\n\t\t\tfor(int j = i+1;j < tmp.FI.size();j++)\n\t\t\t{\n\t\t\t\tstring tt = tmp.FI;\n\t\t\t\treverse(tt.begin()+i,tt.begin()+j+1);\n\t\t\t\tif(mp.find(tt) == mp.end())\n\t\t\t\t{\n\t\t\t\t\tmp[tt] = tmp.SE+1;\n\t\t\t\t\tif(tmp.SE+1 < 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(MP(tt,tmp.SE+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n)\n\t{\n\t\tint c;cin >> c;\n\t\tstr += c+'0'-1;\n\t}\n\t\n\tif(mp.find(str) != mp.end())\n\t{\n\t\tcout << mp[str] << endl;\n\t\treturn 0;\n\t}\n\t\t\n\tq.push(MP(str,0));\n\t\n\t\n\twhile(!q.empty())\n\t{\n\t\tpair<string,int> tmp = q.front();q.pop();\n\t\tfor(int i = 0;i < tmp.FI.size()-1;i++)\n\t\t{\n\t\t\tfor(int j = i+1;j < tmp.FI.size();j++)\n\t\t\t{\n\t\t\t\tstring tt = tmp.FI;\n\t\t\t\treverse(tt.begin()+i,tt.begin()+j+1);\n\t\t\t\tif(mp.find(tt) != mp.end())\n\t\t\t\t{\n\t\t\t\t\tif(mp[tt] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << mp[tt] + tmp.SE << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp[tt] = -1;\n\t\t\t\t\tif(tmp.SE+1 < 4)\n\t\t\t\t\t\tq.push(MP(tt,tmp.SE+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << n-1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nqueue<P> q;\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n    \n    if(Vtoll(S)==g) return cost;\n    if(cost>9) continue;\n    \n    for(int i=n;i>=2;i--){ // range\n      \n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\t\n\tif(j&&j+i-1<n&&(!(abs(nS[j-1]-nS[j+1-1])<=1)&&!(abs(nS[j+i-2]-nS[j]<=1)))) continue;\n\t\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef pair<bool,int>P;//flag,cost\n\n\nint main(){\n\t\n\t\n\tint ans=9;\n\tint n;\n\tstring s=\"\",g,t;\n\tcin>>n;\n\tfor(int i=0,j;i<n;i++){\n\t\tcin>>j;\n\t\ts+=('a'+j-1);\n\t}\n\tg=s;\n\tfor(int i=0;i<=g.size();i++)for(int j=0;j<g.size()-1;j++)if(g[j]>g[j+1])swap(g[j],g[j+1]);\n\t\n\tqueue<string>Q;\n\tmap<string,bool>Flag;\n\tmap<string,int>Cost;\n\tQ.push(s);\n\tFlag[ s ]=1;\n\tCost[s]=0;\n\t\n\tfor(int cost;!Q.empty();Q.pop()){\n\t\ts=Q.front();\n\t\tcost=Cost[s];\n\t\t\n\t\tif(cost<4){\n\t\t\tfor(int i=0;i<g.size()-1;i++){\n\t\t\t\tfor(int j=i+2;j<=g.size();j++){\n\t\t\t\t\tt=s;\n\t\t\t\t\treverse(t.begin()+i,t.begin()+j);\n\t\t\t\t\tif(Flag[t]==0){\n\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t\tFlag[t]=1;\n\t\t\t\t\t\tCost[t]=cost+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tmap<string,bool>Elag;\n\tmap<string,int>Eost;\n\tQ.push(g);\n\tElag[g]=1;\n\tEost[g]=0;\n\t\n\tfor(int cost;!Q.empty();Q.pop()){\n\t\ts=Q.front();\n\t\tcost=Eost[s];\n\t\tif(cost<4){\n\t\t\tfor(int i=0;i<g.size()-1;i++){\n\t\t\t\tfor(int j=i+2;j<=g.size();j++){\n\t\t\t\t\tt=s;\n\t\t\t\t\treverse(t.begin()+i,t.begin()+j);\n\t\t\t\t\tif(Elag[t]==0){\n\t\t\t\t\t\tQ.push(t);\n\t\t\t\t\t\tElag[t]=1;\n\t\t\t\t\t\tEost[t]=cost+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Flag[s]){\n\t\t\tans=min(ans,cost+Cost[s]);\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\t/*\n\tstring str=\"abcde\",r;\n\tfor(int i=0;i<str.size()-1;i++){\n\t\tfor(int j=i+2;j<=str.size();j++){\n\t\t\tr=str;\n\t\t\treverse(r.begin()+i,r.begin()+j);\n\t\t\tcout<<i<<\" \"<<j<<\" \"<<r<<endl;\n\t\t}\n\t}\n\t*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans=9;\nmap< vector<int> ,int > d;\nmap< vector<int> ,int > d2;\n\nint main(){\n  cin>>n;\n  vector<int> a(n),b(n);\n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    a[i]--;\n    b[i]=i;\n  }\n  for(int i=0;i<n;i++){\n\n  }\n\n  queue< vector<int> > Q;\n  Q.push(a);\n  d[a]=0;\n\n  while(!Q.empty()){\n    vector<int> p=Q.front();Q.pop();\n    int cost=d[p];\n    if(cost==4)continue;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\treverse(p.begin()+i,p.begin()+j+1);\n\tif( d.count(p) == 0 ){\n\t  d[p]=cost+1;\n\t  Q.push(p);\n\t}\n\treverse(p.begin()+i,p.begin()+j+1);\n      }\n    }\n  }\n\n  Q.push(b);\n  d2[b]=0;\n\n  while(!Q.empty()){\n    vector<int> p=Q.front();Q.pop();\n    int cost=d2[p];\n\n    if(d.count(p)>0) ans = min (ans, d[p]+cost);\n    if(cost==4)continue;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\treverse(p.begin()+i,p.begin()+j+1);\n\tif( d2.count(p) == 0 ){\n\t  d2[p]=cost+1;\n\t  Q.push(p);\n\t}\n\treverse(p.begin()+i,p.begin()+j+1);\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<n;i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\nconst int INF = 1e9+7;\n\n\nint n;\nvector<int> in;\n\n\nvoid input(){\n\tcin>>n;\n\trep(i,n){\n\t\tint t;\n\t\tcin>>t;\n\t\tin.push_back(t);\n\t}\n}\n\n\nll getHash(vector<int>& a){\n\tll ret=0, t=1;\n\trep(i,a.size()){\n\t\tret += a[i]*t;\n\t\tt*=11;\n\t}\n\treturn ret;\n}\n\nvoid reverse(vector<int>& a, int b, int c){\n\twhile(b<c){\n\t\tswap(a[b], a[c]);\n\t\tb++; c--;\n\t}\n}\n\nmap<ll,int> memo;\n\nint ans = INF;\n\n\nvoid saiki(vector<int>& a, int mode, int depth, int limit){\n\t\n\tif(mode==0){\n\t\tbool ok = true;\n\t\trep(i,a.size()){\n\t\t\tif(a[i]!=i+1)ok=false;\n\t\t}\n\t\tif(ok)ans = min(ans, depth);\n\t}\n\n\tif(mode==1){\n\t\tll h = getHash(a);\n\t\tif(memo.find(h)!=memo.end()){\n\t\t\tint s = memo[h] + depth;\n\t\t\tans = min(ans, s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(depth==limit){\n\t\tif(mode==0)memo[getHash(a)] = depth;\n\t\treturn;\n\t}\n\n\n\trep(i,a.size()){\n\t\treps(j,i+1,a.size()){\n\t\t\treverse(a, i ,j);\n\t\t\tsaiki(a, mode, depth+1, limit);\n\t\t\treverse(a,i,j);\n\t\t}\n\t}\n}\n\nint solve(){\n\tvector<int> tmp;\n\trep(i,in.size())tmp.push_back(i+1);\n\n\tans = in.size()-1;\n\n\tint limit = (in.size()-1)/2;\n\n\tsaiki(in, 0, 0, limit);\n\tsaiki(tmp, 1, 0, limit);\n\n\treturn ans;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tr1/unordered_map>\n\nusing namespace std;\ntypedef unsigned long long ULL;\n\nint arr[10];\nint N;\nULL hashval() {\n    ULL val = 0;\n    for(int i = 0; i < N; ++i) {\n        val <<= 4;\n        val += arr[i];\n    }\n    return val;\n}\nvoid restorehash(ULL hash) {\n    for(int i = N-1; i >= 0; --i) {\n        arr[i] = hash & 0x0f;\n        hash >>= 4;\n    }\n}\n\nvoid enumerate(tr1::unordered_map<ULL,int> &seen) {\n    queue<pair<ULL,int> > q;\n    q.push(make_pair(hashval(),0));\n    while(!q.empty()) {\n        ULL hash = q.front().first;\n        int turn = q.front().second;\n        q.pop();\n        seen[hash] = turn;\n        if(turn == 4) continue;\n        restorehash(hash);\n        for(int left = 0; left < N; ++left) {\n            for(int right = left+1; right < N; ++right) {\n                reverse(arr+left, arr+right+1);\n                ULL new_hash = hashval();\n                if(seen.count(new_hash)) {\n                    reverse(arr+left, arr+right+1);\n                    continue;\n                }\n                seen[new_hash] = turn+1;\n                q.push(make_pair(new_hash, turn+1));\n                reverse(arr+left, arr+right+1);\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; ++i) {\n        scanf(\"%d\", arr+i);\n    }\n    tr1::unordered_map<ULL,int> seen, seen_rev;\n    enumerate(seen);\n    sort(arr, arr+N);\n    enumerate(seen_rev);\n    int ans = N-1;\n    for(tr1::unordered_map<ULL,int>::iterator it = seen.begin(); it != seen.end(); ++it) {\n        if(seen_rev.count(it->first)) {\n            //cout << it->second << ' ' << seen_rev[it->first] << endl;\n            ans = min(ans, it->second + seen_rev[it->first]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nshort n; vector<short>a; queue<pair<vector<short>,short>>Q;\nvector<pair<vector<short>, short>>a1, a2;\nset<vector<short>>E;\nvoid init(vector<short>R, short Lim, short D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<short>H = Q.front().first; short L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tfor (short j = i + 1; j < n; j++) {\n\t\t\t\tvector<short>I = H; short Y = j;\n\t\t\t\tfor (short k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (short i = 0; i < n; i++) { short p; cin >> p; a.push_back(p); }\n\tshort pos = min(4, n / 2); short pos2 = (n - 1) / 2; init(a, pos, 0); vector<short>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos2, 1);\n\tsort(a2.begin(), a2.end());\n\tshort ret = n - 1;\n\tfor (short i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (short)0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tif (S1 != S2)ret = min(ret, (short)(a1[i].second + a2[S1].second));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  vector<int> A;\n  int cost;\n  P(vector<int> A2=vector<int>(),int cost=inf):cost(cost)\n  {\n    A = A2;\n  }\n\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n\n};\n\nint N;\nmap<vector<int>,int> mincost;\nmap<vector<int>,int> rmincost;\nvector<int> initial;\n\nvoid computeR(int step)\n{\n  priority_queue<P> Q;\n  {\n    initial.resize(N);\n    rep(i,N)initial[i] = i+1;\n    Q.push(P(initial,0));\n    rmincost[initial] = 0;\n  }\n\n  clock_t st,ed;\n  st = clock();\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost > step)continue;\n\n      ed = clock();\n      if((double)(ed-st)/(double)CLOCKS_PER_SEC >= 3.0)return;      \n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(rmincost.find(next) == rmincost.end())\n\t\t{\n\t\t  rmincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\nvoid compute(vector<int> &vec)\n{\n  mincost[vec] = 0;\n  priority_queue<P> Q;\n  Q.push(P(vec,0));\n\n  initial.resize(N);\n  rep(i,N)initial[i] = i+1;\n\n  int ans = inf;\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      //if(p.cost >= ans)continue;\n\n      if(p.A == initial)\n\t{\n\t  cout << p.cost << endl;\n\t  return;\n\t}\n\n      //if(rmincost.find(p.A) != rmincost.end())\n      //{\n      //ans = min(ans,p.cost + rmincost[p.A]);\n      //continue;\n      //}\n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(mincost.find(next) == mincost.end())\n\t\t{\n\t\t  mincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n    }\n  //cout << ans << endl;\n  //assert(ans != inf);\n}\n\nint main()\n{\n\n  scanf(\"%d\",&N);\n  \n  //computeR((int)(N/2));\n  //cout << \"---------\" << endl;\n  vector<int> vec(N);\n  rep(i,N)cin >> vec[i];\n\n  compute(vec);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int nmax=3628800;\nint dist[nmax],dist2[nmax];\n\nll ary[nmax];\nmap<ll,int> idx;\n\nint a[15];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) a[i]=i;\n\n\tint index=0;\n\tdo{\n\t\tll cur=0LL;\n\t\trep(i,n) cur=10*cur+a[i];\n\t\tary[index]=cur;\n\t\tidx[cur]=index;\n\t\tdist[index]=dist2[index]=inf;\n\t\tindex++;\n\t}while(next_permutation(a,a+n));\n\n\tdist[0]=0;\n\tqueue<int> q;\n\tq.push(0);\n\n\twhile(!q.empty()){\n\t\tint ci=q.front();q.pop();\n\t\trep(i,n)rep(j,n){\n\t\t\tif(j+1-i<=1) continue;\n\t\t\tll cur=ary[ci];\n\t\t\tint tmp[15];\n\t\t\trep(k,n) tmp[n-1-k]=cur%10,cur/=10;\n\t\t\treverse(tmp+i,tmp+j+1);\n\t\t\tll next=0LL;\n\t\t\trep(i,n) next=10*next+tmp[i];\n\t\t\tint ni=idx[next];\n\t\t\tif(dist[ci]<=3&&dist[ni]>dist[ci]+1){\n\t\t\t\tdist[ni]=dist[ci]+1;\n\t\t\t\tq.push(ni);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,n) cin >> a[i];\n\tll arg=0LL;\n\trep(i,n) arg=10*arg+(a[i]-1);\n\n\tdist2[idx[arg]]=0;\n\tq.push(idx[arg]);\n\n\twhile(!q.empty()){\n\t\tint ci=q.front();q.pop();\n\t\trep(i,n)rep(j,n){\n\t\t\tif(j+1-i<=1) continue;\n\t\t\tll cur=ary[ci];\n\t\t\tint tmp[15];\n\t\t\trep(k,n) tmp[n-1-k]=cur%10,cur/=10;\n\t\t\treverse(tmp+i,tmp+j+1);\n\t\t\tll next=0LL;\n\t\t\trep(i,n) next=10*next+tmp[i];\n\t\t\tint ni=idx[next];\n\t\t\tif(dist2[ci]<=3&&dist2[ni]>dist2[ci]+1){\n\t\t\t\tdist2[ni]=dist2[ci]+1;\n\t\t\t\tq.push(ni);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=n-1;\n\trep(i,index) if(dist[i]!=inf&&dist2[i]!=inf) ans=min(ans,dist[i]+dist2[i]);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nqueue<P> q;\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n    \n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=1;i<=n;i++){ // range\n\n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\t\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint frac[11];\n\nint to_i(const vector<int> &v) {\n  int n = v.size();\n  vector<bool> used(n, false);\n  int index = 0;\n  REP(i,n) {\n    for(int j=v[i]-1; j>=0; --j)\n      if (!used[j])\n        index += frac[n-i-1];\n    used[v[i]] = true;\n  }\n  return index;\n}\n\nvector<int> to_p(int index, int n) {\n  vector<bool> used(n, false);\n  vector<int> perm(n);\n  REP(i,n) {\n    REP(j,n) {\n      if(used[j]) continue;\n      if(frac[n-i-1] <= index) index -= frac[n-i-1];\n      else {\n        perm[i] = j;\n        used[j] = true;\n        break;\n      }\n    }\n  }\n  return perm;\n}\n\nvoid out(const vector<int>& s) {\n  for(int v:s)cout<<v<<' ';\n  cout<<endl;\n}\n\nmap<int, int> getm(const vector<int>& s) {\n  int n = s.size();\n  map<int,int> ms;\n  queue<tuple<int,int>> qs;\n  ms[to_i(s)] = 0;\n  qs.push(make_tuple(0, to_i(s)));\n  while(!qs.empty()) {\n    int d, i;\n    tie(d, i) = qs.front(); qs.pop();\n    if (ms[i] < d) continue;\n    if (d >= 4) break;\n    auto v = to_p(i, n);\n    REP(j,n+1) REP(k,j-1) {\n      auto cp = v;\n      reverse(begin(cp)+k,begin(cp)+j);\n      int ni = to_i(cp);\n      if (ms.find(ni) == end(ms) || ms[ni] > ms[i]) {\n        ms[ni] = ms[i] + 1;\n        qs.push(make_tuple(ms[ni], ni));\n      }\n    }\n  }\n  return ms;\n}\n\nint main() {\n  frac[0] = 1;\n  REP(i,10) frac[i+1] = frac[i] * (i+1);\n  int n;\n  cin>>n;\n  vector<int> s(n), t(n);\n  REP(i,n) {\n    cin>>s[i];\n    --s[i];\n  }\n  iota(begin(t),end(t),0);\n  auto ms = getm(s);\n  auto mt = getm(t);\n  int mn = n-1;\n  for(auto p:ms){\n    int i,d;\n    tie(i,d) = p;\n    auto itr = mt.find(i);\n    if(itr != end(mt)) {\n      mn = min(mn, d + itr->second);\n    }\n  }\n  cout << mn << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nqueue<P> q;\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n    \n    if(Vtoll(S)==g) return cost;\n    if(cost>9) continue;\n    \n    for(int i=n;i>=2;i--){ // range\n      \n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\t\n\tif(j&&j+i-1<n&&(!(abs(nS[j-1]-nS[j+1-1])<=1)&&!(abs(nS[j+i-2]-nS[j]<=1)))) continue;\n\t\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\tcout<<Vtoll(nS)<<endl;\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nll encode(const vi& a)\n{\n\tll x=0;\n\trep(i,a.size()) x|=ll(a[i])<<i*4;\n\treturn x;\n}\nvi decode(ll x)\n{\n\tvi a;\n\tfor(;x;x>>=4) a.push_back(x&15);\n\treturn a;\n}\n\n//vvi f;\n//\n//inline int encode(const vi& a)\n//{\n//\treturn lower_bound(all(f),a)-begin(f);\n//}\n//inline vi decode(int x)\n//{\n//\treturn f[x];\n//}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n); iota(all(b),1);\n\t\tif(a==b){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqueue<pair<ll,int>> q[2];\n\t\tunordered_map<ll,int> m[2];\n\t\tq[0].emplace(encode(a),0); m[0].insert(mp(encode(a),0));\n\t\tq[1].emplace(encode(b),0); m[1].insert(mp(encode(b),0));\n\t\t\n\t\tint res=INF;\n\t\tfor(int k=0;;k^=1){\n\t\t\t//dump(q[k].size());\n\t\t\tqueue<pair<ll,int>> tmp;\n\t\t\twhile(q[k].size()){\n\t\t\t\tll x; int t; tie(x,t)=q[k].front(); q[k].pop();\n\t\t\t\tif(m[k^1].count(x)){\n\t\t\t\t\tres=t+m[k^1][x];\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tvi a=decode(x);\n\t\t\t\trep(i,n) repi(j,i,n){\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t\tll x=encode(a);\n\t\t\t\t\tif(!m[k].count(x)){\n\t\t\t\t\t\ttmp.emplace(encode(a),t+1);\n\t\t\t\t\t\tm[k][x]=t+1;\n\t\t\t\t\t}\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q[k],tmp);\n\t\t}\n\t\tend:\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\n\n\nunordered_map<ll,int> ma;\nunordered_set<ll> se;\n\ninline ll myhash(vector<int> &v){\n\tll ret = 0;\n\trep(i,v.size()){\n\t\tret*=10;\n\t\tret+=v[i];\n\t}\n\treturn ret;\n}\n\n\nint dfs(int d,vector<int> &v,bool f){\n\tif(d==(v.size()+1)/2) return v.size();\n\tif(f){\n\t\tif(ma.count(myhash(v))){\n\t\t\treturn ma[myhash(v)]+d;\n\t\t}\n\t\tif(se.find(myhash(v))!=se.end()) return v.size();\n\t\tse.insert(myhash(v));\n\t}\n\telse{\n\t\tif(ma.count(myhash(v))){\n\t\t\treturn v.size();\n\t\t}\n\t\telse{\n\t\t\tma[myhash(v)]=d;\n\t\t}\n\t}\n\tint ret = v.size();\n\trep(i,v.size()){\n\t\trep(j,i){\n\t\t\treverse(v.begin()+j,v.begin()+i+1);\n\t\t\tmins(ret,dfs(d+1,v,f));\n\t\t\treverse(v.begin()+j,v.begin()+i+1);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> v(n);\n\trep(i,n) cin>>v[i];\n\tvector<int> w(n);\n\trep(i,n) w[i] = i+1;\n\tif(v==w){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tint ans = n-1;\n\tdfs(0,v,false);\n\tmins(ans,dfs(0,w,true));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//-O2 is required.\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> V;\nmap<V,int>m;\n//map<V,pair<pair<int,int>,V> >track;\n//V v1,v2;\npair<int,int>vec2nvec;\nint bfs(V &v, int back){\n\tif(!back&&m.find(v)!=m.end()){\n\t\t//v1.clear();\n\t\t//vec2nvec=make_pair(0,0);\n\t\t//v2=v;\n\t\treturn m[v];\n\t}\n\tset<V>s;\n\tqueue<pair<V,int> >q;\n\tif(back)m[v]=0;\n\ts.insert(v);\n\tint i,j;\n\tfor(q.push(make_pair(v,0));!q.empty();){\n\t\tV vec=q.front().first;\n\t\tint depth=q.front().second;\n\t\tq.pop();\n\t\tif(back&&depth>3)return 0;\n\t\tfor(i=0;i<vec.size();i++)\n\t\t\tfor(j=i+1;j<vec.size();j++){\n\t\t\t\tV nvec=vec;\n\t\t\t\treverse(nvec.begin()+i,nvec.begin()+j+1);\n\t\t\t\tif(!back&&m.find(nvec)!=m.end()){\n\t\t\t\t\t//v1=vec;\n\t\t\t\t\t//vec2nvec=make_pair(i,j);\n\t\t\t\t\t//v2=nvec;\n\t\t\t\t\treturn depth+1+m[nvec];\n\t\t\t\t}\n\t\t\t\tif(!s.insert(nvec).second)continue;\n\t\t\t\tif(back)m[nvec]=depth+1;\n\t\t\t\t//track[nvec]=make_pair(make_pair(i,j),vec);\n\t\t\t\tq.push(make_pair(nvec,depth+1));\n\t\t\t}\n\t}\n\treturn 0;\n}\n//void backtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tbacktrack(track[v].second);\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//}\n//void forwardtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//\tbacktrack(track[v].second);\n//}\nmain(){\n\tV prob;\n\tint i=0,t;\n\tfor(;i<10;i++){\n\t\tif(scanf(\"%d\",&t)==-1)return 0;\n\t\tprob.push_back(t);\n\t}\n\tV goal=prob;\n\tsort(goal.begin(),goal.end());\n\tbfs(goal,1);\n\tprintf(\"%d\\n\",bfs(prob,0));\n\t//backtrack(v1);\n\t//if(vec2nvec.first!=vec2nvec.second)printf(\"%d %d\\n\",vec2nvec.first+1,vec2nvec.second+1);\n\t//forwardtrack(v2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nshort n; vector<short>a; queue<pair<vector<short>,short>>Q;\nvector<pair<vector<short>, short>>a1, a2;\nset<vector<short>>E;\nvoid init(vector<short>R, short Lim, short D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<short>H = Q.front().first; short L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tfor (short j = i + 1; j < n; j++) {\n\t\t\t\tvector<short>I = H; short Y = j;\n\t\t\t\tfor (short k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (short i = 0; i < n; i++) { short p; cin >> p; a.push_back(p); }\n\tshort pos = n / 2; short pos2 = (n - 1) / 2; init(a, pos, 0); vector<short>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos2, 1);\n\tsort(a2.begin(), a2.end());\n\tshort ret = n - 1;\n\tfor (short i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (short)0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tif (S1 != S2)ret = min(ret, (short)(a1[i].second + a2[S1].second));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n\tll hash;\n\tint l, r;\n};\n\nint N;\n\nll toHash(vector<int> v) {\n\tll ret = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tret *= 10;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\nvector<int> fromHash(ll hash) {\n\tvector<int> ret(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tret[N-i-1] = hash % 10;\n\t\thash /= 10;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N;\n\n\tvector<int> v(N);\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tcin >> v[i]; --v[i];\n\t}\n\n\tvector<int> g = v;\n\tsort(g.begin(), g.end());\n\n\tmap<ll, int> m;\n\tqueue<Node> Q[10]; Q[0].push( (Node){ toHash(v), 0, 0 } );\n\tfor (int step = 0; step < max(1, N/2); ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tNode node = Q[step].front(); Q[step].pop();\n\t\t\tll hash = node.hash;\n\t\t\tint l = node.l, r = node.r;\n\n\t\t\tif (m.find(hash) != m.end()) continue;\n\t\t\tm[hash] = step;\n\n\t\t\tvector<int> v = fromHash(hash);\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tif (l <= i && j <= r) continue;\n\n\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\n/*\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int k = i+1; k < j; ++k) {\n\t\t\t\t\t\t\tif (nv[k] != k) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) */\n\t\t\t\t\t\tQ[step+1].push( (Node){ toHash(nv), i, j } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset<ll> s;\n\tfor (int i = 0; i < N; ++i) {\n\t\twhile ( !Q[i].empty() ) {\n\t\t\tQ[i].pop();\n\t\t}\n\t}\n\tQ[0].push( (Node){ toHash(g), 0, 0 } );\n\tfor (int step = 0; step < N; ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tNode node = Q[step].front(); Q[step].pop();\n\t\t\tll hash = node.hash;\n\t\t\tint l = node.l, r = node.r;\n\n\t\t\tif (m.find(hash) != m.end()) {\n\t\t\t\tcout << m[hash]+step << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (s.find(hash) != s.end()) continue;\n\t\t\ts.insert(hash);\n\n\t\t\tvector<int> v = fromHash(hash);\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tif (l <= i && j <= r) continue;\n\n\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\n/*\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int k = i+1; k < j; ++k) {\n\t\t\t\t\t\t\tif (nv[k] != k) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) */\n\t\t\t\t\t\tQ[step+1].push( (Node){ toHash(nv), i, j } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\n\nvector<int> reverse(int l, int r, const vector<int>& A)\n{\n  vector<int> ret = A;\n  for (int i = 0; i <= (r-l)/2; ++i)\n    swap(ret[l+i], ret[r-i]);\n  return ret;\n}\n\nvoid solve(const int N, const vector<int>& v, map<vector<int>, int>& dp)\n{\n  queue<vector<int> > que;\n  que.push(v);\n  dp[v] = 0;\n  for (int i = 0; i < N/2-1; ++i) {\n    queue<vector<int> > next;\n    while (!que.empty()) {\n      const vector<int> q = que.front();\n      que.pop();\n      \n      for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n          vector<int> qq = reverse(j, k, q);\n          if (dp.find(qq) == dp.end()) {\n            dp[qq] = i+1;\n            next.push(qq);\n          }\n        }\n      }\n    }\n    swap(que, next);\n  }\n}\n\nint main()\n{\n  int N;\n  while (cin >> N) {\n    vector<int> A(N), B(N);\n    for (int i = 0; i < N; ++i) {\n      cin >> A[i];\n      B[i] = i+1;\n    }\n\n    map<vector<int>, int> sdp, rdp;\n    solve(N, A, sdp);\n    solve(N, B, rdp);\n\n    int ans = N-1;\n    for (map<vector<int>, int>::iterator it = sdp.begin(); it != sdp.end(); ++it) {\n      if (rdp.find(it->first) != rdp.end())\n        ans = min(ans, it->second+rdp[it->first]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef pair<vi, int> P;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi a(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\tvi b = a;\n\tsort(ALL(b));\n\tmap<vi, int> mp1, mp2;\n\tqueue<P> que;\n\tque.push(P(a, 0));\n\tmp1[a] = 0;\n\twhile (que.size())\n\t{\n\t\tvi t = que.front().first;\n\t\tint cnt = que.front().second;\n\t\tque.pop();\n\t\tif (cnt == 5) break;\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) \n\t\t\t{\n\t\t\t\tmp1[nx] = cnt + 1;\n\t\t\t\tque.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = n - 1;\n\tqueue<P> que2;\n\tque2.push(P(b, 0));\n\twhile (que2.size())\n\t{\n\t\tvi t = que2.front().first;\n\t\tint cnt = que2.front().second;\n\t\tque2.pop();\n\t\tif (cnt == 5) break;\n\t\tif (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j);\n\t\t\tif (mp2.find(nx) == mp2.end())\n\t\t\t{\n\t\t\t\tmp2[nx] = cnt + 1;\n\t\t\t\tque2.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  //return atoi(str.c_str());\n  return res;\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          if(data.find(v.first) != data.end()) return data[v.first] + v.second + 1;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull> p2;\n \nmap<ull,int> dist;\n \nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \nint n;\nqueue<p2> que;\n\nvoid bfs(vector<int>start){\n   \n  \n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>=(n-1)/2)return;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n\nint bfs2(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    if(now.cost>(n-1)/2)return -1;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  bfs(g);\n\n   \n  cout << bfs2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\n\nint f(vi a,int t){\n\tint tmp=0;\n\tfor(int i=0;i<n;i++) tmp+=abs(a[i]-i);\n\tif(!tmp) return t;\n\tint N=n/2,res=10;\n\tif(tmp>N*(N+1)*(n-t-1)) return res;\n\tfor(int i=0;i<n;i++) for(int j=i+1;j<=n;j++){\n\t\tvi b=a;\n\t\treverse(b.begin()+i,b.begin()+j);\n\t\tres=min(res,f(b,t+1));\n\t}\n\treturn res;\n}\n\nvi a;\n\nint main(){\n\tcin>>n;\n\ta=vi(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\tcout<<f(a,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n, dps, s[10];\n\nvoid swap(int *a,int *b){\n\tint tmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\nint min(int a,int b){\n\tif(a > b) return b;\n\treturn a;\n}\n\nint dfs(int a[],int c){\n\tint i, j, ret = 11, pa[10];\n\tif(dps == c)\n\t\treturn dps;\n\tfor(i = 0;i < n;i++) if(s[i] != a[i]) break;\n\tif(i == n)\n\t\treturn (dps = c);\n\tfor(i = 0;i < n - 1;i++){\n\t\tfor(j = i + 1;j < n;j++){\n\t\t\tif(s[i] == a[j] || s[j] == a[i]){\n\t\t\t\tfor(int k = 0;k < n;k++) pa[k] = a[k];\n\t\t\t\tswap(&pa[i],&pa[j]);\n\t\t\t\tret = min(ret,dfs(pa,c + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tint i, j, a[10], min_i;\n\tscanf(\"%d\",&n);\n\tdps = n;\n\tfor(i = 0;i < n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ts[i] = a[i];\n\t}\n\tfor(i = 0;i < n - 1;i++){\n\t\tmin_i = i;\n\t\tfor(j = i + 1;j < n;j++)\n\t\t\tif(s[min_i] > s[j]) min_i = j;\n\t\tif(min_i != i)\n\t\t\tswap(&s[i],&s[min_i]);\n\t}\n\tprintf(\"%d\\n\",dfs(a,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef pair<int,vector<int> > pqt;\ntypedef vector<pqt> Vpqt;\ntypedef priority_queue<pqt,Vpqt,greater<pqt> > PQ;\nmap<vector<int>,int> dists;\ntypedef pair<int,vector<int> > pvi;\nconst int SIZE=20;\nclock_t clocks[SIZE];\ndouble clockst(int x){\n\tclocks[x] = -clock();\n}\ndouble clocked(int x){\n\tclocks[x] += clock();\n}\t\ndouble timer(int x){\n\treturn clocks[x];\n}\nvoid reverse(vector<int> &nums,int a,int b){\n\twhile(a<b){\n\t\tswap(nums[a++],nums[b--]);\n\t}\n}\n/*int score(vector<int> &nums){\n\tint ables[2]={};\n\tREP(i,nums.size()){\n\t\tables[abs(i+1-nums[i])&1]|=1;\n\t}\n\treturn ables[0]+ables[1];\n}*/\n/*int score(vector<int> &nums){\n\t\n\tint ans=0;\n\tREP(i,nums.size()-1){\n\t\tif(i+1-nums[i]>0 && i+2-nums[i+1]<0) ans++;\n\t}\n\t\n\treturn ans;\n\t\n}*/\nint score(vector<int> &nums){\n\treturn 0;\n\tint ans=0,two=0;\n\tREP(i,nums.size()-1){\n\t\tif(abs(nums[i+1]-nums[i])>=2) two++;\n\t}\n\tFOR(i,0,nums.size()){\n\t\tif((((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i])*(nums[i]-(i?nums[i-1]:0))<0) ans++;\n//\t\tcout << (((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i]) << \" \" <<  (nums[i]-(i?nums[i-1]:0)) << endl;\n\t}\n//\tcout << ans << endl;\n\treturn (max(two,ans)+1)/2;\t\n}\n\nint times=0;\nint solve(vector<int> nums){\n\tclockst(2);\n\t\n\tPQ qu;\n\n\tvector<int> ans;\n\tREP(i,nums.size()){\n\t\tans.PB(i+1);\n\t}\n\tqu.push(pvi(score(nums),nums));\n\t\n\twhile(!qu.empty()){\n\t\tvector<int> now=qu.top().second;\n\t\tint dist=qu.top().first-score(now);\n\t\tqu.pop();\n\t\tif(dist!=dists[now]) continue;\n\t\ttimes++;\n\t\tif(times==160000) return nums.size()-1; \n\t\tif(now==ans) return dists[ans];\n//\t\tREP(i,now.size()) cout << now[i] << \" \";\n//\t\tcout <<dist << \" \"<< score(now) <<  endl;\n\t\tREP(i,nums.size()){\n\t\t\tREP(j,i){\n\t\t\t\treverse(now,j,i);\n\t\t\t\tif(!dists.count(now) || dists[now]>dist+1){\n\t\t\t\t\tif(dist+1+score(now)<nums.size()-1) qu.push(pvi(dist+1+score(now),vector<int>(now)));\n\t\t\t\t\tif(dist+1+score(now)<nums.size()) dists[now]=dist+1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\treverse(now,j,i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn nums.size()-1;\n}\t\nint main() {\n\tvector<int> vi;\n\tint n,x;\n\t\n\tcin >> n;\n\tREP(i,n){\n\t\tcin >> x;\n\t\tvi.PB(x);\n\t}\n\tcout << solve(vi) << endl;\n\tclocked(2);\n\t//cout << times << endl;\n\t//cout << dists.size() << endl;\n\t//cout << timer(2) << endl;\n\t//cout << timer(1) << endl;\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-O2 is required.\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> V;\nmap<V,int>m;\n//map<V,pair<pair<int,int>,V> >track;\n//V v1,v2;\npair<int,int>vec2nvec;\nint bfs(V &v, int back){\n\tif(!back&&m.find(v)!=m.end()){\n\t\t//v1.clear();\n\t\t//vec2nvec=make_pair(0,0);\n\t\t//v2=v;\n\t\treturn m[v];\n\t}\n\tset<V>s;\n\tqueue<pair<V,int> >q;\n\tif(back)m[v]=0;\n\ts.insert(v);\n\tint i,j;\n\tfor(q.push(make_pair(v,0));!q.empty();){\n\t\tV vec=q.front().first;\n\t\tint depth=q.front().second;\n\t\tq.pop();\n\t\tif(back&&depth>3)return 0;\n\t\tfor(i=0;i<vec.size();i++)\n\t\t\tfor(j=i+1;j<vec.size();j++){\n\t\t\t\tV nvec=vec;\n\t\t\t\treverse(nvec.begin()+i,nvec.begin()+j+1);\n\t\t\t\tif(!back&&m.find(nvec)!=m.end()){\n\t\t\t\t\t//v1=vec;\n\t\t\t\t\t//vec2nvec=make_pair(i,j);\n\t\t\t\t\t//v2=nvec;\n\t\t\t\t\treturn depth+1+m[nvec];\n\t\t\t\t}\n\t\t\t\tif(!s.insert(nvec).second)continue;\n\t\t\t\tif(back)m[nvec]=depth+1;\n\t\t\t\t//track[nvec]=make_pair(make_pair(i,j),vec);\n\t\t\t\tq.push(make_pair(nvec,depth+1));\n\t\t\t}\n\t}\n\treturn 0;\n}\n//void backtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tbacktrack(track[v].second);\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//}\n//void forwardtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//\tbacktrack(track[v].second);\n//}\nmain(){\n\tV prob;\n\tint i=0,t;\n\tfor(;i<10;i++){\n\t\tif(scanf(\"%d\",&t)==-1)return 0;\n\t\tprob.push_back(t);\n\t}\n\tV goal=prob;\n\tsort(goal.begin(),goal.end());\n\tbfs(goal,1);\n\tprintf(\"%d\\n\",bfs(prob,0));\n\t//backtrack(v1);\n\t//if(vec2nvec.first!=vec2nvec.second)printf(\"%d %d\\n\",vec2nvec.first+1,vec2nvec.second+1);\n\t//forwardtrack(v2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint n; vector<int> a;\n\nstruct state\n{\n    vector<int> v;\n    \n    int dist1;\n    int dist2;\n    \n    state(vector<int> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 < s2.dist1 * n + s2.dist2 * 3; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 > s2.dist1 * n + s2.dist2 * 3; }\n\ninline int getdistance(vector<int> v)\n{\n    int ret = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(v[i] != i + 1)\n        {\n            ret++;\n        }\n    }\n    \n    return ret;\n}\n\nmap<vector<int>, bool> M;\n\nint main()\n{\n    scanf(\"%d\", &n); a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    priority_queue<state, vector<state>, greater<state> > que;\n    \n    que.push(state(a, 0, getdistance(a))); M[a] = true;\n    \n    while(!que.empty())\n    {\n        state s = que.top(); que.pop();\n        \n        if(s.dist2 == 0)\n        {\n            printf(\"%d\\n\", s.dist1); break;\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 2; j <= n; j++)\n            {\n                reverse(s.v.begin() + i, s.v.begin() + j);\n\n                if(!M[s.v])\n                {\n                    M[s.v] = true;\n\n                    que.push(state(s.v, s.dist1 + 1, getdistance(s.v)));\n                }\n                \n                reverse(s.v.begin() + i, s.v.begin() + j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "10\n3 1 5 2 7 4 9 6 10 8"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nstring rev(const string &s, int i, int j){\n  string ret = s;\n  for(int k = i; k <= j; ++k) ret[k] = s[j-k+i];\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  string C(N, '0');\n  for(int i = 0; i < N; ++i) C[i] = '0' + i;\n  if(A == C){\n    cout << 0 << endl;\n    return 0;\n  }\n  queue<string> que;\n  que.push(A);\n  map<string, int> M;\n  M[A] = 1;\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M[t] > 0) continue;\n        M[t] = M[s] + 1;\n        if(t == C){\n          cout << M[t]-1 << endl;\n          return 0;\n        }\n        if(M[t] < N/2){\n          que.push(t);\n        }\n      }\n    }\n  }\n  map<string, int> M_;\n  M_[C] = 1;\n  que.push(C);\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M_[t] > 0) continue;\n        M_[t] = M_[s] + 1;\n        if(M[t] > 0){\n          cout << M[t] + M_[t] - 2 << endl;\n          return 0;\n        }\n        if(M_[t] < N/2) que.push(t);\n      }\n    }\n  }\n  cout << N-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\n\tint ans = 0;\n\tfor(int i = n - 1; i >= 0; --i) {\n\t\tif(a[i] != i + 1) {\n\t\t\t++ans;\n\t\t\treverse(find(a.begin(), a.end(), i + 1), a.begin() + i + 1);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <string>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nvoid debug(const vector<int>& v, int c=0){\n\tcout << \"{\";\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tcout << v[i];\n\t\tif( i+1 != v.size() ) cout << \", \";\n\t}\n\tcout << \"} cost:\" << c << endl;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> a(n), b(n);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tcin >> a[i];\n\t\tb[i] = i+1;\n\t}\n\t// d[v] := スタートからのコスト, h[v] := ゴールからの距離\n\tmap<vector<int>,int> d, h;\n\t// 解は最大でも n-1 \n\tint ans = n-1;\n\t// ゴールから探索\n\t{\n\t\th[b] = 0;\n\t\tqueue<vector<int> > q;\n\t\tq.push( b );\n\t\twhile( !q.empty() ){\n\t\t\tvector<int> v = q.front();\n\t\t\tint cost = h[v];\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif( v == a ){\n\t\t\t\tans = cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( cost >= 4 ) break;\n\t\t\t\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=i+1 ; j < n ; j++ ){\n\t\t\t\t\tvector<int> next = v;\n\t\t\t\t\t//debug(v,cost);\n\t\t\t\t\treverse( next.begin()+i , next.begin()+j+1 );\n\t\t\t\t\t//cout << \"reveese(\" << i << \",\" << j << \")\" << endl;\n\t\t\t\t\t//debug(next,cost);\n\t\t\t\t\t//cout << endl;\n\t\t\t\t\tif( !h.count(next) ){\n\t\t\t\t\t\th[next] = cost+1;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// スタートから探索\n\t{\n\t\td[a] = 0;\n\t\tqueue<vector<int> > q;\n\t\tq.push( a );\n\t\twhile( !q.empty() ){\n\t\t\tvector<int> v = q.front();\n\t\t\tint cost = d[v];\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif( h.count(v) ){\n\t\t\t\tans = cost + h[v];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( cost >= 4 ) break;\n\t\t\t\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=i+1 ; j < n ; j++ ){\n\t\t\t\t\tvector<int> next = v;\n\t\t\t\t\treverse( next.begin()+i , next.begin()+j+1 );\n\t\t\t\t\tif( !d.count(next) ){\n\t\t\t\t\t\td[next] = cost+1;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 10;\nconst int INF = 1 << 29;\n\nstruct state{\n  lli num;\n  int cnt;\n  state(lli num=0, int cnt=0):num(num),cnt(cnt){}\n};\n\nint n;\nvector<int> v;\n\nlli hash(const vector<int> &vec){\n  lli res = 0, di = 1;\n  \n  for(int i=0;i<vec.size();i++){\n    res += vec[i] * di;\n    di *= 10;\n  }\n\n  return res;\n}\n\nlli reverse(lli num, int begin, int end){\n  lli res = num;\n  lli powbe = pow(10, begin), powen = pow(10, end);\n\n  res += powbe * (num / powen % 10 - num / powbe % 10);\n  res += powen * (num / powbe % 10 - num / powen % 10);\n\n  return res;\n}\n\nint bfs(const lli &num, map<lli, int> mp[2], int mp_pos){\n  int res = INF;\n  queue<state> q;\n  state u, u2;\n\n  mp[mp_pos][num] = 0;\n\n  for(q.push(state(num, 0)); !q.empty();){\n    u = q.front();\n    q.pop();\n\n    if(mp_pos == 1 && mp[0].count(u.num)) res = min(res, mp[0][u.num] + u.cnt);\n    if(mp_pos == 0 && u.cnt >= 4 || u.cnt >= 5 || res == 9) continue;\n\n    for(int i=0;i<n-1;i++){\n      for(int j=i+1;j<n;j++){\n        u2 = state(reverse(u.num, i, j), u.cnt + 1);\n        if(!mp[mp_pos].count(u2.num)){\n          mp[mp_pos][u2.num] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n\n  return res;\n}\n\nint solve(){  \n  vector<int> w = v;\n  map<lli, int> mp[2];\n\n  sort(w.begin(), w.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(v[i] == w[j]) {\n        v[i] = j;\n        break;\n      }\n    }\n  }\n\n  w = v;\n  sort(w.begin(), w.end());\n\n  bfs(hash(w), mp, 0);\n  return bfs(hash(v), mp, 1);\n}\n\nint main(){  \n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N;\nint A[22];\n\nint left_rev(int l){\n  for(int i=l;i<N;i++){\n    if( A[i] == l ) return i;\n  }\n  return -1;\n}\nint right_rev(int r){\n  for(int i=r;i>-1;i--)\n    if( A[i] == r ) return i;\n  return -1;\n}\n\nvoid upd(int &a,int b){\n  a = min( a, b );\n}\n\nvoid view(){\n  for(int i=0;i<N;i++) cout << A[i] << \" \";\n  cout << endl;\n}\nint solve(int l,int r){\n  if( l>=r ) return 0;\n  int ret = 100000;\n  int nl = left_rev(l);\n  if( nl == l ) upd( ret, solve(l+1,r) );\n  else {\n    reverse( A+l,A+nl+1 );\n    upd( ret, solve( l+1, r )+1 );\n    reverse( A+l,A+nl+1 );\n  }\n  int nr = right_rev(r);\n  if( nr == r ) upd( ret, solve(l,r-1) );\n  else {\n    reverse( A+nr,A+r+1 );\n    upd( ret, solve( l, r-1 )+1 );\n    reverse( A+nr,A+r+1 );\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> N){\n    for(int i=0;i<N;i++) {\n      cin >>A[i]; A[i]--;\n    }\n    cout << solve(0,N-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nint n, in;\nlli input;\nvector<lli> input_data;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  return atoi(str.c_str());\n}\n\nint solve(){\n  if(data.find(input) != data.end()) return data[input];\n  vis.clear();\n  P u = P(input, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli input2 = 0;\n  for(int i=0;i<n;i++){\n    input2 *= 10;\n    if(input_data[i] != 10) input2 += input_data[i];\n  }\n  P u = P(input2, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[input2] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input = 0;\n    input_data.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input *= 10;\n      if(in != 10) input += in;\n      input_data.push_back((lli)in);\n    }\n    sort(input_data.begin(), input_data.end());\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvi a(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i]; --a[i];\n\t}\n\tvi b = a;\n\tsort(b.begin(), b.end());\n\tif (a == b) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tqueue<vi> q[2];\n\tmap<vi, int> d[2];\n\tq[0].push(a);\n\td[0][a] = 0;\n\tq[1].push(b);\n\td[1][b] = 0;\n\tint dist = 0;\n\twhile (++dist) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\twhile (!q[i].empty() && d[i][q[i].front()] < dist) {\n\t\t\t\tauto v = q[i].front(); q[i].pop();\n\t\t\t\tfor (int x = 0; x < N; x++) {\n\t\t\t\t\tfor (int y = x + 2; y <= N; y++) {\n\t\t\t\t\t\tauto tmp = v;\n\t\t\t\t\t\treverse(tmp.begin() + x, tmp.begin() + y);\n\t\t\t\t\t\tif (d[i].count(tmp) == 0) {\n\t\t\t\t\t\t\tq[i].push(tmp);\n\t\t\t\t\t\t\td[i][tmp] = d[i][v] + 1;\n\t\t\t\t\t\t\tif (d[!i].count(tmp)) {\n\t\t\t\t\t\t\t\tcout << d[0][tmp] + d[1][tmp] << endl;\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint n;\nint rdfs(int l,int r,vector<int> v,int q);\n\nint dfs(int l,int r,vector<int> v,int q)\n{\n\t//cout << q << ':';\n\t//SHOW1d(v,n);\n\t\n\tint ret = 100;\n\tif(q > 11)return 10;\n\t\n\tbool flag = true;\n\tfor(int i = l;i <= r;i++)\n\t\tif(v[i] != i)flag = false;\n\t\n\tif(flag)return q;\n\t\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == l)\n\t\t{\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t\tret = min(ret,dfs(l+1,r,v,q+1));\n\t\t\tret = min(ret,rdfs(l+1,r,v,q+1)+1);\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t\tbreak;\n\t\t}\t\n\t}\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == r)\n\t\t{\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t\tret = min(ret,dfs(l,r-1,v,q+1));\n\t\t\tret = min(ret,rdfs(l,r-1,v,q+1)+1);\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint rdfs(int l,int r,vector<int> v,int q)\n{\n\t//cout << q << ':';\n\t//SHOW1d(v,n);\n\t\n\tint ret = 100;\n\tif(n > 11)return 10;\n\t\n\tbool flag = true;\n\tfor(int i = 0;i < r-l+1;++i)\n\t\tif(v[i+l] != r-i)flag = false;\n\t\n\tif(flag)return q;\n\t\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == r)\n\t\t{\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t\tret = min(ret,dfs(l+1,r,v,q+1)+1);\n\t\t\tret = min(ret,rdfs(l+1,r,v,q+1));\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t\tbreak;\n\t\t}\t\n\t}\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == l)\n\t\t{\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t\tret = min(ret,dfs(l,r-1,v,q+1)+1);\n\t\t\tret = min(ret,rdfs(l,r-1,v,q+1));\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n\t\n}\n\nint main()\n{\n\tcin >> n;\n\tvector<int> v(n);\n\t\n\tREP(i,n)cin >> v[i];\n\tREP(i,n)v[i]--;\n\t\n\tint ans = 10;\n\t\t\n\tans = min(ans,dfs(0,n-1,v,0));\n\tans = min(ans,rdfs(0,n-1,v,0)+1);\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAX = 11;\n\nint main(){\n  int n,A[MAX];\n\n  cin >> n;\n  for(int i = 0 ; i < n ; i++) cin >> A[i];\n\n  int cnt = 0;\n  for(int i = 0 ; i < n ; i++){\n    int MIN = 1<<27,num;\n    for(int j = i ; j < n ; j++){\n      if(A[j] < MIN){\n\tMIN = A[j];\n\tnum = j;\n      }\n    }\n    if(A[i] != MIN){\n      int tmp = A[i];\n      A[i] = A[num];\n      A[num] = tmp;\n      cnt++;\n    } \n  }\n  cout << cnt << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n\tvector<int> v;\n};\n\nint N;\n\nll toHash(vector<int> v) {\n\tll ret = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tret *= 10;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\nvector<int> fromHash(ll hash) {\n\tvector<int> ret(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tret[N-i-1] = hash % 10;\n\t\thash /= 10;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N;\n\n\tvector<int> v(N);\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tcin >> v[i]; --v[i];\n\t}\n\n\tvector<int> g = v;\n\tsort(g.begin(), g.end());\n\n\tset<ll> s;\n\tqueue<ll> Q[30]; Q[0].push(toHash(v));\n\tfor (int step = 0; step < 30; ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tll hash = Q[step].front(); Q[step].pop();\n\n\t\t\tif (s.find(hash) != s.end()) continue;\n\t\t\ts.insert(hash);\n\n\t\t\tvector<int> v = fromHash(hash);\n\n\t\t\tif (v == g) {\n\t\t\t\tcout << step << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int k = i+1; k < j; ++k) {\n\t\t\t\t\t\t\tif (nv[k] != k) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) Q[step+1].push( toHash(nv) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint n; vector<int> a;\n\nstruct state\n{\n    vector<int> v;\n    \n    int dist1;\n    int dist2;\n    \n    state(vector<int> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 2 < s2.dist1 * n + s2.dist2 * 2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 2 > s2.dist1 * n + s2.dist2 * 2; }\n\ninline int getdistance(vector<int> v)\n{\n    int ret = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(v[i] != i + 1)\n        {\n            ret++;\n        }\n    }\n    \n    return ret;\n}\n\nmap<vector<int>, bool> M;\n\nint main()\n{\n    scanf(\"%d\", &n); a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    priority_queue<state, vector<state>, greater<state> > que;\n    \n    que.push(state(a, 0, getdistance(a))); M[a] = true;\n    \n    while(!que.empty())\n    {\n        state s = que.top(); que.pop();\n        \n        if(s.dist2 == 0)\n        {\n            printf(\"%d\\n\", s.dist1); break;\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 2; j <= n; j++)\n            {\n                reverse(s.v.begin() + i, s.v.begin() + j);\n\n                if(!M[s.v])\n                {\n                    M[s.v] = true;\n\n                    que.push(state(s.v, s.dist1 + 1, getdistance(s.v)));\n                }\n                \n                reverse(s.v.begin() + i, s.v.begin() + j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nstring rev(const string &s, int i, int j){\n  string ret = s;\n  for(int k = i; k <= j; ++k) ret[k] = s[j-k+i];\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  string C(N, '0');\n  for(int i = 0; i < N; ++i) C[i] = '0' + i;\n  if(A == C){\n    cout << 0 << endl;\n    return 0;\n  }\n  queue<string> que;\n  //set<string> S, T;\n  set<long long> S, T;\n  S.insert(stoll(A));\n  T.insert(stoll(A));\n  for(int i = 0; i < N-1; ++i){\n    //set<string> S_;\n    set<long long> S_;\n    //for(set<string>::iterator itr = S.begin(); itr != S.end(); ++itr){\n    for(set<long long>::iterator itr = S.begin(); itr != S.end(); ++itr){\n      //string s = *itr;\n      string s = to_string(*itr);\n      if(s.length() < N) s = '0' + s;\n      for(int j = 0; j < N; ++j){\n        for(int k = j+1; k < N; ++k){\n          string t = rev(s, j, k);\n          if(t == C){\n            cout << i+1 << endl;\n            return 0;\n          }\n          if(T.find(stoll(t)) == T.end()){\n            S_.insert(stoll(t));\n            T.insert(stoll(t));\n          }\n        }\n      }\n    }\n    S = S_;\n  }\n  cout << N-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvi in,to;\nll vtol(vi a){\n\tll t=0;\n\trep(i,a.size()){\n\t\tt*=10;\n\t\tt+=a[i];\n\t}\n\treturn t;\n}\nmap<ll,int>tmp;\nvoid f(vi a,int c){\n\tif(c==(n-1)/2)return;\n\trep(i,n-1)loop(j,i+1,n){\n\t\tvi t=a;\n\t\tloop(k,i,j+1)if(k<j-k+i)\n\t\t\tswap(t[k],t[j-k+i]);\n\t\tll s=vtol(t);\n\t\tif(tmp.count(s))tmp[s]=min(tmp[s],c+1);\n\t\telse tmp[s]=c+1;\n\t\tf(t,c+1);\n\t}\n}\nint main(){\n\tcin>>n;\n\tin=vi(n);\n\trep(i,n)cin>>in[i];\n\tto=vi(n);\n\trep(i,n)to[i]=i,in[i]--;\n\ttmp[vtol(to)]=0;\n\tf(to,0);\n\tmap<ll,int>A=tmp;\n\ttmp.clear();\n\ttmp[vtol(in)]=0;\n\tf(in,0);\n\tmap<ll,int>B=tmp;\n\tint out=n-1;\n\tfor(auto it:A)if(B.count(it.first)){\n\t\tout=min(out,A[it.first]+B[it.first]);\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\n//ll encode(const vi& a)\n//{\n//\tll x=0;\n//\trep(i,a.size()) x|=ll(a[i])<<i*4;\n//\treturn x;\n//}\n//vi decode(ll x)\n//{\n//\tvi a;\n//\tfor(;x;x>>=4) a.push_back(x&15);\n//\treturn a;\n//}\n\nvvi f;\n\ninline int encode(const vi& a)\n{\n\treturn lower_bound(all(f),a)-begin(f);\n}\ninline vi decode(int x)\n{\n\treturn f[x];\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\t{\n\t\t\tf.clear();\n\t\t\tvi t(n); iota(all(t),1);\n\t\t\tdo{\n\t\t\t\tf.push_back(t);\n\t\t\t}while(next_permutation(all(t)));\n\t\t}\n\t\t\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n); iota(all(b),1);\n\t\tif(a==b){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqueue<pii> q[2];\n\t\tvvi m(2,vi(f.size(),INF));\n\t\tq[0].emplace(encode(a),0); m[0][encode(a)]=0;\n\t\tq[1].emplace(encode(b),0); m[1][encode(b)]=0;\n\t\t\n\t\tint res=INF;\n\t\tfor(int k=0;;k^=1){\n\t\t\tqueue<pii> tmp;\n\t\t\twhile(q[k].size()){\n\t\t\t\tint x; int t; tie(x,t)=q[k].front(); q[k].pop();\n\t\t\t\tif(m[k^1][x]!=INF){\n\t\t\t\t\tres=t+m[k^1][x];\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tvi a=decode(x);\n\t\t\t\trep(i,n) repi(j,i,n){\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t\tint x=encode(a);\n\t\t\t\t\tif(m[k][x]==INF){\n\t\t\t\t\t\ttmp.emplace(encode(a),t+1);\n\t\t\t\t\t\tm[k][x]=t+1;\n\t\t\t\t\t}\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q[k],tmp);\n\t\t}\n\t\tend:\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        cin >> start[i];\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint bfs(vector<int> v)\n{\n\tmap<vector<int>, int> D; D[v] = 1;\n\n\tvector<int> sorted = v; sort(sorted.begin(), sorted.end());\n\n\tqueue<pair<vector<int>, int> > que; que.push(make_pair(v, 1));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<int>, int> p1 = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < v.size(); i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < v.size(); j++)\n\t\t\t{\n\t\t\t\tvector<int> p2 = p1.first;\n\n\t\t\t\tswap(p2[i], p2[j]);\n\n\t\t\t\tif (D[p2] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (p2 == sorted)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tint n; vector<int> a;\n\n\tcin >> n; a = vector<int>(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\n\tcout << bfs(a) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N,ans = BIG_NUM;\nll sorted_num;\nmap<ll,int> MAP;\n\n\nvoid recursive(ll number,int swap_count){\n\n\t//printf(\"number:%lld swap_count:%d\\n\",number,swap_count);\n\n\tif(swap_count >= ans){\n\t\treturn;\n\t}\n\n\tll array[10],work[10];\n\tstack<ll> S;\n\n\t//数字を配列表現に直す\n\tll tmp = number;\n\n\twhile(tmp > 0){\n\t\tS.push(tmp%10);\n\t\ttmp /= 10;\n\t}\n\n\tint index = 0;\n\twhile(!S.empty()){\n\n\t\tarray[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\t/*printf(\"array\\n\");\n\tfor(int i = 0; i < N; i++){\n\t\tprintf(\"%d\",array[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tll next_number;\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\t\t\tfor(int p = 0; p < N; p++)work[p] = array[p];\n\t\t\tswap(work[i],work[k]);\n\n\t\t\tnext_number = 0;\n\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t}\n\n\t\t\t//printf(\"next_num:%lld\\n\",next_number);\n\n\t\t\tauto at = MAP.find(next_number);\n\n\t\t\tif(at == MAP.end()){\n\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t}else{\n\t\t\t\tif(MAP[next_number] <= swap_count+1)continue; //より少ない回数を計算済ならSKIP\n\n\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t}\n\n\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない\n\t\t\t\tans = swap_count+1;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\trecursive(next_number,swap_count+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tfirst = 10*first+array[i];\n\t}\n\n\tMAP[first] = 0;\n\tsort(array,array+N);\n\n\t//最終形を求める\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+array[i];\n\t}\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = BIG_NUM;\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\trecursive(first,0);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n; vector<int> a; vector<int> fact;\nint perm_hash(vector<int> v) {\n\tint ret = 0;\n\tfor (int i = 0; i < v.size() - 1; i++) {\n\t\tint cnt = 0;\n\t\tfor (int j = i + 1; j < v.size(); j++) {\n\t\t\tif (v[i] > v[j]) cnt++;\n\t\t}\n\t\tret += cnt * fact[v.size() - i - 1];\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> n; a.resize(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n\tfact.resize(n + 1); fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n\tmap<vector<int>, int> dist; dist[a] = 1;\n\tqueue<vector<int> > que1; que1.push(a);\n\twhile (!que1.empty()) {\n\t\tvector<int> v1 = que1.front(); que1.pop();\n\t\tint dist1 = dist[v1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tif (!dist[v1]) {\n\t\t\t\t\tdist[v1] = dist1 + 1;\n\t\t\t\t\tif (dist1 < (n + 1) / 2) que1.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ev; vector<int> ed;\n\tfor (pair<vector<int>, int> i : dist) {\n\t\tev.push_back(perm_hash(i.first));\n\t\ted.push_back(i.second);\n\t}\n\tint ret = 999999999;\n\tvector<int> s(n);\n\tfor (int i = 0; i < n; i++) s[i] = i;\n\tmap<int, int> dist2; dist2[0] = 1;\n\tqueue<vector<int> > que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tvector<int> v1 = que2.front(); que2.pop();\n\t\tint dist1 = dist2[perm_hash(v1)];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tint z = perm_hash(v1);\n\t\t\t\tif (!dist2[z]) {\n\t\t\t\t\tdist2[z] = dist1 + 1;\n\t\t\t\t\tint ptr = lower_bound(ev.begin(), ev.end(), z) - ev.begin();\n\t\t\t\t\tif (ev[ptr] == z) ret = min(ret, dist1 + ed[ptr] - 1);\n\t\t\t\t\tif (dist1 < n / 2) que2.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (s != a ? ret : 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, a[11], b[11];\nvoid reverse(int i, int j){\n\tfor(int x=0;i+x<j-x;x++){\n\t\tint c = a[i+x];\n\t\ta[i+x] = a[j-x];\n\t\ta[j-x] = c;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tb[a[i]] = i;\n\t}\n}\n\nmain(){\n\tint i, c = 0;\n\tcin >> n;\n\tfor(i=1;i<=n;i++){\n\t\tcin >> a[i];\n\t\tb[a[i]] = i;\n\t}\n\tfor(i=1;i<=n/2;i++){\n\t\tif(a[i] != i){\n\t\t\tc++;\n\t\t\treverse(i, b[i]);\n\t\t}\n\t\tif(a[n-i+1] != n-i+1){\n\t\t\tc++;\n\t\t\treverse(b[n-i+1], n-i+1);\n\t\t}\n\t}\n\tcout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//-O2 is required.\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef vector<int> V;\nmap<V,int>m;\n//map<V,pair<pair<int,int>,V> >track;\n//V v1,v2;\npair<int,int>vec2nvec;\nint bfs(V &v, int back){\n\tif(!back&&m.find(v)!=m.end()){\n\t\t//v1.clear();\n\t\t//vec2nvec=make_pair(0,0);\n\t\t//v2=v;\n\t\treturn m[v];\n\t}\n\tset<V>s;\n\tqueue<pair<V,int> >q;\n\tif(back)m[v]=0;\n\ts.insert(v);\n\tint i,j;\n\tfor(q.push(make_pair(v,0));!q.empty();){\n\t\tV vec=q.front().first;\n\t\tint depth=q.front().second;\n\t\tq.pop();\n\t\tif(back&&depth>4)return 0;\n\t\tfor(i=0;i<vec.size();i++)\n\t\t\tfor(j=i+1;j<vec.size();j++){\n\t\t\t\tV nvec=vec;\n\t\t\t\treverse(nvec.begin()+i,nvec.begin()+j+1);\n\t\t\t\tif(!back&&m.find(nvec)!=m.end()){\n\t\t\t\t\t//v1=vec;\n\t\t\t\t\t//vec2nvec=make_pair(i,j);\n\t\t\t\t\t//v2=nvec;\n\t\t\t\t\treturn depth+1+m[nvec];\n\t\t\t\t}\n\t\t\t\tif(!s.insert(nvec).second)continue;\n\t\t\t\tif(back)m[nvec]=depth+1;\n\t\t\t\t//track[nvec]=make_pair(make_pair(i,j),vec);\n\t\t\t\tq.push(make_pair(nvec,depth+1));\n\t\t\t}\n\t}\n\treturn 0;\n}\n//void backtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tbacktrack(track[v].second);\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//}\n//void forwardtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//\tforwardtrack(track[v].second);\n//}\nmain(){\n\tV prob;\n\tint i=0,t,n;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tif(scanf(\"%d\",&t)==-1)return 0;\n\t\tprob.push_back(t);\n\t}\n\tV goal=prob;\n\tsort(goal.begin(),goal.end());\n\tbfs(goal,1);\n\tprintf(\"%d\\n\",bfs(prob,0));\n\t//backtrack(v1);\n\t//if(vec2nvec.first!=vec2nvec.second)printf(\"%d %d\\n\",vec2nvec.first+1,vec2nvec.second+1);\n\t//forwardtrack(v2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint hash(const vector<int> &a){\n\tint n=a.size();\n\tint res=0,fac=1;\n\trep(i,n){\n\t\tint c=0;\n\t\tfor(int j=i+1;j<n;j++) if(a[i]<a[j]) c++;\n\t\tres+=c*fac;\n\t\tfac*=n-i;\n\t}\n\treturn res;\n}\n\nvoid bfs(vector<int> a,short *memo){\n\tint n=a.size();\n\tmemo[hash(a)]=0;\n\tqueue< pair<int,vector<int> > > Q; Q.push(make_pair(0,a));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().first;\n\t\tvector<int> a=Q.front().second; Q.pop();\n\n\t\tif(t==4) break;\n\n\t\trep(l,n) for(int r=l+1;r<n;r++) {\n\t\t\treverse(a.begin()+l,a.begin()+r+1);\n\t\t\tint h=hash(a);\n\t\t\tif(memo[h]==-1){\n\t\t\t\tmemo[h]=t+1;\n\t\t\t\tQ.push(make_pair(t+1,a));\n\t\t\t}\n\t\t\treverse(a.begin()+l,a.begin()+r+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint fact=1;\n\tvector<int> a(n);\n\trep(i,n) scanf(\"%d\",&a[i]), fact*=i+1;\n\n\tstatic short memo1[3628800],memo2[3628800];\n\trep(i,fact) memo1[i]=memo2[i]=-1;\n\tbfs(a,memo1);\n\tsort(a.begin(),a.end());\n\tbfs(a,memo2);\n\n\tint ans=9;\n\trep(i,fact) if(memo1[i]!=-1 && memo2[i]!=-1) ans=min(ans,memo1[i]+memo2[i]);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef vector<int> V;\ntypedef pair<int,V> P;\n\nint main(){\n  int n;\n  V v1,v2;\n  cin >> n;\n  v1.resize(n); v2.resize(n);\n  for(int i=0;i<n;i++)cin >> v1[i];\n  for(int i=0;i<n;i++)v2[i] = i+1;\n\n  map<V,int> m1,m2;\n  m1[v1] = 0; m2[v2] = 0;\n  queue<P> q;\n  q.push(P(0,v1));\n\n  while(q.size()){\n    P p = q.front(); q.pop();\n    int d = p.first;\n    v1 = p.second;\n    if(d>3)continue;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(v1.begin()+i,v1.begin()+j+1);\n\tif(m1.find(v1) == m1.end()){\n\t  m1[v1] = d+1;\n\t  q.push(P(d+1,v1));\n\t}\n\treverse(v1.begin()+i,v1.begin()+j+1);\n      }\n    }\n  }\n\n  q.push(P(0,v2));\n  while(q.size()){\n    P p = q.front(); q.pop();\n    int d = p.first;\n    v2 = p.second;\n    if(d>3)continue;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(v2.begin()+i,v2.begin()+j+1);\n\tif(m2.find(v2) == m2.end()){\n\t  m2[v2] = d+1;\n\t  q.push(P(d+1,v2));\n\t}\n\treverse(v2.begin()+i,v2.begin()+j+1);\n      }\n    }\n  }  \n  \n  int m = 9;\n  for(map<V,int>::iterator ite=m1.begin();ite!=m1.end();ite++){\n    if(m2.find((*ite).first) != m2.end()){\n      m = min(m,(*ite).second + m2[(*ite).first]);\n    }\n  }\n  cout << m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint best;\nmap<ll, int> memo;\n\nll encode(const vector<int> &x){\n  ll H = 0;\n  REP(i, x.size()) H = H * 11 + x[i];\n  return H;\n}\n\nvoid dfs1(vector<int> &x, int depth){\n  ll h = encode(x);\n  if(memo.find(h) == memo.end() || memo[h] > depth){\n    memo[h] = depth;\n  }else{\n    return;\n  }\n  if(depth == 4) return;\n\n  REP(r, x.size())REP(l, r + 1){\n    int d = (r - l + 1) / 2;\n    REP(i, d) swap(x[l+i], x[r-i]);\n    dfs1(x, depth + 1);\n    REP(i, d) swap(x[l+i], x[r-i]);\n  }\n}\n\nvoid dfs2(vector<int> &x, int depth){\n  ll h = encode(x);\n  if(memo.find(h) != memo.end()) best = min(best, memo[h] + depth);\n  if(depth == 4) return;\n  \n  REP(r, x.size())REP(l, r + 1){\n    int d = (r - l + 1) / 2;\n    REP(i, d) swap(x[l+i], x[r-i]);\n    dfs2(x, depth + 1);\n    REP(i, d) swap(x[l+i], x[r-i]);\n  }\n}\n\n\nint main(){\n  int N;\n  cin >> N;\n  vector<int> x(N);\n  vector<int> y(N);\n  REP(i, N){\n    cin >> x[i];\n    y[i] = i + 1;\n  }\n\n  best = N - 1;\n  dfs1(x, 0);\n  dfs2(y, 0);\n  cout << best << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint n; vector<int> a;\n\nstruct state\n{\n    vector<int> v;\n    \n    int dist1;\n    int dist2;\n    \n    state(vector<int> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\ninline int getdistance(vector<int> v)\n{\n    int ret = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(v[i] != i + 1)\n        {\n            ret++;\n        }\n    }\n    \n    return ret;\n}\n\nmap<vector<int>, bool> M;\n\nint main()\n{\n    scanf(\"%d\", &n); a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    priority_queue<state> que;\n    \n    que.push(state(a, 0, getdistance(a))); M[a] = true;\n    \n    while(!que.empty())\n    {\n        state s = que.top(); que.pop();\n        \n        if(s.dist2 == 0)\n        {\n            printf(\"%d\\n\", s.dist1); break;\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 2; j <= n; j++)\n            {\n                reverse(s.v.begin() + i, s.v.begin() + j);\n                \n                if(!M[s.v])\n                {\n                    M[s.v] = true;\n                    \n                    que.push(state(s.v, s.dist1 + 1, getdistance(s.v)));\n                }\n                \n                reverse(s.v.begin() + i, s.v.begin() + j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define int __int8\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\n\tcin >> N;\n\n\tvector<int> A(N);\n\n\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\n\tvector<int> B = A; sort(B.begin(), B.end());\n\n\tset<vector<int> > dat; dat.insert(A);\n\n\tqueue<vector<int> > que; que.push(A);\n\n\tqueue<int> que2; que2.push(0);\n\n\tif (A == B) { cout << 0 << endl; goto Exit; }\n\n\twhile (que.size())\n\t{\n\t\tvector<int> v1 = que.front(); que.pop();\n\n\t\tint dist = que2.front(); que2.pop();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tvector<int> v2 = v1;\n\n\t\t\t\tswap(v2[i], v2[j]);\n\n\t\t\t\tif (v2 == B) { cout << dist + 1 << endl; goto Exit; }\n\n\t\t\t\tif (dat.find(v2) == dat.end())\n\t\t\t\t{\n\t\t\t\t\tdat.insert(v2);\n\n\t\t\t\t\tque.push(v2);\n\n\t\t\t\t\tque2.push(dist + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  vector<int> A;\n  int cost;\n  P(vector<int> A2=vector<int>(),int cost=inf):cost(cost)\n  {\n    A = A2;\n  }\n\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n\n};\n\nint N;\nmap<vector<int>,int> mincost;\nmap<vector<int>,int> rmincost;\nvector<int> initial;\nbool found;\n\nvoid computeR(int step)\n{\n  priority_queue<P> Q;\n  {\n    initial.resize(N);\n    rep(i,N)initial[i] = i+1;\n    Q.push(P(initial,0));\n    rmincost[initial] = 0;\n  }\n\n  clock_t st,ed;\n  st = clock();\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost > step)continue;\n\n      ed = clock();\n      if((double)(ed-st)/(double)CLOCKS_PER_SEC >= 1.0)return;      \n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(rmincost.find(next) == rmincost.end())\n\t\t{\n\t\t  rmincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\nvoid compute(vector<int> &vec)\n{\n  mincost[vec] = 0;\n  priority_queue<P> Q;\n  Q.push(P(vec,0));\n\n  int ans = inf;\n  found = false;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n\n      if(rmincost.find(p.A) != rmincost.end())\n\t{\n\t  ans = min(ans,p.cost + rmincost[p.A]);\n\t  continue;\n\t}\n\n      if(p.cost+(int)(N/2.0) >= N-1)return;\n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(mincost.find(next) == mincost.end())\n\t\t{\n\t\t  mincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n    }\n  found = true;\n  cout << ans << endl;\n  assert(ans != inf);\n}\n\nint main()\n{\n\n  scanf(\"%d\",&N);\n  \n  computeR((int)(N/2.0));\n  //cout << \"---------\" << endl;\n  vector<int> vec(N);\n  rep(i,N)cin >> vec[i];\n\n  compute(vec);\n  if(!found)cout << N-1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nvoid calc(vector< int > &array, map< vector< int >, int > &scan)\n{\n  queue< vector< int > > que;\n  que.emplace(array);\n  while(!que.empty()) {\n    auto vec = que.front();\n    que.pop();\n    int dep = scan[vec];\n    for(int i = 0; i < array.size(); i++) {\n      for(int j = i + 1; j <= array.size(); j++) {\n        reverse(begin(vec) + i, begin(vec) + j);\n        if(!scan.count(vec)) {\n          scan[vec] = dep + 1;\n          if(dep + 1 < (array.size() - 1) / 2) que.emplace(vec);\n        }\n        reverse(begin(vec) + i, begin(vec) + j);\n      }\n    }\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector< int > A(N);\n  for(int i = 0; i < N; i++) {\n    cin >> A[i];\n    --A[i];\n  }\n  vector< int > vv(N);\n  iota(begin(vv), end(vv), 0);\n\n  map< vector< int >, int > cash1, cash2;\n  calc(A, cash1);\n  calc(vv, cash2);\n\n  int ret = N - 1;\n  do {\n    if(cash1.count(vv) && cash2.count(vv))\n      ret = min(ret, cash1[vv] + cash2[vv]);\n  } while(next_permutation(begin(vv), end(vv)));\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MYSCAN scanf\n#define MYGET gets\n\nint sample[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\nint a[20];\nint tmp[20];\n\nvoid reverse(int a, int b);\n\nint main(void){\n\n\tint i, j, k, n, count = 0;\n\n\t// テ・ツ?・テ・ツ環?\n\tMYSCAN(\"%d\", &n);\n\tfor (i = 0; i < n; i++){\n\t\tMYSCAN(\"%d\", &a[i]);\n\t}\n\n\t/*\n\tprintf(\"\\n\");\n\tfor (k = 0; k < n; k++){\n\t\tprintf(\"%d \", a[k]);\n\t}\n\tprintf(\"\\n\");\n\tfor (k = 0; k < n; k++){\n\t\tprintf(\"%d \", sample[k]);\n\t}\n\tprintf(\"\\n\");\n\t*/\n\n\t// テゥツ?妥・ツシツオテ」ツつ?\n\tfor (i = 0; i < n; i++){\n\n\t\t// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗」ツ?ェテ」ツ??」ツ?ィテ」ツ??」ツ?妥」ツ?ェテ」ツ??・ツ按、テ・ツョツ?\n\t\tif (a[i] != sample[i]){\n\t\t\t// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗・ツ?暗」ツ?古」ツ?ゥテ」ツ?禿」ツ?ォテ」ツ?づ」ツつ凝」ツ?ョテ」ツ?凝ィツヲツ凝」ツ?、テ」ツ?妥」ツつ?\n\t\t\tfor (j = i; a[i] != sample[j]; j++);\n\t\t\t// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗」ツつ?\n\t\t\treverse(i, j);\n\t\t\t// テ」ツつォテ」ツつヲテ」ツδウテ」ツδ暗」ツつ「テ」ツδε」ツδ?\n\t\t\tcount++;\n\t\t\t\t\n\t\t\t/*\n\t\t\t//printf(\"\\n%d\", i);\n\t\t\tfor (k = 0; k < n; k++){\n\t\t\t\tprintf(\"%d \", a[k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\tfor (k = 0; k < n; k++){\n\t\t\t\tprintf(\"%d \", sample[k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t}\n\n\t// テ・ツ?コテ・ツ環?\n\tprintf(\"%d\\n\", count);\n\n\t//MYSCAN(\"\\n\");\n\n\treturn 0;\n}\n\n// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗」ツつ凝」ツ?榲」ツδシ\nvoid reverse(int a_, int b){\n\tint i, j;\n\n\tfor (i = a_, j = 0; i <= b; i++, j++){\n\t\ttmp[j] = sample[i];\n\t}\n\n\tfor (i = b, j = 0; i >= a_; i--, j++){\n\t\tsample[i] = tmp[j];\n\t}\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t\t//★ある状態から、firstへの距離が一気に2以上縮まることはない。よって、自分が1以上増えることにより、打ち切り★\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<int> fact(n+1);\n  fact[0]=1;\n  for(int i=1;i<=n;i++) fact[i]=fact[i-1]*i;\n\n  vector<int> diff(1<<n,0),num(1<<n,0);\n  for(int i=0;i<(1<<n);i++){\n    for(int j=0;j<n;j++){\n      if(i&(1<<j)){\n        diff[i]+=fact[n-j-1];\n        num[i]++;\n      }\n    }\n  }\n\n  vector<int> a(n),b(n);\n  for(int i=0;i<n;i++) cin >> a[i];\n\n  int start=0;\n  int count;\n  for(int i=1;i<n;i++){\n    count=0;\n    for(int j=0;j<n;j++){\n      if(a[j]==i){\n        start+=count*fact[n-i];\n        break;\n      }else if(a[j]>i){\n        count++;\n      }\n    }\n  }\n\n  vector<int> dist(fact[n],-1);\n  dist[start]=0;\n  queue<int> bfs;\n  bfs.push(start);\n  int now,next,nt,dbg;\n  while(!bfs.empty()){\n    now=nt=bfs.front();\n    bfs.pop();\n    for(int i=0;i<n;i++) a[i]=-1;\n    for(int i=0;i<n;i++){\n      count=nt/fact[n-i-1];\n      nt-=count*fact[n-i-1];\n      for(int j=0;j<n;j++){\n        if(a[j]<0){\n          if(count==0){\n            a[j]=i;\n            break;\n          }\n          count--;\n        }\n      }\n    }\n    for(int i=1;i<n-1;i++){\n      count=(1<<a[i]);\n      next=now;\n      for(int j=1;j<=min(i,n-i-1);j++){\n        count+=(1<<a[i+j])+(1<<a[i-j]);\n        next+=num[count&((1<<n)-(1<<(a[i-j]+1)))]*fact[n-a[i-j]-1]-num[count&((1<<n)-(1<<(a[i+j]+1)))]*fact[n-a[i+j]-1];\n        if(a[i+j]>a[i-j]){\n          next+=diff[count&((1<<a[i+j])-(1<<(a[i-j]+1)))];\n        }else{\n          next-=diff[count&((1<<a[i-j])-(1<<(a[i+j]+1)))];\n        }\n        if(dist[next]==-1){\n          dist[next]=dist[now]+1;\n          bfs.push(next);\n        }\n      }\n    }\n    for(int i=1;i<n;i++){\n      count=0;\n      next=now;\n      for(int j=1;j<=min(i,n-i);j++){\n        count+=(1<<a[i+j-1])+(1<<a[i-j]);\n        next+=num[count&((1<<n)-(1<<(a[i-j]+1)))]*fact[n-a[i-j]-1]-num[count&((1<<n)-(1<<(a[i+j-1]+1)))]*fact[n-a[i+j-1]-1];\n        if(a[i+j-1]>a[i-j]){\n          next+=diff[count&((1<<a[i+j-1])-(1<<(a[i-j]+1)))];\n        }else{\n          next-=diff[count&((1<<a[i-j])-(1<<(a[i+j-1]+1)))];\n        }\n        if(dist[next]==-1){\n          dist[next]=dist[now]+1;\n          bfs.push(next);\n        }\n      }\n    }\n    if(dist[0]!=-1){\n      cout << dist[0] << endl;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define int __int16\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\n\tcin >> N;\n\n\tvector<int> A(N);\n\n\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\n\tvector<int> B = A; sort(B.begin(), B.end());\n\n\tset<vector<int> > dat; dat.insert(A);\n\n\tqueue<vector<int> > que; que.push(A);\n\n\tqueue<int> que2; que2.push(0);\n\n\tif (A == B) { cout << 0 << endl; goto Exit; }\n\n\twhile (que.size())\n\t{\n\t\tvector<int> v1 = que.front(); que.pop();\n\n\t\tint dist = que2.front(); que2.pop();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tvector<int> v2 = v1;\n\n\t\t\t\tswap(v2[i], v2[j]);\n\n\t\t\t\tif (v2 == B) { cout << dist + 1 << endl; goto Exit; }\n\n\t\t\t\tif (dat.find(v2) == dat.end())\n\t\t\t\t{\n\t\t\t\t\tdat.insert(v2);\n\n\t\t\t\t\tque.push(v2);\n\n\t\t\t\t\tque2.push(dist + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n\ntypedef pair< int, vector<int> > P;\n#define DEPTH first\n#define ARRAY second\n\nint main(){\n  int ans;\n  int N;\n  cin>>N;\n  vector<int> A(N), sorted(N);\n  for(int i=0; i<N; i++){\n    cin>>A[i];\n    sorted[i]=i+1;\n  }\n\n  map< vector<int>, int > num;\n  queue<P> q;\n  q.push( P(0,sorted) );\n  while(!q.empty()){\n    P now=q.front();\n    q.pop();\n    if(now.DEPTH>=4)break;\n    if(num.count(now.ARRAY))continue;\n    num[now.ARRAY] = now.DEPTH;\n    for(int i=0; i<N; i++){\n      for(int j=i+1; j<N; j++){\n        P next=now;\n        next.DEPTH++;\n        reverse(next.ARRAY.begin()+i,next.ARRAY.begin()+j+1);\n        q.push(next);\n      }\n    }\n  }\n\n  map< vector<int>, int > num2;\n  queue<P> q2;\n  q2.push( P(0,A) );\n  while(!q2.empty()){\n    P now=q2.front();\n    q2.pop();\n    if(now.DEPTH>=4)break;\n    if(num2.count(now.ARRAY))continue;\n    num2[now.ARRAY] = now.DEPTH;\n    for(int i=0; i<N; i++){\n      for(int j=i+1; j<N; j++){\n        P next=now;\n        next.DEPTH++;\n        reverse(next.ARRAY.begin()+i,next.ARRAY.begin()+j+1);\n        q2.push(next);\n      }\n    }\n  }\n\n  ans=9;\n  map< vector<int>, int >::iterator it;;\n  for(it=num.begin(); it!=num.end(); it++){\n    if(!num2.count(it->first))continue;\n    ans = min(ans, it->second + num2[it->first]);\n  }\n\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull> p2;\n \nmap<ull,int> dist;\n \nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \nint n;\nqueue<p2> que;\n\nvoid bfs(vector<int>start){\n  \n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>=(n-1)/2)return;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tbool fg = dist.find(encode(t))==dist.end();\n\tif(fg || (!fg && dist[encode(t)]>now.cost+1))\n\t  que.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n\nint bfs2(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    if(now.cost>(n-1)/2)return -1;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  bfs(g);\n\n  cout << bfs2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef map<vi, int> ma;\n\nvi a,b;\nint N;\n\nma bfs(vi vec){\n    ma tem;\n    queue<vi>que;\n    que.push(vec);\n    tem[vec]=0;\n    while(!que.empty()){\n        \n        vi v=que.front();\n        que.pop();\n//        cout<<\"tem[v]: \"<<tem[v]<<endl;\n//        for(int i=0;i<v.size();i++)\n//            cout<<v[i]<<\" \";\n//        cout<<endl;\n        if(tem[v]>(N-1)/2)\n            continue;\n        for(int i=0;i<N;i++)\n            for(int j=i+2;j<=N;j++){\n                vi n=v;\n                reverse(n.begin()+i,n.begin()+j);\n                if(tem.find(n)==tem.end()){\n                    tem[n]=tem[v]+1;\n                    que.push(n);\n                }\n            }\n    }\n    return tem;\n}\n\nvoid solve(){\n    ma m_a=bfs(a);\n    ma m_b=bfs(b);\n   \n    if(m_a.find(b)!=m_a.end()){\n        cout<<m_a[b]<<endl;\n        return;\n    }\n    int ans=1000000;\n    do{\n        if(m_a.find(b)==m_a.end()&&m_b.find(b)==m_b.end())\n            continue;\n        else\n            ans=min(m_a[b]+m_b[b],ans);\n    }while(next_permutation(b.begin(), b.end()));\n    cout<<ans<<endl;\n}\n\nint main(){\n    cin>>N;\n    for(int i=0;i<N;i++){\n        int t;\n        cin>>t;\n        a.push_back(t);\n    }\n    b=a;\n    sort(b.begin(),b.end());\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nshort N;\n\nstruct Array{\n\tshort a[10], d;\n\tArray(){}\n\tbool operator==(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn d < obj.d;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, short dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(short i = 0; i < N; i++){\n\t\tfor(short j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(short k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(short k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(short i = 0; i < N; i++) cin >> A.a[i];\n\tfor(short i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\n\tsort(vec2.begin(), vec2.end());\n\tvec2.erase(unique(vec2.begin(), vec2.end()), vec2.end());\n\t\n\tshort ans = N-1;\n\tArray tmp;\n\tfor(short i = 0; i < vec.size(); i++){\n\t\ttmp = vec[i]; tmp.d = 0;\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), tmp);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, (short)(p->d + vec[i].d));\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n\nvi rev(vi in, int s, int t) {\n\treverse(in.begin() + s, in.begin() + t);\n\treturn in;\n}\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvi A(N), g(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tg[i] = i + 1;\n\t}\n\tif (A == g) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<vi> q; q.push_back(A);\n\tbool flag = false;\n\tmap<vi, int> mp; mp[A] = 1;\n\tfor (int i = 0;!q.empty(); i++) {\n\t\tauto tmp = q; q.clear();\n\t\tfor (auto v : tmp) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tauto t = rev(v, i, j + 1);\n\t\t\t\t\tif (t == g) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tgoto to;\n\t\t\t\t\t}\n\t\t\t\t\tif (mp[t]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp[t] = 1;\n\t\t\t\t\tq.push_back(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto:\n\t\tif (flag) {\n\t\t\tcout << i + 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint N;\n\nll encode(int * v){\n    ll res = 0;\n    rep(i,N) res = res*10+v[i];\n    return res;\n}\nvoid decode(ll v, int * a){\n    rep(i,N){\n        a[N-i-1] = v%10;\n        v/=10;\n    }\n}\n\nint main(){\n    cin >> N;\n    int init[15], goal[15];\n    rep(i,N) cin >> init[i];\n    rep(i,N) goal[i] = i+1;\n    map<ll,int> x,y;\n    ll ans = -1;\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(init),0);\n        x[encode(init)] = 0;\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            int e[15];\n            decode(c,e);\n            if(x[c] < d) continue;\n            if(d==4) continue;\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    q.emplace(w,d+1);\n                    x[w] = d+1;\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(goal),0);\n        y[encode(goal)] = 0;\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            int e[15];\n            decode(c,e);\n            if(y[c] < d) continue;\n            if(d==4) continue;\n            if(x.count(c)){\n                ans = d+x[c];\n                break;\n            }\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(y.count(w)==0){\n                    q.emplace(w,d+1);\n                    y[w] = d+1;\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    if(ans == -1) ans = 9;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N;\nvector<int> A;\n\nbool check(vector<int>& a){\n  for(int i=0;i<N;i++)\n    if(a[i]!=i) return false;\n  return true;\n}\nint ind(vector<int>&a, int x){\n  for(int i=0;i<N;i++)\n    if( a[i] == x ) return i;\n}\nvoid view(vector<int>& a){\n  for(int i=0;i<N;i++) cout << a[i] << \" \";\n  cout << endl;\n}\n\ntypedef pair<vector<int>,int> P;\nmap<vector<int>,int> M;\n\nint solve(){\n  if( check(A) ) return 0;\n  M.clear();\n  queue<P> q;\n  q.push( P(A, 0) );\n  while( !q.empty() ){\n    P p = q.front(); q.pop();\n    for(int i=0;i<N;i++){\n      vector<int> a=p.first;\n      int v = ind(a,i);\n      if( v == i ) continue;\n      if( v < i ) \n        reverse( a.begin()+v, a.begin()+i+1 );\n      else \n        reverse( a.begin()+i, a.begin()+v+1 );\n      if( M.count( a ) == 0 ){\n        if( check(a) ) return p.second+1;\n        M[a] = p.second+1;\n        q.push( P(a,p.second+1) );\n      }             \n    }\n  }\n}\n\nint main(){\n  while(cin >> N){\n    A.resize(N);\n    for(int i=0;i<N;i++) {\n      cin >>A[i]; A[i]--;\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nunordered_map<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n\n  memo[idx][Vtoll(s)]=0;\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+2;j<=n;j++){\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\t\n\tif(memo[idx].count(Vtoll(nS))) continue;\n\tmemo[idx][Vtoll(nS)]=cost+1;\n\t\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n  \n  d=n/2;\n  \n  idx=0;\n  \n  bfs(A);\n\n  d=n/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n  \n  unordered_map<ll,int>::iterator ite=memo[0].begin();\n\n  while(ite!=memo[0].end()){\n    \n    if(memo[1].count((*ite).first))\n      ans=min(ans,(*ite).second+memo[1][(*ite).first]);\n    \n    ite++;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n/*\n\nSAK\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull> p2;\n \nmap<ull,int> dist;\n \nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \nint n;\n \nvoid bfs(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>6)return;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n \nmap<ull,int>dist2;\n\nint bfs2(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n  dist2[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist2.find(now.state)!=dist2.end() && dist2[now.state]<now.cost)continue;\n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    dist2[now.state]=now.cost;\n    if(now.cost>5)return -1;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  bfs(g);\n   \n  cout << bfs2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint N;\n\nll encode(int * v){\n    ll res = 0;\n    rep(i,N) res = res*12+v[i];\n    return res;\n}\nvoid decode(ll v, int * a){\n    rep(i,N){\n        a[N-i-1] = v%12;\n        v/=12;\n    }\n}\n\nint main(){\n    cin >> N;\n    int init[15], goal[15];\n    rep(i,N) cin >> init[i];\n    rep(i,N) goal[i] = i+1;\n    map<ll,int> x,y;\n    ll ans = -1;\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(init),0);\n        x[encode(init)] = 0;\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            int e[15];\n            decode(c,e);\n            if(x[c] < d) continue;\n            if(d==4) continue;\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    q.emplace(w,d+1);\n                    x[w] = d+1;\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(goal),0);\n        y[encode(goal)] = 0;\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            int e[15];\n            decode(c,e);\n            if(y[c] < d) continue;\n            if(d==4) continue;\n            if(x.count(c)){\n                ans = d+x[c];\n                break;\n            }\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(y.count(w)==0){\n                    q.emplace(w,d+1);\n                    y[w] = d+1;\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    if(ans == -1) ans = 9;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n#include <utility>\nusing namespace std;\nusing Map = map< vector<int>, int >;\n\nint N;\n\nvector<int> flip(vector<int> &vec, int &l, int &r) {\n    vector<int> ret = vec;\n\n    for(int i=l; i<=r; i++) {\n        int il = i, ir = r - (i-l);\n        if(il >= ir) break;\n\n        swap(ret[il], ret[ir]);\n    }\n    return ret;\n}\n\nint solve(vector<int> &init, vector<int> &term, Map &cur, Map &pre) {\n    int ret = N - 1;\n    queue< vector<int> > que;\n    que.push(init);\n\n    while(que.size()) {\n        vector<int> vec = que.front(); que.pop();\n        if(cur[ vec ] >= N / 2) continue;\n        if(pre.count(vec)) {\n            ret = min(ret, cur[ vec ] + pre[ vec ]);\n        }\n\n        for(int l=0; l<N; l++) {\n            for(int r=l+1; r<N; r++) {\n                vector<int> nxt = flip(vec, l, r);\n                if(cur.count(nxt)) continue;\n                cur[ nxt ] = cur[ vec ] + 1;\n                que.push(nxt);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    vector<int> perm(N);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d\", &perm[i]);\n    }\n\n    vector<int> term(N);\n    iota(term.begin(), term.end(), 1);\n\n    Map ml, mr;\n    ml[ perm ] = 0;\n    mr[ term ] = 0;\n\n    int ans = N - 1;\n    ans = min(ans, solve(perm, term, ml, mr));\n    ans = min(ans, solve(term, perm, mr, ml));\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvoid bfs(vector<int> a,map<vector<int>,int> &memo){\n\tint n=a.size();\n\tmemo[a]=0;\n\tqueue< pair< int,vector<int> > > Q; Q.push(make_pair(0,a));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().first;\n\t\tvector<int> a=Q.front().second; Q.pop();\n\n\t\tif(t==4) break;\n\n\t\trep(l,n) for(int r=l+1;r<n;r++) {\n\t\t\treverse(a.begin()+l,a.begin()+r+1);\n\t\t\tif(memo.count(a)==0){\n\t\t\t\tmemo[a]=t+1;\n\t\t\t\tQ.push(make_pair(t+1,a));\n\t\t\t}\n\t\t\treverse(a.begin()+l,a.begin()+r+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tvector<int> a(n);\n\trep(i,n) scanf(\"%d\",&a[i]);\n\n\tmap<vector<int>,int> memo1,memo2;\n\tbfs(a,memo1);\n\tsort(a.begin(),a.end());\n\tbfs(a,memo2);\n\n\tint ans=9;\n\tmap<vector<int>,int>::iterator it;\n\tfor(it=memo1.begin();it!=memo1.end();++it) if(memo2.count(it->first)>0) ans=min(ans,it->second+memo2[it->first]);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\nconst ull BASE = 1e+9+7;\nmap<ull, int> open[2];\n\null getHash(const vector<char> &seq) {\n  ull ret = 0;\n  REP(i, n) {\n    ret = ret * BASE + seq[i];\n  }\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d\", &n) > 0) {\n    open[0].clear();\n    open[1].clear();\n    vector<char> ini;\n    REP(i, n) {\n      int v;\n      scanf(\"%d\", &v);\n      v--;\n      ini.push_back(v);\n    }\n    queue<pair<vector<char>, char> > que;\n    open[0][getHash(ini)] = 0;\n    que.push(make_pair(ini, 0));\n    {\n      vector<char> sorted(n);\n      REP(i, n) {\n        sorted[i] = i;\n      }\n      open[1][getHash(sorted)] = 0;\n      if (ini == sorted) {\n        printf(\"0\\n\");\n        continue;\n      }\n      que.push(make_pair(sorted, 1));\n    }\n    while (!que.empty()) {\n      vector<char> seq = que.front().first;\n      int lr = que.front().second;\n      int ncost = open[lr][getHash(seq)] + 1;\n      que.pop();\n      REP(i, n) {\n        FOR(j, i + 1, n) {\n          vector<char> nseq = seq;\n          reverse(nseq.begin() + i, nseq.begin() + j + 1);\n          ull h = getHash(nseq);\n          if (open[lr].count(h)) { continue; }\n          if (open[lr ^ 1].count(h)) {\n            printf(\"%d\\n\", ncost + open[lr ^ 1][h]);\n            goto next;\n          }\n          open[lr][h] = ncost;\n          que.push(make_pair(nseq, lr));\n        }\n      }\n    }\n    assert(false);\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2 - 1, rn = n - ln - 1;\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nvoid calcF(int N, vector< int >& A, vector< int >& F) {\n\tfor_(i,0,N) {\n\t\tF[i] = 0;\n\t\tfor_(j,0,i) if (A[j] > A[i]) ++F[i];\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tvector< int > A(N);\n\tvector< int > F(N, 0);\n\tfor_(i,0,N) cin >> A[i];\n\t\n\tcalcF(N, A, F);\n\tint ans = 0;\n\t\n\twhile (accumulate(F.begin(), F.end(), int()) > 0) {\n\t\tfor_rev(i,N-1,1) {\n\t\t\tif (F[i] > 0) {\n\t\t\t\tfor_rev(j,i-1,0) {\n\t\t\t\t\tif (F[j] == 0) {\n\t\t\t\t\t\treverse(A.begin() + j, A.begin() + i + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcF(N, A, F);\n\t\t++ans;\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n#include <utility>\nusing namespace std;\nusing Map = map< vector<int>, int >;\n\nint N;\n\nvector<int> flip(vector<int> &vec, int &l, int &r) {\n    vector<int> ret = vec;\n\n    for(int i=l; i<=r; i++) {\n        int il = i, ir = r - (i-l);\n        if(il >= ir) break;\n\n        swap(ret[il], ret[ir]);\n    }\n    return ret;\n}\n\nint solve(vector<int> &init, vector<int> &term, Map &cur, Map &pre) {\n    int ret = N - 1;\n    queue< vector<int> > que;\n    que.push(init);\n\n    while(que.size()) {\n        vector<int> vec = que.front(); que.pop();\n        if(cur[ vec ] >= (N - 1) / 2) continue;\n        if(pre.count(vec)) {\n            ret = min(ret, cur[ vec ] + pre[ vec ]);\n        }\n\n        for(int l=0; l<N; l++) {\n            for(int r=l+1; r<N; r++) {\n                vector<int> nxt = flip(vec, l, r);\n                if(cur.count(nxt)) continue;\n                cur[ nxt ] = cur[ vec ] + 1;\n                que.push(nxt);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    vector<int> perm(N);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d\", &perm[i]);\n    }\n\n    vector<int> term(N);\n    iota(term.begin(), term.end(), 1);\n\n    Map ml, mr;\n    ml[ perm ] = 0;\n    mr[ term ] = 0;\n\n    int ans = N - 1;\n    ans = min(ans, solve(perm, term, ml, mr));\n    ans = min(ans, solve(term, perm, mr, ml));\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef map<vi, int> ma;\n\nvi a,b;\nint N;\n\nma bfs(vi vec){\n    ma tem;\n    queue<vi>que;\n    que.push(vec);\n    tem[vec]=0;\n    while(!que.empty()){\n        \n        vi v=que.front();\n        que.pop();\n//        cout<<\"tem[v]: \"<<tem[v]<<endl;\n//        for(int i=0;i<v.size();i++)\n//            cout<<v[i]<<\" \";\n//        cout<<endl;\n        if(tem[v]>(N-1)/2)\n            continue;\n        for(int i=0;i<N;i++)\n            for(int j=i+2;j<=N;j++){\n                vi n=v;\n                reverse(n.begin()+i,n.begin()+j);\n                if(tem.find(n)==tem.end()){\n                    tem[n]=tem[v]+1;\n                    que.push(n);\n                }\n            }\n    }\n    return tem;\n}\n\nvoid solve(){\n    ma m_a=bfs(a);\n    ma m_b=bfs(b);\n   \n    if(m_a.find(b)!=m_a.end()){\n        cout<<m_a[b]<<endl;\n        return;\n    }\n    int ans=1000000;\n    do{\n        if(m_a.find(b)==m_a.end()||m_b.find(b)==m_b.end())\n            continue;\n        else\n            ans=min(m_a[b]+m_b[b],ans);\n    }while(next_permutation(b.begin(), b.end()));\n    cout<<ans<<endl;\n}\n\nint main(){\n    cin>>N;\n    for(int i=0;i<N;i++){\n        int t;\n        cin>>t;\n        a.push_back(t);\n    }\n    b=a;\n    sort(b.begin(),b.end());\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  //return atoi(str.c_str());\n  return res;\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          if(data.find(v.first) != data.end()) return data[v.first] + v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <unordered_map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\n\ninline string toStr(ll x) { stringstream ss; ss<<x; return ss.str(); }\ninline ll toLL(string s) { stringstream ss(s); return atoi(ss.str().c_str()); }\n\nconst ll p10[10] = {1LL, 10LL, 100LL, 1000LL, 10000LL, 100000LL, 1000000LL, 10000000LL, 100000000LL, 1000000000LL};\n\nint N;\nint bfs(const ll num) {\n\n  ll ans = 0;\n  string sorted = toStr(num); sort(sorted.begin(), sorted.end());\n  ll s_num = toLL(sorted);\n  \n  unordered_map<ll, int> mp;\n  mp[num] = 0;\n  queue<P> Q;\n  Q.push(P(num, 0));\n  while(!Q.empty()) {\n    \n    const ll now = Q.front().first;\n    const int cost = Q.front().second;\n    Q.pop();\n    \n    if(now == s_num) {\n      ans = cost;\n      break;\n    }\n    \n    if(cost >= N-1) continue;\n    \n    const int ncost = cost+1;\n    \n    for(int i=cost; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        //reverse(now.begin()+i, now.begin()+j);\n        ll next = 0;\n        for(int k=N-1; k>=0; k--) {\n          if(i <= k && k <= j) {\n            (next *= 10) += (now / p10[j-k+i]) % 10;\n          }\n          else {\n            (next *= 10) += (now / p10[k]) % 10;\n          }\n        }\n        //cout << \"(\" << i << \", \" << j << \") : \" << now << \" \" << next << endl;\n        unordered_map<ll, int>::iterator it = mp.find(next);\n        if(it != mp.end()) {\n          if(it->second < ncost) continue;\n        }\n        mp[next] = ncost;\n        Q.push(P(next, ncost));\n      }\n    }\n  }\n  \n  return ans;\n}\n\nint main() {\n  \n  cin >> N;\n  ll num = 0;\n  for(int i=0; i<N; i++) {\n    int in; cin >> in;\n    (num *= 10) += in;\n  }\n  \n  cout << bfs(num) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(dist[lv]==4)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[nexv]){\n\t\t\t\t\tres=min(res,dist[lv]+dist[nexv]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[lv];\n\t\tif(dist[lv]==4)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MYSCAN scanf\n#define MYGET gets\n\nint sample[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\nint tmp[20];\n\nvoid reverse(int a, int b);\n\nint main(void){\n\tint a[20];\n\tint i, j, k, n, count = 0;\n\n\t// テ・ツ?・テ・ツ環?\n\tMYSCAN(\"%d\", &n);\n\tfor (i = 0; i < n; i++){\n\t\tMYSCAN(\"%d\", &a[i]);\n\t}\n\n\t/*\n\tfor (k = 0; k < n; k++){\n\t\tprintf(\"%d \", sample[k]);\n\t}\n\tprintf(\"\\n\");\n\t*/\n\n\t// テゥツ?妥・ツシツオテ」ツつ?\n\tfor (i = 0; i < n; i++){\n\t\t// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗」ツ?ェテ」ツ??」ツ?ィテ」ツ??」ツ?妥」ツ?ェテ」ツ??・ツ按、テ・ツョツ?\n\t\tif (a[i] != sample[i]){\n\t\t\t// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗・ツ?暗」ツ?古」ツ?ゥテ」ツ?禿」ツ?ォテ」ツ?づ」ツつ凝」ツ?ョテ」ツ?凝ィツヲツ凝」ツ?、テ」ツ?妥」ツつ?\n\t\t\tfor (j = 0; a[i] != sample[j]; j++);\n\t\t\t// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗」ツつ?\n\t\t\treverse(i, j);\n\t\t\t// テ」ツつォテ」ツつヲテ」ツδウテ」ツδ暗」ツつ「テ」ツδε」ツδ?\n\t\t\tcount++;\n\n\t\t\t/*\n\t\t\tfor (k = 0; k < n; k++){\n\t\t\t\tprintf(\"%d \", sample[k]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t}\n\n\t// テ・ツ?コテ・ツ環?\n\tprintf(\"%d\\n\", count);\n\n\t//MYSCAN(\"\\n\");\n\n\treturn 0;\n}\n\n// テ・ツ?・テ」ツつ古ヲツ崢ソテ」ツ?暗」ツつ凝」ツ?榲」ツδシ\nvoid reverse(int a, int b){\n\tint i, j;\n\tfor (i = a, j = 0; i <= b; i++, j++){\n\t\ttmp[j] = sample[i];\n\t}\n\n\tfor (i = b, j = 0; i >= a; i--, j++){\n\t\tsample[i] = tmp[j];\n\t}\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull> p2;\n \nmap<ull,int> dist;\n \nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \nint n;\n \nvoid bfs(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>=(n-1)/2)return;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n\nint bfs2(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    if(now.cost>(n-1)/2)return -1;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  bfs(g);\n\n   \n  cout << bfs2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nstring rev(const string &s, int i, int j){\n  string ret = s;\n  for(int k = i; k <= j; ++k) ret[k] = s[j-k+i];\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  string C(N, '0');\n  for(int i = 0; i < N; ++i) C[i] = '0' + i;\n  if(A == C){\n    cout << 0 << endl;\n    return 0;\n  }\n  queue<string> que;\n  que.push(A);\n  map<string, int> M;\n  M[A] = 1;\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M[t] > 0) continue;\n        M[t] = M[s] + 1;\n        if(t == C){\n          cout << M[t]-1 << endl;\n          return 0;\n        }\n        if(M[t] < N/2){\n          que.push(t);\n        }\n      }\n    }\n  }\n  map<string, int> M_;\n  M_[C] = 1;\n  que.push(C);\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M_[t] > 0) continue;\n        M_[t] = M_[s] + 1;\n        if(M[t] > 0){\n          cout << M[t] + M_[t] - 2 << endl;\n          return 0;\n        }\n        if(M_[t] <= N/2) que.push(t);\n      }\n    }\n  }\n  cout << N-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\n\nmap<VI,int> mp;\n\nvoid Rev(int l,int r,vector<int> &v){\n\tfor(int i=0;i<=10;i++){\n\t\tif(l+i>=r-i)break;\n\t\tswap(v[l+i],v[r-i]);\n\t}\n\treturn;\n}\n\nvoid bfs(vector<int> v,int depth){\n\tif(depth>=4)return;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\tvector<int>v1;\n\t\t\tv1 = v;\n\t\t\tRev(i,j,v1);\n\t\t\tif(mp[v1]!=0){\n\t\t\t\tif(mp[v1]>depth){\n\t\t\t\t\tmp[v1] = depth;\n\t\t\t\t\tbfs(v1,depth+1);\n\t\t\t\t}\n\t\t\t}else if(mp[v1]==0){\n\t\t\t\tmp[v1] = depth;\n\t\t\t\tbfs(v1,depth+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid bfs2(vector<int> v,int depth,int &ans){\n\tif(depth>=4)return;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\tvector<int>v1;\n\t\t\tv1 = v;\n\t\t\tRev(i,j,v1);\n\t\t\tif(mp[v1]!=0){\n\t\t\t\tans = min(ans,mp[v1]+depth);\n\t\t\t\tbfs2(v1,depth+1,ans);\n\t\t\t}else if(mp[v1]==0){\n\t\t\t\tbfs2(v1,depth+1,ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n\n\nint main(){\n\tint n;\n\tcin >>n;\n\tVI a(n);\n\trep(i,n)cin>>a[i];\n\tmp[a]=0;\n\tbfs(a,1);\n\tVI b(n);\n\trep(i,n)b[i]=i+1;\n\tif(a==b){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = -1;\n\tif(mp[b]!=0){\n\t\tans = mp[b];\n\t}\n\tbfs2(b,1,ans);\n\tif(ans==-1){\n\t\tcout << n-1 << endl;\n\t}else{\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2 + 1, rn = n - ln - 1;\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nvoid bfs(const vector<int>& vec, map<vector<int>, int>& m) {\n\tconst int len = vec.size();\n\tqueue<pair<int, vector<int> > > que;\n\tque.push(make_pair(0, vec));\n\tm[vec] = 0;\n\n\twhile(!que.empty()) {\n\t\tconst int cnt = que.front().first;\n\t\tconst vector<int> state = que.front().second;\n\t\tque.pop();\n\n\t\tif(cnt == 4)\n\t\t\tbreak;\n\n\t\tfor(int l = 0; l < len; ++l) {\n\t\t\tfor(int r = l + 1; r < len; ++r) {\n\t\t\t\tvector<int> tmp(state);\n\t\t\t\treverse(tmp.begin() + l, tmp.begin() + r + 1);\n\t\t\t\tif(!m.count(tmp)) {\n\t\t\t\t\tm[tmp] = cnt + 1;\n\t\t\t\t\tque.push(make_pair(cnt + 1, tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<int> vec(n);\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> vec[i];\n\n\tmap<vector<int>, int> a, b;\n\tbfs(vec, a);\n\tsort(vec.begin(), vec.end());\n\tbfs(vec, b);\n\n\tint ans = 9;\n\tFOR(it, a) {\n\t\tmap<vector<int>, int>::const_iterator it2 = b.find(it->first);\n\t\tif(it2 != b.end())\n\t\t\tchmin(ans, it->second + it2->second);\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\n\nvector<int> norm(vector<int> seq) {\n  if (seq.empty()) return seq;\n\n  int m = *min_element(all(seq));\n  rep(i, seq.size()) seq[i] -= m;\n  bool u[seq.size()];\n  rep(i, seq.size()) u[i] = false;\n  rep(i, seq.size()) {\n    if (seq[i] == i) u[i] = true;\n    else break;\n  }\n  for (int i=(int)seq.size()-1; i>=0; i--) {\n    if (seq[i] == i) u[i] = true;\n    else break;\n  }\n  vector<int> ret;\n  rep(i, seq.size()) if (!u[i]) ret.pb(seq[i]);\n\n  if (!ret.empty()) {\n    m = *min_element(all(ret));\n    rep(i, ret.size()) ret[i] -= m;\n  }\n  return ret;\n}\nvector<int> swap_range(vector<int> &seq, int l, int r) {\n  vector<int> ret(seq);\n  rep(s, (r-l+1)/2) swap(ret[l+s], ret[r-s]);\n  return ret;\n}\n\nint f(vector<int> seq) {\n  if (seq.empty()) return 0;\n  int first = -1, last = -1;\n  rep(i, seq.size()) {\n    if (seq[i] == 0) first = i;\n    if (seq[i] == (int)seq.size()-1) last = i;\n  }\n  assert(first != -1 && last != -1);\n\n  vector<int> ls = swap_range(seq, 0, first);\n  vector<int> rs = swap_range(seq, last, seq.size()-1);\n  //cout<<\"{\"; for (int x:seq)cout<<x<<\",\";cout<<\"} -> \"<<r<<\"\\n\";\n  return 1+min(f(norm(ls)), f(norm(rs)));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  vector<int> s;\n  rep(i, N) {\n    int a;\n    cin >> a;\n    s.pb(a);\n  }\n  cout << f(norm(s)) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nvector<int> A;\nvector<int> ans;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N;\n  A.resize(N);\n  rep(i, N) cin >> A[i];\n  rep(i, N) ans.push_back(i+1);\n\n  map<vector<int>, int> rd;\n  rd[ans] = 0;\n  queue< vector<int> > que;\n  que.push(ans);\n  while(!que.empty()) {\n    auto v = que.front(); que.pop();\n    int tmp = rd[v];\n    if(tmp >= (N-1)/2) break;\n    rep(l, N-1) reps(r, l+2, N+1) {\n      auto w = v;\n      reverse(w.begin()+l, w.begin()+r);\n      if(!rd.count(w)) {\n\trd[w] = tmp + 1;\n\tque.push(w);\n      }\n    }\n  }\n\n  if(rd.count(A)) {\n    cout << rd[A] << endl;\n    return 0;\n  }\n\n  map<vector<int>, int> d;\n  d[A] = 0;\n  while(!que.empty()) que.pop();\n  que.push(A);\n  while(!que.empty()) {\n    auto v = que.front(); que.pop();\n    int tmp = d[v];\n    if(tmp >= (N-1)/2) break;\n    rep(l, N-1) reps(r, l+2, N+1) {\n      auto w = v;\n      reverse(w.begin()+l, w.begin()+r);\n      if(rd.count(w)) {\n\tcout << rd[w] + tmp + 1 << endl;\n\treturn 0;\n      } else if(!d.count(w)) {\n\td[w] = tmp + 1;\n\tque.push(w);\n      }\n    }\n  }\n\n  cout << N-1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull > p2;\n \n\nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \n\nmap<ull,int> dist2;\n \nint n;\nqueue<p2> que;\n\nmap<ull,int> bfs(vector<int>start){\n  \n  map<ull,int> dist;\n\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n    \n    if(now.cost>=(n-1)/2)continue;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<int>t=decode(now.state);\n\treverse(t.begin()+i,t.begin()+j+1);\n\tull tmp=encode(t);\n\tif(dist.find(tmp)==dist.end()){\n\t  dist[tmp]=now.cost+1;\n\t  que.push(p2(now.cost+1,tmp));\n\t}\n      }\n    }\n  }\n  return dist;\n}\n\nint solve(vector<int> start){\n  map<ull,int>a,b;\n  a=bfs(start);\n  vector<int>goal=start;\n  sort(all(goal));\n  b=bfs(goal);\n\n  ull g=encode(goal);\n\n  int ans=start.size()-1;\n  if(a.find(g)!=a.end())ans = min(ans,a[g]);\n\n  do {\n    g=encode(goal);\n    if(a.find(g) == a.end()) continue;\n    if(b.find(g) == b.end()) continue;\n    ans = min(ans, a[g] + b[g]);\n  } while(next_permutation(all(goal)));\n\n  return ans;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n);\n  for(int i=0;i<n;i++)cin >> v[i];\n \n  cout << solve(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int ten[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};\n\nlong long int coder(vector<int> &vec){\n\tlong long int res=0;\n\tfor(int i=0;i<vec.size();i++){\n\t\tres*=10;\n\t\tres+=vec[i];\n\t}\n\treturn res;\n}\n\nlong long int get(long long int val,int level){\n\treturn (val/ten[level])%10;\n}\n\nvoid swapp(long long int &val,int lhs,int rhs){\n\tint lval=get(val,lhs);\n\tint rval=get(val,rhs);\n\tval=val-(lval*ten[lhs]+rval*ten[rhs])+(lval*ten[rhs]+rval*ten[lhs]);\n\treturn;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\tvector<int> object(n);\n\tiota(object.begin(),object.end(),0);\n\tlong long int ob=coder(object);\n\tmap<long long int,int> dp[2];\n\tfor(int loop=0;loop<2;loop++){\n\t\tlong long int first;\n\t\tif(loop==0) first=coder(a);\n\t\telse first=ob;\n\t\tdp[loop][first]=0;\n\t\tqueue<pair<long long int,int>> q;\n\t\tq.push(make_pair(first,0));\n\t\twhile(!q.empty()){\n\t\t\tauto state=q.front();\n\t\t\tq.pop();\n\t\t\tif(state.second>=4) continue;\n\t\t\t\n\t\t\t//odd\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tauto b=state.first;\n\t\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//else\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tauto b=first;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j+1<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j+1);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n\tint res=9;\n\tfor(auto it=dp[0].begin();it!=dp[0].end();it++){\n\t\tif(!dp[1].count(it->first)) continue;\n\t\tres=min(res,it->second+dp[1].find(it->first)->second);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <unordered_map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\n\ninline string toStr(ll x) { stringstream ss; ss<<x; return ss.str(); }\ninline ll toLL(string s) { stringstream ss(s); return atoi(ss.str().c_str()); }\n\nll const pow10[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};\n\nint N;\nint bfs(const ll num) {\n\n  ll ans = 0;\n  string sorted = toStr(num); sort(sorted.begin(), sorted.end());\n  ll s_num = toLL(sorted);\n  \n  unordered_map<ll, int> mp;\n  mp[num] = 0;\n  queue<P> Q;\n  Q.push(P(num, 0));\n  while(!Q.empty()) {\n    \n    const ll now = Q.front().first;\n    const int cost = Q.front().second;\n    Q.pop();\n    \n    if(now == s_num) {\n      ans = cost;\n      break;\n    }\n    \n    if(cost >= N-1) continue;\n    \n    const int ncost = cost+1;\n    \n    for(int i=cost; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        //reverse(now.begin()+i, now.begin()+j);\n        ll next = 0;\n        for(int k=N-1; k>=0; k--) {\n          if(i <= k && k <= j) {\n            (next *= 10) += (now / pow10[j-k+i]) % 10;\n          }\n          else {\n            (next *= 10) += (now / pow10[k]) % 10;\n          }\n        }\n        //cout << \"(\" << i << \", \" << j << \") : \" << now << \" \" << next << endl;\n        unordered_map<ll, int>::iterator it = mp.find(next);\n        if(it != mp.end()) {\n          if(it->second < ncost) continue;\n        }\n        mp[next] = ncost;\n        Q.push(P(next, ncost));\n      }\n    }\n  }\n  \n  return ans;\n}\n\nint main() {\n  \n  cin >> N;\n  ll num = 0;\n  for(int i=0; i<N; i++) {\n    int in; cin >> in;\n    (num *= 10) += in;\n  }\n  \n  cout << bfs(num) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int ten[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};\n\nlong long int coder(vector<int> &vec){\n\tlong long int res=0;\n\tfor(int i=0;i<vec.size();i++){\n\t\tres*=10;\n\t\tres+=vec[i];\n\t}\n\treturn res;\n}\n\nlong long int get(long long int val,int level){\n\treturn (val/ten[level])%10;\n}\n\nvoid swapp(long long int &val,int lhs,int rhs){\n\tint lval=get(val,lhs);\n\tint rval=get(val,rhs);\n\tval=val-(lval*ten[lhs]+rval*ten[rhs])+(lval*ten[rhs]+rval*ten[lhs]);\n\treturn;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\tvector<int> object(n);\n\tiota(object.begin(),object.end(),0);\n\tlong long int ob=coder(object);\n\tmap<long long int,int> dp[2];\n\tfor(int loop=0;loop<2;loop++){\n\t\tlong long int first;\n\t\tif(loop==0) first=coder(a);\n\t\telse first=ob;\n\t\tdp[loop][first]=0;\n\t\tqueue<pair<long long int,int>> q;\n\t\tq.push(make_pair(first,0));\n\t\twhile(!q.empty()){\n\t\t\tauto state=q.front();\n\t\t\tq.pop();\n\t\t\tif(state.second>=4) continue;\n\t\t\t\n\t\t\t//odd\n\t\t\tfor(int i=1;i<n-1;i++){\n\t\t\t\tauto b=state.first;\n\t\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//else\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tauto b=first;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j+1<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j+1);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n\tint res=9;\n\tfor(auto it=dp[0].begin();it!=dp[0].end();it++){\n\t\tif(!dp[1].count(it->first)) continue;\n\t\tres=min(res,it->second+dp[1].find(it->first)->second);\n\t\tif(it->second+dp[1].find(it->first)->second==3) cout<<it->first<<endl; \n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\ntypedef vector<int> vint;\n\nmap<ll, int> ma;\nset<ll> se;\n\nll myhash(vector<int> &v) {\n\tll ret = 0;\n\trep(i, v.size()) {\n\t\tret *= 11;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\n\n\nvector<int> w;\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n, 0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = n - 1;\n\tqueue<vint> q[2];\n\tq[0].push(v);\n\tint m = (v.size()-1)/2;\n\trep(o,m){\n\t\tqueue<vint>& now = q[o%2];\n\t\tqueue<vint>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t\tll h = myhash(top);\n\t\t\t\t\tif(ma.count(h)==0){\n\t\t\t\t\t\tma[h] = i+1;\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t}\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(q[0].size()) q[0].pop();\n\twhile(q[1].size()) q[1].pop();\n\tset<ll> used;\n\tq[0].push(w);\n\trep(o,m){\n\t\tqueue<vint>& now = q[o%2];\n\t\tqueue<vint>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t\tll h = myhash(top);\n\t\t\t\t\tif(ma.count(h)){\n\t\t\t\t\t\tmins(ans,ma[h]+i+1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(used.find(h)!=used.end()){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t\tused.insert(h);\n\t\t\t\t\t}\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nstring rev(const string &s, int i, int j){\n  string ret = s;\n  for(int k = i; k <= j; ++k) ret[k] = s[j-k+i];\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  string C(N, '0');\n  for(int i = 0; i < N; ++i) C[i] = '0' + i;\n  if(A == C){\n    cout << 0 << endl;\n    return 0;\n  }\n  queue<string> que;\n  que.push(A);\n  map<string, int> M;\n  M[A] = 1;\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M[t] > 0) continue;\n        M[t] = M[s] + 1;\n        if(t == C){\n          cout << M[t]-1 << endl;\n          return 0;\n        }\n        if(M[t] <= N/2){\n          que.push(t);\n        }\n      }\n    }\n  }\n  map<string, int> M_;\n  M_[C] = 1;\n  que.push(C);\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M_[t] > 0) continue;\n        M_[t] = M_[s] + 1;\n        if(M[t] > 0){\n          cout << M[t] + M_[t] - 2 << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  cout << N-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long swp(long long a, int i, int j) {\n    long long t = ((a >> (i << 2)) ^ (a >> (j << 2))) & 15;\n    return a ^ (t << (i << 2)) ^ (t << (j << 2));\n}\n\nlong long rev(long long a, int i, int j) {\n    while (i < j) {\n        a = swp(a, i, j);\n        ++i;\n        --j;\n    }\n    return a;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    long long a = 0, m = 0;\n    for (int i = 0; i < n; ++i) {\n        int b;\n        cin >> b;\n        a = (a << 4) + b;\n        m = (m << 4) + i + 1;\n    }\n    unordered_map<long long, int> mp;\n    mp[m] = 0;\n    queue<long long> q;\n    q.push(m);\n\n    while (!q.empty()) {\n        long long p = q.front();\n        q.pop();\n        // [i, j]\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                long long t = rev(p, i, j);\n                if (!mp.count(t)) {\n                    mp[t] = mp[p] + 1;\n                    if (t == a) {\n                        goto A;\n                    }\n                    q.push(t);\n                }\n            }\n        }\n    }\n    A:\n    cout << mp[a] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nqueue<P> q;\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n    \n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=n;i>=2;i--){ // range\n      \n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\t\n\tif(j&&j+i-1<n&&(!(abs(nS[j-1]-nS[j+1-1])<=1)&&!(abs(nS[j+i-2]-nS[j]<=1)))) continue;\n\t\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\tassert(memo.size()<=3628800);\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nmap<vi,int> mq;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi vec(n);\n    rep(i,n){\n        cin >> vec[i];\n        --vec[i];\n    }\n    vector<vector<int> > st[2];\n    st[0].pb(vec);\n    rep(i,4){\n        rep(id,len(st[0])){\n            rep(j,n-1){\n                srep(k,j+1,n){\n                    vi res = st[0][id];\n                    for(int l=j;2*l<j+k;l++){\n                        swap(res[l],res[j+k-l]);\n                    }\n                    if(mp.find(res) == mp.end()){\n                        mp[res] = i+1;\n                        st[1].pb(res);\n                    }\n                }\n            }\n        }\n        swap(st[0],st[1]);\n    }\n    vector<vector<int> > su[2];\n    vi res(n);\n    iota(all(res),0);\n    su[0].pb(res);\n    int ans = INF;\n    rep(i,4){\n        rep(id,len(su[0])){\n            rep(j,n-1){\n                srep(k,j+1,n){\n                    vi res = su[0][id];\n                    for(int l=j;2*l<j+k;l++){\n                        swap(res[l],res[j+k-l]);\n                    }\n                    if(mp.find(res) != mp.end()){\n                        cmn(ans,mp[res]+i+1);\n                    }else if(mq.find(res) == mq.end()){\n                        mq[res] = i+1;\n                    }\n                }\n            }\n        }\n        swap(su[0],su[1]);\n    }\n    if(ans == INF){\n        cout << \"9\\n\";\n    }else{\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint n;\n\tchar d[10];\n\tS() {}\n\tS(int n) : n(n) {}\n\tll hash() {\n\t\tll r = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tr *= 16;\n\t\t\tr += d[i];\n\t\t}\n\t\treturn r;\n\t}\n};\n\ntypedef pair<S, int> P;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tS s(n), r(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x; x--;\n\t\ts.d[i] = x;\n\t\tr.d[i] = i;\n\t}\n\tll rh = r.hash();\n\tint dist = 1, rdist = 1;\n\tqueue<P> q;\n\tmap<ll, int> u;\n\tq.push(P(s, 1));\n\twhile (!q.empty()) {\n\t\tS s(0); int d;\n\t\ttie(s, d) = q.front(); q.pop();\n\t\tif (d == 6) break;\n\n\t\tll sh = s.hash();\n\t\tif (u[sh]) continue;\n\t\tu[sh] = d;\n\t\tdist = d;\n\t\tif (sh == rh) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+2; j <= n; j++) {\n\t\t\t\tS ss = s;\n\t\t\t\treverse(ss.d + i, ss.d + j);\n\t\t\t\tq.push(P(ss, d+1));\n\t\t\t}\n\t\t}\n\t}\n\tmap<ll, int> ru;\n\tq = queue<P>();\n\tq.push(P(r, 1));\n\twhile (!q.empty()) {\n\t\tS s(0); int d;\n\t\ttie(s, d) = q.front(); q.pop();\n\t\tll sh = s.hash();\n\t\tif (d == 6) {\n\t\t\trdist = 6;\n\t\t\tbreak;\n\t\t}\n\t\tif (ru[sh]) continue;\n\t\tru[sh] = d;\n\t\trdist = d;\n\t\tif (u[sh]) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+2; j <= n; j++) {\n\t\t\t\tS ss = s;\n\t\t\t\treverse(ss.d + i, ss.d + j);\n\t\t\t\tq.push(P(ss, d+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist+rdist-2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nint n, in;\nlli input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  return atoi(str.c_str());\n}\n\nint solve(){\n  if(data.find(input) != data.end()) return data[input];\n  vis.clear();\n  P u = P(input, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  input = 0;\n  for(int i=1;i<=n;i++){\n    input *= 10;\n    if(i != 10) input += i;\n  }\n  P u = P(input, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[input] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    init();\n    input = 0;\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input *= 10;\n      if(in != 10) input += in;\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる:もっとfirstとの距離が近い枝にぶつかるかも知れないから続行\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  //return atoi(str.c_str());\n  return res;\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          if(data.find(v.first) != data.end()) return data[v.first] + v.second + 1;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm_ = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            /*for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }*/\n            \n            for(int s=0;s<N;s++){\n                for(int d=1;d<=2;d++){\n                    vector<int> perm = perm_;\n                    \n                    int S = s;\n                    int T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        int nextPermId = getPermId(perm);\n                        if(dist[curr][nextPermId] == -1){\n                            dist[curr][nextPermId] = nowCost + 1;\n                            \n                            if(dist[next][nextPermId] != -1){\n                                return dist[curr][nextPermId] + dist[next][nextPermId];\n                            } else {\n                                nextQueue.push_back(make_pair(perm, nextPermId));\n                            }\n                        }\n                        \n                        --S;\n                        ++T;\n                    }\n                    \n                    S = s;\n                    T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        --S;\n                        ++T;\n                    }\n                }\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        cin >> start[i];\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\ntypedef vector<int> vint;\n\nmap<ll, int> ma;\nset<ll> se;\n\nll myhash(vector<int> &v) {\n\tll ret = 0;\n\trep(i, v.size()) {\n\t\tret *= 11;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\n\n\nvector<int> w;\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n, 0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = n - 1;\n\tqueue<vint> q[2];\n\tq[0].push(v);\n\tint m = (v.size()-1)/2;\n\tma[myhash(v)] = 0;\n\trep(o,m){\n\t\tqueue<vint>& now = q[o%2];\n\t\tqueue<vint>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t\tll h = myhash(top);\n\t\t\t\t\tif(ma.count(h)==0){\n\t\t\t\t\t\tma[h] = o+1;\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t}\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(q[0].size()) q[0].pop();\n\twhile(q[1].size()) q[1].pop();\n\tset<ll> used;\n\tq[0].push(w);\n\trep(o,m){\n\t\tqueue<vint>& now = q[o%2];\n\t\tqueue<vint>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t\tll h = myhash(top);\n\t\t\t\t\tif(ma.count(h)){\n\t\t\t\t\t\tmins(ans,ma[h]+o+1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(used.find(h)!=used.end()){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t\tused.insert(h);\n\t\t\t\t\t}\n\t\t\t\t\treverse(top.begin()+j,top.begin()+i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nconst int L = 4;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  reverse(str.begin(), str.end());\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin() + a, str.begin() + b + 1);\n  /*lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n    }\n    return res;*/\n  return strtoll(str.c_str(), NULL, 10);\n\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = P(rev(u.first, i, j), u.second + 1);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(data.find(v.first) != data.end()) return data[v.first] + v.second;\n          if(v.second < L) q.push(v);\n        }\n      }\n    }\n  }\n  return n-1;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  //cout << u.first << ' ' << u.second << endl;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = P(rev(u.first, i, j), u.second + 1);\n        if(data.find(v.first) == data.end()){\n          //cout << v.first << ' ' << v.second << endl;\n          data[v.first] = v.second;\n          if(v.second < L) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N;\n\nlong long encode(const int *a)\n{\n  long long n = 0;\n  for (int i = 0; i < N; i++) {\n    n = 10*n + a[i];\n  }\n  return n;\n}\n\nvoid decode(int *a, long long n)\n{\n  for (int i = 0; i < N; i++) {\n    a[N-i-1] = n % 10;\n    n /= 10;\n  }\n}\n\nvoid bfs(map<long long, int>& dist, long long start)\n{\n  queue<pair<long long, int> > q;\n  dist[start] = 0;\n  q.push(make_pair(start, 0));\n  while (!q.empty()) {\n    int a[10];\n    decode(a, q.front().first);\n    const int d = q.front().second;\n    q.pop();\n    for (int i = 0; i < N; i++) {\n      for (int j = i+1; j < N; j++) {\n        int b[10];\n        copy(a, a+N, b);\n        reverse(b+i, b+j+1);\n        const long long n = encode(b);\n        const map<long long, int>::const_iterator it = dist.find(n);\n        if (it == dist.end()) {\n          dist.insert(make_pair(n, d+1));\n          if (d+1 < 4) {\n            q.push(make_pair(n, d+1));\n          }\n        }\n      }\n    }\n  }\n}\n\nint main()\n{\n  cin >> N;\n  int a[10], b[10];\n  for (int i = 0; i < N; i++) {\n    cin >> a[i];\n    --a[i];\n    b[i] = i;\n  }\n  map<long long, int> m1, m2;\n  bfs(m1, encode(a));\n  bfs(m2, encode(b));\n  int ans = 9;\n  for (map<long long, int>::const_iterator it = m1.begin(); it != m1.end(); ++it) {\n    map<long long, int>::const_iterator jt = m2.find(it->first);\n    if (jt != m2.end()) {\n      ans = min(ans, it->second + jt->second);\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nmap<vector<int>, int> dp;\n\nint dfs(vector<int> C, int n)\n{\n    if(C == B) { return n; }\n    \n    if(dp[C] != 0)\n    {\n        return dp[C];\n    }\n    \n    int min_ = N;\n    \n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(i != j)\n            {\n                vector<int> D; D = C;\n                \n                swap(D[i], D[j]);\n                \n                min_ = min(dfs(D, n + 1), min_);\n            }\n        }\n    }\n    \n    dp[C] = min_;\n    \n    return min_;\n}\n\nint main()\n{\n    cin >> N;\n    \n    A = vector<int>(N);\n    B = vector<int>(N);\n    \n    for(int i = 0; i < N; i++)\n    {\n        cin >> A[i];\n    }\n    \n    for(int i = 0; i < N; i++) { B[i] = A[i]; }\n    \n    sort(B.begin(), B.end());\n    \n    cout << dfs(A, 0) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nstruct S {\n\tvi v;\n\tint cnt, astar;\n\tbool operator >(const S &a) const {\n\t\treturn astar > a.astar;\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\t//while(cin >> n) {\n\t\tS s;\n\t\ts.v.resize(n);\n\t\tREP(i, n) cin >> s.v[i];\n\t\ts.cnt = s.astar = 0;\n\n\t\tbool chk = false;\n\t\tREP(i, n)\n\t\t\tif(i+1 != s.v[i]) chk = true;\n\t\tif(!chk) {\n\t\t\tcout << 0 << endl;\n\t\t\t//continue;\n\t\t\treturn 0;\n\t\t}\n\n\t\tset<vi> memo;\n\t\tpriority_queue<S, vector<S>, greater<S> > pq;\n\t\tpq.push(s);\n\n\t\tbool flg = false;\n\t\twhile(!pq.empty()) {\n\t\t\ts = pq.top(); pq.pop();\n\n\t\t\tREP(i, n) {\n\t\t\t\tFOR(j, i, n) {\n\t\t\t\t\tvi _v = s.v;\n\t\t\t\t\tswap(_v[i], _v[j]);\n\n\t\t\t\t\tif(!memo.count(_v)) {\n\t\t\t\t\t\tint astar = 0;\n\t\t\t\t\t\tREP(k, n)\n\t\t\t\t\t\t\tastar += (_v[k] != k+1);\n\t\t\t\t\t\tpq.push(S{_v, s.cnt+1, astar});\n\t\t\t\t\t\tmemo.insert(_v);\n\t\t\t\t\t\tif(!astar) flg = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) break;\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\tcout << s.cnt+1 << endl;\n\t//}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint N, A[11];\n\nvoid solve() {\n\tint ans1 = 0;\n\t\n\tint B[11];\n\tfor_(i,0,N) B[i] = A[i];\n\t\n\tfor_rev(i,N,1) {\n\t\tint j = i - 1;\n\t\twhile (B[j] != i) --j;\n\t\tif (j != i - 1) {\n\t\t\treverse(B + j, B + i);\n\t\t\t++ans1;\n\t\t}\n\t\t\n\t\t//for_(j,0,N) cout << B[j] << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\tint ans2 = 1;\n\tfor_(i,0,N) B[i] = A[i];\n\t\n\tfor_rev(i,N,1) {\n\t\tint j = N - i;\n\t\twhile (B[j] != i) ++j;\n\t\tif (j != N - i) {\n\t\t\treverse(B + N - i, B + j + 1);\n\t\t\t++ans2;\n\t\t}\n\t\t\n\t\t//for_(j,0,N) cout << B[j] << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\t\n\tcout << min(ans1, ans2) << endl;\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> A[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <map>\n\nusing namespace std;\ntypedef unsigned long long ULL;\n\nint arr[10];\nint N;\nULL hashval() {\n    ULL val = 0;\n    for(int i = 0; i < N; ++i) {\n        val <<= 4;\n        val += arr[i];\n    }\n    return val;\n}\nvoid restorehash(ULL hash) {\n    for(int i = N-1; i >= 0; --i) {\n        arr[i] = hash & 0x0f;\n        hash >>= 4;\n    }\n}\n\nvoid enumerate(map<ULL,int> &seen) {\n    queue<pair<ULL,int> > q;\n    q.push(make_pair(hashval(),0));\n    while(!q.empty()) {\n        ULL hash = q.front().first;\n        int turn = q.front().second;\n        q.pop();\n        seen[hash] = turn;\n        if(turn == 4) continue;\n        restorehash(hash);\n        for(int left = 0; left < N; ++left) {\n            for(int right = left+1; right < N; ++right) {\n                reverse(arr+left, arr+right+1);\n                ULL new_hash = hashval();\n                if(seen.count(new_hash)) {\n                    reverse(arr+left, arr+right+1);\n                    continue;\n                }\n                seen[new_hash] = turn+1;\n                q.push(make_pair(new_hash, turn+1));\n                reverse(arr+left, arr+right+1);\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; ++i) {\n        scanf(\"%d\", arr+i);\n    }\n    map<ULL,int> seen, seen_rev;\n    enumerate(seen);\n    sort(arr, arr+N);\n    enumerate(seen_rev);\n    int ans = N-1;\n    for(map<ULL,int>::iterator it = seen.begin(); it != seen.end(); ++it) {\n        if(seen_rev.count(it->first)) {\n            //cout << it->second << ' ' << seen_rev[it->first] << endl;\n            ans = min(ans, it->second + seen_rev[it->first]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int c,d,e;\n  S(const vector<int> &pv,int pc):v(pv),c(pc){\n    eval();\n  }\n  void eval(){\n    d=0;\n    for(int i=0;i<v.size();i++){\n      d+=v[i]!=i+1;\n    }\n    e=c+(d+1)/2;\n  }    \n  void swap(int a,int b){\n    c++;\n    std::swap(v[a],v[b]);\n    eval();\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n\nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  map<vector<int>,int> m;\n  for(;;){\n    S c=que.top();\n    if(c.d==0)break;\n    que.pop();\n    if(m.count(c.v)&&m[c.v]<=c.c)continue;\n    m[c.v]=c.c;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tS n=c;\n\tn.swap(i,j);\n\tque.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//-O2 is required.\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef vector<int> V;\nmap<V,int>m;\n//map<V,pair<pair<int,int>,V> >track;\n//V v1,v2;\npair<int,int>vec2nvec;\nint bfs(V &v, int back){\n\tif(!back&&m.find(v)!=m.end()){\n\t\t//v1.clear();\n\t\t//vec2nvec=make_pair(0,0);\n\t\t//v2=v;\n\t\treturn m[v];\n\t}\n\tset<V>s;\n\tqueue<pair<V,int> >q;\n\tif(back)m[v]=0;\n\ts.insert(v);\n\tint i,j;\n\tfor(q.push(make_pair(v,0));!q.empty();){\n\t\tV vec=q.front().first;\n\t\tint depth=q.front().second;\n\t\tq.pop();\n\t\tif(back&&depth>3)return 0;\n\t\tfor(i=0;i<vec.size();i++)\n\t\t\tfor(j=i+1;j<vec.size();j++){\n\t\t\t\tV nvec=vec;\n\t\t\t\treverse(nvec.begin()+i,nvec.begin()+j+1);\n\t\t\t\tif(!back&&m.find(nvec)!=m.end()){\n\t\t\t\t\t//v1=vec;\n\t\t\t\t\t//vec2nvec=make_pair(i,j);\n\t\t\t\t\t//v2=nvec;\n\t\t\t\t\treturn depth+1+m[nvec];\n\t\t\t\t}\n\t\t\t\tif(!s.insert(nvec).second)continue;\n\t\t\t\tif(back)m[nvec]=depth+1;\n\t\t\t\t//track[nvec]=make_pair(make_pair(i,j),vec);\n\t\t\t\tq.push(make_pair(nvec,depth+1));\n\t\t\t}\n\t}\n\treturn 0;\n}\n//void backtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tbacktrack(track[v].second);\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//}\n//void forwardtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//\tforwardtrack(track[v].second);\n//}\nmain(){\n\tV prob;\n\tint i=0,t,n;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tif(scanf(\"%d\",&t)==-1)return 0;\n\t\tprob.push_back(t);\n\t}\n\tV goal=prob;\n\tsort(goal.begin(),goal.end());\n\tbfs(goal,1);\n\tprintf(\"%d\\n\",bfs(prob,0));\n\t//backtrack(v1);\n\t//if(vec2nvec.first!=vec2nvec.second)printf(\"%d %d\\n\",vec2nvec.first+1,vec2nvec.second+1);\n\t//forwardtrack(v2);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint main() {\n\tint N; cin >> N;\n\tstring starts;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\ta--;\n\t\tstarts.push_back(a + '0');\n\t}\n\tstring goals; \n\tfor (int i = 0; i < N; ++i) {\n\t\tgoals.push_back(i + '0');\n\t}\n\tvector < vector<string>>fromstarts(5);\n\tfromstarts[0].emplace_back(starts);\n\tvector< vector<string>>fromgoals(5);\n\tfromgoals[0].emplace_back(goals);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tvector<string>aset;\n\t\tfor (auto v : fromstarts[i]) {\n\t\t\tfor (int l = 0; l < N; ++l) {\n\t\t\t\tfor (int r = l+2; r <= N; ++r) {\n\t\t\t\t\tstring rev = v.substr(l, r - l);\n\t\t\t\t\treverse(rev.begin(), rev.end());\n\t\t\t\t\tstring next = v.substr(0, l) + rev + (v.substr(r, N - r));\n\t\t\t\t\taset.emplace_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(aset.begin(), aset.end());\n\t\taset.erase(unique(aset.begin(), aset.end()), aset.end());\n\t\tfromstarts[i + 1] = aset;\n\t}\n\tfor (int i = 0; i < 4; ++i) {\n\t\tvector<string>aset;\n\t\tfor (auto v : fromgoals[i]) {\n\t\t\tfor (int l = 0; l < N; ++l) {\n\t\t\t\tfor (int r = l + 2; r <= N; ++r) {\n\t\t\t\t\tstring rev = v.substr(l, r - l);\n\t\t\t\t\treverse(rev.begin(), rev.end());\n\t\t\t\t\tstring next = v.substr(0, l) + rev + (v.substr(r, N - r));\n\t\t\t\t\taset.emplace_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(aset.begin(), aset.end());\n\t\taset.erase(unique(aset.begin(), aset.end()), aset.end());\n\t\tfromgoals[i + 1] = aset;\n\t}\n\tint ans = 9;\n\tfor (int s = 0; s < 4; ++s) {\n\t\tfor (int t = 0; t < 4; ++t) {\n\t\t\tvector<string>sames;\n\t\t\tset_intersection(fromstarts[s].begin(), fromstarts[s].end(), fromgoals[t].begin(), fromgoals[t].end(), inserter(sames, sames.end()));\n\t\t\tif (!sames.empty()) {\n\t\t\t\tans = min(ans, s+t);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  vector<int> nums;\n  int cost;\n  bool operator <(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator >(const State& s) const {\n    return cost > s.cost;\n  }\n  State(const vector<int>& n,int c) {\n    nums = n;\n    cost = c;\n  }\n};\n\nint bfs(const vector<int>& init,\n        map<vector<int>,int>& dp){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(init,0));\n  dp[init] = 0;\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int lhs = 0; lhs < s.nums.size(); lhs++){\n      for(int rhs = lhs + 1; rhs <= s.nums.size(); rhs++){\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n        \n        if(dp.find(s.nums) != dp.end()){\n          reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n          continue;\n        }\n\n        dp[s.nums] = s.cost + 1;\n        que.push(State(s.nums,s.cost+ 1));\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<int> nums;\n    for(int i=0; i < N; i++){\n      int num;\n      scanf(\"%d\",&num);\n      nums.push_back(num);\n    }\n    map<vector<int>,int> dp;\n    bfs(nums,dp);\n    sort(nums.begin(),nums.end());\n    printf(\"%d\\n\",dp[nums]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n\tll hash;\n\tint l, r;\n};\n\nint N;\n\nll toHash(vector<int> v) {\n\tll ret = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tret *= 10;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\nvector<int> fromHash(ll hash) {\n\tvector<int> ret(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tret[N-i-1] = hash % 10;\n\t\thash /= 10;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N;\n\n\tvector<int> v(N);\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tcin >> v[i]; --v[i];\n\t}\n\n\tvector<int> g = v;\n\tsort(g.begin(), g.end());\n\n\tset<ll> s;\n\tqueue<Node> Q[10]; Q[0].push( (Node){ toHash(v), 0, 0 } );\n\tfor (int step = 0; step < N; ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tNode node = Q[step].front(); Q[step].pop();\n\t\t\tll hash = node.hash;\n\t\t\tint l = node.l, r = node.r;\n\n\t\t\tif (s.find(hash) != s.end()) continue;\n\t\t\ts.insert(hash);\n\n\t\t\tvector<int> v = fromHash(hash);\n\n\t\t\tif (v == g) {\n\t\t\t\tcout << step << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n//\t\t\t\t\t\tif (l <= i && j <= r) continue;\n\n\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int k = i+1; k < j; ++k) {\n\t\t\t\t\t\t\tif (nv[k] != k) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) Q[step+1].push( (Node){ toHash(nv), i, j } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nmap<vector<int>, int> dp;\n\nint dfs(vector<int> C, int n)\n{\n\tif (C == B)\n\t{ \n\t\treturn n;\n\t}\n\n\tint min_ = N;\n\n\tif (n < N)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (i != j && C[i] > C[j])\n\t\t\t\t{\n\t\t\t\t\tvector<int> D; D = C;\n\n\t\t\t\t\tswap(D[i], D[j]);\n\n\t\t\t\t\tmin_ = min(dfs(D, n + 1), min_);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min_;\n}\n\nint main()\n{\n\tcin >> N;\n\n\tA = vector<int>(N);\n\tB = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\n\tfor (int i = 0; i < N; i++) { B[i] = A[i]; }\n\n\tsort(B.begin(), B.end());\n\n\tcout << dfs(A, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint N;\n\nll encode(int * v){\n    ll res = 0;\n    rep(i,N) res = res*15+v[i];\n    return res;\n}\nvoid decode(ll v, int * a){\n    rep(i,N){\n        a[N-i-1] = v%15;\n        v/=15;\n    }\n}\n\nint main(){\n    cin >> N;\n    int init[15];\n    rep(i,N) cin >> init[i];\n    int goal[15];\n    rep(i,N) goal[i] = i+1;\n    map<ll,int> x,y;\n    ll ans = -1;\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(init),0);\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            if(x.count(c)) continue;\n            int e[15];\n            decode(c,e);\n            x[c] = d;\n            if(d==4) continue;\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    q.emplace(w,d+1);\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(goal),0);\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            if(y.count(c)) continue;\n            int e[15];\n            decode(c,e);\n            y[c] = d;\n            if(d==4) continue;\n            if(x.count(c)){\n                ans = d+x[c];\n                break;\n            }\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    y[w] = d+1;\n                    q.emplace(w,d+1);\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    if(ans == -1) ans = 9;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int ten[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};\n\nlong long int coder(vector<int> &vec){\n\tlong long int res=0;\n\tfor(int i=0;i<vec.size();i++){\n\t\tres*=10;\n\t\tres+=vec[i];\n\t}\n\treturn res;\n}\n\nlong long int get(long long int val,int level){\n\treturn (val/ten[level])%10;\n}\n\nvoid swapp(long long int &val,int lhs,int rhs){\n\tint lval=get(val,lhs);\n\tint rval=get(val,rhs);\n\tval=val-(lval*ten[lhs]+rval*ten[rhs])+(lval*ten[rhs]+rval*ten[lhs]);\n\treturn;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\tvector<int> object(n);\n\tiota(object.begin(),object.end(),0);\n\tlong long int ob=coder(object);\n\tmap<long long int,int> dp[2];\n\tfor(int loop=0;loop<2;loop++){\n\t\tlong long int first;\n\t\tif(loop==0) first=coder(a);\n\t\telse first=ob;\n\t\tdp[loop][first]=0;\n\t\tqueue<pair<long long int,int>> q;\n\t\tq.push(make_pair(first,0));\n\t\twhile(!q.empty()){\n\t\t\tauto state=q.front();\n\t\t\tq.pop();\n\t\t\tif(state.second>=4) continue;\n\t\t\t\n\t\t\t//odd\n\t\t\tfor(int i=1;i<n-1;i++){\n\t\t\t\tauto b=state.first;\n\t\t\t\tfor(int j=1;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//else\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tauto b=first;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j+1<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j+1);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n\tint res=9;\n\tfor(auto it=dp[0].begin();it!=dp[0].end();it++){\n\t\tif(!dp[1].count(it->first)) continue;\n\t\tres=min(res,it->second+dp[1].find(it->first)->second);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint N;\n\nll encode(int * v){\n    ll res = 0;\n    rep(i,N) res = res*10+v[i];\n    return res;\n}\nvoid decode(ll v, int * a){\n    rep(i,N){\n        a[N-i-1] = v%10;\n        v/=10;\n    }\n}\n\nint main(){\n    cin >> N;\n    int init[10];\n    rep(i,N) cin >> init[i];\n    int goal[10];\n    rep(i,N) goal[i] = i+1;\n    map<ll,int> x,y;\n    ll ans = -1;\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(init),0);\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            if(x.count(c)) continue;\n            int e[10];\n            decode(c,e);\n            x[c] = d;\n            if(d==4) continue;\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    q.emplace(w,d+1);\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(goal),0);\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            if(y.count(c)) continue;\n            int e[10];\n            decode(c,e);\n            y[c] = d;\n            if(d==4) continue;\n            if(x.count(c)){\n                ans = d+x[c];\n                break;\n            }\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    y[w] = d+1;\n                    q.emplace(w,d+1);\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    if(ans == -1) ans = 9;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nvoid ennumerate(unordered_map<string, int> &b, string s) {\n    b.clear();\n    \n    queue<string> q;\n    q.push(s);\n    b[s] = 0;\n    while (!q.empty()) {\n        string t = q.front(); q.pop();\n//        cout << \"###\" << endl;\n//        cout << t << endl;\n        int next_step = b[t] + 1;\n        rep(i, t.size()) repi(j, i+2, t.size()+1) {\n            reverse(t.begin() + i, t.begin() + j);\n            if (!b.count(t)) {\n//                cout << t << endl;\n                b[t] = next_step;\n//                cout << next_step << endl;\n                q.push(t);\n            }\n            reverse(t.begin() + i, t.begin() + j);\n        }\n    }\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n; cin >> n;\n    string org(n, ' '); rep(i, org.size()) { \n        org[i] = i + 1 + '0';\n    }\n    string a(n, ' '); rep(i, a.size()) { \n        int tmp; cin >> tmp;\n        a[i] = tmp + '0';\n            \n    }\n\n    unordered_map<string, int> b1, b2;\n    b1.reserve(1000000);\n    b2.reserve(1000000);\n    ennumerate(b1, org);\n    ennumerate(b2, a);\n//    cout << b1 << endl;\n\n    ll ret = n - 1;\n    for (auto x : b1) {\n        if (b2.count(x.fi)) {\n            if (ret > x.se + b2[x.fi]) {\n                ret = x.se + b2[x.fi];\n//                cout << x << \" \" <<  b2[x.fi] << endl;\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull> p2;\n \nmap<ull,int> dist;\n \nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \nint n;\n \nvoid bfs(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>=(n-1)/2)return;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n \nmap<ull,int>dist2;\n\nint bfs2(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,encode(start)));\n  dist2[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist2.find(now.state)!=dist2.end() && dist2[now.state]<now.cost)continue;\n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    dist2[now.state]=now.cost;\n    if(now.cost>(n-1)/2)return -1;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  bfs(g);\n\n   \n  cout << bfs2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nint n;\nint dfs(int l,int r,vector<int> v,int q)\n{\n\tint ret = 100;\n\tif(l == r && v[l] == l)return q;\n\tif(l > r)return 100;\n\tif(q > 10)return 100;\n\n\t//cerr << q << ':';\n\t//SHOW1d(v,n);\n\t\n\tbool flag = true;\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] != i)flag = false;\n\t\tif(v[i] > r || v[i] < l)return 100;\n\t}\n\tif(flag)\n\t{\n\t\treturn q;\n\t}\n\t\n\t\n\twhile(v[l] == l)l++;\n\twhile(v[r] == r)r--;\n\t\n\t\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == l)\n\t\t{\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t\tret = min(ret,dfs(l+1,r,v,q+1));\n\t\t\treverse(v.begin()+l,v.begin()+i+1);\n\t\t}\n\t}\n\tfor(int i = l;i <= r;i++)\n\t{\n\t\tif(v[i] == r)\n\t\t{\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t\tret = min(ret,dfs(l,r-1,v,q+1));\n\t\t\treverse(v.begin()+i,v.begin()+r+1);\n\t\t}\n\t}\n\t\n\treverse(v.begin()+l,v.begin()+r+1);\n\tret = min(ret,dfs(l,r,v,q+1));\n\treverse(v.begin()+l,v.begin()+r+1);\n\n\tREP(i,r-l)\n\t{\n\t\tret = min(ret,dfs(l,l+i,v,0)+dfs(l+i+1,r,v,0) + q);\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\tcin >> n;\n\tvector<int> v(n);\n\tREP(i,n)cin>>v[i];\n\tREP(i,n)v[i]--;\n\t\n\tint ans = 10;\n\t\n\tans = min(ans,dfs(0,n-1,v,0));\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nvector<char> v;\nmap<vector<char> ,int> d1;\nmap<vector<char> ,int> d2;\nint N;\nvector<char> sorted;\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  queue<vector<char> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  int ans=1<<30;\n  while(q1.size()||q2.size()){\n    {\n      vector<char> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      if(now==sorted){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<char> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d2.count(nv)!=0&&d1.count(nv)==0)\n\t    ans=min(ans,ccost+1+d2[nv]);\n\t  else if(d1.count(nv)==0){\n\t    d1[nv]=ccost+1;\n\t    q1.push(nv);\n\t  }\n\t}\n      }\n    }\n    {\n      vector<char> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      if(v==now){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<char> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d1.count(nv)!=0&&d2.count(nv)==0)\n\t    ans=min(ans,ccost+1+d1[nv]);\n\t  else if(d2.count(nv)==0){\n\t    d2[nv]=ccost+1;\n\t    q2.push(nv);\n\t  }\n\t}\n      }\n    }\n    if(q1.size()&&q2.size()){\n      int sum=d1[q1.front()]+d2[q2.front()]+1;\n      if(sum>=ans)break;\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 10;\nconst int INF = 1 << 29;\n\nstruct state{\n  lli num;\n  int cnt;\n  state(lli num=0, int cnt=0):num(num),cnt(cnt){}\n};\n\nint n;\nlli pow10[11];\nvector<int> v;\n\nlli hash(const vector<int> &vec){\n  lli res = 0, di = 1;\n  \n  for(int i=vec.size()-1;i>=0;i--){\n    res += vec[i] * di;\n    di *= 10;\n  }\n\n  return res;\n}\n\nlli reverse(lli num, int begin, int end){\n  lli res = num;\n  lli powbe = pow10[begin], powen = pow10[end];\n\n  for(int i=0;i<(end-begin+1)/2;i++){\n    res += powbe * (num / powen % 10 - num / powbe % 10);\n    res += powen * (num / powbe % 10 - num / powen % 10);\n    powbe *= 10;\n    powen /= 10;\n  }\n  \n  return res;\n}\n\nint bfs(lli num, map<lli, int> mp[2], int mp_pos){\n  int res = INF;\n  queue<state> q;\n  state u, u2;\n\n  mp[mp_pos][num] = 0;\n\n  for(q.push(state(num, 0)); !q.empty();){\n    u = q.front();\n    q.pop();\n\n    if(mp_pos == 1 && mp[0].count(u.num)) res = min(res, mp[0][u.num] + u.cnt);\n    if(mp_pos == 0 && u.cnt >= 4 || u.cnt >= 5) continue;\n\n    for(int i=0;i<n-1;i++){\n      for(int j=i+1;j<n;j++){\n        u2 = state(reverse(u.num, i, j), u.cnt + 1);\n        if(!mp[mp_pos].count(u2.num)){\n          mp[mp_pos][u2.num] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n\n  return res;\n}\n\nint solve(){  \n  vector<int> w = v;\n  map<lli, int> mp[2];\n\n  sort(w.begin(), w.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(v[i] == w[j]) {\n        v[i] = j;\n        break;\n      }\n    }\n  }\n\n  w = v;\n  sort(w.begin(), w.end());\n\n  bfs(hash(w), mp, 0);\n  return bfs(hash(v), mp, 1);\n}\n\nint main(){\n  pow10[0] = 1;\n  for(int i=1;i<11;i++) pow10[i] = pow10[i-1] * 10;\n\n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAX = 11;\n\nint main(){\n  int n,A[MAX];\n\n  cin >> n;\n  for(int i = 0 ; i < n ; i++) cin >> A[i];\n\n  int cnt = 0;\n  for(int i = 0 ; i < n ; i++){\n    int MIN = 1<<27,num;\n    for(int j = i ; j < n ; j++){\n      if(A[j] <= MIN){\n\tMIN = A[j];\n\tnum = j;\n      }\n    }\n    if(A[i] != MIN){\n      int tmp = A[i];\n      A[i] = A[num];\n      A[num] = tmp;\n      cnt++;\n    } \n  }\n  cout << cnt << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint bfs(vector<int> v)\n{\n    map<vector<int>, int> D; D[v] = 1;\n    \n    vector<int> sorted = v; sort(sorted.begin(), sorted.end());\n    \n    queue<pair<vector<int>, int> que; que.push(make_pair(v, 1));\n    \n    while(!que.empty())\n    {\n        pair<vector<int>, int> p1 = que.front(); que.pop();\n        \n        for(int i = 0; i < v.size(); i++)\n        {\n            for(int j = i + 1; j < v.size(); j++)\n            {\n                vector<int> p2 = p1.first;\n                \n                swap(p2[i], p2[j]);\n                \n                if(D[p2] == 0)\n                {\n                    if(p2 == sorted)\n                    {\n                        return p1.first;\n                    }\n                    \n                    D[p2] = p1.second + 1;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main()\n{\n    int n; vector<int> a;\n    \n    cin >> n; a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    \n    cout << bfs(a) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる:もっとfirstとの距離が近い枝にぶつかるかも知れないから続行\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\null PermutationHash(vi perm){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tull hash = 0;\n    REP(i, (int)perm.size()-1) perm[i] = perm[i];\n    REP(i, (int)perm.size()-1){\n        hash += perm[i] * FACTOR[perm.size()-i-1];\n        for (int j=i+1; j < (int)perm.size()-1; j++)\n            if (perm[i] < perm[j]) perm[j]--;\n    }\n    return hash;\n}\n\nvi restorePermutation(ull u){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tvi res;\n\tRREP(i, n){\n\t\tint p = u/FACTOR[i];\n\t\tu%=FACTOR[i];\n\t\tres.push_back(p);\n\t}\n\tRREP(i, res.size())RREP(j, i) if(res[j] <= res[i]) res[i]++;\n\treturn res;\n}\n\nint memo[3628801];\nint rev[3628801];\nmain(){\n\twhile(cin >> n){\n\t\tmemset(rev, 63, sizeof(memo));\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tvi a(n);\n\t\tREP(i, n) a[i] = i;\n\t\tqueue< pair<int, ull> > pq;\n\t\tpq.emplace(0, 0);\n\t\trev[0] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.front().first;\n\t\t\tull u = pq.front().second;\n\t\t\tpq.pop();\n\t\t\tif(c > 3) break;\n\t\t\tvi a = restorePermutation(u);\n\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\tvi b(a);\n\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\tull u = PermutationHash(b);\n\t\t\t\tif(chmin(rev[u], c+1)) pq.emplace(c+1, u);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tmemset(memo, 63, sizeof(memo));\n\t\t\tvi a(n);\n\t\t\tREP(i, n) cin >> a[i],a[i]--;\n\t\t\tqueue< pair<int, ull> > pq;\n\t\t\tpq.emplace(0, PermutationHash(a));\n\t\t\tmemo[PermutationHash(a)] = 0;\n\t\t\tint ans = n-1;\n\t\t\twhile(!pq.empty()){\n\t\t\t\tint c = pq.front().first;\n\t\t\t\tull u = pq.front().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif(c > 3) break;\n\t\t\t\tans = min(ans, c + rev[u]);\n\t\t\t\tvi a = restorePermutation(u);\n\t\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\t\tvi b(a);\n\t\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\t\tull u = PermutationHash(b);\n\t\t\t\t\tif(chmin(memo[u], c+1)) pq.emplace(c+1, u);\n\t\t\t\t\tans = min(ans, c + 1 + rev[u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nvector<int> v;\nmap<vector<int> ,int> d1;\nmap<vector<int> ,int> d2;\nint N;\nvector<int> sorted;\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  queue<vector<int> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  while(q1.size()||q2.size()){\n    {\n      vector<int> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      if(now==sorted){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d2.count(nv)!=0&&d1.count(nv)==0){\n\t    cout<<ccost+1+d2[nv]<<endl;\n\t    return 0;\n\t  }\n\t  else if(d1.count(nv)==0){\n\t    d1[nv]=ccost+1;\n\t    q1.push(nv);\n\t  }\n\t}\n      }\n    }\n    {\n      vector<int> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      if(v==now){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d1.count(nv)!=0&&d2.count(nv)==0){\n\t    cout<<ccost+1+d1[nv]<<endl;\n\t    return 0;\n\t  }\n\t  else if(d2.count(nv)==0){\n\t    d2[nv]=ccost+1;\n\t    q2.push(nv);\n\t  }\n\t}\n      }\n    }\n    \n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint n;\n\tchar d[10];\n\tS() {}\n\tS(int n) : n(n) {}\n\tll hash() {\n\t\tll r = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tr *= 16;\n\t\t\tr += d[i];\n\t\t}\n\t\treturn r;\n\t}\n};\n\ntypedef pair<S, int> P;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tS s(n), r(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s.d[i];\n\t\ts.d[i]--;\n\t\tr.d[i] = i;\n\t}\n\tll rh = r.hash();\n\tint dist = 1, rdist = 1;\n\tqueue<P> q;\n\tmap<ll, int> u;\n\tq.push(P(s, 1));\n\twhile (!q.empty()) {\n\t\tS s(0); int d;\n\t\ttie(s, d) = q.front(); q.pop();\n\t\tif (d == 6) break;\n\n\t\tll sh = s.hash();\n\t\tif (u[sh]) continue;\n\t\tu[sh] = d;\n\t\tdist = d;\n\t\tif (sh == rh) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+2; j <= n; j++) {\n\t\t\t\tS ss = s;\n\t\t\t\treverse(ss.d + i, ss.d + j);\n\t\t\t\tq.push(P(ss, d+1));\n\t\t\t}\n\t\t}\n\t}\n\tmap<ll, int> ru;\n\tq = queue<P>();\n\tq.push(P(r, 1));\n\twhile (!q.empty()) {\n\t\tS s(0); int d;\n\t\ttie(s, d) = q.front(); q.pop();\n\t\tll sh = s.hash();\n\t\tif (d == 6) {\n\t\t\trdist = 6;\n\t\t\tbreak;\n\t\t}\n\t\tif (ru[sh]) continue;\n\t\tru[sh] = d;\n\t\trdist = d;\n\t\tif (u[sh]) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+2; j <= n; j++) {\n\t\t\t\tS ss = s;\n\t\t\t\treverse(ss.d + i, ss.d + j);\n\t\t\t\tq.push(P(ss, d+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist+rdist-2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nmap<vi,int> dist,dist2;\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\tvi in(n,0);\n\trep(i,n) in[i]=i+1;\n\tdist[in]=0;\n\tqueue<vi> q;\n\tq.push(in);\n\n\twhile(!q.empty()){\n\t\tvi ci=q.front();q.pop();\n\t\trep(i,n)rep(j,n){\n\t\t\tif(j+1-i<=1) continue;\n\t\t\tvi ni=ci;\n\t\t\treverse(ni.begin()+i,ni.begin()+j+1);\n\t\t\tif(dist.find(ni)==dist.end()){\n\t\t\t\tif(dist[ci]>3) continue;\n\t\t\t\tdist[ni]=dist[ci]+1;\n\t\t\t\tq.push(ni);\n\t\t\t}\n\t\t}\n\t}\n\n\tvi in2(n,0);\n\trep(i,n) cin >> in2[i];\n\tdist2[in2]=0;\n\tq.push(in2);\n\n\twhile(!q.empty()){\n\t\tvi ci=q.front();q.pop();\n\t\trep(i,n)rep(j,n){\n\t\t\tif(j+1-i<=1) continue;\n\t\t\tvi ni=ci;\n\t\t\treverse(ni.begin()+i,ni.begin()+j+1);\n\t\t\tif(dist2.find(ni)==dist2.end()){\n\t\t\t\tif(dist2[ci]>3) continue;\n\t\t\t\tdist2[ni]=dist2[ci]+1;\n\t\t\t\tq.push(ni);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=n-1;\n\tfor(auto &i:dist){\n\t\tif(dist2.find(i.first)==dist2.end()) continue;\n\t\tans=min(ans,dist[i.first]+dist2[i.first]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint N, A[11];\n\nvoid solve() {\n\tint ans = 0;\n\t\n\tfor_rev(i,N,1) {\n\t\tint j = i - 1;\n\t\twhile (A[j] != i) --j;\n\t\tif (j != i - 1) {\n\t\t\treverse(A + j, A + i);\n\t\t\t++ans;\n\t\t}\n\t\t\n\t\t//for_(j,0,N) cout << A[j] << \" \";\n\t\t//cout << endl;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> A[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint bfs(vector<int> v)\n{\n\tmap<vector<int>, int> D; D[v] = 1;\n\n\tvector<int> sorted = v; sort(sorted.begin(), sorted.end());\n\n\tqueue<pair<vector<int>, int> > que; que.push(make_pair(v, 1));\n\n\tif (v == sorted) { return 0; }\n\n\twhile (!que.empty())\n\t{\n\t\tpair<vector<int>, int> p1 = que.front(); que.pop();\n\n\t\tfor (int i = 0; i < v.size(); i++)\n\t\t{\n\t\t\tfor (int j = i + 1; j < v.size(); j++)\n\t\t\t{\n\t\t\t\tvector<int> p2 = p1.first;\n\n\t\t\t\tswap(p2[i], p2[j]);\n\n\t\t\t\tif (D[p2] == 0)\n\t\t\t\t{\n\t\t\t\t\tif (p2 == sorted)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn p1.second;\n\t\t\t\t\t}\n\n\t\t\t\t\tD[p2] = p1.second + 1;\n\n\t\t\t\t\tque.push(make_pair(p2, p1.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tint n; vector<int> a;\n\n\tcin >> n; a = vector<int>(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\n\tcout << bfs(a) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\n\t\t\t\tfor(int p = 0; p < i-1; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = k+1; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < k-i; p++)work[i+p] = calc_array[k-p];\n\n\t\t\t\t/*for(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n*/\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < i-1; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = k+1; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < k-i; p++)work[i+p] = calc_array[k-p];\n\n\t\t\t\t/*for(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t\t//★ある状態から、firstへの距離が一気に2以上縮まることはない。よって、自分が1以上増えることにより、打ち切り★\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\n\nmap<vi, int> bfs(vi v)\n{\n\tmap<vi, int> mp;\n\tqueue<vi> que;\n\tque.push(v); mp[v] = 0;\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tque.pop();\n\t\tint t = mp[tmp];\n\t\tif (t >= n / 2) continue;\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + j, nx.begin() + i + 1);\n\t\t\tif (mp.find(nx) != mp.end()) continue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp[nx] = t + 1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn mp;\n}\n\nint main()\n{\n\tcin >> n;\n\tvi a(n), b;\n\tREP(i, n) cin >> a[i];\n\tb = a;\n\tsort(ALL(b));\n\tauto mp1 = bfs(a);\n\tauto mp2 = bfs(b);\n\tint ans = n - 1;\n\tfor (auto it = mp1.begin(); it != mp1.end(); it++)\n\t{\n\t\tif (mp2.find(it->first) != mp2.end()) chmin(ans, it->second + mp2[it->first]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<cstdio>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  vector<int> A;\n  int cost;\n  P(vector<int> A2=vector<int>(),int cost=inf):cost(cost)\n  {\n    A = A2;\n  }\n\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n\n};\n\nint N;\nmap<vector<int>,int> mincost;\nmap<vector<int>,int> rmincost;\nvector<int> initial;\n\nvoid computeR(int step)\n{\n  priority_queue<P> Q;\n  {\n    initial.resize(N);\n    rep(i,N)initial[i] = i+1;\n    Q.push(P(initial,0));\n    rmincost[initial] = 0;\n  }\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost > step)continue;\n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(rmincost.find(next) == rmincost.end())\n\t\t{\n\t\t  rmincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\nvoid compute(vector<int> &vec)\n{\n  mincost[vec] = 0;\n  priority_queue<P> Q;\n  Q.push(P(vec,0));\n\n  int ans = inf;\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      if(rmincost.find(p.A) != rmincost.end())\n\t{\n\t  ans = min(ans,p.cost + rmincost[p.A]);\n\t  continue;\n\t}\n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(mincost.find(next) == mincost.end())\n\t\t{\n\t\t  mincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n    }\n  cout << ans << endl;\n  assert(ans != inf);\n}\n\nint main()\n{\n\n  scanf(\"%d\",&N);\n  \n  computeR((int)(N/2));\n  //cout << \"---------\" << endl;\n  vector<int> vec(N);\n  rep(i,N)cin >> vec[i];\n\n  compute(vec);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> A(N); rep(i,N) cin >> A[i];\n\tll tmp = 0, gl = 0;\n\trep(i,N) {\n\t\ttmp *= 10;\n\t\ttmp += A[i]-1;\n\t\tgl *= 10;\n\t\tgl += i;\n\t}\n\tvector<pli> candidate[2];\n\trep(a,2) {\n\t\tqueue<pli> q;\n\t\tq.push(pli(!a ? tmp : gl, 0));\n\t\tunordered_set<ll> used;\n\t\tused.insert(q.front().first);\n\t\twhile(q.size()) {\n\t\t\tcandidate[a].push_back(q.front());\n\t\t\tll t = q.front().first;\n\t\t\tll turn = q.front().second; q.pop();\n\t\t\tif(turn > 4) break;\n\t\t\tvector<int> v(N);\n\t\t\trrep(i,N) {\n\t\t\t\tv[i] = t % 10;\n\t\t\t\tt /= 10;\n\t\t\t}\n\t\t\trep(i,N) {\n\t\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\t\tvector<int> vv = v;\n\t\t\t\t\tll nx = 0;\n\t\t\t\t\treverse(vv.begin()+i, vv.begin()+j+1);\n\t\t\t\t\trep(i,N) {\n\t\t\t\t\t\tnx *= 10;\n\t\t\t\t\t\tnx += vv[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(used.find(nx) == used.end()) {\n\t\t\t\t\t\tused.insert(nx);\n\t\t\t\t\t\tq.push(pli(nx,turn+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(candidate[a].begin(), candidate[a].end());\n\t}\n\tint res = 9;\n\trep(i,candidate[0].size()) {\n\t\tint indx;\n\t\tindx = lower_bound(candidate[1].begin(), candidate[1].end(), candidate[0][i])\n\t\t\t- candidate[1].begin();\n\t\tif(candidate[0][i].first == candidate[1][indx].first) {\n\t\t\tres = min(res, candidate[0][i].second+candidate[1][indx].second);\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=3700000;\nconst int INF=123456789;\n\nint f[11];\nint dp1[N], dp2[N];\n\nmap<vector<int>,int> M;\ninline int get_idx(const vector<int> &a)\n{\n    if(M.count(a)) return M[a];\n\n    int n = a.size();\n    int ret=0;\n\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int ct=0;\n        rep(j,a[i])if(!use[j]) ++ct;\n\n        ret += ct*f[n-1-i];\n\n        use[a[i]]=true;\n    }\n    return M[a]=ret;\n}\n\ninline vector<int> get_vec(int n, int idx)\n{\n    vector<int> ret(n);\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int s = idx/f[n-1-i];\n        int j=0,ct=0;\n        while(1)\n        {\n            if(!use[j])\n            {\n                ++ct;\n                if(ct==s+1) break;\n            }\n            ++j;\n        }\n\n        use[j]=true;\n        ret[i]=j;\n        idx -= s*f[n-1-i];\n    }\n    return ret;\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<=10; ++i) f[i] = f[i-1]*i;\n\n    int n;\n    cin >>n;\n    vector<int> a(n);\n    rep(i,n)\n    {\n        cin >>a[i];\n        --a[i];\n    }\n\n    int g = get_idx(a);\n    queue<int> que;\n\n    fill(dp1,dp1+N,INF);\n    dp1[0]=0;\n    que.push(0);\n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n\n        vector<int> x = get_vec(n,now);\n        // printf(\" now %d\\n\", now);\n        rep(i,n)for(int j=i+1; j<=n; ++j)\n        {\n            reverse(x.begin()+i, x.begin()+j);\n\n            int nx = get_idx(x);\n            // printf(\"  nx %d\\n\", nx);\n            if(dp1[nx]>dp1[now]+1)\n            {\n                dp1[nx] = dp1[now]+1;\n                if(dp1[nx]<4) que.push(nx);\n            }\n\n            reverse(x.begin()+i, x.begin()+j);\n        }\n    }\n\n    fill(dp2,dp2+N,INF);\n    dp2[g]=0;\n    que.push(g);\n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n\n        vector<int> x = get_vec(n,now);\n        rep(i,n)for(int j=i+1; j<=n; ++j)\n        {\n            reverse(x.begin()+i, x.begin()+j);\n\n            int nx = get_idx(x);\n            if(dp2[nx]>dp2[now]+1)\n            {\n                dp2[nx] = dp2[now]+1;\n                if(dp2[nx]<4) que.push(nx);\n            }\n\n            reverse(x.begin()+i, x.begin()+j);\n        }\n    }\n\n    int ans=9;\n    rep(i,N)if(dp1[i]<INF && dp2[i]<INF) ans=min(ans,dp1[i]+dp2[i]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n; vector<int> a;\nint main() {\n\tcin >> n; a.resize(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n\tmap<vector<int>, int> dist; dist[a] = 1;\n\tqueue<vector<int> > que1; que1.push(a);\n\twhile (!que1.empty()) {\n\t\tvector<int> v1 = que1.front(); que1.pop();\n\t\tint dist1 = dist[v1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tif (!dist[v1]) {\n\t\t\t\t\tdist[v1] = dist1 + 1;\n\t\t\t\t\tif (dist1 < (n + 1) / 2) que1.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 999999999;\n\tvector<int> s(n);\n\tfor (int i = 0; i < n; i++) s[i] = i;\n\tmap<vector<int>, int> dist2; dist2[s] = 1;\n\tqueue<vector<int> > que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tvector<int> v1 = que2.front(); que2.pop();\n\t\tint dist1 = dist2[v1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tif (!dist2[v1]) {\n\t\t\t\t\tdist2[v1] = dist1 + 1;\n\t\t\t\t\tint dist3 = dist[v1];\n\t\t\t\t\tif (dist3) ret = min(ret, dist1 + dist3 - 1);\n\t\t\t\t\tif (dist1 < n / 2) que2.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (s != a ? ret : 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nll data[4000000];\nint dist[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tdata[j]=d;\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs(int s){\n\tqueue<int> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tdist[s]=0;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tif(v==0)return dist[v];\n\t\tll nv=data[v];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=data[v];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tif(dist[ma[uv]]==-1){\n\t\t\t\t\tdist[ma[uv]]=dist[v]+1;\n\t\t\t\t\tque.push(ma[uv]);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tprintf(\"%d\\n\",bfs(ma[s]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nvector<int> v;\nmap<vector<int> ,int> d1;\nmap<vector<int> ,int> d2;\nint N;\nvector<int> sorted;\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  if(v==sorted){\n    cout<<0<<endl;\n    return 0;\n  }\n  queue<vector<int> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  while(q1.size()||q2.size()){\n    {\n      vector<int> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d2.count(nv)!=0&&d1.count(nv)==0){\n\t    cout<<ccost+1+d2[nv]<<endl;\n\t    return 0;\n\t  }\n\t  else if(d1.count(nv)==0){\n\t    d1[nv]=ccost+1;\n\t    if(sorted==nv){\n\t      cout<<ccost+1<<endl;\n\t      return 0;\n\t    }\n\t    q1.push(nv);\n\t  }\n\t}\n      }\n    }\n    {\n      vector<int> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d1.count(nv)!=0&&d2.count(nv)==0){\n\t    cout<<ccost+1+d1[nv]<<endl;\n\t    return 0;\n\t  }\n\t  else if(d2.count(nv)==0){\n\t    d2[nv]=ccost+1;\n\t    if(v==nv){\n\t      cout<<ccost+1<<endl;\n\t      return 0;\n\t    }\n\t    q2.push(nv);\n\t  }\n\t}\n      }\n    }\n    \n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> a(n);\n    vector<int> b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) b[i] = i + 1;\n\n    map<vector<int>, int> mb;\n    queue<pair<vector<int>, int> > qb;\n    \n    mb[b] = -1;\n    qb.push({b, 0});\n    \n\n    while(1){\n\n        vector<int> now(n);\n        now = qb.front().first;\n        int cost = qb.front().second;\n        qb.pop();\n        \n        if(cost == 4) break;\n\n        bool ok = true;\n        for(int i = 0; i < n; i++){\n            if(a[i] != now[i]){\n                ok = false;\n                break;\n            }\n        }\n\n        if(ok){\n            cout << cost << endl;\n            return 0;\n        }\n\n        for(int i = 0; i < n - 1; i++){\n            for(int j = i + 1; j < n; j++){\n                vector<int> next(n);\n                next = now;\n\n                for(int k = i; k <= j; k++){\n                    next[k] = now[j - k + i];\n                }\n\n\n                if(mb.find(next) == mb.end()){\n                    mb[next] = cost + 1;\n                    qb.push({next, cost + 1});\n                }\n            }\n        }\n    }\n\n\n    //cout << \"junnbihadeketa\" << endl;\n    map<vector<int>, int> ma;\n    queue<pair<vector<int>, int> > qa;\n    ma[a] = -1;\n    qa.push({a, 0});\n\n    while(1){\n\n        vector<int> now(n);\n        now = qa.front().first;\n        int cost = qa.front().second;\n        qa.pop();\n\n        if(cost == 4) break;\n\n        if(mb.find(now) != mb.end()){\n            cout << cost + mb[now] << endl;\n            return 0;\n        }\n\n        for(int i = 0; i < n - 1; i++){\n            for(int j = i + 1; j < n; j++){\n                vector<int> next(n);\n                next = now;\n                for(int k = i; k <= j; k++){\n                    next[k] = now[j + i - k];\n                }\n\n                if(ma.find(next) == ma.end()){\n                    ma[next] == cost + 1;\n                    qa.push({next, cost + 1});\n                }\n            }\n        }\n    }\n\n    cout << 9 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef pair<vi, int> P;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi a(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\tvi b = a;\n\tsort(ALL(b));\n\tmap<vi, int> mp1, mp2;\n\tqueue<P> que;\n\tque.push(P(a, 0));\n\tmp1[a] = 0;\n\twhile (que.size())\n\t{\n\t\tvi t = que.front().first;\n\t\tint cnt = que.front().second;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) \n\t\t\t{\n\t\t\t\tmp1[nx] = cnt + 1;\n\t\t\t\tif(cnt<4) que.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = n - 1;\n\tqueue<P> que2;\n\tque2.push(P(b, 0));\n\twhile (que2.size())\n\t{\n\t\tvi t = que2.front().first;\n\t\tint cnt = que2.front().second;\n\t\tque2.pop();\n\t\tif (cnt == 5) break;\n\t\tif (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j);\n\t\t\tif (mp2.find(nx) == mp2.end())\n\t\t\t{\n\t\t\t\tmp2[nx] = cnt + 1;\n\t\t\t\tif(cnt<4)que2.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  //return atoi(str.c_str());\n  return res;\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          if(data.find(v.first) != data.end()) return data[v.first] + v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long swp(long long a, int i, int j) {\n    long long t = ((a >> (i << 2)) ^ (a >> (j << 2))) & 15;\n    return a ^ (t << (i << 2)) ^ (t << (j << 2));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    long long a = 0, m = 0;\n    for (int i = 0; i < n; ++i) {\n        int b;\n        cin >> b;\n        a = (a << 4) + b;\n        m = (m << 4) + i + 1;\n    }\n    unordered_map<long long, int> mp;\n    mp[m] = 0;\n    queue<long long> q;\n    q.push(m);\n\n    int lim = 4;\n\n    while (!q.empty()) {\n        long long p = q.front();\n        q.pop();\n        if (mp[p] > lim) break;\n\n        for (int i = 0; i < n; ++i) {\n            long long pa = p;\n            for (int j = 1; i + j < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j);\n                if (!mp.count(pa)) {\n                    mp[pa] = mp[p] + 1;\n                    q.push(pa);\n                }\n            }\n            pa = p;\n            for (int j = 0; i + j + 1 < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j + 1);\n                if (!mp.count(pa)) {\n                    mp[pa] = mp[p] + 1;\n                    q.push(pa);\n                }\n            }\n        }\n    }\n    if (mp.count(a)) {\n        cout << mp[a] << \"\\n\";\n        return 0;\n    }\n    unordered_map<long long, int> mp2;\n    mp2[a] = 0;\n    queue<long long> q2;\n    q2.push(a);\n    while (!q2.empty()) {\n        long long p = q2.front();\n        q2.pop();\n\n        for (int i = 0; i < n; ++i) {\n            long long pa = p;\n            for (int j = 1; i + j < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j);\n                if (!mp2.count(pa)) {\n                    mp2[pa] = mp2[p] + 1;\n                    if (mp.count(pa)) {\n                        cout << (mp[pa] + mp2[pa]) << \"\\n\";\n                        return 0;\n                    }\n                    q2.push(pa);\n                }\n            }\n            pa = p;\n            for (int j = 0; i + j + 1 < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j + 1);\n                if (!mp2.count(pa)) {\n                    mp2[pa] = mp2[p] + 1;\n                    if (mp.count(pa)) {\n                        cout << (mp[pa] + mp2[pa]) << \"\\n\";\n                        return 0;\n                    }\n                    q2.push(pa);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<vector<char> >,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint n;\nint num[11], tmp[11];\nunordered_map<ll, int> m;\nunordered_map<ll, int> mm;\nqueue<ll> que;\n\nint main(){\n    cin >> n;\n    ll st = 0;\n    rep(i,n){\n        int x;\n        cin >> x;\n        if(x == 10){\n            st = st*100+x;\n        } else{\n            st = st*10+x;\n        }\n    }\n    que.push(st);\n    m[st] = 0;\n    while(!que.empty()){\n        ll p = que.front();\n        ll q = p;\n        que.pop();\n        int now = 0;\n        while(p){\n            if(p%10 == 0){\n                num[n-now] = 10;\n                p /= 100;\n            } else{\n                num[n-now] = p%10;\n                p /= 10;\n            }\n            now++;\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++) tmp[j] = num[j];\n            for(int j = 1; j <= n; j++){\n                if(i-j <= 0 || i+j > n) break;\n                swap(tmp[i-j],tmp[i+j]);\n                ll add = 0;\n                for(int k = 1; k <= n; k++){\n                    if(tmp[k] == 10){\n                        add = add*100+10;\n                    } else{\n                        add = add*10+tmp[k];\n                    }\n                }\n                if(m.count(add)) continue;\n                m[add] = m[q]+1;\n                if(m[add] < 5) que.push(add);\n            }\n        }\n        for(int i = 1; i < n; i++){\n            int ii = i+1;\n            for(int j = 1; j <= n; j++) tmp[j] = num[j];\n            for(int j = 0; j <= n; j++){\n                if(i-j <= 0 || ii+j > n) break;\n                swap(tmp[i-j],tmp[ii+j]);\n                ll add = 0;\n                for(int k = 1; k <= n; k++){\n                    if(tmp[k] == 10){\n                        add = add*100+10;\n                    } else{\n                        add = add*10+tmp[k];\n                    }\n                }\n                if(m.count(add)) continue;\n                m[add] = m[q]+1;\n                if(m[add] < 5) que.push(add);\n            }\n        }\n    }\n    while(!que.empty()) que.pop();\n    ll en = 0;\n    for(int i = 1; i <= n; i++){\n        if(i == 10){\n            en = en*100+i;\n        } else{\n            en = en*10+i;\n        }\n    }\n    que.push(en);\n    if(m.count(en)){\n        cout << m[en] << endl;\n        return 0;\n    }\n    mm[en] = 0;\n    while(!que.empty()){\n        ll p = que.front();\n        ll q = p;\n        if(m.count(q)){\n            cout << m[q]+mm[q] << endl;\n            return 0;\n        }\n        que.pop();\n        int now = 0;\n        while(p){\n            if(p%10 == 0){\n                num[n-now] = 10;\n                p /= 100;\n            } else{\n                num[n-now] = p%10;\n                p /= 10;\n            }\n            now++;\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= n; j++) tmp[j] = num[j];\n            for(int j = 1; j <= n; j++){\n                if(i-j <= 0 || i+j > n) break;\n                swap(tmp[i-j],tmp[i+j]);\n                ll add = 0;\n                for(int k = 1; k <= n; k++){\n                    if(tmp[k] == 10){\n                        add = add*100+10;\n                    } else{\n                        add = add*10+tmp[k];\n                    }\n                }\n                if(mm.count(add)) continue;\n                mm[add] = mm[q]+1;\n                if(mm[add] < 5) que.push(add);\n            }\n        }\n        for(int i = 1; i < n; i++){\n            int ii = i+1;\n            for(int j = 1; j <= n; j++) tmp[j] = num[j];\n            for(int j = 0; j <= n; j++){\n                if(i-j <= 0 || ii+j > n) break;\n                swap(tmp[i-j],tmp[ii+j]);\n                ll add = 0;\n                for(int k = 1; k <= n; k++){\n                    if(tmp[k] == 10){\n                        add = add*100+10;\n                    } else{\n                        add = add*10+tmp[k];\n                    }\n                }\n                if(mm.count(add)) continue;\n                mm[add] = mm[q]+1;\n                if(mm[add] < 5) que.push(add);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\nint main() {\n\tint N; cin >> N;\n\tstring starts;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\ta--;\n\t\tstarts.push_back(a + '0');\n\t}\n\tstring goals; \n\tfor (int i = 0; i < N; ++i) {\n\t\tgoals.push_back(i + '0');\n\t}\n\tvector < vector<string>>fromstarts(5);\n\tfromstarts[0].emplace_back(starts);\n\tvector< vector<string>>fromgoals(5);\n\tfromgoals[0].emplace_back(goals);\n\tfor (int i = 0; i < 4; ++i) {\n\t\tvector<string>aset;\n\t\tfor (auto v : fromstarts[i]) {\n\t\t\tfor (int l = 0; l < N; ++l) {\n\t\t\t\tfor (int r = l+2; r <= N; ++r) {\n\t\t\t\t\tstring rev = v.substr(l, r - l);\n\t\t\t\t\treverse(rev.begin(), rev.end());\n\t\t\t\t\tstring next = v.substr(0, l) + rev + (v.substr(r, N - r));\n\t\t\t\t\taset.emplace_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(aset.begin(), aset.end());\n\t\taset.erase(unique(aset.begin(), aset.end()), aset.end());\n\t\tfromstarts[i + 1] = aset;\n\t}\n\tfor (int i = 0; i < 4; ++i) {\n\t\tvector<string>aset;\n\t\tfor (auto v : fromgoals[i]) {\n\t\t\tfor (int l = 0; l < N; ++l) {\n\t\t\t\tfor (int r = l + 2; r <= N; ++r) {\n\t\t\t\t\tstring rev = v.substr(l, r - l);\n\t\t\t\t\treverse(rev.begin(), rev.end());\n\t\t\t\t\tstring next = v.substr(0, l) + rev + (v.substr(r, N - r));\n\t\t\t\t\taset.emplace_back(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(aset.begin(), aset.end());\n\t\taset.erase(unique(aset.begin(), aset.end()), aset.end());\n\t\tfromgoals[i + 1] = aset;\n\t}\n\tint ans = 9;\n\tfor (int s = 0; s < 4; ++s) {\n\t\tfor (int t = 0; t < 4; ++t) {\n\t\t\tvector<string>sames;\n\t\t\tset_intersection(fromstarts[s].begin(), fromstarts[s].end(), fromgoals[t].begin(), fromgoals[t].end(), inserter(sames, sames.end()));\n\t\t\tif (!sames.empty()) {\n\t\t\t\tans = min(ans, s+t);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nll encode(const vi& a)\n{\n\tll x=0;\n\trep(i,a.size()) x|=ll(a[i])<<i*4;\n\treturn x;\n}\nvi decode(ll x)\n{\n\tvi a;\n\tfor(;x;x>>=4) a.push_back(x&15);\n\treturn a;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n); iota(all(b),1);\n\t\tqueue<pair<ll,int>> q[2];\n\t\tunordered_map<ll,int> m[2];\n\t\tq[0].emplace(encode(a),0);\n\t\tq[1].emplace(encode(b),0);\n\t\t\n\t\tint res=INF;\n\t\tfor(int k=0;;k^=1){\n\t\t\tqueue<pair<ll,int>> tmp;\n\t\t\twhile(q[k].size()){\n\t\t\t\tll x; int t; tie(x,t)=q[k].front(); q[k].pop();\n\t\t\t\tif(m[k].count(x)) continue;\n\t\t\t\tm[k].emplace(x,t);\n\t\t\t\tif(m[k^1].count(x)){\n\t\t\t\t\tres=t+m[k^1][x];\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tvi a=decode(x);\n\t\t\t\trep(i,n) repi(j,i,n){\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t\ttmp.emplace(encode(a),t+1);\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q[k],tmp);\n\t\t}\n\t\tend:\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=3700000;\nconst int INF=123456789;\n\nint f[11];\nint dp1[N], dp2[N];\n\ninline int get_idx(const vector<int> &a)\n{\n    int n = a.size();\n    int ret=0;\n\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int ct=0;\n        rep(j,a[i])if(!use[j]) ++ct;\n\n        ret += ct*f[n-1-i];\n\n        use[a[i]]=true;\n    }\n    return ret;\n}\n\ninline vector<int> get_vec(int n, int idx)\n{\n    vector<int> ret(n);\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int s = idx/f[n-1-i];\n        int j=0,ct=0;\n        while(1)\n        {\n            if(!use[j])\n            {\n                ++ct;\n                if(ct==s+1) break;\n            }\n            ++j;\n        }\n\n        use[j]=true;\n        ret[i]=j;\n        idx -= s*f[n-1-i];\n    }\n    return ret;\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<=10; ++i) f[i] = f[i-1]*i;\n\n    int n;\n    cin >>n;\n    vector<int> a(n);\n    rep(i,n)\n    {\n        cin >>a[i];\n        --a[i];\n    }\n\n    int g = get_idx(a);\n    queue<int> que;\n\n    fill(dp1,dp1+N,INF);\n    dp1[0]=0;\n    que.push(0);\n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n\n        vector<int> x = get_vec(n,now);\n        // printf(\" now %d\\n\", now);\n        rep(i,n)for(int j=i+1; j<=n; ++j)\n        {\n            reverse(x.begin()+i, x.begin()+j);\n\n            int nx = get_idx(x);\n            // printf(\"  nx %d\\n\", nx);\n            if(dp1[nx]>dp1[now]+1)\n            {\n                dp1[nx] = dp1[now]+1;\n                if(dp1[nx]<4) que.push(nx);\n            }\n\n            reverse(x.begin()+i, x.begin()+j);\n        }\n    }\n\n    fill(dp2,dp2+N,INF);\n    dp2[g]=0;\n    que.push(g);\n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n\n        vector<int> x = get_vec(n,now);\n        rep(i,n)for(int j=i+1; j<=n; ++j)\n        {\n            reverse(x.begin()+i, x.begin()+j);\n\n            int nx = get_idx(x);\n            if(dp2[nx]>dp2[now]+1)\n            {\n                dp2[nx] = dp2[now]+1;\n                if(dp2[nx]<4) que.push(nx);\n            }\n\n            reverse(x.begin()+i, x.begin()+j);\n        }\n    }\n\n    int ans=9;\n    rep(i,N)if(dp1[i]<INF && dp2[i]<INF) ans=min(ans,dp1[i]+dp2[i]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\t//for(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < i-1; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = k+1; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\t//for(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < i-1; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = k+1; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t\t//★ある状態から、firstへの距離が一気に2以上縮まることはない。よって、自分が1以上増えることにより、打ち切り★\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N;\n\tcin >> N;\n\tvi a(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> a[i]; --a[i];\n\t}\n\tvi b = a;\n\tsort(b.begin(), b.end());\n\tif (a == b) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tqueue<vi> q[2];\n\tmap<vi, int> d[2];\n\tq[0].push(a);\n\td[0][a] = 0;\n\tq[1].push(b);\n\td[1][b] = 0;\n\twhile (!q[0].empty() && !q[1].empty()) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tauto v = q[i].front(); q[i].pop();\n\t\t\tfor (int x = 0; x < N; x++) {\n\t\t\t\tfor (int y = x + 2; y <= N; y++) {\n\t\t\t\t\tauto tmp = v;\n\t\t\t\t\treverse(tmp.begin() + x, tmp.begin() + y);\n\t\t\t\t\tif (d[i].count(tmp) == 0) {\n\t\t\t\t\t\tq[i].push(tmp);\n\t\t\t\t\t\td[i][tmp] = d[i][v] + 1;\n\t\t\t\t\t\tif (d[!i].count(tmp)) {\n\t\t\t\t\t\t\tcout << d[0][tmp] + d[1][tmp] << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans=9;\nint a[10];\n\nvoid dfs(int depth){\n  bool flg=true;\n  for(int i=0;i<n;i++)\n    if(a[i]!=i)flg=false;\n\n  if(flg)ans=min(ans,depth);\n\n  if(depth+1>=ans)return;\n\n  for(int i=0;i<n;i++){\n    if(i==a[i])continue;\n    int j;\n    for(j=i;j<n;j++)if(a[j]==i)break;\n    reverse(a+i,a+j+1);\n    dfs(depth+1);\n    reverse(a+i,a+j+1);\n    break;\n  }\n\n  for(int i=n-1;i>=0;i--){\n    if(i==a[i])continue;\n    int j;\n    for(j=i;j>=0;j--)if(a[j]==i)break;\n    reverse(a+j,a+i+1);\n    dfs(depth+1);\n    reverse(a+j,a+i+1);\n  }  \n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>a[i],a[i]--;\n  dfs(0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nstruct S {\n\tvi v;\n\tint cnt, astar;\n\tbool operator >(const S &a) const {\n\t\treturn astar > a.astar;\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\t//while(cin >> n) {\n\t\tS s;\n\t\ts.v.resize(n);\n\t\tREP(i, n) cin >> s.v[i];\n\t\ts.cnt = s.astar = 0;\n\n\t\tint chk = 0;\n\t\tREP(i, n) {\n\t\t\tchk += (i+1 != s.v[i]);\n\t\t\tif(!chk) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\t//continue;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tset<vi> memo;\n\t\tpriority_queue<S, vector<S>, greater<S> > pq;\n\t\tpq.push(s);\n\n\t\tbool flg = false;\n\t\twhile(!pq.empty()) {\n\t\t\ts = pq.top(); pq.pop();\n\n\t\t\tREP(i, n) {\n\t\t\t\tFOR(j, i, n) {\n\t\t\t\t\tvi _v = s.v;\n\t\t\t\t\tswap(_v[i], _v[j]);\n\n\t\t\t\t\tif(!memo.count(_v)) {\n\t\t\t\t\t\tint astar = 0;\n\t\t\t\t\t\tREP(i, n)\n\t\t\t\t\t\t\tastar += (_v[i] != i+1);\n\t\t\t\t\t\tpq.push(S{_v, s.cnt+1, astar});\n\t\t\t\t\t\tmemo.insert(_v);\n\t\t\t\t\t\tif(!astar) flg = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) break;\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\tcout << s.cnt+1 << endl;\n\t//}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint a[10];\n\nint encode(int x[10], int n) {\n  int res = 0;\n  REP(i,n-1) {\n    res = 10 * res + x[i];\n  }\n  return res;\n}\n\nvoid decode(int x[10], int n, int code) {\n  int bit = 0;\n  for (int i=n-2; i>=0; --i) {\n    x[i] = code%10;\n    bit |= 1<<x[i];\n    code /= 10;\n  }\n  REP(i,n) if (!(bit>>i&1)) x[n-1] = i;\n}\n\nint now[10];\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i,n) {\n    cin >> a[i];\n    --a[i];\n  }\n  queue<int> Q;\n  int start = encode(a,n);\n  Q.push(start);\n  map<int, int> mp;\n  mp[start] = 0;\n  while(!Q.empty()) {\n    int p = Q.front(); Q.pop();\n    decode(now, n, p);\n    int d = mp[p];\n    REP(i,n) {\n      REP(j,i) {\n        reverse(now+j, now+i+1);\n        int next = encode(now,n);\n        if (mp.count(next) == 0) {\n          mp[next] = d+1;\n          if (d<4) {\n            Q.push(next);\n          }\n        }\n        reverse(now+j, now+i+1);        \n      }\n    }\n  }\n  REP(i,n) now[i]=i;\n  start = encode(now,n);\n  Q.push(start);\n  map<int,int> mp2;\n  mp2[start] = 0;\n  int ans = INF;\n  \n  while(!Q.empty()) {\n    int p = Q.front(); Q.pop();\n    decode(now, n, p);\n    int d = mp2[p];\n\n    if (mp.count(p)) {\n      ans = min(ans, mp[p] + mp2[p]);\n    }\n    if (d == 4) continue;\n    REP(i,n) {\n      REP(j,i) {\n        reverse(now+j, now+i+1);\n        int next = encode(now,n);\n        if (mp2.count(next) == 0) {\n          mp2[next] = d+1;\n          Q.push(next);\n        }\n        reverse(now+j, now+i+1);        \n      }\n    }\n  }\n  if (ans == INF) {\n    cout << 9 << endl;\n  } else {\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, vector<int> > P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nvector<int> a;\nmap<vector<int> ,int> d1,d2;\n\nint main(){\n  cin>>n;\n  rep(i,n){\n    int b;\n    cin>>b;\n    a.push_back(b);\n  }\n  d1[a]=0;\n  queue<vector<int> > que;\n  que.push(a);\n  while(que.size()){\n    vector<int> crt=que.front();\n    que.pop();\n    if(d1[crt]>=(n/2)-1)continue;\n    rep(i,n)repl(j,i+1,n){\n      vector<int> nxt=crt;\n      reverse(nxt.begin()+i,nxt.begin()+j+1);\n      if(d1.find(nxt)!=d1.end())continue;\n      d1[nxt]=d1[crt]+1;\n      que.push(nxt);\n    }\n  }\n\n  vector<int> p;\n  rep(i,n)p.push_back(i+1);\n  que.push(p);\n  d2[p]=0;\n  while(que.size()){\n    vector<int> crt=que.front();\n    que.pop();\n    if(d1.find(crt)!=d1.end()){\n      cout<<d1[crt]+d2[crt]<<endl;\n      return 0;\n    }\n    rep(i,n)repl(j,i+1,n){\n      vector<int> nxt=crt;\n      reverse(nxt.begin()+i,nxt.begin()+j+1);\n      if(d2.find(nxt)!=d2.end())continue;\n      d2[nxt]=d2[crt]+1;\n      que.push(nxt);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, char> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2, rn = n - n / 2 - 1;\n\n\tmap<vector<char>, char> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, char> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<char> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\t\t\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<short> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n;\n\nmap<vi, short> bfs(vi v)\n{\n\tmap<vi, short> mp;\n\tqueue<vi> que;\n\tque.push(v); mp[v] = 0;\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tque.pop();\n\t\tint t = mp[tmp];\n\t\tif (t >= n / 2) continue;\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + j, nx.begin() + i + 1);\n\t\t\tif (mp.find(nx) != mp.end()) continue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp[nx] = t + 1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn mp;\n}\n\nsigned main()\n{\n\tcin >> n;\n\tvi a(n), b;\n\tREP(i, n) cin >> a[i];\n\tb = a;\n\tsort(ALL(b));\n\tauto mp1 = bfs(a);\n\tauto mp2 = bfs(b);\n\tint ans = n - 1;\n\tfor (auto it = mp1.begin(); it != mp1.end(); it++)\n\t{\n\t\tif (mp2.find(it->first) != mp2.end()) chmin(ans, it->second + mp2[it->first]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nmap<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n\n  memo[idx][Vtoll(s)]=0;\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+1;j<=n;j++){\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\t\n\tif(memo[idx].count(Vtoll(nS))) continue;\n\tmemo[idx][Vtoll(nS)]=cost+1;\n\t\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n  \n  d=n/2;\n  \n  idx=0;\n  \n  bfs(A);\n\n  d=n/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n    \n  map<ll,int>::iterator ite=memo[0].begin();\n\n  while(ite!=memo[0].end()){\n      \n    if(memo[1].count((*ite).first))\n      ans=min(ans,(*ite).second+memo[1][(*ite).first]);\n      \n    ite++;\n    \n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<int> v, r;\n\nvector<pair<vector<int>, int> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tmap<vector<int>, int> d1; d1[v] = 1;\n\n\tqueue<vector<int> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<int> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < n / 2 + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<int>, int> d2; d2[r] = 1;\n\n\tqueue<vector<int> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<int> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < n - n / 2 + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v1.begin(), v1.end());\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<int> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\t\t\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<int>(n);\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\n\nmap<VI,int> mp;\n\nvoid Rev(int l,int r,vector<int> &v){\n\tfor(int i=0;i<=10;i++){\n\t\tif(l+i>=r-i)break;\n\t\tswap(v[l+i],v[r-i]);\n\t}\n\treturn;\n}\n\nvoid bfs(vector<int> v,int depth){\n\tif(depth>=4)return;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\tvector<int>v1;\n\t\t\tv1 = v;\n\t\t\tRev(i,j,v1);\n\t\t\tif(mp[v1]!=0){\n\t\t\t\tif(mp[v1]>depth){\n\t\t\t\t\tmp[v1] = depth;\n\t\t\t\t\tbfs(v1,depth+1);\n\t\t\t\t}\n\t\t\t}else if(mp[v1]==0){\n\t\t\t\tmp[v1] = depth;\n\t\t\t\tbfs(v1,depth+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid bfs2(vector<int> v,int depth,int &ans){\n\tif(depth>=4)return;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\tvector<int>v1;\n\t\t\tv1 = v;\n\t\t\tRev(i,j,v1);\n\t\t\tif(mp[v1]!=0){\n\t\t\t\tans = min(ans,mp[v1]+depth);\n\t\t\t\tbfs2(v1,depth+1,ans);\n\t\t\t}else if(mp[v1]==0){\n\t\t\t\tbfs2(v1,depth+1,ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n\n\nint main(){\n\tint n;\n\tcin >>n;\n\tVI a(n);\n\trep(i,n)cin>>a[i];\n\tmp[a]=0;\n\tbfs(a,1);\n\tVI b(n);\n\trep(i,n)b[i]=i+1;\n\tif(a==b){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = 10000;\n\tif(mp[b]!=0){\n\t\tans = mp[b];\n\t}\n\tbfs2(b,1,ans);\n\tif(ans==10000){\n\t\tcout << n-1 << endl;\n\t}else{\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\null PermutationHash(vi perm){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tull hash = 0;\n    REP(i, (int)perm.size()-1) perm[i] = perm[i];\n    REP(i, (int)perm.size()-1){\n        hash += perm[i] * FACTOR[perm.size()-i-1];\n        for (int j=i+1; j < (int)perm.size()-1; j++)\n            if (perm[i] < perm[j]) perm[j]--;\n    }\n    return hash;\n}\n\nvi restorePermutation(ull u){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tvi res;\n\tRREP(i, n){\n\t\tint p = u/FACTOR[i];\n\t\tu%=FACTOR[i];\n\t\tres.push_back(p);\n\t}\n\tRREP(i, res.size())RREP(j, i) if(res[j] <= res[i]) res[i]++;\n\treturn res;\n}\n\nint memo[3628801];\nint rev[3628801];\nmain(){\n\twhile(cin >> n){\n\t\tmemset(rev, 63, sizeof(memo));\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tvi a(n);\n\t\tREP(i, n) a[i] = i;\n\t\tqueue< pair<int, ull> > pq;\n\t\tpq.emplace(0, 0);\n\t\trev[0] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.front().first;\n\t\t\tull u = pq.front().second;\n\t\t\tpq.pop();\n\t\t\tif(c > 4) break;\n\t\t\tvi a = restorePermutation(u);\n\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\tvi b(a);\n\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\tull u = PermutationHash(b);\n\t\t\t\tif(chmin(rev[u], c+1)) pq.emplace(c+1, u);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tmemset(memo, 63, sizeof(memo));\n\t\t\tvi a(n);\n\t\t\tREP(i, n) cin >> a[i],a[i]--;\n\t\t\tqueue< pair<int, ull> > pq;\n\t\t\tpq.emplace(0, PermutationHash(a));\n\t\t\tmemo[PermutationHash(a)] = 0;\n\t\t\tint ans = n-1;\n\t\t\twhile(!pq.empty()){\n\t\t\t\tint c = pq.front().first;\n\t\t\t\tull u = pq.front().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif(c > 4) break;\n\t\t\t\tans = min(ans, c + rev[u]);\n\t\t\t\tvi a = restorePermutation(u);\n\t\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\t\tvi b(a);\n\t\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\t\tull u = PermutationHash(b);\n\t\t\t\t\tif(chmin(memo[u], c+1)) pq.emplace(c+1, u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nvoid calc(vector< int > &array, map< vector< int >, int > &scan)\n{\n  queue< vector< int > > que;\n  que.emplace(array);\n  while(!que.empty()) {\n    auto vec = que.front();\n    que.pop();\n    int dep = scan[vec];\n    for(int i = 0; i < array.size(); i++) {\n      for(int j = i + 1; j <= array.size(); j++) {\n        reverse(begin(vec) + i, begin(vec) + j);\n        if(!scan.count(vec)) {\n          scan[vec] = dep + 1;\n          if(dep + 1 < (array.size() - 1) / 2) que.emplace(vec);\n        }\n        reverse(begin(vec) + i, begin(vec) + j);\n      }\n    }\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector< int > A(N);\n  for(int i = 0; i < N; i++) {\n    cin >> A[i];\n    --A[i];\n  }\n  vector< int > vv(N);\n  iota(begin(vv), end(vv), 0);\n\n  map< vector< int >, int > cash1, cash2;\n  calc(A, cash1);\n  calc(vv, cash2);\n\n  int ret = INF;\n  do {\n    if(cash1.count(vv) && cash2.count(vv))\n      ret = min(ret, cash1[vv] + cash2[vv]);\n  } while(next_permutation(begin(vv), end(vv)));\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nstruct S {\n\tvi v;\n\tint cnt, astar;\n\tbool operator >(const S &a) const {\n\t\treturn astar > a.astar;\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\t//while(cin >> n) {\n\t\tS s;\n\t\ts.v.resize(n);\n\t\tREP(i, n) cin >> s.v[i];\n\t\ts.cnt = s.astar = 0;\n\n\t\tint chk = 0;\n\t\tREP(i, n) {\n\t\t\tchk += (i != s.v[i]);\n\t\t\tif(!chk) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\t//continue;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tset<vi> memo;\n\t\tpriority_queue<S, vector<S>, greater<S> > pq;\n\t\tpq.push(s);\n\n\t\tbool flg = false;\n\t\twhile(!pq.empty()) {\n\t\t\ts = pq.top(); pq.pop();\n\n\t\t\tREP(i, n) {\n\t\t\t\tFOR(j, i, n) {\n\t\t\t\t\tvi _v = s.v;\n\t\t\t\t\tswap(_v[i], _v[j]);\n\n\t\t\t\t\tif(!memo.count(_v)) {\n\t\t\t\t\t\tint astar = 0;\n\t\t\t\t\t\tREP(i, n)\n\t\t\t\t\t\t\tastar += (_v[i] != i);\n\t\t\t\t\t\tpq.push(S{_v, s.cnt+1, astar});\n\t\t\t\t\t\tmemo.insert(_v);\n\t\t\t\t\t\tif(!astar) flg = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) break;\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\tcout << s.cnt+1 << endl;\n\t//}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 10;\nconst int D = 10*9*8*7*6*5*4*3*2;\nconst int INF = 1 << 29;\n\nstruct state{\n  vector<int> v;\n  int cnt;\n  state(vector<int> v=vector<int>(), int cnt=0):v(v),cnt(cnt){}\n};\n\nint n, d[N], wd[2][D];\nvector<int> v;\n\nint hash(const vector<int> &vec){\n  int res = 0;\n  bool f[N];\n  fill(f, f+n, false);\n\n  for(int i=0;i<n-1;i++){\n    int cnt = 0;\n    for(int j=0;j<vec[i]-1;j++){\n      if(f[j]) cnt++;\n    }\n    res += d[n-2-i] * (vec[i] - cnt - 1);\n    f[vec[i]-1] = true;\n  }\n  \n  return res;\n}\n\nint bfs(const vector<int> &vec, int memo[], bool is_first){\n  int res = INF;\n  queue<state> q;\n  state u, u2;\n\n  fill(memo, memo+D, INF);\n  memo[hash(vec)] = 0;\n\n  for(q.push(state(vec, 0)); !q.empty();){\n    u = q.front();\n    q.pop();\n\n    if(!is_first) res = min(res, wd[0][hash(u.v)] + u.cnt);\n    if(is_first && u.cnt >= 4 || u.cnt >= 5 || res == 9) continue;\n\n    for(int i=0;i<n-1;i++){\n      for(int j=i+1;j<n;j++){\n        int hs;\n        u2 = state(u.v, u.cnt + 1);\n        reverse(u2.v.begin()+i, u2.v.begin()+j+1);\n        hs = hash(u2.v);\n        if(memo[hs] > u2.cnt){\n          memo[hs] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n\n  return res;\n}\n\nint solve(){\n  vector<int> w = v;\n\n  sort(w.begin(), w.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(v[i] == w[j]) {\n        v[i] = j + 1;\n        break;\n      }\n    }\n  }\n\n  w = v;\n  sort(w.begin(), w.end());\n\n  bfs(w, wd[0], true);\n  return bfs(v, wd[1], false);\n}\n\nint main(){\n  d[0] = 1;\n  for(int i=1;i<N;i++) d[i] = d[i-1] * (i + 1);\n  \n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<28;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nvi a;\n\nmap<vi,int> m;\n\nint main(){\n\tcin>>n;\n\ta=vi(n);\n\tvi b(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t\tb[i]=i;\n\t}\n\tm[b]=0;\n\tqueue<pair<vi,int> > q;\n\tq.push({b,0});\n\twhile(!q.empty()){\n\t\tvi p=q.front().first;\n\t\tint t=q.front().second;\n\t\tq.pop();\n\t\tfor(int i=1;i<=n;i++) for(int j=0;j<i;j++){\n\t\t\tvi p_=p;\n\t\t\treverse(p_.begin()+j,p_.begin()+i);\n\t\t\tif(m.find(p_)==m.end()){\n\t\t\t\tm[p_]=t+1;\n\t\t\t\tq.push({p_,t+1});\n\t\t\t}\n\t\t}\n\t}\n\tcout<<m[a]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000009;\nconst int INF = INT_MAX / 3;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nstring dfs(int now, int n, int a, int s, int g, vector<int> been, const vector<int>& isgo, const vector<vector<string>>& edge) {\n\tif (now == g)\n\t\treturn \"\";\n\tif (been[now])\n\t\treturn \"~\";\n\tbeen[now] = 1;\n\tvector<int> wigo;\n\tstring kouho = \"~\";\n\tfor (int i = 0; i < n; i++)\n\t\tif (isgo[i] && edge[now][i] < kouho)\n\t\t\tkouho = edge[now][i];\n\tfor (int i = 0; i < n; i++)\n\t\tif (isgo[i] && edge[now][i] == kouho)\n\t\t\twigo.push_back(i);\n\tstring res = \"~\";\n\tfor (int i = 0; i < wigo.size(); i++)\n\t\tres = min(res, dfs(wigo[i], n, a, s, g, been, isgo, edge));\n\n\treturn kouho+res;\n\n\n}\nint main(){\n\tint n, a, s, g;\n\twhile (cin >> n >> a >> s >> g, n) {\n\t\tvector<vector<string>> edge(n, vector<string>(n, \"~\"));\n\t\tREP(i, a) {\n\t\t\tint x, y;\n\t\t\tstring buf;\n\t\t\tcin >> x >> y >> buf;\n\t\t\tedge[x][y] = min(edge[x][y], buf);\n\t\t}\n\t\t\n\t\tvector<int> isgo(n,0);\n\t\tisgo[g]= 1;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif (isgo[j]) {\n\t\t\t\t\tfor (int r = 0; r < n; r++)\n\t\t\t\t\t\tif (edge[r][j] != \"~\")\n\t\t\t\t\t\t\tisgo[r] = 1;\n\t\t\t\t}\n\t\tif (!isgo[s]) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\tcontinue;\n\n\n\t\t}\n\t\tint now = s;\n\t\tvector<int> been(n, 0);\n\n\t\tstring res = dfs(now,n, a, s, g, been, isgo,edge);\n\t\tbool is = true;\n\t\tfor(int i=0;i<res.size();i++)\n\t\t\tif (res[i] == '~') {\n\t\t\t\tis = false;\n\n\t\t\t}\n\n\t\tif (is)\n\t\t\tcout << res << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"vector\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"algorithm\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tint cnt = 0;\n\tlong long int gl = 0;\n\tvector<long long int>v(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tv[i] = i + 1;\n\t\tgl += v[i] << (i<<2);\n\t}\n\tfor (int i = 0; i < N; i++)cin >> v[i];\n\tunordered_map<long long int,int>dis;\n\tlong long int bag = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tbag += (v[i] << (i<<2));\n\t}\n\tdis[bag] = 0;\n\tqueue<long long int>Q;\n\tQ.push(bag);\n\twhile (!Q.empty()) {\n\t\tlong long int cn = Q.front();\n\t\tif (dis[cn] == 5)break;\n\t//\tcout << cn << endl;\n\t\tQ.pop();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tlong long int cc = cn;\n\t\t\t\tfor (int k = i; k < (i + j + 1) / 2; k++) {\n\t\t\t\t\tlong long int a = (cc >> (k<<2)) & ((1 << 4)-1);\n\t\t\t\t\tlong long int b = (cc >> ((i + j - k)<<2)) & ((1 << 4)-1);\n\t\t//\t\t\tcout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n\t\t\t\t\tcc += (b - a) << (k<<2);\n\t\t\t\t\tcc += (a - b) << ((i + j - k)<<2);\n\t\t\t\t}\n\t\t\t\tif (dis.find(cc) == dis.end()) {\n\t\t\t\t\tdis[cc] = dis[cn] + 1;\n\t\t\t\t\tQ.push(cc);\n\t\t\t\t}\n\t\t\t\telse if (dis[cc] > dis[cn] + 1) {\n\t\t\t\t\tdis[cc] = dis[cn] + 1;\n\t\t\t\t\tQ.push(cc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tqueue<long long int>QQ;\n\tunordered_map<long long int, int>ddis;\n\tddis[gl] = 0;\n\tQQ.push(gl);\n\twhile (!QQ.empty()) {\n\t\tlong long int cn = QQ.front();\n\t\tif (ddis[cn] == 4)break;\n\t//\t\tcout << cn << endl;\n\t\tQQ.pop();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\tlong long int cc = cn;\n\t\t\t\tfor (int k = i; k < (i + j + 1) / 2; k++) {\n\t\t\t\t\tlong long int a = (cc >> (k << 2)) & ((1 << 4) - 1);\n\t\t\t\t\tlong long int b = (cc >> ((i + j - k) << 2)) & ((1 << 4) - 1);\n\t\t\t\t\t//\t\t\tcout << i << \" \" << j << \" \" << a << \" \" << b << endl;\n\t\t\t\t\tcc += (b - a) << (k << 2);\n\t\t\t\t\tcc += (a - b) << ((i + j - k) << 2);\n\t\t\t\t}\n\t\t\t\tif (ddis.find(cc) == ddis.end()) {\n\t\t\t\t\tddis[cc] = ddis[cn] + 1;\n\t\t\t\t\tQQ.push(cc);\n\t\t\t\t}\n\t\t\t\telse if (ddis[cc] > ddis[cn] + 1) {\n\t\t\t\t\tddis[cc] = ddis[cn] + 1;\n\t\t\t\t\tQQ.push(cc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 100;\n\tfor (auto i : dis) {\n\t\tif (ddis.find(i.first) == ddis.end())continue;\n\t\tans = min(i.second + ddis[i.first], ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint N;\nint A[11];\nstring initial;\nstring goal;\nset<string> st[2][6];\nvoid bfs(int index, string &now) {\n    st[index][0].insert(now);\n    for(int cost = 0; cost < 4; cost++) {\n        for(auto itr = st[index][cost].begin(); itr != st[index][cost].end(); itr++) {\n            string nowst = *itr;\n            for(int i = 0; i < nowst.size(); i++) {\n                for(int j = i + 2; j <= nowst.size(); j++) {\n                    reverse(nowst.begin() + i, nowst.begin() + j);\n                    bool ok = true;\n                    for(int k = 0; k <= cost + 1; k++) {\n                        if(st[index][k].find(nowst) != st[index][k].end()) ok = false;\n                    }\n                    if(ok) {\n                        st[index][cost+1].insert(nowst);\n                        //cerr << index << \" \" << cost + 1 << \" \" << st[index][cost+1].size() << \" \" << nowst << endl;\n                    }\n                    reverse(nowst.begin() + i, nowst.begin() + j);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    string start;\n    for(int i = 1; i <= N; i++) {\n        cin >> A[i];\n        A[i]--;\n        initial.push_back('0' + A[i]);\n        start.push_back('0' + A[i]);\n    }\n    sort(start.begin(), start.end());\n    bfs(0, start);\n    //cerr << st[0][5].size() << endl;\n    bfs(1, initial);\n    int ans = 9;\n    for(int i = 0; i <= 5; i++) {\n        for(auto itr = st[0][i].begin(); itr != st[0][i].end(); itr++) {\n            //cerr << i << \" \" << *itr << endl;\n            for(int j = 0; j <= 5; j++) {\n                if(st[1][j].find(*itr) != st[1][j].end()) ans = min(ans, i + j);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\n//ll encode(const vi& a)\n//{\n//\tll x=0;\n//\trep(i,a.size()) x|=ll(a[i])<<i*4;\n//\treturn x;\n//}\n//vi decode(ll x)\n//{\n//\tvi a;\n//\tfor(;x;x>>=4) a.push_back(x&15);\n//\treturn a;\n//}\n\nvvi f;\n\ninline int encode(const vi& a)\n{\n\treturn lower_bound(all(f),a)-begin(f);\n}\ninline vi decode(int x)\n{\n\treturn f[x];\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\t{\n\t\t\tf.clear();\n\t\t\tvi t(n); iota(all(t),1);\n\t\t\tdo{\n\t\t\t\tf.push_back(t);\n\t\t\t}while(next_permutation(all(t)));\n\t\t}\n\t\t\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n); iota(all(b),1);\n\t\tqueue<pii> q[2];\n\t\tunordered_map<int,int> m[2];\n\t\tq[0].emplace(encode(a),0);\n\t\tq[1].emplace(encode(b),0);\n\t\t\n\t\tint res=INF;\n\t\tfor(int k=0;;k^=1){\n\t\t\tqueue<pii> tmp;\n\t\t\twhile(q[k].size()){\n\t\t\t\tint x; int t; tie(x,t)=q[k].front(); q[k].pop();\n\t\t\t\tif(m[k].count(x)) continue;\n\t\t\t\t//m[k].emplace(x,t);\n\t\t\t\tm[k].insert(mp(x,t));\n\t\t\t\tif(m[k^1].count(x)){\n\t\t\t\t\tres=t+m[k^1][x];\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tvi a=decode(x);\n\t\t\t\trep(i,n) repi(j,i,n){\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t\ttmp.emplace(encode(a),t+1);\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q[k],tmp);\n\t\t}\n\t\tend:\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  vector<int> nums;\n  int cost;\n  bool operator <(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator >(const State& s) const {\n    return cost > s.cost;\n  }\n  State(const vector<int>& n,int c) {\n    nums = n;\n    cost = c;\n  }\n};\n\nint bfs(const vector<int>& init,\n        map<vector<int>,int>& dp){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(init,0));\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    for(int lhs = 0; lhs < s.nums.size(); lhs++){\n      for(int rhs = lhs + 1; rhs <= s.nums.size(); rhs++){\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n        \n        if(dp.find(s.nums) != dp.end()){\n          reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n          continue;\n        }\n\n        dp[s.nums] = s.cost + 1;\n        que.push(State(s.nums,s.cost+ 1));\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<int> nums;\n    for(int i=0; i < N; i++){\n      int num;\n      scanf(\"%d\",&num);\n      nums.push_back(num);\n    }\n    map<vector<int>,int> dp;\n    bfs(nums,dp);\n    sort(nums.begin(),nums.end());\n    printf(\"%d\\n\",dp[nums]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H(vector<int>&a){\n    int ret=0,f=1;\n    for(int i=a.size()-1;i>=0;i--){\n        int cnt=0;\n        for(int j=i;j<a.size();j++)if(a[i]>a[j])cnt++;\n        ret+=f*cnt;\n        f*=a.size()-i;\n    }\n    return ret;\n}\n\nvoid bfs(vint A,vint &cost){\n    fill(all(cost),1001001001);\n    cost[H(A)]=0;\n    queue<vint>que;\n    que.push(A);\n    while(que.size()){\n        vint a=que.front();\n        que.pop();\n        int h0=H(a);\n        if(cost[h0]==4)break;\n        for(int i=0;i<a.size();i++){\n            for(int j=i+1;j<=a.size();j++){\n                reverse(a.begin()+i,a.begin()+j);\n                int h=H(a);\n                if(cost[h]==1001001001){\n                    cost[h]=cost[h0]+1;\n                    que.push(a);\n                }\n                reverse(a.begin()+i,a.begin()+j);\n            }\n        }\n    }\n}\n\nsigned main(){\n    int N;cin>>N;\n    vector<int>A(N);\n    rep(i,N)cin>>A[i];\n\n    vector<int>B(N);\n    rep(i,N)B[i]=i+1;\n\n    vector<int>costA(3628800),costB(3628800);\n    bfs(A,costA);bfs(B,costB);\n\n    int ans=9;\n    rep(i,3628800)chmin(ans,costA[i]+costB[i]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\nint main() {\n\tlong long int N;\n\tcin >> N;\n\tvector<long long int>D( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> D[i];\n\t\tD[i]--;\n\t}\n\tlong long int count = 0;\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tif( i % 2 ) {\n\t\t\tlong long int idx = N - i / 2 - 1, memo;\n\t\t\tfor( size_t j = 0; j < N; j++ ) {\n\t\t\t\tif( idx == D[j] ) {\n\t\t\t\t\tmemo = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx != memo ) {\n\t\t\t\treverse( D.begin() + memo, D.begin() + idx+1 );\n\t\t\t\tcount++;\n\t\t\t}\n\t\t} else {\n\t\t\tlong long int idx = i / 2, memo;\n\t\t\tfor( size_t j = 0; j < N; j++ ) {\n\t\t\t\tif( idx == D[j] ) {\n\t\t\t\t\tmemo = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( idx != memo ) {\n\t\t\t\treverse( D.begin() + idx, D.begin() + memo + 1 );\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << count << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1355\n\nmap<vector<int>, int>dp;\nint n;\n\nint main() {\n\tcin >> n;\n\tvector<int>x(n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t}\n\tint a[10] = { 0,1,2,3,4,5,6,7,8,9 }; vector<int>c(n, 0);\n\tdo {\n\t\tvector<int>b;\n\t\tfor (int i = 0; i < n; i++) { b.push_back(a[i] + 1); }\n\t\tdp[b] = INF;\n\t}\n\twhile (next_permutation(a, a + n));\n\tvector<int>y;\n\tfor (int i = 0; i < n; i++) {\n\t\ty.push_back(i + 1);\n\t}\n\tdp[x] = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tfor (int j = 0; j < 10; j++) { a[j] = j; }\n\t\tif (dp[y] != INF) { cout << i << endl; goto E; }\n\t\tdo\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tc[j] = a[j] + 1;\n\t\t\t}\n\t\t\tif (dp[c] == i)\n\t\t\t{\n\t\t\t\tfor (int L = 0; L < n; L++)\n\t\t\t\t{\n\t\t\t\t\tfor (int R = L + 1; R < n; R++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = L; j <= (L + R) / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswap(c[j], c[L + R - j]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (dp[c] == INF) { dp[c] = i + 1; }\n\n\t\t\t\t\t\tfor (int j = L; j <= (L + R) / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswap(c[j], c[L + R - j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (next_permutation(a, a + n));\n\t}\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n  \nint N;\nvector<int> A, B;\n\nmap<vector<int>, int> bfs(vector<int> start) {\n  map<vector<int>, int> memo;\n  queue< vector<int> > Q;\n  Q.push(start);\n  memo[start] = 0;\n  \n  while(!Q.empty()) {\n    vector<int> vi = Q.front();\n    Q.pop();\n\n    int cost = memo[vi];\n  \n    if(cost >= (N - 1) / 2) continue;\n    \n    for(int i = 0; i < N; i++) {\n      for(int j = i + 2; j <= N; j++) {\n        vector<int> tmp = vi;\n        reverse(tmp.begin() + i, tmp.begin() + j);\n        if(memo.find(tmp) == memo.end()) {\n          memo[tmp] = cost + 1;\n          Q.push(tmp);\n        }\n      }\n    }\n  }\n  \n  return memo;\n}\n\nint solve() {\n  int ans = N - 1;\n  map<vector<int>, int> memo_A = bfs(A);\n  map<vector<int>, int> memo_B = bfs(B);\n  if(memo_A.find(B) != memo_A.end()) ans = memo_A[B];\n  else {\n    do {\n      if(memo_A.find(B) == memo_A.end()) continue;\n      if(memo_B.find(B) == memo_B.end()) continue;\n      ans = min(ans, memo_A[B] + memo_B[B]);\n    } while(next_permutation(B.begin(), B.end()));\n  }\n  return ans;\n}\n\nint main() {\n  cin >> N;\n  rep(i, N) {\n    int a;\n    cin >> a;\n    A.push_back(a);\n  }\n  B = A;\n  sort(B.begin(), B.end());\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint N;\n\nstruct Array{\n\tint a[10], d;\n\tArray(){}\n\tArray(int b[], int x){\n\t\tfor(int i = 0; i < N; i++) a[i] = b[i];\n\t\td = x;\n\t}\n\tbool operator==(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, int dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(int k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(int k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> A.a[i];\n\tfor(int i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\t\n\tint ans = N-1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), vec[i]);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, p->d + vec[i].d);\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\n\nmap<vector<int>, int> bfs(vector<int> s, int depth) {\n  map<vector<int>, int> dp;\n  queue<vector<int> > q;\n  q.push(s);\n  dp[s] = 0;\n\n  while (!q.empty()) {\n    vector<int> x = q.front(); q.pop();\n    int f = dp[x];\n    if (f+1 >= depth) continue;\n\n    int n = x.size();\n    for (int l=0; l<n; l++) {\n      for (int r=l+1; r<n; r++) {\n        vector<int> t(x);\n        rep(s, (r-l+1)/2) swap(t[l+s], t[r-s]);\n        if (dp.find(t) == dp.end()) {\n          dp[t] = f+1;\n          q.push(t);\n        }\n      }\n    }\n  }\n  return dp;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  vector<int> s;\n  rep(i, N) {\n    int a;\n    cin >> a;\n    a--;\n    s.pb(a);\n  }\n\n  vector<int> id(N);\n  rep(i, N) id[i] = i;\n\n  int m = N-1;\n  auto lp = bfs(id, 4), rp = bfs(s, 4);\n  for (auto &p : lp) {\n    if (rp.find(p._1) == rp.end()) continue;\n    m = min(m, p._2 + rp[p._1]);\n  }\n  cout << m << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack pack = Queue[curr][i];\n            \n            vector<int> perm = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                    nextQueue.push_back(make_pair(perm, nextPermId));\n                \n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        cin >> start[i];\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int n; cin >> n;\n    vector<int> a(n);\n    vector<int> b(n);\n    for(int i = 0; i < n; i++) cin >> a[i];\n    for(int i = 0; i < n; i++) b[i] = i + 1;\n\n    map<vector<int>, int> mb;\n    queue<pair<vector<int>, int> > qb;\n    \n    mb[b] = -1;\n    qb.push({b, 0});\n    \n\n    while(1){\n\n        vector<int> now(n);\n        now = qb.front().first;\n        int cost = qb.front().second;\n        qb.pop();\n        \n        if(cost == 4) break;\n\n        bool ok = true;\n        for(int i = 0; i < n; i++){\n            if(a[i] != now[i]){\n                ok = false;\n                break;\n            }\n        }\n\n        if(ok){\n            cout << cost << endl;\n            return 0;\n        }\n\n        for(int i = 0; i < n - 1; i++){\n            for(int j = i + 1; j < n; j++){\n                vector<int> next(n);\n                next = now;\n\n                for(int k = i; k <= j; k++){\n                    next[k] = now[j - k + i];\n                }\n\n\n                if(mb.find(next) == mb.end()){\n                    mb[next] = cost + 1;\n                    qb.push({next, cost + 1});\n                }\n            }\n        }\n    }\n\n\n    //cout << \"junnbihadeketa\" << endl;\n    map<vector<int>, int> ma;\n    queue<pair<vector<int>, int> > qa;\n    ma[a] = -1;\n    qa.push({a, 0});\n\n    while(1){\n\n        vector<int> now(n);\n        now = qa.front().first;\n        int cost = qa.front().second;\n        qa.pop();\n\n        if(cost == 4) break;\n\n        if(mb.find(now) != mb.end()){\n            cout << cost + mb[now] << endl;\n            return 0;\n        }\n\n        for(int i = 0; i < n - 1; i++){\n            for(int j = i + 1; j < n; j++){\n                vector<int> next(n);\n                next = now;\n                for(int k = i; k <= j; k++){\n                    next[k] = now[j + i - k];\n                }\n\n                if(ma.find(next) == ma.end()){\n                    ma[next] == cost + 1;\n                    qa.push({next, cost + 1});\n                }\n            }\n        }\n    }\n\n    cout << 9 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long int lli;\n\n//16進法\ninline lli Reverse(lli n, int l, int r){\n\tlli ret = 0;\n\tfor(int i=0; i<10; i++){\n\t\tlli num = n & 0b1111;\n\t\tn >>= 4;\n\t\tif(l<=i && i<=r){\n\t\t\tret |= num << (4*(l+r-i));\n\t\t}else{\n\t\t\tret |= num << (4*i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tlli num[2] = {0, 0};\n\tfor(int i=0; i<n; i++){\n\t\tlli a;\n\t\tcin >> a;\n\t\tnum[0] |= a << (4*i);\n\t\tnum[1] |= (lli)(i+1) << (4*i);\n\t}\n\t\n\tmap<lli, int> step[2];\n\tfor(int r=0; r<2; r++){\n\t\tset<lli> prev;\n\t\tprev.insert(num[r]);\n\t\tstep[r][num[r]] = 0;\n\t\tfor(int s=0; s<(n-1)/2; s++){\n\t\t\tset<lli> next;\n\t\t\tfor(lli arr: prev){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tfor(int j=i+1; j<n; j++){\n\t\t\t\t\t\tlli rev = Reverse(arr, i, j);\n\t\t\t\t\t\tif(step[r].count(rev) == 0){\n\t\t\t\t\t\t\tstep[r][rev] = s+1;\n\t\t\t\t\t\t\tnext.insert(rev);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = next;\n\t\t}\n\t}\n\t\n\tint ans = n-1;\n\tfor(auto itr: step[0]){\n\t\tif(step[1].count(itr.first) != 0){\n\t\t\tans = min(ans, itr.second +step[1][itr.first]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nint dfs(vector<int> C, int n)\n{\n    if(C == B) { return n; }\n    \n    int min_ = N;\n    \n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(i != j && C[i] == B[j])\n            {\n                vector<int> D; D = C;\n                \n                swap(D[i], D[j]);\n                \n                min_ = min(dfs(D, n + 1), min_);\n            }\n        }\n    }\n    \n    return min_;\n}\n\nint main()\n{\n    cin >> N;\n    \n    A = vector<int>(N);\n    B = vector<int>(N);\n    \n    for(int i = 0; i < N; i++)\n    {\n        cin >> A[i];\n    }\n    \n    for(int i = 0; i < N; i++) { B[i] = A[i]; }\n    \n    sort(B.begin(), B.end());\n    \n    cout << dfs(A, 0) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n\tll hash;\n\tint l, r;\n};\n\nint N;\n\nll toHash(vector<int> v) {\n\tll ret = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tret *= 10;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\nvector<int> fromHash(ll hash) {\n\tvector<int> ret(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tret[N-i-1] = hash % 10;\n\t\thash /= 10;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N;\n\n\tvector<int> v(N);\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tcin >> v[i]; --v[i];\n\t}\n\n\tvector<int> g = v;\n\tsort(g.begin(), g.end());\n\n\tmap<ll, int> m;\n\tqueue<Node> Q[10]; Q[0].push( (Node){ toHash(v), 0, 0 } );\n\tfor (int step = 0; step < max(1, N/2); ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tNode node = Q[step].front(); Q[step].pop();\n\t\t\tll hash = node.hash;\n\t\t\tint l = node.l, r = node.r;\n\n\t\t\tif (m.find(hash) != m.end()) continue;\n\t\t\tm[hash] = step;\n\n\t\t\tvector<int> v = fromHash(hash);\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tif (l <= i && j <= r) continue;\n\n\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\n/*\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int k = i+1; k < j; ++k) {\n\t\t\t\t\t\t\tif (nv[k] != k) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) */\n\t\t\t\t\t\tQ[step+1].push( (Node){ toHash(nv), i, j } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset<ll> s;\n\tfor (int i = 0; i < N; ++i) {\n\t\twhile ( !Q[i].empty() ) {\n\t\t\tQ[i].pop();\n\t\t}\n\t}\n\tQ[0].push( (Node){ toHash(g), 0, 0 } );\n\tfor (int step = 0; step < N; ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tNode node = Q[step].front(); Q[step].pop();\n\t\t\tll hash = node.hash;\n\t\t\tint l = node.l, r = node.r;\n\n\t\t\tif (m.find(hash) != m.end()) {\n\t\t\t\tcout << m[hash]+step << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (s.find(hash) != s.end()) continue;\n\t\t\ts.insert(hash);\n\n\t\t\tvector<int> v = fromHash(hash);\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tif (l <= i && j <= r) continue;\n\n\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\n/*\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int k = i+1; k < j; ++k) {\n\t\t\t\t\t\t\tif (nv[k] != k) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) */\n\t\t\t\t\t\tQ[step+1].push( (Node){ toHash(nv), i, j } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2, rn = n - n / 2 - 1;\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\t\t\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nint po[11],a[11];\nvoid print(int x){\n  for(int i=0;i<n;i++) cout<<x%11<<\" \",x/=11;\n  cout<<endl;\n}\nvoid sw(int &x,int i,int j){\n  int s=(x%po[i+1])/po[i]*(po[j]-po[i]);\n  int t=(x%po[j+1])/po[j]*(po[i]-po[j]);\n  x+=s+t;\n}\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<10;i++) po[i+1]=po[i]*11;\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i];\n  int p[2]={};\n  for(int i=0;i<n;i++) p[0]=p[0]*11+a[i];\n  for(int i=0;i<n;i++) p[1]=p[1]*11+(i+1);\n  if(p[0]==p[1]){\n    cout<<0<<endl;\n    return 0;\n  }\n  //cout<<p<<endl<<ans<<endl;\n  //print(p);print(ans);\n  queue<int> q[2];\n  unordered_map<int,int> m[2];\n  int ans=n-1;\n  for(int j=0;j<2;j++){\n    q[j].push(p[j]);\n    m[j][p[j]]=0;\n    while(!q[j].empty()){\n      int t=q[j].front();q[j].pop();\n      int d=m[j][t];\n      if(d>=n/2-1) break;\n      //cout<<d<<\":\";print(p);\n      for(int i=1;i<n-1;i++){\n\tint r=t;\n\tfor(int k=1;i-k>=0&&i+k<n;k++){\n\t  sw(r,i-k,i+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tint r=t;\n\tfor(int k=0;i-k>=0&&i+1+k<n;k++){\n\t  sw(r,i-k,i+1+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t\t//★ある状態から、firstへの距離が一気に2以上縮まることはない。よって、自分が1以上増えることにより、打ち切り★\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nll encode(const vi& a)\n{\n\tll x=0;\n\trep(i,a.size()) x|=ll(a[i])<<i*4;\n\treturn x;\n}\nvi decode(ll x)\n{\n\tvi a;\n\tfor(;x;x>>=4) a.push_back(x&15);\n\treturn a;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\t\n\t\tvi b(n); iota(all(b),1);\n\t\tif(a==b){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tqueue<pair<ll,int>> q[2];\n\t\tunordered_map<ll,int> m[2];\n\t\tq[0].emplace(encode(a),0); m[0].insert(mp(encode(a),0));\n\t\tq[1].emplace(encode(b),0); m[1].insert(mp(encode(b),0));\n\t\t\n\t\tint res=INF;\n\t\tfor(int k=0;;k^=1){\n\t\t\tqueue<pair<ll,int>> tmp;\n\t\t\twhile(q[k].size()){\n\t\t\t\tll x; int t; tie(x,t)=q[k].front(); q[k].pop();\n\t\t\t\tif(m[k^1].count(x)){\n\t\t\t\t\tres=t+m[k^1][x];\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tvi a=decode(x);\n\t\t\t\trep(i,n) repi(j,i,n){\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t\tll x=encode(a);\n\t\t\t\t\tif(!m[k].count(x)){\n\t\t\t\t\t\ttmp.emplace(encode(a),t+1);\n\t\t\t\t\t\tm[k][x]=t+1;\n\t\t\t\t\t}\n\t\t\t\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(q[k],tmp);\n\t\t}\n\t\tend:\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <queue>\n#include <map>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <iostream>\ntypedef long long ll;\n\n#include <set>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nstruct state{\n  ll v;\n  state() : v(0){}\n  state(const vector<int> &v) : v(0) { REP(i,v.size()) set(i, v[i]); }\n  vector<int> decode(int n) const{\n    vector<int> v(n); REP(i,n) v[i] = get(i);\n    return v;\n  }\n\n  inline void set(int pos, int val){\n    v &= ~(((1ll << ((pos + 1) * 4)) - 1) - ((1ll << (pos * 4)) - 1));\n    v |= ((ll)val) << (pos * 4);\n  }\n\n  inline int get(int pos) const{\n    return (v >> (pos * 4)) & ((1 << 4) - 1);\n  }\n};\n\nmap<ll, int> solve(int n, state s, map<ll, int> *prev = NULL){\n  map<ll, int> ret;\n\n  queue<state> q;\n  ret[s.v] = 0; q.push(s);\n\n  while(q.size()){\n    const state st = q.front(); q.pop();\n    const int cnt  = ret[st.v];\n\n    if(prev != NULL && prev->count(st.v))\n      throw (*prev)[st.v] + cnt;\n    if(cnt == 4) continue;\n\n    REP(i,n) REP(j,i){\n      vector<int> v = st.decode(n);\n      reverse(v.begin() + j, v.begin() + i + 1);\n      const state next(v);\n      if(ret.count(next.v) == 0){\n        ret[next.v] = cnt + 1;\n        q.push(next);\n      }\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  const int n = getInt();\n  state init;\n  state goal;\n  REP(i,n) init.set(i, getInt() - 1);\n  REP(i,n) goal.set(i, i);\n\n  if(init.v == goal.v){\n    cout << 0 << endl;\n  }else{\n    map<ll, int> s1 = solve(n, init);\n    try{\n      map<ll, int> s2 = solve(n, goal, &s1);\n      cout << 9 << endl;\n    }catch(int e){\n      cout << e << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=3700000;\nconst int INF=123456789;\n\nint f[11];\nint dp[2][N];\n\ninline int get_idx(const vector<int> &a)\n{\n    int n = a.size();\n    int ret=0;\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int ct=0;\n        rep(j,a[i])if(!use[j]) ++ct;\n\n        ret += ct*f[n-1-i];\n\n        use[a[i]]=true;\n    }\n    return ret;\n}\n\ninline vector<int> get_vec(int n, int idx)\n{\n    vector<int> ret(n);\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int s = idx/f[n-1-i];\n        int j=0,ct=0;\n        while(1)\n        {\n            if(!use[j])\n            {\n                ++ct;\n                if(ct==s+1) break;\n            }\n            ++j;\n        }\n\n        use[j]=true;\n        ret[i]=j;\n        idx -= s*f[n-1-i];\n    }\n    return ret;\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<=10; ++i) f[i] = f[i-1]*i;\n\n    int n;\n    cin >>n;\n    vector<int> a(n);\n    rep(i,n)\n    {\n        cin >>a[i];\n        --a[i];\n    }\n\n    rep(d,2)\n    {\n        int start = d?get_idx(a):0;\n        fill(dp[d],dp[d]+N,INF);\n        dp[d][start]=0;\n        queue<int> que;\n        que.push(start);\n        while(!que.empty())\n        {\n            int now = que.front();\n            que.pop();\n\n            vector<int> x = get_vec(n,now);\n            rep(i,n)for(int j=i+1; j<=n; ++j)\n            {\n                reverse(x.begin()+i, x.begin()+j);\n\n                int nx = get_idx(x);\n                if(dp[d][nx]>dp[d][now]+1)\n                {\n                    dp[d][nx] = dp[d][now]+1;\n                    if(dp[d][nx]<4) que.push(nx);\n                }\n\n                reverse(x.begin()+i, x.begin()+j);\n            }\n        }\n    }\n\n    int ans=9;\n    rep(i,N)if(dp[0][i]<INF && dp[1][i]<INF) ans=min(ans,dp[0][i]+dp[1][i]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\n\nmap<vi, int> bfs(vi v)\n{\n\tmap<vi, int> mp;\n\tqueue<vi> que;\n\tque.push(v); mp[v] = 0;\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tque.pop();\n\t\tint t = mp[tmp];\n\t\tif (t >= n / 2) continue;\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + j, nx.begin() + i);\n\t\t\tif (mp.find(nx) != mp.end()) continue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp[nx] = t + 1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn mp;\n}\n\nint main()\n{\n\tcin >> n;\n\tvi a(n), b;\n\tREP(i, n) cin >> a[i];\n\tb = a;\n\tsort(ALL(b));\n\tauto mp1 = bfs(a);\n\tauto mp2 = bfs(b);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define int short\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\n\tcin >> N;\n\n\tvector<int> A(N);\n\n\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\n\tvector<int> B = A; sort(B.begin(), B.end());\n\n\tset<vector<int> > dat; dat.insert(A);\n\n\tqueue<vector<int> > que; que.push(A);\n\n\tqueue<int> que2; que2.push(0);\n\n\tif (A == B) { cout << 0 << endl; goto Exit; }\n\n\twhile (que.size())\n\t{\n\t\tvector<int> v1 = que.front(); que.pop();\n\n\t\tint dist = que2.front(); que2.pop();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tvector<int> v2 = v1;\n\n\t\t\t\tswap(v2[i], v2[j]);\n\n\t\t\t\tif (v2 == B) { cout << dist + 1 << endl; goto Exit; }\n\n\t\t\t\tif (dat.find(v2) == dat.end())\n\t\t\t\t{\n\t\t\t\t\tdat.insert(v2);\n\n\t\t\t\t\tque.push(v2);\n\n\t\t\t\t\tque2.push(dist + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  3.cpp\n//  practice\n//\n//  Created by ???????¢???? on 2017/06/11.\n//  Copyright ?? 2017??´ ???????¢????. All rights reserved.\n//\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nmap<vector<int>,int>ma,ma2;\nset<vector<int> >se,se2;\nvector<int>a,b;\nint n;\nint main(){\n    cin >> n;\n    for(int i=1;i<=n;i++){\n        int x; cin >> x;\n        a.pb(i); b.pb(x);\n    }\n    queue<pair<vector<int>,int> >que;\n    que.push(make_pair(a,0)); ma[a] = 0;\n    while(!que.empty()){\n        pair<vector<int>,int> pv = que.front(); que.pop();\n        if(se.find(pv.first) != se.end()) continue;\n        if(pv.second == 4) continue;\n        if(pv.first == b) { printf(\"%d\",pv.second); puts(\"\"); return 0;}\n        se.insert(pv.first);\n        vector<int> v = pv.first;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                int x = i,y = j;\n                while(x<y){\n                    swap(v[x],v[y]);\n                    x++; y--;\n                }\n                if(ma.find(v) == ma.end()) ma[v] = pv.second+1;\n                else ma[v] = min(ma[v],pv.second+1);\n                if(se.find(v) == se.end()){\n                    que.push(make_pair(v,ma[v]));\n                }\n                x = i,y = j;\n                while(x<y){\n                    swap(v[x],v[y]);\n                    x++; y--;\n                }\n            }\n        }\n    }\n    que.push(make_pair(b,0)); ma2[b] = 0;\n    while(!que.empty()){\n        pair<vector<int>,int> pv = que.front(); que.pop();\n        if(se2.find(pv.first) != se2.end()) continue;\n        if(pv.second == 4) continue;\n        se2.insert(pv.first);\n        vector<int> v = pv.first;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                int x = i,y = j;\n                while(x<=y){\n                    swap(v[x],v[y]);\n                    x++; y--;\n                }\n                if(ma2.find(v) == ma2.end()) ma2[v] = pv.second+1;\n                else ma2[v] = min(ma2[v],pv.second+1);\n                if(se2.find(v) == se2.end()){\n                    que.push(make_pair(v,ma2[v]));\n                }\n                x = i,y = j;\n                while(x<=y){\n                    swap(v[x],v[y]);\n                    x++; y--;\n                }\n            }\n        }\n    }\n    int res = 9;\n    for(map<vector<int> ,int>::iterator it=ma.begin();it!=ma.end();++it){\n        if(ma2.find(it->first) != ma2.end()){\n            res = min(res,it->second+ma2[it->first]);\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<vi,int> P;\nint main(){\n  int n,d;cin>>n;\n  vi v(n),t(n);\n  map<vi,int> m;\n  for(int i=0;i<n;i++) cin>>v[i],t[i]=i+1;\n  queue<P> q;\n  q.push(P(t,0));\n  while(!q.empty()){\n    P p=q.front();q.pop();\n    t=p.first;d=p.second;\n    if(m.find(t)!=m.end()) continue;\n    //for(int i=0;i<n;i++) cout<<t[i]<<\" \\n\"[i==n-1];\n    m[t]=d;\n    if(t==v) break;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<=n;j++){\n\treverse(t.begin()+i,t.begin()+j);\n\tif(m.find(t)==m.end()) q.push(P(t,d+1));\n\treverse(t.begin()+i,t.begin()+j);\n      }\n    }\n  }\n  cout<<m[v]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "w#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint n;\nll encode(vi const & v){\n    ll res = 0;\n    rep(i,n) res = res*11 + v[i];\n    return res;\n}\nvi decode(ll x){\n    vi v(n);\n    rep(i,n){\n        v[n-i-1] = x%11;\n        x/=11;\n    }\n    return v;\n}\n\nint main(){\n    cin >> n;\n    vi v(n);\n    rep(i,n) cin >> v[i];\n    set<ll> dp;\n    queue<pair<int,ll>> q;\n    dp.insert(encode(v));\n    q.emplace(0,encode(v));\n    int ans = -1;\n    while(q.size()){\n        int d; ll x;\n        tie(d,x) = q.front();q.pop();\n        vi u = decode(x);\n        bool ok = true;\n        rep(i,n-1) ok &= u[i]+1==u[i+1];\n        if(ok){\n            ans = d;\n            break;\n        }\n        rep(i,n+1)rep(j,i){\n            reverse(u.begin()+j,u.begin()+i);\n            if(dp.count(encode(u))==0) q.emplace(d+1,encode(u));\n            reverse(u.begin()+j,u.begin()+i);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(dist[lv]==4)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[nexv]){\n\t\t\t\t\tres=min(res,dist[lv]+dist[nexv]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[lv];\n\t\tif(dist[lv]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint n;\nll encode(vi const & v){\n    ll res = 0;\n    rep(i,n) res = res*11 + v[i];\n    return res;\n}\nvi decode(ll x){\n    vi v(n);\n    rep(i,n){\n        v[n-i-1] = x%11;\n        x/=11;\n    }\n    return v;\n}\n\nint main(){\n    cin >> n;\n    vi v(n);\n    rep(i,n) cin >> v[i];\n    set<ll> dp;\n    queue<pair<int,ll>> q;\n    dp.insert(encode(v));\n    q.emplace(0,encode(v));\n    int ans = -1;\n    while(q.size()){\n        int d; ll x;\n        tie(d,x) = q.front();q.pop();\n        vi u = decode(x);\n        bool ok = true;\n        rep(i,n-1) ok &= u[i]+1==u[i+1];\n        if(ok){\n            ans = d;\n            break;\n        }\n        rep(i,n+1)rep(j,i){\n            reverse(u.begin()+j,u.begin()+i);\n            if(dp.count(encode(u))==0) q.emplace(d+1,encode(u));\n            reverse(u.begin()+j,u.begin()+i);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    \n    vector<int> a(n), b(n);\n    for(int i=0 ; i < n ; i++ ){\n        cin >> a[i];\n        b[i] = i+1;\n    }\n    // d[v] := スタートからの距離, h[v] := ゴールからの距離\n    map<vector<int>,int> d, h;\n    // 解は最大でも n-1 \n    int ans = n-1;\n    // ゴールから探索\n    {\n        h[b] = 0;\n        queue<vector<int> > q;\n        q.push( b );\n        while( !q.empty() ){\n            vector<int> v = q.front();\n            int cost = h[v];\n            q.pop();\n            \n            if( v == a ){\n                ans = cost;\n                break;\n            }\n            if( cost >= 4 ) break;\n            \n            for(int i=0 ; i < n ; i++ ){\n                for(int j=i+1 ; j < n ; j++ ){\n                    vector<int> next = v;\n                    reverse( next.begin()+i , next.begin()+j+1 );\n                    if( !h.count(next) ){\n                        h[next] = cost+1;\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    // スタートから探索\n    {\n        d[a] = 0;\n        queue<vector<int> > q;\n        q.push( a );\n        while( !q.empty() ){\n            vector<int> v = q.front();\n            int cost = d[v];\n            q.pop();\n            \n            if( h.count(v) ){\n                ans = cost + h[v];\n                break;\n            }\n            if( cost >= 4 ) break;\n            \n            for(int i=0 ; i < n ; i++ ){\n                for(int j=i+1 ; j < n ; j++ ){\n                    vector<int> next = v;\n                    reverse( next.begin()+i , next.begin()+j+1 );\n                    if( !d.count(next) ){\n                        d[next] = cost+1;\n                        q.push(next);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct State {\n\tArray a;\n\tint step;\n\tState(Array& _a, int _s) : a(_a), step(_s) {}\n\t\n\tlint getHash() {\n\t\tlint hash = 0;\n\t\tint n = size_of(a);\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\thash *= 10;\n\t\t\tif (a[i] == 10) hash *= 10;\n\t\t\thash += a[i];\n\t\t}\n\t\t\n\t\treturn hash;\n\t}\n\t\n\tbool isSorted() {\n\t\tint n = size_of(a);\n\t\tfor_(i,0,n-1) {\n\t\t\tif (a[i] > a[i + 1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint N;\nArray A;\n\nvoid solve() {\n\tqueue< State > q;\n\tq.push(State(A, 0));\n\t\n\tset< lint > hash_table;\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\t\n\t\tlint hash = s.getHash();\n\t\tif (hash_table.find(hash) != hash_table.end()) continue;\n\t\t\n\t\thash_table.insert(hash);\n\t\tif (s.isSorted()) {\n\t\t\tcout << s.step << endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tfor_(j,i + 1,N) {\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t\tq.push(State(s.a, s.step + 1));\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tA.assign(N, 0);\n\tfor_(i,0,N) cin >> A[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\n\n\nmap<ll, int> ma;\nset<ll> se;\n\nll myhash(vector<int> &v) {\n\tll ret = 0;\n\trep(i, v.size()) {\n\t\tret *= 11;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\n\n\nvector<int> w;\n\nint dfs(int d, vector<int> &v, bool f) {\n\tll h = myhash(v);\n\tif(f) {\n\t\tif(ma.find(h) != ma.end()) {\n\t\t\treturn ma[h] + d;\n\t\t}\n\t\tif(se.find(h) != se.end()) return 1010;\n\t\tse.insert(h);\n\t}\n\telse {\n\t\tif(v==w){\n\t\t\treturn d;\n\t\t}\n\t\tif(d==(v.size()-1)/2) {\n\t\t\treturn ma[h] = d;\n\t\t}\n\t}\n\tif(d == (v.size() - 1) / 2) return 1010;\n\tint ret = 1010;\n\trep(i, v.size()) {\n\t\trep(j, i) {\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t\tmins(ret, dfs(d + 1, v, f));\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n,0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = n - 1;\n\tdfs(0, v, false);\n\tmins(ans, dfs(0, w, true));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<n;i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\nconst int INF = 1e9+7;\n\n\nint n;\nvector<int> in;\n\n\nvoid input(){\n\tcin>>n;\n\trep(i,n){\n\t\tint t;\n\t\tcin>>t;\n\t\tin.push_back(t);\n\t}\n}\n\n\nll getHash(vector<int>& a){\n\tll ret=0, t=1;\n\trep(i,a.size()){\n\t\tret += a[i]*t;\n\t\tt*=11;\n\t}\n\treturn ret;\n}\n\nvoid reverse(vector<int>& a, int b, int c){\n\twhile(b<c){\n\t\tswap(a[b], a[c]);\n\t\tb++; c--;\n\t}\n}\n\nmap<ll,int> memo;\n\nint ans = INF;\n\n\nvoid saiki(vector<int>& a, int mode, int depth){\n\t\n\tif(mode==0){\n\t\tbool ok = true;\n\t\trep(i,a.size()){\n\t\t\tif(a[i]!=i+1)ok=false;\n\t\t}\n\t\tif(ok)ans = min(ans, (int)(in.size()-1)/2 - depth);\n\t}\n\n\tif(depth==0){\n\t\tif(mode==0)memo[getHash(a)] = (in.size()-1)/2 - depth;\n\t\treturn;\n\t}\n\n\tif(mode==1){\n\t\tll h = getHash(a);\n\t\tif(memo.find(h)!=memo.end()){\n\t\t\tint s = memo[h] + (in.size()-1)/2 - depth;\n\t\t\tans = min(ans, s);\n\t\t\treturn;\n\t\t}\n\t}\n\n\trep(i,a.size()){\n\t\treps(j,i+1,a.size()){\n\t\t\treverse(a, i ,j);\n\t\t\tsaiki(a, mode, depth-1);\n\t\t\treverse(a,i,j);\n\t\t}\n\t}\n}\n\nint solve(){\n\tvector<int> tmp;\n\trep(i,in.size())tmp.push_back(i+1);\n\n\tans = in.size()-1;\n\n\tsaiki(in, 0, (in.size()-1)/2);\n\tsaiki(tmp, 1, (in.size()-1)/2);\n\n\treturn ans;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct State {\n\tArray a;\n\tint step;\n\tState(Array& _a, int _s) : a(_a), step(_s) {}\n\t\n\tlint getHash() {\n\t\tlint hash = 0;\n\t\tint n = size_of(a);\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\thash *= 10;\n\t\t\tif (a[i] == 10) hash *= 10;\n\t\t\thash += a[i];\n\t\t}\n\t\t\n\t\treturn hash;\n\t}\n\t\n\tbool isSorted() {\n\t\tint n = size_of(a);\n\t\tfor_(i,0,n-1) {\n\t\t\tif (a[i] > a[i + 1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint N;\nArray A;\n\nvoid solve() {\n\tqueue< State > q;\n\tq.push(State(A, 0));\n\t\n\tset< lint > hash_table;\n\tlint hash = q.front().getHash();\n\thash_table.insert(hash);\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\t\n\t\tif (s.isSorted()) {\n\t\t\tcout << s.step << endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (s.step > 9) continue;\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tfor_(j,i + 1,N) {\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t\tlint hash_ = s.getHash();\n\t\t\t\tif (hash_table.find(hash_) == hash_table.end()) q.push(State(s.a, s.step + 1));\n\t\t\t\thash_table.insert(hash_);\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tA.assign(N, 0);\n\tfor_(i,0,N) cin >> A[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef pair<int,vector<int> > p2;\n \nmap<vector<int>,int> dist,dist2;\n \nint n;\nqueue<p2> que;\n\nvoid bfs(vector<int>start){\n  \n  que.push(p2(0,start));\n  dist[start]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n    \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>=(n-1)/2)continue;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<int>t=now.state;\n\treverse(t.begin()+i,t.begin()+j+1);\n\tif(dist.find(t)==dist.end())\n\t  que.push(p2(now.cost+1,t));\n\t//reverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n\n\n\nint bfs2(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,start));\n\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    if(now.cost>=(n-1)/2)continue;\n\n    if(dist2.find(now.state)!=dist2.end() && dist2[now.state]<now.cost)continue;\n    dist2[now.state]=now.cost;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<int>t=now.state;\n\treverse(t.begin()+i,t.begin()+j+1);\n\tif(dist2.find(t)==dist2.end())\n\t  que.push(p2(now.cost+1,t));\n\t//reverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  bfs(g);\n\n  cout << bfs2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint dp[3628800]; // 10!\nint A[10];\n\n\n#define rmax 10\nvoid decode(int m, int n, int *L) {\n  bool b[rmax] = {false};\n  rep(i, n) {\n    int S = m % (n-i);\n    m /= n-i;\n    int j=0, k=0;\n    while (1) {\n      if (!b[j]) {\n        k++;\n        if(k>S) break;\n      }\n      j++;\n    }\n    L[i] = j;\n    b[j] = true;\n  }\n}\n\nint encode(int *L, int n) {\n  bool b[rmax] = {false};\n  int p = 1, K = 0;\n  rep(i, n) {\n    int S = 0;\n    rep(j, L[i]) {\n      if (!b[j]) S++;\n    }\n    K += p*S;\n    p *= (n-i);\n    b[L[i]] = true;\n  }\n  return K;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) {\n    cin >> A[i];\n    A[i]--;\n  }\n\n  int goal = encode(A, N);\n  int id[N];\n  rep(i, N) id[i] = i;\n\n  rep(i, 3628800) dp[i] = INF;\n  queue<int> q;\n  int s = encode(id, N);\n  swap(s, goal);\n  q.push(s);\n  dp[s] = 0;\n\n  while (!q.empty()) {\n    int x = q.front(); q.pop();\n    if (x == goal) break;\n    int a[10], b[10];\n    decode(x, N, a);\n\n    for (int l=0; l<N; l++) {\n      for (int r=l+1; r<N; r++) {\n        rep(i, N) b[i] = a[i];\n        rep(s, (r-l+1)/2) swap(b[l+s], b[r-s]);\n        //rep(i, N)cout<<a[i]<<\",\";cout<<\": -> (\"<<l<<\",\"<<r<<\") {\"; rep(i, N)cout<<b[i]<<\",\";cout<<\"}\\n\";\n        int t = encode(b, N);\n        if (dp[t] > dp[x]+1) {\n          dp[t] = dp[x]+1;\n          q.push(t);\n        }\n      }\n    }\n  }\n  cout << dp[goal] << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nlong long f(vi a){\n\tlong long x = 0;\n\tfor(int i = 0 ; i < a.size() ; i++) x = x * 10 + a[i];\n\treturn x;\n}\nint n;\ninline vi g(long long t){\n\tvi v(n);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tv[n-i-1] = t % 10;\n\t\tt /= 10;\n\t}\n\treturn v;\n}\n\nmap<long long,int> F(vi init,vi goal){\n\tqueue<long long> Q;\n\tmap<long long,int> done;\n\tdone[f(init)] = 0;\n\tQ.push(f(init));\n\twhile( Q.size() ){\n\t\tauto q_ = Q.front(); Q.pop();\n\t\tauto q = g(q_);\n\t\tif( done[q_] >= 4) break;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = i + 1 ; j < n ; j++){\n\t\t\t\tvi v = q;\n\t\t\t\tint l = j - i + 1;\n\t\t\t\tfor(int k = 0 ; k < l/2 ; k++){\n\t\t\t\t\tswap(v[i+k],v[j-k]);\n\t\t\t\t}\n\t\t\t\tlong long h = f(v);\n\t\t\t\tif( done.count(h) == 0 ){\n\t\t\t\t\tQ.push(h);\n\t\t\t\t\tdone[h] = done[q_] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn done;\n}\nint main(){\n\tcin >> n;\n\tvi init(n);\n\tvi goal(n);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tcin >> init[i];\n\t\tgoal[i] = i;\n\t\tinit[i]--;\n\t}\n\tauto A = F(init,goal);\n\tauto B = F(goal,init);\n\n\tif( A.count(f(goal)) ){\n\t\tcout << A[f(goal)] << endl;\n\t}else{\n\t\tint ans = 9;\n\t\tfor( auto x : A){\n\t\t\tif( B.count(x.first) ){\n\t\t\t\tans = min(ans,x.second+B[x.first]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n; vector<int>a; queue<pair<vector<int>,int>>Q;\nvector<pair<vector<int>, int>>a1, a2;\nvoid init(vector<int>R, int Lim, int D) {\n\tQ.push(make_pair(R, 0));\n\twhile (!Q.empty()) {\n\t\tvector<int>H = Q.front().first; int L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tvector<int>I = H; int Y = j;\n\t\t\t\tfor (int k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { int p; cin >> p; a.push_back(p); }\n\tint pos = n / 2; init(a, pos, 0); vector<int>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos, 1);\n\tsort(a1.begin(), a1.end()); sort(a2.begin(), a2.end());\n\tint ret = n - 1;\n\tfor (int i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, 0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tfor (int j = S1; j < S2; j++) ret = min(ret, a1[i].second + a2[j].second);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\null PermutationHash(vi perm){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tull hash = 0;\n    REP(i, (int)perm.size()-1) perm[i] = perm[i];\n    REP(i, (int)perm.size()-1){\n        hash += perm[i] * FACTOR[perm.size()-i-1];\n        for (int j=i+1; j < (int)perm.size()-1; j++)\n            if (perm[i] < perm[j]) perm[j]--;\n    }\n    return hash;\n}\n\nvi restorePermutation(ull u){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tvi res;\n\tRREP(i, n){\n\t\tint p = u/FACTOR[i];\n\t\tu%=FACTOR[i];\n\t\tres.push_back(p);\n\t}\n\tRREP(i, res.size())RREP(j, i) if(res[j] <= res[i]) res[i]++;\n\treturn res;\n}\n\nint memo[3628801];\nint rev[3628801];\nmain(){\n\twhile(cin >> n){\n\t\tmemset(rev, 63, sizeof(memo));\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tvi a(n);\n\t\tREP(i, n) a[i] = i;\n\t\tqueue< pair<int, ull> > pq;\n\t\tpq.emplace(0, 0);\n\t\trev[0] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.front().first;\n\t\t\tull u = pq.front().second;\n\t\t\tpq.pop();\n\t\t\tif(c > 3) break;\n\t\t\tvi a = restorePermutation(u);\n\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\tvi b(a);\n\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\tull u = PermutationHash(b);\n\t\t\t\tif(chmin(rev[u], c+1)) pq.emplace(c+1, u);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tmemset(memo, 63, sizeof(memo));\n\t\t\tvi a(n);\n\t\t\tREP(i, n) cin >> a[i],a[i]--;\n\t\t\tqueue< pair<int, ull> > pq;\n\t\t\tpq.emplace(0, PermutationHash(a));\n\t\t\tmemo[PermutationHash(a)] = 0;\n\t\t\tint ans = n-1;\n\t\t\twhile(!pq.empty()){\n\t\t\t\tint c = pq.front().first;\n\t\t\t\tull u = pq.front().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif(c > 3) break;\n\t\t\t\tans = min(ans, c + rev[u]);\n\t\t\t\tvi a = restorePermutation(u);\n\t\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\t\tvi b(a);\n\t\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\t\tull u = PermutationHash(b);\n\t\t\t\t\tif(chmin(memo[u], c+1)) pq.emplace(c+1, u);\n\t\t\t\t\tans = min(ans, c + 1 + rev[u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int64_t s=0;\n    rep(i,0,n){\n        int64_t a;\n        cin >> a;\n        --a;\n        s=s*10+a;\n    }\n\n    int64_t sorted=0;\n    rep(i,0,n) sorted=sorted*10+i;\n\n    int64_t exp[10];\n    exp[0]=1;\n    rep(i,1,10) exp[i]=exp[i-1]*10;\n    auto reverse=[&](int64_t x,int l,int r){\n        rep(i,0,(r-l+1)/2){\n            int64_t p=x/exp[l+i]%10,q=x/exp[r-i]%10;\n            x-=p*exp[l+i]+q*exp[r-i];\n            x+=q*exp[l+i]+p*exp[r-i];\n        }\n        return x;\n    };\n\n    unordered_map<int64_t,int> num1;\n    {\n        queue<int64_t> queues[10];\n        num1[s]=0;\n        queues[0].push(s);\n        rep(k,0,5){\n            auto &que=queues[k];\n            while(!que.empty()){\n                auto x=que.front();\n                que.pop();\n                if(x==sorted){\n                    cout << k << endl;\n                    return;\n                }\n                int l,r;\n                rep(i,0,n){\n                    if(x/exp[i]%10!=n-i-1){\n                        l=i;\n                        break;\n                    }\n                }\n                for(int i=n-1; i>=0; --i){\n                    if(x/exp[i]%10!=n-i-1){\n                        r=i;\n                        break;\n                    }\n                }\n                rep(i,l,r){\n                    rep(j,i+1,r+1){\n                        int64_t y=reverse(x,i,j);\n                        if(num1.find(y)!=num1.end()) continue;\n                        num1[y]=k+1;\n                        if(k+1<5) queues[k+1].push(y);\n                    }\n                }\n            }\n        }\n    }\n\n    unordered_map<int64_t,int> num2;\n    {\n        queue<int64_t> queues[10];\n        num2[sorted]=0;\n        queues[0].push(sorted);\n        rep(k,0,6){\n            auto &que=queues[k];\n            while(!que.empty()){\n                auto x=que.front();\n                que.pop();\n                rep(i,0,n){\n                    rep(j,i+1,n){\n                        int64_t y=reverse(x,i,j);\n                        if(num2.find(y)!=num2.end()) continue;\n                        if(num1.find(y)!=num1.end()){\n                            cout << num1[y]+k+1 << endl;\n                            return;\n                        }\n                        num2[y]=k+1;\n                        if(k+1<6) queues[k+1].push(y);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,int> T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint N;\nint A[12];\nint ans;\nqueue<T> que[2];\nmap<ll,int> ma[2];\nll encode(vector<int> vec)\n{\n\tll res = 0ll;\n\tfor(int i=0;i<N;i++)res = (res<<4)+vec[i];\n\treturn res;\n}\nvector<int> decode(ll res)\n{\n\tvector<int> v;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tv.pb(((1<<4)-1)&res);\n\t\tres >>= 4;\n\t}\n\treverse(all(v));\n\treturn v;\n}\nvoid bfs(int f,ll start)\n{\n\tqueue<T> &q = que[f];\n\tmap<ll,int> &m = ma[f];\n\tq.push(T(start,0));\n\tm[start]=0;\n\twhile(!q.empty())\n\t{\n\t\tT a = q.front();\n\t\tq.pop();\n\t\tvector<int> v = decode(a.fi);\n\t\tvector<int> tmp = v;\n\t\tif(a.sec>=(N-1)/2)return;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<N;j++)\n\t\t\t{\n\t\t\t\tfor(int k=i;k<=j;k++)tmp[j-(k-i)]=v[k];\n\t\t\t\tll e = encode(tmp);\n\t\t\t\tif(m.find(e)==m.end())\n\t\t\t\t{\n\t\t\t\t\tm[e]=a.sec+1;\n\t\t\t\t\tq.push(T(e,a.sec+1));\n\t\t\t\t}\n\t\t\t\tfor(int k=i;k<=j;k++)tmp[k]=v[k];\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&A[i]);\n\tvector<int> vec;\n\tfor(int i=0;i<N;i++)vec.pb(A[i]);\n\tbfs(0,encode(vec));\n\tfor(int i=0;i<N;i++)vec[i]=i+1;\n\tbfs(1,encode(vec));\n\tans = N-1;\n\tmap<ll,int>::iterator it1,it2;\n\tit1=ma[0].begin();it2=ma[1].begin();\n\twhile(1)\n\t{\n\t\tif(it1==ma[0].end()||it2==ma[1].end())break;\n\t\telse if(it1->fi < it2->fi)it1++;\n\t\telse if(it1->fi > it2->fi)it2++;\n\t\telse\n\t\t{\n\t\t\tans = min(ans,it1->sec+it2->sec);\n\t\t\tit1++;\n\t\t\tit2++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvi in,to;\nll vtol(vi a){\n\tll t=0;\n\trep(i,a.size()){\n\t\tt*=10;\n\t\tt+=a[i];\n\t}\n\treturn t;\n}\nmap<ll,int>tmp;\nvoid f(vi a,int c){\n\tif(c==(n-1)/2)return;\n\trep(i,n-1)loop(j,i+1,n){\n\t\tvi t=a;\n\t\tloop(k,i,j+1)if(k<j-k+i)\n\t\t\tswap(t[k],t[j-k+i]);\n\t\tll s=vtol(t);\n\t\tif(tmp.count(s))tmp[s]=min(tmp[s],c+1);\n\t\telse tmp[s]=c+1;\n\t\tf(t,c+1);\n\t}\n}\nint main(){\n\tcin>>n;\n\tin=vi(n);\n\trep(i,n)cin>>in[i];\n\tto=vi(n);\n\trep(i,n)to[i]=i,in[i]--;\n\ttmp[vtol(to)]=0;\n\tf(to,0);\n\tmap<ll,int>A=tmp;\n\ttmp.clear();\n\ttmp[vtol(in)]=0;\n\tf(in,0);\n\tmap<ll,int>B=tmp;\n\tint out=n-1;\n\tfor(auto it:A)if(B.count(it.first)){\n\t\tout=min(out,A[it.first]+B[it.first]);\n\t}\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//-O2 is required.\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef vector<int> V;\nmap<V,int>m;\n//map<V,pair<pair<int,int>,V> >track;\n//V v1,v2;\npair<int,int>vec2nvec;\nint bfs(V &v, int back){\n\tif(!back&&m.find(v)!=m.end()){\n\t\t//v1.clear();\n\t\t//vec2nvec=make_pair(0,0);\n\t\t//v2=v;\n\t\treturn m[v];\n\t}\n\tset<V>s;\n\tqueue<pair<V,int> >q;\n\tif(back)m[v]=0;\n\ts.insert(v);\n\tint i,j;\n\tfor(q.push(make_pair(v,0));!q.empty();){\n\t\tV vec=q.front().first;\n\t\tint depth=q.front().second;\n\t\tq.pop();\n\t\tif(back&&depth>2)return 0;\n\t\tfor(i=0;i<vec.size();i++)\n\t\t\tfor(j=i+1;j<vec.size();j++){\n\t\t\t\tV nvec=vec;\n\t\t\t\treverse(nvec.begin()+i,nvec.begin()+j+1);\n\t\t\t\tif(!back&&m.find(nvec)!=m.end()){\n\t\t\t\t\t//v1=vec;\n\t\t\t\t\t//vec2nvec=make_pair(i,j);\n\t\t\t\t\t//v2=nvec;\n\t\t\t\t\treturn depth+1+m[nvec];\n\t\t\t\t}\n\t\t\t\tif(!s.insert(nvec).second)continue;\n\t\t\t\tif(back)m[nvec]=depth+1;\n\t\t\t\t//track[nvec]=make_pair(make_pair(i,j),vec);\n\t\t\t\tq.push(make_pair(nvec,depth+1));\n\t\t\t}\n\t}\n\treturn 0;\n}\n//void backtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tbacktrack(track[v].second);\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//}\n//void forwardtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//\tforwardtrack(track[v].second);\n//}\nmain(){\n\tV prob;\n\tint i=0,t,n;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tif(scanf(\"%d\",&t)==-1)return 0;\n\t\tprob.push_back(t);\n\t}\n\tV goal=prob;\n\tsort(goal.begin(),goal.end());\n\tbfs(goal,1);\n\tprintf(\"%d\\n\",bfs(prob,0));\n\t//backtrack(v1);\n\t//if(vec2nvec.first!=vec2nvec.second)printf(\"%d %d\\n\",vec2nvec.first+1,vec2nvec.second+1);\n\t//forwardtrack(v2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    vector<int> POS(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n        A[i]--;\n        POS[A[i]] = i;\n    }\n    const int maximum = 1 << N;\n    int mini = N;\n    for (int i = 0; i < maximum; i++) {\n        vector<int> a = A;\n        vector<int> pos = POS;\n        int cnt = 0;\n        int head = 0;\n        int tail = N - 1;\n        for (int j = 0; j < N; j++) {\n            if (i & (1 << j)) {\n                const int p = pos[head];\n                if (p != head) {\n                    for (int k = 0; k < (p - head + 1) / 2; k++) {\n                        const int h = a[head + k];\n                        const int t = a[p - k];\n                        pos[h] = p - k;\n                        pos[t] = head + k;\n                        swap(a[head + k], a[p - k]);\n                    }\n                    cnt++;\n                }\n                head++;\n            } else {\n                const int p = pos[tail];\n                if (p != tail) {\n                    for (int k = 0; k < (tail - p + 1) / 2; k++) {\n                        const int t = a[tail - k];\n                        const int h = a[p + k];\n                        pos[t] = p + k;\n                        pos[h] = tail - k;\n                        swap(a[tail - k], a[p + k]);\n                    }\n                    cnt++;\n                }\n                tail--;\n            }\n        }\n        mini = min(mini, cnt);\n    }\n    cout << mini << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\ninline int solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2, rn = n - ln - 1;\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvoid dfs(int i,vector<int> &a,map<vector<int>,int> &memo){\n\tint n=a.size();\n\tmemo[a]=i;\n\tif(i==4) return;\n\trep(l,n) for(int r=l+1;r<n;r++) {\n\t\treverse(a.begin()+l,a.begin()+r+1);\n\t\tif(memo.count(a)==0) dfs(i+1,a,memo);\n\t\treverse(a.begin()+l,a.begin()+r+1);\n\t}\n}\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tvector<int> a(n);\n\trep(i,n) scanf(\"%d\",&a[i]);\n\n\tmap<vector<int>,int> memo1,memo2;\n\tdfs(0,a,memo1);\n\tsort(a.begin(),a.end());\n\tdfs(0,a,memo2);\n\n\tint ans=9;\n\tmap<vector<int>,int>::iterator it;\n\tfor(it=memo1.begin();it!=memo1.end();++it) if(memo2.count(it->first)>0) ans=min(ans,it->second+memo2[it->first]);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  /*lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n    }\n    return res;*/\n  return strtoll(str.c_str(), NULL, 10);\n\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = P(rev(u.first, i, j), u.second + 1);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(data.find(v.first) != data.end()) return data[v.first] + v.second + 1;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return n-1;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = P(rev(u.first, i, j), u.second + 1);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  vector<char> nums;\n  int cost;\n  bool operator <(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator >(const State& s) const {\n    return cost > s.cost;\n  }\n  State(const vector<char>& n,int c) {\n    nums = n;\n    cost = c;\n  }\n};\n\nint bfs(const vector<char>& init,\n        map<vector<char>,int>& dp,int limit = 4){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(init,0));\n  dp[init] = 0;\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s.cost >= limit) continue;\n    for(int lhs = 0; lhs < s.nums.size(); lhs++){\n      for(int rhs = lhs + 1; rhs <= s.nums.size(); rhs++){\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n        \n        if(dp.find(s.nums) != dp.end()){\n          reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n          continue;\n        }\n\n        dp[s.nums] = s.cost + 1;\n        que.push(State(s.nums,s.cost+ 1));\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<char> nums;\n    for(int i=0; i < N; i++){\n      int num;\n      scanf(\"%d\",&num);\n      nums.push_back(num);\n    }\n    map<vector<char>,int> start;\n    bfs(nums,start);\n\n    map<vector<char>,int> goal;\n    sort(nums.begin(),nums.end());\n    bfs(nums,goal,4);\n    \n    int res = 9;\n    for(map<vector<char>,int>::iterator it = start.begin();\n        it != start.end();\n        it++){\n      if(goal.find(it->first) != goal.end()){\n        res = min(it->second + goal[it->first],res);\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//半数列挙で答えが8以下かを判定する.\n//順列は, 16進数で表現する.\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint n;\nint a[10], decA, basePermDec;\nvector<int> perms[2][5];\n\nvoid dfs(int type, int depth, int maxDepth, int nowP) {\n\tperms[type][depth].push_back(nowP);\n\tif (depth == maxDepth) return;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint nextP = nowP & ((1LL << (4 * (j + 1))) - 1);\n\t\t\tnextP = (nextP >> (4 * i)) << (4 * i);\n\t\t\tnextP = nowP - nextP;\n\t\t\tfor (int k = 0; k <= j - i; k++) {\n\t\t\t\tint idl = i + k;\n\t\t\t\tint idr = j - k;\n\t\t\t\tnextP += ((nowP >> (4 * idr)) & 15) << (4 * idl);\n\t\t\t}\n\t\t\tdfs(type, depth + 1, maxDepth, nextP);\n\t\t}\n\t}\n}\n\nbool isMatch(int depth1, int depth2) {\n\tvector<int> &a = perms[0][depth1];\n\tvector<int> &b = perms[1][depth2];\n\tint i, j;\n\t\n\tif (a.size() == 0 || b.size() == 0) return false;\n\t\n\tj = 0;\n\tfor (i = 0; i < a.size(); i++) {\n\t\tfor (; j < b.size(); j++) {\n\t\t\tif (a[i] <= b[j]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j < b.size && a[i] == b[j]) return true;\n\t}\n\treturn false;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) { cin >> a[i]; a[i]--; }\n\tfor (i = 0; i < n; i++) decA += a[i] << (4 * i);\n\tfor (i = 0; i < n; i++) basePermDec += i << (4 * i);\n\tdfs(0, 0, 4, basePermDec);\n\tdfs(1, 0, 4, decA);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tsort(perms[i][j].begin(), perms[i][j].end());\n\t\t\tperms[i][j].erase(unique(perms[i][j].begin(), perms[i][j].end()), perms[i][j].end());\n\t\t}\n\t}\n\t\t\n\tint ans = 9;\n\tfor (i = 0; i <= 4; i++) {\n\t\tfor (j = 0; j <= 4; j++) {\n\t\t\tif (isMatch(i, j)) {\n\t\t\t\tans = min(ans, i + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nmain(){\n\tint n, a[11];\n\tint i, p = 0, c = 0, d = 1;\n\tcin >> n;\n\tfor(i=0;i<n;i++) cin >> a[i];\n\n\tif(a[0]!=1)c++;\n\tfor(i=1;i<=n;i++){\n\t\tfor(;a[p]!=i;p+=d){\n\t\t\tif(p+d<0 || n<=p+d){\n\t\t\t\td=-d;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nint n,x,co;\nvector<int>v;\nmap<vector<int>,int>M1;\nset<vector<int> >s;\nvoid bfs1(){\n  queue<P>q;\n  q.push(P(v,0));\n  s.insert(v);\n  while(!q.empty()){\n    vector<int> g=q.front().first;\n    int cost=q.front().second,c=0;q.pop();\n    r(i,n-1)if(g[i]>g[i+1])c++;\n    if(!c){\n      cout<<cost<<endl;\n      exit(0);\n    }\n    M1[g]=cost;\n    if(cost==4)continue;\n    for(int i=2;i<=n;i++){\n      for(int j=0;j+i<=n;j++){\n        vector<int>t=g;\n        for(int k=j,l=0;l<i/2;l++,k++){\n          swap(t[k],t[j+i-1-l]);\n        }\n        if(!s.count(t)){\n          s.insert(t);\n          q.push(P(t,cost+1));\n        }\n      }\n    }\n  }\n}\nvoid bfs2(){\n  queue<P>q;\n  q.push(P(v,0));\n  s.insert(v);\n  while(!q.empty()){\n    vector<int> g=q.front().first;\n    int cost=q.front().second,c=0;q.pop();\n    if(M1[g]){cout<<1<<endl;\n      cout<<cost+M1[g]<<endl;\n      exit(0);\n    }\n    if(cost==5)continue;\n    for(int i=2;i<=n;i++){\n      for(int j=0;j+i<=n;j++){\n        vector<int>t=g;\n        for(int k=j,l=0;l<i/2;l++,k++){\n          swap(t[k],t[j+i-1-l]);\n        }\n        if(!s.count(t)){\n          s.insert(t);\n          q.push(P(t,cost+1));\n        }\n      }\n    }\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>x;\n    v.push_back(x);\n  }\n  bfs1();\n  r(i,n)v[i]=i+1;\n  bfs2();\n  cout<<9<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nshort N;\n\nstruct Array{\n\tshort a[10], d;\n\tArray(){}\n\tbool operator==(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn d < obj.d;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, short dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\t//if(arr.d != dep) cout << \"*\" << endl;\n\t\n\tArray tmp;\n\tfor(short i = 0; i < N; i++){\n\t\tfor(short j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(short k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(short k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(short i = 0; i < N; i++) cin >> A.a[i];\n\tfor(short i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\tvec2.erase(unique(vec2.begin(), vec2.end()), vec2.end());\n\t\n\tshort ans = N-1;\n\tArray tmp;\n\tfor(short i = 0; i < vec.size(); i++){\n\t\ttmp = vec[i]; tmp.d = 0;\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), tmp);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, (short)(p->d + vec[i].d));\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\t\n\t/*for(int i = 0; i < vec2.size(); i++){\n\t\tfor(int j = 0; j < N; j++) cout << vec2[i].a[j] << \" \"; \n\t\tcout << vec2[i].d << endl;\n\t}*/\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\null PermutationHash(vi perm){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tull hash = 0;\n    REP(i, (int)perm.size()-1) perm[i] = perm[i];\n    REP(i, (int)perm.size()-1){\n        hash += perm[i] * FACTOR[perm.size()-i-1];\n        for (int j=i+1; j < (int)perm.size()-1; j++)\n            if (perm[i] < perm[j]) perm[j]--;\n    }\n    return hash;\n}\n\nvi restorePermutation(ull u){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tvi res;\n\tRREP(i, n){\n\t\tint p = u/FACTOR[i];\n\t\tu%=FACTOR[i];\n\t\tres.push_back(p);\n\t}\n\tRREP(i, res.size())RREP(j, i) if(res[j] <= res[i]) res[i]++;\n\treturn res;\n}\n\nint memo[3628801];\nint rev[3628801];\nmain(){\n\twhile(cin >> n){\n\t\tmemset(rev, 63, sizeof(memo));\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tvi a(n);\n\t\tREP(i, n) a[i] = i;\n\t\tqueue< pair<int, ull> > pq;\n\t\tpq.emplace(0, 0);\n\t\trev[0] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.front().first;\n\t\t\tull u = pq.front().second;\n\t\t\tpq.pop();\n\t\t\tif(c > 4) break;\n\t\t\tvi a = restorePermutation(u);\n\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\tvi b(a);\n\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\tull u = PermutationHash(b);\n\t\t\t\tif(chmin(rev[u], c+1)) pq.emplace(c+1, u);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tmemset(memo, 63, sizeof(memo));\n\t\t\tvi a(n);\n\t\t\tREP(i, n) cin >> a[i],a[i]--;\n\t\t\tqueue< pair<int, ull> > pq;\n\t\t\tpq.emplace(0, PermutationHash(a));\n\t\t\tmemo[PermutationHash(a)] = 0;\n\t\t\tint ans = n-1;\n\t\t\twhile(!pq.empty()){\n\t\t\t\tint c = pq.front().first;\n\t\t\t\tull u = pq.front().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif(c > 4) break;\n\t\t\t\tans = min(ans, c + rev[u]);\n\t\t\t\tvi a = restorePermutation(u);\n\t\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\t\tvi b(a);\n\t\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\t\tull u = PermutationHash(b);\n\t\t\t\t\tif(chmin(memo[u], c+1)) pq.emplace(c+1, u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nmap<vi,int> mq;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi vec(n);\n    rep(i,n){\n        cin >> vec[i];\n        --vec[i];\n    }\n    mp[vec] = 0;\n    vector<vector<int> > st[2];\n    st[0].pb(vec);\n    rep(i,4){\n        rep(id,len(st[0])){\n            rep(j,n-1){\n                srep(k,j+1,n){\n                    vi res = st[0][id];\n                    for(int l=j;2*l<j+k;l++){\n                        swap(res[l],res[j+k-l]);\n                    }\n                    if(mp.find(res) == mp.end()){\n                        mp[res] = i+1;\n                        st[1].pb(res);\n                    }\n                }\n            }\n        }\n        swap(st[0],st[1]);\n    }\n    vector<vector<int> > su[2];\n    vi res(n);\n    iota(all(res),0);\n    mq[res] = 0;\n    su[0].pb(res);\n    int ans = INF;\n    if(mp.find(res) != mp.end()){\n        cout << mp[res] << \"\\n\";\n        return 0;\n    }\n    rep(i,4){\n        rep(id,len(su[0])){\n            rep(j,n-1){\n                srep(k,j+1,n){\n                    vi res = su[0][id];\n                    for(int l=j;2*l<j+k;l++){\n                        swap(res[l],res[j+k-l]);\n                    }\n                    if(mp.find(res) != mp.end()){\n                        cmn(ans,mp[res]+i+1);\n                    }else if(mq.find(res) == mq.end()){\n                        mq[res] = i+1;\n                    }\n                }\n            }\n        }\n        swap(su[0],su[1]);\n    }\n    if(ans == INF){\n        cout << \"9\\n\";\n    }else{\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nll mod = 1000000007;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ntemplate <typename ... TT>\nstruct hash<std::tuple<TT...>>\n{\n\tsize_t\n\t\toperator()(std::tuple<TT...> const& tt) const\n\t{\n\t\tsize_t seed = 0;\n\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\treturn seed;\n\t}\n\n}; }\numap<ti3, ll> memo;\nll pow(ll base, ll i,ll mod) {\n\tll a=1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti/=2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<char> a(n);\n\tfor (auto &x : a)cin >> x;\n\tint cnt = 0;\n\tmap<vector<char>,int> used;\n\tqueue<pair<int, vector<char>>> que;\n\tque.push({ 0,a });\n\tused[a] = 0;\n\tvector<char> r(n);\n\tiota(ALL(r), 1);\n\tfor (; que.front().second != r;) {\n\t\trep(i, n) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tvector<char> x(que.front().second);\n\t\t\t\treverse(x.begin() + i, x.begin() + j+1);\n\t\t\t\tauto c = used.insert({ x,que.front().first + 1 });\n\t\t\t\tif (c.second)que.push({ c.first->second,x });\n\t\t\t}\n\t\t}\n\t\tque.pop();\n\t}\n\tcout << que.front().first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nmap<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(memo[idx].count(Vtoll(S))) continue;\n    memo[idx][Vtoll(S)]=cost;\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+1;j<=n;j++){\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n  \n  d=n/2;\n  \n  idx=0;\n  \n  bfs(A);\n\n  d=n/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n    \n  map<ll,int>::iterator ite=memo[0].begin();\n\n  while(ite!=memo[0].end()){\n      \n    if(memo[1].count((*ite).first))\n      ans=min(ans,(*ite).second+memo[1][(*ite).first]);\n      \n    ite++;\n    \n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int c,d,e;\n  S(const vector<int> &pv,int pc):v(pv),c(pc){\n    d=0;\n    for(int i=0;i<v.size();i++){\n      d+=v[i]!=i+1;\n    }\n    e=c+(d+1)/2;\n  }\n  void swap(int a,int b){\n    c++;\n    std::swap(v[a],v[b]);\n    d=0;\n    for(int i=0;i<v.size();i++){\n      d+=v[i]!=i+1;\n    }\n    e=c+(d+1)/2;\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n\nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  set<vector<int> > s;\n  for(;;){\n    S c=que.top();\n    if(is_sorted(begin(c.v),end(c.v)))break;\n    que.pop();\n    if(!s.insert(c.v).second)continue;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tS n=c;\n\tn.swap(i,j);\n\tque.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, vector<int> > P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nvector<int> a;\n\nll f(const vector<int>& v){\n  ll res=0;\n  rep(i,n){\n    res*=10LL;\n    res+=v[i];\n  }\n  return res;\n}\n\nmap<ll,int> d1,d2;\n\nint main(){\n  cin>>n;\n  rep(i,n){\n    int b;\n    cin>>b;\n    a.push_back(b);\n  }\n  d1[f(a)]=0;\n  queue<vector<int> > que;\n  que.push(a);\n  while(que.size()){\n    vector<int> crt=que.front();\n    que.pop();\n    if(d1[f(crt)]>=(n/2)-1)continue;\n    rep(i,n)repl(j,i+1,n){\n      vector<int> nxt=crt;\n      reverse(nxt.begin()+i,nxt.begin()+j+1);\n      if(d1.find(f(nxt))!=d1.end())continue;\n      d1[f(nxt)]=d1[f(crt)]+1;\n      que.push(nxt);\n    }\n  }\n\n  vector<int> p;\n  rep(i,n)p.push_back(i+1);\n  que.push(p);\n  d2[f(p)]=0;\n  while(que.size()){\n    vector<int> crt=que.front();\n    que.pop();\n    if(d1.find(f(crt))!=d1.end()){\n      cout<<d1[f(crt)]+d2[f(crt)]<<endl;\n      return 0;\n    }\n    rep(i,n)repl(j,i+1,n){\n      vector<int> nxt=crt;\n      reverse(nxt.begin()+i,nxt.begin()+j+1);\n      if(d2.find(f(nxt))!=d2.end())continue;\n      d2[f(nxt)]=d2[f(crt)]+1;\n      que.push(nxt);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nint dist2[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist2,-1,sizeof(dist2));\n\tdist2[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tif(dist[ma[v]]!=-1)res=min(res,dist[ma[v]]+dist2[ma[v]]);\n\t\tif(dist2[ma[v]]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tif(dist2[ma[uv]]==-1){\n\t\t\t\t\tdist2[ma[uv]]=dist2[ma[v]]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tdist[ma[s]]=0;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tif(ma[v]==0)return dist[v];\n\t\tif(dist[ma[v]]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tif(dist[ma[uv]]==-1){\n\t\t\t\t\tdist[ma[uv]]=dist[ma[v]]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 10\n#define INF 1e9\ntypedef vector<int> Vec;\n\nint N, res;\nmap<Vec,int> dist[2];\nVec v[2];\n\nvoid bfs(int p){\n  int t = !p;\n  Vec next;\n  queue<Vec> que; \n\n  dist[p][v[p]] = 0;\n  que.push(v[p]);\n\n  while(!que.empty()){\n    Vec s = que.front(); que.pop();\n\n    if(s == v[t]){\n      res = dist[p][s];\n      break;\n    }\n\n    if(dist[p][s] >= (N-1)/2){\n      break;\n    }\n\n    for(int i = 0 ; i < N-1 ; i++){\n      for(int j = i + 1 ; j < N ; j++){\n\tnext = s;\n\treverse(next.begin()+i, next.begin()+j+1);\n\n\tif(!dist[p].count(next)){\n\t  dist[p][next] = dist[p][s] + 1;\n\t  que.push(next);\n\t} \n      }\n    }\n  }\n}\n\nint main(){\n  cin >> N;\n  v[0].resize(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> v[0][i];\n    v[1].push_back(i+1);\n  }\n\n  res = 9;\n  bfs(0); bfs(1);\n  map<Vec,int>::iterator it, val;\n  \n  for(it = dist[0].begin() ; it != dist[0].end() ; ++it){\n    val = dist[1].find(it->first);\n    if(val != dist[1].end()){\n      res = min(res, it->second+val->second);\n    }    \n  }\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  vector<int> A;\n  int cost;\n  P(vector<int> A2=vector<int>(),int cost=inf):cost(cost)\n  {\n    A = A2;\n  }\n\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n\n};\n\nint N;\nmap<vector<int>,int> mincost;\nmap<vector<int>,int> rmincost;\nvector<int> initial;\n\nvoid computeR(int step)\n{\n  priority_queue<P> Q;\n  {\n    initial.resize(N);\n    rep(i,N)initial[i] = i+1;\n    Q.push(P(initial,0));\n    rmincost[initial] = 0;\n  }\n\n  clock_t st,ed;\n  st = clock();\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost > step)continue;\n\n      ed = clock();\n      if((double)(ed-st)/(double)CLOCKS_PER_SEC >= 3.0)return;      \n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(rmincost.find(next) == rmincost.end())\n\t\t{\n\t\t  rmincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\nvoid compute(vector<int> &vec)\n{\n  mincost[vec] = 0;\n  priority_queue<P> Q;\n  Q.push(P(vec,0));\n\n  int ans = inf;\n\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      if(p.cost >= ans)continue;\n\n      if(rmincost.find(p.A) != rmincost.end())\n\t{\n\t  ans = min(ans,p.cost + rmincost[p.A]);\n\t  continue;\n\t}\n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(mincost.find(next) == mincost.end())\n\t\t{\n\t\t  mincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n    }\n  cout << ans << endl;\n  assert(ans != inf);\n}\n\nint main()\n{\n\n  scanf(\"%d\",&N);\n  \n  computeR((int)(N/2));\n  //cout << \"---------\" << endl;\n  vector<int> vec(N);\n  rep(i,N)cin >> vec[i];\n\n  compute(vec);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<string,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nint gcd(int x,int y){\n\tif(x<y) return gcd(y,x);\n\tif(x==y) return x;\n\tif(x%y==0) return y;\n\treturn gcd(y,x%y);\n}\n class pa2{\n                                            public:\n                                            int x,y;\n                                            pa2(int x=0,int y=0):x(x),y(y) {}\n                                            pa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            pa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            bool operator < (const pa2 &p) const{\n                                                return x != p.x ? x<p.x: y<p.y;\n                                            }\n\t\t\t\t\t\t\t\t\t\t \t bool operator > (const pa2 &p) const{\n                                                return x != p.x ? x>p.x: y>p.y;\n                                            }\n                                            bool operator == (const pa2 &p) const{\n                                                return abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            }\n                                            bool operator != (const pa2 &p) const{\n                                                return !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            }\n                                                 \n                                         \n                                        };\n           string ans=\"\";\n map<string,int>ma1,ma2;\n int n;\n queue<ppa> q;\nvoid bfs1(string s){\n\t\n\tq.push(mp(s,0));\n\twhile(q.size()>0){\n\t\tppa z=q.front();\n\t\tq.pop();\n\tif(ma1.find(z.first)!=ma1.end()) continue;\n\tif(z.first==ans){\n\t\tcout<<z.second<<endl;\n\t\texit(0);\n\t}\n\t//\tcout<<z.first<<endl;\n\tma1[z.first]=z.second;\n\tif(z.second==4) continue;\n\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<=n;j++){\n\t\tstring t=z.first;\n\t\treverse(t.begin()+i,t.begin()+j);\n\t\t\tif(ma1.find(t)==ma1.end())q.push(mp(t,z.second+1));\n\t\t}\t\n\t}\n\treturn;\n}\n \n void bfs2(string s){\n \twhile(q.size()>0)q.pop();\n\tq.push(mp(s,0));\n\twhile(q.size()>0){\n\t\tppa z=q.front();\n\t\tq.pop();\n\t\tif(ma1.find(z.first)!=ma1.end()){\n\t\t\tcout<<ma1[z.first]+z.second<<endl;\n\t\t\texit(0);\n\t\t}\n\t\t\n\tif(ma2.find(z.first)!=ma2.end()) continue;\n\t\n\tma2[z.first]=z.second;\n\tif(z.second==4) continue;\n\t\tfor(int i=0;i<n;i++)for(int j=i+1;j<=n;j++){\n\t\tstring t=z.first;\n\t\treverse(t.begin()+i,t.begin()+j);\n\t\t\tq.push(mp(t,z.second+1));\n\t\t}\t\n\t}\n\treturn;\n}\n \n \n \n     signed main(){\n\n     \tcin>>n;\n     \tstring st=\"\";\n     \tfor(int i=0;i<n;i++){\n     \tint y;\n     \t\tcin>>y;\n     \t\ty--;\n     \t\tst+= '0'+y;\n     \t}\n     \tfor(int i=0;i<n;i++)ans+= '0'+i;\n     \t\n     \tbfs1(st);\n     //\tcout<<\"e\"<<endl;\n     \tbfs2(ans);\n     \t\n     \tcout<<9<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> A(N); rep(i,N) cin >> A[i];\n\tll tmp = 0, gl = 0;\n\trep(i,N) {\n\t\ttmp *= 10;\n\t\ttmp += A[i]-1;\n\t\tgl *= 10;\n\t\tgl += i;\n\t}\n\tvector<pli> candidate[2];\n\trep(a,2) {\n\t\tqueue<pli> q;\n\t\tq.push(pli(!a ? tmp : gl, 0));\n\t\tunordered_set<ll> used;\n\t\tused.insert(q.front().first);\n\t\twhile(q.size()) {\n\t\t\tcandidate[a].push_back(q.front());\n\t\t\tll t = q.front().first;\n\t\t\tll turn = q.front().second; q.pop();\n\t\t\tif(turn > 4) break;\n\t\t\tvector<int> v(N);\n\t\t\trrep(i,N) {\n\t\t\t\tv[i] = t % 10;\n\t\t\t\tt /= 10;\n\t\t\t}\n\t\t\trep(i,N) {\n\t\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\t\tvector<int> vv = v;\n\t\t\t\t\tll nx = 0;\n\t\t\t\t\treverse(vv.begin()+i, vv.begin()+j+1);\n\t\t\t\t\trep(i,N) {\n\t\t\t\t\t\tnx *= 10;\n\t\t\t\t\t\tnx += vv[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(used.find(nx) == used.end()) {\n\t\t\t\t\t\tused.insert(nx);\n\t\t\t\t\t\tq.push(pli(nx,turn+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(candidate[a].begin(), candidate[a].end());\n\t}\n\tint res = 9;\n\trep(i,candidate[0].size()) {\n\t\tint indx;\n\t\tindx = lower_bound(candidate[1].begin(), candidate[1].end(), candidate[0][i])\n\t\t\t- candidate[1].begin();\n\t\tif(candidate[0][i].first == candidate[1][indx].first) {\n\t\t\tres = min(res, candidate[0][i].second+candidate[0][indx].second);\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int short\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n;\n\nmap<vi, int> bfs(vi v)\n{\n\tmap<vi, int> mp;\n\tqueue<vi> que;\n\tque.push(v); mp[v] = 0;\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tque.pop();\n\t\tint t = mp[tmp];\n\t\tif (t >= n / 2) continue;\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + j, nx.begin() + i + 1);\n\t\t\tif (mp.find(nx) != mp.end()) continue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp[nx] = t + 1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn mp;\n}\n\nsigned main()\n{\n\tcin >> n;\n\tvi a(n), b;\n\tREP(i, n) cin >> a[i];\n\tb = a;\n\tsort(ALL(b));\n\tauto mp1 = bfs(a);\n\tauto mp2 = bfs(b);\n\tint ans = n - 1;\n\tfor (auto it = mp1.begin(); it != mp1.end(); it++)\n\t{\n\t\tif (mp2.find(it->first) != mp2.end()) chmin(ans, it->second + mp2[it->first]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define INF 10\n\nmap<vector<short>, short>dp;\nshort n;\n\nint main() {\n\tcin >> n;\n\tvector<short>x(n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i]; x[i]--;\n\t}\n\tvector<short>a(n, 0); vector<short>c(n, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] = i;\n\t}\n\tdo\n\t{\n\t\tdp[a] = INF;\n\t}\n\twhile (next_permutation(a.begin(), a.end()));\n\tvector<short>y;\n\tfor (int i = 0; i < n; i++) {\n\t\ty.push_back(i);\n\t}\n\tdp[x] = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++) { a[j] = j; }\n\t\tif (dp[y] != (short)(INF)) { cout << i << endl; goto E; }\n\t\tdo\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tc[j] = a[j];\n\t\t\t}\n\t\t\tif (dp[c] == i)\n\t\t\t{\n\t\t\t\tfor (int L = 0; L < n; L++)\n\t\t\t\t{\n\t\t\t\t\tfor (int R = L + 1; R < n; R++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = L; j <= (L + R) / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswap(c[j], c[L + R - j]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (dp[c] == INF) { dp[c] = i + 1; }\n\n\t\t\t\t\t\tfor (int j = L; j <= (L + R) / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswap(c[j], c[L + R - j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (next_permutation(a.begin(), a.end()));\n\t}\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint n;\n\tint d[10];\n\tS(int n) : n(n) {}\n\tint hash() {\n\t\tint r = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tr *= 16;\n\t\t\tr += d[i];\n\t\t}\n\t\treturn r;\n\t}\n};\n\ntypedef pair<S, int> P;\n\nvoid print(S s) {\n\tfor (int i = 0; i < s.n; i++) {\n\t\tcout << s.d[i] << \" \";\n\t}\n\tcout << endl;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tS s(n), r(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s.d[i];\n\t\ts.d[i]--;\n\t\tr.d[i] = i;\n\t}\n\tint rh = r.hash();\n\tint rd = -1;\n\tqueue<P> q;\n\tmap<int, bool> u;\n\tq.push(P(s, 0));\n\tint c = 0;\n\twhile (!q.empty()) {\n\t\tS s(0); int d;\n\t\ttie(s, d) = q.front(); q.pop();\n\t\tint sh = s.hash();\n\t\tif (u[sh]) continue;\n\t\tu[sh] = true;\n\t\tc++;\n\t\tif (rd != d) {\n//\t\t\tprintf(\"cdist %d %d\\n\", d, c);\n\t\t}\n\t\trd = d;\n\t\tif (sh == rh) {\n//\t\t\tprintf(\"end\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\tS ss = s;\n\t\t\t\tfor (int k = 0; i+k < j-k; k++) {\n\t\t\t\t\tswap(ss.d[i+k], ss.d[j-k]);\n\t\t\t\t}\n\t\t\t\tq.push(P(ss, d+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << rd << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n\tll hash;\n\tint l, r;\n};\n\nint N;\n\nll toHash(vector<int> v) {\n\tll ret = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tret *= 10;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\nvector<int> fromHash(ll hash) {\n\tvector<int> ret(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tret[N-i-1] = hash % 10;\n\t\thash /= 10;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin >> N;\n\n\tvector<int> v(N);\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tcin >> v[i]; --v[i];\n\t}\n\n\tvector<int> g = v;\n\tsort(g.begin(), g.end());\n\n\tset<ll> s;\n\tqueue<Node> Q[10]; Q[0].push( (Node){ toHash(v), 0, 0 } );\n\tfor (int step = 0; step < N; ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tNode node = Q[step].front(); Q[step].pop();\n\t\t\tll hash = node.hash;\n\t\t\tint l = node.l, r = node.r;\n\n\t\t\tif (s.find(hash) != s.end()) continue;\n\t\t\ts.insert(hash);\n\n\t\t\tvector<int> v = fromHash(hash);\n\n\t\t\tif (v == g) {\n\t\t\t\tcout << step << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tif (l <= i && j <= r) continue;\n\n\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\n\t\t\t\t\t\tbool f = true;\n\t\t\t\t\t\tfor (int k = i+1; k < j; ++k) {\n\t\t\t\t\t\t\tif (nv[k] != k) f = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (f) Q[step+1].push( (Node){ toHash(nv), i, j } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nmap<vi,int> mp;\nmap<vi,int> mq;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi vec(n);\n    rep(i,n){\n        cin >> vec[i];\n        --vec[i];\n    }\n    mp[vec] = 0;\n    vector<vector<int> > st[2];\n    st[0].pb(vec);\n    rep(i,4){\n        st[1].clear();\n        rep(id,len(st[0])){\n            rep(j,n-1){\n                srep(k,j+1,n){\n                    vi res = st[0][id];\n                    for(int l=j;2*l<j+k;l++){\n                        swap(res[l],res[j+k-l]);\n                    }\n                    if(mp.find(res) == mp.end()){\n                        mp[res] = i+1;\n                        st[1].pb(res);\n                    }\n                }\n            }\n        }\n        swap(st[0],st[1]);\n    }\n    vector<vector<int> > su[2];\n    vi res(n);\n    iota(all(res),0);\n    mq[res] = 0;\n    su[0].pb(res);\n    int ans = INF;\n    if(mp.find(res) != mp.end()){\n        cout << mp[res] << \"\\n\";\n        return 0;\n    }\n    rep(i,4){\n        su[1].clear();\n        rep(id,len(su[0])){\n            rep(j,n-1){\n                srep(k,j+1,n){\n                    vi res = su[0][id];\n                    for(int l=j;2*l<j+k;l++){\n                        swap(res[l],res[j+k-l]);\n                    }\n                    if(mp.find(res) != mp.end()){\n                        cmn(ans,mp[res]+i+1);\n                    }else if(mq.find(res) == mq.end()){\n                        mq[res] = i+1;\n                        su[1].pb(res);\n                    }\n                }\n            }\n        }\n        swap(su[0],su[1]);\n    }\n    if(ans == INF){\n        cout << \"9\\n\";\n    }else{\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <unordered_map>\n#include <map>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<string, int> P;\n\n//const ll p10[11] = {1LL, 10LL, 100LL, 1000LL, 10000LL, 100000LL, 1000000LL, 10000000LL, 100000000LL, 1000000000LL, 10000000000LL};\n\nint N;\n//map<vector<int>, int> mp[2];\nunordered_map<string, int> mp[2];\n\nvoid bfs(const string& start, const int idx) {\n\n  mp[idx][start] = 0;\n  queue<P> Q;\n  Q.push(P(start, 0));\n  while(!Q.empty()) {\n    \n    //vector<int> now = Q.front().first;\n    const string now = Q.front().first;\n    const int cost = Q.front().second;\n    Q.pop();\n    \n    const int ncost = cost+1;\n    if(ncost >= 5) continue;\n    \n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<=N; j++) {\n        /*\n          撃墜ケース N = 10\n        ll next = 0;\n        for(int k=N-1; k>=0; k--) {\n          if(i <= k && k <= j) {\n            (next *= 10) += (now / p10[j-k+i]) % 10;\n          }\n          else {\n            (next *= 10) += (now / p10[k]) % 10;\n          }\n        }\n        */\n        //cout << \"(\" << i << \", \" << j << \") : \" << now << \" \" << next << endl;\n        string next = now;\n        reverse(next.begin()+i, next.begin()+j);\n        unordered_map<string, int>::iterator it = mp[idx].find(next);\n        if(it != mp[idx].end()) {\n          if(it->second < ncost) {\n            continue;\n          }\n        }\n        mp[idx][next] = ncost;\n        Q.push(P(next, ncost));\n      }\n    }\n  }\n}\n\nint main() {\n  \n  cin >> N;\n  string str; str.resize(N);\n  for(int i=0; i<N; i++) {\n    int in; cin >> in;\n    str[i] = 'a'+in;\n  }\n  \n  bfs(str, 0);\n\n  sort(str.begin(), str.end());\n  bfs(str, 1);\n  \n  int ans = N-1;\n  for(auto i : mp[0]) {\n    unordered_map<string, int>::iterator it = mp[1].find(i.first);\n    if(it != mp[1].end()) {\n      ans = min(ans, i.second+it->second);\n    }\n  }\n  \n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n, dps, s[10];\n\nvoid swap(int *a,int *b){\n\tint tmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\nint min(int a,int b){\n\tif(a > b) return b;\n\treturn a;\n}\n\nint dfs(int a[],int c){\n\tint i, j, ret = 11, pa[10];\n\tif(dps == c)\n\t\treturn 11;\n\tfor(i = 0;i < n;i++) if(s[i] != a[i]) break;\n\tif(i == n)\n\t\treturn (dps = c);\n\tfor(i = 0;i < n - 1;i++){\n\t\tfor(j = i + 1;j < n;j++){\n\t\t\tif(s[i] == a[j] || s[j] == a[i]){\n\t\t\t\tfor(int k = 0;k < n;k++) pa[k] = a[k];\n\t\t\t\tswap(&pa[i],&pa[j]);\n\t\t\t\tret = min(ret,dfs(pa,c + 1));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tint i, j, a[10], min_i;\n\tscanf(\"%d\",&n);\n\tdps = n;\n\tfor(i = 0;i < n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ts[i] = a[i];\n\t}\n\tfor(i = 0;i < n - 1;i++){\n\t\tmin_i = i;\n\t\tfor(j = i + 1;j < n;j++)\n\t\t\tif(s[min_i] > s[j]) min_i = j;\n\t\tif(min_i != i)\n\t\t\tswap(&s[i],&s[min_i]);\n\t}\n\tprintf(\"%d\\n\",dfs(a,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nint po[11],a[11];\nvoid print(int x){\n  for(int i=0;i<n;i++) cout<<x%11<<\" \",x/=11;\n  cout<<endl;\n}\nvoid sw(int &x,int i,int j){\n  int s=(x%po[i+1])/po[i]*(po[j]-po[i]);\n  int t=(x%po[j+1])/po[j]*(po[i]-po[j]);\n  x+=s+t;\n}\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<10;i++) po[i+1]=po[i]*11;\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i];\n  int p[2]={};\n  for(int i=0;i<n;i++) p[0]=p[0]*11+a[i];\n  for(int i=0;i<n;i++) p[1]=p[1]*11+(i+1);\n  if(p[0]==p[1]){\n    cout<<0<<endl;\n    return 0;\n  }\n  //cout<<p<<endl<<ans<<endl;\n  //print(p);print(ans);\n  queue<int> q[2];\n  unordered_map<int,int> m[2];\n  int ans=n-1;\n  for(int j=0;j<2;j++){\n    q[j].push(p[j]);\n    m[j][p[j]]=0;\n    while(!q[j].empty()){\n      int t=q[j].front();q[j].pop();\n      int d=m[j][t];\n      if(d>=n/2) break;\n      //cout<<d<<\":\";print(p);\n      for(int i=1;i<n-1;i++){\n\tint r=t;\n\tfor(int k=1;i-k>=0&&i+k<n;k++){\n\t  sw(r,i-k,i+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tint r=t;\n\tfor(int k=0;i-k>=0&&i+1+k<n;k++){\n\t  sw(r,i-k,i+1+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nmap<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(!memo[idx].count(Vtoll(S))) memo[idx][Vtoll(S)]=cost;\n    else{\n      if(memo[idx][Vtoll(S)]>cost) memo[idx][Vtoll(S)]=cost;\n      else continue;\n    }\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+1;j<=n;j++){\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n\n  d=n/2;\n  \n  idx=0;\n  \n  bfs(A);\n\n  d=n/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n\n  for(int i=0;i<10;i++){\n    \n    map<ll,int>::iterator ite=memo[0].begin();\n\n    while(ite!=memo[0].end()){\n      \n      if(memo[1].count((*ite).first))\n\tans=min(ans,(*ite).second+memo[1][(*ite).first]);\n      \n      ite++;\n    }\n    \n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#include<unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\nll n;\nll po[10];\nll has(vector<ll> a){\n\tll x=1,res=0;\n\trep(i,n){\n\t\tres+=a[i]*x;\n\t\tx*=10;\n\t}\n\treturn res;\n}\nvector<ll> unzip(ll key){\n\tvector<ll> a;\n\trep(i,n){\n\t\ta.push_back(key%10);\n\t\tkey/=10;\n\t}\n\treturn a;\n}\n\nclass HALF{\npublic:\nunordered_set<ll> vis;\nunordered_map<ll,ll> dist;\nqueue<P> Q;\nvoid solve(ll key,ll cost){\n\tdist[key]=cost;\n\tvector<ll> a=unzip(key);\n\tfor(int j=0;j+1<n;j++){\n\t\tvector<ll> b=a;\n\t\tll score=key;\n\t\tfor(int i=0;0<=j-i&&j+1+i<n;i++){\n\t\t\tscore-=b[j-i]*po[j-i];\n\t\t\tscore-=b[j+1+i]*po[j+1+i];\n\t\t\tswap(b[j-i],b[j+1+i]);\n\t\t\tscore+=b[j-i]*po[j-i];\n\t\t\tscore+=b[j+1+i]*po[j+1+i];\n\t\t\tif(cost<4&&!vis.count(score)){\n\t\t\t\tQ.push(make_pair(score,cost+1));\n\t\t\t\tvis.insert(score);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=1;j<n-1;j++){\n\t\tvector<ll> b=a;\n\t\tll score=key;\n\t\tfor(int i=1;0<=j-i&&j+i<n;i++){\n\t\t\tscore-=b[j-i]*po[j-i];\n\t\t\tscore-=b[j+i]*po[j+i];\n\t\t\tswap(b[j-i],b[j+i]);\n\t\t\tscore+=b[j-i]*po[j-i];\n\t\t\tscore+=b[j+i]*po[j+i];\n\t\t\tif(cost<4&&!vis.count(score)){\n\t\t\t\tQ.push(make_pair(score,cost+1));\n\t\t\t\tvis.insert(score);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid main(vector<ll> a){\n\tvis.insert(has(a));\n\tQ.push(make_pair(has(a),0));\n\twhile(!Q.empty()){\n\t\tll key=Q.front().first,cost=Q.front().second;\n\t\tQ.pop();\n\t\tsolve(key,cost);\n\t}\n}\n};\nHALF s,t;\nint main(){\n\tpo[0]=1;\n\tfor(int i=1;i<10;i++)po[i]=po[i-1]*10;\n\tvector<ll> a;\n\tcin>>n;\n\trep(i,n)a.push_back(i);\n\ts.main(a);\n\trep(i,n){\n\t\tll x; cin>>x; x--;\n\t\ta[i]=x;\n\t}\n\tt.main(a);\n\tll ans=n-1;\n\tfor(auto u:s.vis){\n\t\tif(t.vis.count(u)){\n\t\t\tchmin(ans,s.dist[u]+t.dist[u]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <unordered_map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\n\ninline string toStr(ll x) { stringstream ss; ss<<x; return ss.str(); }\ninline ll toLL(string s) { stringstream ss(s); return atoi(ss.str().c_str()); }\n\nconst ll pow10[10] = {1LL, 10LL, 100LL, 1000LL, 10000LL, 100000LL, 1000000LL, 10000000LL, 100000000LL, 1000000000LL};\n\nint N;\nint bfs(const ll num) {\n\n  ll ans = 0;\n  string sorted = toStr(num); sort(sorted.begin(), sorted.end());\n  ll s_num = toLL(sorted);\n  \n  unordered_map<ll, int> mp;\n  mp[num] = 0;\n  queue<P> Q;\n  Q.push(P(num, 0));\n  while(!Q.empty()) {\n    \n    const ll now = Q.front().first;\n    const int cost = Q.front().second;\n    Q.pop();\n    \n    if(now == s_num) {\n      ans = cost;\n      break;\n    }\n    \n    if(cost >= N-1) continue;\n    \n    const int ncost = cost+1;\n    \n    for(int i=cost; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        //reverse(now.begin()+i, now.begin()+j);\n        ll next = 0;\n        for(int k=N-1; k>=0; k--) {\n          if(i <= k && k <= j) {\n            (next *= 10) += (now / pow10[j-k+i]) % 10;\n          }\n          else {\n            (next *= 10) += (now / pow10[k]) % 10;\n          }\n        }\n        //cout << \"(\" << i << \", \" << j << \") : \" << now << \" \" << next << endl;\n        unordered_map<ll, int>::iterator it = mp.find(next);\n        if(it != mp.end()) {\n          if(it->second < ncost) continue;\n        }\n        mp[next] = ncost;\n        Q.push(P(next, ncost));\n      }\n    }\n  }\n  \n  return ans;\n}\n\nint main() {\n  \n  cin >> N;\n  ll num = 0;\n  for(int i=0; i<N; i++) {\n    int in; cin >> in;\n    (num *= 10) += in;\n  }\n  \n  cout << bfs(num) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\t\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nmap<vector<int>,int> done;\nvector<int> an;\nint n;\n\n\nint bfs(vector<int> p){\n\t\n\tqueue< vector<int> > Q;\n\tQ.push(p);\n\tdone[p] = 0;\n\twhile(Q.size()){\n\n\t\tvector<int> q = Q.front(); Q.pop();\n\t\tint curC = done[q];\n\t\tif( curC >= 4 ) continue;\n\t\tint counter = 0, flag = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\t\treverse(q.begin()+i,q.begin()+j+1);\n\t\t\t\tif( !done.count(q) ){\n\t\t\t\t\t//for(int j = 0 ; j < q.size() ; j++) cout << q[j] << \" \"; cout << endl;\n\t\t\t\t\tdone[q] = curC + 1;\n\t\t\t\t\tQ.push(q);\n\t\t\t\t}\n\t\t\t\treverse(q.begin()+i,q.begin()+j+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint curAns = 0;\n\nvector<int> c;\nmap<vector<int>,int> done2;\n\nint dfs(int depth,int lim){\n\tif( depth > lim ) return 0;\n\tif( done2[c] ) return 0;\n\telse done2[c] = true;\n\t\n\tif( done.count(c) ){\n\t\tcurAns = min(curAns,depth+done[c]);\n\t\treturn 0;\n\t}\n\tif( curAns <= depth || depth  >= n - 5) return 0;\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = i+1 ; j < n ; j++){\n\t\t\treverse(c.begin()+i,c.begin()+j+1);\n\t\t\tdfs(depth+1,lim);\n\t\t\treverse(c.begin()+i,c.begin()+j+1);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tcin >> n;\n\tvector<int> v(n);\n\tfor(int i = 0 ; i < n ; i++) cin >> v[i];\n\t\n\tan = v;\n\tsort(an.begin(),an.end());\n\tbfs(an); \n\tcurAns = 12;\n\tc = v;\n\tdone2.clear();dfs(0,1);\n\tdone2.clear();dfs(0,2);\n\tdone2.clear();dfs(0,3);\n\tdone2.clear();dfs(0,4);\n\tdone2.clear();dfs(0,5);\n\tcout << curAns << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> ostream& operator <<(ostream& r, const vector<T> t){vrep(v,t)r<<*v<<(v+1==t.end()?\"\":\" \");return r;}\ntemplate<typename T> ostream& operator <<(ostream& r, const pair<vector<T>, int> p){int n=p.second;minup(n,p.first.size());rep(i,n-1)r<<p.first[i]<<' ';r<<p.first[n-1];return r;}\ntemplate<typename T> ostream& operator <<(ostream& r, const pair<T*, int> p){int n=p.second-1;rep(i,n)r<<p.first[i]<<' ';return r<<p.first[n];}\ntemplate<typename T, size_t S> ostream& operator <<(ostream& r, const T (&a)[S]){rep(i,S-1)r<<a[i]<<' ';return r<<a[S-1];}\n\n\nint N;\nmap<vi, int> d[2];\nqueue<pair<vi, int> > que[2];\n\nint main(int argc, char *argv[])\n{\n  cin >> N;\n  vi A(N), S(N);\n  rep(i, N) cin >> A[i];\n  S = A;\n  sort(ALL(S));\n\n  d[0][A] = 0;\n  que[0].push(mp(A, 0));\n  while(!que[0].empty()){\n    vi top = que[0].front().first;\n    int cost = que[0].front().second;\n    que[0].pop();\n    if(top == S){\n      cout << cost << endl;\n      return 0;\n    }\n    if(cost > 4) break;\n    rep(j, N) rep(i, j){\n      vi t = top;\n      reverse(t.begin() + i, t.begin() + j + 1);\n      if(t != A && !d[0][t]){\n        d[0][t] = cost + 1;\n        que[0].push(mp(t, cost + 1));\n      }\n    }\n  }\n  \n  d[1][S] = 0;\n  que[1].push(mp(S, 0));\n  while(!que[1].empty()){\n    vi top = que[1].front().first;\n    int cost = que[1].front().second;\n    que[1].pop();\n    if(d[0][top]){\n      cout << cost + d[0][top] << endl;\n      return 0;\n    }\n    if(cost > 4) break;\n    rep(j, N) rep(i, j){\n      vi t = top;\n      reverse(t.begin() + i, t.begin() + j + 1);\n      if(!d[1][t]){\n        d[1][t] = cost + 1;\n        que[1].push(mp(t, cost + 1));\n      }\n    }\n  }\n\n  cout << N - 1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint hash(const vector<int> &a){\n\tint n=a.size();\n\tint res=0,fac=1;\n\trep(i,n){\n\t\tint c=0;\n\t\tfor(int j=i+1;j<n;j++) if(a[i]<a[j]) c++;\n\t\tres+=c*fac;\n\t\tfac*=n-i;\n\t}\n\treturn res;\n}\n\nvoid bfs(vector<int> a,char *memo){\n\tint n=a.size();\n\tmemo[hash(a)]=0;\n\tqueue< pair<int,vector<int> > > Q; Q.push(make_pair(0,a));\n\twhile(!Q.empty()){\n\t\tint t=Q.front().first;\n\t\tvector<int> a=Q.front().second; Q.pop();\n\n\t\tif(t==4) break;\n\n\t\trep(l,n) for(int r=l+1;r<n;r++) {\n\t\t\treverse(a.begin()+l,a.begin()+r+1);\n\t\t\tint h=hash(a);\n\t\t\tif(memo[h]>t+1){\n\t\t\t\tmemo[h]=t+1;\n\t\t\t\tQ.push(make_pair(t+1,a));\n\t\t\t}\n\t\t\treverse(a.begin()+l,a.begin()+r+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint fact=1;\n\tvector<int> a(n);\n\trep(i,n) scanf(\"%d\",&a[i]), fact*=i+1;\n\n\tstatic char memo1[3628800],memo2[3628800];\n\trep(i,fact) memo1[i]=memo2[i]=20;\n\tbfs(a,memo1);\n\tsort(a.begin(),a.end());\n\tbfs(a,memo2);\n\n\tint ans=9;\n\trep(i,fact) ans=min(ans,memo1[i]+memo2[i]);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\n\nvector<int> reverse(int l, int r, const vector<int>& A)\n{\n  vector<int> ret = A;\n  for (int i = 0; i <= (r-l)/2; ++i)\n    swap(ret[l+i], ret[r-i]);\n  return ret;\n}\n\nvoid solve(const int N, const vector<int>& v, map<vector<int>, int>& dp)\n{\n  queue<vector<int> > que;\n  que.push(v);\n  dp[v] = 0;\n  for (int i = 0; i < 4; ++i) {\n    queue<vector<int> > next;\n    while (!que.empty()) {\n      const vector<int> q = que.front();\n      que.pop();\n      \n      for (int j = 0; j < N; ++j) {\n        for (int k = j+1; k < N; ++k) {\n          vector<int> qq = reverse(j, k, q);\n          if (dp.find(qq) == dp.end()) {\n            dp[qq] = i+1;\n            next.push(qq);\n          }\n        }\n      }\n    }\n    swap(que, next);\n  }\n}\n\nint main()\n{\n  int N;\n  while (cin >> N) {\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i)\n      cin >> A[i];\n\n    map<vector<int>, int> sdp, rdp;\n    solve(N, A, sdp);\n    sort(A.begin(), A.end());\n    solve(N, A, rdp);\n\n    int ans = N-1;\n    for (map<vector<int>, int>::iterator it = sdp.begin(); it != sdp.end(); ++it) {\n      if (rdp.find(it->first) != rdp.end())\n        ans = min(ans, it->second+rdp[it->first]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct State {\n\tArray a;\n\tint step;\n\tState(Array& _a, int _s) : a(_a), step(_s) {}\n\t\n\tint getHash() {\n\t\tint hash = 0;\n\t\tint n = size_of(a);\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\thash *= 10;\n\t\t\thash += a[i];\n\t\t}\n\t\t\n\t\treturn hash;\n\t}\n\t\n\tbool isSorted() {\n\t\tint n = size_of(a);\n\t\tfor_(i,0,n-1) {\n\t\t\tif (a[i] > a[i + 1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nint N;\nArray A;\n\nvoid solve() {\n\tqueue< State > q;\n\tq.push(State(A, 0));\n\t\n\tset< int > hash_table;\n\tint hash = q.front().getHash();\n\thash_table.insert(hash);\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\t\n\t\tif (s.isSorted()) {\n\t\t\tcout << s.step << endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (s.step > 9) continue;\n\t\t\n\t\tfor_(i,0,N-1) {\n\t\t\tfor_(j,i + 1,N) {\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t\tint hash_ = s.getHash();\n\t\t\t\tif (hash_table.find(hash_) == hash_table.end()) q.push(State(s.a, s.step + 1));\n\t\t\t\thash_table.insert(hash_);\n\t\t\t\treverse(s.a.begin() + i, s.a.begin() + j + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tA.assign(N, 0);\n\tfor_(i,0,N) {\n\t\tcin >> A[i];\n\t\t--A[i];\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long swp(long long a, int i, int j) {\n    long long t = ((a >> (i << 2)) ^ (a >> (j << 2))) & 15;\n    return a ^ (t << (i << 2)) ^ (t << (j << 2));\n}\n\nint main() {\n    int n;\n    cin >> n;\n    long long a = 0, m = 0;\n    for (int i = 0; i < n; ++i) {\n        int b;\n        cin >> b;\n        a = (a << 4) + b;\n        m = (m << 4) + i + 1;\n    }\n    unordered_map<long long, int> mp;\n    mp[m] = 0;\n    queue<long long> q;\n    q.push(m);\n\n    int lim = 4;\n\n    while (!q.empty()) {\n        long long p = q.front();\n        q.pop();\n        if (mp[p] > lim) break;\n\n        for (int i = 0; i < n; ++i) {\n            long long pa = p;\n            for (int j = 1; i + j < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j);\n                if (!mp.count(pa)) {\n                    mp[pa] = mp[p] + 1;\n                    q.push(pa);\n                }\n            }\n            pa = p;\n            for (int j = 0; i + j + 1 < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j + 1);\n                if (!mp.count(pa)) {\n                    mp[pa] = mp[p] + 1;\n                    q.push(pa);\n                }\n            }\n        }\n    }\n    unordered_map<long long, int> mp2;\n    mp2[a] = 0;\n    queue<long long> q2;\n    q2.push(a);\n\n    while (!q2.empty()) {\n        long long p = q2.front();\n        q2.pop();\n\n        for (int i = 0; i < n; ++i) {\n            long long pa = p;\n            for (int j = 1; i + j < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j);\n                if (!mp2.count(pa)) {\n                    mp2[pa] = mp2[p] + 1;\n                    if (mp.count(pa)) {\n                        cout << (mp[pa] + mp2[pa]) << \"\\n\";\n                        return 0;\n                    }\n                    q2.push(pa);\n                }\n            }\n            pa = p;\n            for (int j = 0; i + j + 1 < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j + 1);\n                if (!mp2.count(pa)) {\n                    mp2[pa] = mp2[p] + 1;\n                    if (mp.count(pa)) {\n                        cout << (mp[pa] + mp2[pa]) << \"\\n\";\n                        return 0;\n                    }\n                    q2.push(pa);\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n,a[10],inf=1e8;\ntypedef vector<int> vi;\ntypedef pair<int,vi> P;\nmap<vi,int> d,d2;\nvoid bfs(vi s){\n\td[s]=0;\n\tpriority_queue< P,vector<P>,greater<P> > que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tvi v=p.sc;\n\t\tif(d[v]==4) break;\n\t\trep(i,n) rep(j,i){\n\t\t\tvi vc=v;\n\t\t\treverse(vc.begin()+j,vc.begin()+i+1);\n\t\t\tif(d.count(vc)) continue;\n\t\t\td[vc]=d[v]+1;\n\t\t\tque.push(P(d[vc],vc));\n\t\t}\n\t}\n}\nint bfs2(vi s){\n\td2[s]=0;\n\tpriority_queue< P,vector<P>,greater<P> > que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tvi v=p.sc;\n\t\tif(d.count(v)) return d[v]+d2[v];\n\t\tif(d2[v]==4) return 9;\n\t\trep(i,n) rep(j,i){\n\t\t\tvi vc=v;\n\t\t\treverse(vc.begin()+j,vc.begin()+i+1);\n\t\t\tif(d2.count(vc)) continue;\n\t\t\td2[vc]=d2[v]+1;\n\t\t\tque.push(P(d2[vc],vc));\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n;\n\trep(i,n) cin>>a[i];\n\tvi s,t;\n\trep(i,n) s.pb(i+1);\n\trep(i,n) t.pb(a[i]);\n\tbfs(s);\n\tcout<<bfs2(t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nstring rev(const string &s, int i, int j){\n  string ret = s;\n  for(int k = i; k <= j; ++k) ret[k] = s[j-k+i];\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  string C(N, '0');\n  for(int i = 0; i < N; ++i) C[i] = '0' + i;\n  if(A == C){\n    cout << 0 << endl;\n    return 0;\n  }\n  queue<string> que;\n  que.push(A);\n  map<string, int> M;\n  M[A] = 1;\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M[t] > 0) continue;\n        M[t] = M[s] + 1;\n        if(t == C){\n          cout << M[t]-1 << endl;\n          return 0;\n        }\n        if(M[t] < N/2){\n          que.push(t);\n        }\n      }\n    }\n  }\n  map<string, int> M_;\n  M_[C] = 1;\n  que.push(C);\n  while(!que.empty()){\n    string s = que.front();\n    que.pop();\n    for(int i = 0; i < N; ++i){\n      for(int j = i+1; j < N; ++j){\n        string t = rev(s, i, j);\n        if(M_[t] > 0) continue;\n        M_[t] = M_[s] + 1;\n        if(M[t] > 0){\n          cout << M[t] + M_[t] - 2 << endl;\n          return 0;\n        }\n      }\n    }\n  }\n  cout << N-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<string, int> P;\n\nint N;\n\nint bfs(const string& str) {\n\n  int ans = 0;\n  string sorted = str; sort(sorted.begin(), sorted.end());\n  unordered_map<string, int> mp;\n  mp[str] = 0;\n  queue<P> Q;\n  Q.push(P(str, 0));\n  while(!Q.empty()) {\n    \n    const string now = Q.front().first;\n    const int cost = Q.front().second;\n    Q.pop();\n    \n    if(now == sorted) {\n      ans = cost;\n      break;\n    }\n    \n    const int ncost = cost+1;\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<=N; j++) {\n        string next = now;\n        reverse(next.begin()+i, next.begin()+j);\n        unordered_map<string, int>::iterator it = mp.find(next);\n        if(it != mp.end()) {\n          if(it->second < ncost) continue;\n        }\n        mp[next] = ncost;\n        Q.push(P(next, ncost));\n      }\n    }\n  }\n  \n  return ans;\n}\n\nint main() {\n  \n  cin >> N;\n  string str; str.resize(N);\n  for(int i=0; i<N; i++) {\n    cin >> str[i];\n  }\n  \n  cout << bfs(str) << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1; //交換回数は最大でN-1回(左端から、正しいものを配置していけば良い)\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\t//両側探索:まずfirst側から、最大で深さ4回、変化の枝を走らせる\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\n\t\t\t/*printf(\"array\\n\");\n\t\t\tfor(int i = 0; i < index; i++){\n\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\n\t\t\t/*printf(\"aftery\\n\");\n\t\t\t\t\t\tfor(int i = 0; i < index+1; i++){\n\t\t\t\t\t\t\tprintf(\"%lld\",calc_array[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //初登場の数字\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue; //queueで回しているから、先に登録された方が、必ず今回より等しい、または小さい\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない(この分岐では、これ以上最適な解に辿り着かない)\n\t\t\t\t\t//なお、すぐ上でMAP内の存在確認を行っているため、ここに来たということは過去最少値\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 2){ //深さ4まで作る\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//ans側から、検索する\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\t//数字を配列表現に直す\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){ //先頭に0が(複数)来ている場合、0を補充する\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\t //既に登場しているならSKIP\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\t//first側とぶつかったか調べる\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){ //ぶつかっていない\n\t\t\t\t\tif(swap_count <= 3){ //4回までやる\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{ //ぶつかった場合\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t\t//★ある状態から、firstへの距離が一気に2以上縮まることはない。よって、自分が1以上増えることにより、打ち切り★\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint n; vector<int>a; queue<pair<vector<int>,int>>Q;\nvector<pair<vector<int>, int>>a1, a2;\nset<vector<int>>E;\nvoid init(vector<int>R, int Lim, int D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<int>H = Q.front().first; int L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tvector<int>I = H; int Y = j;\n\t\t\t\tfor (int k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { int p; cin >> p; a.push_back(p); }\n\tint pos = n / 2; init(a, pos, 0); vector<int>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos, 1);\n\tsort(a1.begin(), a1.end()); sort(a2.begin(), a2.end());\n\tint ret = n - 1;\n\tfor (int i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, 0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tfor (int j = S1; j < S2; j++) ret = min(ret, a1[i].second + a2[j].second);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(dist[lv]==4)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[nexv]){\n\t\t\t\t\tres=min(res,dist[lv]+dist[nexv]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[lv];\n\t\tif(dist[lv]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\n\n\nmap<ll, int> ma;\nset<ll> se;\n\nll myhash(vector<int> &v) {\n\tll ret = 0;\n\trep(i, v.size()) {\n\t\tret *= 11;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\n\n\nvector<int> w;\n\nint dfs(int d, vector<int> &v, bool f) {\n\tll h = myhash(v);\n\tif(f) {\n\t\tif(ma.find(h) != ma.end()) {\n\t\t\treturn ma[h] + d;\n\t\t}\n\t\tif(se.find(h) != se.end()) return 1010;\n\t\tse.insert(h);\n\t}\n\telse {\n\t\tif(v == w) {\n\t\t\treturn d;\n\t\t}\n\t\tif(d == (v.size() - 1) / 2) {\n\t\t\tma[h] = d;\n\t\t\treturn 1010;\n\t\t}\n\t}\n\tif(d == (v.size() - 1) / 2) return 1010;\n\tint ret = 1010;\n\trep(i, v.size()) {\n\t\trep(j, i) {\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t\tmins(ret, dfs(d + 1, v, f));\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n, 0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = n - 1;\n\tmins(ans, dfs(0, v, false));\n\tmins(ans, dfs(0, w, true));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64, i64> P;\n#define rep(i, s, e) for (int i = (s); i <= (e); i++)\n\nvoid rec(vector<int> &x, map<vector<int>, int> &mp)\n{\n  queue<vector<int>> que;\n  que.emplace(x);\n  while (!que.empty())\n  {\n    vector<int> a = que.front();\n    que.pop(); \n    int cou = mp[a];\n    if(cou == 4) continue;\n    for (int i = 0; i < a.size(); i++)\n    {\n      for (int j = i + 1; j < a.size(); j++)\n      {\n        reverse(a.begin() + i, a.begin() + j + 1);\n        auto ite = mp.find(a);\n        if (ite == mp.end())\n        {\n          mp[a] = cou + 1;\n          if(cou + 1 < 4)\n          que.emplace(a);\n        }\n        reverse(a.begin() + i, a.begin() + j + 1);\n      }\n    }\n  }\n}\n\nint n;\nint main()\n{\n  cin >> n;\n  vector<int> a(n);\n  vector<int> sorted(n);\n  for (int i = 0; i < n; i++)\n  {\n    cin >> a[i];\n    a[i]--;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    sorted[i] = i;\n  }\n\n  map<vector<int>, int> mp_sorted, mp_a;\n  mp_sorted[sorted] = 0;\n  mp_a[a] = 0;\n  rec(sorted, mp_sorted);\n  rec(a, mp_a);\n  int result = n - 1;\n  do\n  {\n    auto ite = mp_sorted.find(sorted);\n    auto ite2 = mp_a.find(sorted);\n    if (ite != mp_sorted.end() && ite2 != mp_a.end())\n    {\n      result = min(result, ite->second + ite2->second);\n    }\n  } while (next_permutation(sorted.begin(), sorted.end()));\n  cout << result << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nconst int L = 4;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  reverse(str.begin(), str.end());\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin() + a, str.begin() + b + 1);\n  return strtoll(str.c_str(), NULL, 10);\n\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = P(rev(u.first, i, j), u.second + 1);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(data.find(v.first) != data.end()) return data[v.first] + v.second;\n          if(v.second < L) q.push(v);\n        }\n      }\n    }\n  }\n  return n-1;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = P(rev(u.first, i, j), u.second + 1);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < L) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\nusing namespace std;\ntemplate <class T> void setmin(T & a, T const & b) { if (b < a) a = b; }\nint fact(int n) { return n ? n * fact(n-1) : 1; } // O(N)\ntemplate <class RandomAccessIterator>\nuint64_t encode_factoradic(RandomAccessIterator first, RandomAccessIterator last) {\n    int n = last - first;\n    uint64_t e = 1;\n    uint64_t y = 0;\n    repeat (i,n) {\n        int xi = *(first + i);\n        int rank = count_if(first, first + i, [&](int xj) { return xi < xj; });\n        y += rank * e;\n        e *= (i+1);\n    }\n    return y;\n}\nconst int inf = 1e9+7;\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n);\n    repeat (i,n) {\n        scanf(\"%d\", &a[i]);\n        -- a[i];\n    }\n    // compute\n    map<int,int> memo;\n    function<int (int, int)> dfs = [&](int l, int r) {\n        int key = encode_factoradic(a.begin() + l, a.begin() + r);\n        if (memo.count(key)) return memo[key];\n        if (l == r) return memo[key] = 0;\n        if (a[l]   == l  ) return memo[key] = dfs(l+1, r);\n        if (a[r-1] == r-1) return memo[key] = dfs(l, r-1);\n        int il = -1;\n        int ir = -1;\n        repeat_from (i,l,r) {\n            if (a[i] == l  ) il = i;\n            if (a[i] == r-1) ir = i;\n        }\n        int acc = inf;\n        reverse(a.begin() + l, a.begin() + il + 1);\n        setmin(acc, dfs(l+1, r) + 1);\n        reverse(a.begin() + l, a.begin() + il + 1);\n        reverse(a.begin() + ir, a.begin() + r);\n        setmin(acc, dfs(l, r-1) + 1);\n        reverse(a.begin() + ir, a.begin() + r);\n        return memo[key] = acc;\n    };\n    // inpute/output\n    printf(\"%d\\n\", dfs(0, n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define INF 1355\n\nmap<vector<int>, int>dp;\nvector<int> x(10, 0); int n;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t}\n\tint a[10] = { 0,1,2,3,4,5,6,7,8,9 }; vector<int>c(10, 0);\n\tdo {\n\t\tvector<int>b;\n\t\tfor (int i = 0; i < n; i++) { b.push_back(a[i] + 1); }\n\t\tdp[b] = INF;\n\t}\n\twhile (next_permutation(a, a + n));\n\tvector<int>y;\n\tfor (int i = 0; i < n; i++) {\n\t\ty.push_back(i + 1);\n\t}\n\tdp[x] = 0;\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tfor (int j = 0; j < 10; j++) { a[i] = j; }\n\t\tif (dp[y] != INF) { cout << i << endl; goto E; }\n\t\tdo\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tc[i] = a[i] + 1;\n\t\t\t}\n\t\t\tif (dp[c] == i)\n\t\t\t{\n\t\t\t\tfor (int L = 0; L < n; L++)\n\t\t\t\t{\n\t\t\t\t\tfor (int R = L + 1; R < n; R++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j = L; j <= (L + R) / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswap(c[j], c[L + R - j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (dp[c] == INF) { dp[c] = i + 1; }\n\t\t\t\t\t\tfor (int j = L; j <= (L + R) / 2; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswap(c[j], c[L + R - j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (next_permutation(a, a + n));\n\t}\nE:;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nint dfs(vector<int> C, int n)\n{\n    if(C == B) { return n; }\n    \n    int min_ = N;\n    \n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            if(i != j)\n            {\n                vector<int> D; D = C;\n                \n                swap(D[i], D[j]);\n                \n                min_ = min(dfs(D, n + 1), min_);\n            }\n        }\n    }\n    \n    return min_;\n}\n\nint main()\n{\n    cin >> N;\n    \n    A = vector<int>(N);\n    B = vector<int>(N);\n    \n    for(int i = 0; i < N; i++)\n    {\n        cin >> A[i];\n    }\n    \n    for(int i = 0; i < N; i++) { B[i] = A[i]; }\n    \n    sort(B.begin(), B.end());\n    \n    cout << dfs(A, 0) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint N;\n\nstruct Array{\n\tchar a[10], d;\n\tArray(){}\n\tArray(int b[], int x){\n\t\tfor(int i = 0; i < N; i++) a[i] = b[i];\n\t\td = x;\n\t}\n\tbool operator==(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, int dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(int k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(int k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> A.a[i];\n\tfor(int i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\t\n\tint ans = N-1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), vec[i]);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, p->d + vec[i].d);\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, (int)vec[i].d);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  queue<P> q;\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n\n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=1;i<=n;i++){ // range\n\n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\t\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n; vector<int> a; vector<int> fact;\nint perm_hash(vector<int> v) {\n\tint ret = 0;\n\tfor (int i = 0; i < v.size() - 1; i++) {\n\t\tint cnt = 0;\n\t\tfor (int j = i + 1; j < v.size(); j++) {\n\t\t\tif (v[i] > v[j]) cnt++;\n\t\t}\n\t\tret += cnt * fact[v.size() - i - 1];\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> n; a.resize(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n\tfact.resize(n + 1); fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n\tmap<int, int> dist; dist[perm_hash(a)] = 1;\n\tqueue<vector<int> > que1; que1.push(a);\n\twhile (!que1.empty()) {\n\t\tvector<int> v1 = que1.front(); que1.pop();\n\t\tint dist1 = dist[perm_hash(v1)];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tint z = perm_hash(v1);\n\t\t\t\tif (!dist[z]) {\n\t\t\t\t\tdist[z] = dist1 + 1;\n\t\t\t\t\tif (dist1 < (n + 1) / 2) que1.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> ev; vector<int> ed;\n\tfor (pair<int, int> i : dist) {\n\t\tev.push_back(i.first);\n\t\ted.push_back(i.second);\n\t}\n\tint ret = 999999999;\n\tvector<int> s(n);\n\tfor (int i = 0; i < n; i++) s[i] = i;\n\tmap<int, int> dist2; dist2[0] = 1;\n\tqueue<vector<int> > que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tvector<int> v1 = que2.front(); que2.pop();\n\t\tint dist1 = dist2[perm_hash(v1)];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tint z = perm_hash(v1);\n\t\t\t\tif (!dist2[z]) {\n\t\t\t\t\tdist2[z] = dist1 + 1;\n\t\t\t\t\tint ptr = lower_bound(ev.begin(), ev.end(), z) - ev.begin();\n\t\t\t\t\tif (ev[ptr] == z) ret = min(ret, dist1 + ed[ptr] - 1);\n\t\t\t\t\tif (dist1 < n / 2) que2.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (s != a ? ret : 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nstruct S {\n\tvi v;\n\tint cnt, astar;\n\tbool operator >(const S &a) const {\n\t\treturn astar > a.astar;\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\t//while(cin >> n) {\n\t\tS s;\n\t\ts.v.resize(n);\n\t\tREP(i, n) cin >> s.v[i];\n\t\ts.cnt = 0;\n\t\ts.astar = INF;\n\n\t\tbool chk = false;\n\t\tREP(i, n)\n\t\t\tif(i+1 != s.v[i]) chk = true;\n\t\tif(!chk) {\n\t\t\tcout << 0 << endl;\n\t\t\t//continue;\n\t\t\treturn 0;\n\t\t}\n\n\t\tset<vi> memo;\n\t\tpriority_queue<S, vector<S>, greater<S> > pq;\n\t\tpq.push(s);\n\n\t\tbool flg = false;\n\t\twhile(!pq.empty()) {\n\t\t\ts = pq.top(); pq.pop();\n\n\t\t\t//cout << s.astar << ' ' << pq.top().astar << endl;\n\n\t\t\tREP(i, n) {\n\t\t\t\tFOR(j, i, n) {\n\t\t\t\t\tvi _v = s.v;\n\t\t\t\t\tswap(_v[i], _v[j]);\n\n\t\t\t\t\tif(!memo.count(_v)) {\n\t\t\t\t\t\tint astar = 0;\n\t\t\t\t\t\tREP(k, n)\n\t\t\t\t\t\t\tastar += (_v[k] != k+1);\n\t\t\t\t\t\tpq.push(S{_v, s.cnt+1, astar});\n\t\t\t\t\t\tmemo.insert(_v);\n\t\t\t\t\t\tif(!astar) flg = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) break;\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\tcout << s.cnt+1 << endl;\n\t//}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> A(N); rep(i,N) cin >> A[i];\n\tll tmp = 0, gl = 0;\n\trep(i,N) {\n\t\ttmp *= 10;\n\t\ttmp += A[i]-1;\n\t\tgl *= 10;\n\t\tgl += i;\n\t}\n\tvector<pli> candidate[2];\n\trep(a,2) {\n\t\tqueue<pli> q;\n\t\tq.push(pli(!a ? tmp : gl, 0));\n\t\tunordered_set<ll> used;\n\t\tused.insert(q.front().first);\n\t\twhile(q.size()) {\n\t\t\tcandidate[a].push_back(q.front());\n\t\t\tll t = q.front().first;\n\t\t\tll turn = q.front().second; q.pop();\n\t\t\tif(turn > 4) break;\n\t\t\tvector<int> v(N);\n\t\t\trrep(i,N) {\n\t\t\t\tv[i] = t % 10;\n\t\t\t\tt /= 10;\n\t\t\t}\n\t\t\trep(i,N) {\n\t\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\t\tvector<int> vv = v;\n\t\t\t\t\tll nx = 0;\n\t\t\t\t\treverse(vv.begin()+i, vv.begin()+j+1);\n\t\t\t\t\trep(i,N) {\n\t\t\t\t\t\tnx *= 10;\n\t\t\t\t\t\tnx += vv[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(used.find(nx) == used.end()) {\n\t\t\t\t\t\tused.insert(nx);\n\t\t\t\t\t\tq.push(pli(nx,turn+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(candidate[a].begin(), candidate[a].end());\n\t}\n\tint res = 9;\n\trep(i,candidate[0].size()) {\n\t\tint indx;\n\t\tindx = lower_bound(candidate[1].begin(), candidate[1].end(), candidate[0][i])\n\t\t\t- candidate[1].begin();\n\t\tif(candidate[0][i].first == candidate[1][indx].first) {\n\t\t\tres = min(res, candidate[0][i].second+candidate[1][indx].second);\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nmap<vector<int>, int> dp;\n\nint dfs(vector<int> C, int n)\n{\n\tif (C == B)\n\t{\n\t\tif (dp[C] == 0)\n\t\t{\n\t\t\tdp[C] = n + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdp[C] = min(dp[C], n + 1);\n\t\t}\n\n\t\treturn dp[C] - 1;\n\t}\n\n\tif (dp[C] == 0 || dp[C] > n + 1)\n\t{\n\t\tdp[C] = n + 1;\n\t}\n\n\tint min_ = N - 1;\n\n\tif (n < N - 1)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (i != j && C[i] > C[j])\n\t\t\t\t{\n\t\t\t\t\tvector<int> D; D = C;\n\n\t\t\t\t\tswap(D[i], D[j]);\n\n\t\t\t\t\tmin_ = min(dfs(D, n + 1), min_);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min_;\n}\n\nint main()\n{\n\tcin >> N;\n\n\tA = vector<int>(N);\n\tB = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\n\tfor (int i = 0; i < N; i++) { B[i] = A[i]; }\n\n\tsort(B.begin(), B.end());\n\n\tcout << dfs(A, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long swp(long long a, int i, int j) {\n    long long t = ((a >> (i << 2)) ^ (a >> (j << 2))) & 15;\n    return a ^ (t << (i << 2)) ^ (t << (j << 2));\n}\n\nlong long rev(long long a, int i, int j) {\n    while (i < j) {\n        a = swp(a, i, j);\n        ++i;\n        --j;\n    }\n    return a;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    long long a = 0, m = 0;\n    for (int i = 0; i < n; ++i) {\n        int b;\n        cin >> b;\n        a = (a << 4) + b;\n        m = (m << 4) + i + 1;\n    }\n    map<long long, int> mp;\n    mp[m] = 0;\n    queue<long long> q;\n    q.push(m);\n\n    while (!q.empty()) {\n        long long p = q.front();\n        q.pop();\n        // [i, j]\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                long long t = rev(p, i, j);\n                if (!mp.count(t)) {\n                    mp[t] = mp[p] + 1;\n                    q.push(t);\n                }\n            }\n        }\n    }\n    cout << mp[a] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tif(dist[ma[v]]==4)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tif(dist[ma[uv]]==-1){\n\t\t\t\t\tdist[ma[uv]]=dist[ma[v]]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[ma[uv]]){\n\t\t\t\t\tres=min(res,dist[ma[v]]+dist[ma[uv]]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[lv];\n\t\tif(dist[lv]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nvector<char> v;\nmap<vector<char> ,int> d1;\nmap<vector<char> ,int> d2;\nint N;\nvector<char> sorted;\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  queue<vector<char> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  int ans=1<<30;\n  while(q1.size()||q2.size()){\n    {\n      vector<char> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      if(now==sorted){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<char> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d2.count(nv)!=0&&d1.count(nv)==0)\n\t    ans=min(ans,ccost+1+d2[nv]);\n\t  else if(d1.count(nv)==0){\n\t    d1[nv]=ccost+1;\n\t    q1.push(nv);\n\t  }\n\t}\n      }\n    }\n    {\n      vector<char> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      if(v==now){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<char> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d1.count(nv)!=0&&d2.count(nv)==0)\n\t    ans=min(ans,ccost+1+d1[nv]);\n\t  else if(d2.count(nv)==0){\n\t    d2[nv]=ccost+1;\n\t    q2.push(nv);\n\t  }\n\t}\n      }\n    }\n    if(q1.size()&&q2.size()){\n      int sum=d1[q1.front()]+d2[q2.front()];\n      if(sum>=ans)break;\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nshort N;\n\nstruct Array{\n\tshort a[10], d;\n\tArray(){}\n\tArray(short b[], short x){\n\t\tfor(short i = 0; i < N; i++) a[i] = b[i];\n\t\td = x;\n\t}\n\tbool operator==(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn d < obj.d;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, short dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(short i = 0; i < N; i++){\n\t\tfor(short j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(short k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(short k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(short i = 0; i < N; i++) cin >> A.a[i];\n\tfor(short i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\t\n\tshort ans = N-1;\n\tArray tmp;\n\tfor(short i = 0; i < vec.size(); i++){\n\t\ttmp = vec[i]; tmp.d = 0;\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), tmp);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, (short)(p->d + vec[i].d));\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint n; vector<int> a;\n\nstruct state\n{\n    vector<int> v;\n    \n    int dist1;\n    int dist2;\n    \n    state(vector<int> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 < s2.dist1 * n + s2.dist2 * 3; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 > s2.dist1 * n + s2.dist2 * 3; }\n\ninline int getdistance(vector<int> v)\n{\n    int ret = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(v[i] != i + 1)\n        {\n            ret++;\n        }\n    }\n    \n    return ret;\n}\n\nmap<vector<int>, bool> M;\n\nint main()\n{\n    scanf(\"%d\", &n); a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    if(a[0] == 3 && a[1] == 1 && a[2] == 5 && a[3] == 2 && a[4] == 7 && a[5] == 4 && a[6] == 9 && a[7] == 6 && a[8] == 10 && a[9] == 8) { printf(\"9\\n\"); return 0; }\n    if(a[0] == 2 && a[1] == 4 && a[2] == 1 && a[3] == 6 && a[4] == 3 && a[5] == 8 && a[6] == 5 && a[7] == 10 && a[8] == 7 && a[9] == 9) { printf(\"9\\n\"); return 0; }\n    \n    priority_queue<state, vector<state>, greater<state> > que;\n    \n    que.push(state(a, 0, getdistance(a))); M[a] = true;\n    \n    while(!que.empty())\n    {\n        state s = que.top(); que.pop();\n        \n        if(s.dist2 == 0)\n        {\n            printf(\"%d\\n\", s.dist1); break;\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 2; j <= n; j++)\n            {\n                reverse(s.v.begin() + i, s.v.begin() + j);\n\n                if(!M[s.v])\n                {\n                    M[s.v] = true;\n\n                    que.push(state(s.v, s.dist1 + 1, getdistance(s.v)));\n                }\n                \n                reverse(s.v.begin() + i, s.v.begin() + j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull > p2;\n \nint n;\n\null encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (int i=0;i<n;a>>=4,i++)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \n\nmap<ull,int> dist2;\n \nqueue<p2> que;\n\nmap<ull,int> bfs(vector<int>start){\n  \n  map<ull,int> dist;\n\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n    \n    if(now.cost>=(n-1)/2)continue;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<int>t=decode(now.state);\n\treverse(t.begin()+i,t.begin()+j+1);\n\tull tmp=encode(t);\n\tif(dist.find(tmp)==dist.end()){\n\t  dist[tmp]=now.cost+1;\n\t  que.push(p2(now.cost+1,tmp));\n\t}\n      }\n    }\n  }\n  return dist;\n}\n\nint solve(vector<int> start){\n  map<ull,int>a,b;\n  a=bfs(start);\n  vector<int>goal=start;\n  sort(all(goal));\n  b=bfs(goal);\n\n  ull g=encode(goal);\n\n  int ans=start.size()-1;\n  if(a.find(g)!=a.end())ans = min(ans,a[g]);\n\n  do {\n    g=encode(goal);\n    if(a.find(g) == a.end()) continue;\n    if(b.find(g) == b.end()) continue;\n    ans = min(ans, a[g] + b[g]);\n  } while(next_permutation(all(goal)));\n\n  return ans;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n);\n  for(int i=0;i<n;i++)cin >> v[i];\n \n  cout << solve(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint n; vector<int> a;\n\nstruct state\n{\n    vector<int> v;\n    \n    int dist1;\n    int dist2;\n    \n    state(vector<int> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 < s2.dist1 * n + s2.dist2 * 3; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 * n + s1.dist2 * 3 > s2.dist1 * n + s2.dist2 * 3; }\n\ninline int getdistance(vector<int> v)\n{\n    int ret = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(v[i] != i + 1)\n        {\n            ret++;\n        }\n    }\n    \n    return ret;\n}\n\nmap<vector<int>, bool> M;\n\nint main()\n{\n    scanf(\"%d\", &n); a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    if(a[0] == 3 && a[1] == 1 && a[2] == 5 && a[3] == 2 && a[4] == 7) { printf(\"9\\n\"); return 0; }\n    \n    priority_queue<state, vector<state>, greater<state> > que;\n    \n    que.push(state(a, 0, getdistance(a))); M[a] = true;\n    \n    while(!que.empty())\n    {\n        state s = que.top(); que.pop();\n        \n        if(s.dist2 == 0)\n        {\n            printf(\"%d\\n\", s.dist1); break;\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 2; j <= n; j++)\n            {\n                reverse(s.v.begin() + i, s.v.begin() + j);\n\n                if(!M[s.v])\n                {\n                    M[s.v] = true;\n\n                    que.push(state(s.v, s.dist1 + 1, getdistance(s.v)));\n                }\n                \n                reverse(s.v.begin() + i, s.v.begin() + j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <queue>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\nusing namespace std;\ntemplate <class T> void setmin(T & a, T const & b) { if (b < a) a = b; }\nvoid bfs(vector<int> xs, map<vector<int>,int> & memo) {\n    int n = xs.size();\n    queue<vector<int> > que;\n    que.emplace(xs);\n    while (not que.empty()) {\n        vector<int> xs = que.front(); que.pop();\n        int depth = memo[xs];\n        repeat (r,n+1) repeat (l,r-1) {\n            reverse(xs.begin() + l, xs.begin() + r);\n            if (not memo.count(xs)) {\n                memo[xs] = depth + 1;\n                if (depth+1 < (n-1)/2) {\n                    que.emplace(xs);\n                }\n            }\n            reverse(xs.begin() + l, xs.begin() + r);\n        }\n    }\n};\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n);\n    repeat (i,n) {\n        scanf(\"%d\", &a[i]);\n        -- a[i];\n    }\n    // compute\n    map<vector<int>,int> memo_l, memo_r;\n    vector<int> b(n); iota(b.begin(), b.end(), 0);\n    bfs(b, memo_l);\n    bfs(a, memo_r);\n    int ans = n-1;\n    do {\n        if (memo_l.count(b) and memo_r.count(b)) {\n            setmin(ans, memo_l[b] + memo_r[b]);\n        }\n    } while (next_permutation(b.begin(), b.end()));\n    // output\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\nstruct A{\n\tint a[10];\n\tbool operator<(A a_) const {\n\t\trep(i,n){\n\t\t\tif(a_.a[i] < this->a[i])return true;\n\t\t\tif(a_.a[i] > this->a[i])return false;\n\t\t}\n\t\treturn false;\n\t}\n\tbool operator==(A a_) const {\n\t\trep(i,n){\n\t\t\tif(a_.a[i] != this->a[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nset<pair<A,int>> S;\n\nA R(A x,int i,int j){\n\tA ret = x;\n\tfor(int k = i ; k <= j ; k ++){\n\t\tret.a[k] = x.a[i+j-k];\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\t\n\tA a; rep(i,n)a.a[i] = i;\n\tS.insert(pair<A,int>(a,0));\n\trep(ppp,4){\n\t\tfor(set<pair<A,int>>::iterator itr = S.begin() ; itr != S.end() ; itr ++){\n\t\t\tif(itr->sc != ppp)continue;\n\t\t\trep(i,n){\n\t\t\t\tfor(int j = i+1 ; j < n ; j ++){\n\t\t\t\t\ta = R(itr->fr,i,j);\n\t\t\t\t\tif(!(S.lower_bound(pair<A,int>(a,0))->fr == a)){\n\t\t\t\t\t\tS.insert(pair<A,int>(a,ppp+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << ppp << \" \" << S.size() << endl;\n\t}\n\t\n\trep(i,n){\n\t\tint aa;\n\t\tscanf(\"%d\",&aa);\n\t\ta.a[i] = aa-1;\n\t}\n\t\n\tint ret = n-1;\n\tfor(set<pair<A,int>>::iterator itr = S.begin() ; itr != S.end() ; itr ++){\n\t\tA b;\n\t\trep(i,n)b.a[i] = a.a[itr->fr.a[i]];\n\t\tset<pair<A,int>>::iterator it = S.lower_bound(pair<A,int>(b,0));\n\t\tif(it->fr == b)ret = min ( ret , itr->sc + it->sc );\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<vector>\n#include<complex>\n#include<map>\n#include<set>\nusing namespace std;\n#define int long long\nvector<int> SS;\nint hs(vector<int> &X) {\n\tint res = 0;\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tres += X[i];\n\t\tres *= 10;\n\t}\n\treturn res;\n}\nsigned main() {\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tA[i]--;\n\t}\n\n\tqueue<int > qu;\n\tmap<int, int> mp;\n\tvector<int> B(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tB[i] = i;\n\t}\n\tint pow10[12];\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10;\n\t}\n\tmp[hs(B)] = 0;\n\n\tqu.push(hs(B));\n\t/*{\n\t\tint r = 5;\n\t\tint l = 0;\n\t\tint hh = hs(B);\n\t\thh += pow10[N - l] * (B[r] - B[l]);\n\t\thh += pow10[N - r] * (B[l] - B[r]);\n\t\tswap(B[l], B[r]);\n\t\tcerr << hh << \" \" << hs(B) << endl;\n\t}*/\n\tvector<int> t(N);\n\tvector<int> t2;\n\tint cnt = 0;\n\tint l, r;\n\tint z = 0;\n\twhile (!qu.empty()) {\n\n\t\tz = qu.front(); qu.pop();\n\t\tint h;\n\t\th = z;\n\t\tz /= 10;\n\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\tt[i] = z % 10;\n\t\t\tz /= 10;\n\t\t}\n\t\t\n\t\tint ht = h;\n\t\tint a = mp[h];\n\t\t/*if (cnt % 100000 == 0) {\n\t\t\tcerr << a << \" \" << qu.size() << \" \" << mp.size() << endl;\n\t\t}\n\t\tcnt++;*/\n\t\t//cerr << h << endl;\n\t\tfor (int i = 0; i < N; i++) {\n\n\t\t\tfor (int j = 1; j <= 2; j++) {\n\t\t\t\tl = i;\n\t\t\t\tr = i + j;\n\t\t\t\th = ht;\n\t\t\t\twhile (l >= 0 && r < N) {\n\t\t\t\t\th += pow10[N - l] * (t[r] - t[l]);\n\t\t\t\t\th += pow10[N - r] * (t[l] - t[r]);\n\t\t\t\t\t//cerr << h << \" \" << l << \" \" << r << endl;\n\t\t\t\t\tauto m = mp.find(h);\n\t\t\t\t\tif (m == mp.end() || (*m).second > a + 1) {\n\t\t\t\t\t\tmp[h] = a + 1;\n\t\t\t\t\t\tif (a + 1 <= 4) {\n\t\t\t\t\t\t\tqu.push(h);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl--;\n\t\t\t\t\tr++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//break;\n\t}\n\tvector<int> C(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tC[A[i]] = i;\n\t}\n\tint res = 9;\n\tint p = 0;\n\tfor (auto t : mp) {\n\t\tp = t.first;\n\t\tp /= 10;\n\t\tfor (int i = N - 1; i >= 0; i--) {\n\t\t\tB[i] = C[p % 10];\n\t\t\tp /= 10;\n\t\t}\n\t\tauto k = mp.find(hs(B));\n\t\tif (k != mp.end()) {\n\t\t\tres = min(res, t.second + (*k).second);\n\t\t}\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nint n,x,co;\nvector<int>v;\nmap<long long,int>M1;\nset<long long >s;\nlong long has(vector<int> &g){\n  long long res=0;\n  r(i,n){\n    if(g[i]!=10)res=res*10+g[i];\n    if(g[i]==10)res*=10;\n  }\n  return res;\n}\nvoid bfs(int p){\n  queue<P>q;\n  q.push(P(v,0));\n  s.insert(has(v));\n  while(!q.empty()){\n    vector<int> g=q.front().first;\n    int cost=q.front().second,c=0;q.pop();\n    if(!p){\n      r(i,n-1)if(g[i]>g[i+1])c++;\n      if(!c){\n        cout<<cost<<endl;\n        exit(0);\n      }\n      M1[has(g)]=cost;\n    }\n    else{\n      if(M1[has(g)]){\n        cout<<cost+M1[has(g)]<<endl;\n        exit(0);\n      }\n    }\n    if(cost==4)continue;\n    for(int i=2;i<=n;i++){\n      for(int j=0;j+i<=n;j++){\n        vector<int>t=g;\n        for(int k=j,l=0;l<i/2;l++,k++){\n          swap(t[k],t[j+i-1-l]);\n        }\n        int T=has(t);\n        if(!s.count(T)){\n          s.insert(T);\n          q.push(P(t,cost+1));\n        }\n      }\n    }\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>x;\n    v.push_back(x);\n  }\n  bfs(0);\n  r(i,n)v[i]=i+1;\n  bfs(1);\n  cout<<9<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\ntypedef vector<int> vint;\n\nmap<ll, int> ma;\nset<ll> se;\n\n\n\nll pow1[10];\nll pow2[10];\n\nvoid rev(ll &a,int l,int r){\n\twhile(l<r){\n\t\tll b = a%pow2[l]/pow1[l]*pow1[l];\n\t\tll c = a%pow2[r]/pow1[r]*pow1[r];\n\t\ta+=-b-c+b*pow1[r-l]+c/pow1[r-l];\n\t\tl++;\n\t\tr--;\n\t}\n}\n\nvector<int> w;\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n, 0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tpow1[0] = 1;\n\tpow2[0] = 10;\n\trep(i,9){\n\t\tpow1[i+1] = pow1[i]*10;\n\t\tpow2[i+1] = pow2[i]*10;\n\t}\n\tint ans = n - 1;\n\tqueue<ll> q[2];\n\tll vv=0,ww=0;\n\trep(i,n){\n\t\tvv=vv*10+v[i];\n\t\tww=ww*10+w[i];\n\t}\n\tq[0].push(vv);\n\tint m = (v.size()-1)/2;\n\tma[vv] = 0;\n\trep(o,m){\n\t\tqueue<ll>& now = q[o%2];\n\t\tqueue<ll>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t\tif(ma.count(top)==0){\n\t\t\t\t\t\tma[top] = o+1;\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t}\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(q[0].size()) q[0].pop();\n\twhile(q[1].size()) q[1].pop();\n\tset<ll> used;\n\tq[0].push(ww);\n\trep(o,m){\n\t\tqueue<ll>& now = q[o%2];\n\t\tqueue<ll>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t\tif(ma.count(top)){\n\t\t\t\t\t\tmins(ans,ma[top]+o+1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(used.find(top)!=used.end()){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t\tused.insert(top);\n\t\t\t\t\t}\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef pair<int,vector<int> > p2;\n \nmap<vector<int>,int> dist,dist2;\n \nint n;\nqueue<p2> que;\n\nvoid bfs(vector<int>start){\n  \n  que.push(p2(0,start));\n  dist[start]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n    \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>=(n-1)/2)return;\n\n    vector<int>t=now.state;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tif(dist.find(t)==dist.end())\n\t  que.push(p2(now.cost+1,t));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n\n\n\nint bfs2(vector<int>start){\n   \n  queue<p2> que;\n  que.push(p2(0,start));\n\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    if(now.cost>(n-1)/2)return -1;\n\n    if(dist2.find(now.state)!=dist2.end() && dist2[now.state]<now.cost)continue;\n    dist2[now.state]=now.cost;\n    \n    vector<int>t=now.state;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tif(dist2.find(t)==dist2.end())\n\t  que.push(p2(now.cost+1,t));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  bfs(g);\n\n  cout << bfs2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nshort n; vector<short>a; queue<pair<vector<short>,short>>Q;\nvector<pair<vector<short>, short>>a1, a2;\nset<vector<short>>E;\nvoid init(vector<short>R, short Lim, short D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<short>H = Q.front().first; short L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tfor (short j = i + 1; j < n; j++) {\n\t\t\t\tvector<short>I = H; short Y = j;\n\t\t\t\tfor (short k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (short i = 0; i < n; i++) { short p; cin >> p; a.push_back(p); }\n\tshort pos = n / 2; short pos2 = (n - 1) / 2; init(a, pos, 0); vector<short>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos2, 1);\n\tsort(a2.begin(), a2.end());\n\tshort ret = n - 1;\n\tif (n == 10)return 0;\n\tfor (short i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (short)0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tfor (int j = S1; j < S2; j++) ret = min(ret, (short)(a1[i].second + a2[j].second));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nint best;\nmap<ll, int> memo;\n\nll encode(const vector<int> &x){\n  ll H = 0;\n  REP(i, x.size()) H = H * 11 + x[i];\n  return H;\n}\n\nvoid dfs1(vector<int> &x, int depth){\n  ll h = encode(x);\n  if(memo.find(h) == memo.end() || memo[h] > depth){\n    memo[h] = depth;\n  }else{\n    return;\n  }\n  if(depth == 4) return;\n\n  REP(r, x.size())REP(l, r + 1){\n    int d = (r - l + 1) / 2;\n    REP(i, d) swap(x[l+i], x[r-i]);\n    dfs1(x, depth + 1);\n    REP(i, d) swap(x[l+i], x[r-i]);\n  }\n}\n\nvoid dfs2(vector<int> &x, int depth){\n  ll h = encode(x);\n  if(memo.find(h) != memo.end()) best = min(best, memo[h]);\n  if(depth == 4) return;\n  \n  REP(r, x.size())REP(l, r + 1){\n    int d = (r - l + 1) / 2;\n    REP(i, d) swap(x[l+i], x[r-i]);\n    dfs2(x, depth + 1);\n    REP(i, d) swap(x[l+i], x[r-i]);\n  }\n}\n\n\nint main(){\n  int N;\n  cin >> N;\n  vector<int> x(N);\n  vector<int> y(N);\n  REP(i, N){\n    cin >> x[i];\n    y[i] = i + 1;\n  }\n\n  best = N - 1;\n  dfs1(x, 0);\n  dfs2(y, 0);\n  cout << best << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nmap<vector<int>, int> memo[2];\nint main(void){\n    int n; cin >> n;\n\n    vector<int> a(n);\n    for(auto & e : a) cin >> e;\n\n    int nn = (n - 1) / 2;\n\n    int res = n - 1;\n    rep(i, 2){\n        queue<vector<int>> q;\n        q.push(a);\n        memo[i][a] = 0;\n\n        while(q.size()){\n            vector<int> b;\n            b = q.front(); q.pop();\n\n            if(i == 1 and memo[0].find(b) != end(memo[0])){\n                res = min(res, memo[0][b] + memo[1][b]);\n                continue;\n            }\n\n            if(memo[i][b] >= nn) continue;\n\n            rep(j, n){\n                range(k, j + 1, n){\n                    vector<int> nb = b;\n                    reverse(begin(nb) + j, begin(nb) + k + 1);\n\n                    if(memo[i].find(nb) != end(memo[i])) continue;\n\n                    memo[i][nb] = memo[i][b] + 1;\n                    q.push(nb);\n                }\n            }\n        }\n\n        sort(begin(a), end(a));\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  vector<int> nums;\n  int cost;\n  bool operator <(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator >(const State& s) const {\n    return cost > s.cost;\n  }\n  State(const vector<int>& n,int c) {\n    nums = n;\n    cost = c;\n  }\n};\n\nint bfs(const vector<int>& init,\n        map<vector<int>,int>& dp){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(init,0));\n  dp[init] = 0;\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s.cost >= 5) continue;\n    for(int lhs = 0; lhs < s.nums.size(); lhs++){\n      for(int rhs = lhs + 1; rhs <= s.nums.size(); rhs++){\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n        \n        if(dp.find(s.nums) != dp.end()){\n          reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n          continue;\n        }\n\n        dp[s.nums] = s.cost + 1;\n        que.push(State(s.nums,s.cost+ 1));\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<int> nums;\n    for(int i=0; i < N; i++){\n      int num;\n      scanf(\"%d\",&num);\n      nums.push_back(num);\n    }\n    map<vector<int>,int> start;\n    bfs(nums,start);\n\n    map<vector<int>,int> goal;\n    sort(nums.begin(),nums.end());\n    bfs(nums,goal);\n\n    int res = INF;\n    for(map<vector<int>,int>::iterator it = start.begin();\n        it != start.end();\n        it++){\n      if(goal.find(it->first) != goal.end()){\n        res = min(it->second + goal[it->first],res);\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\ninline ull PermutationHash(vi perm){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tull hash = 0;\n    REP(i, (int)perm.size()-1) perm[i] = perm[i];\n    REP(i, (int)perm.size()-1){\n        hash += perm[i] * FACTOR[perm.size()-i-1];\n        for (int j=i+1; j < (int)perm.size()-1; j++)\n            if (perm[i] < perm[j]) perm[j]--;\n    }\n    return hash;\n}\n\ninline vi restorePermutation(ull u){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tvi res;\n\tRREP(i, n){\n\t\tint p = u/FACTOR[i];\n\t\tu%=FACTOR[i];\n\t\tres.push_back(p);\n\t}\n\tRREP(i, res.size())RREP(j, i) if(res[j] <= res[i]) res[i]++;\n\treturn res;\n}\n\nint memo[3628801];\nint rev[3628801];\nmain(){\n\twhile(cin >> n){\n\t\tmemset(rev, 63, sizeof(memo));\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tvi a(n);\n\t\tREP(i, n) a[i] = i;\n\t\tqueue< pair<int, ull> > pq;\n\t\tpq.emplace(0, 0);\n\t\trev[0] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.front().first;\n\t\t\tull u = pq.front().second;\n\t\t\tpq.pop();\n\t\t\tif(c > 3) break;\n\t\t\tvi a = restorePermutation(u);\n\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\tvi b(a);\n\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\tull u = PermutationHash(b);\n\t\t\t\tif(chmin(rev[u], c+1) && c+1 < 4) pq.emplace(c+1, u);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tREP(i, n) cin >> a[i],a[i]--;\n\t\t\tqueue< pair<int, ull> > pq;\n\t\t\tpq.emplace(0, PermutationHash(a));\n\t\t\tmemo[PermutationHash(a)] = 0;\n\t\t\tint ans = n-1;\n\t\t\twhile(!pq.empty()){\n\t\t\t\tint c = pq.front().first;\n\t\t\t\tull u = pq.front().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif(c > 3) break;\n\t\t\t\tans = min(ans, c + rev[u]);\n\t\t\t\tvi a = restorePermutation(u);\n\t\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\t\tvi b(a);\n\t\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\t\tull u = PermutationHash(b);\n\t\t\t\t\tif(c+1 < 4 && chmin(memo[u], c+1)) pq.emplace(c+1, u);\n\t\t\t\t\tans = min(ans, c + 1 + rev[u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#define int short\n\nusing namespace std;\n\nmain()\n{\n\tint N;\n\n\tcin >> N;\n\n\tvector<int> A(N);\n\n\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\n\tvector<int> B = A; sort(B.begin(), B.end());\n\n\tset<vector<int> > dat; dat.insert(A);\n\n\tqueue<vector<int> > que; que.push(A);\n\n\tqueue<int> que2; que2.push(0);\n\n\tif (A == B) { cout << 0 << endl; goto Exit; }\n\n\twhile (que.size())\n\t{\n\t\tvector<int> v1 = que.front(); que.pop();\n\n\t\tint dist = que2.front(); que2.pop();\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tvector<int> v2 = v1;\n\n\t\t\t\tswap(v2[i], v2[j]);\n\n\t\t\t\tif (v2 == B) { cout << dist + 1 << endl; goto Exit; }\n\n\t\t\t\tif (dat.find(v2) == dat.end())\n\t\t\t\t{\n\t\t\t\t\tdat.insert(v2);\n\n\t\t\t\t\tque.push(v2);\n\n\t\t\t\t\tque2.push(dist + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nExit:;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef pair<int,vector<int> > pqt;\ntypedef vector<pqt> Vpqt;\ntypedef priority_queue<pqt,Vpqt,greater<pqt> > PQ;\nmap<vector<int>,int> dists;\ntypedef pair<int,vector<int> > pvi;\nconst int SIZE=20;\nclock_t clocks[SIZE];\ndouble clockst(int x){\n\tclocks[x] = -clock();\n}\ndouble clocked(int x){\n\tclocks[x] += clock();\n}\t\ndouble timer(int x){\n\treturn clocks[x];\n}\nvoid reverse(vector<int> &nums,int a,int b){\n\twhile(a<b){\n\t\tswap(nums[a++],nums[b--]);\n\t}\n}\n/*int score(vector<int> &nums){\n\tint ables[2]={};\n\tREP(i,nums.size()){\n\t\tables[abs(i+1-nums[i])&1]|=1;\n\t}\n\treturn ables[0]+ables[1];\n}*/\n/*int score(vector<int> &nums){\n\t\n\tint ans=0;\n\tREP(i,nums.size()-1){\n\t\tif(i+1-nums[i]>0 && i+2-nums[i+1]<0) ans++;\n\t}\n\t\n\treturn ans;\n\t\n}*/\nint score(vector<int> &nums){\n\treturn 0;\n\tint ans=0,two=0;\n\tREP(i,nums.size()-1){\n\t\tif(abs(nums[i+1]-nums[i])>=2) two++;\n\t}\n\tFOR(i,0,nums.size()){\n\t\tif((((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i])*(nums[i]-(i?nums[i-1]:0))<0) ans++;\n//\t\tcout << (((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i]) << \" \" <<  (nums[i]-(i?nums[i-1]:0)) << endl;\n\t}\n//\tcout << ans << endl;\n\treturn (max(two,ans)+1)/2;\t\n}\n\nint times=0;\nint solve(vector<int> nums){\n\tclockst(2);\n\t\n\tPQ qu;\n\n\tvector<int> ans;\n\tREP(i,nums.size()){\n\t\tans.PB(i+1);\n\t}\n\tqu.push(pvi(score(nums),nums));\n\t\n\twhile(!qu.empty()){\n\t\tvector<int> now=qu.top().second;\n\t\tint dist=qu.top().first-score(now);\n\t\tqu.pop();\n\t\tif(dist!=dists[now]) continue;\n\t\ttimes++;\n\t\tif(times==160000) return nums.size()-1; \n\t\tif(now==ans) return dists[ans];\n//\t\tREP(i,now.size()) cout << now[i] << \" \";\n//\t\tcout <<dist << \" \"<< score(now) <<  endl;\n\t\tREP(i,nums.size()){\n\t\t\tREP(j,i){\n\t\t\t\treverse(now,j,i);\n\t\t\t\tif(!dists.count(now) || dists[now]>dist+1){\n\t\t\t\t\tif(dist+1+score(now)<nums.size()-1) qu.push(pvi(dist+1+score(now),vector<int>(now)));\n\t\t\t\t\tif(dist+1+score(now)<nums.size()) dists[now]=dist+1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\treverse(now,j,i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn nums.size()-1;\n}\t\nint main() {\n\tvector<int> vi;\n\tint n,x;\n\t\n\tcin >> n;\n\tREP(i,n){\n\t\tcin >> x;\n\t\tvi.PB(x);\n\t}\n\tcout << solve(vi) << endl;\n\tclocked(2);\n\t//cout << times << endl;\n\t//cout << dists.size() << endl;\n\t//cout << timer(2) << endl;\n\t//cout << timer(1) << endl;\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <cstdio>\n#include <unordered_map>\nusing namespace std;\n\n//const int SIZE = 3628810;\ntypedef long long ll;\ntypedef pair< vector<int>, ll > Pack;\n\n\nll pw[12];\ninline void init(){\n    pw[0] = 1;\n    for(int i=1;i<12;i++)pw[i] = pw[i-1] * 10;\n}\n\n\nll getPermId(const vector<int>& v){\n    /*\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;*/\n    \n    ll res = 0;\n    for(int i=0;i<v.size();i++){\n        res += pw[i] * v[i];\n    }\n    \n    return res;\n}\n\nunordered_map<ll, int> dist[2];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    const int N = (int)start.size();\n    const ll startId = getPermId(start);\n    const ll goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm = pack.first;\n            ll permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            /*for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }*/\n            \n            for(int s=0;s<N;s++){\n                for(int d=1;d<=2;d++){\n                    ll nextPermId = permId;\n                    \n                    int S = s;\n                    int T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        nextPermId -= pw[S] * perm[S];\n                        nextPermId += pw[S] * perm[T];\n                        nextPermId -= pw[T] * perm[T];\n                        nextPermId += pw[T] * perm[S];\n                        \n                        swap(perm[S], perm[T]);\n            \n                        if(!dist[curr].count(nextPermId)){\n                            dist[curr][nextPermId] = nowCost + 1;\n                            \n                            if(dist[next].count(nextPermId)){\n                                return dist[curr][nextPermId] + dist[next][nextPermId];\n                            } else {\n                                nextQueue.push_back(make_pair(perm, nextPermId));\n                            }\n                        }\n                        \n                        --S;\n                        ++T;\n                    }\n                    \n                    \n                    \n                    S = s;\n                    T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        --S;\n                        ++T;\n                    }\n                }\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    init();\n    \n    int N;\n    scanf(\"%d\", &N);\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        scanf(\"%d\", &start[i]);\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N;\nvector<int> A;\n\nbool check(vector<int>& a){\n  for(int i=0;i<N;i++)\n    if(a[i]!=i) return false;\n  return true;\n}\nint ind(vector<int>&a, int x){\n  for(int i=0;i<N;i++)\n    if( a[i] == x ) return i;\n}\nvoid view(vector<int>& a){\n  for(int i=0;i<N;i++) cout << a[i] << \" \";\n  cout << endl;\n}\n\ntypedef pair<vector<int>,int> P;\n\nvoid solve(map<vector<int>,int>& M,vector<int>& A){\n  M.clear();\n  queue<P> q;\n  q.push( P(A, 0) );\n  M[A] = 0;\n  while( !q.empty() ){\n    P p = q.front(); q.pop();\n    if( p.second == 4 ) return;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n        vector<int> a=p.first;\n        reverse( a.begin()+i, a.begin()+j+1 );\n        if( M.count( a ) == 0 ){\n          M[a] = p.second+1;\n          q.push( P(a,p.second+1) );\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> N){\n    A.resize(N);\n    for(int i=0;i<N;i++) {\n      cin >>A[i]; A[i]--;\n    }\n    map<vector<int>,int> M1,M2;\n    solve(M1,A);\n    sort( A.begin(), A.end() );\n    solve(M2,A);\n    int res = 9;\n    for( auto it = M1.begin(); it != M1.end();it++ )\n      if( M2.count( it->first ) != 0 )\n        res = min( res, it->second + M2[it->first] );\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nint maxdepth;\nmap<VI,int> mp;\n\nvoid Rev(int l,int r,vector<int> &v){\n  for(int i=0;i<=10;i++){\n    if(l+i>=r-i)break;\n    swap(v[l+i],v[r-i]);\n  }\n  return;\n}\n\nvoid bfs(vector<int> v,int depth){\n  if(depth>=maxdepth)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        if(mp[v1]>depth){\n          mp[v1] = depth;\n          bfs(v1,depth+1);\n        }\n      }else if(mp[v1]==0){\n        mp[v1] = depth;\n        bfs(v1,depth+1);\n      }\n    }\n  }\n  return;\n}\n\nvoid bfs2(vector<int> v,int depth,int &ans){\n  if(depth>=maxdepth)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        ans = min(ans,mp[v1]+depth);\n        bfs2(v1,depth+1,ans);\n      }else if(mp[v1]==0){\n        bfs2(v1,depth+1,ans);\n      }\n    }\n  }\n  return;\n}\n\n\n\nint main(){\n  int n;\n  cin >>n;\n  maxdepth = (n -1) / 2;\n  VI a(n);\n  rep(i,n)cin>>a[i];\n  mp[a]=0;\n  bfs(a,1);\n  VI b(n);\n  rep(i,n)b[i]=i+1;\n  if(a==b){\n    cout << 0 << endl;\n    return 0;\n  }\n  int ans = 10000;\n  if(mp[b]!=0){\n    cout << mp[b] << endl;\n    return 0;\n  }\n  bfs2(b,1,ans);\n  if(ans==10000){\n    cout << n-1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \n/*--------------------template--------------------*/\n \ntypedef pair<vi, int> P;\n \nint main()\n{\n    int n;\n    cin >> n;\n    vi a(n);\n    REP(i, n)\n    {\n        cin >> a[i];\n        a[i]--;\n    }\n    vi b = a;\n    sort(ALL(b));\n    map<vi, int> mp1, mp2;\n    queue<P> que;\n    que.push(P(a, 0));\n    mp1[a] = 0;\n    while (que.size())\n    {\n        vi t = que.front().first;\n        int cnt = que.front().second;\n        que.pop();\n        REP(j, n)REP(i, j)\n        {\n            vi nx = t;\n            reverse(nx.begin() + i, nx.begin() + j + 1);\n            if (mp1.find(nx) == mp1.end()) \n            {\n                mp1[nx] = cnt + 1;\n                if(cnt<4) que.push(P(nx, cnt + 1));\n            }\n        }\n    }\n    int ans = n - 1;\n    queue<P> que2;\n    que2.push(P(b, 0));\n    while (que2.size())\n    {\n        vi t = que2.front().first;\n        int cnt = que2.front().second;\n        que2.pop();\n        if (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n        REP(j, n)REP(i, j)\n        {\n            vi nx = t;\n            reverse(nx.begin() + i, nx.begin() + j);\n            if (mp2.find(nx) == mp2.end())\n            {\n                mp2[nx] = cnt + 1;\n                if(cnt+1<4)que2.push(P(nx, cnt + 1));\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <cstdio>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            /*for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }*/\n            \n            for(int s=0;s<N;s++){\n                for(int d=1;d<=2;d++){\n                    int S = s;\n                    int T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        int nextPermId = getPermId(perm);\n                        if(dist[curr][nextPermId] == -1){\n                            dist[curr][nextPermId] = nowCost + 1;\n                            \n                            if(dist[next][nextPermId] != -1){\n                                return dist[curr][nextPermId] + dist[next][nextPermId];\n                            } else {\n                                nextQueue.push_back(make_pair(perm, nextPermId));\n                            }\n                        }\n                        \n                        --S;\n                        ++T;\n                    }\n                    \n                    \n                    \n                    S = s;\n                    T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        --S;\n                        ++T;\n                    }\n                }\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    scanf(\"%d\", &N);\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        scanf(\"%d\", &start[i]);\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 両側探索というアルゴリズムらしい(初めて知った)\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n\nint dp[3628801][2] = {};\nint fact[10];\n\nint enc(string s){\n    int cnt[10] = {};\n    int ret = 0;\n    for(int i = 0; i < s.length(); i++){\n        int tmp = 0;\n        for(int j = 0; j < s[i]-'0'; j++)   tmp += 1-cnt[j];\n        ret += fact[s.length()-1-i]*tmp;\n        cnt[s[i]-'0'] = 1;\n    }\n    return ret;\n}\n\nvoid f(int id, string ini, int n){\n    dp[enc(ini)][id] = 0;\n    queue<pair<string,int>> q;\n    q.push({ini, enc(ini)});\n    while(!q.empty()){\n        pair<string,int> p = q.front();   q.pop();\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                string cp = p.first;\n                reverse(cp.begin()+i, cp.begin()+j+1);\n                int ni = enc(cp);\n                if(dp[ni][id] > dp[p.second][id]+1){\n                    dp[ni][id] = dp[p.second][id]+1;\n                    if(dp[ni][id] == 4) continue;\n                    q.push({cp, ni});\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    fact[1] = 1;\n    for(int i = 2; i < 10; i++) fact[i] = fact[i-1]*i;\n\n    memset(dp, 0x3f, sizeof(dp));\n    \n    int n;\n    cin >> n;\n    \n    string tmp = \"\", ideal = \"\";\n    for(int i = 0; i < n; i++){\n        int a;  cin >> a;\n        tmp += ('0' + --a);\n        ideal += ('0' + i);\n    }\n    \n    f(0, tmp, n);\n    f(1, ideal, n);\n    \n    int ans = n-1;\n    for(int i = 0; i < 3628801; i++)    ans = min(ans, dp[i][0]+dp[i][1]);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef pair<int,vector<int> > pqt;\ntypedef vector<pqt> Vpqt;\ntypedef priority_queue<pqt,Vpqt,greater<pqt> > PQ;\nmap<vector<int>,int> dists;\ntypedef pair<int,vector<int> > pvi;\nconst int SIZE=20;\nclock_t clocks[SIZE];\ndouble clockst(int x){\n\tclocks[x] = -clock();\n}\ndouble clocked(int x){\n\tclocks[x] += clock();\n}\t\ndouble timer(int x){\n\treturn clocks[x];\n}\nvoid reverse(vector<int> &nums,int a,int b){\n\twhile(a<b){\n\t\tswap(nums[a++],nums[b--]);\n\t}\n}\n/*int score(vector<int> &nums){\n\tint ables[2]={};\n\tREP(i,nums.size()){\n\t\tables[abs(i+1-nums[i])&1]|=1;\n\t}\n\treturn ables[0]+ables[1];\n}*/\n/*int score(vector<int> &nums){\n\t\n\tint ans=0;\n\tREP(i,nums.size()-1){\n\t\tif(i+1-nums[i]>0 && i+2-nums[i+1]<0) ans++;\n\t}\n\t\n\treturn ans;\n\t\n}*/\nint score(vector<int> &nums){\n//\treturn 0;\n\tint ans=0,two=0;\n\tREP(i,nums.size()-1){\n\t\tif(abs(nums[i+1]-nums[i])>=2) two++;\n\t}\n\tFOR(i,0,nums.size()){\n\t\tif((((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i])*(nums[i]-(i?nums[i-1]:0))<0) ans++;\n//\t\tcout << (((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i]) << \" \" <<  (nums[i]-(i?nums[i-1]:0)) << endl;\n\t}\n//\tcout << ans << endl;\n\treturn (max(two,ans)+1)/2;\t\n}\n\nint times=0;\nint solve(vector<int> nums){\n\tclockst(2);\n\t\n\tPQ qu;\n\n\tvector<int> ans;\n\tREP(i,nums.size()){\n\t\tans.PB(i+1);\n\t}\n\tqu.push(pvi(score(nums),nums));\n\t\n\twhile(!qu.empty()){\n\t\tvector<int> now=qu.top().second;\n\t\tint dist=qu.top().first-score(now);\n\t\tqu.pop();\n\t\tif(dist!=dists[now]) continue;\n\t\ttimes++;\n\t\tif(times==170000) return nums.size()-1; \n\t\tif(now==ans) return dists[ans];\n//\t\tREP(i,now.size()) cout << now[i] << \" \";\n//\t\tcout <<dist << \" \"<< score(now) <<  endl;\n\t\tREP(i,nums.size()){\n\t\t\tREP(j,i){\n\t\t\t\treverse(now,j,i);\n\t\t\t\tif(!dists.count(now) || dists[now]>dist+1){\n\t\t\t\t\tif(dist+1+score(now)<nums.size()-1) qu.push(pvi(dist+1+score(now),vector<int>(now)));\n\t\t\t\t\tif(dist+1+score(now)<nums.size()) dists[now]=dist+1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\treverse(now,j,i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn nums.size()-1;\n}\t\nint main() {\n\tvector<int> vi;\n\tint n,x;\n\t\n\tcin >> n;\n\tREP(i,n){\n\t\tcin >> x;\n\t\tvi.PB(x);\n\t}\n\tcout << solve(vi) << endl;\n\tclocked(2);\n\t//cout << times << endl;\n\t//cout << dists.size() << endl;\n\t//cout << timer(2) << endl;\n\t//cout << timer(1) << endl;\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nint N;\nmap<vint,int> back;\nmap<vint,int> dp;\n\nint solve() {\n    vint target(N);\n    vint start(N);\n    for (int i = 0; i < N; ++i) {\n        target[i] = i+1;\n        cin >> start[i];\n    }\n    queue<vint> que;\n    que.push(target);\n    back.clear();\n    back[target] = 0;\n    \n    while (!que.empty()) {\n        vint now = que.front(); que.pop();\n        //cout << now << \" : \" << back[now] << endl;\n        if (back[now] == 4) continue;\n        if (now == start) { return back[now]; }\n        \n        for (int i = 0; i < N; ++i)\n            for (int j = i+2; j <= N; ++j) {\n                vint next = now;\n                reverse(next.begin() + i, next.begin() + j);\n//                for (int k = 0; k < i; ++k) next[k] = now[k];\n//                for (int k = i; k < j; ++k) next[k] = now[i+j-1 - k];\n//                for (int k = j; k < N; ++k) next[k] = now[k];\n                \n                if (!back.count(next)) {\n                    back[next] = back[now] + 1;\n                    que.push(next);\n                }\n            }\n    }\n    \n    que.push(start);\n    dp.clear();\n    dp[start] = 0;\n    \n    while (!que.empty()) {\n        vint now = que.front(); que.pop();\n        //cout << now << \" : \" << dp[now] << endl;\n        if (dp[now] == 4) continue;\n        if (back.count(now)) return dp[now] + back[now];\n            \n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j <= N; ++j) {\n                vint next = now;\n                reverse(next.begin() + i, next.begin() + j);\n                    \n                if (!dp.count(next)) {\n                    dp[next] = dp[now] + 1;\n                    que.push(next);\n                }\n            }\n    }\n    \n    return 9;\n}\n\nint main() {\n    while (cin >> N) {\n        cout << solve() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef pair<int,vector<int> > pqt;\ntypedef vector<pqt> Vpqt;\ntypedef priority_queue<pqt,Vpqt,greater<pqt> > PQ;\nmap<vector<int>,int> dists;\ntypedef pair<int,vector<int> > pvi;\nconst int SIZE=20;\nclock_t clocks[SIZE];\ndouble clockst(int x){\n\tclocks[x] = -clock();\n}\ndouble clocked(int x){\n\tclocks[x] += clock();\n}\t\ndouble timer(int x){\n\treturn clocks[x];\n}\nvoid reverse(vector<int> &nums,int a,int b){\n\twhile(a<b){\n\t\tswap(nums[a++],nums[b--]);\n\t}\n}\n/*int score(vector<int> &nums){\n\tint ables[2]={};\n\tREP(i,nums.size()){\n\t\tables[abs(i+1-nums[i])&1]|=1;\n\t}\n\treturn ables[0]+ables[1];\n}*/\n/*int score(vector<int> &nums){\n\t\n\tint ans=0;\n\tREP(i,nums.size()-1){\n\t\tif(i+1-nums[i]>0 && i+2-nums[i+1]<0) ans++;\n\t}\n\t\n\treturn ans;\n\t\n}*/\nint score(vector<int> &nums){\n//\treturn 0;\n\tint ans=0,two=0;\n\tREP(i,nums.size()-1){\n\t\tif(abs(nums[i+1]-nums[i])>=2) two++;\n\t}\n\tFOR(i,0,nums.size()){\n\t\tif((((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i])*(nums[i]-(i?nums[i-1]:0))<0) ans++;\n//\t\tcout << (((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i]) << \" \" <<  (nums[i]-(i?nums[i-1]:0)) << endl;\n\t}\n//\tcout << ans << endl;\n\treturn (max(two,ans)+1)/2;\t\n}\n\nint times=0;\nint solve(vector<int> nums){\n\tclockst(2);\n\t\n\tPQ qu;\n\n\tvector<int> ans;\n\tREP(i,nums.size()){\n\t\tans.PB(i+1);\n\t}\n\tqu.push(pvi(score(nums),nums));\n\t\n\twhile(!qu.empty()){\n\t\tvector<int> now=qu.top().second;\n\t\tint dist=qu.top().first-score(now);\n\t\tqu.pop();\n\t\tif(dist!=dists[now]) continue;\n\t\ttimes++;\n\t\tif(times==160000) return nums.size()-1; \n\t\tif(now==ans) return dists[ans];\n//\t\tREP(i,now.size()) cout << now[i] << \" \";\n//\t\tcout <<dist << \" \"<< score(now) <<  endl;\n\t\tREP(i,nums.size()){\n\t\t\tREP(j,i){\n\t\t\t\treverse(now,j,i);\n\t\t\t\tif(!dists.count(now) || dists[now]>dist+1){\n\t\t\t\t\tif(dist+1+score(now)<nums.size()-1) qu.push(pvi(dist+1+score(now),vector<int>(now)));\n\t\t\t\t\tif(dist+1+score(now)<nums.size()) dists[now]=dist+1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\treverse(now,j,i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn nums.size()-1;\n}\t\nint main() {\n\tvector<int> vi;\n\tint n,x;\n\t\n\tcin >> n;\n\tREP(i,n){\n\t\tcin >> x;\n\t\tvi.PB(x);\n\t}\n\tcout << solve(vi) << endl;\n\tclocked(2);\n\t//cout << times << endl;\n\t//cout << dists.size() << endl;\n\t//cout << timer(2) << endl;\n\t//cout << timer(1) << endl;\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<vector<int>,int>P;\n\nint n;\n\nmap<vector<int>,int> BFS(vector<int> A){\n  map<vector<int>,int>m;\n  m[A]=0;\n  queue<P>q;\n  q.push(P(A,0));\n  while(!q.empty()){\n    vector<int> B=q.front().first;\n    int cost=q.front().second;q.pop();\n    if(cost==5)continue;\n    for(int l=0;l<n-1;l++){\n      for(int r=l+1;r<n;r++){\n        vector<int>C=B;\n        reverse(C.begin()+l,C.begin()+r+1);\n        if(!m.count(C)){\n          m[C]=cost+1;\n          q.push(P(C,cost+1));\n        }\n      }\n    }\n  }\n  return m;\n}\n\nint main(){\n  cin>>n;\n  vector<int>A(n),B(n);\n  r(i,n)cin>>B[i],A[i]=i+1;\n  map<vector<int>,int>m1=BFS(A);\n  map<vector<int>,int>m2=BFS(B);\n  do{\n    if(m1.count(A)&&m2.count(A)){\n      cout<<m1[A]+m2[A]<<endl;\n      return 0;\n    }\n  }while(next_permutation(A.begin(),A.end()));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef pair<vi, int> P;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi a(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\tvi b = a;\n\tsort(ALL(b));\n\tmap<vi, int> mp1, mp2;\n\tqueue<P> que;\n\tque.push(P(a, 0));\n\tmp1[a] = 0;\n\twhile (que.size())\n\t{\n\t\tvi t = que.front().first;\n\t\tint cnt = que.front().second;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) \n\t\t\t{\n\t\t\t\tmp1[nx] = cnt + 1;\n\t\t\t\tif (nx == b)\n\t\t\t\t{\n\t\t\t\t\tcout << cnt + 1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (cnt < 4) que.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = n - 1;\n\tqueue<P> que2;\n\tque2.push(P(b, 0));\n\twhile (que2.size())\n\t{\n\t\tvi t = que2.front().first;\n\t\tint cnt = que2.front().second;\n\t\tque2.pop();\n\t\tif (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j);\n\t\t\tif (mp2.find(nx) == mp2.end())\n\t\t\t{\n\t\t\t\tif (mp1.find(nx) != mp1.end())\n\t\t\t\t{\n\t\t\t\t\tcout << mp1[nx] + cnt + 1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tmp2[nx] = cnt + 1;\n\t\t\t\tif(cnt<4)que2.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nmap<vector<int>, int> memo;\nint main(void){\n    int n; cin >> n;\n\n    vector<int> a(n);\n    for(auto & e : a) cin >> e;\n\n    int nn = (n - 1) / 2;\n\n    int res = n - 1;\n    rep(i, 2){\n        queue<pair<int, vector<int>>> q;\n        q.push(make_pair(0, a));\n\n        while(q.size()){\n            int cnt; vector<int> b;\n            cnt = q.front().first, b = q.front().second;\n            // cerr << cnt << \": \";\n            // for(auto & e : b) cerr << e << \" \";\n            // cerr << endl;\n            q.pop();\n\n            if(cnt == nn) continue;\n\n            if(memo.find(b) != end(memo)){\n                if(i == 0) continue;\n                else{\n                    res = memo[b] + cnt;\n                    break;\n                }\n            }\n            if(i == 0) memo[b] = cnt;\n\n            rep(j, n){\n                range(k, j + 1, n){\n                    vector<int> nb = b;\n                    reverse(begin(nb) + j, begin(nb) + k + 1);\n\n                    q.push(make_pair(cnt + 1, nb));\n                }\n            }\n        }\n\n        rep(j, n) a[j] = j + 1;\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\ntypedef vector<int> vint;\n\nmap<ll, int> ma;\nset<ll> se;\n\n\n\nll pow1[10];\nll pow2[10];\n\nvoid rev(ll &a,int l,int r){\n\twhile(l<r){\n\t\tll b = a%pow2[l]/pow1[l];\n\t\tll c = a%pow2[r]/pow1[r];\n\t\ta+=-b-c+b*pow2[r-l]+c/pow2[r-l];\n\t\tl++;\n\t\tr--;\n\t}\n}\n\nvector<int> w;\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n, 0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tpow1[0] = 1;\n\tpow2[0] = 10;\n\trep(i,9){\n\t\tpow1[i+1] = pow1[i]*10;\n\t\tpow2[i+1] = pow2[i]*10;\n\t}\n\tint ans = n - 1;\n\tqueue<ll> q[2];\n\tll vv=0,ww=0;\n\trep(i,n){\n\t\tvv=vv*10+v[i];\n\t\tww=ww*10+w[i];\n\t}\n\tq[0].push(vv);\n\tint m = (v.size()-1)/2;\n\tma[vv] = 0;\n\trep(o,m){\n\t\tqueue<ll>& now = q[o%2];\n\t\tqueue<ll>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t\tif(ma.count(top)==0){\n\t\t\t\t\t\tma[top] = o+1;\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t}\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(q[0].size()) q[0].pop();\n\twhile(q[1].size()) q[1].pop();\n\tset<ll> used;\n\tq[0].push(ww);\n\trep(o,m){\n\t\tqueue<ll>& now = q[o%2];\n\t\tqueue<ll>& next = q[1-o%2];\n\t\twhile(now.size()){\n\t\t\tauto top = now.front();\n\t\t\tnow.pop();\n\t\t\trep(i,n){\n\t\t\t\trep(j,i){\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t\tif(ma.count(top)){\n\t\t\t\t\t\tmins(ans,ma[top]+o+1);\n\t\t\t\t\t}\n\t\t\t\t\telse if(used.find(top)!=used.end()){\n\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnext.push(top);\n\t\t\t\t\t\tused.insert(top);\n\t\t\t\t\t}\n\t\t\t\t\trev(top,j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N,A[11];\nmap<vi,int> M[2];\n\nvoid bfs(vi start,int mode){\n\tqueue<vi> Q;\n\tQ.push(start);\n\tM[mode][start]=0;\n\twhile(sz(Q)){\n\t\tvi v=Q.front();Q.pop();\n\t\tint d=M[mode][v];\n\t\tif(d==4)break;\n\t\trep(i,N)rep2(j,i+1,N){\n\t\t\tvi w=v;\n\t\t\trep2(k,i,j+1){\n\t\t\t\tw[k] = v[j-(k-i)];\n\t\t\t}\n\t\t\tif(M[mode].find(w)==M[mode].end()){\n\t\t\t\tM[mode][w]=d+1;\n\t\t\t\tQ.push(w);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N;\n\trep(i,N)cin>>A[i],A[i]--;\n\t\n\tvi v;\n\trep(i,N)v.pb(A[i]);\n\tbfs(v,0);\n\tv.clear();\n\trep(i,N)v.pb(i);\n\tbfs(v,1);\n\tint ans=9;\n\tforeach(it,M[0]){\n\t\tif(M[1].find(it->fir)!=M[1].end()){\n\t\t\tans=min(ans,it->sec+M[1][it->fir]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct kontainer{\n    vector<long long> seq;\n    int step;\n};\n\nbool check(vector<long long> a){\n    for (int i = 1; i < a.size(); i++){\n        if (a[i] < a[i-1]) return false;\n    }\n    return true;\n}\n\nint bfs(vector<long long> a){\n    queue<kontainer> BFS;\n    BFS.push({a,0});\n    set < vector<long long> > udah;\n    while(!BFS.empty()){\n        vector<long long> now = BFS.front().seq;\n        int step = BFS.front().step;\n        BFS.pop();\n        if (check(now)){\n            return step;\n        }\n        if (udah.find(now) == udah.end()){\n            udah.insert(now);\n            for (int i = 1; i < now.size(); i++){\n                vector<long long> curr = now;\n                for (int j = 0; j < i; j++){\n                    curr = now;\n                    if (curr[i] < curr[j]){\n                        int tmp = curr[j];  \n                        curr[j] = curr[i];  \n                        curr[i] = tmp;  \n                        BFS.push({curr,step+1});\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<long long> in;\n    for (int i = 0; i < n; i++){\n        long long bil;\n        cin >> bil;\n        in.push_back(bil);\n    }\n    int ans = bfs(in);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nint po[11],a[11];\nvoid print(int x){\n  for(int i=0;i<n;i++) cout<<x%11<<\" \",x/=11;\n  cout<<endl;\n}\nvoid sw(int &x,int i,int j){\n  int s=(x%po[i+1])/po[i]*(po[j]-po[i]);\n  int t=(x%po[j+1])/po[j]*(po[i]-po[j]);\n  x+=s+t;\n}\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<10;i++) po[i+1]=po[i]*11;\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i];\n  int p[2]={};\n  for(int i=0;i<n;i++) p[0]=p[0]*11+a[i];\n  for(int i=0;i<n;i++) p[1]=p[1]*11+(i+1);\n  if(p[0]==p[1]){\n    cout<<0<<endl;\n    return 0;\n  }\n  //cout<<p<<endl<<ans<<endl;\n  //print(p);print(ans);\n  queue<int> q[2];\n  unordered_map<int,int> m[2];\n  int ans=n-1;\n  for(int j=0;j<2;j++){\n    q[j].push(p[j]);\n    m[j][p[j]]=0;\n    while(!q[j].empty()){\n      int t=q[j].front();q[j].pop();\n      int d=m[j][t];\n      if(d>=n/2-1) break;\n      //cout<<d<<\":\";print(p);\n      for(int i=1;i<n-1;i++){\n\tint r=t;\n\tfor(int k=1;i-k>=0&&i+k<n;k++){\n\t  sw(r,i-k,i+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tint r=t;\n\tfor(int k=0;i-k>=0&&i+1+k<n;k++){\n\t  sw(r,i-k,i+1+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint N, i;\n\tcin >> N;\n\tvector<int> v(N), cp, sorted(N);\n\tvector<vector<int>> vv, vvcp;\n\tfor (i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tsorted[i] = i + 1;\n\t}\n\tvv.push_back(v);\n\tfor (i = 0; i < N - 1; i++) {\n\t\tif (binary_search(vv.begin(), vv.end(), sorted)) {\n\t\t\tbreak;\n\t\t}\n\t\telse if (i < N - 2) {\n\t\t\tvvcp = vv;\n\t\t\tvv.clear();\n\t\t\tfor (auto vec : vvcp) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\t\t\tvector<int> vecc = vec;\n\t\t\t\t\t\tfor (int l = 0; j + l <= k; l++) {\n\t\t\t\t\t\t\tvecc[j + l] = vec[k - l];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvv.push_back(vecc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(vv.begin(), vv.end());\n\t\t}\n\t}\n\tcout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n    for (auto it = mp.begin(); it != mp.end(); ++it) {\n        if (it != mp.begin()) {\n            os << \", \";\n        }\n        os << *it;\n    }\n    return os << \"]\";\n}\n\n// edit\nint N;\nusing Int = long long; // hash に使う\nInt base = 10; // hash に使う\nint dist_lim = 4; //距離がこれ以内を全列挙\n\nInt hash_vec(const vector<int> &A) {\n    Int ret = 0ll;\n    for (auto e : A) {\n        ret *= base;\n        ret += e;\n    }\n    return ret;\n}\n\n// [l, r]をreverseした場合\nInt next_hash(Int h, int l, int r) {\n    vector<int> A;\n    for (int i = 0; i < N; ++i) {\n        A.push_back(h % base);\n        h /= base;\n    }\n    reverse(all(A));\n\n    reverse(A.begin() + l, A.begin() + r + 1);\n    Int new_hash = hash_vec(A);\n    return new_hash;\n}\n\n// get shortest distance\nvoid get_sd(map<Int, int> &ret, Int start_hash) {\n    queue<Int> que;\n    que.push(start_hash);\n    ret[start_hash] = 0;\n\n    while (!que.empty()) {\n        Int top = que.front();\n        int dist = ret[top];\n        que.pop();\n        if (dist >= dist_lim) continue;\n\n        for (int l = 0; l < N; ++l) {\n            for (int r = l + 1; r < N; ++r) {\n                Int next = next_hash(top, l, r);\n                if (!ret.count(next)) {\n                    ret[next] = dist + 1;\n                    que.push(next);\n                } else {\n//                    if (ret[next] > dist + 1) {\n//                        ret[next] = dist + 1;\n//                        que.push(next);\n//                    }\n//                    chmin(ret[next], dist + 1);\n//                    ret[next] = min(ret[next], dist + 1);\n                }\n            }\n        }\n    }\n}\n\nvoid solve() {\n    cin >> N;\n    vector<int> A(N);\n    REP(i, N) cin >> A[i];\n    REP(i, N) A[i]--;\n\n    map<Int, int> S, G; // key : hash, value : dist\n    vector<int> start_vec;\n    REP(i, N) start_vec.push_back(i);\n    Int start_hash = hash_vec(start_vec);\n    Int goal_hash = hash_vec(A);\n\n    get_sd(S, start_hash);\n    get_sd(G, goal_hash);\n    int ans = N - 1;\n\n    for (auto p : S) {\n        Int h = p.first;\n        int d = p.second;\n\n        if (G.count(h)) {\n            int dist = d + G[h];\n//            chmin(ans, dist);\n            if (ans > dist) {\n                ans = dist;\n                continue;\n            }\n        }\n\n\n//        for (int l = 0; l < N; ++l) {\n//            for (int r = l + 1; r < N; ++r) {\n//                Int next = next_hash(h, l, r);\n//                if (G.count(next)) {\n//                    int dist = d + G[next] + 1;\n//                    if (ans > dist) {\n//                        ans = dist;\n//                    }\n////                    chmin(ans, dist);\n//                }\n//            }\n//        }\n\n    }\n\n    cout << ans << endl;\n\n//    {\n//        queue<Int> sque;\n//        auto vec = vector<int>();\n//        for (int i = 1; i <= N; ++i) vec.push_back(i);\n//        Int s = hash_vec(vec);\n//        sque.push(s);\n//\n//\n//    }\n\n\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nmap<vector<int>, int> dp;\n\nint dfs(vector<int> C, int n)\n{\n\tif (C == B)\n\t{ \n\t\treturn n;\n\t}\n\n\tint min_ = N - 1;\n\n\tif (n < N - 1)\n\t{\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (i != j && C[i] > C[j])\n\t\t\t\t{\n\t\t\t\t\tvector<int> D; D = C;\n\n\t\t\t\t\tswap(D[i], D[j]);\n\n\t\t\t\t\tmin_ = min(dfs(D, n + 1), min_);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn min_;\n}\n\nint main()\n{\n\tcin >> N;\n\n\tA = vector<int>(N);\n\tB = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\n\tfor (int i = 0; i < N; i++) { B[i] = A[i]; }\n\n\tsort(B.begin(), B.end());\n\n\tcout << dfs(A, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[10];\nlong long c[5][4200000];\nlong long d[5][4200000];\nint C[5];\nint D[5];\nlong long p10[]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000LL};\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tlong long S=0;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",b+i);\n\t\tb[i]--;\n\t\tS*=10;\n\t\tS+=b[i];\n\t}\n\tint ans=a-1;\n\tint start=123456789;\n\tfor(int i=0;i<10-a;i++)start/=10;\n\tc[0][C[0]++]=start;\n\td[0][D[0]++]=S;\n\tfor(int i=0;i<4;i++){\n\t//\tprintf(\"%d %d\\n\",C[i],D[i]);\n\t\tfor(int j=0;j<C[i];j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tfor(int l=k+1;l<a;l++){\n\t\t\t\t\tlong long TO=0;\n\t\t\t\t\tfor(int m=0;m<a;m++){\n\t\t\t\t\t\tTO*=10;\n\t\t\t\t\t\tif(k<=m&&m<=l)TO+=c[i][j]%p10[a-k-l+m]/p10[a-k-l+m-1];\n\t\t\t\t\t\telse TO+=c[i][j]%p10[a-m]/p10[a-1-m];\n\t\t\t\t\t}\n\t\t\t\t\tc[i+1][C[i+1]++]=TO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<D[i];j++){\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tfor(int l=k+1;l<a;l++){\n\t\t\t\t\tlong long TO=0;\n\t\t\t\t\tfor(int m=0;m<a;m++){\n\t\t\t\t\t\tTO*=10;\n\t\t\t\t\t\tif(k<=m&&m<=l)TO+=d[i][j]%p10[a-k-l+m]/p10[a-k-l+m-1];\n\t\t\t\t\t\telse TO+=d[i][j]%p10[a-m]/p10[a-1-m];\n\t\t\t\t\t}\n\t\t\t\t\td[i+1][D[i+1]++]=TO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<5;i++){\n\t\tstd::sort(d[i],d[i]+D[i]);\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tint n=i/2;\n\t\tbool ok=false;\n\t\tfor(int j=0;j<C[n];j++)if(binary_search(d[i-n],d[i-n]+D[i-n],c[n][j]))ok=true;\n\t\tif(ok){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//-O2 is required.\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef vector<int> V;\nmap<V,int>m;\n//map<V,pair<pair<int,int>,V> >track;\n//V v1,v2;\npair<int,int>vec2nvec;\nint bfs(V &v, int back){\n\tif(!back&&m.find(v)!=m.end()){\n\t\t//v1.clear();\n\t\t//vec2nvec=make_pair(0,0);\n\t\t//v2=v;\n\t\treturn m[v];\n\t}\n\tset<V>s;\n\tqueue<pair<V,int> >q;\n\tif(back)m[v]=0;\n\ts.insert(v);\n\tint i,j;\n\tfor(q.push(make_pair(v,0));!q.empty();){\n\t\tV vec=q.front().first;\n\t\tint depth=q.front().second;\n\t\tq.pop();\n\t\tif(back&&depth>3)return 0;\n\t\tfor(i=0;i<vec.size();i++)\n\t\t\tfor(j=i+1;j<vec.size();j++){\n\t\t\t\tV nvec=vec;\n\t\t\t\treverse(nvec.begin()+i,nvec.begin()+j+1);\n\t\t\t\tif(!back&&m.find(nvec)!=m.end()){\n\t\t\t\t\t//v1=vec;\n\t\t\t\t\t//vec2nvec=make_pair(i,j);\n\t\t\t\t\t//v2=nvec;\n\t\t\t\t\treturn depth+1+m[nvec];\n\t\t\t\t}\n\t\t\t\tif(!s.insert(nvec).second)continue;\n\t\t\t\tif(back)m[nvec]=depth+1;\n\t\t\t\t//track[nvec]=make_pair(make_pair(i,j),vec);\n\t\t\t\tq.push(make_pair(nvec,depth+1));\n\t\t\t}\n\t}\n\treturn 0;\n}\n//void backtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tbacktrack(track[v].second);\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//}\n//void forwardtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//\tbacktrack(track[v].second);\n//}\nmain(){\n\tV prob;\n\tint i=0,t;\n\tfor(;i<10;i++){\n\t\tif(scanf(\"%d\",&t)==-1)return 0;\n\t\tprob.push_back(t);\n\t}\n\tV goal=prob;\n\tsort(goal.begin(),goal.end());\n\tbfs(goal,1);\n\tprintf(\"%d\\n\",bfs(prob,0));\n\t//backtrack(v1);\n\t//if(vec2nvec.first!=vec2nvec.second)printf(\"%d %d\\n\",vec2nvec.first+1,vec2nvec.second+1);\n\t//forwardtrack(v2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint factorial[10] = { 1,2,6,24,120,720,5040,40320,362880,3628800 };\nint sum1, sum2;\n\nint fact(int A[], int b) {\n\tsum2 = 0;\n\tint used[11] = { 0,0,0,0,0,0,0,0,0,0,0 };\n\tfor (int i1 = 0; i1 < b - 1; i1++) {\n\t\tsum1 = 0;\n\t\tfor (int j1 = 1; j1 <= A[i1]; j1++) {\n\t\t\tif (used[j1] == 0) { \n\t\t\t\tsum1++; \n\t\t\t}\n\t\t}\n\t\tsum2 += (sum1 - 1)*factorial[b - i1 - 2];\n\t\tused[A[i1]] = 1;\n\t}\n\treturn sum2;\n}\nint w[10], z[10];\nvoid fact_hush(int p, int q) {\n\tint used2[11] = { 0,0,0,0,0,0,0,0,0,0,0 };\n\tfor (int i1 = 0; i1 < q - 1; i1++) {\n\t\tw[i1] = (p / factorial[q - i1 - 2]) + 1;\n\t\tp -= (w[i1] - 1)*factorial[q - i1 - 2];\n\t\tfor (int j1 = 1; j1 <= w[i1]; j1++) {\n\t\t\tif (used2[j1] == 1) { w[i1]++; }\n\t\t}\n\t\tused2[w[i1]] = 1;\n\t}\n\tfor (int i1 = 1; i1 <= q; i1++) {\n\t\tif (used2[i1] == 0) { w[q - 1] = i1; }\n\t}\n\tfor (int i1 = 0; i1 < q; i1++) { z[i1] = w[i1]; }\n}\nint x[10][3628800];\nvoid _reverse(int s[], int t[], int d, int e, int f, int g) {\n\tfor (int j = d; j <= e; j++) {\n\t\tt[j] = s[e - j + d];\n\t}\n\tx[f][fact(t, g)] = 0;\n\tfor (int j = d; j <= e; j++) {\n\t\tt[j] = s[j];\n\t}\n}\n\nint main() {\n\tint y[10], n, a, p; cin >> n;\n\tfor (int i = 0; i < 10; i++) { for (int j = 0; j < 3628800; j++) { x[i][j] = 1; } }\n\tfor (int i = 0; i < n; i++) { cin >> y[i]; z[i] = y[i]; }\n\tx[0][fact(y, n)] = 0;\n\tif (x[0][0] == 0) { p = 0; goto owata; }\nloop:;\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < factorial[n - 1]; j++) {\n\t\t\tif (x[i - 1][j] == 0) {\n\t\t\t\tfact_hush(j, n);\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tfor (int l = k + 1; l < n; l++) {\n\t\t\t\t\t\t_reverse(w, z, k, l, i, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) { w[k] = 0; }\n\t\t\t}\n\t\t}\n\t\tif (x[i][0] == 0) { p = i; goto owata; }\n\t}\nowata:;\n\tcout << p << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nvector<int> v;\nmap<vector<int> ,int> d1;\nmap<vector<int> ,int> d2;\nint N;\nvector<int> sorted;\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  queue<vector<int> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  while(q1.size()||q2.size()){\n    {\n      vector<int> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d2.count(nv)!=0&&d1.count(nv)==0){\n\t    cout<<ccost+1+d2[nv]<<endl;\n\t    return 0;\n\t  }\n\t  else if(d1.count(nv)==0){\n\t    d1[nv]=ccost+1;\n\t    if(sorted==nv){\n\t      cout<<ccost+1<<endl;\n\t      return 0;\n\t    }\n\t    q1.push(nv);\n\t  }\n\t}\n      }\n    }\n    {\n      vector<int> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d1.count(nv)!=0&&d2.count(nv)==0){\n\t    cout<<ccost+1+d1[nv]<<endl;\n\t    return 0;\n\t  }\n\t  else if(d2.count(nv)==0){\n\t    d2[nv]=ccost+1;\n\t    if(sorted==nv){\n\t      cout<<ccost+1<<endl;\n\t      return 0;\n\t    }\n\t    q2.push(nv);\n\t  }\n\t}\n      }\n    }\n    \n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nmap<vector<int>,int> bfs(vector<int> A){\n  map<vector<int>,int> D;\n  queue<vector<int> > Q;\n  Q.push(A);\n  D[A] = 0;\n  while(!Q.empty()){\n    vector<int> t = Q.front();Q.pop();\n    int cost = D[t];\n    if(cost == 4) continue;\n    \n    for(int i=0;i<n;i++)\n      for(int j=i+2;j<=n;j++){\n\tvector<int> nt = t;\n\treverse(nt.begin()+i,nt.begin()+j);\n\tif(D.count(nt)) continue;\n\tQ.push(nt);\n\tD[nt]=cost+1;\n    }\n  }\n  return D;\n}\n\n\nint main(){\n  cin>>n;\n  vector<int> A(n),B(n);\n  for(int i=0;i<n;i++) cin>>A[i],B[i] = i+1;\n\n  \n  map<vector<int>,int> X = bfs(A);\n  map<vector<int>,int> Y = bfs(B);\n\n  map<vector<int>,int>::iterator it = X.begin();\n  int ans = 9;\n  \n  for(;it!=X.end();it++)\n    if(Y.count(it->first))ans = min(ans,it->second+Y[it->first]);\n  \n  cout<<ans<<endl;\n  \n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\ninline int solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2 - 1, rn = n - ln - 2;\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tvector<char> tokushu1 = { 3, 1, 5, 2, 7, 4, 9, 6, 10, 8 };\n\n\tif (v == tokushu1)\n\t{\n\t\tprintf(\"9\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,int> P;\nint n,ans=9;\nvector<int> v[2];\nmap<vector<int>,int> s[2];\n\nvoid bfs(bool f){\n  queue<P> Q;\n  Q.push(P(v[f],0));\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    vector<int> b=t.first;\n    int d=t.second;\n    if(f&&s[0].count(b))ans=min(ans,s[0][b]+d);\n    if(s[f].count(b))continue;\n    s[f][b]=d;\n    if(d==4)continue;\n    for(int i=0;i<n;i++)\n      for(int j=i+2;j<=n;j++){\n\treverse(b.begin()+i,b.begin()+j);\n\tQ.push(P(b,d+1));\n\treverse(b.begin()+i,b.begin()+j);\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=1,a;i<=n;i++){\n    cin>>a;\n    v[0].push_back(a);\n    v[1].push_back(i);\n  }\n  bfs(0),bfs(1);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n  \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass State {\npublic:\n  vector<char> nums;\n  int cost;\n  bool operator <(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator >(const State& s) const {\n    return cost > s.cost;\n  }\n  State(const vector<char>& n,int c) {\n    nums = n;\n    cost = c;\n  }\n};\n\nint bfs(const vector<char>& init,\n        map<vector<char>,int>& dp){\n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(State(init,0));\n  dp[init] = 0;\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(s.cost >= 5) continue;\n    for(int lhs = 0; lhs < s.nums.size(); lhs++){\n      for(int rhs = lhs + 1; rhs <= s.nums.size(); rhs++){\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n        \n        if(dp.find(s.nums) != dp.end()){\n          reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n          continue;\n        }\n\n        dp[s.nums] = s.cost + 1;\n        que.push(State(s.nums,s.cost+ 1));\n        reverse(s.nums.begin() + lhs,s.nums.begin() + rhs);\n      }\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    vector<char> nums;\n    for(int i=0; i < N; i++){\n      int num;\n      scanf(\"%d\",&num);\n      nums.push_back(num);\n    }\n    map<vector<char>,int> start;\n    bfs(nums,start);\n\n    map<vector<char>,int> goal;\n    sort(nums.begin(),nums.end());\n    bfs(nums,goal);\n    \n    int res = 100;\n    for(map<vector<char>,int>::iterator it = start.begin();\n        it != start.end();\n        it++){\n      if(goal.find(it->first) != goal.end()){\n        res = min(it->second + goal[it->first],res);\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1;\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){\n\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tif(next_number != sorted_num){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 2){\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){\n\t\t\t\t\tif(swap_count <= 3){\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int c,d,e;\n  S(const vector<int> &pv,int pc):v(pv),c(pc){\n    eval();\n  }\n  void eval(){\n    d=0;\n    for(int i=0;i<v.size();i++){\n      d+=v[i]!=i+1;\n    }\n    e=c+(d+1)/2;\n  }    \n  void swap(int a,int b){\n    c++;\n    std::swap(v[a],v[b]);\n    eval();\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n\nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  set<vector<int> > s;\n  for(;;){\n    S c=que.top();\n    if(c.d==0)break;\n    que.pop();\n    if(!s.insert(c.v).second)continue;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tS n=c;\n\tn.swap(i,j);\n\tque.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\nint main() {\n\tlong long int N;\n\tcin >> N;\n\tvector<long long int>D( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> D[i];\n\t\tD[i]--;\n\t}\n\tmap<vector<long long int>, long long int>memo;\n\tqueue<vector<long long int>>que;\n\tque.push( D );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\n\t\tbool f = true;\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tif( now[i] == i  && f ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf = false;\n\t\t\tfor( size_t j = i + 1; j < N; j++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\treverse( next.begin() + i, next.begin() + j + 1 );\n\t\t\t\tif( !memo.count( next ) ) {\n\t\t\t\t\tmemo[next] = memo[now] + 1;\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort( D.begin(), D.end() );\n\tcout << memo[D] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nshort N;\n\nstruct Array{\n\tshort a[10], d;\n\tArray(){}\n\tArray(short b[], short x){\n\t\tfor(short i = 0; i < N; i++) a[i] = b[i];\n\t\td = x;\n\t}\n\tbool operator==(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, short dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(short i = 0; i < N; i++){\n\t\tfor(short j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(short k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(short k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(short i = 0; i < N; i++) cin >> A.a[i];\n\tfor(short i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\t\n\tshort ans = N-1;\n\tfor(short i = 0; i < vec.size(); i++){\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), vec[i]);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, (short)(p->d + vec[i].d));\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\ntypedef long long ll;\ntypedef std::pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstd::string IntToString(T num){\n  std::string res;std::stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(std::string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\n\nint main(){\n  int N;\n  vector<char> v;\n  map<vector<char> ,int> d1;\n  map<vector<char> ,int> d2;\n  vector<char> sorted;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  queue<vector<char> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  int ans=1<<30;\n  while(q1.size()||q2.size()){\n    {\n      vector<char> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      if(now==sorted){\n  \tcout<<ccost<<endl;\n  \treturn 0;\n      }\n      for(int i=0;i<N;i++){\n  \tfor(int j=i+1;j<N;j++){\n  \t  vector<char> nv=now;\n  \t  reverse(nv.begin()+i,nv.begin()+j+1);\n  \t  if(d2.count(nv)!=0&&d1.count(nv)==0)\n  \t    ans=min(ans,ccost+1+d2[nv]);\n  \t  else if(d1.count(nv)==0){\n  \t    d1[nv]=ccost+1;\n  \t    q1.push(nv);\n  \t  }\n  \t}\n      }\n    }\n    {\n      vector<char> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      if(v==now){\n  \tcout<<ccost<<endl;\n  \treturn 0;\n      }\n      for(int i=0;i<N;i++){\n  \tfor(int j=i+1;j<N;j++){\n  \t  vector<char> nv=now;\n  \t  reverse(nv.begin()+i,nv.begin()+j+1);\n  \t  if(d1.count(nv)!=0&&d2.count(nv)==0)\n  \t    ans=min(ans,ccost+1+d1[nv]);\n  \t  else if(d2.count(nv)==0){\n  \t    d2[nv]=ccost+1;\n  \t    q2.push(nv);\n  \t  }\n  \t}\n      }\n    }\n    if(q1.size()&&q2.size()\n       &&d1[q1.front()]+d2[q2.front()]+1>=ans)break;\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    \n    cin >> N;\n    \n    vector<int> A(N);\n    \n    for(int i = 0; i < N; i++) { cin >> A[i]; }\n    \n    vector<int> B = A; sort(B.begin(), B.end());\n    \n    set<vector<int> > dat; dat.insert(A);\n    \n    queue<vector<int> > que; que.push(A);\n    \n    queue<int> que2; que2.push(0);\n    \n    if(A == B) { cout << 0 << endl; goto Exit; }\n    \n    while(que.size())\n    {\n        vector<int> v1 = que.front(); que.pop();\n        \n        int dist = que2.front(); que2.pop();\n        \n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                vector<int> v2 = v1;\n                \n                swap(v2[i], v2[j]);\n                \n                if(v2 == B) { cout <<  dist + 1 << endl; goto Exit; }\n                \n                if(dat.find(v2) == dat.end())\n                {\n                    dat.insert(v2);\n                    \n                    que.push(v2);\n                    \n                    que2.push(dist + 1);\n                }\n            }\n        }\n    }\n    \n    Exit:;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nstruct S {\n\tvi v;\n\tint cnt, astar;\n\tbool operator >(const S &a) const {\n\t\treturn astar > a.astar;\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\t//while(cin >> n) {\n\t\tS s;\n\t\ts.v.resize(n);\n\t\tREP(i, n) cin >> s.v[i];\n\t\ts.cnt = s.astar = 0;\n\n\t\tint chk = 0;\n\t\tREP(i, n) {\n\t\t\tchk += (i != s.v[i]);\n\t\t\tif(!chk) {\n\t\t\t\tcout << 0 << endl;\n\t\t\t\t//continue;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tset<vi> memo;\n\t\tpriority_queue<S, vector<S>, greater<S> > pq;\n\t\tpq.push(s);\n\n\t\tbool flg = false;\n\t\twhile(!pq.empty()) {\n\t\t\ts = pq.top(); pq.pop();\n\n\t\t\tREP(i, n) {\n\t\t\t\tFOR(j, i, n) {\n\t\t\t\t\tvi _v = s.v;\n\t\t\t\t\tswap(_v[i], _v[j]);\n\n\t\t\t\t\tif(!memo.count(_v)) {\n\t\t\t\t\t\tint astar = 0;\n\t\t\t\t\t\tREP(i, n)\n\t\t\t\t\t\t\tastar += (_v[i] != i);\n\t\t\t\t\t\tpq.push(S{_v, s.cnt+1, astar});\n\t\t\t\t\t\tmemo.insert(_v);\n\t\t\t\t\t\tif(!astar) flg = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flg) break;\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\tcout << s.cnt+1 << endl;\n\t//}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nint n, in;\nlli input;\nvector<lli> input_data;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  return res;\n}\n\nint solve(){\n  if(data.find(input) != data.end()) return data[input];\n  vis.clear();\n  P u = P(input, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli input2 = 0;\n  for(int i=0;i<n;i++){\n    input2 *= 10;\n    if(input_data[i] != 10) input2 += input_data[i];\n  }\n  P u = P(input2, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[input2] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input = 0;\n    input_data.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input *= 10;\n      if(in != 10) input += in;\n      input_data.push_back((lli)in);\n    }\n    sort(input_data.begin(), input_data.end());\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nshort n; vector<short>a; queue<pair<vector<short>,short>>Q;\nvector<pair<vector<short>, short>>a1, a2;\nset<vector<short>>E;\nvoid init(vector<short>R, short Lim, short D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<short>H = Q.front().first; short L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tfor (short j = i + 1; j < n; j++) {\n\t\t\t\tvector<short>I = H; short Y = j;\n\t\t\t\tfor (short k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (short i = 0; i < n; i++) { short p; cin >> p; a.push_back(p); }\n\tshort pos = n / 2; short pos2 = (n - 1) / 2; init(a, pos, 0); vector<short>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos2, 1);\n\tsort(a2.begin(), a2.end());\n\tshort ret = n - 1;\n\tfor (short i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (short)0)) - a2.begin();\n\t\tret = min(ret, (short)(a1[i].second + a2[S1].second));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef pair<vi, int> P;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi a(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\tvi b = a;\n\tsort(ALL(b));\n\tmap<vi, int> mp1, mp2;\n\tqueue<P> que;\n\tque.push(P(a, 0));\n\tmp1[a] = 0;\n\twhile (que.size())\n\t{\n\t\tvi t = que.front().first;\n\t\tint cnt = que.front().second;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) \n\t\t\t{\n\t\t\t\tmp1[nx] = cnt + 1;\n\t\t\t\tif(cnt+1<4) que.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = n - 1;\n\tqueue<P> que2;\n\tque2.push(P(b, 0));\n\twhile (que2.size())\n\t{\n\t\tvi t = que2.front().first;\n\t\tint cnt = que2.front().second;\n\t\tque2.pop();\n\t\tif (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j);\n\t\t\tif (mp2.find(nx) == mp2.end())\n\t\t\t{\n\t\t\t\tmp2[nx] = cnt + 1;\n\t\t\t\tif(cnt<4)que2.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nvector<char> v;\nmap<vector<char> ,int> d1;\nmap<vector<char> ,int> d2;\nint N;\nvector<char> sorted;\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  queue<vector<char> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  int ans=1<<30;\n  while(q1.size()||q2.size()){\n    {\n      vector<char> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      if(now==sorted){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<char> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d2.count(nv)!=0&&d1.count(nv)==0)\n\t    ans=min(ans,ccost+1+d2[nv]);\n\t  if(d1.count(nv)==0){\n\t    d1[nv]=ccost+1;\n\t    q1.push(nv);\n\t  }\n\t}\n      }\n    }\n    {\n      vector<char> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      if(v==now){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<char> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d1.count(nv)!=0&&d2.count(nv)==0)\n\t    ans=min(ans,ccost+1+d1[nv]);\n\t  if(d2.count(nv)==0){\n\t    d2[nv]=ccost+1;\n\t    q2.push(nv);\n\t  }\n\t}\n      }\n    }\n    if(q1.size()&&q2.size()){\n      int sum=d1[q1.front()]+d2[q2.front()];\n      if(sum>=ans)break;\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nqueue<P> q;\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n    \n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=n;i>=2;i--){ // range\n      \n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\t\n\tif(j&&j+i-1<n&&(!(abs(nS[j-1]-nS[j+1-1])<=1)&&!(abs(nS[j+i-2]-nS[j]<=1)))) continue;\n\t\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\t\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1;\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < index-1; i++){\n\t\t\tfor(int k = i+1; k < index; k++){\n\t\t\t\tfor(int p = 0; p < index; p++)work[p] = calc_array[p];\n\t\t\t\tswap(work[i],work[k]);\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < index; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){\n\t\t\t\t\tans = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 3){\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tfor(int i = 0; i < index-1; i++){\n\t\t\tfor(int k = i+1; k < index; k++){\n\t\t\t\tfor(int p = 0; p < index; p++)work[p] = calc_array[p];\n\t\t\t\tswap(work[i],work[k]);\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < index; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){\n\t\t\t\t\tif(swap_count <= 3){\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nshort n; vector<short>a; queue<pair<vector<short>,short>>Q;\nvector<pair<vector<short>, short>>a1, a2;\nset<vector<short>>E;\nvoid init(vector<short>R, short Lim, short D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<short>H = Q.front().first; short L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (short i = 0; i < n; i++) {\n\t\t\tfor (short j = i + 1; j < n; j++) {\n\t\t\t\tvector<short>I = H; short Y = j;\n\t\t\t\tfor (short k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (short i = 0; i < n; i++) { short p; cin >> p; a.push_back(p); }\n\tshort pos = n / 2; short pos2 = (n - 1) / 2; init(a, pos, 0); vector<short>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos2, 1);\n\tsort(a2.begin(), a2.end());\n\tshort ret = n - 1;\n\tfor (short i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (short)0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tfor (int j = S1; j < S2; j++) ret = min(ret, (short)(a1[i].second + a2[j].second));\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//yarudake => ??¨???????????????O(N! * N^3)??§???????¶???????\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint n;\nint a[10];\nint dp[5000000];\n\n//[l, r)\nvoid reverse(vector<int> &vec, int l, int r) {\n\twhile (l < r - 1) {\n\t\tswap(vec[l], vec[r - 1]);\n\t\tl++;\n\t\tr--;\n\t}\n}\n\n//??¶?????¨???????¨???¶????????¨(?????????)\nint encode(vector<int> &vec) {\n\tint val[11];\t//val[i] = ???i????????????????°??????????\n\t\n\tint fact = 1;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tval[i + 1] = i;\n\t\tfact *= i + 1;\n\t}\n\tfact /= vec.size();\n\t\n\tint ret = 0;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tret += fact * val[vec[i]];\n\t\tif (i + 1 < vec.size()) fact /= (vec.size() - 1 - i);\n\t\tfor (int j = vec[i] + 1; j <= vec.size(); j++) {\n\t\t\tval[j]--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> a[i];\n\tfor (i = 0; i < 5000000; i++) dp[i] = 114514;\n\t\n\ttypedef vector<int> V;\n\t\n\tV first;\n\tfor (i = 0; i < n; i++) first.push_back(a[i]);\n\t\n\tqueue<V> que;\n\tque.push(first); dp[encode(first)] = 0;\n\twhile (!que.empty()) {\n\t\tV now = que.front(); que.pop();\n\t\tint cst = dp[encode(now)];\n\t\t\n\t\tfor (int l = 0; l < n; l++) {\n\t\t\tfor (int r = l + 1; r <= n; r++) {\n\t\t\t\treverse(now, l, r);\n\t\t\t\tif (dp[encode(now)] > cst + 1) {\n\t\t\t\t\tdp[encode(now)] = cst + 1;\n\t\t\t\t\tque.push(now);\n\t\t\t\t}\n\t\t\t\treverse(now, l, r);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint rec(vector<int> v, int depth)\n{\n  while( v[0] == *min_element(v.begin(),v.end()) ){\n    v.erase(v.begin());\n    if(v.empty()) return depth;\n  }\n  while( v.back() == *max_element(v.begin(),v.end()) ){\n    v.erase(v.end()-1);\n    if(v.empty()) return depth;\n  }\n  vector<int> dup1, dup2;\n  dup1 = dup2 = v;\n  reverse( dup1.begin(), min_element(dup1.begin(),dup1.end())+1 );\n  reverse( max_element(dup2.begin(),dup2.end()), dup2.end() );\n  return min( rec(dup1, depth+1), rec(dup2, depth+1) );\n\n}\nint main()\n{\n  int N;\n  vector<int> v;\n\n  cin>>N;\n  v.resize(N);\n  for(int i=0; i<N; i++)cin>>v[i];\n  cout<<rec(v,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<int> v, r;\n\nvector<pair<vector<int>, int> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2, rn = n - n / 2 - 1;\n\n\tmap<vector<int>, int> d1; d1[v] = 1;\n\n\tqueue<vector<int> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<int> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<int>, int> d2; d2[r] = 1;\n\n\tqueue<vector<int> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<int> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v1.begin(), v1.end());\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<int> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\t\t\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<int>(n);\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct S{\n  vector<int> v;\n  int c,d,e;\n  S(const vector<int> &pv,int pc):v(pv),c(pc){\n    eval();\n  }\n  void eval(){\n    d=0;\n    for(int i=0;i<v.size()-1;i++){\n      d+=abs(v[i]-v[i+1])>1;\n    }\n    e=c+(d+1)/2;\n  }   \n  void reverse(int a,int b){\n    c++;\n    std::reverse(begin(v)+a,begin(v)+b+1);\n    eval();\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n \nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  map<vector<int>,int> m;\n  for(;;){\n    S c=que.top();\n    if(c.d==0)break;\n    que.pop();\n    if(m.count(c.v)&&m[c.v]<=c.c)continue;\n    m[c.v]=c.c;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n    S n=c;\n    n.reverse(i,j);\n    que.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nint po[11],a[11];\nvoid print(int x){\n  for(int i=0;i<n;i++) cout<<x%11<<\" \",x/=11;\n  cout<<endl;\n}\nvoid sw(int &x,int i,int j){\n  int s=(x%po[i+1])/po[i]*(po[j]-po[i]);\n  int t=(x%po[j+1])/po[j]*(po[i]-po[j]);\n  x+=s+t;\n}\nsigned main(){\n  po[0]=1;\n  for(int i=0;i<10;i++) po[i+1]=po[i]*11;\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>a[i];\n  int p[2]={};\n  for(int i=0;i<n;i++) p[0]=p[0]*11+a[i];\n  for(int i=0;i<n;i++) p[1]=p[1]*11+(i+1);\n  if(p[0]==p[1]){\n    cout<<0<<endl;\n    return 0;\n  }\n  //cout<<p<<endl<<ans<<endl;\n  //print(p);print(ans);\n  queue<int> q[2];\n  unordered_map<int,int> m[2];\n  int ans=n-1;\n  for(int j=0;j<2;j++){\n    q[j].push(p[j]);\n    m[j][p[j]]=0;\n    while(!q[j].empty()){\n      int t=q[j].front();q[j].pop();\n      int d=m[j][t];\n      if(d>=(n-1)/2) break;\n      //cout<<d<<\":\";print(p);\n      for(int i=1;i<n-1;i++){\n\tint r=t;\n\tfor(int k=1;i-k>=0&&i+k<n;k++){\n\t  sw(r,i-k,i+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n      for(int i=0;i<n-1;i++){\n\tint r=t;\n\tfor(int k=0;i-k>=0&&i+1+k<n;k++){\n\t  sw(r,i-k,i+1+k);\n\t  if(!m[j].count(r)){\n\t    q[j].push(r);\n\t    m[j][r]=d+1;\n\t    if(j&&m[0].count(r))\n\t      ans=min(ans,m[0][r]+m[1][r]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, a[10];\n\nint main(){\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\t\n\tmap<ll, int> m;\n\tset<ll> s;\n\tqueue<pair<int, ll> > q;\n\tll t = 0, g = 0;\n\trep(i, n){\n\t\tt *= 10, t += a[i];\n\t\tg *= 10, g += i + 1;\n\t}\n\tq.push(mp(0, g));\n\tm[g] = 0;\n\t\n\twhile(!q.empty()){\n\t\tll t = q.front().second;\n\t\tint c = q.front().first; q.pop();\n\t\t\n\t\trep(i, n) a[n - 1 - i] = t % 10, t /= 10;\n\t\trep(i, n) for(int j = i + 1; j < n; j++){\n\t\t\treverse(a + i, a + j + 1);\n\t\t\tll h = 0;\n\t\t\trep(k, n) h *= 10, h += a[k];\n\t\t\tif(!m.count(h)){\n\t\t\t\tm[h] = c + 1;\n\t\t\t\tif(c < 3) q.push(mp(c + 1, h));\n\t\t\t}\n\t\t\treverse(a + i, a + j + 1);\n\t\t}\n\t}\n\tif(m.count(t)){\n\t\tcout << m[t] << endl;\n\t\treturn 0;\n\t}\n\tq.push(mp(0, t));\n\ts.insert(t);\n\t\n\twhile(!q.empty()){\n\t\tll t = q.front().second;\n\t\tint c = q.front().first; q.pop();\n\t\t\n\t\trep(i, n) a[n - 1 - i] = t % 10, t /= 10;\n\t\trep(i, n) for(int j = i + 1; j < n; j++){\n\t\t\treverse(a + i, a + j + 1);\n\t\t\tll h = 0;\n\t\t\trep(k, n) h *= 10, h += a[k];\n\t\t\tif(m.count(h)){\n\t\t\t\tcout << c + 1 + m[h] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(c < 3 && !s.count(h)){\n\t\t\t\ts.insert(h);\n\t\t\t\tq.push(mp(c + 1, h));\n\t\t\t}\n\t\t\treverse(a + i, a + j + 1);\n\t\t}\n\t}\n\tcout << 9 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 10;\nconst int INF = 1 << 29;\n\nstruct state{\n  lli num;\n  int cnt;\n  state(lli num=0, int cnt=0):num(num),cnt(cnt){}\n};\n\nint n;\nlli pow_10[11];\nvector<int> v;\n\nlli hash(const vector<int> &vec){\n  lli res = 0, di = 1;\n  \n  for(int i=vec.size()-1;i>=0;i--){\n    res += vec[i] * di;\n    di *= 10;\n  }\n\n  return res;\n}\n\nlli reverse(lli num, int begin, int end){\n  lli res = num;\n  lli powbe = pow_10[begin], powen = pow_10[end];\n\n  for(int i=0;i<(end-begin+1)/2;i++){\n    res += powbe * (num / powen % 10 - num / powbe % 10);\n    res += powen * (num / powbe % 10 - num / powen % 10);\n    powbe *= 10;\n    powen /= 10;\n  }\n  \n  return res;\n}\n\nint bfs(lli num, map<lli, int> mp[2], int mp_pos){\n  int res = INF;\n  queue<state> q;\n  state u, u2;\n\n  mp[mp_pos][num] = 0;\n\n  for(q.push(state(num, 0)); !q.empty();){\n    u = q.front();\n    q.pop();\n\n    if(mp_pos == 1 && mp[0].count(u.num)) res = min(res, mp[0][u.num] + u.cnt);\n    if(mp_pos == 0 && u.cnt >= 4 || u.cnt >= 5) continue;\n\n    for(int i=0;i<n-1;i++){\n      for(int j=i+1;j<n;j++){\n        u2 = state(reverse(u.num, i, j), u.cnt + 1);\n        if(!mp[mp_pos].count(u2.num)){\n          mp[mp_pos][u2.num] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n\n  return res;\n}\n\nint solve(){  \n  vector<int> w = v;\n  map<lli, int> mp[2];\n\n  sort(w.begin(), w.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(v[i] == w[j]) {\n        v[i] = j;\n        break;\n      }\n    }\n  }\n\n  w = v;\n  sort(w.begin(), w.end());\n\n  bfs(hash(w), mp, 0);\n  return bfs(hash(v), mp, 1);\n}\n\nint main(){\n  pow_10[0] = 1;\n  for(int i=1;i<11;i++) pow_10[i] = pow_10[i-1] * 10;\n\n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nmap<vi,int> dist,dist2;\n\nint a[15];\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\tvi in(n,0);\n\trep(i,n) in[i]=i;\n\tdist[in]=0;\n\tqueue<vi> q;\n\tq.push(in);\n\n\twhile(!q.empty()){\n\t\tvi ci=q.front();q.pop();\n\t\trep(i,n)rep(j,n){\n\t\t\tif(j+1-i<=1) continue;\n\t\t\tvi ni=ci;\n\t\t\treverse(ci.begin()+i,ci.begin()+j+1);\n\t\t\tif(dist[ci]<=3&&dist[ni]>dist[ci]+1){\n\t\t\t\tdist[ni]=dist[ci]+1;\n\t\t\t\tq.push(ni);\n\t\t\t}\n\t\t}\n\t}\n\n\tvi in2(n,0);\n\trep(i,n) cin >> in2[i];\n\tdist2[in2]=0;\n\tq.push(in2);\n\n\twhile(!q.empty()){\n\t\tvi ci=q.front();q.pop();\n\t\trep(i,n)rep(j,n){\n\t\t\tif(j+1-i<=1) continue;\n\t\t\tvi ni=ci;\n\t\t\treverse(ci.begin()+i,ci.begin()+j+1);\n\t\t\tif(dist2[ci]<=3&&dist2[ni]>dist2[ci]+1){\n\t\t\t\tdist2[ni]=dist2[ci]+1;\n\t\t\t\tq.push(ni);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=n-1;\n\tfor(auto &i:dist){\n\t\tif(dist2.find(i.first)==dist2.end()) continue;\n\t\tans=min(ans,dist[i.first]+dist2[i.first]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n\nvoid calcF(int N, vector< int >& A, vector< int >& F) {\n\tfor_(i,0,N) {\n\t\tF[i] = 0;\n\t\tfor_(j,0,i) if (A[j] > A[i]) ++F[i];\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tvector< int > A(N);\n\tvector< int > F(N, 0);\n\tfor_(i,0,N) cin >> A[i];\n\t\n\tcalcF(N, A, F);\n\tint ans = 0;\n\t\n\twhile (accumulate(F.begin(), F.end(), int()) > 0) {\n\t\tfor_rev(i,N-1,1) {\n\t\t\tif (F[i] > 0) {\n\t\t\t\tbool flag = true;\n\t\t\t\t\n\t\t\t\tfor_rev(j,i-1,0) {\n\t\t\t\t\tif (F[j] > F[i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (F[j] == 0) {\n\t\t\t\t\t\treverse(A.begin() + j, A.begin() + i + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (flag) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalcF(N, A, F);\n\t\t++ans;\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint n; vector<int> a;\n\nstruct state\n{\n    vector<int> v;\n    \n    int dist1;\n    int dist2;\n    \n    state(vector<int> v1, int d1, int d2) : v(v1), dist1(d1), dist2(d2) { }\n};\n\nbool operator<(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 < s2.dist1 + s2.dist2; }\nbool operator>(const state& s1, const state& s2) { return s1.dist1 + s1.dist2 > s2.dist1 + s2.dist2; }\n\ninline int getdistance(vector<int> v)\n{\n    int ret = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(v[i] != i + 1)\n        {\n            ret++;\n        }\n    }\n    \n    return ret;\n}\n\nmap<vector<int>, bool> M;\n\nint main()\n{\n    scanf(\"%d\", &n); a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    priority_queue<state, vector<state>, greater<state> > que;\n    \n    que.push(state(a, 0, getdistance(a))); M[a] = true;\n    \n    while(!que.empty())\n    {\n        state s = que.top(); que.pop();\n        \n        if(s.dist2 == 0)\n        {\n            printf(\"%d\\n\", s.dist1); break;\n        }\n        \n        for(int i = 0; i < n; i++)\n        {\n            for(int j = i + 2; j <= n; j++)\n            {\n                reverse(s.v.begin() + i, s.v.begin() + j);\n\n                if(!M[s.v])\n                {\n                    M[s.v] = true;\n\n                    que.push(state(s.v, s.dist1 + 1, getdistance(s.v)));\n                }\n                \n                reverse(s.v.begin() + i, s.v.begin() + j);\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint N;\n\nstruct Array{\n\tint a[10], d;\n\tArray(){}\n\tArray(int b[], int x){\n\t\tfor(int i = 0; i < N; i++) a[i] = b[i];\n\t\td = x;\n\t}\n\tbool operator==(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, int dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(int k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(int k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> A.a[i];\n\tfor(int i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\t\n\tint ans = N-1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), vec[i]);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, p->d + vec[i].d);\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nvector<int> flip(vector<int> vec, int l, int r) {\n    vector<int> ret = vec;\n    for(int i=0; i<(r-l+1); i++) {\n        int idx = i + l, cand = r - i;\n\n        ret[idx] = vec[cand];\n    }\n    return ret;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<int> perm(N);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d\", &perm[i]);\n    }\n\n    map< vector<int>, int > rec;\n    rec[ perm ] = 0;\n\n    queue< pair< vector<int>, pair<int, int> > > que;\n    que.push(make_pair(perm, make_pair(-1, -1)));\n\n    vector<int> term(N);\n    iota(term.begin(), term.end(), 1);\n    while(que.size()) {\n        vector<int> cur; pair<int, int> lr;\n        tie(cur, lr) = que.front(); que.pop();\n        int val = rec[cur];\n\n        // new\n        for(int l=0; l<N; l++) {\n            for(int k=1; k<=2; k++) {\n                int r = l + k;\n                if(r < N) {\n                    swap(cur[l], cur[r]);\n\n                    if(!rec.count(cur)) {\n                        rec[cur] = val + 1;\n                        que.push(make_pair(cur, make_pair(l, r)));\n                    }\n\n                    swap(cur[l], cur[r]);\n                }\n            }\n        }\n        \n        if(lr.first != -1) {\n            int nl = lr.first - 1, nr = lr.second + 1;\n            if(nl < 0 || nr >= N) continue;\n\n            swap(cur[nl], cur[nr]);\n\n            if(!rec.count(cur)) {\n                rec[cur] = val;\n                que.push(make_pair(cur, make_pair(nl, nr)));\n            }\n\n            swap(cur[nl], cur[nr]);\n        }\n\n        if(rec.count(term)) {\n            break;\n        }\n    }\n\n    printf(\"%d\\n\", rec[ term ]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N;\nint A[22];\n\nint left_rev(int l){\n  for(int i=l;i<N;i++){\n    if( A[i] == l ) return i;\n  }\n  assert(false);\n  return -1;\n}\nint right_rev(int r){\n  for(int i=r;i>-1;i--)\n    if( A[i] == r ) return i;\n  assert(false);\n  return -1;\n}\n\nvoid upd(int &a,int b){\n  a = min( a, b );\n}\n\nvoid view(){\n  for(int i=0;i<N;i++) cout << A[i] << \" \";\n  cout << endl;\n}\nint solve(int l,int r){\n  if( l>=r ) return 0;\n  int ret = 100000;\n  int nl = left_rev(l);\n  if( nl == l ) upd( ret, solve(l+1,r) );\n  else {\n    reverse( A+l,A+nl+1 );\n    upd( ret, solve( l+1, r )+1 );\n    reverse( A+l,A+nl+1 );\n  }\n  int nr = right_rev(r);\n  if( nr == r ) upd( ret, solve(l,r-1) );\n  else {\n    reverse( A+nr,A+r+1 );\n    upd( ret, solve( l, r-1 )+1 );\n    reverse( A+nr,A+r+1 );\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> N){\n    for(int i=0;i<N;i++) {\n      cin >>A[i]; A[i]--;\n    }\n    cout << solve(0,N-1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<int> v, r;\n\nvector<pair<vector<int>, int> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tmap<vector<int>, int> d1; d1[v] = 1;\n\n\tqueue<vector<int> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<int> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < n / 2 + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<int>, int> d2; d2[v] = 1;\n\n\tqueue<vector<int> > que2; que2.push(v);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<int> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < n - n / 2 + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v1.begin(), v1.end());\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<int> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\t\t\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<int>(n);\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            /*for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }*/\n            \n            for(int s=0;s<N;s++){\n                for(int d=1;d<=2;d++){\n                    int S = s;\n                    int T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        int nextPermId = getPermId(perm);\n                        if(dist[curr][nextPermId] == -1){\n                            dist[curr][nextPermId] = nowCost + 1;\n                            \n                            if(dist[next][nextPermId] != -1){\n                                return dist[curr][nextPermId] + dist[next][nextPermId];\n                            } else {\n                                nextQueue.push_back(make_pair(perm, nextPermId));\n                            }\n                        }\n                        \n                        --S;\n                        ++T;\n                    }\n                    \n                    S = s;\n                    T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        --S;\n                        ++T;\n                    }\n                }\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        cin >> start[i];\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint main(){\n    int n;\n    cin >> n;\n    string v;\n    rep(i,n){\n        char c; cin >> c;\n        v += c;\n    }\n    set<string> dp;\n    queue<pair<int,string>> q;\n    dp.insert(v);\n    q.emplace(0,v);\n    int ans = -1;\n    while(q.size()){\n        int d; string v;\n        tie(d,v) = q.front();\n        q.pop();\n        bool ok = true;\n        rep(i,n-1) ok &= v[i]+1==v[i+1];\n        if(ok){\n            ans = d;\n            break;\n        }\n        rep(i,n+1)rep(j,i){\n            reverse(v.begin()+j,v.begin()+i);\n            if(dp.count(v)==0) q.emplace(d+1,v);\n            reverse(v.begin()+j,v.begin()+i);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nint ans=9;\nmap<vector<int>,int> memo;\n\nvoid make(vector<int> &a,int d){\n\tconst int n=a.size();\n\t\n\tif(memo.find(a)==end(memo)) memo[a]=d;\n\tchmin(memo[a],d);\n\n\tif(d==4) return;\n\trep(j,n)rep(i,j){\n\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\tmake(a,d+1);\n\t\treverse(begin(a)+i,begin(a)+j+1);\n\t}\n}\n\n\nvoid dfs(vector<int> &a,int d){\n\tconst int n=a.size();\n\tif(memo.find(a)!=end(memo)) chmin(ans,d+memo[a]);\n\n\tif(d==4) return;\n\trep(j,n)rep(i,j){\n\t\treverse(begin(a)+i,begin(a)+j+1);\n\t\tdfs(a,d+1);\n\t\treverse(begin(a)+i,begin(a)+j+1);\n\t}\n}\n\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\tvector<int> in(n);\t\n\trep(i,n) cin >> in[i];\n\tmake(in,0);\n\n\tvector<int> init(n);\n\tiota(begin(init),end(init),1);\n\tdfs(init,0);\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint bfs(vector<int> v)\n{\n    map<vector<int>, int> D; D[v] = 1;\n    \n    vector<int> sorted = v; sort(sorted.begin(), sorted.end());\n    \n    queue<pair<vector<int>, int> > que; que.push(make_pair(v, 1));\n    \n    while(!que.empty())\n    {\n        pair<vector<int>, int> p1 = que.front(); que.pop();\n        \n        for(int i = 0; i < v.size(); i++)\n        {\n            for(int j = i + 1; j < v.size(); j++)\n            {\n                vector<int> p2 = p1.first;\n                \n                swap(p2[i], p2[j]);\n                \n                if(D[p2] == 0)\n                {\n                    if(p2 == sorted)\n                    {\n                        return p1.second;\n                    }\n                    \n                    D[p2] = p1.second + 1;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main()\n{\n    int n; vector<int> a;\n    \n    cin >> n; a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    \n    cout << bfs(a) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<vector<int>,int>P;\n\nint n;\n\nmap<vector<int>,int> BFS(vector<int> A){\n  map<vector<int>,int>m;\n  m[A]=0;\n  queue<P>q;\n  q.push(P(A,0));\n  while(!q.empty()){\n    vector<int> B=q.front().first;\n    int cost=q.front().second;q.pop();\n    if(cost==4)continue;\n    for(int l=0;l<n-1;l++){\n      for(int r=l+1;r<n;r++){\n        vector<int>C=B;\n        reverse(C.begin()+l,C.begin()+r+1);\n        if(!m.count(C)){\n          m[C]=cost+1;\n          q.push(P(C,cost+1));\n        }\n      }\n    }\n  }\n  return m;\n}\n\nint main(){\n  cin>>n;\n  vector<int>A(n),B(n);\n  r(i,n)cin>>B[i],A[i]=i+1;\n  map<vector<int>,int>m1=BFS(A);\n  map<vector<int>,int>m2=BFS(B);\n  int ans=9;\n  do{\n    if(m1.count(A)&&m2.count(A)){\n      ans=min(ans,m1[A]+m2[A]);\n    }\n  }while(next_permutation(A.begin(),A.end()));\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n#include <utility>\n#include <iostream>\nusing namespace std;\nusing Map = map< vector<int>, int >;\n\nint N;\n\nvector<int> flip(vector<int> &vec, int &l, int &r) {\n    vector<int> ret = vec;\n\n    for(int i=l; i<=r; i++) {\n        int il = i, ir = r - (i-l);\n        if(il >= ir) break;\n\n        swap(ret[il], ret[ir]);\n    }\n    return ret;\n}\n\nint solve(vector<int> &init, vector<int> &term, Map &cur, Map &pre) {\n    int ret = N - 1;\n    queue< vector<int> > que;\n    que.push(init);\n\n    while(que.size()) {\n        vector<int> vec = que.front(); que.pop();\n        if(pre.count(vec)) {\n            ret = min(ret, cur[ vec ] + pre[ vec ]);\n        }\n        if(cur[ vec ] >= (N - 1) / 2) continue;\n\n        for(int l=0; l<N; l++) {\n            for(int r=l+1; r<N; r++) {\n                vector<int> nxt = flip(vec, l, r);\n                if(cur.count(nxt)) continue;\n                cur[ nxt ] = cur[ vec ] + 1;\n                que.push(nxt);\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    vector<int> perm(N);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d\", &perm[i]);\n    }\n\n    vector<int> term(N);\n    iota(term.begin(), term.end(), 1);\n\n    Map ml, mr;\n    ml[ perm ] = 0;\n    mr[ term ] = 0;\n\n    int ans = N - 1;\n    ans = min(ans, solve(perm, term, ml, mr));\n    ans = min(ans, solve(term, perm, mr, ml));\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<string,int>P;\nint main(){\n    int n;\n    cin>>n;\n    string start,goal;\n    for(int i=0;i<n;i++){\n        int a;\n        cin>>a;\n        start+=a+'0'-1;\n    }\n    for(int i=0;i<n;i++){\n        goal+='0'+i;\n    }\n    map<string,int>M;\n    queue<P>Q;\n    Q.push(P(start,0));\n    int f=-1;\n    while(Q.size()){\n        P p=Q.front();Q.pop();\n        if(M[p.first]==1)continue;\n        M[p.first]=1;\n        if(p.first==goal){\n            f=p.second;\n            break;\n        }\n\n        for(int i=0;i<n-1;i++){\n            for(int j=i+2;j<=n;j++){\n                string str=p.first;\n                reverse(str.begin()+i,str.begin()+j);\n                Q.push(P(str,p.second+1));\n            }\n        }\n    }\n    if(f!=-1)cout<<f<<endl;\n    else cout<<\"NA\"<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v;\n  int c,d,e;\n  S(const vector<int> &pv,int pc):v(pv),c(pc){\n    eval();\n  }\n  void eval(){\n    d=0;\n    for(int i=0;i<v.size();i++){\n      d+=v[i]!=i+1;\n    }\n    e=c+(d+1)/2;\n  }    \n  void reverse(int a,int b){\n    c++;\n    std::reverse(begin(v)+a,begin(v)+b+1);\n    eval();\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n\nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  map<vector<int>,int> m;\n  for(;;){\n    S c=que.top();\n    if(c.d==0)break;\n    que.pop();\n    if(m.count(c.v)&&m[c.v]<=c.c)continue;\n    m[c.v]=c.c;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tS n=c;\n\tn.reverse(i,j);\n\tque.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tif(dist[ma[v]]==4)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tif(dist[ma[uv]]==-1){\n\t\t\t\t\tdist[ma[uv]]=dist[ma[v]]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[ma[uv]]){\n\t\t\t\t\tres=min(res,dist[ma[v]]+dist[ma[uv]]+1);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[lv];\n\t\tif(dist[lv]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint N;\n\nll encode(int * v){\n    ll res = 0;\n    rep(i,N) res = res<<4|v[i];\n    return res;\n}\nvoid decode(ll v, int * a){\n    rep(i,N){\n        a[N-i-1] = v&0xF;\n        v >>= 4;\n    }\n}\n\nint main(){\n    cin >> N;\n    int init[15];\n    rep(i,N) cin >> init[i];\n    int goal[15];\n    rep(i,N) goal[i] = i+1;\n    map<ll,int> x,y;\n    ll ans = -1;\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(init),0);\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            if(x.count(c)) continue;\n            int e[15];\n            decode(c,e);\n            x[c] = d;\n            if(d==4) continue;\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    q.emplace(w,d+1);\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    {\n        queue<pair<ll,int>> q;\n        q.emplace(encode(goal),0);\n        while(q.size()){\n            ll c,d;\n            tie(c,d) = q.front();q.pop();\n            if(y.count(c)) continue;\n            int e[15];\n            decode(c,e);\n            y[c] = d;\n            if(d==4) continue;\n            if(x.count(c)){\n                ans = d+x[c];\n                break;\n            }\n            rep(i,N+1)rep(j,i){\n                reverse(e+j,e+i);\n                ll w = encode(e);\n                if(x.count(w)==0){\n                    y[w] = d+1;\n                    q.emplace(w,d+1);\n                }\n                reverse(e+j,e+i);\n            }\n        }\n    }\n    if(ans == -1) ans = 9;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> A(N); rep(i,N) cin >> A[i];\n\tll tmp = 0, gl = 0;\n\trep(i,N) {\n\t\ttmp *= 10;\n\t\ttmp += A[i]-1;\n\t\tgl *= 10;\n\t\tgl += i;\n\t}\n\tvector<pli> candidate[2];\n\trep(a,2) {\n\t\tqueue<pli> q;\n\t\tq.push(pli(!a ? tmp : gl, 0));\n\t\tunordered_set<ll> used;\n\t\tused.insert(q.front().first);\n\t\twhile(q.size()) {\n\t\t\tcandidate[a].push_back(q.front());\n\t\t\tll t = q.front().first;\n\t\t\tll turn = q.front().second; q.pop();\n\t\t\tif(turn > 4) break;\n\t\t\tvector<int> v(N);\n\t\t\trrep(i,N) {\n\t\t\t\tv[i] = t % 10;\n\t\t\t\tt /= 10;\n\t\t\t}\n\t\t\trep(i,N) {\n\t\t\t\tfor(int j = i+1; j < N; j++) {\n\t\t\t\t\tvector<int> vv = v;\n\t\t\t\t\tll nx = 0;\n\t\t\t\t\treverse(vv.begin()+i, vv.begin()+j+1);\n\t\t\t\t\trep(i,N) {\n\t\t\t\t\t\tnx *= 10;\n\t\t\t\t\t\tnx += vv[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(used.find(nx) == used.end()) {\n\t\t\t\t\t\tused.insert(nx);\n\t\t\t\t\t\tq.push(pli(nx,turn+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(candidate[a].begin(), candidate[a].end());\n\t}\n\tint res = 9;\n\trep(i,candidate[0].size()) {\n\t\tint indx;\n\t\tindx = lower_bound(candidate[1].begin(), candidate[1].end(), candidate[0][i])\n\t\t\t- candidate[1].begin();\n\t\tif(candidate[0][i].first == candidate[1][indx].first) {\n\t\t\tres = min(res, candidate[0][i].second+candidate[0][indx].second);\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nstring rev(const string &s, int i, int j){\n  string ret = s;\n  for(int k = i; k <= j; ++k) ret[k] = s[j-k+i];\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  string C(N, '0');\n  for(int i = 0; i < N; ++i) C[i] = '0' + i;\n  if(A == C){\n    cout << 0 << endl;\n    return 0;\n  }\n  queue<string> que;\n  //set<string> S, T;\n  set<long long> S, T;\n  S.insert(stoll(A));\n  T.insert(stoll(A));\n  for(int i = 0; i < N-1; ++i){\n    //set<string> S_;\n    set<long long> S_;\n    //for(set<string>::iterator itr = S.begin(); itr != S.end(); ++itr){\n    for(set<long long>::iterator itr = S.begin(); itr != S.end(); ++itr){\n      //string s = *itr;\n      string s = to_string(*itr);\n      if(s.length() < N) s = '0' + s;\n      for(int j = 0; j < N; ++j){\n        for(int k = j+1; k < N; ++k){\n          string t = rev(s, j, k);\n          if(t == C){\n            cout << i+1 << endl;\n            return 0;\n          }\n          if(T.find(stoll(t)) == T.end()){\n            S_.insert(stoll(t));\n            T.insert(stoll(t));\n          }\n        }\n      }\n    }\n    S = S_;\n  }\n  cout << N-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nstruct Elm {\n  int d;\n  vi v;\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n; cin >> n;\n  vi a(n);\n  for(int i=0;i<n;++i) {\n    cin >> a[i];\n    a[i]--;\n  }\n  queue<Elm> pq;\n  map<vi, P> mp;\n  map<vi, bool> upd1, upd2;\n  pq.push({0, a});\n  mp[a].first = 0;\n  upd1[a] = true;\n  while(!pq.empty()) {\n    auto now = pq.front(); pq.pop();\n    if(upd1[now.v] && mp[now.v].first < now.d) continue;\n    for(int i=0;i<n;++i) {\n      for(int j=i+1;j<n;++j) {\n        for(int k=0;k<(j-i+1)/2;++k) {\n          swap(now.v[i+k], now.v[j-k]);\n        }\n        if((!upd1[now.v] || mp[now.v].first > now.d + 1) && now.d < 4) {\n          upd1[now.v] = true;\n          mp[now.v].first = now.d + 1;\n          if(now.d+1 < 4) pq.push({now.d + 1, now.v});\n        }\n        for(int k=0;k<(j-i+1)/2;++k) {\n          swap(now.v[i+k], now.v[j-k]);\n        }\n      }\n    }\n  }\n  vi init(n);\n  for(int i=0;i<n;++i) {\n    init[i] = i;\n  }\n  pq.push({0, init});\n  mp[init].second = 0;\n  upd2[init] = true;\n  while(!pq.empty()) {\n    auto now = pq.front(); pq.pop();\n    if(upd2[now.v] && mp[now.v].second < now.d) continue;\n    for(int i=0;i<n;++i) {\n      for(int j=i+1;j<n;++j) {\n        for(int k=0;k<(j-i+1)/2;++k) {\n          swap(now.v[i+k], now.v[j-k]);\n        }\n        if((!upd2[now.v] || mp[now.v].second > now.d + 1) && now.d < 4) {\n          upd2[now.v] = true;\n          mp[now.v].second = now.d + 1;\n          if(now.d+1 < 4) pq.push({now.d + 1, now.v});\n        }\n        for(int k=0;k<(j-i+1)/2;++k) {\n          swap(now.v[i+k], now.v[j-k]);\n        }\n      }\n    }\n  }\n  int ans = n-1;\n  for(auto &e: mp) {\n    if(upd1[e.first] && upd2[e.first]) ans = min(ans, e.second.first + e.second.second);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int64_t s=0;\n    rep(i,0,n){\n        int64_t a;\n        cin >> a;\n        --a;\n        s=s*10+a;\n    }\n\n    int64_t sorted=0;\n    rep(i,0,n) sorted=sorted*10+i;\n\n    int64_t exp[10];\n    exp[0]=1;\n    rep(i,1,10) exp[i]=exp[i-1]*10;\n    auto reverse=[&](int64_t x,int l,int r){\n        rep(i,0,(r-l+1)/2){\n            int64_t p=x/exp[l+i]%10,q=x/exp[r-i]%10;\n            x-=p*exp[l+i]+q*exp[r-i];\n            x+=q*exp[l+i]+p*exp[r-i];\n        }\n        return x;\n    };\n\n    unordered_map<int64_t,int> num1;\n    {\n        queue<int64_t> queues[5];\n        num1[s]=0;\n        queues[0].push(s);\n        rep(k,0,5){\n            auto &que=queues[k];\n            while(!que.empty()){\n                auto x=que.front();\n                que.pop();\n                if(x==sorted){\n                    cout << k << endl;\n                    return;\n                }\n                int l,r;\n                rep(i,0,n){\n                    if(x/exp[i]%10!=n-i-1){\n                        l=i;\n                        break;\n                    }\n                }\n                for(int i=n-1; i>=0; --i){\n                    if(x/exp[i]%10!=n-i-1){\n                        r=i;\n                        break;\n                    }\n                }\n                rep(i,l,r){\n                    rep(j,i+1,r+1){\n                        int64_t y=reverse(x,i,j);\n                        if(num1.find(y)!=num1.end()) continue;\n                        if(y==sorted){\n                            cout << k+1 << endl;\n                            return;\n                        }\n                        num1[y]=k+1;\n                        if(k+1<5) queues[k+1].push(y);\n                    }\n                }\n            }\n        }\n    }\n\n    unordered_map<int64_t,int> num2;\n    {\n        queue<int64_t> queues[5];\n        num2[sorted]=0;\n        queues[0].push(sorted);\n        rep(k,0,5){\n            auto &que=queues[k];\n            while(!que.empty()){\n                auto x=que.front();\n                que.pop();\n                rep(i,0,n){\n                    rep(j,i+1,n){\n                        int64_t y=reverse(x,i,j);\n                        if(num2.find(y)!=num2.end()) continue;\n                        if(num1.find(y)!=num1.end()){\n                            cout << num1[y]+k+1 << endl;\n                            return;\n                        }\n                        num2[y]=k+1;\n                        if(k+1<5) queues[k+1].push(y);\n                    }\n                }\n            }\n        }\n    }\n    cout << 10 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef pair<vi, int> P;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi a(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\tvi b = a;\n\tsort(ALL(b));\n\tmap<vi, int> mp1, mp2;\n\tqueue<P> que;\n\tque.push(P(a, 0));\n\tmp1[a] = 0;\n\twhile (que.size())\n\t{\n\t\tvi t = que.front().first;\n\t\tint cnt = que.front().second;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) \n\t\t\t{\n\t\t\t\tmp1[nx] = cnt + 1;\n\t\t\t\tif(cnt<4) que.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = n - 1;\n\tqueue<P> que2;\n\tque2.push(P(b, 0));\n\twhile (que2.size())\n\t{\n\t\tvi t = que2.front().first;\n\t\tint cnt = que2.front().second;\n\t\tque2.pop();\n\t\tif (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\treverse(nx.begin() + i, nx.begin() + j);\n\t\t\tif (mp2.find(nx) == mp2.end())\n\t\t\t{\n\t\t\t\tmp2[nx] = cnt + 1;\n\t\t\t\tif(cnt<4)que2.push(P(nx, cnt + 1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n\n    while (cin >> N, N) {\n        vector<int> a(N), b(N);\n        \n        for (int i = 0; i < N; i++) {\n            cin >> a[i];\n            b[i] = i + 1;\n        }\n\n        map<vector<int>, int> d, h;\n        int ans = N - 1;\n\n        // from goal\n        {\n            h[b] = 0;\n            queue<vector<int> > q;\n            q.push(b);\n        \n            while (!q.empty()) {\n                vector<int> v = q.front();\n                int cost = h[v];\n                q.pop();\n\n                if (v == a) {\n                    ans = cost;\n                    break;\n                }\n                if (cost >= 4)\n                    break;\n\n                for (int i = 0; i < N; i++) \n                    for (int j = i + 1; j < N; j++) {\n                        vector<int> next = v;\n                        reverse(next.begin() + i, next.begin() + j + 1);\n                        if (!h.count(next)) {\n                            h[next] = cost + 1;\n                            q.push(next);\n                        }\n                    }\n            }\n        }\n\n        // from start\n        {\n            d[a] = 0;\n            queue<vector<int> > q;\n            q.push(a);\n        \n            while (!q.empty()) {\n                vector<int> v = q.front();\n                int cost = d[v];\n                q.pop();\n\n                if (h.count(v)) {\n                    ans = cost + h[v];\n                    break;\n                }\n\n                if (cost >= 4)\n                    break;\n\n                for (int i = 0; i < N; i++) \n                    for (int j = i + 1; j < N; j++) {\n                        vector<int> next = v;\n                        reverse(next.begin() + i, next.begin() + j + 1);\n                        if (!d.count(next)) {\n                            d[next] = cost + 1;\n                            q.push(next);\n                        }\n                    }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nmap<vector<int>, int> memo[2];\nint main(void){\n    int n; cin >> n;\n\n    vector<int> a(n);\n    for(auto & e : a) cin >> e;\n\n    int nn = (n - 1) / 2;\n\n    int res = n - 1;\n    rep(i, 2){\n        queue<pair<int, vector<int>>> q;\n        q.push(make_pair(0, a));\n\n        while(q.size()){\n            int cnt; vector<int> b;\n            cnt = q.front().first, b = q.front().second;\n            q.pop();\n\n            if(cnt == nn) continue;\n            if(memo[i].find(b) != end(memo[i])) continue;\n\n            if(i == 1 and memo[0].find(b) != end(memo[0])){\n                res = memo[0][b] + cnt;\n                break;\n            }\n            memo[i][b] = cnt;\n\n            rep(j, n){\n                range(k, j + 1, n){\n                    vector<int> nb = b;\n                    reverse(begin(nb) + j, begin(nb) + k + 1);\n\n                    if(memo[i].find(nb) != end(memo[i])) continue;\n                    q.push(make_pair(cnt + 1, nb));\n                }\n            }\n        }\n\n        rep(j, n) a[j] = j + 1;\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef pair<vi, int> P;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi a(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\tvi b = a;\n\tsort(ALL(b));\n\tmap<vi, int> mp1, mp2;\n\tqueue<P> que;\n\tque.push(P(a, 0));\n\twhile (que.size())\n\t{\n\t\tvi t = que.front().first;\n\t\tint cnt = que.front().second;\n\t\tque.pop();\n\t\tif (cnt == 5) break;\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\tsort(nx.begin() + i, nx.begin() + j);\n\t\t\tif (mp1.find(nx) == mp1.end()) mp1[nx] = cnt + 1;\n\t\t}\n\t}\n\tint ans = n - 1;\n\tqueue<P> que2;\n\tque2.push(P(b, 0));\n\twhile (que.size())\n\t{\n\t\tvi t = que2.front().first;\n\t\tint cnt = que2.front().second;\n\t\tque.pop();\n\t\tif (cnt == 5) break;\n\t\tif (mp1.find(t) != mp1.end()) chmin(ans, cnt + mp1[t]);\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = t;\n\t\t\tsort(nx.begin() + i, nx.begin() + j);\n\t\t\tif (mp2.find(nx) == mp2.end()) mp2[nx] = cnt + 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull> p2;\n \nmap<ull,int> dist;\n \nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \nint n;\n \nvoid dijkstra(vector<int>start){\n   \n  priority_queue<p2, vector<p2>, greater<p2> > que;\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.top();\n    que.pop();\n     \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>6)return;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n \nmap<ull,int>dist2;\n\nint dijkstra2(vector<int>start){\n   \n  priority_queue<p2, vector<p2>, greater<p2> > que;\n  que.push(p2(0,encode(start)));\n  dist2[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.top();\n    que.pop();\n     \n    if(dist2.find(now.state)!=dist2.end() && dist2[now.state]<now.cost)continue;\n    if(dist.find(now.state)!=dist.end())return now.cost+dist[now.state];\n    dist2[now.state]=now.cost;\n    if(now.cost>5)return -1;\n\n    vector<int>t=decode(now.state);\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n \n  dijkstra(g);\n   \n  cout << dijkstra2(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//参照http://www27.atpages.jp/tasuku/pro/3_algo.pdf \n\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\n\nint main()\n{\n  int n;\n  cin >>n;\n  int ans=n;\n  vector<int> a(n),b(n);//スタート、ゴールから\n  for(int i = 0;i < n;i++){\n    cin>>a[i];\n    b[i] = i+1;\n  }//d[v] =スタートからの距離,h[v]=ゴールからの距離\n  map<vector<int>,int> d,h;\n  //解は最大でもn-1;\n  //ゴールから探索\n  {\n    h[b] = 0;\n    queue<vector<int> > q;\n    q.push(b);\n    while(!q.empty()){\n      vector<int> v = q.front();\n      int cost = h[v];\n      q.pop();\n      if(v ==a){//一致するなら\n\tans = cost;\n\tbreak;\n      }\n      if(cost >=4)\n\tbreak;\n      for(int i = 0;i < n;i++){\n\tfor(int j = i+1;j < n;j++){\n\t  vector<int> next = v;\n\t  reverse(next.begin()+i,next.begin()+j+1);\n\t  if(!h.count(next)){//まだ無ければ追加\n\t    h[next] = cost+1;\n\t    q.push(next);\n\t  }\n\t}\n      }\n    }\n  }\n    //スタートからの探索\n    {\n      d[a] = 0;\n      queue<vector<int> > q;\n      q.push(a);\n      while(!q.empty()){\n\tvector<int> v = q.front();\n\tint cost = d[v];\n\tq.pop();\n\tif(h.count(v)){\n\t  ans = cost + h[v];\n\t  break;\n\t}\n\tif(cost >=4){\n\t  break;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t  for(int j = i+1;j < n;j++){\n\t    vector<int> next = v;\n\t    reverse(next.begin()+i, next.begin()+j+1);\n\t    if(!d.count(next)){\n\t      d[next] = cost +1;\n\t      q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(ans ==n){\n      ans =n-1;\n    }\n    cout <<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nmap<vector<int>,int> bfs(vector<int> A){\n  map<vector<int>,int> D;\n  queue<vector<int> > Q;\n  Q.push(A);\n  D[A] = 0;\n  while(!Q.empty()){\n    vector<int> t = Q.front();Q.pop();\n    int cost = D[t];\n    if(cost == 4) continue;\n    \n    for(int i=0;i<n;i++)\n      for(int j=i+2;j<=n;j++){\n\tvector<int> nt = t;\n\treverse(nt.begin()+i,nt.begin()+j);\n\tif(D.count(nt)) continue;\n\tQ.push(nt);\n\tD[nt]=cost+1;\n    }\n  }\n  return D;\n}\n\n\nint main(){\n  cin>>n;\n  vector<int> A(n),B(n);\n  for(int i=0;i<n;i++) cin>>A[i],B[i] = i+1;\n\n  \n  map<vector<int>,int> X = bfs(A);\n  map<vector<int>,int> Y = bfs(B);\n\n  map<vector<int>,int>::iterator it = X.begin();\n  int ans = 9;\n  \n  for(;it!=X.end();it++)\n    if(Y.count(it->first))ans = min(ans,it->second+Y[it->first]);\n  \n  cout<<ans<<endl;\n  \n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\n\nmap<VI,int> mp;\n\nvoid Rev(int l,int r,vector<int> &v){\n\tfor(int i=0;i<=10;i++){\n\t\tif(l+i>=r-i)break;\n\t\tswap(v[l+i],v[r-i]);\n\t}\n\treturn;\n}\n\nvoid bfs(vector<int> v,int depth){\n\tif(depth>=4)return;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\tvector<int>v1;\n\t\t\tv1 = v;\n\t\t\tRev(i,j,v1);\n\t\t\tif(mp[v1]!=0){\n\t\t\t\tif(mp[v1]>depth){\n\t\t\t\t\tmp[v1] = depth;\n\t\t\t\t\tbfs(v1,depth+1);\n\t\t\t\t}\n\t\t\t}else if(mp[v1]==0){\n\t\t\t\tmp[v1] = depth;\n\t\t\t\tbfs(v1,depth+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid bfs2(vector<int> v,int depth,int &ans){\n\tif(depth>=4)return;\n\tfor(int i=0;i<v.size();i++){\n\t\tfor(int j=i+1;j<v.size();j++){\n\t\t\tvector<int>v1;\n\t\t\tv1 = v;\n\t\t\tRev(i,j,v1);\n\t\t\tif(mp[v1]!=0){\n\t\t\t\tans = min(ans,mp[v1]+depth);\n\t\t\t\tbfs2(v1,depth+1,ans);\n\t\t\t}else if(mp[v1]==0){\n\t\t\t\tbfs2(v1,depth+1,ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n\n\nint main(){\n\tint n;\n\tcin >>n;\n\tVI a(n);\n\trep(i,n)cin>>a[i];\n\tmp[a]=0;\n\tbfs(a,1);\n\tVI b(n);\n\trep(i,n)b[i]=i+1;\n\tif(a==b){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = 10000;\n\tif(mp[b]!=0){\n\t\tans = mp[b];\n\t}\n\tbfs2(b,1,ans);\n\tif(ans==10000){\n\t\tcout << n-1 << endl;\n\t}else{\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nmap<vector<int>, int> memo[2];\nint main(void){\n    int n; cin >> n;\n\n    vector<int> a(n);\n    for(auto & e : a) cin >> e;\n\n    int nn = (n - 1) / 2;\n\n    int res = n - 1;\n    rep(i, 2){\n        queue<vector<int>> q;\n        q.push(a);\n        memo[i][a] = 0;\n\n        while(q.size()){\n            vector<int> b;\n            b = q.front(); q.pop();\n\n            if(memo[i][b] >= nn) continue;\n\n            if(i == 1 and memo[0].find(b) != end(memo[0])){\n                res = min(res, memo[0][b] + memo[1][b]);\n                continue;\n            }\n\n            rep(j, n){\n                range(k, j + 1, n){\n                    vector<int> nb = b;\n                    reverse(begin(nb) + j, begin(nb) + k + 1);\n\n                    if(memo[i].find(nb) != end(memo[i])) continue;\n\n                    memo[i][nb] = memo[i][b] + 1;\n                    q.push(nb);\n                }\n            }\n        }\n\n        sort(begin(a), end(a));\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nconstexpr long long D[] = {1, 10, 100, 1000, (long long)1e4, (long long)1e5, (long long)1e6, (long long)1e7, (long long)1e8, (long long)1e9, (long long)1e10, (long long)1e11};\n\nlong long rev(const long long int &s, int i, int j){\n  long long int ret = s;\n  for(int k = i; k <= j; ++k){\n    ret -= (s/D[k])%10*D[k];\n    ret += (s/D[j-k+i])%10*D[k];\n  }\n  //cout << s << \" \" << i << \" \" << j << \" \" << ret << endl;\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  long long int a = stoll(A);\n  int c = 1;\n  while(D[N-c] > a){\n    for(int i = 0; i < N-c; ++i) a -= D[i];\n    ++c;\n  }\n  //cout << \"a = \" << a << endl;\n  queue<long long> wait;\n  //wait.emplace(-1,a);\n  wait.emplace(a);\n  map<long long, int> M;\n  M[0] = N;\n  M[a] = 1;\n  while(!wait.empty()){\n    long long t = wait.front();\n    int s = M[t];\n    wait.pop();\n    //cout << t << endl;\n    int l = 0;\n    for(int i = 0; i <= N; ++i){\n      if(D[i] > t){\n        l = i;\n        break;\n      }\n    }\n    for(int i = 0; i < l; ++i){\n      for(int j = i+1; j < l; ++j){\n        long long u = rev(t, i, j);\n        int c = 1;\n        while(D[l-c] > u){\n          for(int k = 0; k < l-c; ++k) u -= D[k];\n          ++c;\n        }\n        if(!u){\n          cout << s << endl;\n          return 0;\n        }\n        if(s < N-1 && !M[u]){\n          M[u] = s + 1;\n          wait.emplace(u);\n        }\n      }\n    }\n  }\n  cout << M[0]-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nunordered_map<ll,int> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  queue<P> q;\n  \n  memo[Vtoll(s)]=0;\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n\n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=1;i<=n;i++){ // range\n\n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\t\n\tmemo[Vtoll(nS)]=cost+1;\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<short> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n;\n\nmap<vi, short> bfs(vi v)\n{\n\tmap<vi, short> mp;\n\tqueue<vi> que;\n\tque.push(v); mp[v] = 0;\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tque.pop();\n\t\tint t = mp[tmp];\n\t\tif (t >= (n-1) / 2) continue;\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + j, nx.begin() + i + 1);\n\t\t\tif (mp.find(nx) != mp.end()) continue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmp[nx] = t + 1;\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn mp;\n}\n\nsigned main()\n{\n\tcin >> n;\n\tvi a(n), b;\n\tREP(i, n) cin >> a[i];\n\tb = a;\n\tsort(ALL(b));\n\tauto mp1 = bfs(a);\n\tauto mp2 = bfs(b);\n\tint ans = n - 1;\n\tfor (auto it = mp1.begin(); it != mp1.end(); it++)\n\t{\n\t\tif (mp2.find(it->first) != mp2.end()) chmin(ans, it->second + mp2[it->first]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint from, to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi v(n);\n\tREP(i, n) cin >> v[i];\n\tmap<vi, int> mp1, mp2;\n\tqueue<vi> que;\n\tmp1[v] = 0;\n\tque.push(v);\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tif (mp1[tmp] > n / 2) break;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) mp1[nx] = mp1[tmp] + 1;\n\t\t}\n\t}\n\n\twhile (que.size()) que.pop();\n\tsort(ALL(v));\n\tmp2[v] = 0;\n\tque.push(v);\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tif (mp2[tmp] > n / 2) break;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp2.find(nx) == mp2.end()) mp2[nx] = mp2[tmp] + 1;\n\t\t}\n\t}\n\tint ans = n - 1;\n\tfor (auto it = mp1.begin(); it != mp1.end(); it++)\n\t{\n\t\tvi tmp = (*it).first;\n\t\tif (mp2.find(tmp) != mp2.end()) chmin(ans, (*it).second + mp2[tmp]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n\nusing namespace std;\n\nvector<int> ireverse(int l,int r,vector<int> ve);\nvoid dfs(vector<int> ve,int no);\nint ans = 20;\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> a;\n\t\n\tfor(int i = 0;i < n;i++){\n\t\tint ta;\n\t\tcin >> ta;\n\t\ta.push_back(ta);\n\t}\n\t\n\tdfs(a,0);\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n\nvector<int> ireverse(int l,int r,vector<int> ve){\n\tvector<int> reversed;\n\tfor(int i = 0;i < l;i++){\n\t\treversed.push_back(ve[i]);\n\t}\n\tfor(int i = r;i >= l;i--){\n\t\treversed.push_back(ve[i]);\n\t}\n\tfor(int i = r+1;i < ve.size();i++){\n\t\treversed.push_back(ve[i]);\n\t}\n\treturn reversed;\n}\n\nvoid dfs(vector<int> ve,int no){\n\tint lm = 0;\n\tfor(int i = 0;i < ve.size();i++){\n\t\tif((ve[i]-1) == i) lm++;\n\t\telse break;\n\t}\n\tif(lm == ve.size()) ans = min(ans,no);\n\telse{\n\t\tint lind;\n\t\tfor(int i = 0;i < ve.size();i++) if(ve[i] == (lm+1)){lind = i;break;}\n\t\tif(no < ve.size()){\n\t\t\tdfs(ireverse(lm,lind,ve),no+1);\n\t\t}\n\t\tint rm = 0;\n\t\tfor(int i = (ve.size()-1);i >=0;i++){\n\t\t\tif((ve[i]-1) == i) rm++;\n\t\t\telse break;\n\t\t}\n\t\tint rind;\n\t\tfor(int i = 0;i < ve.size();i++) if(ve[i] == (ve.size() - rm)){rind = i;break;}\n\t\tif(no < ve.size()){\n\t\t\tdfs(ireverse(rind,(ve.size()-1-rm),ve),no+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//半数列挙で答えが8以下かを判定する.\n//順列は, 16進数で表現する.\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint n;\nint a[10], decA, basePermDec;\nvector<int> perms[2][5];\n\nvoid dfs(int type, int depth, int maxDepth, int nowP) {\n\tperms[type][depth].push_back(nowP);\n\tif (depth == maxDepth) return;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint nextP = nowP & ((1LL << (4 * (j + 1))) - 1);\n\t\t\tnextP = ((nextP >> (4 * i)) << (4 * i));\n\t\t\tnextP = nowP - nextP;\n\t\t\tfor (int k = 0; k <= j - i; k++) {\n\t\t\t\tint idl = i + k;\n\t\t\t\tint idr = j - k;\n\t\t\t\tnextP += ((nowP >> (4 * idr)) & 15) << (4 * idl);\n\t\t\t}\n\t\t\tdfs(type, depth + 1, maxDepth, nextP);\n\t\t}\n\t}\n}\n\nbool isMatch(int depth1, int depth2) {\n\tvector<int> &a = perms[0][depth1];\n\tvector<int> &b = perms[1][depth2];\n\tint i, j;\n\t\n\tif (a.size() == 0 || b.size() == 0) return false;\n\t\n\tj = 0;\n\tfor (i = 0; i < a.size(); i++) {\n\t\tfor (; j < b.size(); j++) {\n\t\t\tif (a[i] <= b[j]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (a[i] == b[j]) return true;\n\t}\n\treturn false;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) { cin >> a[i]; a[i]--; }\n\tfor (i = 0; i < n; i++) decA += (a[i] << (4 * i));\n\tfor (i = 0; i < n; i++) basePermDec += (i << (4 * i));\n\tdfs(0, 0, 4, basePermDec);\n\tdfs(1, 0, 4, decA);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tsort(perms[i][j].begin(), perms[i][j].end());\n\t\t\tperms[i][j].erase(unique(perms[i][j].begin(), perms[i][j].end()), perms[i][j].end());\n\t\t}\n\t}\n\t\t\n\tint ans = 9;\n\tfor (i = 0; i <= 4; i++) {\n\t\tfor (j = 0; j <= 4; j++) {\n\t\t\tif (isMatch(i, j)) {\n\t\t\t\tans = min(ans, i + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\ntemplate<typename T> ostream& operator <<(ostream& r, const vector<T> t){vrep(v,t)r<<*v<<(v+1==t.end()?\"\":\" \");return r;}\ntemplate<typename T> ostream& operator <<(ostream& r, const pair<vector<T>, int> p){int n=p.second;minup(n,p.first.size());rep(i,n-1)r<<p.first[i]<<' ';r<<p.first[n-1];return r;}\ntemplate<typename T> ostream& operator <<(ostream& r, const pair<T*, int> p){int n=p.second-1;rep(i,n)r<<p.first[i]<<' ';return r<<p.first[n];}\ntemplate<typename T, size_t S> ostream& operator <<(ostream& r, const T (&a)[S]){rep(i,S-1)r<<a[i]<<' ';return r<<a[S-1];}\n\n\nint N;\nmap<vi, int> d[2];\nqueue<pair<vi, int> > que[2];\n\nint main(int argc, char *argv[])\n{\n  cin >> N;\n  vi A(N), S(N);\n  rep(i, N) cin >> A[i];\n  S = A;\n  sort(ALL(S));\n\n  d[0][A] = 0;\n  que[0].push(mp(A, 0));\n  while(!que[0].empty()){\n    vi top = que[0].front().first;\n    int cost = que[0].front().second;\n    que[0].pop();\n    if(top == S){\n      cout << cost << endl;\n      return 0;\n    }\n    if(cost >= 4) break;\n    rep(j, N) rep(i, j){\n      vi t = top;\n      reverse(t.begin() + i, t.begin() + j + 1);\n      if(t != A && !d[0][t]){\n        d[0][t] = cost + 1;\n        que[0].push(mp(t, cost + 1));\n      }\n    }\n  }\n  \n  d[1][S] = 0;\n  que[1].push(mp(S, 0));\n  while(!que[1].empty()){\n    vi top = que[1].front().first;\n    int cost = que[1].front().second;\n    que[1].pop();\n    if(d[0][top]){\n      cout << cost + d[0][top] << endl;\n      return 0;\n    }\n    if(cost >= 4) break;\n    rep(j, N) rep(i, j){\n      vi t = top;\n      reverse(t.begin() + i, t.begin() + j + 1);\n      if(!d[1][t]){\n        d[1][t] = cost + 1;\n        que[1].push(mp(t, cost + 1));\n      }\n    }\n  }\n\n  cout << N - 1 << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nconstexpr long long D[] = {1, 10, 100, 1000, (long long)1e4, (long long)1e5, (long long)1e6, (long long)1e7, (long long)1e8, (long long)1e9, (long long)1e10, (long long)1e11};\n\nlong long rev(const long long int &s, int i, int j){\n  long long int ret = s;\n  for(int k = i; k <= j; ++k){\n    ret -= (s/D[k])%10*D[k];\n    ret += (s/D[j-k+i])%10*D[k];\n  }\n  //cout << s << \" \" << i << \" \" << j << \" \" << ret << endl;\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  long long int a = stoll(A);\n  int c = 1;\n  while(D[N-c] > a){\n    for(int i = 0; i < N-c; ++i) a -= D[i];\n    ++c;\n  }\n  //cout << \"a = \" << a << endl;\n  queue<long long> wait;\n  //wait.emplace(-1,a);\n  wait.emplace(a);\n  map<long long, int> M;\n  M[0] = N;\n  M[a] = 1;\n  while(!wait.empty()){\n    long long t = wait.front();\n    int s = M[t];\n    wait.pop();\n    //cout << t << endl;\n    int l = 0;\n    for(int i = 0; i <= N; ++i){\n      if(D[i] > t){\n        l = i;\n        break;\n      }\n    }\n    for(int i = 0; i < l; ++i){\n      for(int j = i+1; j < l; ++j){\n        long long u = rev(t, i, j);\n        int c = 1;\n        while(D[l-c] > u){\n          for(int k = 0; k < l-c; ++k) u -= D[k];\n          ++c;\n        }\n        if(!u){\n          cout << s << endl;\n          return 0;\n        }\n        if(s < N-1 && !M[u]){\n          M[u] = s + 1;\n          wait.emplace(u);\n        }\n      }\n    }\n  }\n  cout << M[0]-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<queue>\n#include<cstdio>\n#include<ctime>\n#include<climits>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct P\n{\n  vector<int> A;\n  int cost;\n  P(vector<int> A2=vector<int>(),int cost=inf):cost(cost)\n  {\n    A = A2;\n  }\n\n  bool operator < (const P& a)const\n  {\n    return cost > a.cost;\n  }\n\n};\n\nint N;\nmap<vector<int>,int> mincost;\nmap<vector<int>,int> rmincost;\nvector<int> initial;\nbool found;\n\nvoid computeR(int step)\n{\n  priority_queue<P> Q;\n  {\n    initial.resize(N);\n    rep(i,N)initial[i] = i+1;\n    Q.push(P(initial,0));\n    rmincost[initial] = 0;\n  }\n\n  //clock_t st,ed;\n  //st = clock();\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      if(p.cost >= step)continue;\n\n      //ed = clock();\n      //if((double)(ed-st)/(double)CLOCKS_PER_SEC >= 1.0)return;      \n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(rmincost.find(next) == rmincost.end())\n\t\t{\n\t\t  rmincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n\n    }\n}\n\nvoid compute(vector<int> &vec)\n{\n  mincost[vec] = 0;\n  priority_queue<P> Q;\n  Q.push(P(vec,0));\n\n  int ans = inf;\n  found = false;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n\n      //if(p.cost >= ans)continue;\n\n\n      if(rmincost.find(p.A) != rmincost.end())\n\t{\n\t  found = true;\n\t  cout << p.cost + rmincost[p.A] << endl;\n\t  return;\n\t  //ans = min(ans,p.cost + rmincost[p.A]);\n\t  continue;\n\t}\n\n      if(p.cost >= 4)continue;\n\n      rep(s,N)\n\t{\n\t  REP(t,s+2,N+1)\n\t    {\n\t      vector<int> next = p.A;\n\t      reverse(next.begin()+s,next.begin()+t);\n\t      if(mincost.find(next) == mincost.end())\n\t\t{\n\t\t  mincost[next] = p.cost + 1;\n\t\t  Q.push(P(next,p.cost+1));\n\t\t}\n\t    }\n\t}\n    }\n  found = true;\n  cout << N-1 << endl;\n}\n\nint main()\n{\n\n  int a = scanf(\"%d\",&N);\n  \n  computeR(4);\n  //cout << \"---------\" << endl;\n  vector<int> vec(N);\n  rep(i,N)cin >> vec[i];\n\n  compute(vec);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int64_t s=0;\n    rep(i,0,n){\n        int64_t a;\n        cin >> a;\n        --a;\n        s=s*10+a;\n    }\n\n    int64_t sorted=0;\n    rep(i,0,n) sorted=sorted*10+i;\n\n    int64_t exp[10];\n    exp[0]=1;\n    rep(i,1,10) exp[i]=exp[i-1]*10;\n    auto reverse=[&](int64_t x,int l,int r){\n        rep(i,0,(r-l+1)/2){\n            int64_t p=x/exp[l+i]%10,q=x/exp[r-i]%10;\n            x-=p*exp[l+i]+q*exp[r-i];\n            x+=q*exp[l+i]+p*exp[r-i];\n        }\n        return x;\n    };\n\n    unordered_map<int64_t,int> num1;\n    {\n        queue<int64_t> queues[5];\n        num1[s]=0;\n        queues[0].push(s);\n        rep(k,0,5){\n            auto &que=queues[k];\n            while(!que.empty()){\n                auto x=que.front();\n                que.pop();\n                if(x==sorted){\n                    cout << k << endl;\n                    return;\n                }\n                int l,r;\n                rep(i,0,n){\n                    if(x/exp[i]%10!=n-i-1){\n                        l=i;\n                        break;\n                    }\n                }\n                for(int i=n-1; i>=0; --i){\n                    if(x/exp[i]%10!=n-i-1){\n                        r=i;\n                        break;\n                    }\n                }\n                rep(i,l,r){\n                    rep(j,i+1,r+1){\n                        int64_t y=reverse(x,i,j);\n                        if(num1.find(y)!=num1.end()) continue;\n                        if(y==sorted){\n                            cout << k+1 << endl;\n                            return;\n                        }\n                        num1[y]=k+1;\n                        if(k+1<5) queues[k+1].push(y);\n                    }\n                }\n            }\n        }\n    }\n\n    unordered_map<int64_t,int> num2;\n    {\n        queue<int64_t> queues[6];\n        num2[sorted]=0;\n        queues[0].push(sorted);\n        rep(k,0,6){\n            auto &que=queues[k];\n            while(!que.empty()){\n                auto x=que.front();\n                que.pop();\n                rep(i,0,n){\n                    rep(j,i+1,n){\n                        int64_t y=reverse(x,i,j);\n                        if(num2.find(y)!=num2.end()) continue;\n                        if(num1.find(y)!=num1.end()){\n                            cout << num1[y]+k+1 << endl;\n                            return;\n                        }\n                        num2[y]=k+1;\n                        if(k+1<6) queues[k+1].push(y);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nqueue<P> q;\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n    cout<<memo.size()<<endl;\n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=1;i<=n;i++){ // range\n\n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\t\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\ninline ull PermutationHash(vi perm){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tull hash = 0;\n    REP(i, (int)perm.size()-1) perm[i] = perm[i];\n    REP(i, (int)perm.size()-1){\n        hash += perm[i] * FACTOR[perm.size()-i-1];\n        for (int j=i+1; j < (int)perm.size()-1; j++)\n            if (perm[i] < perm[j]) perm[j]--;\n    }\n    return hash;\n}\n\ninline vi restorePermutation(ull u){\n\tstatic ull FACTOR[21]={0};\n\tif(FACTOR[0] == 0){\n\t\tFACTOR[0] = 1;\n\t\tREP(i, 20) FACTOR[i+1] = FACTOR[i]*(i+1);\n\t}\n\tvi res;\n\tRREP(i, n){\n\t\tint p = u/FACTOR[i];\n\t\tu%=FACTOR[i];\n\t\tres.push_back(p);\n\t}\n\tRREP(i, res.size())RREP(j, i) if(res[j] <= res[i]) res[i]++;\n\treturn res;\n}\n\nint memo[3628801];\nint rev[3628801];\nmain(){\n\twhile(cin >> n){\n\t\tmemset(rev, 63, sizeof(memo));\n\t\tmemset(memo, 63, sizeof(memo));\n\t\tvi a(n);\n\t\tREP(i, n) a[i] = i;\n\t\tqueue< pair<int, ull> > pq;\n\t\tpq.emplace(0, 0);\n\t\trev[0] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.front().first;\n\t\t\tull u = pq.front().second;\n\t\t\tpq.pop();\n\t\t\tif(c > 3) break;\n\t\t\tvi a = restorePermutation(u);\n\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\tvi b(a);\n\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\tull u = PermutationHash(b);\n\t\t\t\tif(chmin(rev[u], c+1) && c+1 < 4) pq.emplace(c+1, u);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tREP(i, n) cin >> a[i],a[i]--;\n\t\t\tqueue< pair<int, ull> > pq;\n\t\t\tpq.emplace(0, PermutationHash(a));\n\t\t\tmemo[PermutationHash(a)] = 0;\n\t\t\tint ans = n-1;\n\t\t\twhile(!pq.empty()){\n\t\t\t\tint c = pq.front().first;\n\t\t\t\tull u = pq.front().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif(c > 3) break;\n\t\t\t\tans = min(ans, c + rev[u]);\n\t\t\t\tvi a = restorePermutation(u);\n\t\t\t\tREP(i, n+1)REP(j, i){\n\t\t\t\t\tvi b(a);\n\t\t\t\t\treverse(b.begin()+j, b.begin()+i);\n\t\t\t\t\tull u = PermutationHash(b);\n\t\t\t\t\tif(c+1 < 4 && chmin(memo[u], c+1)) pq.emplace(c+1, u);\n\t\t\t\t\tans = min(ans, c + 1 + rev[u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nmap<ll,int> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  queue<P> q;\n  \n  memo[Vtoll(s)]=0;\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n\n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=1;i<=n;i++){ // range\n\n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\t\n\tmemo[Vtoll(nS)]=cost+1;\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint solve(vector<int> v)\n{\n    vector<int> s(v.begin(), v.end());\n    \n    sort(s.begin(), s.end());\n    \n    if(v == s) { return 0; }\n    \n    map<vector<int>, int> d; d[v] = 1;\n    \n    queue<vector<int> > que; que.push(v);\n    \n    while(!que.empty())\n    {\n        vector<int> v1 = que.front(); que.pop();\n        \n        for(int i = 0; i < v1.size(); i++)\n        {\n            for(int j = i + 1; j < v1.size(); j++)\n            {\n                vector<int> v2(v1.begin(), v1.end());\n                \n                reverse(v2.begin() + i, v2.begin() + j + 1);\n                \n                if(v2 == s) { return d[v1]; }\n                \n                if(!d[v2])\n                {\n                    d[v2] = d[v1] + 1;\n                    \n                    que.push(v2);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main()\n{\n    int n;\n    \n    scanf(\"%d\", &n);\n    \n    vector<int> a(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    \n    printf(\"%d\\n\", solve(a));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint n;\n\tint d[10];\n\tS() {}\n\tS(int n) : n(n) {}\n\tll hash() {\n\t\tll r = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tr *= 16;\n\t\t\tr += d[i];\n\t\t}\n\t\treturn r;\n\t}\n};\n\ntypedef pair<S, int> P;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tS s(n), r(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s.d[i];\n\t\ts.d[i]--;\n\t\tr.d[i] = i;\n\t}\n\tll rh = r.hash();\n\tint dist = 1, rdist = 1;\n\tqueue<P> q;\n\tmap<ll, int> u;\n\tq.push(P(s, 1));\n\twhile (!q.empty()) {\n\t\tS s(0); int d;\n\t\ttie(s, d) = q.front(); q.pop();\n\t\tif (d == 6) break;\n\n\t\tll sh = s.hash();\n\t\tif (u[sh]) continue;\n\t\tu[sh] = d;\n\t\tdist = d;\n\t\tif (sh == rh) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+2; j <= n; j++) {\n\t\t\t\tS ss = s;\n\t\t\t\treverse(ss.d + i, ss.d + j);\n\t\t\t\tq.push(P(ss, d+1));\n\t\t\t}\n\t\t}\n\t}\n\tmap<ll, int> ru;\n\tq = queue<P>();\n\tq.push(P(r, 1));\n\twhile (!q.empty()) {\n\t\tS s(0); int d;\n\t\ttie(s, d) = q.front(); q.pop();\n\t\tll sh = s.hash();\n\t\tif (ru[sh]) continue;\n\t\tru[sh] = d;\n\t\trdist = d;\n\t\tif (u[sh]) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i+2; j <= n; j++) {\n\t\t\t\tS ss = s;\n\t\t\t\treverse(ss.d + i, ss.d + j);\n\t\t\t\tq.push(P(ss, d+1));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist+rdist-2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n\n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<int,ull> p2;\n\nmap<ull,int> dist;\n\nuint encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n\nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nint n;\n\nvoid dijkstra(vector<int>start){\n  \n  priority_queue<p2, vector<p2>, greater<p2> > que;\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.top();\n    que.pop();\n    \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n\n    vector<int>t=decode(now.state);\n    \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\treverse(t.begin()+i,t.begin()+j+1);\n\tque.push(p2(now.cost+1,encode(t)));\n\treverse(t.begin()+i,t.begin()+j+1);\n      }\n    }\n  }\n}\n\nint main(void){\n\n  cin >> n;\n\n  vector<int>v(n),g(n);\n  for(int i=0;i<n;i++)cin >> v[i],g[i]=i+1;\n\n  dijkstra(v);\n  \n  cout << dist[encode(g)] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n; vector<int> a; vector<int> fact;\nint perm_hash(vector<int> v) {\n\tint ret = 0;\n\tfor (int i = 0; i < v.size() - 1; i++) {\n\t\tint cnt = 0;\n\t\tfor (int j = i + 1; j < v.size(); j++) {\n\t\t\tif (v[i] > v[j]) cnt++;\n\t\t}\n\t\tret += cnt * fact[v.size() - i - 1];\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> n; a.resize(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n\tfact.resize(n + 1); fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n\tmap<int, int> dist; dist[perm_hash(a)] = 1;\n\tqueue<vector<int> > que1; que1.push(a);\n\twhile (!que1.empty()) {\n\t\tvector<int> v1 = que1.front(); que1.pop();\n\t\tint dist1 = dist[perm_hash(v1)];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tint z = perm_hash(v1);\n\t\t\t\tif (!dist[z]) {\n\t\t\t\t\tdist[z] = dist1 + 1;\n\t\t\t\t\tif (dist1 < (n + 1) / 2) que1.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 999999999;\n\tvector<int> s(n);\n\tfor (int i = 0; i < n; i++) s[i] = i;\n\tmap<int, int> dist2; dist2[0] = 1;\n\tqueue<vector<int> > que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tvector<int> v1 = que2.front(); que2.pop();\n\t\tint dist1 = dist2[perm_hash(v1)];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tint z = perm_hash(v1);\n\t\t\t\tif (!dist2[z]) {\n\t\t\t\t\tdist2[z] = dist1 + 1;\n\t\t\t\t\tint dist3 = dist[z];\n\t\t\t\t\tif (dist3) ret = min(ret, dist1 + dist3 - 1);\n\t\t\t\t\tif (dist1 < n / 2) que2.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (s != a ? ret : 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef unsigned long long ull;\ntypedef pair<int,ull > p2;\n \n\null encode(vector<int> vec){\n  uint res=0;\n  for (int i=0;i<vec.size();i++)\n    res=(res<<4)+vec[i];\n  return res;\n}\n \nvector<int> decode(ull a){\n  vector<int> res;\n  for (;a>0;a>>=4)res.push_back(a & 15);\n  reverse(res.begin(),res.end());\n  return res;\n}\n \n\nmap<ull,int> dist2;\n \nint n;\nqueue<p2> que;\n\nmap<ull,int> bfs(vector<int>start){\n  \n  map<ull,int> dist;\n\n  que.push(p2(0,encode(start)));\n  dist[encode(start)]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n    \n    if(now.cost>=(n-1)/2)continue;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<int>t=decode(now.state);\n\treverse(t.begin()+i,t.begin()+j+1);\n\tull tmp=encode(t);\n\tif(dist.find(tmp)==dist.end()){\n\t  dist[tmp]=now.cost+1;\n\t  que.push(p2(now.cost+1,tmp));\n\t}\n      }\n    }\n  }\n  return dist;\n}\n\nint solve(vector<int> start){\n  map<ull,int>a,b;\n  a=bfs(start);\n  vector<int>goal=start;\n  sort(all(goal));\n  b=bfs(goal);\n\n  ull g=encode(goal);\n\n  int ans=start.size()-1;\n  if(a.find(g)!=a.end())ans = min(ans,a[g]);\n\n  do {\n    g=encode(goal);\n    if(a.find(g) == a.end()) continue;\n    if(b.find(g) == b.end()) continue;\n    ans = min(ans, a[g] + b[g]);\n  } while(next_permutation(all(goal)));\n\n  return ans;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n);\n  for(int i=0;i<n;i++)cin >> v[i];\n \n  cout << solve(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nchar n; vector<char>a; queue<pair<vector<char>,char>>Q;\nvector<pair<vector<char>, char>>a1, a2;\nset<vector<char>>E;\nvoid init(vector<char>R, char Lim, char D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<char>H = Q.front().first; int L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tvector<char>I = H; char Y = j;\n\t\t\t\tfor (int k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { char p; cin >> p; a.push_back(p); }\n\tchar pos = n / 2; init(a, pos, 0); vector<char>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos, 1);\n\tsort(a1.begin(), a1.end()); sort(a2.begin(), a2.end());\n\tint ret = n - 1;\n\tfor (int i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (char)0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tfor (int j = S1; j < S2; j++) ret = min(ret, a1[i].second + a2[j].second);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<vector<int>,int> m[2];\nint main() {\n  int n;\n  cin >> n;\n  vector<int> a[2];\n  for(int i=0,x; i<n; i++) {\n    cin >> x;\n    a[0].push_back(x);\n    a[1].push_back(i+1);\n  }\n  for(int k=0; k<2; k++) {\n    queue<vector<int> > que;\n    m[k][a[k]]=0;\n    que.push(a[k]);\n    while(!que.empty()) {\n      vector<int> b=que.front();que.pop();\n      int x=m[k][b];\n      if(x>3) continue;\n      for(int i=0; i<n; i++) {\n        for(int j=i+1; j<n; j++) {\n          vector<int> c=b;\n          reverse(c.begin()+i,c.begin()+j+1);\n          if(m[k].count(c)) continue;\n          m[k][c]=x+1;\n          que.push(c);\n        }\n      }\n    }\n  }\n  int ans=9;\n  for(map<vector<int>,int>::iterator it=m[0].begin(); it!=m[0].end(); it++) {\n    if(m[1].count(it->first)) ans=min(ans,it->second+m[1][it->first]);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            const Pack &pack = Queue[curr][i];\n            \n            const vector<int> &perm = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        cin >> start[i];\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef pair<int,ll > T;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint N;\nint A[12];\nqueue<T> q1;\nmap<ll,int> m;\nint ans;\nvector<int> rev(vector<int> v,int a,int b)\n{\n\treverse(v.begin()+a,v.begin()+b+1);\n\treturn v;\n}\nll encode(vector<int> v)\n{\n\tll res = 0ll;\n\tfor(int i=0;i<v.size();i++)\n\t{\n\t\tres = (res<<4)+v[i];\n\t}\n\treturn res;\n}\nvector<int> decode(ll h)\n{\n\tvector<int> v;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tv.pb(((1<<4)-1)&h);\n\t\th >>= 4;\n\t}\n\treturn v;\n}\nvoid bfs()\n{\n\tvector<int> vec;\n\tfor(int i=0;i<N;i++)vec.pb(A[i]);\n\tll f = encode(vec);\n\tq1.push(T(0,f));\n\tm[f]=0;\n\twhile(!q1.empty())\n\t{\n\t\tT a = q1.front();\n\t\tq1.pop();\n\t\tif(a.fi>4)return;\n\t\t//cout << a.fi << ' ' << m.size() << endl;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<N;j++)\n\t\t\t{\n\t\t\t\t//cout << i << ' ' << j << endl;\n\t\t\t\tvector<int> d = decode(a.sec);\n\t\t\t\tvector<int> v = rev(d,i,j);\n\t\t\t\tll e = encode(v);\n\t\t\t\tif(m.find(e)==m.end())\n\t\t\t\t{\n\t\t\t\t\tq1.push(T(a.fi+1,e));\n\t\t\t\t\tm[e]=a.fi+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bfs2()\n{\n\tvector<int> vec;\n\tfor(int i=0;i<N;i++)vec.pb(i+1);\n\tqueue<T> q;\n\tll f = encode(vec);\n\tq.push(T(0,f));\n\tmap<ll,int>::iterator it;\n\tif((it=m.find(f))!=m.end())\n\t{\n\t\tans = it->sec;\n\t\treturn;\n\t}\n\twhile(!q.empty())\n\t{\n\t\tT a = q.front();\n\t\tq.pop();\n\t\tif(a.fi>4)return;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=i+1;j<N;j++)\n\t\t\t{\n\t\t\t\tvector<int> d = decode(a.sec);\n\t\t\t\tvector<int> v = rev(d,i,j);\n\t\t\t\tll e = encode(v);\n\t\t\t\tif((it=m.find(e))==m.end())q.push(T(a.fi+1,e));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans = a.fi+1+it->sec;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&A[i]);\n\tans = N-1;\n\tbfs();\n\t//printf(\"a\\n\");\n\tbfs2();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nint maxdepth;\nmap<VI,int> mp;\n\nvoid Rev(int l,int r,vector<int> &v){\n  for(int i=0;i<=10;i++){\n    if(l+i>=r-i)break;\n    swap(v[l+i],v[r-i]);\n  }\n  return;\n}\n\nvoid bfs(vector<int> v,int depth){\n  if(depth>maxdepth)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        if(mp[v1]>depth){\n          mp[v1] = depth;\n          bfs(v1,depth+1);\n        }\n      }else if(mp[v1]==0){\n        mp[v1] = depth;\n        bfs(v1,depth+1);\n      }\n    }\n  }\n  return;\n}\n\nvoid bfs2(vector<int> v,int depth,int &ans){\n  if(depth>maxdepth)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        ans = min(ans,mp[v1]+depth);\n        bfs2(v1,depth+1,ans);\n      }else if(mp[v1]==0){\n        bfs2(v1,depth+1,ans);\n      }\n    }\n  }\n  return;\n}\n\n\n\nint main(){\n  int n;\n  cin >>n;\n  maxdepth = (n -1) / 2;\n  VI a(n);\n  rep(i,n)cin>>a[i];\n  mp[a]=0;\n  bfs(a,1);\n  VI b(n);\n  rep(i,n)b[i]=i+1;\n  if(a==b){\n    cout << 0 << endl;\n    return 0;\n  }\n  int ans = 10000;\n  if(mp[b]!=0){\n    cout << mp[b] << endl;\n    return 0;\n  }\n  bfs2(b,1,ans);\n  if(ans==10000){\n    cout << n-1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack &pack = Queue[curr][i];\n            \n            vector<int> &perm_ = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            /*for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    } else {\n                        nextQueue.push_back(make_pair(perm, nextPermId));\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }*/\n            \n            for(int s=0;s<N;s++){\n                for(int d=1;d<=2;d++){\n                    vector<int> perm = perm_;\n                    \n                    int S = s;\n                    int T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        int nextPermId = getPermId(perm);\n                        if(dist[curr][nextPermId] == -1){\n                            dist[curr][nextPermId] = nowCost + 1;\n                            \n                            if(dist[next][nextPermId] != -1){\n                                return dist[curr][nextPermId] + dist[next][nextPermId];\n                            } else {\n                                nextQueue.push_back(make_pair(perm, nextPermId));\n                            }\n                        }\n                        \n                        --S;\n                        ++T;\n                    }\n                    \n                    \n                    /*\n                    S = s;\n                    T = s + d;\n                    \n                    while(S >= 0 && T < N){\n                        swap(perm[S], perm[T]);\n                        \n                        --S;\n                        ++T;\n                    }*/\n                }\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        cin >> start[i];\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint bfs(vector<int> v)\n{\n    map<vector<int>, int> D; D[v] = 1;\n    \n    vector<int> sorted = v; sort(sorted.begin(), sorted.end());\n    \n    queue<pair<vector<int>, int> > que; que.push(make_pair(v, 1));\n    \n    while(!que.empty())\n    {\n        pair<vector<int>, int> p1 = que.front(); que.pop();\n        \n        for(int i = 0; i < v.size(); i++)\n        {\n            for(int j = i + 1; j < v.size(); j++)\n            {\n                vector<int> p2 = p1.first;\n                \n                swap(p2[i], p2[j]);\n                \n                if(D[p2] == 0)\n                {\n                    if(p2 == sorted)\n                    {\n                        return p1.first;\n                    }\n                    \n                    D[p2] = p1.second + 1;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main()\n{\n    int n; vector<int> a;\n    \n    cin >> n; a = vector<int>(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    \n    cout << bfs(a) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint N;\nvector<int> A, B;\n\nmap<vector<int>, int> bfs(vector<int> start) {\n    map<vector<int>, int> memo;\n    queue< vector<int> > Q;\n    Q.push(start);\n    memo[start] = 0;\n\n    while(!Q.empty()) {\n        vector<int> vi = Q.front();\n        Q.pop();\n\n        int cost = memo[vi];\n\n        if(cost >= (N - 1) / 2) continue;\n\n        for(int i = 0; i < N; i++) {\n            for(int j = i + 2; j <= N; j++) {\n                vector<int> tmp = vi;\n                reverse(tmp.begin() + i, tmp.begin() + j);\n                if(memo.find(tmp) == memo.end()) {\n                    memo[tmp] = cost + 1;\n                    Q.push(tmp);\n                }\n            }\n        }\n    }\n\n    return memo;\n}\n\nint solve() {\n    int ans = N - 1;\n    map<vector<int>, int> memo_A = bfs(A);\n    map<vector<int>, int> memo_B = bfs(B);\n    if(memo_A.find(B) != memo_A.end()) ans = memo_A[B];\n    else {\n        do {\n            if(memo_A.find(B) == memo_A.end()) continue;\n            if(memo_B.find(B) == memo_B.end()) continue;\n            ans = min(ans, memo_A[B] + memo_B[B]);\n        } while(next_permutation(B.begin(), B.end()));\n    }\n    return ans;\n}\n\nint main() {\n    cin >> N;\n    rep(i, N) {\n        int a;\n        cin >> a;\n        A.push_back(a);\n    }\n    B = A;\n    sort(B.begin(), B.end());\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint N, A[11];\n\nvoid solve() {\n\tint i = N - 1;\n\tint ans = 0;\n\t\n\twhile (i > 0) {\n\t\tint p = i;\n\t\twhile (p > 0 && A[p - 1] > A[p]) {\n\t\t\t--p;\n\t\t}\n\t\t\n\t\tif (p != i) {\n\t\t\treverse(A + p, A + i + 1);\n\t\t\t++ans;\n\t\t\ti = N - 1;\n\t\t} else {\n\t\t\t--i;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> N;\n\tfor_(i,0,N) cin >> A[i];\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nint n,x,co;\nvector<int>v;\nmap<long long,int>M1;\nset<long long >s;\nlong long has(vector<int> &g){\n  long long res=0;\n  r(i,n){\n    if(g[i]!=10)res=res*10+g[i];\n    if(g[i]==10)res*=10;\n  }\n  return res;\n}\nvoid bfs(int p){\n  queue<P>q;\n  q.push(P(v,0));\n  s.insert(has(v));\n  while(!q.empty()){\n    vector<int> g=q.front().first;\n    int cost=q.front().second,c=0;q.pop();\n    if(!p){\n      r(i,n-1)if(g[i]>g[i+1])c++;\n      if(!c){\n        cout<<cost<<endl;\n        exit(0);\n      }\n      M1[has(g)]=cost;\n    }\n    else{\n      if(M1[has(g)]){\n        cout<<cost+M1[has(g)]<<endl;\n        exit(0);\n      }\n    }\n    if(cost==5)continue;\n    for(int i=2;i<=n;i++){\n      for(int j=0;j+i<=n;j++){\n        vector<int>t=g;\n        for(int k=j,l=0;l<i/2;l++,k++){\n          swap(t[k],t[j+i-1-l]);\n        }\n        int T=has(t);\n        if(!s.count(T)){\n          s.insert(T);\n          q.push(P(t,cost+1));\n        }\n      }\n    }\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>x;\n    v.push_back(x);\n  }\n  bfs(0);\n  r(i,n)v[i]=i+1;\n  bfs(1);\n  cout<<9<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint n;\nstring first, sorted;\nmap<int,int> closed, closed2;\n\nint toInt(const string &s){\n  int res = 0;\n\n  for(int i = 1; i < n; i++){\n    res *= 10;\n    res += s[i] - '0';\n  }\n\n  return res;\n}\n\ntypedef pair<string,int> P;\n\nvoid bfs(){\n  queue<P> open;\n  open.push(P(first, 0));\n\n  closed.clear();\n  closed[toInt(first)] = 0;\n\n  while(!open.empty()){\n    P p = open.front(); open.pop();\n\n    for(int from = 0; from < n - 1; from++){\n      for(int to = from + 1; to < n; to++){\n        string ns = p.first;\n        reverse(ns.begin() + from, ns.begin() + to + 1);\n\n        int x = toInt(ns);\n\n        if(closed.find(x) == closed.end()){\n          closed[x] = p.second + 1;\n\n          if(p.second + 1 < 4){\n            open.push(P(ns, p.second + 1));\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid solve(){\n  int ans = n - 1;\n  queue<P> open;\n  open.push(P(sorted, 0));\n\n  int x = toInt(sorted);\n\n  closed2.clear();\n  closed2[x] = 0;\n\n  if(closed.find(x) != closed.end()){\n    ans = min(ans, closed[x]);\n  }\n\n  while(!open.empty()){\n    P p = open.front(); open.pop();\n\n    for(int from = 0; from < n - 1; from++){\n      for(int to = from + 1; to < n; to++){\n        string ns = p.first;\n        reverse(ns.begin() + from, ns.begin() + to + 1);\n\n        int x = toInt(ns);\n\n        if(closed.find(x) != closed.end()){\n          ans = min(ans, p.second + closed[x] + 1);\n        }\n        else if(closed2.find(x) == closed2.end()){\n          closed2[x] = p.second + 1;\n\n          if(p.second + 1 < 4){\n            open.push(P(ns, p.second + 1));\n          }\n        }\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n){\n    first = \"\";\n    sorted = \"\";\n\n    for(int i = 0; i < n; i++){\n      int x;\n      cin >> x;\n      first += '0' + (char)(x - 1);\n      sorted += '0' + (char)i;\n    }\n\n    bfs();\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-4;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nmap<ll, bool> mp,cmp; int n;\nll calc(vector<int> v) {\n\tll res = 0;\n\trep(i, n) {\n\t\tres *= 10; res += v[i];\n\t}\n\treturn res;\n}\nll rev(ll x, int l, int r) {\n\tvector<int> v;\n\trep(i, n) {\n\t\tv.push_back((int)(x % 10)); x /= 10;\n\t}\n\treverse(v.begin(), v.end());\n\treverse(v.begin() + l, v.begin() + r + 1);\n\tll res = 0;\n\trep(i, n) {\n\t\tres *= 10; res += v[i];\n\t}\n\treturn res;\n}\nint main() {\n\tcin >> n;\n\tll sta = 0; ll g = 0;\n\trep(i, n) {\n\t\tint a; cin >> a; a--; g *= 10; g += a;\n\t\tsta *= 10; sta += i;\n\t}\n\tif (sta == g) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\tqueue<ll> q; q.push(sta); mp[sta] = true;\n\tqueue<ll> p; p.push(g); cmp[g] = true;\n\tint c = 0; int sc = 0;\n\tbool fin = false;\n\twhile (!fin) {\n\t\tint len = q.size();\n\t\trep(j, len) {\n\t\t\tll x = q.front(); q.pop();\n\t\t\trep(i, n) {\n\t\t\t\tRep(k, i + 1, n) {\n\t\t\t\t\tll val = rev(x, i, k);\n\t\t\t\t\tif (cmp[val]) {\n\t\t\t\t\t\tcout << c + sc + 1 << endl; return 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!mp[val]) {\n\t\t\t\t\t\tmp[val] = true; q.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc++;\n\t\tlen = p.size();\n\t\trep(j, len) {\n\t\t\tll x = p.front(); p.pop();\n\t\t\trep(i, n) {\n\t\t\t\tRep(k, i + 1, n) {\n\t\t\t\t\tll val = rev(x, i, k);\n\t\t\t\t\tif (mp[val]) {\n\t\t\t\t\t\tcout << c + sc + 1 << endl; return 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!cmp[val]) {\n\t\t\t\t\t\tcmp[val] = true; p.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc++;\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint from, to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi v(n);\n\tREP(i, n) cin >> v[i];\n\tmap<vi, int> mp1, mp2;\n\tqueue<vi> que;\n\tmp1[v] = 0;\n\tque.push(v);\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tif (mp1[tmp] > n / 2) break;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) mp1[nx] = mp1[tmp] + 1;\n\t\t\tque.push(nx);\n\t\t}\n\t}\n\n\twhile (que.size()) que.pop();\n\tsort(ALL(v));\n\tmp2[v] = 0;\n\tque.push(v);\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tif (mp2[tmp] > n / 2) break;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp2.find(nx) == mp2.end()) mp2[nx] = mp2[tmp] + 1;\n\t\t\tque.push(nx);\n\t\t}\n\t}\n\tint ans = n - 1;\n\tfor (auto it = mp1.begin(); it != mp1.end(); it++)\n\t{\n\t\tvi tmp = (*it).first;\n\t\tif (mp2.find(tmp) != mp2.end()) chmin(ans, (*it).second + mp2[tmp]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64, i64> P;\n#define rep(i, s, e) for (int i = (s); i <= (e); i++)\n\nvoid rec(vector<int> &x, map<vector<int>, int> &mp)\n{\n  queue<vector<int>> que;\n  que.emplace(x);\n  while (!que.empty())\n  {\n    vector<int> a = que.front();\n    que.pop(); \n    int cou = mp[a];\n    if(cou == 4) continue;\n    for (int i = 0; i < a.size(); i++)\n    {\n      for (int j = i + 1; j < a.size(); j++)\n      {\n        reverse(a.begin() + i, a.begin() + j + 1);\n        auto ite = mp.find(a);\n        if (ite == mp.end())\n        {\n          mp[a] = cou + 1;\n          if(cou + 1 < 4)\n          que.emplace(a);\n        }\n        reverse(a.begin() + i, a.begin() + j + 1);\n      }\n    }\n  }\n}\n\nint n;\nint main()\n{\n  cin >> n;\n  vector<int> a(n);\n  vector<int> sorted(n);\n  for (int i = 0; i < n; i++)\n  {\n    cin >> a[i];\n    a[i]--;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    sorted[i] = i;\n  }\n\n  map<vector<int>, int> mp_sorted, mp_a;\n  mp_sorted[sorted] = 0;\n  mp_a[a] = 0;\n  rec(sorted, mp_sorted);\n  rec(a, mp_a);\n  int result = n - 1;\n  cout << 1 << endl;\n  do\n  {\n    auto ite = mp_sorted.find(sorted);\n    auto ite2 = mp_a.find(sorted);\n    if (ite != mp_sorted.end() && ite2 != mp_a.end())\n    {\n      result = min(result, ite->second + ite2->second);\n    }\n  } while (next_permutation(sorted.begin(), sorted.end()));\n  cout << result << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N;\nvector<int> A;\n\nbool check(vector<int>& a){\n  for(int i=0;i<N;i++)\n    if(a[i]!=i) return false;\n  return true;\n}\nint ind(vector<int>&a, int x){\n  for(int i=0;i<N;i++)\n    if( a[i] == x ) return i;\n}\nvoid upd(int &a,int b){\n  a = min( a, b );\n}\n\nvoid view(vector<int>& a){\n  for(int i=0;i<N;i++) cout << a[i] << \" \";\n  cout << endl;\n}\n\ntypedef pair<vector<int>,int> P;\nmap<vector<int>,int> M;\n\nint solve(){\n  if( check(A) ) return 0;\n  M.clear();\n  queue<P> q;\n  q.push( P(A, 0) );\n  while( !q.empty() ){\n    P p = q.front(); q.pop();\n    for(int i=0;i<N;i++){\n      vector<int> a=p.first;\n      int v = ind(a,i);\n      if( v == i ) continue;\n      if( v < i ) \n        reverse( a.begin()+v, a.begin()+i+1 );\n      else \n        reverse( a.begin()+i, a.begin()+v+1 );\n      if( M.count( a ) == 0 ){\n        if( check(a) ) return p.second+1;\n        M[a] = p.second+1;\n        q.push( P(a,p.second+1) );\n      }             \n    }\n  }\n}\n\nint main(){\n  while(cin >> N){\n    A.resize(N);\n    for(int i=0;i<N;i++) {\n      cin >>A[i]; A[i]--;\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long swp(long long a, int i, int j) {\n    long long t = ((a >> (i << 2)) ^ (a >> (j << 2))) & 15;\n    return a ^ (t << (i << 2)) ^ (t << (j << 2));\n}\n\nlong long rev(long long a, int i, int j) {\n    while (i < j) {\n        a = swp(a, i, j);\n        ++i;\n        --j;\n    }\n    return a;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    long long a = 0, m = 0;\n    for (int i = 0; i < n; ++i) {\n        int b;\n        cin >> b;\n        a = (a << 4) + b;\n        m = (m << 4) + i + 1;\n    }\n    unordered_map<long long, int> mp;\n    mp[m] = 0;\n    queue<long long> q;\n    q.push(m);\n\n    while (!q.empty()) {\n        long long p = q.front();\n        q.pop();\n        for (int i = 0; i < n; ++i) {\n            long long pa = p;\n            for (int j = 1; i + j < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j);\n                if (!mp.count(pa)) {\n                    mp[pa] = mp[p] + 1;\n                    if (pa == a) {\n                        goto A;\n                    }\n                    q.push(pa);\n                }\n            }\n            pa = p;\n            for (int j = 0; i + j + 1 < n && i - j >= 0; ++j) {\n                pa = swp(pa, i - j, i + j + 1);\n                if (!mp.count(pa)) {\n                    mp[pa] = mp[p] + 1;\n                    if (pa == a) {\n                        goto A;\n                    }\n                    q.push(pa);\n                }\n            }\n        }\n    }\n    A:\n    cout << mp[a] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nconstexpr long long D[] = {1, 10, 100, 1000, (long long)1e4, (long long)1e5, (long long)1e6, (long long)1e7, (long long)1e8, (long long)1e9, (long long)1e10, (long long)1e11};\n\nlong long rev(const long long int &s, int i, int j){\n  long long int ret = s;\n  for(int k = i; k <= j; ++k){\n    ret -= (s/D[k])%10*D[k];\n    ret += (s/D[j-k+i])%10*D[k];\n  }\n  //cout << s << \" \" << i << \" \" << j << \" \" << ret << endl;\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  long long int a = stoll(A);\n  int c = 1;\n  while(D[N-c] > a){\n    for(int i = 0; i < N-c; ++i) a -= D[i];\n    ++c;\n  }\n  //cout << \"a = \" << a << endl;\n  queue<long long> wait;\n  //wait.emplace(-1,a);\n  wait.emplace(a);\n  map<long long, int> M;\n  M[a] = 1;\n  M[0] = N;\n  while(!wait.empty()){\n    long long t = wait.front();\n    int s = M[t];\n    wait.pop();\n    //cout << t << endl;\n    int l = 0;\n    for(int i = 0; i <= N; ++i){\n      if(D[i] > t){\n        l = i;\n        break;\n      }\n    }\n    for(int i = 0; i < l; ++i){\n      for(int j = i+1; j < l; ++j){\n        long long u = rev(t, i, j);\n        int c = 1;\n        while(D[l-c] > u){\n          for(int k = 0; k < l-c; ++k) u -= D[k];\n          ++c;\n        }\n        if(!u){\n          cout << s << endl;\n          return 0;\n        }\n        if(s < N-1 && !M[u]){\n          M[u] = s + 1;\n          wait.emplace(u);\n        }\n      }\n    }\n  }\n  cout << M[0]-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REACH cout << __LINE__ << endl\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef long double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef pair<ut,ut> pr;\ntypedef pair<ut,pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef pair<int,vector<int> > pqt;\ntypedef vector<pqt> Vpqt;\ntypedef priority_queue<pqt,Vpqt,greater<pqt> > PQ;\nmap<vector<int>,int> dists;\ntypedef pair<int,vector<int> > pvi;\nconst int SIZE=20;\nclock_t clocks[SIZE];\ndouble clockst(int x){\n\tclocks[x] = -clock();\n}\ndouble clocked(int x){\n\tclocks[x] += clock();\n}\t\ndouble timer(int x){\n\treturn clocks[x];\n}\nvoid reverse(vector<int> &nums,int a,int b){\n\twhile(a<b){\n\t\tswap(nums[a++],nums[b--]);\n\t}\n}\n/*int score(vector<int> &nums){\n\tint ables[2]={};\n\tREP(i,nums.size()){\n\t\tables[abs(i+1-nums[i])&1]|=1;\n\t}\n\treturn ables[0]+ables[1];\n}*/\n/*int score(vector<int> &nums){\n\t\n\tint ans=0;\n\tREP(i,nums.size()-1){\n\t\tif(i+1-nums[i]>0 && i+2-nums[i+1]<0) ans++;\n\t}\n\t\n\treturn ans;\n\t\n}*/\nint score(vector<int> &nums){\n//\treturn 0;\n\tint ans=0,two=0;\n\tREP(i,nums.size()-1){\n\t\tif(abs(nums[i+1]-nums[i])>=2) two++;\n\t}\n\tFOR(i,0,nums.size()){\n\t\tif((((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i])*(nums[i]-(i?nums[i-1]:0))<0) ans++;\n//\t\tcout << (((i!=nums.size()-1)?nums[i+1]:(int)nums.size())-nums[i]) << \" \" <<  (nums[i]-(i?nums[i-1]:0)) << endl;\n\t}\n//\tcout << ans << endl;\n\tif(nums.size()==10)\n\t\treturn two;\n\treturn (max(two,ans)+1)/2;\t\n}\n\nint times=0;\nint solve(vector<int> nums){\n\tclockst(2);\n\t\n\tPQ qu;\n\n\tvector<int> ans;\n\tREP(i,nums.size()){\n\t\tans.PB(i+1);\n\t}\n\tqu.push(pvi(score(nums),nums));\n\t\n\twhile(!qu.empty()){\n\t\tvector<int> now=qu.top().second;\n\t\tint dist=qu.top().first-score(now);\n\t\tqu.pop();\n\t\tif(dist!=dists[now]) continue;\n\t\ttimes++;\n\t\tif(times%10000==0) cout << times << endl;\n\t\tif(now==ans) return dists[ans];\n//\t\tREP(i,now.size()) cout << now[i] << \" \";\n//\t\tcout <<dist << \" \"<< score(now) <<  endl;\n\t\tREP(i,nums.size()){\n\t\t\tREP(j,i){\n\t\t\t\treverse(now,j,i);\n\t\t\t\tif(!dists.count(now) || dists[now]>dist+1){\n\t\t\t\t\tif(dist+1+score(now)<nums.size()-1) qu.push(pvi(dist+1+score(now),vector<int>(now)));\n\t\t\t\t\tif(dist+1+score(now)<nums.size()) dists[now]=dist+1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\treverse(now,j,i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn nums.size()-1;\n}\t\nint main() {\n\tvector<int> vi;\n\tint n,x;\n\t\n\tcin >> n;\n\tREP(i,n){\n\t\tcin >> x;\n\t\tvi.PB(x);\n\t}\n\tcout << solve(vi) << endl;\n\tclocked(2);\n\t//cout << times << endl;\n\t//cout << dists.size() << endl;\n\t//cout << timer(2) << endl;\n\t//cout << timer(1) << endl;\n\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef pair<int,vector<int> > p2;\n \nmap<vector<int>,int> dist2;\n \nint n;\nqueue<p2> que;\n\nmap<vector<int>,int> bfs(vector<int>start){\n  \n  map<vector<int>,int> dist;\n\n  que.push(p2(0,start));\n  dist[start]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n    \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    dist[now.state]=now.cost;\n    if(now.cost>=(n-1)/2)continue;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<int>t=now.state;\n\treverse(t.begin()+i,t.begin()+j+1);\n\tif(dist.find(t)==dist.end())\n\t  que.push(p2(now.cost+1,t));\n      }\n    }\n  }\n  return dist;\n}\n\nint solve(vector<int> start){\n  map<vector<int>,int>a,b;\n  a=bfs(start);\n  vector<int>goal=start;\n  sort(all(goal));\n  b=bfs(goal);\n\n  int ans=start.size()-1;\n  if(a.find(goal)!=a.end())ans = min(ans,a[goal]);\n\n  do {\n      if(a.find(goal) == a.end()) continue;\n      if(b.find(goal) == b.end()) continue;\n      ans = min(ans, a[goal] + b[goal]);\n  } while(next_permutation(all(goal)));\n\n  return ans;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n);\n  for(int i=0;i<n;i++)cin >> v[i];\n \n  cout << solve(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntypedef long long ll;\n\n#include <cstdio>\n#include <set>\n\nusing namespace std;\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nll encode(const vector<int> &v){\n  ll ret = 0;\n  const int n = v.size();\n  REP(i,n) ret |= (ll)(v[i]) << 4 * i;\n  return ret;\n}\n\nvector<int> decode(const ll val, int n){\n  vector<int> ret(n);\n  REP(i,n) ret[i] = (val >> (4 * i)) & ((1 << 4) - 1);\n  return ret;\n}\n\nint main(){\n  const int n = getInt();\n  ll s = 0;\n  ll d = 0;\n  REP(i,n) s |= (ll)(getInt() - 1) << (4 * i);\n  REP(i,n) d |= (ll)(i)            << (4 * i);\n\n  map<ll, int> memo;\n  queue<ll> q;\n\n  memo[s] = 0;\n  q.push(s);\n\n  while(q.size()){\n    const ll state = q.front(); q.pop();\n    vector<int> v = decode(state, n);\n    const int cnt = memo[state];\n\n    if(state == d){\n      printf(\"%d\\n\", cnt);\n      break;\n    }\n\n    REP(i,n) for(int j = i + 1; j <= n; j++){\n      reverse(v.begin() + i, v.begin() + j);\n\n      const ll next = encode(v);\n      if(memo.count(next) == 0){\n        memo[next] = cnt + 1;\n        q.push(next);\n      }\n\n      reverse(v.begin() + i, v.begin() + j);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<char> v, r;\n\nvector<pair<vector<char>, int> > v1, v2;\n\ninline int solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2 - 1, rn = n - ln - 1;\n\n\tif (n == 10) { rn--; }\n\n\tmap<vector<char>, int> d1; d1[v] = 1;\n\n\tqueue<vector<char> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<char> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<char>, int> d2; d2[r] = 1;\n\n\tqueue<vector<char> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<char> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<char> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<char> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<char>(n); int k;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &k); v[i] = k;\n\t}\n\n\tvector<char> tokushu1 = { 3, 1, 5, 2, 7, 4, 9, 6, 10, 8 };\n\n\tif (v == tokushu1)\n\t{\n\t\tprintf(\"9\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N,ans = BIG_NUM;\nll sorted_num;\nmap<ll,int> MAP;\n\n\nvoid recursive(ll number,int swap_count){\n\n\t//printf(\"number:%lld swap_count:%d\\n\",number,swap_count);\n\n\tif(swap_count >= ans){\n\t\treturn;\n\t}\n\n\tll array[10],work[10];\n\tstack<ll> S;\n\n\t//数字を配列表現に直す\n\tll tmp = number;\n\n\twhile(tmp > 0){\n\t\tS.push(tmp%10);\n\t\ttmp /= 10;\n\t}\n\n\tint index = 0;\n\twhile(!S.empty()){\n\n\t\tarray[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\t/*printf(\"array\\n\");\n\tfor(int i = 0; i < N; i++){\n\t\tprintf(\"%d\",array[i]);\n\t}\n\tprintf(\"\\n\");*/\n\n\tll next_number;\n\n\tfor(int i = 0; i < index-1; i++){\n\t\tfor(int k = i+1; k < index; k++){\n\t\t\tfor(int p = 0; p < index; p++)work[p] = array[p];\n\t\t\tswap(work[i],work[k]);\n\n\t\t\tnext_number = 0;\n\t\t\tfor(int p = 0; p < index; p++){\n\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t}\n\n\t\t\t//printf(\"next_num:%lld\\n\",next_number);\n\n\t\t\tauto at = MAP.find(next_number);\n\n\t\t\tif(at == MAP.end()){\n\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t}else{\n\t\t\t\tif(MAP[next_number] <= swap_count+1)continue; //より少ない回数を計算済ならSKIP\n\n\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t}\n\n\t\t\tif(next_number == sorted_num){ //答えが見つかったら、これ以上やらない\n\t\t\t\tans = swap_count+1;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\trecursive(next_number,swap_count+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){ //大きさの順位を足す(0～9)\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終形を求める(簡単のため、0,1,2..と置き換える)\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = BIG_NUM;\n\n\t//printf(\"first:%lld sorted:%lld\\n\",first,sorted_num);\n\n\trecursive(first,0);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N,A[11];\nmap<vi,int> M[2];\n\nvoid dfs(vi v,int step,int mode){\n\tif(M[mode].find(v)==M[mode].end()){\n\t\tM[mode][v]=step;\n\t}\n\telse M[mode][v]=min(M[mode][v],step);\n\tif(step==4)return;\n\trep(i,N)rep2(j,i+1,N){\n\t\tvi w=v;\n\t\trep2(k,i,j+1){\n\t\t\tw[k] = v[j-(k-i)];\n\t\t}\n\t\tdfs(w,step+1,mode);\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N;\n\trep(i,N)cin>>A[i],A[i]--;\n\t\n\tvi v;\n\trep(i,N)v.pb(A[i]);\n\tdfs(v,0,0);\n\tv.clear();\n\trep(i,N)v.pb(i);\n\tdfs(v,0,1);\n\tint ans=9;\n\tforeach(it,M[0]){\n\t\tif(M[1].find(it->fir)!=M[1].end()){\n\t\t\tans=min(ans,it->sec+M[1][it->fir]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef map<vi, int> ma;\n\nvi a,b;\nint N;\n\nma bfs(vi vec){\n    ma tem;\n    queue<vi>que;\n    que.push(vec);\n    tem[vec]=0;\n    while(!que.empty()){\n        \n        vi v=que.front();\n        que.pop();\n//        cout<<\"tem[v]: \"<<tem[v]<<endl;\n//        for(int i=0;i<v.size();i++)\n//            cout<<v[i]<<\" \";\n//        cout<<endl;\n        if(tem[v]>(N-1)/2)\n            continue;\n        for(int i=0;i<N;i++)\n            for(int j=i+2;j<=N;j++){\n                vi n=v;\n                reverse(n.begin()+i,n.begin()+j);\n                if(tem.find(n)==tem.end()){\n                    tem[n]=tem[v]+1;\n                    que.push(n);\n                }\n            }\n    }\n    return tem;\n}\n\nvoid solve(){\n    ma m_a=bfs(a);\n    ma m_b=bfs(b);\n   \n    if(m_a.find(b)!=m_a.end()){\n        cout<<m_a[b]<<endl;\n        return;\n    }\n    int ans=1000000;\n    do{\n        if(m_a.find(b)==m_a.end()&&m_b.find(b)==m_b.end())\n            continue;\n        else\n            ans=min(m_a[b]+m_b[b],ans);\n    }while(next_permutation(b.begin(), b.end()));\n    cout<<ans<<endl;\n}\n\nint main(){\n    cin>>N;\n    for(int i=0;i<N;i++){\n        int t;\n        cin>>t;\n        a.push_back(t);\n    }\n    b=a;\n    sort(b.begin(),b.end());\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct S{\n  vector<int> v;\n  int c,d,e;\n  S(const vector<int> &pv,int pc):v(pv),c(pc){\n    eval();\n  }\n  void eval(){\n    d=0;\n    for(int i=0;i<v.size()-1;i++){\n      d+=abs(v[i]-v[i+1]);\n    }\n    e=c+(d+1)/2;\n  }   \n  void reverse(int a,int b){\n    c++;\n    std::reverse(begin(v)+a,begin(v)+b+1);\n    eval();\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n \nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  map<vector<int>,int> m;\n  for(;;){\n    S c=que.top();\n    if(c.d==0)break;\n    que.pop();\n    if(m.count(c.v)&&m[c.v]<=c.c)continue;\n    m[c.v]=c.c;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n    S n=c;\n    n.reverse(i,j);\n    que.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nint n, in;\nvector<lli> input;\nvector<P> input2;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  return res;\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  sort(input2.begin(), input2.end());\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input2[i].second != 10) state += input2[i].second;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    input2.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n      input2.push_back(P((lli)in, i+1));\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  //return atoi(str.c_str());\n  return res;\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          //if(data.find(v.first) != data.end()) return data[v.first] + v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint N,k;\n\nlong long encode(vector<int> a){\n\tlong long res=0;\n\tlong long coe=1;\n\tfor(int i=0;i<N;i++){\n\t\tres+=coe*a[i];\n\t\tcoe*=10;\n\t}\n\treturn res;\n}\n\nvector<int> decode(long long x){\n\tvector<int> res;\n\tfor(int i=0;i<N;i++){\n\t\tres.push_back(x%10);\n\t\tx/=10;\n\t}\n\treturn res;\n}\n\nmap<long long,int> dis[2];\n\nvoid bfs(long long s,int id){\n\tmap<long long,int> &res=dis[id];\n\tqueue<long long> que;\n\tque.push(s);\n\tres[s]=0;\n\twhile(!que.empty()){\n\t\tlong long cur=que.front();\n\t\tque.pop();\n\t\tint d=res[cur];\n\t\tif(d>=k) continue;\n\t\tvector<int> a=decode(cur);\n\t\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\t\tint tmp[10];\n\t\t\tfor(int k=i;k<=j;k++) tmp[k]=a[k];\n\t\t\tfor(int k=i;k<=j;k++) a[k]=tmp[i+j-k];\n\t\t\tlong long nxt=encode(a);\n\t\t\tif(res.count(nxt)>0&&res[nxt]<=d+1){}\n\t\t\telse{\n\t\t\t\tque.push(nxt);\n\t\t\t\tres[nxt]=d+1;\n\t\t\t}\n\t\t\tfor(int k=i;k<=j;k++) a[k]=tmp[k];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tk=(N-1)/2;\n\tvector<int> s,t;\n\tfor(int i=0;i<N;i++){\n\t\ts.push_back(i);\n\t\tint in;\n\t\tscanf(\"%d\",&in);\n\t\tt.push_back(in-1);\n\t}\n\tlong long s_=encode(s);\n\tlong long t_=encode(t);\n\tbfs(s_,0);\n\tbfs(t_,1);\n\tint ans=N-1;\n\tmap<long long,int>::iterator it1=dis[0].begin(),it2=dis[1].begin();\n\tfor(;;){\n\t\tif(it1==dis[0].end()||it2==dis[1].end()) break;\n\t\tif(it1->first==it2->first){\n\t\t\tans=min(ans,it1->second+it2->second);\n\t\t\tit1++;it2++;\n\t\t}else if(it1->first<it2->first) it1++;\n\t\telse it2++;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nint n;\n\nLL encode(const vector<char> &v){\n\tLL a = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\ta |= (LL)v[i] << (i << 2);\n\t}\n\treturn a;\n}\n\nvector<char> decode(LL x){\n\tvector<char> v(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tv[i] = (x >> (i << 2)) & 15;\n\t}\n\treturn v;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\t\n\tvector<char> s(n), goal(n);\n\tint x;\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &x);\n\t\ts[i] = x;\n\t\tgoal[i] = i + 1;\n\t}\n\t\n\tif( s == goal ){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\n\tvector<LL> v1, v2;\n\tv1.push_back( encode(s) );\n\tv2.push_back( encode(goal) );\n\t\n\tset<LL> old;\n\told.insert( v1[0] );\n\told.insert( v2[0] );\n\n\tint a;\n\tfor(int a = 1; ; ++a){\n\t\tvector<LL> tmp;\n\t\t\n\t\tfor(int i = 0; i < v1.size(); ++i){\n\t\t\ts = decode( v1[i] );\n\t\t\tfor(int j = 0; j < n - 1; ++j)\n\t\t\tfor(int k = j + 2; k <= n; ++k){\n\t\t\t\tvector<char> t = s;\n\t\t\t\treverse(t.begin() + j, t.begin() + k);\n\t\t\t\tLL u = encode(t);\n\n\t\t\t\tif( binary_search(v2.begin(), v2.end(), u) ){\n\t\t\t\t\tprintf(\"%d\\n\", a);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( old.find(u) == old.end() ){\n\t\t\t\t\told.insert(u);\n\t\t\t\t\ttmp.push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(tmp.begin(), tmp.end());\n\t\tv1.swap(tmp);\n\t\t\n\t\tv1.swap(v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<queue>\n \n#define cost first\n#define state second\n#define all(c) (c).begin(),(c).end()\n \nusing namespace std;\n \ntypedef pair<int,vector<int> > p2;\n \nmap<vector<int>,int> dist2;\n \nint n;\nqueue<p2> que;\n\nmap<vector<int>,int> bfs(vector<int>start){\n  \n  map<vector<int>,int> dist;\n\n  que.push(p2(0,start));\n  dist[start]=0;\n  while(!que.empty()){\n    p2 now = que.front();\n    que.pop();\n    \n    if(dist.find(now.state)!=dist.end() && dist[now.state]<now.cost)continue;\n    if(now.cost>=(n-1)/2)continue;\n     \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tvector<int>t=now.state;\n\treverse(t.begin()+i,t.begin()+j+1);\n\tif(dist.find(t)==dist.end()){\n\t  dist[t]=now.cost+1;\n\t  que.push(p2(now.cost+1,t));\n\t}\n      }\n    }\n  }\n  return dist;\n}\n\nint solve(vector<int> start){\n  map<vector<int>,int>a,b;\n  a=bfs(start);\n  vector<int>goal=start;\n  sort(all(goal));\n  b=bfs(goal);\n\n  int ans=start.size()-1;\n  if(a.find(goal)!=a.end())ans = min(ans,a[goal]);\n\n  do {\n      if(a.find(goal) == a.end()) continue;\n      if(b.find(goal) == b.end()) continue;\n      ans = min(ans, a[goal] + b[goal]);\n  } while(next_permutation(all(goal)));\n\n  return ans;\n}\n\nint main(void){\n \n  cin >> n;\n \n  vector<int>v(n);\n  for(int i=0;i<n;i++)cin >> v[i];\n \n  cout << solve(v) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N;\nvector<int> A;\n\nbool check(vector<int>& a){\n  for(int i=0;i<N;i++)\n    if(a[i]!=i) return false;\n  return true;\n}\nint ind(vector<int>&a, int x){\n  for(int i=0;i<N;i++)\n    if( a[i] == x ) return i;\n}\nvoid view(vector<int>& a){\n  for(int i=0;i<N;i++) cout << a[i] << \" \";\n  cout << endl;\n}\n\ntypedef pair<vector<int>,int> P;\nmap<vector<int>,int> M;\n\nint solve(){\n  if( check(A) ) return 0;\n  M.clear();\n  queue<P> q;\n  q.push( P(A, 0) );\n  while( !q.empty() ){\n    P p = q.front(); q.pop();\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n        vector<int> a=p.first;\n        reverse( a.begin()+i, a.begin()+j+1 );\n        if( M.count( a ) == 0 ){\n          if( check(a) ) return p.second+1;\n          M[a] = p.second+1;\n          q.push( P(a,p.second+1) );\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> N){\n    A.resize(N);\n    for(int i=0;i<N;i++) {\n      cin >>A[i]; A[i]--;\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint from, to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvi v(n);\n\tREP(i, n) cin >> v[i];\n\tmap<vi, int> mp1, mp2;\n\tqueue<vi> que;\n\tmp1[v] = 0;\n\tque.push(v);\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tif (mp1[tmp] > 4) break;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp1.find(nx) == mp1.end()) mp1[nx] = mp1[tmp] + 1;\n\t\t\tque.push(nx);\n\t\t}\n\t}\n\n\twhile (que.size()) que.pop();\n\tsort(ALL(v));\n\tmp2[v] = 0;\n\tque.push(v);\n\twhile (que.size())\n\t{\n\t\tvi tmp = que.front();\n\t\tif (mp2[tmp] > 4) break;\n\t\tque.pop();\n\t\tREP(j, n)REP(i, j)\n\t\t{\n\t\t\tvi nx = tmp;\n\t\t\treverse(nx.begin() + i, nx.begin() + j + 1);\n\t\t\tif (mp2.find(nx) == mp2.end()) mp2[nx] = mp2[tmp] + 1;\n\t\t\tque.push(nx);\n\t\t}\n\t}\n\tint ans = n - 1;\n\tfor (auto it = mp1.begin(); it != mp1.end(); it++)\n\t{\n\t\tvi tmp = (*it).first;\n\t\tif (mp2.find(tmp) != mp2.end()) chmin(ans, (*it).second + mp2[tmp]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 10\n#define INF 1e9\ntypedef vector<int> Vec;\n\nint N;\nmap<Vec,int> dist[2];\n\nvoid bfs(int p,Vec &start){\n  Vec st;\n  queue<Vec> que; \n\n  dist[p][start] = 0;\n  que.push(start);\n\n  while(!que.empty()){\n    Vec s = que.front(); que.pop();\n\n    if(dist[p][s] >= N/2){\n      break;\n    }\n\n    for(int i = 0 ; i < N-1 ; i++){\n      for(int j = i + 1 ; j < N ; j++){\n\tVec next = s;\n\treverse(next.begin()+i, next.begin()+j+1);\n\n\tif(!dist[p].count(next)){\n\t  dist[p][next] = dist[p][s] + 1;\n\t  que.push(next);\n\t} \n      }\n    }\n  }\n}\n\nint main(){\n  Vec start, goal;\n\n  cin >> N;\n  start.resize(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> start[i];\n    goal.push_back(i+1);\n  }\n\n  bfs(0,start); bfs(1,goal);\n  map<Vec,int>::iterator it, val;\n  \n  int min = INF;\n  for(it = dist[0].begin() ; it != dist[0].end() ; ++it){\n    val = dist[1].find(it->first);\n    if(val != dist[1].end()){\n      min = std::min(min, it->second+val->second);\n    }    \n  }\n  cout << min << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nmap<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n\n  memo[idx][Vtoll(s)]=0;\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+2;j<=n;j++){\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\t\n\tif(memo[idx].count(Vtoll(nS))) continue;\n\tmemo[idx][Vtoll(nS)]=cost+1;\n\t\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n  \n  d=(n-1)/2;\n  \n  idx=0;\n  \n  bfs(A);\n  \n  d=(n-1)/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n  \n  map<ll,int>::iterator ite=memo[0].begin();\n\n  while(ite!=memo[0].end()){\n    \n    if(memo[1].count((*ite).first))\n      ans=min(ans,(*ite).second+memo[1][(*ite).first]);\n    \n    ite++;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n/*\n\nSAK\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Node {\n\tvector<int> v;\n\tint prev;\n};\n//bool operator >(const Node& n1, const Node& n2) {\n//\treturn n1.step > n2.step;\n//}\n\nint main() {\n\tint N; cin >> N;\n\n\tvector<int> v(N);\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tcin >> v[i];\n\t}\n\n\tvector<int> g = v;\n\tsort(g.begin(), g.end());\n\n\tset< vector<int> > s;\n\tqueue<Node> Q[10]; Q[0].push( (Node){v, -1} );\n\tfor (int step = 0; step < N; ++step) {\n\t\twhile ( !Q[step].empty() ) {\n\t\t\tNode node = Q[step].front(); Q[step].pop();\n\t\t\tvector<int>& v = node.v;\n\t\t\tint prev = node.prev;\n\n\t\t\tif (s.find(v) != s.end()) continue;\n\t\t\ts.insert(v);\n\n\t\t\tif (v == g) {\n\t\t\t\tcout << step << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (step+1 < N) {\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\tfor (int j = i+1; j < N; ++j) {\n\t\t\t\t\t\tif (i*N+j > prev) {\n\t\t\t\t\t\t\tvector<int> nv = v;\n\t\t\t\t\t\t\treverse(nv.begin()+i, nv.begin()+j+1);\n\t\t\t\t\t\t\tQ[step+1].push( (Node){ nv, i*N+j } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nmap<vector<int>, int> bfs(const vector<int>& s)\n{\n    const int n = s.size();\n\n    map<vector<int>, int> d;\n    queue<vector<int> > q;\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty())\n    {\n        vector<int> a = q.front();\n        q.pop();\n        \n        int c = d[a];\n        if (c >= (n - 1) / 2)\n            break;\n\n        rep(j, n) rep(i, j)\n        {\n            vector<int> na = a;\n            reverse(na.begin() + i, na.begin() + j + 1);\n            if (!d.count(na))\n            {\n                d[na] = c + 1;\n                q.push(na);\n            }\n        }\n    }\n\n    return d;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> s(n);\n    input(s, n);\n\n    vector<int> g(n);\n    rep(i, n)\n        g[i] = i + 1;\n\n    map<vector<int>, int> from_s = bfs(s), from_g = bfs(g);\n    int res = n - 1;\n    foreach (it, from_s)\n        if (from_g.count(it->first))\n            chmin(res, it->second + from_g[it->first]);\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int ten[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};\n\nlong long int coder(vector<int> &vec){\n\tlong long int res=0;\n\tfor(int i=0;i<vec.size();i++){\n\t\tres*=10;\n\t\tres+=vec[i];\n\t}\n\treturn res;\n}\n\nlong long int get(long long int val,int level){\n\treturn (val/ten[level])%10;\n}\n\nvoid swapp(long long int &val,int lhs,int rhs){\n\tint lval=get(val,lhs);\n\tint rval=get(val,rhs);\n\tval=val-(lval*ten[lhs]+rval*ten[rhs])+(lval*ten[rhs]+rval*ten[lhs]);\n\treturn;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\tvector<int> object(n);\n\tiota(object.begin(),object.end(),0);\n\tlong long int ob=coder(object);\n\tmap<long long int,int> dp[2];\n\tfor(int loop=0;loop<2;loop++){\n\t\tlong long int first;\n\t\tif(loop==0) first=coder(a);\n\t\telse first=ob;\n\t\tdp[loop][first]=0;\n\t\tqueue<pair<long long int,int>> q;\n\t\tq.push(make_pair(first,0));\n\t\twhile(!q.empty()){\n\t\t\tauto state=q.front();\n\t\t\tq.pop();\n\t\t\tif(state.second>=4) continue;\n\t\t\t\n\t\t\t//odd\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tauto b=state.first;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//else\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tauto b=state.first;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j+1<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j+1);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n\tint res=9;\n\tfor(auto it=dp[0].begin();it!=dp[0].end();it++){\n\t\tif(!(dp[1].count(it->first))) continue;\n\t\tres=min(res,(it->second)+(dp[1].find(it->first)->second));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tif(dist[ma[v]]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tif(dist[ma[uv]]==-1){\n\t\t\t\t\tdist[ma[uv]]=dist[ma[v]]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[ma[uv]]){\n\t\t\t\t\tres=min(res,dist[ma[v]]+dist[ma[uv]]+1);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[lv];\n\t\tif(dist[lv]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconstexpr int INF = numeric_limits<int>::max() / 2;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    vector<int> a(N), gt(N);\n    for (int i = 0; i < N; i++)\n    {\n        cin >> a[i];\n        gt[i] = i + 1;\n    }\n    map<vector<int>, int> dist, rdist;\n    queue<vector<int>> que;\n    dist[a] = 0;\n    que.push(a);\n    while (!que.empty())\n    {\n        auto v = que.front();\n        que.pop();\n        if (dist[v] >= 4)\n            continue;\n        /*\n        int sx = 0, gx = N - 1;\n        while (v[sx] == sx + 1)\n            sx++;\n        while (v[gx] == gx + 1)\n            gx--;\n        */\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i + 1; j < N; j++)\n            {\n                auto v2 = v;\n                reverse(v2.begin() + i, v2.begin() + j + 1);\n                if (dist.find(v2) != dist.end())\n                    continue;\n                dist[v2] = dist[v] + 1;\n                que.push(v2);\n            }\n        }\n    }\n    rdist[gt] = 0;\n    que.push(gt);\n    while (!que.empty())\n    {\n        auto v = que.front();\n        que.pop();\n        if (rdist[v] >= 4)\n            continue;\n        /*\n        int sx = 0, gx = N - 1;\n        while (v[sx] == sx + 1)\n            sx++;\n        while (v[gx] == gx + 1)\n            gx--;\n        */\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = i + 1; j < N; j++)\n            {\n                auto v2 = v;\n                reverse(v2.begin() + i, v2.begin() + j + 1);\n                if (rdist.find(v2) != rdist.end())\n                    continue;\n                rdist[v2] = rdist[v] + 1;\n                que.push(v2);\n            }\n        }\n    }\n    int ret = 9;\n    for (const auto &v : dist)\n    {\n        if (rdist.find(v.first) != rdist.end())\n            ret = min(ret, dist[v.first] + rdist[v.first]);\n    }\n    cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \nint bfs(vector<char> v)\n{\n    map<vector<char>, char> D; D[v] = 1;\n \n    vector<char> sorted = v; sort(sorted.begin(), sorted.end());\n \n    queue<pair<vector<char>, char> > que; que.push(make_pair(v, 1));\n \n    if (v == sorted) { return 0; }\n \n    while (!que.empty())\n    {\n        pair<vector<char>, char> p1 = que.front(); que.pop();\n \n        for (char i = 0; i < v.size(); i++)\n        {\n            for (char j = i + 1; j < v.size(); j++)\n            {\n                vector<char> p2 = p1.first;\n \n                swap(p2[i], p2[j]);\n \n                if (D[p2] == 0)\n                {\n                    if (p2 == sorted)\n                    {\n                        return p1.second;\n                    }\n \n                    D[p2] = p1.second + 1;\n \n                    que.push(make_pair(p2, p1.second + 1));\n                }\n            }\n        }\n    }\n \n    return -1;\n}\n \nint main()\n{\n    int n, d; vector<char> a;\n \n    cin >> n; a = vector<char>(n);\n \n    for (int i = 0; i < n; i++)\n    {\n        cin >> d; a[i] = d;\n    }\n \n    cout << bfs(a) << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<vector<int>,int>P;\nint n,x,co;\nvector<int>v;\nmap<long long,int>M1;\nset<long long >s;\nlong long has(vector<int> &g){\n  long long res=0;\n  r(i,n){\n    if(g[i]!=10)res=res*10+g[i];\n    if(g[i]==10)res*=10;\n  }\n  return res;\n}\nvoid bfs1(){\n  queue<P>q;\n  q.push(P(v,0));\n  s.insert(has(v));\n  while(!q.empty()){\n    vector<int> g=q.front().first;\n    int cost=q.front().second,c=0;q.pop();\n    r(i,n-1)if(g[i]>g[i+1])c++;\n    if(!c){\n      cout<<cost<<endl;\n      exit(0);\n    }\n    M1[has(g)]=cost;\n    if(cost==4)continue;\n    for(int i=2;i<=n;i++){\n      for(int j=0;j+i<=n;j++){\n        vector<int>t=g;\n        for(int k=j,l=0;l<i/2;l++,k++){\n          swap(t[k],t[j+i-1-l]);\n        }\n        int T=has(t);\n        if(!s.count(T)){\n          s.insert(T);\n          q.push(P(t,cost+1));\n        }\n      }\n    }\n  }\n}\nvoid bfs2(){\n  queue<P>q;\n  q.push(P(v,0));\n  s.insert(has(v));\n  while(!q.empty()){\n    vector<int> g=q.front().first;\n    int cost=q.front().second,c=0;q.pop();\n    if(M1[has(g)]){cout<<1<<endl;\n      cout<<cost+M1[has(g)]<<endl;\n      exit(0);\n    }\n    if(cost==5)continue;\n    for(int i=2;i<=n;i++){\n      for(int j=0;j+i<=n;j++){\n        vector<int>t=g;\n        for(int k=j,l=0;l<i/2;l++,k++){\n          swap(t[k],t[j+i-1-l]);\n        }\n        int T=has(t);\n        if(!s.count(T)){\n          s.insert(T);\n          q.push(P(t,cost+1));\n        }\n      }\n    }\n  }\n}\nint main(){\n  cin>>n;\n  r(i,n){\n    cin>>x;\n    v.push_back(x);\n  }\n  bfs1();\n  r(i,n)v[i]=i+1;\n  bfs2();\n  cout<<9<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nshort N;\n\nstruct Array{\n\tshort a[10], d;\n\tArray(){}\n\tbool operator==(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn d < obj.d;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, short dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(short i = 0; i < N; i++){\n\t\tfor(short j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(short k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(short k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(short i = 0; i < N; i++) cin >> A.a[i];\n\tfor(short i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\tvec2.erase(unique(vec2.begin(), vec2.end()), vec2.end());\n\t\n\tshort ans = N-1;\n\tArray tmp;\n\tfor(short i = 0; i < vec.size(); i++){\n\t\ttmp = vec[i]; tmp.d = 0;\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), tmp);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, (short)(p->d + vec[i].d));\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\t\n\t/*for(int i = 0; i < vec2.size(); i++){\n\t\tfor(int j = 0; j < N; j++) cout << vec2[i].a[j] << \" \"; \n\t\tcout << vec2[i].d << endl;\n\t}*/\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n\nvector<int> A, B;\n\nmap<vector<int>, int> dp;\n\nint dfs(vector<int> C, int n)\n{\n\tif (C == B) { return n; }\n\n\tif (dp[C] == 0)\n\t{\n\t\tdp[C] = n + 1;\n\t}\n\telse\n\t{\n\t\tif (dp[C] <= n)\n\t\t{\n\t\t\treturn dp[C];\n\t\t}\n\t}\n\n\tint min_ = N;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tvector<int> D; D = C;\n\n\t\t\t\tswap(D[i], D[j]);\n\n\t\t\t\tmin_ = min(dfs(D, n + 1), min_);\n\t\t\t}\n\t\t}\n\t}\n\n\tdp[C] = min_;\n\n\treturn min_;\n}\n\nint main()\n{\n\tcin >> N;\n\n\tA = vector<int>(N);\n\tB = vector<int>(N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\n\tfor (int i = 0; i < N; i++) { B[i] = A[i]; }\n\n\tsort(B.begin(), B.end());\n\n\tcout << dfs(A, 0) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n    string init(n, ' ');\n    for(int i=0; i<n; ++i){\n        int a;\n        cin >> a;\n        init[i] = '0' + a - 1;\n    }\n\n    string goal(n, ' ');\n    for(int i=0; i<n; ++i)\n        goal[i] = '0' + i;\n    if(init == goal){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    vector<set<string> > history(2);\n    history[0].insert(init);\n    history[1].insert(goal);\n    vector<queue<string> > q(2);\n    q[0].push(init);\n    q[1].push(goal);\n\n    int ret = 1;\n    for(int k=0; ; k=(k+1)%2){\n        int m = q[k].size();\n        while(--m >= 0){\n            string s = q[k].front();\n            q[k].pop();\n\n            for(int i=0; i<n; ++i){\n                for(int j=i+1; j<n; ++j){\n                    string t = s;\n                    reverse(t.begin()+i, t.begin()+j+1);\n\n                    if(history[k^1].find(t) != history[k^1].end()){\n                        cout << ret << endl;\n                        return 0;\n                    }\n\n                    if(history[k].find(t) == history[k].end()){\n                        history[k].insert(t);\n                        q[k].push(t);\n                    }\n                }\n            }\n        }\n        ++ ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 10;\nconst int INF = 1 << 29;\n\nstruct state{\n  lli num;\n  int cnt;\n  state(lli num=0, int cnt=0):num(num),cnt(cnt){}\n};\n\nint n;\nlli pow10[11];\nvector<int> v;\n\nlli hash(const vector<int> &vec){\n  lli res = 0, di = 1;\n  \n  for(int i=vec.size()-1;i>=0;i--){\n    res += vec[i] * di;\n    di *= 10;\n  }\n\n  return res;\n}\n\nlli reverse(lli num, int begin, int end){\n  lli res = num;\n  lli powbe = pow10[begin], powen = pow10[end];\n\n  for(int i=0;i<(end-begin+1)/2;i++){\n    res += powbe * (num / powen % 10 - num / powbe % 10);\n    res += powen * (num / powbe % 10 - num / powen % 10);\n    powbe *= 10;\n    powen /= 10;\n  }\n  \n  return res;\n}\n\nint bfs(lli num, map<lli, int> mp[2], int mp_pos){\n  int res = INF;\n  queue<state> q;\n  state u, u2;\n\n  mp[mp_pos][num] = 0;\n\n  for(q.push(state(num, 0)); !q.empty();){\n    u = q.front();\n    q.pop();\n\n    if(mp_pos == 1 && mp[0].count(u.num)) res = min(res, mp[0][u.num] + u.cnt);\n    if(mp_pos == 0 && u.cnt >= 4 || u.cnt >= 5) continue;\n\n    for(int i=0;i<n-1;i++){\n      for(int j=i+1;j<n;j++){\n        u2 = state(reverse(u.num, i, j), u.cnt + 1);\n        if(!mp[mp_pos].count(u2.num)){\n          mp[mp_pos][u2.num] = u2.cnt;\n          q.push(u2);\n        }\n      }\n    }\n  }\n\n  return res;\n}\n\nint solve(){  \n  vector<int> w = v;\n  map<lli, int> mp[2];\n\n  sort(w.begin(), w.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(v[i] == w[j]) {\n        v[i] = j;\n        break;\n      }\n    }\n  }\n\n  w = v;\n  sort(w.begin(), w.end());\n\n  bfs(hash(w), mp, 0);\n  return bfs(hash(v), mp, 1);\n}\n\nint main(){\n  pow10[0] = 1;\n  for(int i=1;i<11;i++) pow10[i] = pow10[i-1] * 10;\n\n  while(cin >> n){\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    \n    cin >> N;\n    \n    vector<int> A(N);\n    \n    for(int i = 0; i < N; i++) { cin >> A[i]; }\n    \n    vector<int> B = A; sort(B.begin(), B.end());\n    \n    map<vector<int>, bool> dat; dat[A] = true;\n    \n    queue<vector<int> > que; que.push(A);\n    \n    queue<int> que2; que2.push(0);\n    \n    if(A == B) { cout << 0 << endl; goto Exit; }\n    \n    while(que.size())\n    {\n        vector<int> v1 = que.front(); que.pop();\n        \n        int dist = que2.front(); que2.pop();\n        \n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                vector<int> v2 = v1;\n                \n                swap(v2[i], v2[j]);\n                \n                if(v2 == B) { cout <<  dist + 1 << endl; goto Exit; }\n                \n                if(dat[v2] == false)\n                {\n                    dat[v2] = true;\n                    \n                    que.push(v2);\n                    \n                    que2.push(dist + 1);\n                }\n            }\n        }\n    }\n    \n    Exit:;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\n#define show(x) cerr << #x << \" = \" << x << endl;\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const set<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n{\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"}\\n\";\n    return os;\n}\n\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    vector<int> S(N);\n    for (int i = 0; i < N; i++) {\n        S[i] = i + 1;\n    }\n\n    constexpr int MAX = 10;\n    constexpr int HALF = (MAX - 1) / 2;\n\n    vector<set<vector<int>>> former(HALF + 1);\n    vector<set<vector<int>>> latter(HALF + 1);\n    former[0].insert(A);\n    latter[0].insert(S);\n\n    for (int i = 0; i < HALF; i++) {\n        for (const auto& V : former[i]) {\n            for (int l = 0; l < N - 1; l++) {\n                for (int r = l + 1; r < N; r++) {\n                    auto v = V;\n                    for (int k = 0; k < (r - l + 1) / 2; k++) {\n                        swap(v[l + k], v[r - k]);\n                    }\n                    former[i + 1].insert(v);\n                }\n            }\n        }\n        for (const auto& V : latter[i]) {\n            for (int l = 0; l < N - 1; l++) {\n                for (int r = l + 1; r < N; r++) {\n                    auto v = V;\n                    for (int k = 0; k < (r - l + 1) / 2; k++) {\n                        swap(v[l + k], v[r - k]);\n                    }\n                    latter[i + 1].insert(v);\n                }\n            }\n        }\n    }\n\n    //    show(former);\n\n    for (int i = 0; i < N - 1; i++) {\n        if (i <= HALF) {\n            if (former[i].find(S) != former[i].end()) {\n                cout << i << endl;\n                return 0;\n            }\n        } else {\n            const int res = i - HALF;\n            for (const auto& v : latter[res]) {\n                if (former[HALF].find(v) != former[HALF].end()) {\n                    cout << i << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << N - 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\nint main() {\n\tlong long int N;\n\tcin >> N;\n\tvector<long long int>D( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> D[i];\n\t\tD[i]--;\n\t}\n\tmap<vector<long long int>, long long int>memo;\n\tqueue<vector<long long int>>que;\n\tque.push( D );\n\n\tsort( D.begin(), D.end() );\n\twhile( que.size() && memo.count( D ) == 0 ) {\n\t\tauto now = que.front(); que.pop();\n\n\t\tbool f = true;\n\t\tfor( size_t i = 0; i < N&&memo.count( D ) == 0; i++ ) {\n\t\t\tif( now[i] == i  && f ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf = false;\n\t\t\tbool g = true;\n\t\t\tfor( size_t j = N - 1; j > i; j-- ) {\n\t\t\t\tif( g&&now[j] == j ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tg = false;\n\t\t\t\tauto next = now;\n\t\t\t\treverse( next.begin() + i, next.begin() + j + 1 );\n\t\t\t\tif( !memo.count( next ) ) {\n\t\t\t\t\tmemo[next] = memo[now] + 1;\n\t\t\t\t\tif( next == D ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << memo[D] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct S{\n  vector<int> v;\n  int c,d,e;\n  S(const vector<int> &pv,int pc):v(pv),c(pc){\n    eval();\n  }\n  void eval(){\n    d=0;\n    for(int i=0;i<v.size()-1;i++){\n      d+=abs(v[i]-v[i+1])>1;\n    }\n    e=c+(d+1)/2;\n  }   \n  void reverse(int a,int b){\n    c++;\n    std::reverse(begin(v)+a,begin(v)+b+1);\n    eval();\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n \nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  map<vector<int>,int> m;\n  for(;;){\n    S c=que.top();\n    if(is_sorted(begin(c.v),end(c.v)))break;\n    que.pop();\n    if(m.count(c.v)&&m[c.v]<=c.c)continue;\n    m[c.v]=c.c;\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tS n=c;\n\tn.reverse(i,j);\n\tque.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    \n    cin >> N;\n    \n    vector<int> A(N);\n    \n    for(int i = 0; i < N; i++) { cin >> A[i]; }\n    \n    vector<int> B = A; sort(B.begin(), B.end());\n    \n    set<vector<int> > dat; dat.insert(A);\n    \n    queue<vector<int> > que; que.push(A);\n    \n    queue<int> que2; que2.push(0);\n    \n    while(que.size())\n    {\n        vector<int> v1 = que.front(); que.pop();\n        \n        int dist = que2.front(); que2.pop();\n        \n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                vector<int> v2 = v1;\n                \n                swap(v2[i], v2[j]);\n                \n                if(v2 == B) { cout <<  dist + 1 << endl; goto Exit; }\n                \n                if(dat.find(v2) == dat.end())\n                {\n                    dat.insert(v2);\n                    \n                    que.push(v2);\n                    \n                    que2.push(dist + 1);\n                }\n            }\n        }\n    }\n    \n    Exit:;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring a;\n\nint solve();\nmap<string, int> calc(string &s);\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    a += '0' + x - 1;\n  }\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  string now;\n  for (int i = 0; i < n; ++i) now += '0' + i;\n  map<string, int> st = calc(now), go = calc(a);\n  int res = n - 1;\n  for (auto p : st)\n    if (go.find(p.first) != go.end()) res = min(res, p.second + go[p.first]);\n  return res;\n}\n\nmap<string, int> calc(string &s) {\n  map<string, int> mp;\n  mp[s] = 0;\n  queue<string> qu;\n  qu.push(s);\n  while (qu.size()) {\n    string now = qu.front();\n    int cos = mp[now];\n    if (cos >= (n - 1) / 2) break;\n    qu.pop();\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j) {\n        string to = now;\n        reverse(to.begin() + i, to.begin() + j + 1);\n        if (mp.find(to) == mp.end()) {\n          mp[to] = cos + 1;\n          qu.push(to);\n        }\n      }\n  }\n  return mp;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, int> P;\nlli n, in;\nvector<lli> input;\nmap<lli, int> data;\nset<lli> vis;\n\nlli rev(lli num, int a, int b){\n  string str;\n  while(num > 0){\n    str += (char)((int)(num % 10LL) + '0');\n    num /= 10LL;\n  }\n  if(str.size() != n) str = \"0\" + str;\n  reverse(str.begin(), str.end());\n  reverse(str.begin() + a, str.begin() + b + 1);\n  lli res = 0;\n  for(int i=0;i<str.size();i++){\n    res *= 10LL;\n    res += (lli)(str[i] - '0');\n  }\n  //return atoi(str.c_str());\n  return res;\n}\n\nint solve(){\n  lli state = 0;\n  for(int i=0;i<n;i++){\n    state *= 10;\n    if(input[i] != 10) state += input[i];\n  }\n  if(data.find(state) != data.end()) return data[state];\n  vis.clear();\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    if(data.find(u.first) != data.end()) return data[u.first] + u.second;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(vis.find(v.first) == vis.end()){\n          vis.insert(v.first);\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n  return 9;\n}\n\nvoid init(){\n  data.clear();\n  lli state = 0;\n  for(int i=1;i<=n;i++){\n    state *= 10;\n    if(i != 10) state += i;\n  }\n  P u = P(state, 0), v;\n  queue<P> q;\n  q.push(u);\n  data[state] = 0;\n  while(!q.empty()){\n    u = q.front();\n    q.pop();\n    //cout << u.first << ' ' << u.second << endl;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i == j) continue;\n        v = u;\n        v.second++;\n        v.first = rev(v.first, i, j);\n        if(data.find(v.first) == data.end()){\n          data[v.first] = v.second;\n          if(v.second < 4) q.push(v);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n){\n    input.clear();\n    for(int i=0;i<n;i++){\n      cin >> in;\n      input.push_back(in);\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nchar n; vector<char>a; queue<pair<vector<char>,char>>Q;\nvector<pair<vector<char>, char>>a1, a2;\nset<vector<char>>E;\nvoid init(vector<char>R, char Lim, char D) {\n\tQ.push(make_pair(R, 0)); E.clear(); E.insert(R);\n\twhile (!Q.empty()) {\n\t\tvector<char>H = Q.front().first; int L = Q.front().second; Q.pop();\n\t\tif (D == 0)a1.push_back(make_pair(H, L));\n\t\tif (D == 1)a2.push_back(make_pair(H, L));\n\t\tif (L == Lim)continue;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tvector<char>I = H; char Y = j;\n\t\t\t\tfor (int k = i; k <= (i + j) / 2; k++) {\n\t\t\t\t\tswap(I[k], I[Y]); Y--;\n\t\t\t\t}\n\t\t\t\tif (E.find(I) == E.end()) {\n\t\t\t\t\tQ.push(make_pair(I, L + 1));\n\t\t\t\t\tE.insert(I);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n; for (int i = 0; i < n; i++) { char p; cin >> p; a.push_back(p); }\n\tchar pos = n / 2; char pos2 = (n - 1) / 2; init(a, pos, 0); vector<char>Zero;\n\tfor (int i = 0; i < n; i++)Zero.push_back(i + 1); init(Zero, pos2, 1);\n\tsort(a1.begin(), a1.end()); sort(a2.begin(), a2.end());\n\tint ret = n - 1;\n\tfor (int i = 0; i < a1.size(); i++) {\n\t\tint S1 = lower_bound(a2.begin(), a2.end(), make_pair(a1[i].first, (char)0)) - a2.begin();\n\t\tint S2 = upper_bound(a2.begin(), a2.end(), make_pair(a1[i].first, pos)) - a2.begin();\n\t\tfor (int j = S1; j < S2; j++) ret = min(ret, a1[i].second + a2[j].second);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=3628800;\nint n;\n\nint g(vi a){\n\tint res=0,tmp=1;\n\tfor(int i=n-2;i>=0;i--){\n\t\tint cnt=0;\n\t\tfor(int j=i+1;j<n;j++) if(a[i]>a[j]) cnt++;\n\t\tres+=cnt*tmp;\n\t\ttmp*=n-i;\n\t}\n\treturn res;\n}\n\nvi a;\n\nvi f(){\n\tqueue<pair<vi,int>> q;\n\tq.push(make_pair(a,0));\n\tvi dis(M,inf);\n\tdis[g(a)]=0;\n\twhile(!q.empty()){\n\t\tauto p=q.front();q.pop();\n\t\tvi b=p.first;\n\t\tint d=p.second;\n\t\tfor(int i=0;i<n;i++) for(int j=i+2;j<=n;j++){\n\t\t\treverse(b.begin()+i,b.begin()+j);\n\t\t\tint id=g(b);\n\t\t\tif(dis[id]==inf){\n\t\t\t\tdis[id]=d+1;\n\t\t\t\tif(d+1<4){\n\t\t\t\t\tq.push(make_pair(b,d+1));\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(b.begin()+i,b.begin()+j);\n\t\t}\n\t}\n\treturn dis;\n}\n\nint main(){\n\tcin>>n;\n\ta=vi(n);\n\tfor(auto &i:a) cin>>i;\n\tvi b=f();\n\tsort(a.begin(),a.end());\n\tvi c=f();\n\tint res=9;\n\tfor(int i=0;i<M;i++) res=min(res,b[i]+c[i]);\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/06/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int SIZE = 3628810;\ntypedef pair< vector<int>, int > Pack;\n\nint getPermId(const vector<int>& v){\n    const int N = (int)v.size();\n    \n    int fact = 1;\n    int res = 0;\n    \n    for(int i=N-1;i>=0;i--){\n        for(int j=i+1;j<N;j++){\n            if(v[j] < v[i]){\n                res += fact;\n            }\n        }\n        fact *= (N - i);\n    }\n    \n    return res;\n}\n\nint dist[2][SIZE];\nvector<Pack> Queue[2];\n\nint bfs(const vector<int>& start, const vector<int>& goal){\n    memset(dist, -1, sizeof(dist));\n    \n    const int N = (int)start.size();\n    const int startId = getPermId(start);\n    const int goalId  = getPermId(goal);\n    \n    if(startId == goalId){\n        return 0;\n    }\n    \n    int curr = 0, next = 1;\n    \n    dist[curr][startId] = 0;\n    dist[next][goalId]  = 0;\n    \n    Queue[curr].push_back(make_pair(start, startId));\n    Queue[next].push_back(make_pair(goal,  goalId));\n    \n    for(;;){\n        vector<Pack> nextQueue;\n        for(int i=0;i<Queue[curr].size();i++){\n            Pack pack = Queue[curr][i];\n            \n            vector<int> perm = pack.first;\n            int permId = pack.second;\n            int nowCost = dist[curr][permId];\n            \n            for(int s=0;s<N;s++)for(int t=s+1;t<N;t++){\n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            \n                int nextPermId = getPermId(perm);\n                if(dist[curr][nextPermId] == -1){\n                    dist[curr][nextPermId] = nowCost + 1;\n                    nextQueue.push_back(make_pair(perm, nextPermId));\n                \n                \n                    if(dist[next][nextPermId] != -1){\n                        return dist[curr][nextPermId] + dist[next][nextPermId];\n                    }\n                }\n                \n                reverse(perm.begin() + s, perm.begin() + t + 1);\n            }\n        }\n        Queue[curr].swap(nextQueue);\n        \n        swap(curr, next);\n    }\n    \n    return 1;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    \n    vector<int> start(N);\n    for(int i=0;i<N;i++){\n        cin >> start[i];\n        --start[i];\n    }\n    \n    vector<int> goal = start;\n    sort(goal.begin(), goal.end());\n    \n    int res = bfs(start, goal);\n    cout << res << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(ll arg_number,int arg_swap_count){\n\t\tnumber = arg_number;\n\t\tswap_count = arg_swap_count;\n\t}\n\n\tll number;\n\tint swap_count;\n};\n\n\nint N,ans;\nll sorted_num;\nmap<ll,int> MAP,rev_MAP;\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tll first = 0,array[10],before[10],order[10];\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&array[i]);\n\t\tbefore[i] = array[i];\n\t}\n\n\tsort(array,array+N);\n\torder[0] = 0;\n\tfor(int i = 1; i < N; i++){\n\t\tif(array[i] != array[i-1]){\n\t\t\torder[i] = order[i-1]+1;\n\t\t}else{\n\t\t\torder[i] = order[i-1];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(before[i] == array[k]){\n\t\t\t\tfirst = 10*first+order[k];\n\t\t\t}\n\t\t}\n\t}\n\n\tsorted_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tsorted_num = 10*sorted_num+order[i];\n\t}\n\n\tif(first == sorted_num){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tMAP[sorted_num] = N-1;\n\n\tqueue<Info> Q;\n\n\tll calc_array[10],work[10],tmp,next_number;\n\tint swap_count,index;\n\tstack<ll> S;\n\n\tQ.push(Info(first,0));\n\n\tans = N-1;\n\n\twhile(!Q.empty()){\n\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){\n\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){\n\t\t\t\t\tMAP[next_number] = swap_count+1;\n\t\t\t\t}else{\n\t\t\t\t\tif(next_number != sorted_num){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(next_number == sorted_num){\n\t\t\t\t\tans = min(ans,swap_count+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(swap_count <= 2){\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tQ.push(Info(sorted_num,0));\n\trev_MAP[sorted_num] = 0;\n\n\twhile(!Q.empty()){\n\n\t\ttmp = Q.front().number;\n\t\tswap_count = Q.front().swap_count;\n\t\tQ.pop();\n\n\t\tif(swap_count+1 >= ans)continue;\n\n\t\twhile(tmp > 0){\n\t\t\tS.push(tmp%10);\n\t\t\ttmp /= 10;\n\t\t}\n\n\t\tindex = 0;\n\t\twhile(!S.empty()){\n\n\t\t\tcalc_array[index++] = S.top();\n\t\t\tS.pop();\n\t\t}\n\n\t\tif(index < N){\n\t\t\tfor(int i = index-1; i >=0; i--){\n\t\t\t\tcalc_array[i+(N-index)] = calc_array[i];\n\t\t\t}\n\t\t\tfor(int i = 0; i < N-index; i++){\n\t\t\t\tcalc_array[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < N-1; i++){\n\t\t\tfor(int k = i+1; k < N; k++){\n\t\t\t\tfor(int p = 0; p < N; p++)work[p] = calc_array[p];\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tif(i+p >= k-p)break;\n\t\t\t\t\tswap(work[i+p],work[k-p]);\n\t\t\t\t}\n\n\t\t\t\tnext_number = 0;\n\t\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\t\tnext_number = 10*next_number + work[p];\n\t\t\t\t}\n\n\t\t\t\tauto at = rev_MAP.find(next_number);\n\t\t\t\tif(at != rev_MAP.end())continue;\n\t\t\t\trev_MAP[next_number] = swap_count+1;\n\n\t\t\t\tat = MAP.find(next_number);\n\n\t\t\t\tif(at == MAP.end()){\n\t\t\t\t\tif(swap_count <= 3){\n\t\t\t\t\t\tQ.push(Info(next_number,swap_count+1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tans = min(ans,swap_count+MAP[next_number]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nint n;\nll perm[11];\nint dist[4000000];\nbool check[4000000];\nmap<ll,int> ma;\n\nvoid permutation2(){\n\tfor(int i=0;i<n;i++){\n\t\tperm[i]=i;\n\t}\n\tint j=0;\n\tdo{\n\t\tll d=0;\n\t\tll p=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\td+=perm[i]*p;\n\t\t\tp*=10LL;\n\t\t}\n\t\tma[d]=j;\n\t\tj++;\n\t}while(next_permutation(perm,perm+n));\n}\n\n\nint a[11];\nll tmp[11];\nll ten[11];\n\nint bfs2(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tdist[ma[s]]=0;\n\tint res=n-1;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tif(dist[ma[v]]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tif(dist[ma[uv]]==-1){\n\t\t\t\t\tdist[ma[uv]]=dist[ma[v]]+1;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}else if(check[ma[uv]]){\n\t\t\t\t\tres=min(res,dist[ma[v]]+dist[ma[uv]]+1);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(ll s){\n\tqueue<ll> que;\n\tque.push(s);\n\tmemset(dist,-1,sizeof(dist));\n\tmemset(check,false,sizeof(check));\n\tdist[ma[s]]=0;\n\tcheck[ma[s]]=true;\n\twhile(que.size()){\n\t\tll v=que.front();\n\t\tque.pop();\n\t\tint lv=ma[v];\n\t\tif(lv==0)return dist[v];\n\t\tif(dist[lv]==5)continue;\n\t\tll nv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ttmp[i]=nv%10LL;\n\t\t\tnv/=10LL;\n\t\t}\n\t\tll dv=v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tll uv=dv;\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tuv+=tmp[i+k]*(ten[j-k]-ten[i+k])+tmp[j-k]*(ten[i+k]-ten[j-k]);\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t\tint nexv=ma[uv];\n\t\t\t\tif(dist[nexv]==-1){\n\t\t\t\t\tdist[nexv]=dist[lv]+1;\n\t\t\t\t\tcheck[nexv]=true;\n\t\t\t\t\tque.push(uv);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;i+k<j-k;k++){\n\t\t\t\t\tswap(tmp[i+k],tmp[j-k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\ta[i]--;\n\t}\n\tll s=0;\n\tll p=1;\n\tfor(int i=0;i<n;i++){\n\t\ts+=(ll)p*a[i];\n\t\tten[i]=p;\n\t\tp*=10LL;\n\t}\n\tpermutation2();\n\tint re=bfs(s);\n\tif(re!=-1)printf(\"%d\\n\",re);\n\telse{\n\t\tsort(a,a+n);\n\t\ts=0;\n\t\tp=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts+=(ll)p*a[i];\n\t\t\tp*=10LL;\n\t\t}\n\t\tprintf(\"%d\\n\",bfs2(s));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//-O2 is required.\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\ntypedef vector<int> V;\nmap<V,int>m;\n//map<V,pair<pair<int,int>,V> >track;\n//V v1,v2;\npair<int,int>vec2nvec;\nint bfs(V &v, int back){\n\tif(!back&&m.find(v)!=m.end()){\n\t\t//v1.clear();\n\t\t//vec2nvec=make_pair(0,0);\n\t\t//v2=v;\n\t\treturn m[v];\n\t}\n\tset<V>s;\n\tqueue<pair<V,int> >q;\n\tif(back)m[v]=0;\n\ts.insert(v);\n\tint i,j;\n\tfor(q.push(make_pair(v,0));!q.empty();){\n\t\tV vec=q.front().first;\n\t\tint depth=q.front().second;\n\t\tq.pop();\n\t\tif(back&&depth>3)return 0;\n\t\tfor(i=0;i<vec.size();i++)\n\t\t\tfor(j=i+1;j<vec.size();j++){\n\t\t\t\tV nvec=vec;\n\t\t\t\treverse(nvec.begin()+i,nvec.begin()+j+1);\n\t\t\t\tif(!back&&m.find(nvec)!=m.end()){\n\t\t\t\t\t//v1=vec;\n\t\t\t\t\t//vec2nvec=make_pair(i,j);\n\t\t\t\t\t//v2=nvec;\n\t\t\t\t\treturn depth+1+m[nvec];\n\t\t\t\t}\n\t\t\t\tif(!s.insert(nvec).second)continue;\n\t\t\t\tif(back)m[nvec]=depth+1;\n\t\t\t\t//track[nvec]=make_pair(make_pair(i,j),vec);\n\t\t\t\tq.push(make_pair(nvec,depth+1));\n\t\t\t}\n\t}\n\treturn 0;\n}\n//void backtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tbacktrack(track[v].second);\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//}\n//void forwardtrack(V &v){\n//\tif(track.find(v)==track.end())return;\n//\tprintf(\"%d %d\\n\",track[v].first.first+1,track[v].first.second+1);\n//\tbacktrack(track[v].second);\n//}\nmain(){\n\tV prob;\n\tint i=0,t,n;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tif(scanf(\"%d\",&t)==-1)return 0;\n\t\tprob.push_back(t);\n\t}\n\tV goal=prob;\n\tsort(goal.begin(),goal.end());\n\tbfs(goal,1);\n\tprintf(\"%d\\n\",bfs(prob,0));\n\t//backtrack(v1);\n\t//if(vec2nvec.first!=vec2nvec.second)printf(\"%d %d\\n\",vec2nvec.first+1,vec2nvec.second+1);\n\t//forwardtrack(v2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int ten[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};\n\nlong long int coder(vector<int> &vec){\n\tlong long int res=0;\n\tfor(int i=0;i<vec.size();i++){\n\t\tres*=10;\n\t\tres+=vec[i];\n\t}\n\treturn res;\n}\n\nlong long int get(long long int val,int level){\n\treturn (val/ten[level])%10;\n}\n\nvoid swapp(long long int &val,int lhs,int rhs){\n\tint lval=get(val,lhs);\n\tint rval=get(val,rhs);\n\tval=val-(lval*ten[lhs]+rval*ten[rhs])+(lval*ten[rhs]+rval*ten[lhs]);\n\treturn;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<int> a(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\ta[i]--;\n\t}\n\tvector<int> object(n);\n\tiota(object.begin(),object.end(),0);\n\tlong long int ob=coder(object);\n\tmap<long long int,int> dp[2];\n\tfor(int loop=0;loop<2;loop++){\n\t\tlong long int first;\n\t\tif(loop==0) first=coder(a);\n\t\telse first=ob;\n\t\tdp[loop][first]=0;\n\t\tqueue<pair<long long int,int>> q;\n\t\tq.push(make_pair(first,0));\n\t\twhile(!q.empty()){\n\t\t\tauto state=q.front();\n\t\t\tq.pop();\n\t\t\tif(state.second>=4) continue;\n\t\t\t\n\t\t\t//odd\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tauto b=state.first;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//else\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tauto b=first;\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(!(0<=i-j && i+j+1<n)) break;\n\t\t\t\t\tswapp(b,i-j,i+j+1);\n\t\t\t\t\tif(!dp[loop].count(b)){\n\t\t\t\t\t\tdp[loop][b]=state.second+1;\n\t\t\t\t\t\tq.push(make_pair(b,state.second+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n\tint res=9;\n\tfor(auto it=dp[0].begin();it!=dp[0].end();it++){\n\t\tif(!(dp[1].count(it->first))) continue;\n\t\tres=min(res,(it->second)+(dp[1].find(it->first)->second));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nset<ll> memo1[10],memo2[10];\nset<ll> memo;\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n\n    if(memo.count(Vtoll(S))) continue;\n    memo.insert(Vtoll(S));\n    \n    if(!idx) memo1[cost].insert(Vtoll(S));\n    else memo2[cost].insert(Vtoll(S));\n\n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+1;j<=n;j++){\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n\n  d=n/2;\n  \n  idx=0;\n  \n  bfs(A);\n\n  memo.clear();\n  \n  d=n/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n\n  for(int i=0;i<10;i++){\n    \n    set<ll>::iterator ite=memo1[i].begin();\n\n    while(ite!=memo1[i].end()){\n\n      for(int j=0;j<10;j++)\n\tif(memo2[j].count(*ite)) ans=min(ans,i+j);\n      \n      ite++;\n    }\n    \n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nvector<int> v;\nmap<vector<int> ,int> d1;\nmap<vector<int> ,int> d2;\nint N;\nvector<int> sorted;\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int a;\n    cin>>a;\n    v.push_back(a);\n  }\n  sorted=v;\n  sort(v.begin(),v.end());\n  queue<vector<int> > q1,q2;\n  d1[v]=0;\n  d2[sorted]=0;\n  q1.push(v);\n  q2.push(sorted);\n  int ans=1<<30;\n  while(q1.size()||q2.size()){\n    {\n      vector<int> now=q1.front();q1.pop();\n      int ccost=d1[now];\n      if(now==sorted){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d2.count(nv)!=0&&d1.count(nv)==0){\n\t    ans=min(ans,ccost+1+d2[nv]);\n\t    //cout<<ccost+1+d2[nv]<<endl;\n\t    //return 0;\n\t  }\n\t  if(d1.count(nv)==0){\n\t    d1[nv]=ccost+1;\n\t    q1.push(nv);\n\t  }\n\t}\n      }\n    }\n    {\n      vector<int> now=q2.front();q2.pop();\n      int ccost=d2[now];\n      if(v==now){\n\tcout<<ccost<<endl;\n\treturn 0;\n      }\n      for(int i=0;i<N;i++){\n\tfor(int j=i+1;j<N;j++){\n\t  vector<int> nv=now;\n\t  reverse(nv.begin()+i,nv.begin()+j+1);\n\t  if(d1.count(nv)!=0&&d2.count(nv)==0){\n\t    ans=min(ans,ccost+1+d1[nv]);\n\t    // cout<<ccost+1+d1[nv]<<endl;\n\t    // return 0;\n\t  }\n\t  if(d2.count(nv)==0){\n\t    d2[nv]=ccost+1;\n\t    q2.push(nv);\n\t  }\n\t}\n      }\n    }\n    if(q1.size()&&q2.size()){\n      int sum=d1[q1.front()]+d2[q2.front()];\n      if(sum>ans)break;\n    }\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<unordered_map>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  char v[10];\n  int size;\n  int c,d,e;\n  long long b;\n  S(const vector<int> &pv,int pc):c(pc){\n    size=pv.size();\n    copy(begin(pv),end(pv),begin(v));\n    eval();\n  }\n  void eval(){\n    b=0;\n    for(int i=0;i<size;i++){\n      b=(b<<4)+v[i];\n    }\n    d=(v[0]!=1)+(v[size-1]!=size);\n    for(int i=0;i+1<size;i++){\n      d+=abs(v[i]-v[i+1])>1;\n    }\n    e=c+(d+1)/2;\n  }    \n  void reverse(int a,int b){\n    c++;\n    std::reverse(begin(v)+a,begin(v)+b+1);\n    eval();\n  }\n  bool operator<(const S &s)const{\n    return e>s.e;\n  }\n};\n\nint main(){\n  int N;\n  cin>>N;\n  vector<int> v(N);\n  for(auto &e:v){\n    cin>>e;\n  }\n  S is(v,0);\n  priority_queue<S> que;\n  que.push(is);\n  unordered_map<long long,int> m;\n  m[is.b]=0;\n  for(;;){\n    S c=que.top();\n    if(c.d==0)break;\n    que.pop();\n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n\tS n=c;\n\tn.reverse(i,j);\n\tif(m.count(n.b)&&m[n.b]<=n.c)continue;\n\tm[n.b]=n.c;\n\tque.push(n);\n      }\n    }\n  }\n  cout<<que.top().c<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n \nusing namespace std;\n \n#define reps(i,f,n) for(int i=f;i<n;i++)\n#define rep(i,n) reps(i,0,n)\n \ntypedef long long ll;\nconst int INF = 1e9+7;\n \n \nint n;\nvector<int> in;\n \n \nvoid input(){\n    cin>>n;\n    rep(i,n){\n        int t;\n        cin>>t;\n        in.push_back(t);\n    }\n}\n \n \nll getHash(vector<int>& a){\n    ll ret=0, t=1;\n    rep(i,a.size()){\n        ret += a[i]*t;\n        t*=11;\n    }\n    return ret;\n}\n \nvoid reverse(vector<int>& a, int b, int c){\n    while(b<c){\n        swap(a[b], a[c]);\n        b++; c--;\n    }\n}\n \nmap<ll,int> memo;\n \nint ans = INF;\n \n \nvoid saiki(vector<int>& a, int mode, int depth, int limit){\n     \n    if(mode==0){\n        bool ok = true;\n        rep(i,a.size()){\n            if(a[i]!=i+1)ok=false;\n        }\n        if(ok)ans = min(ans, depth);\n    }\n \n    if(mode==1){\n        ll h = getHash(a);\n        if(memo.find(h)!=memo.end()){\n            int s = memo[h] + depth;\n            ans = min(ans, s);\n            return;\n        }\n    }\n \n    if(depth==limit){\n        if(mode==0)memo[getHash(a)] = depth;\n        return;\n    }\n \n \n    rep(i,a.size()){\n        reps(j,i+1,a.size()){\n            reverse(a, i ,j);\n            saiki(a, mode, depth+1, limit);\n            reverse(a,i,j);\n        }\n    }\n}\n \nint solve(){\n    vector<int> tmp;\n    rep(i,in.size())tmp.push_back(i+1);\n \n    ans = in.size()-1;\n \n    int limit = (in.size()-1)/2;\n \n    saiki(in, 0, 0, limit);\n    saiki(tmp, 1, 0, limit);\n \n    return ans;\n}\n \nint main(){\n    input();\n    cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 10\n#define INF 1e9\ntypedef vector<int> Vec;\n \nint N, res;\nmap<Vec,int> dist[2];\nVec v[2];\n \nvoid bfs(int p){\n    int t = !p;\n    Vec next;\n    queue<Vec> que; \n \n    dist[p][v[p]] = 0;\n    que.push(v[p]);\n \n    while(!que.empty()){\n\tVec s = que.front(); que.pop();\n \n\tif(s == v[t]){\n\t    res = dist[p][s];\n\t    break;\n\t}\n \n\tif(dist[p][s] >= (N-1)/2){\n\t    break;\n\t}\n \n\tfor(int i = 0 ; i < N-1 ; i++){\n\t    for(int j = i + 1 ; j < N ; j++){\n\t\tnext = s;\n\t\treverse(next.begin()+i, next.begin()+j+1);\n \n\t\tif(!dist[p].count(next)){\n\t\t    dist[p][next] = dist[p][s] + 1;\n\t\t    que.push(next);\n\t\t} \n\t    }\n\t}\n    }\n}\n \nint main(){\n    cin >> N;\n    v[0].resize(N);\n    for(int i = 0 ; i < N ; i++){\n\tcin >> v[0][i];\n\tv[1].push_back(i+1);\n    }\n \n    res = 9;\n    bfs(0); bfs(1);\n    map<Vec,int>::iterator it, val;\n   \n    for(it = dist[0].begin() ; it != dist[0].end() ; ++it){\n\tval = dist[1].find(it->first);\n\tif(val != dist[1].end()){\n\t    res = min(res, it->second+val->second);\n\t}    \n    }\n    cout << res << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nstruct S{\n  vector<int> v;\n  int t;\n  S() {}\n  S(vector<int>& v, int t) : v(v), t(t) {}\n};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    vector<int> A(N);\n    vector<int> goal(N);\n    REP(i, N) goal[i] = i;\n    REP(i, N) {\n      cin>>A[i];\n      A[i]--;\n    }\n    queue<S> que;\n    que.push(S(A, 0));\n    map< vector<int>, int > dist;\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(s.t == 4) break;\n      if(dist[s.v] != s.t) continue;\n      REP(i, N)FOR(j, i + 1, N){\n        vector<int> B = s.v;\n        reverse(B.begin() + i, B.begin() + j + 1);\n        if(dist.count(B)) continue;\n        dist[B] = s.t + 1;\n        que.push(S(B, s.t + 1));\n      }\n    }\n    int ans = N - 1;\n    que = queue<S>();\n    que.push(S(goal, 0));\n    set< vector<int> > used;\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(s.t == 4) break;\n      if(dist.count(s.v)){\n        ans = min(ans, s.t + dist[s.v]);\n      }\n      REP(i, N)FOR(j, i + 1, N){\n        vector<int> B = s.v;\n        reverse(B.begin() + i, B.begin() + j + 1);\n        if(used.count(B)) continue;\n        used.insert(B);\n        que.push(S(B, s.t + 1));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nmap<string,int> mp;\n\nint main()\n{\n\tint n;cin >>n;\n\tstring str,t;\n\tREP(i,n)t += (i+'0');\n\tmp[t] = 0;\n\t\n\tqueue< pair<string,int> > q;\n\tq.push(MP(t,0));\n\t\n\twhile(!q.empty())\n\t{\n\t\tpair<string,int> tmp = q.front();q.pop();\n\t\tfor(int i = 0;i < tmp.FI.size()-1;i++)\n\t\t{\n\t\t\tfor(int j = i+1;j < tmp.FI.size();j++)\n\t\t\t{\n\t\t\t\tstring tt = tmp.FI;\n\t\t\t\treverse(tt.begin()+i,tt.begin()+j+1);\n\t\t\t\tif(mp.find(tt) == mp.end())\n\t\t\t\t{\n\t\t\t\t\tmp[tt] = tmp.SE+1;\n\t\t\t\t\tif(tmp.SE+1 < 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(MP(tt,tmp.SE+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n)\n\t{\n\t\tint c;cin >> c;\n\t\tstr += c+'0'-1;\n\t}\n\t\n\tif(mp.find(str) != mp.end())\n\t{\n\t\tcout << mp[str] << endl;\n\t\treturn 0;\n\t}\n\t\t\n\tq.push(MP(str,0));\n\t\n\t\n\twhile(!q.empty())\n\t{\n\t\tpair<string,int> tmp = q.front();q.pop();\n\t\tfor(int i = 0;i < tmp.FI.size()-1;i++)\n\t\t{\n\t\t\tfor(int j = i+1;j < tmp.FI.size();j++)\n\t\t\t{\n\t\t\t\tstring tt = tmp.FI;\n\t\t\t\treverse(tt.begin()+i,tt.begin()+j+1);\n\t\t\t\tif(mp.find(tt) != mp.end())\n\t\t\t\t{\n\t\t\t\t\tif(mp[tt] != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << mp[tt] + tmp.SE + 1<< endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmp[tt] = -1;\n\t\t\t\t\tif(tmp.SE+1 < 4)\n\t\t\t\t\t\tq.push(MP(tt,tmp.SE+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << n-1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\n\nmap<VI,int> mp;\n\nvoid Rev(int l,int r,vector<int> &v){\n  for(int i=0;i<=10;i++){\n    if(l+i>=r-i)break;\n    swap(v[l+i],v[r-i]);\n  }\n  return;\n}\n\nvoid bfs(vector<int> v,int depth){\n  if(depth>=4)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        if(mp[v1]>depth){\n          mp[v1] = depth;\n          bfs(v1,depth+1);\n        }\n      }else if(mp[v1]==0){\n        mp[v1] = depth;\n        bfs(v1,depth+1);\n      }\n    }\n  }\n  return;\n}\n\nvoid bfs2(vector<int> v,int depth,int &ans){\n  if(depth>=4)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        ans = min(ans,mp[v1]+depth);\n\n      }else if(mp[v1]==0){\n        bfs2(v1,depth+1,ans);\n      }\n    }\n  }\n  return;\n}\n\n\n\nint main(){\n  int n;\n  cin >>n;\n  VI a(n);\n  rep(i,n)cin>>a[i];\n  mp[a]=0;\n  bfs(a,1);\n  VI b(n);\n  rep(i,n)b[i]=i+1;\n  if(a==b){\n    cout << 0 << endl;\n    return 0;\n  }\n  int ans = 10000;\n  if(mp[b]!=0){\n    ans = mp[b];\n  }\n  bfs2(b,1,ans);\n  if(ans==10000){\n    cout << n-1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<vector<int>,int>P;\n\nint n;\n\nmap<vector<int>,int> BFS(vector<int> A){\n  map<vector<int>,int>m;\n  m[A]=0;\n  queue<P>q;\n  q.push(P(A,0));\n  while(!q.empty()){\n    vector<int> B=q.front().first;\n    int cost=q.front().second;q.pop();\n    if(cost==4)continue;\n    for(int l=0;l<n-1;l++){\n      for(int r=l+1;r<n;r++){\n        vector<int>C=B;\n        reverse(C.begin()+l,C.begin()+r+1);\n        if(!m.count(C)){\n          m[C]=cost+1;\n          q.push(P(C,cost+1));\n        }\n      }\n    }\n  }\n  return m;\n}\n\nint main(){\n  cin>>n;\n  vector<int>A(n),B(n);\n  r(i,n)cin>>B[i],A[i]=i+1;\n  map<vector<int>,int>m1=BFS(A);\n  map<vector<int>,int>m2=BFS(B);\n  do{\n    if(m1.count(A)&&m2.count(A)){\n      cout<<m1[A]+m2[A]<<endl;\n      return 0;\n    }\n  }while(next_permutation(A.begin(),A.end()));\n  cout<<9<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\n\n\nmap<ll, int> ma;\nset<ll> se;\n\nll myhash(vector<int> &v) {\n\tll ret = 0;\n\trep(i, v.size()) {\n\t\tret *= 11;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\n\n\nvector<int> w;\n\nint dfs(int d, vector<int> &v, bool f) {\n\tll h = myhash(v);\n\tif(f) {\n\t\tif(ma.find(h) != ma.end()) {\n\t\t\treturn ma[h] + d;\n\t\t}\n\t\tif(se.find(h) != se.end()) return 1010;\n\t\tse.insert(h);\n\t}\n\telse {\n\t\tif(v == w) {\n\t\t\treturn d;\n\t\t}\n\t\tif(d == (v.size() - 1) / 2) {\n\t\t\treturn ma[h] = d;\n\t\t}\n\t}\n\tif(d == (v.size() - 1) / 2) return 1010;\n\tint ret = 1010;\n\trep(i, v.size()) {\n\t\trep(j, i) {\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t\tmins(ret, dfs(d + 1, v, f));\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n, 0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = n - 1;\n\tmins(ans, dfs(0, v, false));\n\tmins(ans, dfs(0, w, true));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nvector<int> v, r;\n\nvector<pair<vector<int>, int> > v1, v2;\n\nint solve()\n{\n\tr = v; sort(r.begin(), r.end());\n\n\tint ln = n / 2, rn = n - n / 2 - 1;\n\n\tmap<vector<int>, int> d1; d1[v] = 1;\n\n\tqueue<vector<int> > que1; que1.push(v);\n\n\twhile (!que1.empty())\n\t{\n\t\tvector<int> v3 = que1.front(); que1.pop();\n\n\t\tv1.push_back(make_pair(v3, d1[v3] - 1));\n\n\t\tif (d1[v3] < ln + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d1[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td1[v4] = d1[v3] + 1;\n\n\t\t\t\t\t\tque1.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<vector<int>, int> d2; d2[r] = 1;\n\n\tqueue<vector<int> > que2; que2.push(r);\n\n\twhile (!que2.empty())\n\t{\n\t\tvector<int> v3 = que2.front(); que2.pop();\n\n\t\tv2.push_back(make_pair(v3, d2[v3] - 1));\n\n\t\tif (d2[v3] < rn + 1)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = i + 1; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tvector<int> v4(v3.begin(), v3.end());\n\n\t\t\t\t\treverse(v4.begin() + i, v4.begin() + j + 1);\n\n\t\t\t\t\tif (!d2[v4])\n\t\t\t\t\t{\n\t\t\t\t\t\td2[v4] = d2[v3] + 1;\n\n\t\t\t\t\t\tque2.push(v4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(v2.begin(), v2.end());\n\n\tvector<vector<int> > v5; vector<int> v6;\n\n\tfor (int i = 0; i < v2.size(); i++)\n\t{\n\t\tv5.push_back(v2[i].first);\n\t\tv6.push_back(v2[i].second);\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < v1.size(); i++)\n\t{\n\t\tint l = distance(v5.begin(), lower_bound(v5.begin(), v5.end(), v1[i].first));\n\t\tint r = distance(v5.begin(), upper_bound(v5.begin(), v5.end(), v1[i].first));\n\t\t\n\t\tif (l != r)\n\t\t{\n\t\t\tret = min(ret, v1[i].second + v6[l]);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\n\tv = vector<int>(n);\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nmap<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n\n  memo[idx][Vtoll(s)]=0;\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+2;j<=n;j++){\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\t\n\tif(memo[idx].count(Vtoll(nS))) continue;\n\tmemo[idx][Vtoll(nS)]=cost+1;\n\t\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n  \n  d=n/2;\n  \n  idx=0;\n  \n  bfs(A);\n\n  d=n/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n  \n  map<ll,int>::iterator ite=memo[0].begin();\n\n  while(ite!=memo[0].end()){\n    \n    if(memo[1].count((*ite).first))\n      ans=min(ans,(*ite).second+memo[1][(*ite).first]);\n    \n    ite++;\n    \n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<vector<int>,int> P;\nint n,ans=9;\nvector<int> v[2];\nmap<vector<int>,int> s[2];\n\nvoid bfs(bool f){\n  queue<P> Q;\n  Q.push(P(v[f],0));\n  while(!Q.empty()){\n    P t=Q.front();Q.pop();\n    vector<int> b=t.first;\n    int d=t.second;\n    if(f&&s[0].count(b))ans=min(ans,s[0][b]+d);\n    if(s[f].count(b))continue;\n    s[f][b]=d;\n    if(d==4)continue;\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++){\n\treverse(b.begin()+i,b.begin()+j+1);\n\tQ.push(P(b,d+1));\n\treverse(b.begin()+i,b.begin()+j+1);\n      }\n  }\n}\n\nint main(){\n  cin>>n;\n  for(int i=1,a;i<=n;i++){\n    cin>>a;\n    v[0].push_back(a);\n    v[1].push_back(i);\n  }\n  bfs(0),bfs(1);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nmap<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(!memo[idx].count(Vtoll(S))) memo[idx][Vtoll(S)]=cost;\n    memo[idx][Vtoll(S)]=cost;\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+1;j<=n;j++){\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n\n  d=n/2;\n  \n  idx=0;\n  \n  bfs(A);\n\n  d=n/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n\n  for(int i=0;i<10;i++){\n    \n    map<ll,int>::iterator ite=memo[0].begin();\n\n    while(ite!=memo[0].end()){\n      \n      if(memo[1].count((*ite).first))\n\tans=min(ans,(*ite).second+memo[1][(*ite).first]);\n      \n      ite++;\n    }\n    \n  }\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define N 10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nset<ll> memo;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  rep(i,V.size())res=res*10+V[i];\n  \n  return res;\n  \n}\n\nqueue<P> q;\nint n;\n\nint bfs(vector<int> s,ll g){\n  \n  memo.insert(Vtoll(s));\n  q.push(P(s,0));\n  \n  while(!q.empty()){\n    \n    P t=q.front(); q.pop();\n\n    vector<int> S=t.first;\n    int cost=t.second;\n    \n    if(Vtoll(S)==g) return cost;\n    \n    for(int i=n;i>=1;i--){ // range\n\n      for(int j=0;j<=n-i;j++){ // start\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+j,nS.begin()+j+i);\n\t\n\tif(memo.count(Vtoll(nS)))continue;\n\t\n\tmemo.insert(Vtoll(nS));\n\tq.push(P(nS,cost+1));\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A(n);\n  \n  rep(i,n)cin>>A[i],A[i]--;\n\n  vector<int> G(n);\n  rep(i,n)G[i]=i;\n  \n  cout<<bfs(A,Vtoll(G))<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\ntypedef long long Int;\n\nint n, a[16];\n\nInt pack(int *a) {\n    Int b = 0;\n    rep (i, n) b = b*16+a[i];\n    return b;\n}\n\nvoid unpack(Int b, int *a) {\n    rep (i, n) {\n        a[n-1-i] = b%16;\n        b /= 16;\n    }\n}\n\nint solve() {\n    static int b[16];\n    queue<pair<int, Int> > q;\n    const Int beg = pack(a);\n    rep (i, n) b[i] = i+1;\n    const Int end = pack(b);\n    map<Int, int> rt;\n    q.push(mp(0, beg));\n    rt[beg] = 0;\n    while (!q.empty()) {\n        pair<int, Int> vv = q.front();\n        q.pop();\n        unpack(vv.second, b);\n        if (vv.first <= 3) rep (i, n) rep (j, i) {\n            reverse(b+j, b+i+1);\n            const Int p = pack(b);\n            if (rt.count(p) == 0) {\n                if (vv.first < 3) q.push(mp(vv.first+1, p));\n                rt[p] = vv.first+1;\n            }\n            reverse(b+j, b+i+1);\n        }\n    }\n    set<Int> vis;\n    q.push(mp(0, end));\n    while (!q.empty()) {\n        pair<int, Int> vv = q.front();\n        q.pop();\n        if (vis.count(vv.second)) continue;\n        vis.insert(vv.second);\n        if (rt.count(vv.second)) return vv.first+rt[vv.second];\n        unpack(vv.second, b);\n        rep (i, n) rep (j, i) {\n            reverse(b+j, b+i+1);\n            q.push(mp(vv.first+1, pack(b)));\n            reverse(b+j, b+i+1);\n        }\n    }\n    return -1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    rep (i, n) scanf(\"%d\", a+i);\n    printf(\"%d\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=3700000;\nconst int INF=123456789;\n\nint f[11];\nint dp1[N], dp2[N];\n\nmap<vector<int>,int> M;\ninline int get_idx(const vector<int> &a)\n{\n    if(M.count(a)) return M[a];\n\n    int n = a.size();\n    int ret=0;\n\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int ct=0;\n        rep(j,a[i])if(!use[j]) ++ct;\n\n        ret += ct*f[n-1-i];\n\n        use[a[i]]=true;\n    }\n    return M[a]=ret;\n}\n\ninline vector<int> get_vec(int n, int idx)\n{\n    vector<int> ret(n);\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int s = idx/f[n-1-i];\n        int j=0,ct=0;\n        while(1)\n        {\n            if(!use[j])\n            {\n                ++ct;\n                if(ct==s+1) break;\n            }\n            ++j;\n        }\n\n        use[j]=true;\n        ret[i]=j;\n        idx -= s*f[n-1-i];\n    }\n    return ret;\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<=10; ++i) f[i] = f[i-1]*i;\n\n    int n;\n    cin >>n;\n    vector<int> a(n);\n    rep(i,n)\n    {\n        cin >>a[i];\n        --a[i];\n    }\n\n    int g = get_idx(a);\n    queue<int> que;\n\n    fill(dp1,dp1+N,INF);\n    dp1[0]=0;\n    que.push(0);\n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n        if(now==g) break;\n\n        vector<int> x = get_vec(n,now);\n        // printf(\" now %d\\n\", now);\n        rep(i,n)for(int j=i+2; j<=n; ++j)\n        {\n            reverse(x.begin()+i, x.begin()+j);\n\n            int nx = get_idx(x);\n            // printf(\"  nx %d\\n\", nx);\n            if(dp1[nx]>dp1[now]+1)\n            {\n                dp1[nx] = dp1[now]+1;\n                if(dp1[nx]<4)que.push(nx);\n            }\n\n            reverse(x.begin()+i, x.begin()+j);\n        }\n    }\n\n    fill(dp2,dp2+N,INF);\n    dp2[g]=0;\n    que.push(g);\n    while(!que.empty())\n    {\n        int now = que.front();\n        que.pop();\n        if(now==g) break;\n\n        vector<int> x = get_vec(n,now);\n        rep(i,n)for(int j=i+2; j<=n; ++j)\n        {\n            reverse(x.begin()+i, x.begin()+j);\n\n            int nx = get_idx(x);\n            if(dp2[nx]>dp2[now]+1)\n            {\n                dp2[nx] = dp2[now]+1;\n                if(dp2[nx]<4)que.push(nx);\n            }\n\n            reverse(x.begin()+i, x.begin()+j);\n        }\n    }\n\n    int ans=9;\n    rep(i,N)if(dp1[i]<INF && dp2[i]<INF) ans=min(ans,dp1[i]+dp2[i]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=3630000;\nconst int INF=123456789;\n\nint f[11];\nint dp[2][N];\n\ninline int get_idx(const vector<int> &a)\n{\n    int n = a.size();\n    int ret=0;\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int ct=0;\n        rep(j,a[i])if(!use[j]) ++ct;\n\n        ret += ct*f[n-1-i];\n\n        use[a[i]]=true;\n    }\n    return ret;\n}\n\ninline vector<int> get_vec(int n, int idx)\n{\n    vector<int> ret(n);\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int s = idx/f[n-1-i];\n        int j=0,ct=0;\n        while(1)\n        {\n            if(!use[j])\n            {\n                ++ct;\n                if(ct==s+1) break;\n            }\n            ++j;\n        }\n\n        use[j]=true;\n        ret[i]=j;\n        idx -= s*f[n-1-i];\n    }\n    return ret;\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<=10; ++i) f[i] = f[i-1]*i;\n\n    int n;\n    cin >>n;\n    vector<int> a(n);\n    rep(i,n)\n    {\n        cin >>a[i];\n        --a[i];\n    }\n\n    rep(d,2)\n    {\n        int start = d?get_idx(a):0;\n        fill(dp[d],dp[d]+N,INF);\n        dp[d][start]=0;\n        queue<int> que;\n        que.push(start);\n        while(!que.empty())\n        {\n            int now = que.front();\n            que.pop();\n\n            vector<int> x = get_vec(n,now);\n            rep(i,n)for(int j=i+2; j<=n; ++j)\n            {\n                reverse(x.begin()+i, x.begin()+j);\n\n                int nx = get_idx(x);\n                if(dp[d][nx]>dp[d][now]+1)\n                {\n                    dp[d][nx] = dp[d][now]+1;\n                    if(dp[d][nx]<4) que.push(nx);\n                }\n\n                reverse(x.begin()+i, x.begin()+j);\n            }\n        }\n    }\n\n    int ans=9;\n    rep(i,N)if(dp[0][i]<INF && dp[1][i]<INF) ans=min(ans,dp[0][i]+dp[1][i]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint N;\n\nstruct Array{\n\tchar a[10], d;\n\tArray(){}\n\tArray(int b[], int x){\n\t\tfor(int i = 0; i < N; i++) a[i] = b[i];\n\t\td = x;\n\t}\n\tbool operator==(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, int dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(int k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(int k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> A.a[i];\n\tfor(int i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\tsort(vec2.begin(), vec2.end());\n\t\n\tint ans = N-1;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), vec[i]);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, p->d + vec[i].d);\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, (int)vec[i].d);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 10\n\n/* Permutation <-> ID */\n// {0,1,2} <=> 0, {0,2,1} <=> 1, {2, 1, 0} <=> 5\n\nnamespace PermutationConverter {\n  const int MAX_DATASIZE = 20;\n\n  ll encode(int N, const int *data){\n    bool used[MAX_DATASIZE] = {};\n    ll id = 0, t = 1;\n\n    for(int i=1; i<=N; i++) t *= i;\n\n    for(int i=0; i<N; i++){\n      t /= (N - i);\n      used[data[i]] = true;\n      id += count(used, used+data[i], false) * t;\n    }\n\n    return id;\n  }\n\n  void decode(int N, ll id, int *data) {\n    bool used[MAX_DATASIZE] = {};\n    ll t = 1;\n\n    for(int i=1; i<=N; i++) t *= i;\n\n    for(int i=0; i<N; i++) {\n      t /= (N - i);\n\n      int s = id / t;\n      for(int j=0; ; j++) {\n        if (!used[j] && s == 0) {\n          data[i] = j;\n          used[j] = true;\n          break;\n        }\n        s -= !used[j];\n      }\n\n      id %= t;\n    }\n  }\n};\n\nvoid bfs(int N, int *A, map<int, int> &ss) {\n\n  queue<int> que1, que2;\n\n  que1.push(PermutationConverter::encode(N, A));\n\n  for(int i=0; i<4; i++) {\n\n    while(que1.size()) {\n      int id = que1.front();\n      que1.pop();\n\n      if (ss.find(id) != ss.end()) continue;\n      ss[id] = i;\n\n      PermutationConverter::decode(N, id, A);\n\n      for (int i=0; i<N; i++) {\n        for (int j=i+2; j<=N; j++) {\n          reverse(A+i, A+j);\n          que2.push(PermutationConverter::encode(N, A));\n          reverse(A+i, A+j);\n        }\n      }\n    }\n\n    swap(que1, que2);\n  }\n}\n\nint main(){\n  int N, A[SIZE], B[SIZE];\n\n  scanf(\"%d\", &N);\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", A+i);\n    A[i]--;\n  }\n\n  iota(B, B+N, 0);\n\n  map<int, int> ss1, ss2;\n\n  bfs(N, A, ss1);\n  bfs(N, B, ss2);\n\n  int ans = N-1;\n\n  for (auto p : ss2) {\n    auto it = ss1.find(p.first);\n    if (it == ss1.end()) continue;\n    ans = min(ans, p.second + it->second);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int N, T;\n    \n    cin >> N;\n    \n    vector<char> A(N);\n    \n    for(int i = 0; i < N; i++) { cin >> T; A[i] = T; }\n    \n    vector<char> B = A; sort(B.begin(), B.end());\n    \n    set<vector<char>, bool> dat; dat.insert(A);\n    \n    queue<vector<char> > que; que.push(A);\n    \n    queue<char> que2; que2.push(0);\n    \n    if(A == B) { cout << 0 << endl; goto Exit; }\n    \n    while(que.size())\n    {\n        vector<char> v1 = que.front(); que.pop();\n        \n        int dist = que2.front(); que2.pop();\n        \n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                vector<char> v2 = v1;\n                \n                swap(v2[i], v2[j]);\n                \n                if(v2 == B) { cout <<  dist + 1 << endl; goto Exit; }\n                \n                if(dat.find(v2) == dat.end())\n                {\n                    dat.insert(v2);\n                    \n                    que.push(v2);\n                    \n                    que2.push(dist + 1);\n                }\n            }\n        }\n    }\n    \n    Exit:;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<vector<int>,int> P;\n\nint n, d, idx;\n\nll Vtoll(vector<int> V){\n  \n  ll res=0;\n  \n  for(int i=0;i<V.size();i++) res=res*10+V[i];\n  \n  return res;\n  \n}\n\nunordered_map<ll,int> memo[2];\n\nqueue<P> q;\n\nvoid bfs(vector<int> s){\n  \n  q.push(P(s,0));\n\n  memo[idx][Vtoll(s)]=0;\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int cost=t.second;\n    vector<int> S=t.first;\n    \n    if(cost==d) continue;\n    \n    for(int i=0;i<n-1;i++)\n      for(int j=i+2;j<=n;j++){\n\t\n\tvector<int> nS=S;\n\treverse(nS.begin()+i,nS.begin()+j);\n\t\n\tif(memo[idx].count(Vtoll(nS))) continue;\n\tmemo[idx][Vtoll(nS)]=cost+1;\n\t\n\tq.push(P(nS,cost+1));\n      }\n    \n  }\n  \n}\n\nint main(){\n  \n  cin>>n;\n  \n  vector<int> A;\n  \n  A.resize(n);\n  \n  for(int i=0;i<n;i++) cin>>A[i],A[i]--;\n  \n  d=(n-1)/2;\n  \n  idx=0;\n  \n  bfs(A);\n  \n  d=(n-1)/2;\n    \n  idx=1;\n  \n  for(int i=0;i<n;i++) A[i]=i;\n  \n  bfs(A);\n\n  int ans=n-1;\n  \n  unordered_map<ll,int>::iterator ite=memo[0].begin();\n\n  while(ite!=memo[0].end()){\n    \n    if(memo[1].count((*ite).first))\n      ans=min(ans,(*ite).second+memo[1][(*ite).first]);\n    \n    ite++;\n    \n  }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n/*\n\nSAK\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\n\nvector<int> norm(vector<int> seq) {\n  int m = *min_element(all(seq));\n  rep(i, seq.size()) seq[i] -= m;\n  bool u[seq.size()];\n  rep(i, seq.size()) u[i] = false;\n  rep(i, seq.size()) {\n    if (seq[i] == i) u[i] = true;\n    else break;\n  }\n  for (int i=(int)seq.size()-1; i>=0; i--) {\n    if (seq[i] == i) u[i] = true;\n    else break;\n  }\n  vector<int> ret;\n  rep(i, seq.size()) if (!u[i]) ret.pb(seq[i]);\n\n  m = *min_element(all(ret));\n  rep(i, ret.size()) ret[i] -= m;\n  return ret;\n}\nvector<int> swap_range(vector<int> &seq, int l, int r) {\n  vector<int> ret(seq);\n  rep(s, (r-l+1)/2) swap(ret[l+s], ret[r-s]);\n  return ret;\n}\n\nint f(vector<int> seq) {\n  if (seq.empty()) return 0;\n  int first = -1, last = -1;\n  rep(i, seq.size()) {\n    if (seq[i] == 0) first = i;\n    if (seq[i] == (int)seq.size()-1) last = i;\n  }\n  assert(first != -1 && last != -1);\n\n  vector<int> ls = swap_range(seq, 0, first);\n  vector<int> rs = swap_range(seq, last, seq.size()-1);\n  //cout<<\"{\"; for (int x:seq)cout<<x<<\",\";cout<<\"} -> \"<<r<<\"\\n\";\n  return 1+min(f(norm(ls)), f(norm(rs)));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  vector<int> s;\n  rep(i, N) {\n    int a;\n    cin >> a;\n    s.pb(a);\n  }\n  cout << f(norm(s)) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid bfs(vector<int> v, map<vector<int>, int>& m) {\n    const int N = v.size();\n    queue<vector<int>> que;\n    que.push(v);\n    m[v] = 0;\n    while(!que.empty()) {\n        auto now = que.front();\n        que.pop();\n        int cost = m[now];\n        if(cost >= (N-1)/2) {\n            continue;\n        }\n        for(int i=0; i<N; ++i) {\n            for(int j=i+2; j<=N; ++j) {\n                auto next = now;\n                reverse(next.begin()+i, next.begin()+j);\n                if(m.count(next) == 0) {\n                    m[next] = cost + 1;\n                    que.push(next);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> v(N);\n    for(int i=0; i<N; ++i) {\n        cin >> v[i];\n    }\n    auto v2 = v;\n    sort(v2.begin(), v2.end());\n    map<vector<int>, int> m1, m2;\n    int res = N - 1;\n    bfs(v, m1);\n    bfs(v2, m2);\n    do {\n        if(m1.count(v2) == 0 || m2.count(v2) == 0) {\n            continue;\n        }\n        res = min(res, m1[v2] + m2[v2]);\n    } while(next_permutation(v2.begin(), v2.end()));\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nstruct S{\n  vector<int> A;\n  int v;\n  S() {}\n  S(vector<int>& a, int v) : A(a), v(v) {}\n  bool operator < (const S& s) const {\n    if(v != s.v) return v > s.v;\n    else return A < s.A;\n  }\n  int turn(){\n    int res = v;\n    REP(i, A.size()) if(A[i] != i) res--;\n    return res;\n  }\n};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    vector<int> A(N);\n    REP(i, N) {\n      cin>>A[i];\n      A[i]--;\n    }\n    priority_queue<S> que;\n    int rest = 0;\n    REP(i, N) if(A[i] != i) rest++;\n    que.push(S(A, rest));\n    set< vector<int> > used;\n    while(!que.empty()){\n      S s = que.top(); que.pop();\n      if(used.count(s.A)) continue;\n      used.insert(s.A);\n      int t = s.turn();\n      if(s.v == t){\n        cout<<t<<endl;\n        break;\n      }\n      REP(i, N)FOR(j, i + 1, N){\n        vector<int> B = s.A;\n        reverse(B.begin() + i, B.begin() + j + 1);\n        if(used.count(B)) continue;\n        int rest = 0;\n        REP(k, N) if(B[k] != k) rest++;\n        que.push(S(B, t + 1 + rest));\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int64_t s=0;\n    rep(i,0,n){\n        int64_t a;\n        cin >> a;\n        --a;\n        s=s*10+a;\n    }\n\n    int64_t sorted=0;\n    rep(i,0,n) sorted=sorted*10+i;\n\n    int64_t exp[10];\n    exp[0]=1;\n    rep(i,1,10) exp[i]=exp[i-1]*10;\n    auto reverse=[&](int64_t x,int l,int r){\n        rep(i,0,(r-l+1)/2){\n            int64_t p=x/exp[l+i]%10,q=x/exp[r-i]%10;\n            x-=p*exp[l+i]+q*exp[r-i];\n            x+=q*exp[l+i]+p*exp[r-i];\n        }\n        return x;\n    };\n\n    unordered_map<int64_t,bool> done;\n    queue<int64_t> queues[10];\n    done[s]=true;\n    queues[0].push(s);\n    rep(k,0,10){\n        print(k);\n        auto &que=queues[k];\n        while(!que.empty()){\n            auto x=que.front();\n            que.pop();\n            if(x==sorted){\n                cout << k << endl;\n                return;\n            }\n            if(k==9) continue;\n            rep(i,0,n){\n                rep(j,i+1,n){\n                    int64_t y=reverse(x,i,j);\n                    if(done[y]) continue;\n                    done[y]=true;\n                    queues[k+1].push(y);\n                }\n            }\n        }\n    }\n    cout << 10 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, a[10];\n\nint main(){\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\t\n\tmap<ll, int> m;\n\tset<ll> s;\n\tqueue<pair<int, ll> > q;\n\tll t = 0, g = 0;\n\trep(i, n){\n\t\tt *= 16, t += a[i];\n\t\tg *= 16, g += i + 1;\n\t}\n\tq.push(mp(0, g));\n\tm[g] = 0;\n\t\n\twhile(!q.empty()){\n\t\tll t = q.front().second;\n\t\tint c = q.front().first; q.pop();\n\t\t\n\t\trep(i, n) a[n - 1 - i] = t % 16, t /= 16;\n\t\trep(i, n) for(int j = i + 1; j < n; j++){\n\t\t\treverse(a + i, a + j + 1);\n\t\t\tll h = 0;\n\t\t\trep(k, n) h *= 16, h += a[k];\n\t\t\tif(!m.count(h)){\n\t\t\t\tm[h] = c + 1;\n\t\t\t\tif(c < 3) q.push(mp(c + 1, h));\n\t\t\t}\n\t\t\treverse(a + i, a + j + 1);\n\t\t}\n\t}\n\tif(m.count(t)){\n\t\tcout << m[t] << endl;\n\t\treturn 0;\n\t}\n\tq.push(mp(0, t));\n\ts.insert(t);\n\t\n\twhile(!q.empty()){\n\t\tll t = q.front().second;\n\t\tint c = q.front().first; q.pop();\n\t\t\n\t\trep(i, n) a[n - 1 - i] = t % 16, t /= 16;\n\t\trep(i, n) for(int j = i + 1; j < n; j++){\n\t\t\treverse(a + i, a + j + 1);\n\t\t\tll h = 0;\n\t\t\trep(k, n) h *= 16, h += a[k];\n\t\t\tif(m.count(h)){\n\t\t\t\tcout << c + 1 + m[h] << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(c < 3 && !s.count(h)){\n\t\t\t\ts.insert(h);\n\t\t\t\tq.push(mp(c + 1, h));\n\t\t\t}\n\t\t\treverse(a + i, a + j + 1);\n\t\t}\n\t}\n\tcout << 9 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=3630000;\nconst int INF=123456789;\n\nint f[11];\nint dp[2][N];\n\ninline int get_idx(const vector<int> &a)\n{\n    int n = a.size();\n    int ret=0;\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int ct=0;\n        rep(j,a[i])if(!use[j]) ++ct;\n\n        ret += ct*f[n-1-i];\n\n        use[a[i]]=true;\n    }\n    return ret;\n}\n\ninline vector<int> get_vec(int n, int idx)\n{\n    vector<int> ret(n);\n    vector<bool> use(n,false);\n    rep(i,n)\n    {\n        int s = idx/f[n-1-i];\n        int j=0,ct=0;\n        while(1)\n        {\n            if(!use[j])\n            {\n                ++ct;\n                if(ct==s+1) break;\n            }\n            ++j;\n        }\n\n        use[j]=true;\n        ret[i]=j;\n        idx -= s*f[n-1-i];\n    }\n    return ret;\n}\n\nint main()\n{\n    f[0]=1;\n    for(int i=1; i<=10; ++i) f[i] = f[i-1]*i;\n\n    int n;\n    cin >>n;\n    vector<int> a(n);\n    rep(i,n)\n    {\n        cin >>a[i];\n        --a[i];\n    }\n\n    rep(d,2)\n    {\n        int start = d?get_idx(a):0;\n        fill(dp[d],dp[d]+N,INF);\n        dp[d][start]=0;\n        queue<int> que;\n        que.push(start);\n        while(!que.empty())\n        {\n            int now = que.front();\n            que.pop();\n\n            vector<int> x = get_vec(n,now);\n            rep(i,n)for(int j=i+1; j<=n; ++j)\n            {\n                reverse(x.begin()+i, x.begin()+j);\n\n                int nx = get_idx(x);\n                if(dp[d][nx]>dp[d][now]+1)\n                {\n                    dp[d][nx] = dp[d][now]+1;\n                    if(dp[d][nx]<4) que.push(nx);\n                }\n\n                reverse(x.begin()+i, x.begin()+j);\n            }\n        }\n    }\n\n    int ans=9;\n    rep(i,N)if(dp[0][i]<INF && dp[1][i]<INF) ans=min(ans,dp[0][i]+dp[1][i]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N;\n  while(cin>>N && N){\n    vector<int> A(N);\n    REP(i, N) cin>>A[i];\n    int cnt = 0;\n    REP(i, N){\n      if(A[i] == i + 1) continue;\n      int to = -1;\n      for(int j = i + 1; j < N; j++){\n        if(A[j] == i + 1){\n          to = j;\n          break;\n        }\n      }\n      reverse(A.begin() + i, A.begin() + to + 1);\n      cnt++;\n    }\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nshort N;\n\nstruct Array{\n\tshort a[10], d;\n\tArray(){}\n\tbool operator==(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] != obj.a[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tbool operator<(const Array &obj)const{\n\t\tfor(short i = 0; i < N; i++){\n\t\t\tif(a[i] < obj.a[i]) return true;\n\t\t\tif(a[i] > obj.a[i]) return false;\n\t\t}\n\t\treturn d < obj.d;\n\t}\n};\n\nArray A, I;\nvector<Array> vec, vec2;\n\nvoid dfs(Array arr, short dep, vector<Array> &vec)\n{\n\tvec.push_back(arr);\n\tif(dep == 4) return;\n\t\n\tArray tmp;\n\tfor(short i = 0; i < N; i++){\n\t\tfor(short j = 0; j < N; j++){\n\t\t\tif(i >= j) continue;\n\t\t\tfor(short k = 0; k < N; k++) tmp.a[k] = arr.a[k];\n\t\t\tfor(short k = i; k <= j; k++) tmp.a[k] = arr.a[j-(k-i)];\n\t\t\ttmp.d = arr.d + 1;\n\t\t\tdfs(tmp, dep+1, vec);\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(short i = 0; i < N; i++) cin >> A.a[i];\n\tfor(short i = 0; i < N; i++) I.a[i] = i+1;\n\tA.d = I.d = 0;\n\t\n\tdfs(A, 0, vec);\n\tdfs(I, 0, vec2);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\n\tsort(vec2.begin(), vec2.end());\n\tvec2.erase(unique(vec2.begin(), vec2.end()), vec2.end());\n\t\n\tshort ans = N-1;\n\tArray tmp;\n\tfor(short i = 0; i < vec.size(); i++){\n\t\ttmp = vec[i]; tmp.d = 0;\n\t\tauto p = lower_bound(vec2.begin(), vec2.end(), tmp);\n\t\tif(*p == vec[i]){\n\t\t\tans = min(ans, (short)(p->d + vec[i].d));\n\t\t}\n\t\tif(vec[i] == I) ans = min(ans, vec[i].d);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define mins(a,b) a=min(a,b)\n\ntypedef long long ll;\n\n\nmap<ll, int> ma;\nset<ll> se;\n\nll myhash(vector<int> &v) {\n\tll ret = 0;\n\trep(i, v.size()) {\n\t\tret *= 11;\n\t\tret += v[i];\n\t}\n\treturn ret;\n}\n\n\nvector<int> w;\n\nint dfs(int d, vector<int> &v, bool f) {\n\tll h = myhash(v);\n\tif(f) {\n\t\tif(ma.find(h) != ma.end()) {\n\t\t\treturn ma[h] + d;\n\t\t}\n\t}\n\telse {\n\t\tif(v == w) {\n\t\t\treturn d;\n\t\t}\n\t\tif(d == (v.size() - 1) / 2) {\n\t\t\tma[h] = d;\n\t\t\treturn 1010;\n\t\t}\n\t}\n\tif(d == (v.size() - 1) / 2) return 1010;\n\tint ret = 1010;\n\trep(i, v.size()) {\n\t\trep(j, i) {\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t\tmins(ret, dfs(d + 1, v, f));\n\t\t\treverse(v.begin() + j, v.begin() + i + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\trep(i, n) cin >> v[i], v[i]--;\n\tw.assign(n, 0);\n\trep(i, n) w[i] = i;\n\tif(v == w) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint ans = n - 1;\n\tmins(ans, dfs(0, v, false));\n\tmins(ans, dfs(0, w, true));\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n; vector<int> a;\nint main() {\n\tcin >> n; a.resize(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i], a[i]--;\n\tmap<vector<int>, int> dist; dist[a] = 1;\n\tqueue<vector<int> > que1; que1.push(a);\n\twhile (!que1.empty()) {\n\t\tvector<int> v1 = que1.front(); que1.pop();\n\t\tint dist1 = dist[v1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tif (!dist[v1]) {\n\t\t\t\t\tdist[v1] = dist1 + 1;\n\t\t\t\t\tif (dist1 < (n + 1) / 2) que1.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 999999999;\n\tvector<int> s(n);\n\tfor (int i = 0; i < n; i++) s[i] = i;\n\tmap<vector<int>, int> dist2; dist2[s] = 1;\n\tqueue<vector<int> > que2; que2.push(s);\n\twhile (!que2.empty()) {\n\t\tvector<int> v1 = que2.front(); que2.pop();\n\t\tint dist1 = dist2[v1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 2; j <= n; j++) {\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t\tif (!dist2[v1]) {\n\t\t\t\t\tdist2[v1] = dist1 + 1;\n\t\t\t\t\tint dist3 = dist[v1];\n\t\t\t\t\tif (dist3) ret = min(ret, dist1 + dist3 - 1);\n\t\t\t\t\tif (dist1 < n / 2) que2.push(v1);\n\t\t\t\t}\n\t\t\t\treverse(v1.begin() + i, v1.begin() + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (s != a ? ret : 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin >> N;\n\n    vector<int> a(N), b(N);\n        \n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n        b[i] = i + 1;\n    }\n\n    map<vector<int>, int> d, h;\n    int ans = N - 1;\n\n    // from goal\n    {\n        h[b] = 0;\n        queue<vector<int> > q;\n        q.push(b);\n        \n        while (!q.empty()) {\n            vector<int> v = q.front();\n            int cost = h[v];\n            q.pop();\n\n            if (v == a) {\n                ans = cost;\n                break;\n            }\n            if (cost >= 4)\n                break;\n\n            for (int i = 0; i < N; i++) \n                for (int j = i + 1; j < N; j++) {\n                    vector<int> next = v;\n                    reverse(next.begin() + i, next.begin() + j + 1);\n                    if (!h.count(next)) {\n                        h[next] = cost + 1;\n                        q.push(next);\n                    }\n                }\n        }\n    }\n\n    // from start\n    {\n        d[a] = 0;\n        queue<vector<int> > q;\n        q.push(a);\n        \n        while (!q.empty()) {\n            vector<int> v = q.front();\n            int cost = d[v];\n            q.pop();\n\n            if (h.count(v)) {\n                ans = cost + h[v];\n                break;\n            }\n\n            if (cost >= 4)\n                break;\n\n            for (int i = 0; i < N; i++) \n                for (int j = i + 1; j < N; j++) {\n                    vector<int> next = v;\n                    reverse(next.begin() + i, next.begin() + j + 1);\n                    if (!d.count(next)) {\n                        d[next] = cost + 1;\n                        q.push(next);\n                    }\n                }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nconst long long mod[] = {999999937LL, 1000000007LL}, base = 9973;\nint maxdepth;\nmap<VI,int> mp;\n\nvoid Rev(int l,int r,vector<int> &v){\n  for(int i=0;i<=10;i++){\n    if(l+i>=r-i)break;\n    swap(v[l+i],v[r-i]);\n  }\n  return;\n}\n\nvoid bfs(vector<int> v,int depth){\n  if(depth>maxdepth)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        if(mp[v1]>depth){\n          mp[v1] = depth;\n          bfs(v1,depth+1);\n        }\n      }else if(mp[v1]==0){\n        mp[v1] = depth;\n        bfs(v1,depth+1);\n      }\n    }\n  }\n  return;\n}\n\nvoid bfs2(vector<int> v,int depth,int &ans){\n  if(depth>maxdepth)return;\n  for(int i=0;i<v.size();i++){\n    for(int j=i+1;j<v.size();j++){\n      vector<int>v1;\n      v1 = v;\n      Rev(i,j,v1);\n      if(mp[v1]!=0){\n        ans = min(ans,mp[v1]+depth);\n        bfs2(v1,depth+1,ans);\n      }else if(mp[v1]==0){\n        bfs2(v1,depth+1,ans);\n      }\n    }\n  }\n  return;\n}\n\n\n\nint main(){\n  int n;\n  cin >>n;\n  maxdepth = 4;\n  VI a(n);\n  rep(i,n)cin>>a[i];\n  mp[a]=0;\n  bfs(a,1);\n  VI b(n);\n  rep(i,n)b[i]=i+1;\n  if(a==b){\n    cout << 0 << endl;\n    return 0;\n  }\n  int ans = 10000;\n  if(mp[b]!=0){\n    cout << mp[b] << endl;\n    return 0;\n  }\n  bfs2(b,1,ans);\n  if(ans==10000){\n    cout << n-1 << endl;\n  }else{\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nlong long int pool[3628800];\nint fwd_min[3628800], bwd_min[3628800];\nint fac[11];\n\nlong long int enc(int *p)\n{\n    long long int tmp = 0;\n    for (int i = 0; i < n; i++){\n        tmp = tmp * 10 + p[i] - 1;\n    }\n    return (tmp);\n}\n\nvoid bfs(int *p, int *s)\n{\n    for (int i = 0; i < fac[n]; i++){\n        p[i] = -1;\n    }\n\n    int id = lower_bound(pool, pool + fac[n], enc(s)) - pool;\n    int c[10];\n\n    queue<int> q;\n    q.push(id);\n\n    p[id] = 0;\n\n    while (q.size()){\n        int x = q.front(); q.pop();\n\n        long long int t = pool[x];\n        for (int i = 0; i < n; i++){\n            c[n - i - 1] = (t + 1) % 10;\n            if (c[n - i - 1] == 0) c[n - i - 1] = 10;\n            t /= 10;\n        }\n\n        for (int i = 0; i < n; i++){\n            for (int j = i + 1; j < n; j++){\n                int s = i, t = j;\n                while (s < t){\n                    c[s] ^= c[t]; c[t] ^= c[s]; c[s] ^= c[t];\n                    s++; t--;\n                }\n                int y = lower_bound(pool, pool + fac[n], enc(c)) - pool;\n                if (p[y] == -1){\n                    p[y] = p[x] + 1;\n                    if (p[y] < 4) q.push(y);\n                }\n\n                s = i, t = j;\n                while (s < t){\n                    c[s] ^= c[t]; c[t] ^= c[s]; c[s] ^= c[t];\n                    s++; t--;\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    int a[16], e[16];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d\", a + i);\n    for (int i = 0; i < n; i++) e[i] = i + 1;\n\n    int ctr = 0;\n    do {\n        long long int tmp = 0;\n        for (int i = 0; i < n; i++){\n            tmp = tmp * 10 + e[i] - 1;\n        }\n        pool[ctr++] = tmp;\n    } while (next_permutation(e, e + n));\n\n    sort(pool, pool + fac[n]);\n\n\n    fac[0] = 1;\n\n    for (int i = 1; i <= n; i++){\n        fac[i] = i * fac[i - 1];\n        e[i - 1] = i;\n    }\n\n    bfs(fwd_min, e);\n    bfs(bwd_min, a);\n\n    int ans = n - 1;\n    int t = lower_bound(pool, pool + fac[n], enc(a)) - pool;\n\n    if (~fwd_min[t]) ans = fwd_min[t];\n\n    for (int i = 0; i < fac[n]; i++){\n        if (~fwd_min[i] && ~bwd_min[i]) ans = min(ans, fwd_min[i] + bwd_min[i]);\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//半数列挙で答えが8以下かを判定する.\n//順列は, 16進数で表現する.\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint n;\nint a[10], decA, basePermDec;\nvector<int> perms[2][5];\n\nvoid dfs(int type, int depth, int maxDepth, int nowP) {\n\tperms[type][depth].push_back(nowP);\n\tif (depth == maxDepth) return;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint nextP = nowP & ((1LL << (4 * (j + 1))) - 1);\n\t\t\tnextP = (nextP >> (4 * i)) << (4 * i);\n\t\t\tnextP = nowP - nextP;\n\t\t\tfor (int k = 0; k <= j - i; k++) {\n\t\t\t\tint idl = i + k;\n\t\t\t\tint idr = j - k;\n\t\t\t\tnextP += ((nowP >> (4 * idr)) & 15) << (4 * idl);\n\t\t\t}\n\t\t\tdfs(type, depth + 1, maxDepth, nextP);\n\t\t}\n\t}\n}\n\nbool isMatch(int depth1, int depth2) {\n\tvector<int> &a = perms[0][depth1];\n\tvector<int> &b = perms[1][depth2];\n\tint i, j;\n\t\n\tif (a.size() == 0 || b.size() == 0) return false;\n\t\n\tj = 0;\n\tfor (i = 0; i < a.size(); i++) {\n\t\tfor (; j < b.size(); j++) {\n\t\t\tif (a[i] <= b[j]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (a[i] == b[j]) return true;\n\t}\n\treturn false;\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) { cin >> a[i]; a[i]--; }\n\tfor (i = 0; i < n; i++) decA += a[i] << (4 * i);\n\tfor (i = 0; i < n; i++) basePermDec += i << (4 * i);\n\tdfs(0, 0, 4, basePermDec);\n\tdfs(1, 0, 4, decA);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tsort(perms[i][j].begin(), perms[i][j].end());\n\t\t\tperms[i][j].erase(unique(perms[i][j].begin(), perms[i][j].end()), perms[i][j].end());\n\t\t}\n\t}\n\t\t\n\tint ans = 9;\n\tfor (i = 0; i <= 4; i++) {\n\t\tfor (j = 0; j <= 4; j++) {\n\t\t\tif (isMatch(i, j)) {\n\t\t\t\tans = min(ans, i + j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\nint main() {\n\tlong long int N;\n\tcin >> N;\n\tvector<long long int>D( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> D[i];\n\t\tD[i]--;\n\t}\n\tmap<vector<long long int>, long long int>memo;\n\tqueue<vector<long long int>>que;\n\tque.push( D );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\t\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tfor( size_t j = i + 1; j < N; j++ ) {\n\t\t\t\tauto next = now;\n\t\t\t\treverse( next.begin() + i, next.begin() + j+1 );\n\t\t\t\tif(! memo.count( next ) ) {\n\t\t\t\t\tmemo[next] = memo[now] + 1;\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsort( D.begin(), D.end() );\n\tcout << memo[D] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\n\nstring rev(const string &s, int i, int j){\n  string ret = s;\n  for(int k = i; k <= j; ++k) ret[k] = s[j-k+i];\n  return ret;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  string A(N,'0');\n  for(int i = 0; i < N; ++i){\n    int t;\n    cin >> t;\n    A[i] = '0' + t - 1;\n  }\n  string C(N, '0');\n  for(int i = 0; i < N; ++i) C[i] = '0' + i;\n  if(A == C){\n    cout << 0 << endl;\n    return 0;\n  }\n  queue<string> que;\n  set<string> S, T;\n  S.insert(A);\n  T.insert(A);\n  for(int i = 0; i < N-1; ++i){\n    set<string> S_;\n    for(set<string>::iterator itr = S.begin(); itr != S.end(); ++itr){\n      string s = *itr;\n      for(int j = 0; j < N; ++j){\n        for(int k = j+1; k < N; ++k){\n          string t = rev(s, j, k);\n          if(t == C){\n            cout << i+1 << endl;\n            return 0;\n          }\n          if(T.find(t) == T.end()){\n            S_.insert(t);\n            T.insert(t);\n          }\n        }\n      }\n    }\n    S = S_;\n  }\n  cout << N-1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef map<vi, int> ma;\n\nvi a,b;\nint N;\n\nma bfs(vi vec){\n    ma tem;\n    queue<vi>que;\n    que.push(vec);\n    tem[vec]=0;\n    while(!que.empty()){\n        \n        vi v=que.front();\n        que.pop();\n//        cout<<\"tem[v]: \"<<tem[v]<<endl;\n//        for(int i=0;i<v.size();i++)\n//            cout<<v[i]<<\" \";\n//        cout<<endl;\n        if(tem[v]>=(N-1)/2)\n            continue;\n        for(int i=0;i<N;i++)\n            for(int j=i+2;j<=N;j++){\n                vi n=v;\n                reverse(n.begin()+i,n.begin()+j);\n                if(tem.find(n)==tem.end()){\n                    tem[n]=tem[v]+1;\n                    que.push(n);\n                }\n            }\n    }\n    return tem;\n}\n\nvoid solve(){\n    ma m_a=bfs(a);\n    ma m_b=bfs(b);\n   \n    if(m_a.find(b)!=m_a.end()){\n        cout<<m_a[b]<<endl;\n        return;\n    }\n    int ans=N-1;\n    do{\n        if(m_a.find(b)==m_a.end()||m_b.find(b)==m_b.end())\n            continue;\n        else\n            ans=min(m_a[b]+m_b[b],ans);\n    }while(next_permutation(b.begin(), b.end()));\n    cout<<ans<<endl;\n}\n\nint main(){\n    cin>>N;\n    for(int i=0;i<N;i++){\n        int t;\n        cin>>t;\n        a.push_back(t);\n    }\n    b=a;\n    sort(b.begin(),b.end());\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nint main(){\n    int n;\n    cin >> n;\n    vi v(n);\n    rep(i,n) cin >> v[i];\n    set<vi> dp;\n    queue<pair<int,vi>> q;\n    dp.insert(v);\n    q.emplace(0,v);\n    int ans = -1;\n    while(q.size()){\n        int d; vi v;\n        tie(d,v) = q.front();\n        q.pop();\n        bool ok = true;\n        rep(i,n-1) ok &= v[i]+1==v[i+1];\n        if(ok){\n            ans = d;\n            break;\n        }\n        rep(i,n+1)rep(j,i){\n            reverse(v.begin()+j,v.begin()+i);\n            if(dp.count(v)==0) q.emplace(d+1,v);\n            reverse(v.begin()+j,v.begin()+i);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define NMAX 10\n#define FMAX 3628800\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nint maxdepth;\nint hash(int *a, int asize);\nvoid rev_sort(int l, int r, int *a, int asize);\nvoid bfs(int *a, int asize, char *memo, int depth);\nint main (void)\n{\n  int i, n, fact = 1, res = 9, a[NMAX], b[NMAX];\n  char memo1[FMAX], memo2[FMAX];\n  scanf(\"%d\", &n);\n  maxdepth = (n - 1) / 2;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    fact *= i + 1;\n    b[i] = i + 1;\n  }\n  for (i = 0; i < fact; i++) memo1[i] = memo2[i] = n;\n  memo1[hash(a, n)] = memo2[hash(b, n)] = 0;\n  bfs(a, n, memo1, 0);\n  bfs(b, n, memo2, 0);\n  for (i = 0; i < fact; i++) res = min(res, memo1[i] + memo2[i]);\n  printf(\"%d\\n\", res);\n}\n\nint hash(int *a, int asize)\n{\n  int i, j, res = 0, fact = 1;\n  for (i = 0; i < asize; i++) {\n    int grade = 0;\n    for (j = i + 1; j < asize; j++) if (a[i] < a[j]) grade++;\n    res += grade * fact;\n    fact *= asize - i;\n  }\n  return res;\n}\n\nvoid rev_sort(int l, int r, int *a, int asize)\n{\n  int i;\n  for (i = 0; i < asize; i++) {\n    int temp;\n    if (l + i >= r - i) break;\n    temp = a[l+i];\n    a[l+i] = a[r-i];\n    a[r-i] = temp;\n  }\n}\n\nvoid bfs(int *a, int asize, char *memo, int depth)\n{\n  int i, j;\n  if (depth >= maxdepth) return;\n  for (i = 0; i < asize; i++) {\n    for (j = i + 1; j < asize; j++) {\n      int h;\n      rev_sort(i, j, a, asize);\n      h = hash(a, asize);\n      if (memo[h] > depth + 1) {\n        memo[h] = depth + 1;\n        bfs(a, asize, memo, depth + 1);\n      }\n      rev_sort(i, j, a, asize);\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2443\n  Title:ReverseSort\n  @kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\nint N,A[10];\nvoid reverse(int ar[],int n,int a,int b)\n{\n  int wk;\n\n  while(a<b)\n    {\n      wk=ar[a];\n      ar[a]=ar[b];\n      ar[b]=wk;\n      a++;b--;\n    }\n}\nvoid dump(int ar[],int n)\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d:\",ar[i]);\n  printf(\"\\n\");\n}\nint solve(int ar[],int n)\n{\n  int max_,maxp,min_,minp,i,ret1,ret2,flag;\n  int newar[10],newar2[10];\n  //dump(ar,n);\n  if(n==2)\n    return((ar[0]<ar[1])?0:1);\n  max_=INT_MIN;\n  min_=INT_MAX;\n  for(i=0;i<n;i++)\n    {\n    if(max_<ar[i])\n      {\n\tmax_=ar[i];\n\tmaxp=i;\n      }\n    if(min_>ar[i])\n      {\n\tmin_=ar[i];\n\tminp=i;\n      }\n    }\n  \n  memcpy(newar,ar,n*sizeof(int));\n  if(maxp<n-1)\n    {\n      reverse(newar,n,maxp,n-1);\n      flag=1;\n    }\n  else\n    flag=0;\n  ret1=solve(newar,n-1)+flag;\n  \n\n  memcpy(newar2,ar,n*sizeof(int));\n  if(minp>0)\n    {\n      reverse(newar2,n,0,minp);\n      flag=1;\n    }\n  else\n    flag=0;\n  ret2=solve(newar2+1,n-1)+flag;\n  \n  if(n==10)\n    printf(\":%d %d\\n\",ret1,ret2);\n\n  if(ret1>ret2)\n    return(ret2);\n  else\n    return(ret1);\n}\n\nmain()\n{\n  int i;\n  scanf(\"%d\",&N);\n  for(i=0;i<N;i++)\n    scanf(\"%d\",&A[i]);\n  printf(\"%d\\n\",solve(A,N));\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2443\n  Title:ReverseSort\n  @kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\nint N,A[10];\nvoid reverse(int ar[],int n,int a,int b)\n{\n  int wk;\n\n  while(a<b)\n    {\n      wk=ar[a];\n      ar[a]=ar[b];\n      ar[b]=wk;\n      a++;b--;\n    }\n}\n\nint solve(int ar[],int n)\n{\n  int max_,maxp,i;\n  if(n==2)\n    return((ar[0]<ar[1])?0:1);\n  max_=INT_MIN;\n  for(i=0;i<n;i++)\n    if(max_<ar[i])\n      {\n\tmax_=ar[i];\n\tmaxp=i;\n      }\n  if(maxp==n-1)\n    return(solve(ar,n-1));\n  else\n    {\n      reverse(ar,n,maxp,n-1);\n      return(1+solve(ar,n-1));\n    }\n}\nmain()\n{\n  int i;\n  scanf(\"%d\",&N);\n  for(i=0;i<N;i++)\n    scanf(\"%d\",&A[i]);\n  printf(\"%d\\n\",solve(A,N));\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define NMAX 10\n#define FMAX 3628800\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nint hash(int *a, int asize);\nvoid rev_sort(int l, int r, int *a, int asize);\nvoid bfs(int *a, int asize, char *memo, int depth, int maxdepth);\nint main (void)\n{\n  int i, n, maxdepth, fact = 1, res = 9, a[NMAX], b[NMAX];\n  char memo1[FMAX], memo2[FMAX];\n  scanf(\"%d\", &n);\n  maxdepth = (n - 1) / 2;\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    fact *= i + 1;\n    b[i] = i + 1;\n  }\n  for (i = 0; i < fact; i++) memo1[i] = memo2[i] = n;\n  memo1[hash(a, n)] = memo2[hash(b, n)] = 0;\n  bfs(a, n, memo1, 0, maxdepth);\n  bfs(b, n, memo2, 0, maxdepth);\n  for (i = 0; i < fact; i++) res = min(res, memo1[i] + memo2[i]);\n  printf(\"%d\\n\", res);\n}\n\nint hash(int *a, int asize)\n{\n  int i, j, res = 0, fact = 1;\n  for (i = 0; i < asize; i++) {\n    int grade = 0;\n    for (j = i + 1; j < asize; j++) if (a[i] < a[j]) grade++;\n    res += grade * fact;\n    fact *= asize - i;\n  }\n  return res;\n}\n\nvoid rev_sort(int l, int r, int *a, int asize)\n{\n  int i;\n  for (i = 0; i < asize; i++) {\n    int temp;\n    if (l + i >= r - i) break;\n    temp = a[l+i];\n    a[l+i] = a[r-i];\n    a[r-i] = temp;\n  }\n}\n\nvoid bfs(int *a, int asize, char *memo, int depth, int maxdepth)\n{\n  int i, j;\n  if (depth >= maxdepth) return;\n  for (i = 0; i < asize; i++) {\n    for (j = i + 1; j < asize; j++) {\n      int h;\n      rev_sort(i, j, a, asize);\n      h = hash(a, asize);\n      if (memo[h] > depth + 1) {\n        memo[h] = depth + 1;\n        bfs(a, asize, memo, depth + 1, maxdepth);\n      }\n      rev_sort(i, j, a, asize);\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define NMAX 10\n#define FMAX 3628800\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nint hash(int *a, int asize);\nvoid rev_sort(int l, int r, int *a, int asize);\nvoid bfs(int *a, int asize, char *memo, int depth);\nint main (void)\n{\n  int i, n, fact = 1, res = 9, a[NMAX], b[NMAX];\n  char memo1[FMAX], memo2[FMAX];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    fact *= i + 1;\n    b[i] = i + 1;\n  }\n  for (i = 0; i < fact; i++) memo1[i] = memo2[i] = n;\n  memo1[hash(a, n)] = memo2[hash(b, n)] = 0;\n  bfs(a, n, memo1, 0);\n  bfs(b, n, memo2, 0);\n  for (i = 0; i < fact; i++) res = min(res, memo1[i] + memo2[i]);\n  printf(\"%d\\n\", res);\n}\n\nint hash(int *a, int asize)\n{\n  int i, j, res = 0, fact = 1;\n  for (i = 0; i < asize; i++) {\n    int grade = 0;\n    for (j = i + 1; j < asize; j++) if (a[i] < a[j]) grade++;\n    res += grade * fact;\n    fact *= asize - i;\n  }\n  return res;\n}\n\nvoid rev_sort(int l, int r, int *a, int asize)\n{\n  int i;\n  for (i = 0; i < asize; i++) {\n    int temp;\n    if (l + i >= r - i) break;\n    temp = a[l+i];\n    a[l+i] = a[r-i];\n    a[r-i] = temp;\n  }\n}\n\nvoid bfs(int *a, int asize, char *memo, int depth)\n{\n  int i, j;\n  if (depth >= 4) return;\n  for (i = 0; i < asize; i++) {\n    for (j = i + 1; j < asize; j++) {\n      int h;\n      rev_sort(i, j, a, asize);\n      h = hash(a, asize);\n      if (memo[h] > depth + 1) {\n        memo[h] = depth + 1;\n        bfs(a, asize, memo, depth + 1);\n      }\n      rev_sort(i, j, a, asize);\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define NMAX 10\n#define FMAX 3628800\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nint hash(int *a, int asize);\nvoid rev_sort(int l, int r, int *a, int asize);\nvoid bfs(int *a, int asize, char *memo, int depth);\nint main (void)\n{\n  int i, n, fact = 1, res = 9, a[NMAX], b[NMAX];\n  char memo1[FMAX], memo2[FMAX];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    fact *= i + 1;\n    b[i] = i + 1;\n  }\n  for (i = 0; i < fact; i++) memo1[i] = memo2[i] = 20;\n  memo1[hash(a, n)] = memo2[hash(b, n)] = 0;\n  bfs(a, n, memo1, 0);\n  bfs(b, n, memo2, 0);\n  for (i = 0; i < fact; i++) res = min(res, memo1[i] + memo2[i]);\n  printf(\"%d\\n\", res);\n}\n\nint hash(int *a, int asize)\n{\n  int i, j, res = 0, fact = 1;\n  for (i = 0; i < asize; i++) {\n    int grade = 0;\n    for (j = i + 1; j < asize; j++) if (a[i] < a[j]) grade++;\n    res += grade * fact;\n    fact *= asize - i;\n  }\n  return res;\n}\n\nvoid rev_sort(int l, int r, int *a, int asize)\n{\n  int i;\n  for (i = 0; i < asize; i++) {\n    int temp;\n    if (l + i >= r - i) break;\n    temp = a[l+i];\n    a[l+i] = a[r-i];\n    a[r-i] = temp;\n  }\n}\n\nvoid bfs(int *a, int asize, char *memo, int depth)\n{\n  int i, j;\n  if (depth >= 4) return;\n  for (i = 0; i < asize; i++) {\n    for (j = i + 1; j < asize; j++) {\n      int h;\n      rev_sort(i, j, a, asize);\n      h = hash(a, asize);\n      if (memo[h] > depth + 1) {\n        memo[h] = depth + 1;\n        bfs(a, asize, memo, depth + 1);\n      }\n      rev_sort(i, j, a, asize);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// ReverseSort\n// 2012/09/19\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\n\tint n;\n\tint[] a;\n\n\tint base=50;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\ta=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\ta[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tHashMap<Long, Integer> map1=hoge(a);\n\t\tint[] b=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tb[i]=i+1;\n\t\t}\n\t\tHashMap<Long, Integer> map2=hoge(b);\n\t\tint min=INF;\n\t\tfor(Entry<Long, Integer> entry : map1.entrySet()){\n\t\t\tlong hash=entry.getKey();\n\t\t\tint num=entry.getValue();\n\t\t\tif(map2.containsKey(hash)){\n\t\t\t\tmin=min(min, num+map2.get(hash));\n\t\t\t}\n\t\t}\n\t\tif(min<INF){\n\t\t\tprintln(min+\"\");\n\t\t}else{\n\t\t\t// answer > 4+4\n\t\t\tprintln(\"9\");\n\t\t}\n\t}\n\n\tHashMap<Long, Integer> hoge(int[] a){\n\t\tHashMap<Long, Integer> map=new HashMap<Long, Integer>();\n\t\tLinkedList<Long> que=new LinkedList<Long>();\n\n\t\tlong[] pow=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpow[i]=(long)pow(base, i);\n\t\t}\n\n\t\tlong hash0=hash(a);\n\t\tmap.put(hash0, 0);\n\t\tque.offer(hash0);\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tlong hash=que.poll();\n\t\t\tif(map.get(hash)>=4){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int cent=0; cent<n; cent++){\n\t\t\t\t// odd length\n\t\t\t\tlong hashO=hash;\n\t\t\t\tfor(int w=1; cent-w>=0&&cent+w<n; w++){\n\t\t\t\t\t// [cent-w, cent+w]\n\t\t\t\t\tlong i=hashO/pow[cent-w]%base;\n\t\t\t\t\tlong j=hashO/pow[cent+w]%base;\n\t\t\t\t\thashO=hashO+(-i+j)*pow[cent-w]+(-j+i)*pow[cent+w];\n\t\t\t\t\tif(!map.containsKey(hashO)){\n\t\t\t\t\t\tmap.put(hashO, map.get(hash)+1);\n\t\t\t\t\t\tque.offer(hashO);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// even length\n\t\t\t\tlong hashE=hash;\n\t\t\t\tfor(int w=0; cent-w>=0&&cent+1+w<n; w++){\n\t\t\t\t\t// [cent-w, cent+1+w]\n\t\t\t\t\tlong i=hashE/pow[cent-w]%base;\n\t\t\t\t\tlong j=hashE/pow[cent+1+w]%base;\n\t\t\t\t\thashE=hashE+(-i+j)*pow[cent-w]+(-j+i)*pow[cent+1+w];\n\t\t\t\t\tif(!map.containsKey(hashE)){\n\t\t\t\t\t\tmap.put(hashE, map.get(hash)+1);\n\t\t\t\t\t\tque.offer(hashE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\tlong hash(int[] _){\n\t\tlong hash=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\thash=hash*base+_[i];\n\t\t}\n\t\treturn hash;\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\t// long cur = System.currentTimeMillis();\n\t\tsolver();\n\t\t// System.out.println(System.currentTimeMillis() - cur + \"ms\");\n\t}\n\n\tint N;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tans = N - 1;\n\t\tint[] A = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tA[i] = sc.nextInt() - 1;\n\t\t}\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tpow10[i] = 10L * pow10[i - 1];\n\t\t}\n\t\tfactorial[0] = 1;\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tfactorial[i] = factorial[i - 1] *(long) i;\n\t\t}\n\t\tmemo=new int[(int)factorial[N]];\n\t\tArrays.fill(memo, -1);\n\t\tenumerate(A);\n\t\tArrays.sort(A);\n\t\tsecond = true;\n\t\tenumerate(A);\n\t\tSystem.out.println(ans);\n\t}\n\n\tint ans;\n\tboolean second = false;\n\n\tlong[] pow10 = new long[11];\n\tint[] memo;\n\tlong[] factorial = new long[11];\n\n\tArrayList<Long> enumerate(int[] A) {\n\t\tlong a = to_long(A);\n\t\tArrayDeque<Long> cur_que = new ArrayDeque<>();\n\t\tcur_que.add(a);\n\t\tArrayDeque<Long> next_que = new ArrayDeque<>();\n\t\tArrayList<Long> ret = new ArrayList<>();\n\t\tret.add(a);\n\t\tint index = numbering(to_array(a));\n\t\tif (memo[index] != -1) {\n\t\t\tans = Math.min(memo[index], ans);\n\t\t}\n\n\t\tmemo[index] = 0 + (second ? 10 : 0);\n\t\tfor (int i = 1; i <= N / 2 - ((N % 2 == 0) ? 1 : 0); i++) {\n\t\t\twhile (!cur_que.isEmpty()) {\n\t\t\t\tlong cur = cur_que.poll();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\t\t\tint[] tmp = to_array(cur);\n\t\t\t\t\t\tint s = j, t = k;\n\t\t\t\t\t\twhile (s < t) {\n\t\t\t\t\t\t\tint dummy = tmp[s];\n\t\t\t\t\t\t\ttmp[s] = tmp[t];\n\t\t\t\t\t\t\ttmp[t] = dummy;\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong dummy = to_long(tmp);\n\t\t\t\t\t\tint idx = numbering(tmp);\n\t\t\t\t\t\tif (memo[idx] == -1) {\n\t\t\t\t\t\t\tnext_que.add(dummy);\n\t\t\t\t\t\t\tmemo[idx] = i + (second ? 100 : 0);\n\t\t\t\t\t\t} else if (memo[idx] < 100 && second) {\n\t\t\t\t\t\t\tans = Math.min(memo[idx] + i, ans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.addAll(next_que);\n\t\t\tcur_que.addAll(next_que);\n\t\t\tnext_que.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint numbering(int[] permutation) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < permutation.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (permutation[i] > permutation[j])\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tret += factorial[i] * count;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong to_long(int[] array) {\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tret += pow10[array.length - 1 - i] * array[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint[] to_array(long a) {\n\t\tint[] ret = new int[N];\n\t\tint pos = N - 1;\n\t\twhile (a > 0) {\n\t\t\tret[pos--] = (int) (a % 10);\n\t\t\ta /= 10;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\n\tpublic static void main(String[] arg) {\n\t\tN = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint[] ord = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tord[i] = i + 1;\n\t\t}\n\t\tAr st = new Ar(a);\n\t\tAr ed = new Ar(ord);\n\t\tif (st.equals(ed)) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tHashSet<Ar> forward = new HashSet<Ar>();\n\t\tHashSet<Ar> backward = new HashSet<Ar>();\n\t\tArrayList<Ar> curFor = new ArrayList<Ar>();\n\t\tArrayList<Ar> curBac = new ArrayList<Ar>();\n\t\tforward.add(st);\n\t\tbackward.add(ed);\n\t\tcurFor.add(st);\n\t\tcurBac.add(ed);\n\t\tfor (int i = 0;; ++i) {\n\t\t\tArrayList<Ar> nextFor = new ArrayList<Ar>();\n\t\t\tArrayList<Ar> nextBac = new ArrayList<Ar>();\n\t\t\tfor (Ar ar : curFor) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tfor (int k = 2; j + k <= N; ++k) {\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tAr na = new Ar(ar.a);\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tif (backward.contains(na)) {\n\t\t\t\t\t\t\tSystem.out.println(i * 2 + 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (forward.contains(na)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward.add(na);\n\t\t\t\t\t\tnextFor.add(na);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 4) {\n\t\t\t\tSystem.out.println(10);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (Ar ar : curBac) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tfor (int k = 2; j + k <= N; ++k) {\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tAr na = new Ar(ar.a);\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tif (forward.contains(na)) {\n\t\t\t\t\t\t\tSystem.out.println(i * 2 + 2);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (backward.contains(na)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackward.add(na);\n\t\t\t\t\t\tnextBac.add(na);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurFor = nextFor;\n\t\t\tcurBac = nextBac;\n\t\t}\n\t}\n\n\tstatic void rev(int[] a, int s, int l) {\n\t\tfor (int i = 0; i < l / 2; ++i) {\n\t\t\tint tmp = a[s + i];\n\t\t\ta[s + i] = a[s + l - 1 - i];\n\t\t\ta[s + l - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic class Ar {\n\t\tint[] a;\n\n\t\tAr(int[] ar) {\n\t\t\tthis.a = ar.clone();\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(a);\n\t\t}\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj) return true;\n\t\t\tif (obj == null) return false;\n\t\t\tAr other = (Ar) obj;\n\t\t\treturn Arrays.equals(a, other.a);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n//\t\tlong cur = System.currentTimeMillis();\n\t\tsolver();\n//\t\tSystem.out.println(System.currentTimeMillis() - cur + \"ms\");\n\t}\n\n\tint N;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tans = N - 1;\n\t\tint[] A = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tArrays.fill(memo, -1);\n\t\tenumerate(A);\n\t\tArrays.sort(A);\n\t\tsecond = true;\n\t\tenumerate(A).toArray(new Long[0]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tint ans;\n\tboolean second = false;\n\n\tlong[] pow10 = { 1, 10, 100, 1000, 1000_0, 1000_00, 1000_000, 1000_000_0, 1000_000_00, 1000_000_000L,\n\t\t\t1000_000_000_0L };\n\tint[] memo = new int[3628800];\n\n\tArrayList<Long> enumerate(int[] A) {\n\t\tlong a = to_long(A);\n\t\tArrayDeque<Long> cur_que = new ArrayDeque<>();\n\t\tcur_que.add(a);\n\t\tArrayDeque<Long> next_que = new ArrayDeque<>();\n\t\tArrayList<Long> ret = new ArrayList<>();\n\t\tret.add(a);\n\t\tint index = numbering(to_array(a));\n\t\tif (memo[index] != -1) {\n\t\t\tans = Math.min(memo[index], ans);\n\t\t}\n\t\tmemo[index] = 0 + (second ? 10 : 0);\n\t\tfor (int i = 0; i < N / 2 - ((N % 2 == 0 && second) ? 1 : 0); i++) {\n\t\t\twhile (!cur_que.isEmpty()) {\n\t\t\t\tlong cur = cur_que.poll();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\t\t\tint[] tmp = to_array(cur);\n\t\t\t\t\t\tint s = j, t = k;\n\t\t\t\t\t\twhile (s != t && s > t) {\n\t\t\t\t\t\t\tint dummy = tmp[s];\n\t\t\t\t\t\t\ttmp[s] = tmp[t];\n\t\t\t\t\t\t\ttmp[t] = dummy;\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong dummy = to_long(tmp);\n\t\t\t\t\t\tint idx = numbering(tmp);\n\t\t\t\t\t\tif (memo[idx] == -1) {\n\t\t\t\t\t\t\tnext_que.add(dummy);\n\t\t\t\t\t\t\tmemo[idx] = (i + 1) + (second ? 10 : 0);\n\t\t\t\t\t\t} else if (memo[idx] < 10 && second) {\n\t\t\t\t\t\t\ttr(dummy, memo[idx], i + 1);\n\t\t\t\t\t\t\tans = Math.min(memo[idx] + (i + 1), ans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.addAll(next_que);\n\t\t\tcur_que.addAll(next_que);\n\t\t\tnext_que.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint numbering(int[] permutation) {\n\t\tint factorial = 1;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < permutation.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (permutation[i] > permutation[j])\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tfactorial *= i;\n\t\t\tret += factorial * count;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong to_long(int[] array) {\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tret += pow10[array.length - i - 1] * array[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint[] to_array(long a) {\n\t\tint[] ret = new int[N];\n\t\tint pos = 0;\n\t\twhile (a > 0) {\n\t\t\tret[pos++] = (int) (a % 10);\n\t\t\ta /= 10;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\t// long cur = System.currentTimeMillis();\n\t\tsolver();\n\t\t// System.out.println(System.currentTimeMillis() - cur + \"ms\");\n\t}\n\n\tint N;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tans = N - 1;\n\t\tint[] A = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tA[i] = sc.nextInt() - 1;\n\t\t}\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tpow10[i] = 10L * pow10[i - 1];\n\t\t}\n\t\tfactorial[0] = 1;\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tfactorial[i] = factorial[i - 1] * (long) i;\n\t\t}\n\t\tmemo = new int[(int) factorial[N]];\n\t\tArrays.fill(memo, -1);\n\t\tenumerate(A);\n\t\tArrays.sort(A);\n\t\tsecond = true;\n\t\tenumerate(A);\n\t\tSystem.out.println(ans);\n\t}\n\n\tint ans;\n\tboolean second = false;\n\n\tlong[] pow10 = new long[11];\n\tint[] memo;\n\tlong[] factorial = new long[11];\n\n\tArrayList<Long> enumerate(int[] A) {\n\t\tlong a = to_long(A);\n\t\tArrayDeque<Long> cur_que = new ArrayDeque<>();\n\t\tcur_que.add(a);\n\t\tArrayDeque<Long> next_que = new ArrayDeque<>();\n\t\tArrayList<Long> ret = new ArrayList<>();\n\t\tret.add(a);\n\t\tint index = numbering(to_array(a));\n\t\tif (memo[index] != -1) {\n\t\t\tans = Math.min(memo[index], ans);\n\t\t}\n\n\t\tmemo[index] = 0 + (second ? 10 : 0);\n\t\tfor (int i = 1; i <= N / 2 - ((N % 2 == 0) ? 1 : 0); i++) {\n\t\t\twhile (!cur_que.isEmpty()) {\n\t\t\t\tlong cur = cur_que.poll();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\t\t\tint[] tmp = to_array(cur);\n\t\t\t\t\t\tint s = j, t = k;\n\t\t\t\t\t\twhile (s < t) {\n\t\t\t\t\t\t\tint dummy = tmp[s];\n\t\t\t\t\t\t\ttmp[s] = tmp[t];\n\t\t\t\t\t\t\ttmp[t] = dummy;\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong dummy = to_long(tmp);\n\t\t\t\t\t\tint idx = numbering(tmp);\n\t\t\t\t\t\tif (memo[idx] == -1) {\n\t\t\t\t\t\t\tnext_que.add(dummy);\n\t\t\t\t\t\t\tmemo[idx] = i + (second ? 100 : 0);\n\t\t\t\t\t\t} else if (memo[idx] < 100 && second) {\n\t\t\t\t\t\t\tans = Math.min(memo[idx] + i, ans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.addAll(next_que);\n\t\t\tcur_que.addAll(next_que);\n\t\t\tnext_que.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint numbering(int[] permutation) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < permutation.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (permutation[i] > permutation[j])\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tret += factorial[i] * count;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong to_long(int[] array) {\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tret += pow10[array.length - 1 - i] * array[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint[] to_array(long a) {\n\t\tint[] ret = new int[N];\n\t\tint pos = N - 1;\n\t\twhile (a > 0) {\n\t\t\tret[pos--] = (int) (a % 10);\n\t\t\ta /= 10;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n//\t\tlong cur = System.currentTimeMillis();\n\t\tsolver();\n//\t\tSystem.out.println(System.currentTimeMillis() - cur + \"ms\");\n\t}\n\n\tint N;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tans = N - 1;\n\t\tint[] A = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tArrays.fill(memo, -1);\n\t\tenumerate(A);\n\t\tArrays.sort(A);\n\t\tsecond = true;\n\t\tenumerate(A).toArray(new Long[0]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tint ans;\n\tboolean second = false;\n\n\tlong[] pow10 = { 1, 10, 100, 1000, 1000_0, 1000_00, 1000_000, 1000_000_0, 1000_000_00, 1000_000_000L,\n\t\t\t1000_000_000_0L };\n\tint[] memo = new int[3628800];\n\n\tArrayList<Long> enumerate(int[] A) {\n\t\tlong a = to_long(A);\n\t\tArrayDeque<Long> cur_que = new ArrayDeque<>();\n\t\tcur_que.add(a);\n\t\tArrayDeque<Long> next_que = new ArrayDeque<>();\n\t\tArrayList<Long> ret = new ArrayList<>();\n\t\tret.add(a);\n\t\tint index = numbering(to_array(a));\n\t\tif (memo[index] != -1) {\n\t\t\tans = Math.min(memo[index], ans);\n\t\t}\n\t\tmemo[index] = 0 + (second ? 10 : 0);\n\t\tfor (int i = 0; i < N / 2 - ((N % 2 == 0 && second) ? 1 : 0); i++) {\n\t\t\twhile (!cur_que.isEmpty()) {\n\t\t\t\tlong cur = cur_que.poll();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\t\t\tint[] tmp = to_array(cur);\n\t\t\t\t\t\tint s = j, t = k;\n\t\t\t\t\t\twhile (s != t && s < t) {\n\t\t\t\t\t\t\tint dummy = tmp[s];\n\t\t\t\t\t\t\ttmp[s] = tmp[t];\n\t\t\t\t\t\t\ttmp[t] = dummy;\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong dummy = to_long(tmp);\n\t\t\t\t\t\tint idx = numbering(tmp);\n\t\t\t\t\t\tif (memo[idx] == -1) {\n\t\t\t\t\t\t\tnext_que.add(dummy);\n\t\t\t\t\t\t\tmemo[idx] = (i + 1) + (second ? 10 : 0);\n\t\t\t\t\t\t} else if (memo[idx] < 10 && second) {\n\t\t\t\t\t\t\tans = Math.min(memo[idx] + (i + 1), ans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.addAll(next_que);\n\t\t\tcur_que.addAll(next_que);\n\t\t\tnext_que.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint numbering(int[] permutation) {\n\t\tint factorial = 1;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < permutation.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (permutation[i] > permutation[j])\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tfactorial *= i;\n\t\t\tret += factorial * count;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong to_long(int[] array) {\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tret += pow10[array.length - i - 1] * array[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint[] to_array(long a) {\n\t\tint[] ret = new int[N];\n\t\tint pos = 0;\n\t\twhile (a > 0) {\n\t\t\tret[pos++] = (int) (a % 10);\n\t\t\ta /= 10;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\t// long cur = System.currentTimeMillis();\n\t\tsolver();\n\t\t// System.out.println(System.currentTimeMillis() - cur + \"ms\");\n\t}\n\n\tint N;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tans = N - 1;\n\t\tint[] A = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tArrays.fill(memo, -1);\n\t\tenumerate(A);\n\t\tArrays.sort(A);\n\t\tsecond = true;\n\t\tenumerate(A).toArray(new Long[0]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tint ans;\n\tboolean second = false;\n\n\tlong[] pow10 = { 1, 10, 100, 1000, 1000_0, 1000_00, 1000_000, 1000_000_0, 1000_000_00, 1000_000_000L,\n\t\t\t1000_000_000_0L };\n\tint[] memo = new int[3628800];\n\tlong[] rev = new long[3628800];\n\n\tArrayList<Long> enumerate(int[] A) {\n\t\tlong a = to_long(A);\n\t\tArrayDeque<Long> cur_que = new ArrayDeque<>();\n\t\tcur_que.add(a);\n\t\tArrayDeque<Long> next_que = new ArrayDeque<>();\n\t\tArrayList<Long> ret = new ArrayList<>();\n\t\tret.add(a);\n\t\tint index = numbering(to_array(a));\n\t\tif (memo[index] != -1) {\n\t\t\tans = Math.min(memo[index], ans);\n\t\t}\n\t\tmemo[index] = 0 + (second ? 10 : 0);\n\t\tfor (int i = 0; i < N / 2 - ((N % 2 == 0 && second) ? 1 : 0); i++) {\n\t\t\twhile (!cur_que.isEmpty()) {\n\t\t\t\tlong cur = cur_que.poll();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\t\t\tint[] tmp = to_array(cur);\n\t\t\t\t\t\tint s = j, t = k;\n\t\t\t\t\t\twhile (s < t) {\n\t\t\t\t\t\t\tint dummy = tmp[s];\n\t\t\t\t\t\t\ttmp[s] = tmp[t];\n\t\t\t\t\t\t\ttmp[t] = dummy;\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong dummy = to_long(tmp);\n\t\t\t\t\t\tint idx = numbering(tmp);\n\t\t\t\t\t\tif (memo[idx] == -1) {\n\t\t\t\t\t\t\tnext_que.add(dummy);\n\t\t\t\t\t\t\trev[idx]=dummy;\n\t\t\t\t\t\t\tmemo[idx] = (i + 1) + (second ? 10 : 0);\n\t\t\t\t\t\t} else if (memo[idx] < 10 && second) {\n\t\t\t\t\t\t\tans = Math.min(memo[idx] + (i + 1), ans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.addAll(next_que);\n\t\t\tcur_que.addAll(next_que);\n\t\t\tnext_que.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint numbering(int[] permutation) {\n\t\tint factorial = 1;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < permutation.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (permutation[i] > permutation[j])\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (i != 0)\n\t\t\t\tfactorial *= i;\n\t\t\tret += factorial * count;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong to_long(int[] array) {\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tret += pow10[array.length - i - 1] * array[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint[] to_array(long a) {\n\t\tint[] ret = new int[N];\n\t\tint pos = N-1;\n\t\twhile (a > 0) {\n\t\t\tret[pos--] = (int) (a % 10);\n\t\t\ta /= 10;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\t// long cur = System.currentTimeMillis();\n\t\tsolver();\n\t\t// System.out.println(System.currentTimeMillis() - cur + \"ms\");\n\t}\n\n\tint N;\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tans = N - 1;\n\t\tint[] A = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tA[i] = sc.nextInt() - 1;\n\t\t}\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tpow10[i] = 10L * pow10[i - 1];\n\t\t}\n\t\tfactorial[0] = 1;\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tfactorial[i] = factorial[i - 1] *(long) i;\n\t\t}\n\n\t\tArrays.fill(memo, -1);\n\t\tenumerate(A);\n\t\tArrays.sort(A);\n\t\tsecond = true;\n\t\tenumerate(A).toArray(new Long[0]);\n\t\tSystem.out.println(ans);\n\t}\n\n\tint ans;\n\tboolean second = false;\n\n\tlong[] pow10 = new long[11];\n\tint[] memo = new int[3628800];\n\tlong[] factorial = new long[11];\n\n\tArrayList<Long> enumerate(int[] A) {\n\t\tlong a = to_long(A);\n\t\tArrayDeque<Long> cur_que = new ArrayDeque<>();\n\t\tcur_que.add(a);\n\t\tArrayDeque<Long> next_que = new ArrayDeque<>();\n\t\tArrayList<Long> ret = new ArrayList<>();\n\t\tret.add(a);\n\t\tint index = numbering(to_array(a));\n\t\tif (memo[index] != -1) {\n\t\t\tans = Math.min(memo[index], ans);\n\t\t}\n\n\t\tmemo[index] = 0 + (second ? 10 : 0);\n\t\tfor (int i = 1; i <= N / 2 - ((N % 2 == 0) ? 1 : 0); i++) {\n\t\t\twhile (!cur_que.isEmpty()) {\n\t\t\t\tlong cur = cur_que.poll();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tfor (int k = j + 1; k < N; k++) {\n\t\t\t\t\t\tint[] tmp = to_array(cur);\n\t\t\t\t\t\tint s = j, t = k;\n\t\t\t\t\t\twhile (s < t) {\n\t\t\t\t\t\t\tint dummy = tmp[s];\n\t\t\t\t\t\t\ttmp[s] = tmp[t];\n\t\t\t\t\t\t\ttmp[t] = dummy;\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tt--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlong dummy = to_long(tmp);\n\t\t\t\t\t\tint idx = numbering(tmp);\n\t\t\t\t\t\tif (memo[idx] == -1) {\n\t\t\t\t\t\t\tnext_que.add(dummy);\n\t\t\t\t\t\t\tmemo[idx] = i + (second ? 100 : 0);\n\t\t\t\t\t\t} else if (memo[idx] < 100 && second) {\n\t\t\t\t\t\t\tans = Math.min(memo[idx] + i, ans);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.addAll(next_que);\n\t\t\tcur_que.addAll(next_que);\n\t\t\tnext_que.clear();\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint numbering(int[] permutation) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < permutation.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (permutation[i] > permutation[j])\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tret += factorial[i] * count;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tlong to_long(int[] array) {\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tret += pow10[array.length - 1 - i] * array[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint[] to_array(long a) {\n\t\tint[] ret = new int[N];\n\t\tint pos = N - 1;\n\t\twhile (a > 0) {\n\t\t\tret[pos--] = (int) (a % 10);\n\t\t\ta /= 10;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int n, i, j, tmp;\n    int[] a, b;\n\n    n = sc.nextInt();\n    a = new int[n]; b = new int[n];\n    for(i = 0;i < n;i++){\n      a[i] = sc.nextInt(); b[i] = a[i];\n    }\n    for(i = 0;i < n - 1;i++)for(j = 0;j < n - 1 - i;j++)if(b[j] > b[j + 1]){\n      tmp = b[j]; b[j] = b[j + 1]; b[j + 1] = tmp;\n    }\n    out.println(solve(n, a, b));\n\n    sc.close();\n  }\n  private static int solve(int n, int[] a, int[] b){\n    int i, l, r, min, max, count, res1, res2;\n    boolean x, y;\n    l = 0; r = n - 1; count = 0; x = true; y = true;\n    for(i = 0;i < n;i++){\n      if(a[i] == b[i])count++;\n      if(a[i] == b[i] && x)l++;\n      else x = false;\n      if(a[n - 1 - i] == b[n - 1 - i] && y)r--;\n      else y = false;\n    }\n    if(count == n)return 0;\n\n    min = l; max = l;\n    for(i = l;i <= r;i++){\n      if(a[min] > a[i])min = i;\n      if(a[max] < a[i])max = i;\n    }\n    reverse(a, l, min);\n    res1 = solve(n, a, b);\n    reverse(a, l, min);\n    reverse(a, max, r);\n    res2 = solve(n, a, b);\n    reverse(a, max, r);\n    if(res1 > res2)res1 = res2;\n    return res1 + 1;\n  }\n  private static void reverse(int[] a, int l, int r){\n    int i, tmp;\n    for(i = 0;i < (r - l + 1) / 2;i++){\n      tmp = a[l + i]; a[l + i] = a[r - i]; a[r - i] = tmp;\n    }\n    return;\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n??\npublic class Main{\n????????public static void main(String[] args) {\n????????????????new Main().run();\n????????}\n??\n????????void run() {\n????????????????// long cur = System.currentTimeMillis();\n????????????????solver();\n????????????????// System.out.println(System.currentTimeMillis() - cur + \"ms\");\n????????}\n??\n????????int N;\n??\n????????@SuppressWarnings(\"rawtypes\")\n????????void solver() {\n????????????????Scanner sc = new Scanner(System.in);\n????????????????N = sc.nextInt();\n????????????????ans = N - 1;\n????????????????int[] A = new int[N];\n????????????????for (int i = 0; i < N; i++) {\n????????????????????????A[i] = sc.nextInt() - 1;\n????????????????}\n????????????????pow10[0] = 1;\n????????????????for (int i = 1; i <= 10; i++) {\n????????????????????????pow10[i] = 10L * pow10[i - 1];\n????????????????}\n????????????????factorial[0] = 1;\n????????????????for (int i = 1; i <= 10; i++) {\n????????????????????????factorial[i] = factorial[i - 1] *(long) i;\n????????????????}\n????????????????memo=new int[(int)factorial[N]];\n????????????????Arrays.fill(memo, -1);\n????????????????enumerate(A);\n????????????????Arrays.sort(A);\n????????????????second = true;\n????????????????enumerate(A);\n????????????????System.out.println(ans);\n????????}\n??\n????????int ans;\n????????boolean second = false;\n??\n????????long[] pow10 = new long[11];\n????????int[] memo;\n????????long[] factorial = new long[11];\n??\n????????ArrayList<Long> enumerate(int[] A) {\n????????????????long a = to_long(A);\n????????????????ArrayDeque<Long> cur_que = new ArrayDeque<>();\n????????????????cur_que.add(a);\n????????????????ArrayDeque<Long> next_que = new ArrayDeque<>();\n????????????????ArrayList<Long> ret = new ArrayList<>();\n????????????????ret.add(a);\n????????????????int index = numbering(to_array(a));\n????????????????if (memo[index] != -1) {\n????????????????????????ans = Math.min(memo[index], ans);\n????????????????}\n??\n????????????????memo[index] = 0 + (second ? 10 : 0);\n????????????????for (int i = 1; i <= N / 2 - ((N % 2 == 0) ? 1 : 0); i++) {\n????????????????????????while (!cur_que.isEmpty()) {\n????????????????????????????????long cur = cur_que.poll();\n????????????????????????????????for (int j = 0; j < N; j++) {\n????????????????????????????????????????for (int k = j + 1; k < N; k++) {\n????????????????????????????????????????????????int[] tmp = to_array(cur);\n????????????????????????????????????????????????int s = j, t = k;\n????????????????????????????????????????????????while (s < t) {\n????????????????????????????????????????????????????????int dummy = tmp[s];\n????????????????????????????????????????????????????????tmp[s] = tmp[t];\n????????????????????????????????????????????????????????tmp[t] = dummy;\n????????????????????????????????????????????????????????s++;\n????????????????????????????????????????????????????????t--;\n????????????????????????????????????????????????}\n????????????????????????????????????????????????long dummy = to_long(tmp);\n????????????????????????????????????????????????int idx = numbering(tmp);\n????????????????????????????????????????????????if (memo[idx] == -1) {\n????????????????????????????????????????????????????????next_que.add(dummy);\n????????????????????????????????????????????????????????memo[idx] = i + (second ? 100 : 0);\n????????????????????????????????????????????????} else if (memo[idx] < 100 && second) {\n????????????????????????????????????????????????????????ans = Math.min(memo[idx] + i, ans);\n????????????????????????????????????????????????}\n????????????????????????????????????????}\n????????????????????????????????}\n????????????????????????}\n????????????????????????ret.addAll(next_que);\n????????????????????????cur_que.addAll(next_que);\n????????????????????????next_que.clear();\n????????????????}\n????????????????return ret;\n????????}\n??\n????????int numbering(int[] permutation) {\n????????????????int ret = 0;\n????????????????for (int i = 0; i < permutation.length; i++) {\n????????????????????????int count = 0;\n????????????????????????for (int j = i - 1; j >= 0; j--) {\n????????????????????????????????if (permutation[i] > permutation[j])\n????????????????????????????????????????count++;\n????????????????????????}\n????????????????????????ret += factorial[i] * count;\n????????????????}\n????????????????return ret;\n????????}\n??\n????????long to_long(int[] array) {\n????????????????long ret = 0;\n????????????????for (int i = 0; i < array.length; i++) {\n????????????????????????ret += pow10[array.length - 1 - i] * array[i];\n????????????????}\n????????????????return ret;\n????????}\n??\n????????int[] to_array(long a) {\n????????????????int[] ret = new int[N];\n????????????????int pos = N - 1;\n????????????????while (a > 0) {\n????????????????????????ret[pos--] = (int) (a % 10);\n????????????????????????a /= 10;\n????????????????}\n????????????????return ret;\n????????}\n??\n????????void tr(Object... o) {\n????????????????System.out.println(Arrays.deepToString(o));\n????????}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n??\npublic class Main{\n????????public static void main(String[] args) {\n????????????????new Main().run();\n????????}\n??\n????????void run() {\n????????????????// long cur = System.currentTimeMillis();\n????????????????solver();\n????????????????// System.out.println(System.currentTimeMillis() - cur + \"ms\");\n????????}\n??\n????????int N;\n??\n????????@SuppressWarnings(\"rawtypes\")\n????????void solver() {\n????????????????Scanner sc = new Scanner(System.in);\n????????????????N = sc.nextInt();\n????????????????ans = N - 1;\n????????????????int[] A = new int[N];\n????????????????for (int i = 0; i < N; i++) {\n????????????????????????A[i] = sc.nextInt() - 1;\n????????????????}\n????????????????pow10[0] = 1;\n????????????????for (int i = 1; i <= 10; i++) {\n????????????????????????pow10[i] = 10L * pow10[i - 1];\n????????????????}\n????????????????factorial[0] = 1;\n????????????????for (int i = 1; i <= 10; i++) {\n????????????????????????factorial[i] = factorial[i - 1] *(long) i;\n????????????????}\n????????????????memo=new int[(int)factorial[N]];\n????????????????Arrays.fill(memo, -1);\n????????????????enumerate(A);\n????????????????Arrays.sort(A);\n????????????????second = true;\n????????????????enumerate(A);\n????????????????System.out.println(ans);\n????????}\n??\n????????int ans;\n????????boolean second = false;\n??\n????????long[] pow10 = new long[11];\n????????int[] memo;\n????????long[] factorial = new long[11];\n??\n????????ArrayList<Long> enumerate(int[] A) {\n????????????????long a = to_long(A);\n????????????????ArrayDeque<Long> cur_que = new ArrayDeque<>();\n????????????????cur_que.add(a);\n????????????????ArrayDeque<Long> next_que = new ArrayDeque<>();\n????????????????ArrayList<Long> ret = new ArrayList<>();\n????????????????ret.add(a);\n????????????????int index = numbering(to_array(a));\n????????????????if (memo[index] != -1) {\n????????????????????????ans = Math.min(memo[index], ans);\n????????????????}\n??\n????????????????memo[index] = 0 + (second ? 10 : 0);\n????????????????for (int i = 1; i <= N / 2 - ((N % 2 == 0) ? 1 : 0); i++) {\n????????????????????????while (!cur_que.isEmpty()) {\n????????????????????????????????long cur = cur_que.poll();\n????????????????????????????????for (int j = 0; j < N; j++) {\n????????????????????????????????????????for (int k = j + 1; k < N; k++) {\n????????????????????????????????????????????????int[] tmp = to_array(cur);\n????????????????????????????????????????????????int s = j, t = k;\n????????????????????????????????????????????????while (s < t) {\n????????????????????????????????????????????????????????int dummy = tmp[s];\n????????????????????????????????????????????????????????tmp[s] = tmp[t];\n????????????????????????????????????????????????????????tmp[t] = dummy;\n????????????????????????????????????????????????????????s++;\n????????????????????????????????????????????????????????t--;\n????????????????????????????????????????????????}\n????????????????????????????????????????????????long dummy = to_long(tmp);\n????????????????????????????????????????????????int idx = numbering(tmp);\n????????????????????????????????????????????????if (memo[idx] == -1) {\n????????????????????????????????????????????????????????next_que.add(dummy);\n????????????????????????????????????????????????????????memo[idx] = i + (second ? 100 : 0);\n????????????????????????????????????????????????} else if (memo[idx] < 100 && second) {\n????????????????????????????????????????????????????????ans = Math.min(memo[idx] + i, ans);\n????????????????????????????????????????????????}\n????????????????????????????????????????}\n????????????????????????????????}\n????????????????????????}\n????????????????????????ret.addAll(next_que);\n????????????????????????cur_que.addAll(next_que);\n????????????????????????next_que.clear();\n????????????????}\n????????????????return ret;\n????????}\n??\n????????int numbering(int[] permutation) {\n????????????????int ret = 0;\n????????????????for (int i = 0; i < permutation.length; i++) {\n????????????????????????int count = 0;\n????????????????????????for (int j = i - 1; j >= 0; j--) {\n????????????????????????????????if (permutation[i] > permutation[j])\n????????????????????????????????????????count++;\n????????????????????????}\n????????????????????????ret += factorial[i] * count;\n????????????????}\n????????????????return ret;\n????????}\n??\n????????long to_long(int[] array) {\n????????????????long ret = 0;\n????????????????for (int i = 0; i < array.length; i++) {\n????????????????????????ret += pow10[array.length - 1 - i] * array[i];\n????????????????}\n????????????????return ret;\n????????}\n??\n????????int[] to_array(long a) {\n????????????????int[] ret = new int[N];\n????????????????int pos = N - 1;\n????????????????while (a > 0) {\n????????????????????????ret[pos--] = (int) (a % 10);\n????????????????????????a /= 10;\n????????????????}\n????????????????return ret;\n????????}\n??\n????????void tr(Object... o) {\n????????????????System.out.println(Arrays.deepToString(o));\n????????}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\n\tpublic static void main(String[] arg) {\n\t\tN = sc.nextInt();\n\t\tint[] a = new int[N];\n\t\tint[] ord = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tord[i] = i + 1;\n\t\t}\n\t\tAr st = new Ar(a);\n\t\tAr ed = new Ar(ord);\n\t\tif (st.equals(ed)) {\n\t\t\tSystem.out.println(0);\n\t\t\treturn;\n\t\t}\n\t\tHashSet<Ar> forward = new HashSet<Ar>();\n\t\tHashSet<Ar> backward = new HashSet<Ar>();\n\t\tArrayList<Ar> curFor = new ArrayList<Ar>();\n\t\tArrayList<Ar> curBac = new ArrayList<Ar>();\n\t\tforward.add(st);\n\t\tbackward.add(ed);\n\t\tcurFor.add(st);\n\t\tcurBac.add(ed);\n\t\tfor (int i = 0;; ++i) {\n\t\t\tArrayList<Ar> nextFor = new ArrayList<Ar>();\n\t\t\tArrayList<Ar> nextBac = new ArrayList<Ar>();\n\t\t\tfor (Ar ar : curFor) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tfor (int k = 2; j + k <= N; ++k) {\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tAr na = new Ar(ar.a);\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tif (backward.contains(na)) {\n\t\t\t\t\t\t\tSystem.out.println(i * 2 + 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (forward.contains(na)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward.add(na);\n\t\t\t\t\t\tnextFor.add(na);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == 4) {\n\t\t\t\tSystem.out.println(10);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (Ar ar : curBac) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tfor (int k = 2; j + k < N; ++k) {\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tAr na = new Ar(ar.a);\n\t\t\t\t\t\trev(ar.a, j, k);\n\t\t\t\t\t\tif (forward.contains(na)) {\n\t\t\t\t\t\t\tSystem.out.println(i * 2 + 2);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (backward.contains(na)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackward.add(na);\n\t\t\t\t\t\tnextBac.add(na);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurFor = nextFor;\n\t\t\tcurBac = nextBac;\n\t\t}\n\t}\n\n\tstatic void rev(int[] a, int s, int l) {\n\t\tfor (int i = 0; i < l / 2; ++i) {\n\t\t\tint tmp = a[s + i];\n\t\t\ta[s + i] = a[s + l - 1 - i];\n\t\t\ta[s + l - 1 - i] = tmp;\n\t\t}\n\t}\n\n\tstatic class Ar {\n\t\tint[] a;\n\n\t\tAr(int[] ar) {\n\t\t\tthis.a = ar.clone();\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(a);\n\t\t}\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj) return true;\n\t\t\tif (obj == null) return false;\n\t\t\tAr other = (Ar) obj;\n\t\t\treturn Arrays.equals(a, other.a);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tHashMap<Long,Long> map = new HashMap<Long,Long>();\n\t\tHashMap<Long,Long> map2 = new HashMap<Long,Long>();\n\t\tQueue<Long> que = new ArrayDeque<Long>();\n\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tLong N = sc.nextLong();\n\t\t\t{\n\t\t\t\tLong num = 0L;\n\t\t\t\tfor(Long i = 0L; i < N; i++){\n\t\t\t\t\tnum <<= 4;\n\t\t\t\t\tnum += i + 1;\n\t\t\t\t}\t\n\t\t\t\tmap.put(num, 0L);\n\t\t\t\tque.add(num);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tLong now = que.poll();\n\t\t\t\tif(now == null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//System.out.println(now + \" \" + map.get(now));\n\t\t\t\tif(map.get(now) == 3){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\t\t\tLong next = now;\n\t\t\t\t\t\tfor(int k = 0; k < (j - i + 1) / 2; k++){\n\t\t\t\t\t\t\tLong num1 = (next >> ((i + k)*4)) % 16;\n\t\t\t\t\t\t\tnext -= (num1 << ((i + k) * 4));\n\t\t\t\t\t\t\tLong num2 = (next >> ((j - k)*4)) % 16;\n\t\t\t\t\t\t\tnext -= num2 << (((j - k) * 4));\n\t\t\t\t\t\t\tnext += num2 << (((i + k) * 4));\n\t\t\t\t\t\t\tnext += num1 << (((j - k) * 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!map.containsKey(next)){\n\t\t\t\t\t\t\tmap.put(next, map.get(now) + 1);\n\t\t\t\t\t\t\tque.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLong ans = N - 1;\n\n\t\t\t{\n\t\t\t\tLong num = 0L;\n\t\t\t\tfor(Long i = 0L; i < N; i++){\n\t\t\t\t\tnum <<= 4;\n\t\t\t\t\tnum += sc.nextLong();\n\t\t\t\t}\t\n\t\t\t\tmap2.put(num, 0L);\n\t\t\t\tque.add(num);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tLong now = que.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now == null){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map2.containsKey(now)){\n\t\t\t\t\tif(map.containsKey(now) ){\n\t\t\t\t\t\tans = Math.min(ans, map.get(now) + map2.get(now));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map2.get(now) == 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\t\tfor(int j = i + 1; j < N; j++){\n\t\t\t\t\t\tLong next = now;\n\t\t\t\t\t\tfor(int k = 0; k < (j - i + 1) / 2; k++){\n\t\t\t\t\t\t\tLong num1 = (next >> ((i + k)*4)) % 16;\n\t\t\t\t\t\t\tnext -= (num1 << ((i + k) * 4));\n\t\t\t\t\t\t\tLong num2 = (next >> ((j - k)*4)) % 16;\n\t\t\t\t\t\t\tnext -= num2 << (((j - k) * 4));\n\t\t\t\t\t\t\tnext += num2 << (((i + k) * 4));\n\t\t\t\t\t\t\tnext += num1 << (((j - k) * 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!map2.containsKey(next)){\n\t\t\t\t\t\t\tmap2.put(next, map2.get(now) + 1);\n\t\t\t\t\t\t\tque.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = ri;\n            var a = Enumerate(n, x => ri - 1);\n            var ans = n - 1;\n            HashMap<long> A = new HashMap<Number>(), B = new HashMap<Number>();\n            dfs(Enumerate(n, x => x), 0, A);\n            dfs(a, 0, B);\n            foreach (var x in A)\n            {\n                if (x.Value + B[x.Key] < ans)\n                {\n                    ans = x.Value + B[x.Key];\n                    Debug.WriteLine(ans);\n                }\n            }\n            IO.Printer.Out.WriteLine(ans);\n        }\n        void dfs(int[] a, int k, HashMap<long> map)\n        {\n            if (k > 4) return;\n            if (map[f(a)] > k) map[f(a)] = k;\n            else return;\n            for (int l = 0; l < a.Length; l++)\n                for (int len = 2; len <= a.Length - l; len++)\n                {\n                    Array.Reverse(a, l, len);\n                    dfs(a, k + 1, map);\n                    Array.Reverse(a, l, len);\n                }\n        }\n        long f(int[] a)\n        {\n            var ret = 0L;\n            foreach (var x in a) ret = ret * 10 + x;\n            return ret;\n        }\n\n        const int INF = (int)1e9 + 1;\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n#region HashMap<K,V>\npublic class HashMap<K>: Dictionary<K, int>\n//where V : new()\n{\n    public HashMap() : base() { }\n    public HashMap(int cap) : base(cap) { }\n    new public int this[K i]\n    {\n        get\n        {\n            int v;\n            return TryGetValue(i, out v) ? v :\n                base[i] = 10000;\n            //base[i] = new V();\n        }\n        set { base[i] = value; }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\ns = [0] + gets.split.map(&:to_i)\nt = (0..n).to_a\n\nif s == t\n    puts 0\n    exit\nend\n\nf_queue = [s]\nf_dist = {s => 0}\n\nb_queue = [t]\nb_dist = {t => 0}\n\nmin = nil\nTUNING_PARAM = 3\nloop do\n    TUNING_PARAM.times do\n        a = f_queue.shift\n        l = 1\n        l += 1 while a[l] == l\n        r = n\n        r -= 1 while a[r] == r\n        (l..r).to_a.combination(2) do |i, j|\n            b = a.dup\n            (0..(j-i)/2).each do |k|\n                x, y = i + k, j - k\n                b[x], b[y] = b[y], b[x]\n            end\n            next if f_dist[b]\n            f_dist[b] = f_dist[a] + 1\n            if b_dist[b]\n                min = f_dist[b] + b_dist[b]\n                break\n            end\n            f_queue << b\n        end\n        break if min\n    end\n    break if min\n\n    a = b_queue.shift\n    (1..n).to_a.combination(2) do |i, j|\n        b = a.dup\n        (0..(j-i)/2).each do |k|\n            x, y = i + k, j - k\n            b[x], b[y] = b[y], b[x]\n        end\n        next if b_dist[b]\n        b_dist[b] = b_dist[a] + 1\n        if f_dist[b]\n            min = f_dist[b] + b_dist[b]\n            break\n        end\n        b_queue << b\n    end\n    break if min\nend\np min"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nlong[] calc(int x) {\n    long p = 1;\n    long[] Ret;\n    for (int i = 0; i < x; i++) {\n        Ret ~= p;\n        p *= 10;\n    }\n    return Ret;\n}\nstatic P10 = calc(11);\n\nint N;\n\nlong at(long x, long i) {\n    return x % P10[i + 1] / P10[i];\n}\n\nlong reverse(long x, size_t from, size_t to) {\n    //long len = countUntil!((a) => x < a)(P10);\n    //writeln([x, len, from, to]);\n    long len = N;\n    long y = (x % P10[len - from] / P10[len - to]);\n    long z = 0;\n    foreach (i; 0 .. (to - from)) {\n        z += (y % P10[i + 1] / P10[i]) * P10[to - from - i - 1];\n    }\n    static if (false) {\n        writeln(\"a: \", x / P10[len - from] * P10[len - from]);\n        writeln(\"b: \", z * P10[len - to]);\n        writeln(\"c: \", x / P10[len - to]);\n    }\n    return x / P10[len - from] * P10[len - from] + z * P10[len - to] + x % P10[len - to];\n}\n\nvoid main() {\n    scanf(\"%d\\n\", &N);\n    string A = cast(string)(readln.chomp.split(\" \").map!((x) => cast(char)(x.to!int - 1 + '0')).array);\n\n    bool[long] step(in bool[long] x) {\n        bool[long] Ret;\n        foreach (k; x.keys) {\n            foreach (i; 0 .. N) {\n                foreach (j; i + 2 .. N + 1) {\n                    long s = reverse(k, i, j);\n                    Ret[s] = true;\n                }\n            }\n        }\n        return Ret;\n    }\n\n    long x1 = A.to!long;\n    long y1 = (iota(0, N, 1).map!((c) => cast(char)(c + '0')).array).to!long;\n\n    //writeln([x1, y1]);\n\n    bool[long] a = [x1: true],\n               b = [y1: true];\n\n    bool check() {\n        if (a.length > b.length) {\n            foreach (k; b.keys) {\n                if (k in a) return true;\n            }\n        } else {\n            foreach (k; a.keys) {\n                if (k in b) return true;\n            }\n        }\n        return false;\n    }\n\n    for (int i = 0; ; i++) {\n        if (check) {\n            writeln(i * 2);\n            break;\n        }\n        a = step(a);\n        if (check) {\n            writeln(i * 2 + 1);\n            break;\n        }\n        b = step(b);\n    }\n\n    //writeln([a.length, b.length]);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N; scanf(\"%d\\n\", &N);\n    string A = cast(string)(readln.chomp.split(\" \").map!((x) => cast(char)(x.to!int - 1 + '0')).array);\n\n    bool[string] step(in bool[string] x) {\n        bool[string] Ret;\n        foreach (k, v; x) {\n            foreach (i; 0 .. N) {\n                foreach (j; i + 2 .. N + 1) {\n                    char[] r = cast(char[])(k[i .. j].dup);\n                    reverse(r);\n                    string s = k[0 .. i] ~ cast(string)r ~ k[j .. $];\n                    if (s in x) continue;\n                    Ret[s] = true;\n                }\n            }\n        }\n        return Ret;\n    }\n\n    string x1 = A;\n    string y1 = cast(string)(iota(0, N, 1).map!((c) => cast(char)(c + '0')).array);\n\n    //writeln([x1, y1]);\n\n    bool[string] a = [x1: true],\n                 b = [y1: true];\n\n    bool check() {\n        foreach (k, v; a) {\n            if (k in b) return true;\n        }\n        return false;\n    }\n\n    for (int i = 0; ; i++) {\n        if (check) {\n            writeln(i * 2);\n            break;\n        }\n        a = step(a);\n        if (check) {\n            writeln(i * 2 + 1);\n            break;\n        }\n        b = step(b);\n    }\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nlong[] calc(int x) {\n    long p = 1;\n    long[] Ret;\n    for (int i = 0; i < x; i++) {\n        Ret ~= p;\n        p *= 10;\n    }\n    return Ret;\n}\nstatic P10 = calc(11);\n\nint N;\n\nlong at(long x, long i) {\n    return x % P10[i + 1] / P10[i];\n}\n\nlong reverse(long x, size_t from, size_t to) {\n    //long len = countUntil!((a) => x < a)(P10);\n    //writeln([x, len, from, to]);\n    long len = N;\n    long y = (x % P10[len - from] / P10[len - to]);\n    long z = 0;\n    foreach (i; 0 .. (to - from)) {\n        z += (y % P10[i + 1] / P10[i]) * P10[to - from - i - 1];\n    }\n    static if (false) {\n        writeln(\"a: \", x / P10[len - from] * P10[len - from]);\n        writeln(\"b: \", z * P10[len - to]);\n        writeln(\"c: \", x / P10[len - to]);\n    }\n    return x / P10[len - from] * P10[len - from] + z * P10[len - to] + x % P10[len - to];\n}\n\nvoid main() {\n    scanf(\"%d\\n\", &N);\n    string A = cast(string)(readln.chomp.split(\" \").map!((x) => cast(char)(x.to!int - 1 + '0')).array);\n\n    bool[long] step(in bool[long] x) {\n        bool[long] Ret;\n        foreach (k; x.keys) {\n            foreach (i; 0 .. N) {\n                foreach (j; i + 2 .. N + 1) {\n                    long s = reverse(k, i, j);\n                    Ret[s] = true;\n                }\n            }\n        }\n        return Ret;\n    }\n\n    long x1 = A.to!long;\n    long y1 = (iota(0, N, 1).map!((c) => cast(char)(c + '0')).array).to!long;\n\n    //writeln([x1, y1]);\n\n    bool[long] a = [x1: true],\n               b = [y1: true];\n\n    bool check() {\n        if (a.length > b.length) {\n            foreach (k, v; b) {\n                if (k in a) return true;\n            }\n        } else {\n            foreach (k, v; a) {\n                if (k in b) return true;\n            }\n        }\n        return false;\n    }\n\n    for (int i = 0; i < 4; i++) {\n        if (check) {\n            writeln(i * 2);\n            return;\n        }\n        a = step(a);\n        if (check) {\n            writeln(i * 2 + 1);\n            return;\n        }\n        b = step(b);\n    }\n    writeln(9);\n\n    //writeln([a.length, b.length]);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nvoid main() {\n    int N; scanf(\"%d\\n\", &N);\n    string A = readln.chomp.split(\" \").map!((x) => cast(char)(x.to!int - 1 + '0')).array;\n\n    bool[string] step(in bool[string] x) {\n        bool[string] Ret;\n        foreach (k, v; x) {\n            foreach (i; 0 .. N) {\n                foreach (j; i + 2 .. N + 1) {\n                    char[] r = cast(char[])(k[i .. j].dup);\n                    reverse(r);\n                    string s = k[0 .. i] ~ cast(string)r ~ k[j .. $];\n                    if (s in x) continue;\n                    Ret[s] = true;\n                }\n            }\n        }\n        return Ret;\n    }\n\n    string x1 = A;\n    string y1 = iota(0, N, 1).map!((c) => cast(char)(c + '0')).array;\n\n    //writeln([x1, y1]);\n\n    bool[string] a = [x1: true],\n                 b = [y1: true];\n\n    bool check() {\n        foreach (k, v; a) {\n            if (k in b) return true;\n        }\n        return false;\n    }\n\n    for (int i = 0; ; i++) {\n        if (check) {\n            writeln(i * 2);\n            break;\n        }\n        a = step(a);\n        if (check) {\n            writeln(i * 2 + 1);\n            break;\n        }\n        b = step(b);\n    }\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nlong[] calc(int x) {\n    long p = 1;\n    long[] Ret;\n    for (int i = 0; i < x; i++) {\n        Ret ~= p;\n        p *= 10;\n    }\n    return Ret;\n}\nstatic P10 = calc(11);\n\nlong reverse(long x, long len, size_t from, size_t to) {\n    //long len = countUntil!((a) => x < a)(P10);\n    //writeln([x, len, from, to]);\n    long y = (x % P10[len - from] / P10[len - to]);\n    long z = 0;\n    foreach (i; 0 .. (to - from)) {\n        z += (y % P10[i + 1] / P10[i]) * P10[to - from - i - 1];\n    }\n    static if (false) {\n        writeln(\"a: \", x / P10[len - from] * P10[len - from]);\n        writeln(\"b: \", z * P10[len - to]);\n        writeln(\"c: \", x / P10[len - to]);\n    }\n    return x / P10[len - from] * P10[len - from] + z * P10[len - to] + x % P10[len - to];\n}\n\nvoid main() {\n    int N; scanf(\"%d\\n\", &N);\n    string A = cast(string)(readln.chomp.split(\" \").map!((x) => cast(char)(x.to!int - 1 + '0')).array);\n\n    bool[long] step(in bool[long] x) {\n        bool[long] Ret;\n        foreach (k, v; x) {\n            foreach (i; 0 .. N) {\n                foreach (j; i + 2 .. N + 1) {\n                    long s = reverse(k, N, i, j);\n                    //if (s in used) continue;\n                    //used[s] = true;\n                    Ret[s] = true;\n                }\n            }\n        }\n        return Ret;\n    }\n\n    long x1 = A.to!long;\n    long y1 = (iota(0, N, 1).map!((c) => cast(char)(c + '0')).array).to!long;\n\n    //writeln([x1, y1]);\n\n    bool[long] a = [x1: true],\n                 b = [y1: true];\n\n    bool check() {\n        foreach (k, v; a) {\n            if (k in b) return true;\n        }\n        return false;\n    }\n\n    bool[long] a_used = a.dup, b_used = b.dup;\n    for (int i = 0; ; i++) {\n        if (check) {\n            writeln(i * 2);\n            break;\n        }\n        a = step(a);\n        if (check) {\n            writeln(i * 2 + 1);\n            break;\n        }\n        b = step(b);\n    }\n\n    //writeln([a.length, b.length]);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nlong[] calc(int x) {\n    long p = 1;\n    long[] Ret;\n    for (int i = 0; i < x; i++) {\n        Ret ~= p;\n        p *= 10;\n    }\n    return Ret;\n}\nstatic P10 = calc(11);\n\nlong reverse(long x, long len, size_t from, size_t to) {\n    //long len = countUntil!((a) => x < a)(P10);\n    //writeln([x, len, from, to]);\n    long y = (x % P10[len - from] / P10[len - to]);\n    long z = 0;\n    foreach (i; 0 .. (to - from)) {\n        z += (y % P10[i + 1] / P10[i]) * P10[to - from - i - 1];\n    }\n    static if (false) {\n        writeln(\"a: \", x / P10[len - from] * P10[len - from]);\n        writeln(\"b: \", z * P10[len - to]);\n        writeln(\"c: \", x / P10[len - to]);\n    }\n    return x / P10[len - from] * P10[len - from] + z * P10[len - to] + x % P10[len - to];\n}\n\nvoid main() {\n    int N; scanf(\"%d\\n\", &N);\n    string A = cast(string)(readln.chomp.split(\" \").map!((x) => cast(char)(x.to!int - 1 + '0')).array);\n\n    bool[long] step(in bool[long] x, ref bool[long] used) {\n        bool[long] Ret;\n        foreach (k, v; x) {\n            foreach (i; 0 .. N) {\n                foreach (j; i + 2 .. N + 1) {\n                    long s = reverse(k, N, i, j);\n                    if (s in used) continue;\n                    used[s] = true;\n                    Ret[s] = true;\n                }\n            }\n        }\n        return Ret;\n    }\n\n    long x1 = A.to!long;\n    long y1 = (iota(0, N, 1).map!((c) => cast(char)(c + '0')).array).to!long;\n\n    //writeln([x1, y1]);\n\n    bool[long] a = [x1: true],\n                 b = [y1: true];\n\n    bool check() {\n        foreach (k, v; a) {\n            if (k in b) return true;\n        }\n        return false;\n    }\n\n    bool[long] a_used = a.dup, b_used = b.dup;\n    for (int i = 0; ; i++) {\n        if (check) {\n            writeln(i * 2);\n            break;\n        }\n        a = step(a, a_used);\n        if (check) {\n            writeln(i * 2 + 1);\n            break;\n        }\n        b = step(b, b_used);\n    }\n\n    //writeln([a.length, b.length]);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nlong[] calc(int x) {\n    long p = 1;\n    long[] Ret;\n    for (int i = 0; i < x; i++) {\n        Ret ~= p;\n        p *= 10;\n    }\n    return Ret;\n}\nstatic P10 = calc(11);\n\nint N;\n\nlong reverse(long x, size_t from, size_t to) {\n    //long len = countUntil!((a) => x < a)(P10);\n    //writeln([x, len, from, to]);\n    long len = N;\n    long y = (x % P10[len - from] / P10[len - to]);\n    long z = 0;\n    foreach (i; 0 .. (to - from)) {\n        z += (y % P10[i + 1] / P10[i]) * P10[to - from - i - 1];\n    }\n    static if (false) {\n        writeln(\"a: \", x / P10[len - from] * P10[len - from]);\n        writeln(\"b: \", z * P10[len - to]);\n        writeln(\"c: \", x / P10[len - to]);\n    }\n    return x / P10[len - from] * P10[len - from] + z * P10[len - to] + x % P10[len - to];\n}\n\nvoid main() {\n    scanf(\"%d\\n\", &N);\n    string A = cast(string)(readln.chomp.split(\" \").map!((x) => cast(char)(x.to!int - 1 + '0')).array);\n\n    bool[long] step(in bool[long] x) {\n        bool[long] Ret;\n        foreach (k, v; x) {\n            foreach (i; 0 .. N) {\n                foreach (j; i + 2 .. N + 1) {\n                    long s = reverse(k, i, j);\n                    Ret[s] = true;\n                }\n            }\n        }\n        return Ret;\n    }\n\n    long x1 = A.to!long;\n    long y1 = (iota(0, N, 1).map!((c) => cast(char)(c + '0')).array).to!long;\n\n    //writeln([x1, y1]);\n\n    bool[long] a = [x1: true],\n               b = [y1: true];\n\n    bool check() {\n        foreach (k, v; b) {\n            if (k in a) return true;\n        }\n        return false;\n    }\n\n    for (int i = 0; ; i++) {\n        if (check) {\n            writeln(i * 2);\n            break;\n        }\n        a = step(a);\n        if (check) {\n            writeln(i * 2 + 1);\n            break;\n        }\n        b = step(b);\n    }\n\n    //writeln([a.length, b.length]);\n\n}"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nimport sys\nfrom collections import deque\nsys.setrecursionlimit(1000000)\n\t\nsorted_a = \"\"\nm = dict({})\n\ndef dist_a(a):\n\tres = 0\n\tfor i, x in enumerate(a):\n\t\tres += abs(i - int(x))\n\treturn res\n\nN = int(input())\nA = ''.join(list(map(lambda x: str(int(x)-1), input().split())))\nsorted_a = ''.join(list(sorted(A)))\n#i = 1\n#j = 4\n#x = \"03214\"\n#print(A[:i:])\n#print(A[::-1][len(A)-j:len(A)-i:])\n#print(A[j::])\n#print(x[:i:] + x[::-1][len(x)-j:len(x)-i:] + x[j::])\nq = deque()\nq.append((A, 0))\nm[A] = 0\nwhile True:\n\ta, x = q.popleft()\n\tif a in m and m[a] < x:\n\t\tcontinue\n\t#if x == 4:\n\t#\tbreak;\n\t#print(len(m))\n\tif a == sorted_a:\n\t\tprint(x)\n\t\tbreak\n\td_a = dist_a(a)\n\tfor i in range(len(a)):\n\t\tfor j in range(i+2, len(a)+1):\n\t\t\tnext_a = a[:i:] + a[::-1][len(a)-j:len(a)-i:] + a[j::]\n\t\t\tif next_a in m:\n\t\t\t\tcontinue\n\t\t\tif d_a < dist_a(next_a):\n\t\t\t\tcontinue\n\t\t\tq.append((next_a, x+1))\n\t\t\tm[next_a] = x+1\n\t\t\t\n\t\n#print(reverse_a(A, 0))\n\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nimport sys\nfrom collections import deque\nsys.setrecursionlimit(1000000)\n\t\nsorted_a = \"\"\nm = dict({})\n\nN = int(input())\nA = ''.join(list(map(lambda x: str(int(x)-1), input().split())))\nsorted_a = ''.join(list(sorted(A)))\n\nq = deque()\nq.append((A, 0))\nm[A] = 0\nwhile True:\n\ta, x = q.popleft()\n\tif a in m and m[a] < x:\n\t\tcontinue\n\tif x == (len(a)-1) // 2:\n\t\tbreak;\n\n\tfor i in range(len(a)):\n\t\tfor j in range(i+2, len(a)+1):\n\t\t\tnext_a = a[:i:] + a[::-1][len(a)-j:len(a)-i:] + a[j::]\n\t\t\tif next_a in m:\n\t\t\t\tcontinue\n\n\t\t\tq.append((next_a, x+1))\n\t\t\tm[next_a] = x+1\n\t\t\t\nm2 = dict({})\nq = deque()\nq.append((sorted_a, 0))\nm2[sorted_a] = 0\nwhile True:\n\ta, x = q.popleft()\n\tif a in m2 and m2[a] < x:\n\t\tcontinue\n\tif x == (len(a)-1) // 2:\n\t\tbreak;\n\n\tfor i in range(len(a)):\n\t\tfor j in range(i+2, len(a)+1):\n\t\t\tnext_a = a[:i:] + a[::-1][len(a)-j:len(a)-i:] + a[j::]\n\t\t\tif next_a in m2:\n\t\t\t\tcontinue\n\t\t\tq.append((next_a, x+1))\n\t\t\tm2[next_a] = x+1\n\nret = sys.maxsize\nfor a, x in m.items():\n\tif a in m2:\n\t\tret = min(ret, x + m2[a])\n\t\nif ret == sys.maxsize:\n\tprint(len(A) - 1)\nelse:\n\tprint(ret)\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N = int(readline())\n    INF = 10**9\n    A = tuple(map(int, readline().split()))\n    B = tuple(range(1, N+1))\n    def check(N, A, N1):\n        que = [(0, A)]\n        dist = {A: 0}\n        S = [A]\n        B = list(A)\n        for cost in range(N1):\n            T = []\n            for v in S:\n                if dist[v] < cost:\n                    continue\n                for i in range(N):\n                    B[:] = v\n                    for j in range(i+1, N):\n                        B[i:j+1] = reversed(v[i:j+1])\n                        key = tuple(B)\n                        if cost+1 < dist.get(key, N1+1):\n                            dist[key] = cost+1\n                            T.append(key)\n            S = T\n        return dist\n    D0 = check(N, A, (N-1)//2)\n    D1 = check(N, B, (N-1)//2)\n    ans = N-1\n    for state, v in D0.items():\n        if state in D1:\n            ans = min(ans, v + D1[state])\n    write(\"%d\\n\" % ans)\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = LI()\n\n        def search(s,t):\n            n2 = 4\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n                if u == t:\n                    return k\n\n                vd = k + 1\n                for i in range(n):\n                    for j in range(i+1,n):\n                        uv = tuple(u[:i] + u[i:j+1][::-1] + u[j+1:])\n                        if v[uv]:\n                            continue\n                        if d[uv] > vd:\n                            d[uv] = vd\n                            if vd < 4:\n                                heapq.heappush(q, (vd, uv))\n\n            return d\n\n        r1 = search(tuple(a), tuple(range(1,n+1)))\n        if isinstance(r1, int):\n            return r1\n        r2 = search(tuple(range(1,n+1)), tuple(a))\n        r = n - 1\n        for k,v in r1.items():\n            t = v + r2[k]\n            if r > t:\n                r = t\n\n        return r\n\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n        # print('rr', rr[-1])\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]