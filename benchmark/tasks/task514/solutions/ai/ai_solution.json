[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint main() {\n    int N;\n    int a[MAX_N] = {0}, b[MAX_N] = {0};\n    int graph[MAX_N][MAX_N] = {0};\n    \n    scanf(\"%d\", &N);\n    \n    int total_in = 0, total_out = 0;\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &a[i]);\n        total_in += a[i];\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &b[i]);\n        total_out += b[i];\n    }\n    \n    if (total_in != total_out) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        int remaining_out = b[i];\n        for (int j = 1; j <= N && remaining_out > 0; j++) {\n            if (a[j] > 0 && i != j) {\n                graph[i][j] = 1;\n                a[j]--;\n                remaining_out--;\n            }\n        }\n        \n        if (remaining_out > 0) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n    \n    printf(\"YES\\n\");\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (graph[i][j]) {\n                printf(\"%d %d\\n\", i, j);\n            }\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 500\n\nint a[MAXN + 1], b[MAXN + 1];\nint in_degree[MAXN + 1], out_degree[MAXN + 1];\nint adj[MAXN + 1][MAXN + 1];\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i <= N; ++i) {\n        scanf(\"%d\", &a[i]);\n    }\n    for (int i = 0; i <= N; ++i) {\n        scanf(\"%d\", &b[i]);\n    }\n\n    // Check if sum of a_i equals sum of b_i and equals N\n    int sum_a = 0, sum_b = 0;\n    for (int i = 0; i <= N; ++i) {\n        sum_a += a[i];\n        sum_b += b[i];\n    }\n    if (sum_a != N || sum_b != N) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    // Assign in_degree and out_degree to vertices\n    int vertex = 1;\n    for (int deg = 0; deg <= N; ++deg) {\n        for (int j = 0; j < a[deg]; ++j) {\n            in_degree[vertex] = deg;\n            vertex++;\n        }\n    }\n\n    vertex = 1;\n    for (int deg = 0; deg <= N; ++deg) {\n        for (int j = 0; j < b[deg]; ++j) {\n            out_degree[vertex] = deg;\n            vertex++;\n        }\n    }\n\n    // Check if sum of in_degrees equals sum of out_degrees\n    int total_in = 0, total_out = 0;\n    for (int i = 1; i <= N; ++i) {\n        total_in += in_degree[i];\n        total_out += out_degree[i];\n    }\n    if (total_in != total_out) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    // Construct adjacency list using greedy approach\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            if (i == j) continue;\n            while (out_degree[i] > 0 && in_degree[j] > 0) {\n                adj[i][j] = 1;\n                out_degree[i]--;\n                in_degree[j]--;\n            }\n        }\n        // Handle self-loops if needed\n        while (out_degree[i] > 0 && in_degree[i] > 0) {\n            adj[i][i] = 1;\n            out_degree[i]--;\n            in_degree[i]--;\n        }\n    }\n\n    // Verify if all degrees are zero\n    for (int i = 1; i <= N; ++i) {\n        if (out_degree[i] != 0 || in_degree[i] != 0) {\n            printf(\"NO\\n\");\n            return 0;\n        }\n    }\n\n    // Output the graph\n    printf(\"YES\\n\");\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            printf(\"%d \", adj[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> a(N), b(N);\n    for (int i = 0; i < N; ++i) cin >> a[i];\n    for (int i = 0; i < N; ++i) cin >> b[i];\n\n    vector<pair<int, int>> in, out;\n    for (int i = 0; i < N; ++i) {\n        if (a[i] > 0) in.emplace_back(i, a[i]);\n        if (b[i] > 0) out.emplace_back(i, b[i]);\n    }\n\n    sort(in.begin(), in.end());\n    sort(out.begin(), out.end());\n\n    vector<vector<int>> adj(N, vector<int>(N, 0));\n    int i = 0, j = 0;\n    bool possible = true;\n\n    while (i < in.size() && j < out.size()) {\n        int u = out[j].first;\n        int v = in[i].first;\n        int cnt = min(out[j].second, in[i].second);\n        \n        if (u == v) {\n            possible = false;\n            break;\n        }\n        \n        adj[u][v] += cnt;\n        out[j].second -= cnt;\n        in[i].second -= cnt;\n        \n        if (out[j].second == 0) ++j;\n        if (in[i].second == 0) ++i;\n    }\n\n    if (i < in.size() || j < out.size()) possible = false;\n\n    if (!possible) {\n        cout << \"NO\" << endl;\n    } else {\n        cout << \"YES\" << endl;\n        for (int u = 0; u < N; ++u) {\n            for (int v = 0; v < N; ++v) {\n                if (adj[u][v] > 0) {\n                    cout << u + 1 << \" \" << v + 1 << \" \" << adj[u][v] << endl;\n                }\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] a = new int[N];\n        int[] b = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            a[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < N; i++) {\n            b[i] = scanner.nextInt();\n        }\n        \n        if (!isPossible(a, b, N)) {\n            System.out.println(\"NO\");\n            return;\n        }\n        \n        List<Integer> inNodes = new ArrayList<>();\n        List<Integer> outNodes = new ArrayList<>();\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < a[i]; j++) {\n                inNodes.add(i + 1);\n            }\n            for (int j = 0; j < b[i]; j++) {\n                outNodes.add(i + 1);\n            }\n        }\n        \n        Collections.sort(inNodes);\n        Collections.sort(outNodes, Collections.reverseOrder());\n        \n        int[][] graph = new int[N + 1][N + 1];\n        boolean possible = true;\n        \n        for (int i = 0; i < inNodes.size(); i++) {\n            int u = outNodes.get(i);\n            int v = inNodes.get(i);\n            if (u == v) {\n                possible = false;\n                break;\n            }\n            graph[u][v]++;\n        }\n        \n        if (!possible) {\n            System.out.println(\"NO\");\n            return;\n        }\n        \n        System.out.println(\"YES\");\n        for (int u = 1; u <= N; u++) {\n            for (int v = 1; v <= N; v++) {\n                if (graph[u][v] > 0) {\n                    System.out.println(u + \" \" + v);\n                }\n            }\n        }\n    }\n    \n    private static boolean isPossible(int[] a, int[] b, int N) {\n        int sumA = 0;\n        int sumB = 0;\n        for (int i = 0; i < N; i++) {\n            sumA += a[i];\n            sumB += b[i];\n        }\n        if (sumA != sumB) {\n            return false;\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 22:00:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class GraphReconstruction {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        int N = Integer.parseInt(br.readLine());\n        \n        int[] inDegree = new int[N+1];\n        int[] outDegree = new int[N+1];\n        \n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 0; i <= N; i++) {\n            inDegree[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i <= N; i++) {\n            outDegree[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        int totalInDegree = 0;\n        int totalOutDegree = 0;\n        \n        for (int i = 0; i <= N; i++) {\n            totalInDegree += i * inDegree[i];\n            totalOutDegree += i * outDegree[i];\n        }\n        \n        if (totalInDegree != totalOutDegree) {\n            bw.write(\"NO\\n\");\n            bw.flush();\n            return;\n        }\n        \n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        int[] remainingInDegree = Arrays.copyOf(inDegree, N+1);\n        int[] remainingOutDegree = Arrays.copyOf(outDegree, N+1);\n        \n        for (int u = 1; u <= N; u++) {\n            for (int v = 1; v <= N; v++) {\n                if (remainingOutDegree[u] > 0 && remainingInDegree[v] > 0) {\n                    graph.get(u).add(v);\n                    remainingOutDegree[u]--;\n                    remainingInDegree[v]--;\n                }\n            }\n        }\n        \n        boolean possible = true;\n        for (int i = 1; i <= N; i++) {\n            if (remainingInDegree[i] != 0 || remainingOutDegree[i] != 0) {\n                possible = false;\n                break;\n            }\n        }\n        \n        if (!possible) {\n            bw.write(\"NO\\n\");\n        } else {\n            bw.write(\"YES\\n\");\n            for (int u = 1; u <= N; u++) {\n                for (int v : graph.get(u)) {\n                    bw.write(u + \" \" + v + \"\\n\");\n                }\n            }\n        }\n        \n        bw.flush();\n    }\n}",
    "timestamp": "2025-08-05 22:00:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> in_deg(N + 1), out_deg(N + 1);\n    int total_in = 0, total_out = 0;\n    \n    for (int i = 1; i <= N; i++) {\n        cin >> in_deg[i];\n        total_in += in_deg[i];\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        cin >> out_deg[i];\n        total_out += out_deg[i];\n    }\n    \n    if (total_in != total_out) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    \n    vector<vector<int>> graph(N + 1);\n    vector<int> remaining_in(N + 1), remaining_out(N + 1);\n    \n    for (int i = 1; i <= N; i++) {\n        remaining_in[i] = in_deg[i];\n        remaining_out[i] = out_deg[i];\n    }\n    \n    for (int u = 1; u <= N; u++) {\n        for (int v = 1; v <= N; v++) {\n            if (u == v) continue;\n            \n            if (remaining_out[u] > 0 && remaining_in[v] > 0) {\n                graph[u].push_back(v);\n                remaining_out[u]--;\n                remaining_in[v]--;\n            }\n        }\n    }\n    \n    bool possible = true;\n    for (int i = 1; i <= N; i++) {\n        if (remaining_in[i] != 0 || remaining_out[i] != 0) {\n            possible = false;\n            break;\n        }\n    }\n    \n    if (!possible) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    \n    cout << \"YES\" << endl;\n    for (int u = 1; u <= N; u++) {\n        for (int v : graph[u]) {\n            cout << u << \" \" << v << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:00:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_graph(N, in_degrees, out_degrees):\n    if sum(in_degrees) != sum(out_degrees):\n        return \"NO\"\n    \n    in_vertices = [[] for _ in range(N+1)]  \n    out_vertices = [[] for _ in range(N+1)]  \n    \n    for i, count in enumerate(in_degrees):\n        in_vertices[i] = [i] * count\n\n    for i, count in enumerate(out_degrees):\n        out_vertices[i] = [i] * count\n\n    edges = []\n    out_index, in_index = 0, 0\n    out_vertex_count, in_vertex_count = 0, 0\n    \n    for _ in range(N):\n        while out_vertex_count + len(out_vertices[out_index]) <= 0 and out_index < len(out_vertices) - 1:\n            out_index += 1\n        if out_index >= len(out_vertices):\n            break\n        from_vertex = out_vertices[out_index].pop()\n        out_vertex_count -= 1\n\n        while in_vertex_count + len(in_vertices[in_index]) <= 0 and in_index < len(in_vertices) - 1:\n            in_index += 1\n        if in_index >= len(in_vertices):\n            break\n        to_vertex = in_vertices[in_index].pop()\n        in_vertex_count -= 1\n\n        if from_vertex != to_vertex:\n            edges.append((from_vertex, to_vertex))\n            out_vertex_count += 1\n            in_vertex_count += 1\n\n    if len(edges) == sum(out_degrees):\n        result = \"YES\\n\"\n        result += \"\\n\".join(f\"{u} {v}\" for u, v in edges)\n        return result\n\n    return \"NO\"\n\nN = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(find_graph(N, a, b))",
    "timestamp": "2025-08-13 08:24:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DirectedGraphRecovery {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int[] a = new int[N + 1];\n        int[] b = new int[N + 1];\n        \n        for (int i = 0; i <= N; i++) {\n            a[i] = scanner.nextInt();\n        }\n        \n        for (int i = 0; i <= N; i++) {\n            b[i] = scanner.nextInt();\n        }\n        \n        if (isPossible(N, a, b)) {\n            System.out.println(\"YES\");\n            int[] inDegreeCounts = calculateDegreeDistribution(a, N);\n            int[] outDegreeCounts = calculateDegreeDistribution(b, N);\n            List<int[]> edges = new ArrayList<>();\n\n            int p = 0, q = 0;\n            for (int j = 0; j <= N; j++) {\n                for (int k = 0; k < outDegreeCounts[j]; k++) {\n                    while (b[j]-- > 0) {\n                        --inDegreeCounts[p];\n                        --outDegreeCounts[q];\n                        edges.add(new int[]{p, q});\n                        if (inDegreeCounts[p] == 0) p++;\n                        if (outDegreeCounts[q] == 0) q++;\n                    }\n                }\n            }\n\n            for (int[] edge : edges) {\n                System.out.println((edge[0] + 1) + \" \" + (edge[1] + 1));\n            }\n        } else {\n            System.out.println(\"NO\");\n        }\n\n        scanner.close();\n    }\n\n    private static int[] calculateDegreeDistribution(int[] degrees, int N) {\n        int[] degreeDistribution = new int[N];\n        int index = 0;\n        for (int i = 0; i <= N; i++) {\n            Arrays.fill(degreeDistribution, index, index + degrees[i], i);\n            index += degrees[i];\n        }\n        return degreeDistribution;\n    }\n\n    private static boolean isPossible(int N, int[] a, int[] b) {\n        int sumA = 0;\n        int sumB = 0;\n        for (int i = 0; i <= N; i++) {\n            sumA += a[i] * i;\n            sumB += b[i] * i;\n        }\n        return sumA == sumB;\n    }\n}",
    "timestamp": "2025-08-13 08:24:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int a[n + 1], b[n + 1];\n    int total_in = 0, total_out = 0;\n    \n    for (int i = 0; i <= n; ++i) {\n        scanf(\"%d\", &a[i]);\n        total_in += a[i] * i;\n    }\n    \n    for (int i = 0; i <= n; ++i) {\n        scanf(\"%d\", &b[i]);\n        total_out += b[i] * i;\n    }\n    \n    if (total_in != total_out) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    int *in_deg = (int *)malloc(n * sizeof(int));\n    int *out_deg = (int *)malloc(n * sizeof(int));\n    \n    int idx = 0;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < a[i]; ++j) {\n            in_deg[idx++] = i;\n        }\n    }\n\n    idx = 0;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j < b[i]; ++j) {\n            out_deg[idx++] = i;\n        }\n    }\n    \n    int adj[n][n], next_out[n];\n    for (int i = 0; i < n; ++i) {\n        next_out[i] = 0;\n        for (int j = 0; j < n; ++j) {\n            adj[i][j] = 0;\n        }\n    }\n\n    int i = 0, j = 0;\n    while (i < n && j < n) {\n        if (in_deg[i] > 0 && out_deg[j] > 0) {\n            adj[j][next_out[j]++] = i + 1;\n            --in_deg[i];\n            --out_deg[j];\n        }\n        if (in_deg[i] == 0) ++i;\n        if (out_deg[j] == 0) ++j;\n    }\n\n    for (i = 0; i < n; ++i) {\n        if (in_deg[i] > 0 || out_deg[i] > 0) {\n            printf(\"NO\\n\");\n            free(in_deg);\n            free(out_deg);\n            return 0;\n        }\n    }\n    \n    printf(\"YES\\n\");\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < next_out[i]; ++j) {\n            printf(\"%d %d\\n\", i + 1, adj[i][j]);\n        }\n    }\n    \n    free(in_deg);\n    free(out_deg);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:24:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_graph_reconstruction(N, a, b):\n    # Check if total in-degrees and out-degrees match\n    total_in = sum(i * a[i] for i in range(N + 1))\n    total_out = sum(i * b[i] for i in range(N + 1))\n    \n    if total_in != total_out:\n        return \"NO\"\n    \n    # Check vertex count constraint\n    vertices_with_in = sum(a[i] for i in range(N + 1))\n    vertices_with_out = sum(b[i] for i in range(N + 1))\n    \n    if vertices_with_in != N or vertices_with_out != N:\n        return \"NO\"\n    \n    # Reconstruct graph\n    graph = [[] for _ in range(N + 1)]\n    in_degree = [0] * (N + 1)\n    out_degree = [0] * (N + 1)\n    \n    # Create vertices based on out-degree\n    for v in range(1, N + 1):\n        remain_out = b[out_degree[v]]\n        while remain_out > 0:\n            # Find a vertex to connect to\n            for u in range(1, N + 1):\n                if in_degree[u] < a[in_degree[u]]:\n                    graph[v].append(u)\n                    out_degree[v] += 1\n                    in_degree[u] += 1\n                    remain_out -= 1\n                    break\n            \n            # If cannot place more out edges\n            if remain_out > 0 and out_degree[v] == b[out_degree[v] - 1]:\n                return \"NO\"\n    \n    # Verify degree constraints\n    for v in range(1, N + 1):\n        if out_degree[v] != b[out_degree[v]] or in_degree[v] != a[in_degree[v]]:\n            return \"NO\"\n    \n    # Construct output\n    result = [\"YES\"]\n    for v in range(1, N + 1):\n        for u in graph[v]:\n            result.append(f\"{v} {u}\")\n    \n    return \"\\n\".join(result)\n\n# Read input\nN = int(input())\na = [0] * (N + 1)\nb = [0] * (N + 1)\n\nfor _ in range(N):\n    x, y = map(int, input().split())\n    a[x] += 1\n    b[y] += 1\n\nprint(solve_graph_reconstruction(N, a, b))",
    "timestamp": "2025-08-13 08:25:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    a = list(map(int, input[ptr:ptr+N+1]))\n    ptr += N+1\n    b = list(map(int, input[ptr:ptr+N+1]))\n    ptr += N+1\n\n    sum_a = sum(i * a[i] for i in range(N+1))\n    sum_b = sum(i * b[i] for i in range(N+1))\n    if sum_a != sum_b:\n        print(\"NO\")\n        return\n\n    in_degrees = []\n    out_degrees = []\n    for i in range(N+1):\n        in_degrees.extend([i] * a[i])\n        out_degrees.extend([i] * b[i])\n    \n    in_degrees = deque(sorted(in_degrees, reverse=True))\n    out_degrees = deque(sorted(out_degrees, reverse=True))\n    \n    edges = []\n    vertices = list(range(1, N+1))\n    \n    # We need to assign in and out degrees to vertices\n    # Assign highest out-degree to highest in-degree vertices\n    # But for simplicity, we can just process in any order\n    \n    # Create a list of vertices with their out-degrees\n    out_vertices = []\n    for i in range(N+1):\n        out_vertices.extend([(i, v) for v in vertices[:b[i]]])\n        vertices = vertices[b[i]:]\n    \n    out_vertices.sort(reverse=True)\n    vertices = [v for (d, v) in out_vertices]\n    out_deg = [d for (d, v) in out_vertices]\n    \n    in_deg = []\n    vertices_in = list(range(1, N+1))\n    for i in range(N+1):\n        in_deg.extend([i] * a[i])\n    in_deg = deque(sorted(in_deg, reverse=True))\n    \n    # Now, assign edges\n    edges = []\n    for u in vertices:\n        d = out_deg[u-1]\n        targets = []\n        while d > 0 and in_deg:\n            max_in = in_deg[0]\n            if max_in == 0:\n                break\n            targets.append(max_in)\n            in_deg.popleft()\n            d -= 1\n        # Add edges from u to any vertices with remaining in_degree\n        # But we need to manage the in_deg list properly\n        # This is a simplified approach; may not work for all cases\n        for _ in range(d):\n            if in_deg and in_deg[0] > 0:\n                max_in = in_deg[0]\n                targets.append(max_in)\n                in_deg.popleft()\n            else:\n                print(\"NO\")\n                return\n        for t_in in targets:\n            v = -1\n            # Find a vertex with in_degree t_in (but we don't track which vertex has which in_degree)\n            # This part is tricky; the above approach is not sufficient\n            # Hence, the problem requires a more sophisticated method like the Havel-Hakimi for directed graphs\n            pass\n        # Since the above is incomplete, we need a different approach\n    \n    # Alternative approach: Use the Gale-Ryser theorem for bipartite graphs\n    # But for directed graphs, it's more complex\n    \n    # Check if the sequences are graphical\n    # For simplicity, we'll assume that if sum_a == sum_b, then it's possible (not always true)\n    # But the actual condition is more involved\n    \n    # For the purpose of this code, we'll proceed under the assumption that the sequences are valid\n    # and try to construct a graph\n    \n    # Reconstruct in_deg and out_deg lists\n    in_deg = []\n    out_deg = []\n    for i in range(N+1):\n        in_deg.extend([i] * a[i])\n        out_deg.extend([i] * b[i])\n    in_deg = sorted(in_deg, reverse=True)\n    out_deg = sorted(out_deg, reverse=True)\n    \n    # Check if the sequences meet the necessary conditions\n    # The necessary condition is sum a_i = sum b_i, but not sufficient\n    # Another condition is that sum_{k=1 to n} min(d_j^out, k) >= sum_{k=1 to n} min(d_j^in, k) for all 1 <= k <= N\n    # But implementing this is complex\n    \n    # For the sake of this problem, we'll assume that if sum_a == sum_b, then it's possible\n    # and proceed to construct a graph\n    \n    # Assign out_deg to vertices 1..N\n    vertices_out = []\n    cnt = 0\n    for d in range(N, -1, -1):\n        for _ in range(b[d]):\n            vertices_out.append((d, cnt+1))\n            cnt += 1\n    vertices_out.sort(reverse=True)\n    \n    # Assign in_deg to vertices 1..N\n    vertices_in = []\n    cnt = 0\n    for d in range(N, -1, -1):\n        for _ in range(a[d]):\n            vertices_in.append((d, cnt+1))\n            cnt += 1\n    vertices_in.sort(reverse=True)\n    \n    # Now, vertices_out is sorted by out_degree descending, vertices_in by in_degree descending\n    # We can use a greedy approach to connect highest out to highest in\n    \n    edges = []\n    temp_out = [list(t) for t in vertices_out]\n    temp_in = [list(t) for t in vertices_in]\n    \n    for i in range(len(temp_out)):\n        u = temp_out[i][1]\n        out_d = temp_out[i][0]\n        # Connect u to out_d vertices with highest remaining in_degree\n        for j in range(len(temp_in)):\n            if out_d <= 0:\n                break\n            if temp_in[j][0] > 0:\n                v = temp_in[j][1]\n                edges.append((u, v))\n                temp_in[j][0] -= 1\n                out_d -= 1\n        if out_d > 0:\n            print(\"NO\")\n            return\n    \n    # Verify that all in_degrees are zero\n    for d, v in temp_in:\n        if d != 0:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    for u, v in edges:\n        print(u, v)\n\nsolve()",
    "timestamp": "2025-08-13 08:25:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool findGraph(int N, const vector<int>& a, const vector<int>& b) {\n    int sum_a = 0, sum_b = 0;\n    for (int i = 0; i <= N; ++i) {\n        sum_a += i * a[i];\n        sum_b += i * b[i];\n    }\n    return sum_a == sum_b;\n}\n\nvoid constructGraph(int N, const vector<int>& a, const vector<int>& b) {\n    int remaining = N;\n    vector<pair<int, int>> in_degree;\n    vector<pair<int, int>> out_degree;\n    \n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j < a[i]; ++j) {\n            in_degree.emplace_back(i, remaining--);\n        }\n    }\n    \n    remaining = N;\n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j < b[i]; ++j) {\n            out_degree.emplace_back(i, remaining--);\n        }\n    }\n    \n    vector<vector<int>> graph(N + 1);\n    vector<int> in_cnt(N + 1, 0);\n    vector<int> out_cnt(N + 1, 0);\n    \n    for (int i = 0; i < in_degree.size(); ++i) {\n        int in_d = in_degree[i].first;\n        int vertex_in = in_degree[i].second;\n        \n        for (int j = 0; j < out_degree.size(); ++j) {\n            int out_d = out_degree[j].first;\n            int vertex_out = out_degree[j].second;\n            \n            if (in_cnt[vertex_in] < in_d && out_cnt[vertex_out] < out_d) {\n                graph[vertex_out].push_back(vertex_in);\n                in_cnt[vertex_in]++;\n                out_cnt[vertex_out]++;\n            }\n        }\n    }\n    \n    cout << \"YES\" << endl;\n    for (int i = 1; i <= N; ++i) {\n        for (int j : graph[i]) {\n            cout << i << \" \" << j << endl;\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> a(N + 1), b(N + 1);\n    \n    for (int i = 0; i <= N; ++i) {\n        cin >> a[i];\n    }\n    \n    for (int i = 0; i <= N; ++i) {\n        cin >> b[i];\n    }\n    \n    if (findGraph(N, a, b)) {\n        constructGraph(N, a, b);\n    } else {\n        cout << \"NO\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:45:48"
  }
]