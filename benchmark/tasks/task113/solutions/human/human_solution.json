[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\tnowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):scr[n-1]>scr[nowN]>n-1:nowN);\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\tnowN = (time[n-1]==time[nowN]?min(n-1,nowN):time[n-1]>time[nowN]>n-1:nowN);\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n\nusing namespace std;\n\npair<int,int> seg[1<<18];\nint N,R,L;\n\nvoid update(int k,int a){\n    int id = k + 1;\n    k += (1 << 17)-1;\n    seg[k].first += a;\n    seg[k].second = id;\n\n    while(k){\n        k = (k-1)/2;\n        if(seg[2*k+1].first >= seg[2*k+2].first){\n            seg[k] = seg[2*k+1];\n        }\n        else if(seg[2*k+1].first < seg[2*k+2].first){\n            seg[k] = seg[2*k+2];\n        }\n    }\n}\n    \nint main(){\n    int data[100000] = {0};\n    scanf(\"%d %d %d\",&N,&R,&L);\n\n    for(int i=0;i<N;i++)update(i,0);\n\n    int top=0;\n    int prev=0;\n    for(int i=0;i<R;i++){\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x);\n        data[top] += t - prev;\n        update(d-1,x);\n        top = seg[0].second - 1;\n        prev = t;\n    }\n    data[top] += L-prev;\n\n    int maxi = 0;\n\n    for(int i=1;i<N;i++)if(data[maxi] < data[i] ) maxi = i;\n\n    printf(\"%d\\n\",maxi+1);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n+1];\n    for(int i=0;i<2*n+1;i++){\n      points[i] = Team(i,0);\n    }\n\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point += p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,-100000);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams);\n\n    map<int,vector<Team> > records;\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      records[time].push_back(Team(id,point));\n    }\n\n    for(map<int,vector<Team> >::iterator it = records.begin();\n\tit != records.end();\n\tit++){\n      for(int i=0;i<it->second.size();i++){\n\tseg_tree.insert(it->second[i].id,it->second[i].point);\n      }\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += it->first - prev_time;\n\tprev_time = it->first;\n\tprev_champ = team.id;\n      }\n    }\n\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 1;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX_N = 1000001;\n\nint T_Time[MAX_N], Score[MAX_N];\n\nint main()\n{\n\n\tint N, R, L, d, t, x, most, P_T = 0, P_D = 1;\n\tpriority_queue< pair< int, int > > ScoreHeap;\n\n\tmemset( Score , 0, sizeof( Score ) );\n\tmemset( T_Time, 0, sizeof( T_Time ) );\n\n\tcin >> N >> R >> L;\n\n\tfor( int i = 0; i < R; i++ ) {\n\n\t\tcin >> d >> t >> x;\n\t\tScore[d] += x;\n\n\t\tScoreHeap.push( make_pair( Score[d], -d ) );\n\n\t\twhile( true ) {\n\n\t\t\tpair< int, int > temp = ScoreHeap.top();\n\t\t\tif( temp.first == Score[-temp.second] ) {\n\n\t\t\t\tT_Time[P_D] += t - P_T;\n\t\t\t\tP_D = -temp.second;\n\t\t\t\tP_T = t;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tScoreHeap.pop();\n\n\t\t}\n\n\t}\n\n\tT_Time[P_D] += L - P_T;\n\n\tfor( int i = 1; i <= N - 1; i++ ) {\n\n\t\tif( T_Time[i] == T_Time[i + 1] ) most = i;\n\t\telse if( T_Time[i] < T_Time[i + 1] ) most = i + 1;\n\t\telse most = i;\n\n\t}\n\n\tcout << most << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <limits.h>\n \nusing namespace std;\ntypedef pair<int,int> P;\nP seg[1111111];\nint n;\nvoid update(int a,int b);\nP pamax(P a,P b);\nint b;\nint main(){\n  int r,l;\n  int team[100000]={0};\n   \n  cin >> n >> r >> l;\n  b=1;\n  while(b<n)b*=2;\n  for(int i=0; i<n; i++) {\n    update(i,0);\n  }\n  int now=0,top=0;\n  \n  for (int i=0;i<r;i++){\n    int d,t,x;\n    cin >> d >> t >> x;\n    team[top]+=t-now;\n    update(d-1,x);\n    top=seg[0].second-1;\n    now=t;\n  }\n  team[top]+=l-now;\n  \n  int ans = 0;\n  for (int i=1;i<n;i++){\n    if(team[ans]<team[i]) ans=i;\n  }\n  cout << ans+1 << endl;\n}\n \n \n \nvoid update(int k, int x){\n  int id = k + 1;\n  k += b - 1;\n  seg[k].first += x;\n  seg[k].second = id;\n   \n  while (k>0){\n    k = (k - 1) / 2;\n    if (seg[k * 2 + 1].first > seg[k * 2 + 2].first){\n      seg[k] = seg[k * 2 + 1];\n    }\n    else if (seg[k * 2 + 1].first < seg[k * 2 + 2].first){\n      seg[k] = seg[k * 2 + 2];\n    }\n    else {\n      seg[k] = seg[k * 2 + 1];\n    }\n  }\n  /*while(k>0){\n    k=(k-1)/2;\n    seg[k]=pamax(seg[k*2+1],seg[k*2+2]);\n    }*/\n}\n\nP pamax(P a,P b){\n  int x,y;\n  x=a.second;\n  y=b.second;\n  if(x<y)return b;\n  else return a;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<set>\n#include<algorithm>\nusing namespace std;\nint s[100000];\nint p[1000000];\nint q[1000000];\nint r[1000000];\nint ans[100000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tset<pair<int,int> >S;\n\tfor(int i=0;i<a;i++){\n\t\tS.insert(make_pair(0,i));\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d%d\",p+i,r+i,q+i);\n\t\tp[i]--;\n\t}\n\tint now=0;\n\tfor(int i=0;i<c;i++){\n\t\twhile(now<b&&r[now]==i){\n\t\t\tS.erase(make_pair(-s[p[now]],p[now]));\n\t\t\ts[p[now]]+=q[now];\n\t\t\tS.insert(make_pair(-s[p[now]],p[now]));\n\t\t\tnow++;\n\t\t}\n\t\tpair<int,int> M=*(S.begin());\n\t\tans[M.second]++;\n\t}\n\tint val=0;\n\tint at=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(val<ans[i]){\n\t\t\tval=ans[i];\n\t\t\tat=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",at+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#define INF (2 << 28)\nusing namespace std;\n\ntypedef pair<int, int> iiP;\n\nint n;\niiP seg[2 * 100001 - 1];\n\nvoid init(int q){\n\n  n = 1;\n  while(n < q) n *= 2;\n\n  for(int i = 0; i < n; i++) seg[i] = iiP(-INF, -i);\n\n}\n\nvoid update(int i, iiP a){\n\n  i += n - 1;\n  seg[i] = a;\n\n  while(i > 0){\n    i = (i - 1) / 2;\n    seg[i] = max(seg[i * 2 + 1], seg[i * 2 + 2]);\n  }\n\n}\n\nint main(){\n\n  int N, R, L, d, t, x, prev;\n  int sumt[100001] = {0}, score[100001] = {0};\n  cin >> N >> R >> L;\n\n  init(N);\n  cin >> d >> t >> x;\n  sumt[1] += t, score[d] += x;\n  update(d, iiP(score[d], -d));\n  prev = t;\n  //  cout << \":\" << score[d] << \" \" << d << endl;\n  for(int i = 1; i < R; i++){\n    cin >> d >> t >> x;\n    iiP p = seg[0];\n    score[d] += x, sumt[-p.second] += t - prev;\n    prev = t;\n    //cout << \":\" << score[d] << \" \" << d << endl;\n    update(d, iiP(score[d], -d));\n  }\n\n  iiP p = seg[0];\n  //  cout << p.first << \" \" << -p.second << endl;\n  sumt[-p.second] += L - prev;\n\n  cout << max_element(sumt + 1, sumt + N + 1) - sumt << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\nconst int MAX_N = 1<<20;\n\nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = -INF;\n        dat[i].se = -(i-n+1);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(-INF, n-1);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\trep(i, n) update(i, INF);\n\tvi v(n, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\t//cout<<-p.se<<endl;\n\t\tv[-p.se] = t-tt+1;\n\t\ttt = t;\n\t\tupdate(d-1, x);\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] = l-tt+1;\n\tint ans = 0;\n\tfor(int i = 1; i < v.size(); i++){\n\t\tif(v[ans] < v[i]) ans = i;\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long int Int;\n#define REP(i, j) for(Int i = 0; i < (Int)(j); ++i)\n#define FOR(i, j, k) for(Int i = (Int)(j); i < (Int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<Int, Int> P;\nconst Int MAX_N = (1 << 17);\nnamespace std {\n  bool operator > (const P& a, const P& b) {\n    return a.first != b.first ? a.first > b.first : a.second < b.second;\n  }\n}\n\nInt n;\nP v[2 * MAX_N - 1];\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(Int nn){\n  n = 1;\n  while(n < nn) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(0, 1);\n}\n\n// テヲツキツサテ・ツュツ療」ツ?渓テ」ツ?ョテ」ツつづ」ツ?ョテ」ツつ誕テ」ツ?ォテヲツ崢エテヲツ鳴ー\nvoid update(Int k, Int a){\n  k += n - 1;\n  v[k].first = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);\n  }\n}\n\n// [a, b)テ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?、テ」ツつ津ヲツ個?」ツ?、テ」ツδ?」ツδシテ」ツδ?」ツδ甘」ツδウテ」ツδ静」ツδシテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n// kテ」ツ?ッテ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ヲツキツサテ・ツュツ療」ツ?〕, rテ」ツ?ッテ」ツ?敕」ツつ古」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ擬l, r)\n// テ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?凖ヲツ卍づ」ツ?ッquery(a, b, 0, 0, n)テ」ツ?ィテ」ツ?療」ツ?ヲテ・ツ堕シテ」ツ?カ\nP query(Int a, Int b, Int k, Int l, Int r){\n  if(b <= l || a >= r) return P(-1, -1);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return max(vl, vr);\n}\n\nint main() {\n  Int N, R, L, d, t, x, bef = 1; cin >>N >>R >>L;\n  P tar = P(0, 1);\n  vector<Int> cnt(N, 0);\n  init(N);\n  set<P> S;\n  REP(r, R){\n    cin >>d >>t >>x;\n    --d;\n    cnt[tar.second - 1] += t - bef;\n    update(d, x + v[d + n - 1].first);\n    tar = query(0, N, 0, 0, n);\n    bef = t;\n  }\n  cnt[tar.second - 1] += L - bef + 1;\n  Int ans = 0;\n  REP(i, N) if(cnt[i] > cnt[ans]) ans = i;\n  cout <<ans + 1 <<endl;\n  REP(i, N) cout <<i + 1 <<\": \" <<cnt[i] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  team[search(id,n)].point+=key;\n  maxHeapify(id);\n  while(id>1&&team[id/2].point<team[id].point){\n    swap(team[id],team[id/2]);\n    id=id/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=search(top,n);\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i],x[i],n);\n    //printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n    if(i==0){\n      team[search(1,n)].showed+=t[0];\n    }\n    else if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  //for(int i=1;i<=n;i++){\n  //printf(\"%d %d\\n\",team[i].id,team[i].showed);\n  //}\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAX 1000000\n\nint N, R, L;\nlong long S[MAX+1], T[MAX+1];\nint H[MAX+1], P[MAX+1]; // heap\n\nbool isGreater(int a, int b){\n  if ( S[a] == S[b] ) return a > b;\n  return S[a] < S[b];\n}\n\nvoid swp(int a, int b){\n  int i1 = H[a];\n  int i2 = H[b];\n  swap(H[a], H[b]);\n  P[i1] = b;\n  P[i2] = a;\n}\n\nvoid downHeap(int i){\n  int l, r, largest;\n  l = 2*i;\n  r = 2*i+1;\n  if ( l <= N && isGreater(H[i], H[l]) ) largest = l;\n  else largest = i;\n  if ( r <= N && isGreater(H[largest], H[r]) ) largest = r;\n  if ( largest != i ){\n    swp(i, largest);\n    downHeap(largest);\n  }\n}\n\nvoid upHeap(int i){\n  while ( i > 1 && isGreater(H[i/2], H[i]) ){\n    swp(i, i/2);\n    i = i/2;\n  }\n}\n\nvoid update(int d, int t, int x){\n  S[d] += x;\n  if ( x > 0 ){\n    upHeap(P[d]);\n  } else if( x < 0 ){\n    downHeap(P[d]);\n  }\n}\n\nvoid init(){\n  for ( int i = 0; i <= N; i++ ){\n    S[i] = 0;\n    T[i] = 0;\n    H[i] = i;\n    P[i] = i;\n  }\n\n  // build heap\n  for ( int i = N/2; i >= 1; i-- ) downHeap(i);\n}\n\nmain(){\n  cin >> N >> R >> L;\n  init();\n  int d, t, x;\n  int pret = 0;\n  int pred = 1;\n  for ( int i = 0; i < R; i++ ){\n    scanf(\"%d %d %d\", &d, &t, &x);\n    T[pred] += t - pret;\n    update(d, t, x);\n    pred = H[1];\n    pret = t;\n  }\n\n  T[pred] += L - pret;\n\n  int maxv = -2000000000;\n  int ans = -1;\n  for ( int i = 1; i <= N; i++ ){\n    if ( maxv < T[i] ){\n      maxv = T[i];\n      ans = i;\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long int Int;\n#define REP(i, j) for(Int i = 0; i < (Int)(j); ++i)\n#define FOR(i, j, k) for(Int i = (Int)(j); i < (Int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<Int, Int> P;\nconst Int MAX_N = (1 << 17);\nnamespace std {\n  bool operator > (const P& a, const P& b) {\n    return a.first != b.first ? a.first > b.first : a.second < b.second;\n  }\n}\n\nInt n;\nP v[2 * MAX_N - 1];\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(Int nn){\n  n = 1;\n  while(n < nn) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(0, 1);\n  REP(i, nn) v[i + n - 1] = P(0, i + 1);\n}\n\n// テヲツキツサテ・ツュツ療」ツ?渓テ」ツ?ョテ」ツつづ」ツ?ョテ」ツつ誕テ」ツ?ォテヲツ崢エテヲツ鳴ー\nvoid update(Int k, Int a){\n  k += n - 1;\n  v[k].first = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);\n  }\n}\n\n// [a, b)テ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?、テ」ツつ津ヲツ個?」ツ?、テ」ツδ?」ツδシテ」ツδ?」ツδ甘」ツδウテ」ツδ静」ツδシテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n// kテ」ツ?ッテ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ヲツキツサテ・ツュツ療」ツ?〕, rテ」ツ?ッテ」ツ?敕」ツつ古」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ擬l, r)\n// テ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?凖ヲツ卍づ」ツ?ッquery(a, b, 0, 0, n)テ」ツ?ィテ」ツ?療」ツ?ヲテ・ツ堕シテ」ツ?カ\nP query(Int a, Int b, Int k, Int l, Int r){\n  if(b <= l || a >= r) return P(-1, -1);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return max(vl, vr);\n}\n\nint main() {\n  Int N, R, L, d, t, x, bef = 0; cin >>N >>R >>L;\n  P tar = P(0, 1);\n  vector<Int> cnt(N, 0);\n  init(N);\n  set<P> S;\n  REP(r, R){\n    cin >>d >>t >>x;\n    --d;\n    cnt[tar.second - 1] += t - bef;\n    update(d, x + v[d + n - 1].first);\n    tar = query(0, N, 0, 0, n);\n    bef = t;\n  }\n  cnt[tar.second - 1] += L - bef;\n  Int ans = 0;\n  REP(i, N) if(cnt[i] > cnt[ans]) ans = i;\n  cout <<ans + 1 <<endl;\n  //REP(i, N) cout <<i + 1 <<\": \" <<cnt[i] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 20000\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\nstruct segtree{\n  int N;\n  P dat[MAX_N * 2 - 1];\n  segtree(){}\n  segtree(int n){\n    N = 1;\n    while(n > N) N *= 2;\n\n    rep(i, 2 * N - 1) dat[i] = MP(-10000000, -10000000);\n    for(int i = N - 1; i < 2 * N - 1; i++) dat[i] = MP(0, -1 * (i - N + 1));\n  }\n\n  void update(int k, int a){\n    k += N - 1;\n    dat[k].F += a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1], dat[2*k+2]);\n    }\n  }\n\n  P query(int a, int b){ return query(a, b, 0, 0, N); }\n  P query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return P(-10000000, -10000000);\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      P vl = query(a, b, 2*k+1, l, (l+r)/2);\n      P vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return max(vl, vr);\n    }\n  }\n};\n\nint main(){\n  int N, R, L;\n  int res[MAX_N];\n  scanf(\"%d%d%d\", &N, &R, &L);\n  segtree seg(N);\n  rep(i, N) seg.update(i, 0);\n  int time = 0;\n  rep(i, R){\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x); d--;\n    P s = seg.query(0, N);\n    res[-s.second] += t - time;\n    seg.update(d, x);\n    time = t;\n  }\n\n  P s = seg.query(0, N);\n  res[-s.second] += L - time;\n\n  int ans = 0;\n  rep(i, N) if(res[ans] < res[i]) ans = i;\n\n  printf(\"%d\\n\", ans+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint P[100000],T[100000];\nint main() {\n    int N,R,L,PT=0,n1=0;\n    scanf(\"%d %d %d\",&N,&R,&L);\n    for(int i=0;i<R;i++) {\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x); d--;\n        P[d]+=x;\n        if(x>0) {\n            if(P[d]>p1||(P[d]==P[n1]&&n1>d)) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=d;\n            }\n        }\n        if(x<0) {\n            if(d!=n1) continue;\n            int n2=n1,p2=P[d];\n            for(int j=N-1;j>=0;j--) {\n                if(p2<=P[j]) {n2=j,p2=P[j];}\n            }\n            if(n2!=n1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=n2;\n            }\n        }\n    }\n    T[n1]+=L-PT+1;\n    int ans_n=0,ans_t=0;\n    for(int i=0;i<N;i++) {\n        if(ans_t<T[i]) {\n            ans_t=T[i];\n            ans_n=i;\n        }\n    }\n    printf(\"%d\\n\",ans_n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int>P;\n\n#define INF 2<<29\n#define F first\n#define S second\n\nP tree[1000005];\nint time_[1000005];\n\nint n,r,l;\nint now=1;\nint temp=1;\nint before_t=0;\nint ans=1;\n\nvoid add(int d,int x){\n  tree[d+temp].S+=x;\n  int j=d+temp;\n  do{\n    j=(j-1)/2;\n    if(tree[2*j+1].S>tree[2*j+2].S){ \n      tree[j]=tree[2*j+1];\n    }else if(tree[2*j+1].S<tree[2*j+2].S){\n      tree[j]=tree[2*j+2];\n    }else{\n      tree[j]=tree[2*j+1];\n    }\n  }while(j>0);\n\n  return; \n} \n\nint main(){\n  int d,t,x;\n  \n  scanf(\"%d %d %d\",&n,&r,&l);\n  while(temp<n){\n    temp*=2;\n  }\n  temp--;\n\n  for(int i=0;i<n;i++){\n    tree[i+temp].F=i+1;\n  }\n  \n  for(int i=0;i<r;i++){\n    scanf(\"%d %d %d\",&d,&t,&x);\n    time_[now]+=t-before_t;\n    before_t=t;\n\n    add(d-1,x);\n    now=tree[0].F;\n  }\n  time_[now]+=l-before_t;\n\n  for(int i=1;i<=n;i++){\n    if(time_[ans]<time_[i]) ans=i;\n  }\n\n  printf(\"%d\\n\",ans);\n  \n  return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n// pp basics\n\n#define in ,\n#define esc_paren(...) __VA_ARGS__\n#define pp_empty(...)\n#define pp_cat_i(x, y) x ## y\n#define pp_cat(x, y) pp_cat_i(x, y)\n\n#define pp_inc0 1\n#define pp_inc1 2\n#define pp_inc2 3\n#define pp_inc3 4\n#define pp_inc4 5\n#define pp_inc5 6\n#define pp_inc6 7\n#define pp_inc7 8\n#define pp_inc8 9\n#define pp_inc(i) pp_cat(pp_inc, i)\n\n// pp args counter\n\n#define pp_arg10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) _9\n#define pp_has_comma(...) pp_arg10(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 0)\n#define pp_trigger_paren(...) ,\n#define pp_is_empty(...) \\\n  pp_is_empty1( \\\n      pp_has_comma(__VA_ARGS__), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__), \\\n      pp_has_comma(__VA_ARGS__()), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__()) \\\n      ) \n#define pp_paste5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4\n#define pp_is_empty1(_0, _1, _2, _3) pp_has_comma(pp_paste5(pp_is_empty_case_, _0, _1, _2, _3))\n#define pp_is_empty_case_0001 ,\n\n#define pp_is_one(...) pp_is_one_(__VA_ARGS__, pp_one_seq)\n#define pp_is_one_(...) pp_is_one_n(__VA_ARGS__)\n#define pp_is_one_n(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10, N, ...) N\n#define pp_one_seq 0,0,0,0,0,0,0,0,0,1,0\n\n#define pp_narg(...) \\\n         pp_narg_(__VA_ARGS__, pp_narg_seq)\n#define pp_narg_(...) \\\n         pp_narg_n(__VA_ARGS__)\n#define pp_narg_n( \\\n          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\\n         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\\n         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\\n         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\\n         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\\n         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\\n         _61,_62,_63,n,...) n\n#define pp_narg_seq \\\n         63,62,61,60, \\\n         59,58,57,56,55,54,53,52,51,50, \\\n         49,48,47,46,45,44,43,42,41,40, \\\n         39,38,37,36,35,34,33,32,31,30, \\\n         29,28,27,26,25,24,23,22,21,20, \\\n         19,18,17,16,15,14,13,12,11,10, \\\n          9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n// pp if\n#define pp_if_0(x, y) y\n#define pp_if_1(x, y) x\n#define pp_if(cond, x, y) pp_cat(pp_if_, cond)(x, y)\n\n// pp foreach\n#define pp_foreach_i9(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i8(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i7(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i6(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i5(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i4(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i3(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i2(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i1(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i0(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i(i, f, ...) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach(f, ...) pp_foreach_i(0, f, __VA_ARGS__)\n\n// alternative rep macro\n#define rep(...) rep1(rep2, (__VA_ARGS__))\n#define rep1(X, A) X A\n#define rep2(i, ...) pp_if(pp_is_one(__VA_ARGS__), rep_len1(i, __VA_ARGS__), rep3(i, __VA_ARGS__))\n#define rep_len1(i, end, ...) for (int i = 0; i < end; i++)\n#define rep3(i, iter, ...) rep4(rep5, (iter, i, esc_paren __VA_ARGS__))\n#define rep4(X, A) X A\n#define rep5(iter, ...) iter(__VA_ARGS__)\n\n// iterators\n#define up up_iter ,\n#define up_iter3(i, start, end) for (int i = start; i < end; i++)\n#define up_iter4(i, start, end, up) for (int i = start; i < end; i += up)\n#define up_iter(...) pp_cat(up_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define down down_iter ,\n#define down_iter2(i, end) for(int i = end-1; i >= 0; i--)\n#define down_iter3(i, start, end) for (int i = end-1; i >= start; i--)\n#define down_iter4(i, start, end, down) for (int i = end-1; i >= start; i -= down)\n#define down_iter(...) pp_cat(down_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define viter viter_iter ,\n#define viter_iter(i, v) auto tmpitr=v.begin(); for (auto i=*tmpitr; tmpitr != v.end(); tmpitr++)\n\n// debug macros\n#define debug_var_elem(v) << #v << \"=\" << v << \" \"\n#ifdef DEBUG\n#define debug_echo(e) cout << \"L\" << __LINE__ << \": \" << e << endl\n#define debug_var(...) cout << \"L\" << __LINE__ << \": \" pp_foreach(debug_var_elem, __VA_ARGS__) << endl\n#define debug_ary(ary) cout << \"L\" << __LINE__ << \" [ \"; for(auto ele : ary) cout << ele << \" \"; cout << \"]\" << endl;\n#else\n#define debug_echo(e)\n#define debug_var(...)\n#define debug_ary(ary)\n#endif\n\n// short names\ntypedef long long ll;\n#define down_queue(x) priority_queue<x>\n#define up_queue(x) priority_queue<x, vector<x>, greater<x>>\nll gcd(ll a,ll b){while(b){ll tmp = a % b;a = b;b = tmp;}return a;}\nll lcm(ll a,ll b){return a / gcd(a,b) * b;}\n#define all(x) x.begin(), x.end()\n#define split_str(str, sp_word) istringstream stream(str); string res; for(int cnt = 0; getline(stream,res,sp_word); cnt++)\n#define digit(x) ((int)log10((double)(x)) + 1)\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\nvector<int> digit_split(int n){vector<int> result(digit(n));for(int i = 0; n; i++){result[i] = n % 10;n /= 10;}return result;}\n#define time(content) {auto start = clock();content;auto end = clock();cout << (double)(end - start) << \"ms\" << endl;} \n#define vec_cpy(to,from) copy(all(to),back_inserter(from))\n#define ary_cpy(to,from) memcpy(to, from, sizeof(from))\n#define MOD 1000000007 \n\n// pp unionfind\n#define pp_gen_field(list) pp_gen_field1 list\n#define pp_gen_field1(name, val) decltype(val) name;\n#define pp_gen_init(list) pp_gen_init1 list\n#define pp_gen_init1(name, val) ,val\n#define pp_gen_find_set_wrap(ufnodename) ufnodename pp_gen_find_set\n#define pp_gen_find_set(list) pp_gen_find_set1 list\n#define pp_gen_find_set1(name, val) \\\n  find_set_ ## name(int x, decltype(val) v) { \\\n    if (nodes[x].parent == x) { \\\n      nodes[x].name = v; \\\n      return nodes[x]; \\\n    } else { \\\n      return nodes[x] = find_set_ ## name(nodes[x].parent, v); \\\n    } \\\n  }\n#define pp_gen_unite_set(list) pp_gen_unite_set1 list\n#define pp_gen_unite_set1(name, val) \\\n  if (nodes[x].name == val) { \\\n    find_set_ ## name(x, find(y).name); \\\n  } \\\n  if (nodes[y].name == val) { \\\n    find_set_ ## name(y, find(x).name); \\\n  }\n\n#define def_unionfind(ufname, ufnodename, ...) \\\n  struct ufnodename { \\\n    int parent; \\\n    pp_foreach(pp_gen_field, __VA_ARGS__) \\\n  }; \\\n  struct ufname { \\\n    vector<ufnodename> nodes; \\\n    vector<int> rank; \\\n    ufname(int n) : nodes(n+1), rank(n+1) { \\\n      rep (i in n) { \\\n        nodes[i] = ufnodename{i pp_foreach(pp_gen_init, __VA_ARGS__)}; \\\n        rank[i] = 0; \\\n      } \\\n    } \\\n    ufnodename find(int x) { \\\n      if (nodes[x].parent == x) { \\\n        return nodes[x]; \\\n      } else { \\\n        return nodes[x] = find(nodes[x].parent); \\\n      } \\\n    } \\\n    pp_foreach(pp_gen_find_set_wrap(ufnodename), __VA_ARGS__) \\\n    void unite(int x, int y) { \\\n      x = find(x).parent; \\\n      y = find(y).parent; \\\n      if (x == y) return; \\\n      if (rank[x] < rank[y]) { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[x].parent = y; \\\n      } else { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[y].parent = x; \\\n        if (rank[x] == rank[y]) rank[x]++; \\\n      } \\\n    } \\\n    bool same(int x, int y) { \\\n      return find(x).parent == find(y).parent; \\\n    } \\\n  }\n\n//\n// Implementation\n//\n\nint main(){\n  int n,r,l;cin >> n >> r >> l;\n  vector<int> times(n,0),score(n,0),d(r),t(r),x(r);\n\n  rep(i in r){\n    cin >> d[i] >> t[i] >> x[i];\n    d[i]--;\n  }\n\n  for(int i = 0;i < r;i++){\n    score[d[i]] += x[i];\n    if(t[i] == t[i + 1]) continue;\n    times[distance(score.begin(),max_element(all(score)))] += (i == r - 1 ? l - t[i] : t[i + 1] - t[i]);\n  }\n\n  cout << distance(times.begin(),max_element(all(times))) + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<ll> dat;\n\tvector<int> id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(2*n-1);\n\t\tid.resize(2*n-1);\n\t\trep(i,2*n-1) dat[i] = -INF;\n\t\trep(i,n) update(i,INF);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] += a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\n\tvector<int> v(n,0);\n\tSeg seg(n);\n\n\tint top_id = seg.id[0],pre_time = 0;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\tseg.update(d-1,x);\n\t\ttop_id = seg.id[0];\n\t}\n\n\tv[top_id] += l - pre_time;\n\n    int res = 0,ans = 0;\n\trep(i,n)\n\t{\n\t\tif(res < v[i])\n\t\t{\n\t\t\tres = v[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tcout << ans+1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint N,R,L,d,t,x,i,time=0,team,T[100001],P[100001],i2,max;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i<=R;i++){\n\t\tT[i]=0;\n\t\tP[i]=0;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tP[d]+=x;\n\t\tmax=0;\n\t\tif(i!=1){\n\t\t\tfor(i2=1;i2<=R;i2++){\n\t\t\t\tif(P[i2]>P[max]){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t\telse if(P[i2]==P[max]&&i2<max){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t}\n\t\tT[team]+=t-time;\n\t\t}\n\t\ttime=t;\n\t\tteam=max;\n\t\tT[0]=0;\n\t}\n\tif(time!=L){\n\t\tT[max]=L-time;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(T[i]>T[max]){\n\t\t\tmax=i;\n\t\t}\n\t\telse if(T[i]==T[max]&&i<max){\n\t\t\tmax=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N, R, L;\n    while(cin >> N >> R >> L && N){\n        const int B = sqrt(N);\n        vector<int> bucket((N - 1) / B + 1);\n        vector<int> point(N + B, INT_MIN);\n        REP(i, N) point[i] = 0;\n        int last_time = 0;\n        int camera_id = 0;\n        vector<int> answer(N);\n        for(int i = 0; i < R; i++){\n            int d, t, x;\n            scanf(\"%d %d %d\", &d, &t, &x);\n            d--;\n            point[d] += x;\n            if(point[d] > bucket[d / B]){\n                bucket[d / B] = point[d];\n            }else if(point[d] - x == bucket[d / B]){\n                bucket[d / B] = *max_element(point.begin() + (d / B) * B, point.begin() + (d / B + 1) * B);\n            }\n            answer[camera_id] += t - last_time;\n            last_time = t;\n            if(camera_id == d && x < 0){\n                int k = max_element(bucket.begin(), bucket.end()) - bucket.begin();\n                camera_id = max_element(point.begin() + k * B, point.begin() + (k + 1) * B) - point.begin();\n                assert(camera_id == max_element(point.begin(), point.end()) - point.begin());\n            }else if(point[d] > point[camera_id]){\n                camera_id = d;\n            }\n            assert(camera_id >= 0 && camera_id < N);\n            //REP(i, N) cout << point[i] << \" \"; cout << endl;\n            //REP(i, (N - 1) / B + 1) cout << bucket[i] << \" \"; cout << endl;\n            //printf(\"time:%d point[%d] += %d camera: %d\\n\", t, d + 1, x, camera_id + 1);\n        }\n        answer[camera_id] += L - last_time;\n        cout << max_element(answer.begin(), answer.end()) - answer.begin() + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint a,toread,N,R,L,d,t,x,i,time=0,team,T[1001],P[1001],i2,max,dscanf[1001],tscanf[1001],xscanf[1001];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i<=R;i++){\n\t\tT[i]=0;\n\t\tP[i]=0;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tdscanf[i]=d;\n\t\ttscanf[i]=t;\n\t\txscanf[i]=x;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(i!=1){\n\t\t\tfor(a=i;a>=1;a--){\n\t\t\t\tif(tscanf[i]>=tscanf[a]){\n\t\t\t\t\ttoread=tscanf[i];\n\t\t\t\t\ttscanf[i]=tscanf[a];\n\t\t\t\t\ttscanf[a]=toread;\n\t\t\t\t\ttoread=dscanf[i];\n\t\t\t\t\tdscanf[i]=dscanf[a];\n\t\t\t\t\tdscanf[a]=toread;\n\t\t\t\t\ttoread=xscanf[i];\n\t\t\t\t\txscanf[i]=xscanf[a];\n\t\t\t\t\txscanf[a]=toread;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=R;i++){\n\t\td=dscanf[i];\n\t\tt=tscanf[i];\n\t\tx=xscanf[i];\n\t\tP[d]+=x;\n\t\tmax=0;\n\t\tif(i!=1){\n\t\t\tfor(i2=1;i2<=R;i2++){\n\t\t\t\tif(P[i2]>P[max]){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t\telse if(P[i2]==P[max]&&i2<max){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t}\n\t\tT[team]+=t-time;\n\t\t}\n\t\ttime=t;\n\t\tteam=max;\n\t\tT[0]=0;\n\t}\n\tif(time!=L){\n\t\tT[max]=L-time;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(T[i]>T[max]){\n\t\t\tmax=i;\n\t\t}\n\t\telse if(T[i]==T[max]&&i<max){\n\t\t\tmax=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100001)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\nint n_;\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int score[4*MAX_N -1],time[4*MAX_N -1];\n  int r,l,n;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  n_=n;\n  n=1;\n  while(n<n_) n*=2;\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    //printf(\"k=%d\\n\",k);\n    updata(time, k, time[k+n-2]+t, n);\n\n    //printf(\"b\\n\");\n    updata(score, d, score[d+n-2]+x, n);\n  \n\n    /*printf(\"c\");\n    \n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n-1;i<n*2-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n      }*/\n    \n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-2]+t, n);\n\n  /*\n  printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-2;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n_) return k-n+2; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  else if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point {\n  int x,y;\n  bool operator < (const Point& p) const {\n    if( y != p.y ) return y < p.y;\n    return x > p.x;\n  }\n};\nostream& operator << (ostream& os,const Point& p) {\n  os << p.x/* <<\" \"<< p.y*/;\n}\n\nint score[100001];\nint t[1000000];\nint time_[1000000];\nint main(){\n  priority_queue<Point> Q;\n  priority_queue<Point> T;\n  int N,R,L;\n  int d,x;\n  int dmy;\n  int a=1,b=0;\n\n  cin >>N>>R>>L;\n\n\n  for(int i=0;i<R;i++){\n    cin >>d>>t[i]>>x;    \n    score[d]+=x;\n    Q.push((Point){d,score[d]});  \n \n    while(score[Q.top().x] != Q.top().y){\n      Q.pop();\n    }\n    time_[a]+=t[i]-b; \n    T.push((Point){a,time_[a]});\n    a=Q.top().x;\n    b=t[i];\n    T.push((Point){a,time_[a]});\n    \n  }\n  \n  while( !Q.empty() && score[Q.top().x] != Q.top().y){\n    Q.pop();\n  }\n  time_[a]+=L-b;\n  if( !Q.empty() ) a=Q.top().x;\n  else a = 1;\n  b=L;\n  T.push((Point){a,time_[a]});\n \n  cout <<T.top()<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <climits>\n\nusing namespace std;\n\n//typedef __int64 lint;\n\nconst double EPS = 1e-10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int INF = 1001001001;\n//const lint INFLL = (__int64)1001001001001001001;\n\n#define clear(a) memset((a), 0, sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\npair<int, int> seg[1 << 18];\n\nvoid update(int k, int x)\n{\n\tint id = k + 1;\n\tk += (1 << 17) - 1;\n\tseg[k].first += x;\n\tseg[k].second = id;\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\tif (seg[k * 2 + 1].first > seg[k * 2 + 2].first){\n\t\t\tseg[k] = seg[k * 2 + 1];\n\t\t}\n\t\telse if (seg[k * 2 + 1].first < seg[k * 2 + 2].first){\n\t\t\tseg[k] = seg[k * 2 + 2];\n\t\t}\n\t\telse {\n\t\t\tseg[k] = seg[k * 2 + 1];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint N, R, L;\n\tint team[100000] = {0};\n\t\n\tscanf(\"%d %d %d\", &N, &R, &L);\n\t\n\tfor (int i = 0; i < N; i++) update(i, 0);\n\t\n\tint prev = 0;\n\tint top = 0;\n\tfor (int i = 0; i < R; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\tteam[top] += b - prev;\n\t\tupdate(a - 1, c);\n\t\ttop = seg[0].second - 1;\n\t\tprev = b;\n\t}\n\tteam[top] += L - prev;\n\t\n\tint maxi = 0;\n\tfor (int i = 1; i < N; i++) if (team[maxi] < team[i]) maxi = i;\n\t\n\tprintf(\"%d\\n\", maxi + 1);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nstruct Event {\n  int id,time,score;\n  bool operator < ( const Event& event ) const {\n    if( time != event.time ) return time < event.time;\n    if( id   != event.id   ) return id   < event.id;\n    return score > event.score;\n  }\n};\n\nstruct Data {\n  int id,score;\n  bool operator < ( const Data& data ) const {\n    if( score != data.score ) return score < data.score;\n    return id > data.id;\n  }\n};\n\nconst int MAX_N = 200000;\nint sum[MAX_N],total_score[MAX_N];\nint N,R,L;\n\nint main(){\n  cin >> N >> R >> L;\n  vector<Event> buf(R);\n  rep(i,R) cin >> buf[i].id >> buf[i].time >> buf[i].score;\n  rep(i,R) --buf[i].id;\n  buf.push_back((Event){0,0,0});\n  buf.push_back((Event){0,L,0});\n  sort(buf.begin(),buf.end());\n  rep(i,N) sum[i] = total_score[i] = 0;\n  \n  priority_queue<Data> Q;\n  int prev = 0,pre_id = 0;\n  rep(i,(int)buf.size()){\n    Event e = buf[i];\n    sum[e.id] += e.score;\n    Q.push((Data){e.id,sum[e.id]});\n    while( !Q.empty() && sum[Q.top().id] != Q.top().score ) Q.pop();\n    total_score[pre_id] += e.time - prev;\n    prev = e.time;\n    pre_id = Q.top().id;\n  }\n  int maxi = 0;\n  rep(i,N) if( total_score[i] > total_score[maxi] ) maxi = i;\n  cout << maxi + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;\ntypedef long long int64;\n\ntypedef pair< int, int > Pi;\n\nint n;\nvector< Pi > seg;\nvoid update( int id, int x){\n  int i = id + n - 1;\n  seg[i].first += x;\n  seg[i].second = -id;\n  while(i > 0){\n    i = ( i - 1 ) / 2;\n    seg[i] = max( seg[i * 2 + 1], seg[i * 2 + 2]);\n  }\n}\nvoid init( int& size){\n  n = 1;\n  while( n < size ) n *= 2;\n  seg.resize( n * 2 - 1, Pi(-1,-1));\n}\n\nint main(){\n  int N, R, L;\n  scanf(\"%d %d %d\", &N, &R, &L);\n  init(N);\n  for(int i = 0; i < N; i++) update( i, 0);\n\n\n  int most = 0, now = 0;\n  vector< int > array(N, 0);\n\n  while(R--){\n    int d, t, x;\n    scanf(\"%d %d %d\", &d, &t, &x);\n    d--;\n    array[most] += t - now;\n    update( d, x);\n    now = t;\n    most = -seg[0].second;\n  }\n  array[most] += L - now;\n  printf(\"%d\\n\", distance( array.begin(), max_element( array.begin(), array.end())) + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nbool operator <(const P &p1, const P &p2) {\n\tif (p1.second == p2.second) return p1.first > p2.first;\n\treturn p1.second < p2.second;\n}\n\nstruct Data {\n\tint d, t, x;\n\tData(int d, int t, int x) : d(d), t(t), x(x) { }\n};\n\nbool compare(const Data &d1, const Data &d2) {\n\treturn d1.t < d2.t;\n}\n\nint main() {\n\tvector<Data> v;\n\n\tint N, R, L; cin >> N >> R >> L;\n\tfor (int i = 0; i < R; ++i) {\n\t\tint d, t, x; cin >> d >> t >> x;\n\t\tv.push_back( Data(d-1, t, x) );\n\t}\n\tsort( v.begin(), v.end(), compare );\n\n\tvector<int> ans(N, 0);\n\tvector<P> datas;\n\tfor (int i = 0; i < N; ++i) {\n\t\tdatas.push_back( P(i, 0) ); // テヲツ可凝・ツ可催」ツ?古」ツ?ァテ」ツ?凝」ツ??\n\t}\n\n\tint bt = 0, last = datas.size() - 1;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tint t = v[i].t;\n\t\tint d = v[i].d; // テ」ツδ?」ツδシテ」ツδ?ァツ閉ェテ・ツ渉キ\n\t\tint x = v[i].x; // テ・ツ環?ァツつケ or テヲツクツ崚ァツつケ テ・ツ按?\n\n\t\tint pos = -1;\n\t\tfor (int i = 0; i < datas.size(); ++i) {\n\t\t\tif (datas[i].first == d) {\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// テ・ツ環?ァツョツ?\n\t\tans[datas[0].first] += t - bt;\n\n\t\tdatas[pos].second += x;\n\t\tif (x < 0) { // テヲツクツ崚ァツつケ\n\t\t\tfor (int i = pos + 1; i < datas.size(); ++i) {\n\t\t\t\tif ( !(datas[i-1] < datas[i]) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswap( datas[i-1], datas[i] );\n//\t\t\t\tcout << (i-1) << \" \" << i << endl;\n\t\t\t}\n\t\t}\n\t\telse if (x > 0) { // テ・ツ環?ァツつケ\n\t\t\tfor (int i = pos - 1; i >= 0; --i) {\n\t\t\t\tif ( datas[i+1] < datas[i] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswap( datas[i+1], datas[i] );\n///\t\t\t\tcout << (i+1) << \" \" << i << endl;\n\t\t\t}\n\t\t}\n\n\t\tbt = t;\n\t}\n\tans[datas[0].first] += L - bt;\n\n\tint ansNo = 0, ansT = -1;\n\tfor (int i = 0; i < ans.size(); ++i) {\n\t\tif (ans[i] > ansT) {\n\t\t\tansT = ans[i];\n\t\t\tansNo = i;\n\t\t}\n\t}\n\tcout << (ansNo + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint main()\n{\n\tint n,r,l,ans[100000]={},score[100000]={};\n\tcin>>n>>r>>l;\n\tint last=0;\n\tint m=0;//????????£????????§?????????????????£?????????????????????ID\n\tfor(int i=0;i<r;i++){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x;\n\t\tscore[--d]+=x;\n\t\tif(x>=0){\n\t\t\tif(score[d]>score[m]||((score[d]==score[m])&&d<m)){\n\t\t\t\tans[m]+=t-last;\n\t\t\t\tlast=t;\n\t\t\t\tm=d;\n\t\t\t}\n\t\t}else if(m==d){\n\t\t\tint tmp=m;\n\t\t\tfor(int j=0;j<n;j++)if(score[j]>score[m]||((score[j]==score[m])&&j<m))tmp=j;\n\t\t\tans[m]+=t-last;\n\t\t\tlast=t;\n\t\t\tm=tmp;\t\t\t\n\t\t}\n\t}\n\tans[m]+=l-last;\n\tint res1=0,res2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(res1<ans[i]){\n\t\t\tres1=ans[i];\n\t\t\tres2=i;\n\t\t}\n\t}\n\tres2++;\n\tcout<<res2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N, R, L;\n    while(cin >> N >> R >> L && N){\n        const int B = sqrt(N);\n        vector<int> bucket((N - 1) / B + 1);\n        vector<int> point(N + B, INT_MIN);\n        REP(i, N) point[i] = 0;\n        int last_time = 0;\n        int camera_id = 0;\n        vector<int> answer(N + B);\n        for(int i = 0; i < R; i++){\n            int d, t, x;\n            scanf(\"%d %d %d\", &d, &t, &x);\n            d--;\n            point[d] += x;\n            if(point[d] > bucket[d / B]){\n                bucket[d / B] = point[d];\n            }else if(point[d] - x == bucket[d / B]){\n                bucket[d / B] = *max_element(point.begin() + (d / B) * B, point.begin() + (d / B) * (B + 1));\n            }\n            answer[camera_id] += t - last_time;\n            last_time = t;\n            if(camera_id == d && x < 0){\n                //REP(i, N) cout << point[i] << \" \"; cout << endl;\n                //REP(i, (N - 1) / B + 1) cout << bucket[i] << \" \"; cout << endl;\n                int k = max_element(bucket.begin(), bucket.end()) - bucket.begin();\n                camera_id = max_element(point.begin() + k * B, point.begin() + k * (B + 1)) - point.begin();\n            }else if(point[d] > point[camera_id]){\n                camera_id = d;\n            }\n            //printf(\"time:%d point[%d] += %d camera: %d\\n\", t, d + 1, x, camera_id + 1);\n        }\n        answer[camera_id] += L - last_time;\n        cout << max_element(answer.begin(), answer.end()) - answer.begin() + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define INF -(1<<30)\ntypedef pair<int,int>P;\nvoid update(int i,int x);\nP query(int a,int b,int i,int l,int r);\nint n=1;\nP dat[400009];\nint sum[100009];\n\nint main(){\n  int m,q,l;\n  int t[1000009];\n  cin>>m>>q>>l;\n  t[q]=l;\n  while(n<m)n*=2;\n  for(int i=0;i<n*2-1;i++){\n    dat[i].fi=0;\n    dat[i].se=0;\n  }\n  for(int i=1;i<=n;i++){\n    update(i,0);\n  }\n  for(int i=0;i<=q;i++){\n    int d,x;\n    if(i!=q)cin>>d>>t[i]>>x;\n    int id=n-dat[0].se;\n    int time;\n    if(i)time=t[i]-t[i-1];\n    else time=t[i];\n    sum[id]+=time;\n    if(i!=q)update(d,x);\n  }\n\n  int mx=-1,ans;\n  for(int i=1;i<=m;i++){\n    if(mx<sum[i]){\n      mx=sum[i];\n      ans=i;\n    }\n  }\n  cout<<ans<<endl;\n  return(0);\n}\n\nvoid update(int i,int x){\n  i=n-i;\n  int j=i+n-1;\n  dat[j].fi+=x;\n  dat[j].se=i;\n  while(j>0){\n    j=(j-1)/2;\n    dat[j]=max(dat[j*2+1],dat[j*2+2]);\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\t\n\t/*\n\tfor(int i=0; i<7; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tcout << a - b <<endl;\n\t\t*/\n\t/*\n\tfor(int i=0; i<4; i++){\n\t\tint T, K;\n\t\tcin >> T >> K;\n\t\tif(T == 1){\n\t\t\tcout << K*6000 << endl;\n\t\t}\n\t\telse if(T == 2){\n\t\t\tcout << K*4000 << endl;\n\t\t}\n\t\telse if(T == 3){\n\t\t\tcout << K*3000 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << K*2000 << endl;\n\t\t}\n\n\t}\n\t*/\n\t/*\n\tint n;\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tint x, y, b, p;\n\t\tcin >> x >> y >> b >> p;\n\n\t\tif(b >= 5 && p >= 2){\n\t\t\tcout << (x*b + y*p)*4/5 << endl;\n\t\t}\n\n\t\telse{\n\t\t\tcout << min(x*b + y*p,(x * max(b,5) + y * max(p,2))*4/5 ) << endl;\n\t\t}\n\t}\n\t*/\n\t/*\t\n\tfor(int data = 0; data<100; data++){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)return 0;\n\n\t\tint  N = n;\n\t\tbool jud = false;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tif(k == 0) N--;\n\t\t\telse if(k > 1)jud = true;\n\t\t}\n\n\t\tif(jud == false) cout << \"NA\" << endl;\n\t\telse cout << N+1 << endl;\n\n\n\t}\n\t*/\n\t/*\n\tfor(int D = 0; D < 100; D++){\n\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)return 0;\n\t\tint hand[10] = {};\n\t\tint ba = 0;\n\n\t\tstring top;\n\t\tcin >> top;\n\n\t\tfor(int i=0; i<100; i++){\n\t\t\tif(top[i] == 'M') hand[i%n]++;\n\t\t\tif(top[i] == 'S'){\n\t\t\t\tba += hand[i%n]+1;\n\t\t\t\thand[i%n] = 0;\n\t\t\t}\n\t\t\tif(top[i] == 'L'){\n\t\t\t\thand[i%n]+=ba+1;\n\t\t\t\tba = 0;\n\t\t\t}\n\t\t}\n\n\t\tsort(hand,hand+n);\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcout << hand[i] << \" \";\n\t\t}\n\t\tcout << ba << endl;\n\n\t}\n\t*/\n\t/*\n\tint q;\n\tcin >> q;\n\n\tfor(int i=0; i<q; i++){\n\t\tint c,a,n,ans = 0;\n\t\tcin >> c >> a >> n;\n\t\tint can = min(min(c,a),n);\n\t\t//can\n\t\tans+=can;\n\t\tc-=can;\n\t\ta-=can;\n\t\tn-=can;\n\n\t\t//acc\n\t\tint acc = min(c/2,a);\n\t\tans+=acc;\n\t\ta-=acc;\n\t\tc-=acc*2;\n\n\t\t//ccc\n\t\tans+=c/3;\n\n\t\tcout << ans << endl;\n\n\t}\n\t*/\n\n\tint team,change,second;\n\tcin >> team >> change >> second;\n\n\tint tv[100100] = {},point[100100] = {},top = 1,secb = 0;//,tv[byousuu],point[id]\n\n\n\tfor(int i=1; i<=change+1; i++){\n\n\t\tif(i == change+1){\n\t\t\ttv[top]+= second-secb;\n\t\t\tbreak;\n\t\t}\n\n\t\tint num,sec,poi;\n\t\tcin >> num >> sec >> poi;\n\t\ttv[top] += sec-secb;\n\n\t\tsecb = sec;\n\n\t\tpoint[num]+=poi;\n\n\t\tif(num != top){\n\t\t\tif(point[num] > point[top] || (point[num] == point[top] && num < top) )top = num;\n\t\t}\n\t\telse if(poi < 0){\n\t\t\tfor(int j=1; j<=team; j++){\n\t\t\t\tif(point[j] > point[top] || (point[j] == point[top] && j < top)) top = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1; i<=team; i++){\n\t\tif(tv[i] > tv[top]) top = i;\n\t}\n\n\tcout << top << endl;\n\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct team{\n    long long n,p,time;\n};\n\nstruct re{\n    int d,x;\n    long long t;\n};\n\nbool operator<(const team& t1,const team& t2){\n    if(t1.p==t2.p){\n        return t1.n > t2.n;\n    }\n    return t1.p < t2.p;\n}\n\nbool operator<(const re& r1,const re& r2){\n    return r1.t < r2.t;\n}\n\npriority_queue<team> q;\nre rec[1000001];\nteam tea[100001];\n\nint main() {\n\n    long long n,r,l;\n\n    cin >> n >> r >> l;\n\n\n\n    for(int i=0;i<r;i++){\n        cin >> rec[i].d >> rec[i].t >> rec[i].x;\n    }\n\n    sort(rec,rec+r);\n\n    /*for(int i=0;i<r;i++){\n        cout << rec[i].d << \" \" << rec[i].t << \" \" << rec[i].x << endl;\n    }*/\n\n    for(int i=1;i<=n;i++){\n        tea[i].n = i;\n        tea[i].p = 0;\n        tea[i].time = 0;\n        q.push(tea[i]);\n    }\n    /*while (!q.empty()) {\n        cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n        q.pop();\n    }*/\n    /*for(int i=0;i<=n;i++){\n        cout << tea[i].n << \" \" <<  tea[i].p << \" \" << tea[i].time << endl;\n    }*/\n\n\n\n    tea[ rec[0].d ].p += rec[0].x;\n    //cout << \"point is  \" << tea[ rec[0].d].p << endl;\n    q.push(tea[rec[0].d]);\n    team tmp = q.top(); q.pop();\n    //cout << tmp.n <<\" \" << tmp.p << \" \" << tmp.time << endl;\n    tea[tmp.n].time += rec[0].t;\n    //q.push(tea[tmp.n]);\n\ncout << endl;\n /*   while (!q.empty()) {\n        tmp = q.top();\n        cout << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n        cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n        cout << endl;\n        q.pop();\n    }*/\n\n    for(int i=1;i<r-1;i++){\n        tea[ rec[i].d ].p += rec[i].x;\n        q.push(tea[rec[i].d]);\n        tmp = q.top(); q.pop();\n        //cout << i << \" \" << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n        if(rec[i+1].t != rec[i].t) {\n            tea[tmp.n].time += rec[i + 1].t - rec[i].t;\n            //q.push(tea[tmp.n]);\n        }\n    }\n\n    tea[ rec[r-1].d ].p = rec[r-1].x;\n    q.push(tea[rec[0].d]);\n    tmp = q.top(); q.pop();\n    //cout << tmp.n << tmp.p << tmp.time << endl;\n    tea[tmp.n].time += l - rec[r-1].t;\n    //q.push(tea[tmp.n]);\n\n    /*while (!q.empty()) {\n       tmp = q.top();\n       cout << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n       cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n       cout << endl;\n       q.pop();\n   }*/\n\n\n    /*for(int i=0;i<=n;i++){\n        cout << tea[i].time << endl;\n    }*/\n\n\n    int ans=1;\n\n    for(int i=2;i<=n;i++){\n        ans = tea[i].time > tea[ans].time ? i : ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P {\n\tint id, score;\n\tP(int id, int score) : id(id), score(score) { }\n};\n\nbool operator <(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id > p2.id;\n\treturn p1.score < p2.score;\n}\nbool operator >(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id < p2.id;\n\treturn p1.score > p2.score;\n}\n\nstruct Data {\n\tint d, t, x;\n\tData(int d, int t, int x) : d(d), t(t), x(x) { }\n};\n\nbool compare(const Data &d1, const Data &d2) {\n\treturn d1.t < d2.t;\n}\n\nint main() {\n\tvector<Data> v;\n\n\tint N, R, L; cin >> N >> R >> L;\n\tfor (int i = 0; i < R; ++i) {\n\t\tint d, t, x; cin >> d >> t >> x;\n\t\tv.push_back( Data(d-1, t, x) );\n\t}\n\tsort( v.begin(), v.end(), compare );\n\n\tpriority_queue<P> Q;\n\tfor (int i = 0; i < N; ++i) {\n\t\tQ.push( P(i, 0) );\n\t}\n\n\tvector<int> score(N, 0);\n\tvector<int> broadTime(N, 0);\n\n\tint bt = 0;\n\tint maxNo = 0;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tint t = v[i].t;\n\t\tint pos = v[i].d; // テ」ツδ?」ツδシテ」ツδ?ァツ閉ェテ・ツ渉キ\n\t\tint x = v[i].x; // テ・ツ環?ァツつケ or テヲツクツ崚ァツつケ テ・ツ按?\n\n\t\tP top = Q.top();\n\n\t\t// テ・ツ環?ァツョツ?\n\t\tbroadTime[top.id] += t - bt;\n\t\tscore[pos] += x;\n\t\tif (x > 0) { // テ・ツ環?ァツつケ\n\t\t\tif (pos != top.id) {\n\t\t\t\tqueue<P> Q2;\n\t\t\t\twhile ( 1 ) {\n\t\t\t\t\tP data = Q.top(); Q.pop();\n\t\t\t\t\tif (data.id == pos) {\n\t\t\t\t\t\tdata.score = score[pos];\n\t\t\t\t\t\tQ.push(data);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tQ2.push(data);\n\t\t\t\t}\n\t\t\t\twhile ( !Q2.empty() ) {\n\t\t\t\t\tQ.push( Q2.front() ); Q2.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile ( 1 ) {\n\t\t\tP Top = Q.top();\n\t\t\tif (Top.score == score[Top.id] ) break;\n\n\t\t\tQ.pop();\n\t\t\tQ.push( P(Top.id, score[Top.id]) );\n\t\t}\n\n//\t\tcout << \":\" << top.id << endl;\n\n\t\tbt = t;\n\t}\n\tbroadTime[Q.top().id] += L - bt;\n\n\tint ansNo = 0, ansT = -1;\n\tfor (int i = 0; i < broadTime.size(); ++i) {\n\t\tif (broadTime[i] > ansT) {\n\t\t\tansT = broadTime[i];\n\t\t\tansNo = i;\n\t\t}\n//\t\tcout << \":\" << broadTime[i] << endl;\n\t}\n\tcout << (ansNo + 1) << endl;\n\n\tfor (int i = 0; i < score.size(); ++i) {\n//\t\tcout << score[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint n,r,L; scanf(\"%d%d%d\",&n,&r,&L);\n\n\tset< pair<int,int> > S;\n\trep(i,n) S.insert(make_pair(0,i));\n\n\tint t_prev=0;\n\tstatic int score[100000],total[100000];\n\twhile(r--){\n\t\tint d,t,x; scanf(\"%d%d%d\",&d,&t,&x); d--;\n\n\t\ttotal[S.begin()->second]+=t-t_prev;\n\n\t\tS.erase(S.find(make_pair(-score[d],d)));\n\t\tscore[d]+=x;\n\t\tS.insert(make_pair(-score[d],d));\n\n\t\tt_prev=t;\n\t}\n\ttotal[S.begin()->second]+=L-t_prev;\n\n\tprintf(\"%d\\n\",max_element(total,total+n)-total+1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint main()\n{\n  int n,r,l;\n  for(;cin>>n>>r>>l;)\n    {\n      // id,score;\n      pair<int,int> tree[n*2-1];\n      for(int i=0;i<n*2-1;i++)\n\ttree[i]=make_pair(0,-1);\n      int time[n+1];\n      memset(time,0,sizeof(time));\n      //初期化\n      for(int i=1;i<=n;i++)\n\t{\n\t  int num=(i-1)+(n-1);\n\t  tree[num].first=i;\n\t  tree[num].second=0;\n\t  pair<int ,int>base;\n\t  while(true)\n\t    {\n\t      num=(num-1)/2;\n\t      if(num*2+2<n*2-1 &&\n\t\t tree[num*2+1].second < tree[num*2+2].second\n\t\t )\n\t\tbase=tree[num*2+2];\n\t      else\n\t\tbase=tree[num*2+1];\n\t      tree[num]=base;\n\t      if(num==0)break;\n\t    }\n\t}\n      int oldtime=0;\n      for(int i=0;i<r;i++)\n\t{\n\t  int d,t,x;\n\t  cin>>d>>t>>x;\n\t  time[tree[0].first]+=(t-oldtime);\n\t  oldtime=t;\n\t  //木の更新\n\n\t  d--;\n\t  int num=d+(n-1);\n\t  //\t  tree[num].first=i;\n\t  tree[num].second+=x;\n\t  pair<int ,int>base;\n\t  while(true)\n\t    {\n\t      num=(num-1)/2;\n\t      if(num*2+2<n*2-1 &&\n\t\t tree[num*2+1].second < tree[num*2+2].second\n\t\t )\n\t\tbase=tree[num*2+2];\n\t      else\n\t\tbase=tree[num*2+1];\n\t      tree[num]=base;\n\t      if(num==0)break;\n\t    }\n\n\t}\n      time[tree[0].first]+=(l-oldtime);\n      int max_time=0;\n      int max_id;\n      for(int i=n;i>0;i--)\n\t{\n\t  if(max_time<=time[i])\n\t    {\n\t      max_time=time[i];\n\t      max_id=i;\n\t    }\n\t}\n      cout<<max_id<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Data{\n  int x, z;\n\n  bool operator < (const Data& data) const{\n    if(z != data.z) return z < data.z;\n    return x > data.x;\n\n  }\n};\n\nstruct Result{\n  int x, y;\n\n  bool operator < (const Result& result) const{\n    if(y != result.y) return y < result.y;\n    return x > result.x;\n  }\n};\n\nint ta[100001], lt[100001];\n\nint main(){\n  int n, r, limit;\n  int x, y, z;\n  int max = -999999;\n  int t = 0, tt = 1;\n  priority_queue<Data> Q;\n  priority_queue<Result> P;\n\n  cin >> n >> r >> limit;\n\n  for(int i = 0; i < r; i++){\n    cin >> x >> y >> z;\n    ta[x] += z;\n    Q.push((Data){x,ta[x]});\n    while(!Q.empty() && Q.top().z != ta[Q.top().x]) Q.pop();\n    lt[tt] += y - t; \n      t = y;\n      tt = Q.top().x;\n  }\n\n  lt[tt] += limit - t;\n\n  max = 1;\n  for(int i = 1; i <= n; i++){\n    if(lt[i] > lt[max])\n      max = i;\n  }\n\n  cout << max << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define F first\n#define S second\n#define INF 1>>20\nusing namespace std;\ntypedef pair<int,int> P;\nvoid update(int k,int x);\nvoid init(int n_);\nP pamax(P a,P b);\nP seg[1111111];\nint n,r,l;//左からチーム数、レコード数、制限時間\nint main(){\n  int time[1111111]={0};\n  int top=0,btime=0;\n  int d,t,x;//左からチームID、獲得した時間、加減得点\n  cin >> n >> r >> l;\n  init(n);\n  for(int i=0;i<r;i++){\n    cin >> d >> t >> x;\n    time[top]+=t-btime;\n    btime=t;\n    update(d-1,x);//チームIDと加減得点\n    top=seg[0].F-1;//一位奴の更新\n  }\n  time[top]+=l-btime;\n  for(int i=1;i<n;i++){//映ってる時間がもっとも多いチームを調べる\n    if(time[top]<time[i])top=i;\n  }\n  cout << top << endl;\n}\n\nvoid init(int n_){\n  int n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<n;i++){\n    seg[i]=P(0,0);\n  }\n}\n\nvoid update(int k,int x){\n  int id=k+1;\n  k+=n-1;\n  seg[k].F=id;\n  seg[k].S+=x;\n  while(k>0){\n    k=(k-1)/2;\n    seg[k]=pamax(seg[k*2+1],seg[k*2+2]);\n  }\n}\n\nP pamax(P a,P b){\n  int x,y;\n  x=a.S;\n  y=b.S;\n  if(x<y)return b;\n  else return a;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nint main(){\n\n\tint n, r, l;\n\tstd::cin >> n >> r >> l;\n\n\tstd::vector<int>time(n, 0);\n\tstd::vector<int>score(n, 0);\n\n\tint id_now = 0, time_before = 0;\n\n\tfor (int i = 0; i < r; i++){\n\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\n\t\td--;\n\n\t\ttime[id_now] += (t - time_before);\n\t\tscore[d] += x;\n\n\t\tid_now = 0;\n\t\tfor (int j = 1; j < n; j++){\n\t\t\tif (score[j]>score[id_now])id_now = j;\n\t\t}\n\n\t\ttime_before = t;\n\t}\n\n\ttime[id_now] += (l - time_before);\n\n\tint res = 0;\n\n\tfor (int i = 1; i < n; i++){\n\t\tif (time[i]>time[res])res = i;\n\t}\n\n\tstd::cout << res + 1 << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// Custom Header {{{\n#define ALL(x) x.begin(), x.end()\nusing namespace std;\nusing i64 = long long;\nusing pii = pair<i64, i64>;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF  = 0x3f3f3f3f;\nconstexpr i64 LINF = 0x3f3f3f3f3f3f3f3fLL;\n// }}}\n\nstruct Team {\n    int id;\n    i64 score;\n\n    Team(int id=0, i64 score=0) : id(id), score(score) {}\n    bool operator> (const Team &o) const {\n        if (score == o.score) {\n            return id < o.id;\n        } else {\n            return score > o.score;\n        }\n    }\n    bool operator< (const Team &o) const {\n        if (score == o.score) {\n            return id > o.id;\n        } else {\n            return score < o.score;\n        }\n    }\n};\n\ntemplate<class Monoid> struct SegTree { // {{{\n    using Func = function<Monoid(Monoid, Monoid)>;\n    const int sz;\n    const Func fn;\n    const Monoid unity;\n    vector<Monoid> dat;\n\n    SegTree(int n, const Monoid &u, Func f)\n        : sz(1 << (__lg(n+5) + 1)), fn(f), unity(u), dat(sz*2, unity) {}\n\n    void set(int k, const Monoid &v) { dat[k + sz] = v; }\n\n    Monoid& operator[] (int k) { return dat[k + sz]; }\n\n    void build() { for (int k = sz-1; k > 0; --k) dat[k] = fn(dat[2*k], dat[2*k+1]); }\n\n    void update(int k, const Monoid &v) {\n        dat[ k += sz ] = v;\n        while(k >>= 1) dat[k] = fn(dat[2*k], dat[2*k+1]);\n    }\n\n    Monoid query(int a, int b) const {\n        Monoid L = unity,  R = unity;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = fn(L, dat[a++]);\n            if (b & 1) R = fn(dat[--b], R);\n        }\n        return fn(L, R);\n    }\n}; // }}}\n\nint d[1000100];\nint t[1000100];\ni64 x[1000100];\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N, R, L;\n    cin >> N >> R >> L;\n\n    for (int i = 1; i <= R; ++i) {\n        cin >> d[i] >> t[i] >> x[i];\n    }\n\n    SegTree<Team> seg(N, Team(0, -LINF), [](const Team &a, const Team &b) { return (a > b) ? a : b; });\n\n    for (int i = 1; i <= N; ++i) {\n        seg.update(i, Team(i, 0));\n    }\n\n    vector<i64> tsum(N+1, 0);\n\n    for (int i = 1; i <= R; ++i) {\n        const auto top = seg.query(1, N+1);\n        tsum[top.id] += t[i] - t[i-1];\n\n        const auto p = seg[d[i]];\n        seg.update(d[i], Team(d[i], p.score + x[i]));\n    }\n    const auto top = seg.query(1, N+1);\n    tsum[top.id] += L - t[R];\n\n    int longest = *max_element(begin(tsum) + 1, end(tsum));\n\n    for (int i = 1; i <= N; ++i) {\n        if (tsum[i] == longest) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n\n\n\n    return 0;\n}\n\n// vim: set foldmethod=marker :\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[131250];\nstruct node {\n    int id, point;\n} node[1<<18];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint n,r,l;\nstruct log{\n\tint d[1000000];\n\tint x[1000000];\n};\nlog team;\nint t[1000000+1];\npriority_queue <pair<int,int> >que;\npair<int,int> p;\nint pnt[100000];\nint tm[100000];\nint mx;\nint mnum;\nint main(){\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d%d%d\",&team.d[i],&t[i],&team.x[i]);\n\t}\n\tt[r]=l;\n\tfor(int i=0;i<r;i++){\n\t\tpnt[team.d[i]]+=team.x[i];\n\tfor(int j=1;j<=n;j++){\n\t\tque.push(make_pair(pnt[j],j*(-1)));\n\t}\n\t\tp=que.top();\n\t\ttm[p.second*(-1)]+=t[i+1]-t[i];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tque.pop();\n\t\t}\n\t\tcout<<p.second*(-1)<<\" \"<<tm[p.second*(-1)]<<\" \"<<pnt[p.second*(-1)]<<endl;\n\t}\n\tmx=tm[1];\n\tfor(int i=1;i<=n;i++){\n\t\tif(mx<tm[i]){\n\t\t\tmx=tm[i];\n\t\t\tmnum=i;\n\t\t}\n\t}\n\tcout<<mnum<<endl;\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 20000\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\nstruct segtree{\n  int N;\n  P dat[MAX_N * 2 - 1];\n  segtree(){}\n  segtree(int n){\n    N = 1;\n    while(n > N) N *= 2;\n\n    rep(i, 2 * N - 1) dat[i] = MP(-1000000, -1000000);\n    for(int i = N - 1; i < 2 * N - 1; i++) dat[i] = MP(0, -1 * (i - N + 1));\n  }\n\n  void update(int k, int a){\n    k += N - 1;\n    dat[k].F += a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1], dat[2*k+2]);\n    }\n  }\n\n  P query(int a, int b){ return query(a, b, 0, 0, N); }\n  P query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return P(-100000, -1000000);\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      P vl = query(a, b, 2*k+1, l, (l+r)/2);\n      P vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return max(vl, vr);\n    }\n  }\n};\n\nint main(){\n  int N, R, L;\n  int res[MAX_N];\n  scanf(\"%d%d%d\", &N, &R, &L);\n  segtree seg(N);\n  rep(i, N) seg.update(i, 0);\n  int time = 0;\n  rep(i, R){\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x); d--;\n    P s = seg.query(0, N);\n    res[-s.second] += t - time;\n    seg.update(d, x);\n    time = t;\n  }\n\n  P s = seg.query(0, N);\n  res[-s.second] += L - time;\n\n  int ans = 0;\n  rep(i, N) if(res[ans] < res[i]) ans = i;\n\n  printf(\"%d\\n\", ans+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[150010];\nstruct node {\n    int id, point;\n} node[1<<21];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[199999];\nint point[100000];\nint n=1;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\ta[c] = P(d, p(0, 0));\n\tc++;\n\twhile (n < b)n <<= 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment[n + i - 1].second = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tkousin(0, 0);\n\t}\n\tn--;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nstatic const int MAX_N = 1000001;\n\nint T_Time[MAX_N], Score[MAX_N];\n\nint main()\n{\n\n\tint N, R, L, d, t, x, most, P_T = 0, P_D = 1;\n\tpriority_queue< pair< int, int > > ScoreHeap;\n\n\tmemset( Score , 0, sizeof( Score ) );\n\tmemset( T_Time, 0, sizeof( T_Time ) );\n\n\tcin >> N >> R >> L;\n\n\tfor( int i = 0; i < R; i++ ) {\n\n\t\tcin >> d >> t >> x;\n\t\tScore[d] += x;\n\n\t\tScoreHeap.push( make_pair( Score[d], -d ) );\n\n\t\twhile( true ) {\n\n\t\t\tpair< int, int > temp = ScoreHeap.top();\n\t\t\tif( temp.first == Score[-temp.second] ) {\n\n\t\t\t\tT_Time[P_D] += t - P_T;\n\t\t\t\tP_D = -temp.second;\n\t\t\t\tP_T = t;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tScoreHeap.pop();\n\n\t\t}\n\n\t}\n\n\tT_Time[P_D] += L - P_T;\n\n\tint Max = 0;\n\n\tfor( int i = 1; i <= N; i++ ) {\n\t\tif( Max < T_Time[i] ) { Max = T_Time[i]; most = i; }\n\t}\n\n\tcout << most << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define double long double\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef vector<pii> VP;\ntypedef vector<string> VS;\ntypedef priority_queue<int> PQ;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n#define eps 1e-12 \n//priority_queue<int,vector<int>, greater<int> > q2;\n\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, R, L; cin >> N >> R >> L;\n\tset<pii>S;\n\tREP(i, N) S.emplace(pii(0, -i));\n\tVI score(N, 0);\n\tVI ans(N, 0);\n\tint bf = 0;\n\tREP(i, R) {\n\t\tint id, now, p; cin >> id >> now >> p;\n\t\tid--;\n\t\tauto it = S.rbegin();\n\t\t//it--;\n\t\t//cout << it->second << endl;\n\t\tans[-it->second] += (now - bf);\n\t\tS.erase(pii(score[id], -id));\n\t\tscore[id] += p;\n\t\tS.emplace(score[id], -id);\n\t\tbf = now;\n\t}\n\t\n\tauto it = S.rbegin();\n\t//it--;\n\tans[-it->second] += (L - bf);\n\t\n\tint res = -1;\n\tint tmp = 0;\n\tREP(i, N) {\n\t\tif (ans[i] > tmp) {\n\t\t\ttmp = ans[i];\n\t\t\tres = i;\n\t\t}\n\t}\n\tcout << res + 1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct SegmentTree{\n  typedef pair<int, int> Pi;\n  const int INF = (1 << 30);\n  vector<Pi> data;\n  int sz;\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz *= 2;\n    data.resize(2*sz-1, Pi(-1, -1));\n  }\n  void update(int k, int x)\n  {\n    int id = -k;\n    k += sz - 1;\n    data[k].first += x;\n    data[k].second = id;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = max(data[2*k+1], data[2*k+2]);\n    }\n  }\n};\n\nint main()\n{\n  int N, R, L;\n  cin >> N >> R >> L;\n  SegmentTree seg(N);\n  for(int i = 0; i < N; i++) seg.update(i, 1);\n  vector<int> tv(N, 0);\n  int cur = 0, elp = 0;\n  while(R--){\n    int d, t, x;\n    cin >> d >> t >> x;\n    --d;\n    seg.update(d, x);\n    tv[cur] += t - elp;\n    cur = -seg.data[0].second;\n    elp = t;\n  }\n  tv[cur] += L - elp;\n  cout << max_element(tv.begin(), tv.end()) - tv.begin() + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[100010], p[100010];\nint main()\n{\n    int n, r, l;\n    scanf(\"%d%d%d\", &n, &r, &l);\n    map<int, vector<pair<int, int>>> history;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n        history[t].push_back(make_pair(d, x));\n    }\n\n    set<pair<int, int>, greater<pair<int, int>>> s;\n    s.insert(make_pair(0, -1));\n    int pt=0;\n    for(auto& i: history) {\n        int id=-s.begin()->second;\n        int t=i.first;\n        a[id]+=t-pt;\n        for(auto& j: i.second) {\n            int d=j.first;\n            int x=j.second;\n            auto k=s.find(make_pair(p[d], -d));\n            if (k!=s.end()) s.erase(k);\n            p[d]+=x;\n            s.insert(make_pair(p[d], -d));\n        }\n        pt=t;\n    }\n    a[-s.begin()->second]+=l-(history.rbegin()->first);\n    //for(int i=1;i<=n;++i) printf(\"%d \", a[i]); puts(\"\");\n    printf(\"%d\\n\", max_element(a+1, a+n+1)-a);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint P[100000],T[100000];\nint main() {\n    int N,R,L,PT=0,n1=0,p1=0;\n    scanf(\"%d %d %d\",&N,&R,&L);\n    for(int i=0;i<R;i++) {\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x); d--;\n        P[d]+=x;\n        if(x>0) {\n            if(P[d]>p1||(P[d]==p1&&n1>d)) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=d;\n                p1=P[d];\n            }\n        }\n        if(x<0) {\n            if(d!=n1) continue;\n            int n2=n1,p2=P[d];\n            for(int j=N-1;j>=0;j--) {\n                if(p2<=P[j]) {n2=j,p2=P[j];}\n            }\n            if(n2!=n1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=n2;\n                p1=p2;\n            }\n        }\n    }\n    T[n1]+=L-PT+1;\n    int ans_n=0,ans_t=0;\n    for(int i=0;i<N;i++) {\n        if(ans_t<T[i]) {\n            ans_t=T[i];\n            ans_n=i;\n        }\n    }\n    printf(\"%d\\n\",ans_n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, int> P;\nconst LL INF = 2 << 60;\n\nconst int MAX_N = 262144;\nP dat[MAX_N * 2 - 1];\nLL times[MAX_N];\n\nint n, r, l;\n\nvoid init()\n{\n\tfor (int i = 0; i < 2 * n - 1; i++)\n\t{\n\t\tdat[i] = P(0, -(2 << 20));\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdat[n + i - 1].second = -i;\n\t}\n}\n\nvoid update(int i, LL x)\n{\n\ti += n - 1;\n\tdat[i].first += x;\n\twhile (i > 0)\n\t{\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n}\n\nP query(int a, int b, int k, int l, int r)\n{\n\tif(r <= a || b <= l) return P(-INF, -1);\n\tif(a <= l && r <= b) return dat[k];\n\telse\n\t{\n\t\tP vl = query(a, b,k * 2 + 1, l, (l + r) / 2);\n\t\tP vr = query(a, b,k * 2 + 1, (l + r) / 2, r);\n\t\tif(vr > vl) return vr;\n\t\treturn vl;\n\t}\n}\n\nint main(void)\n{\n\twhile(cin >> n >> r >> l && n >= 2)\n\t{\n\t\tvector<int> d(r), x(r), t(r);\n\t\tfor (int i = 0; i < r; i++)\n\t\t{\n\t\t\tcin >> d[i] >> x[i] >> t[i];\n\t\t\td[i]--;\n\t\t}\n\t\tinit();\n\t\tmemset(times, 0, sizeof(times));\n\t\tP pre = P(0,0);\n\t\tint pret = 0;\n\t\tfor (int i = 0; i < r; i++)\n\t\t{\n\t\t\tif(i + 1 < r && t[i] == t[i + 1])\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tupdate(d[i], x[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tupdate(d[i], x[i]);\n\t\t\tP p = query(0, n-1, 0, 0, n);\n\t\t\ttimes[-pre.second] += (t[i] - pret);\n\t\t\tpret = t[i];\n\t\t\tpre = p;\n\t\t}\n\t\tcout << (max_element(times, times + n) - times) + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\nconst int MAX_N = 1 << 8;\nint n;\npii dat[2 * MAX_N - 1];\n\nvoid init(int n_)\n{\n\tn = 1;\n\twhile (n < n_)n *= 2;\n\tfor (int i = 0; i < 2 * n - 1; i++)dat[i] = pii(INT_MAX,0);\n}\n\nvoid update(int k, pii a)\n{\n\tk += n - 1;\n\tdat[k] = a;\n\twhile (k > 0)\n\t{\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\npii query(int a, int b, int k, int l, int r)\n{\n\tif (r <= a || b <= l)return pii(INT_MAX,0);\n\tif (a <= l&&r <= b)return dat[k];\n\telse\n\t{\n\t\tpii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\n\npii calc(int a, int b)//[a,b)\n{\n\treturn query(a, b, 0, 0, n);\n}\n\nsigned main()\n{\n\tint r, l;\n\tcin >> n >> r >> l;\n\tint ans[100001] = {};\n\tinit(n);\n\tfor (int i = 0; i < n; i++)update(i, pii(0,i));\n\tint b = 0;\n\twhile (r--)\n\t{\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x; d--;\n\t\tans[calc(0, n).second] += t-b;\n\t\tb = t;\n\t\tpii p = dat[d+ n - 1];\n\t\tp.first -= x;\n\t\tupdate(d , p);\n\t}ans[calc(0, n).second] += l - b;\n\tint p = -1, id = 0;\n\tfor (int i = n-1; i >= 0; i--)\n\t{\n\t\tif (ans[i] >= p)\n\t\t{\n\t\t\tp = ans[i];\n\t\t\tid = i + 1;\n\t\t}\n\t}\n\n\n\tcout << id << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int inf = (int)1e+9;\n\nconst int max = (int)1e+6 + 1;\n\nint n, r, l;\nP seg[max * 2];\nint point[max];\n\nvoid init(){\n\tint x = 1;\n\twhile (x < n)x *= 2;\n\tn = x;\n\trep(i, max * 2)seg[i].first = -inf, seg[i].second = 0;\n\tREP(i, n - 1, n * 2 - 1)seg[i].second = i - (n - 1);\n}\n\nvoid update(int k, int e){\n\tk += n - 1;\n\tseg[k].first += e;\n\twhile (k > 0){\n\t\tk = (k - 1) / 2;\n\t\tint BigI;\n\t\tif (seg[k * 2 + 1].first == seg[k * 2 + 2].first)BigI = std::min(seg[k * 2 + 1].second, seg[k * 2 + 2].second);\n\t\telse BigI = (seg[k * 2 + 1].first > seg[k * 2 + 2].first ? k * 2 + 1 : k * 2 + 2);\n\t\tseg[k].first = seg[BigI].first;\n\t\tseg[k].second = seg[BigI].second;\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tint before = 0;\n\tinit();\n\trep(i, r){\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\t\t--d;\n\t\tpoint[seg[0].second] += (t - before);\n\t\tupdate(d, x);\n\t\tbefore = t;\n\t}\n\tpoint[seg[0].second] += (l - before);\n\n\tint maxI = 0;\n\tREP(i, 1, n){\n\t\tif (point[i] > point[maxI])maxI = i;\n\t}\n\tstd::cout << maxI + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint point[100001];\nint times[100001];\n\nint main() {\n\n    int n,r,l;\n\n    cin >> n >> r >> l;\n\n    priority_queue<pair<int,int> > que;//??????,????????????\n\n    que.push(make_pair(0,1));\n\n    int lasttime = 0;\n\n    for(int i=0;i<r;i++){\n        int d,t,x;\n        cin >> d >> t >> x;\n        pair<int,int> p = que.top();\n        while(p.first != point[p.second] && !que.empty()){\n            que.pop();\n            p = que.top();\n        }\n\n        times[p.second] += t - lasttime;\n        lasttime = t;\n\n        point[d] += x;\n\n        que.push(make_pair(point[d],d));\n\n    }\n\n    pair<int,int> p = que.top();\n    while(p.first != point[p.second] && !que.empty()){\n        que.pop();\n        p = que.top();\n    }\n    times[p.second] += l - lasttime;\n\n    int ans = -1,anstime = -1;\n\n    for(int i=1;i<=n;i++){\n        if(anstime<times[i]){\n            ans = i;\n            anstime = times[i];\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long d[1000001],t[1000002],x[1000001],a[100001],b[100001];\nint main(void)\n{\n    int n,r,l,w,j,flg,h,g,m,i;\n\tscanf(\"%d %d %d\",&n,&r,&l);\n\tfor(i=1;i<=r;i++){\n\t    scanf(\"%lld %lld %lld\",&d[i],&t[i],&x[i]);\n\t}\n\tt[r+1]=l; d[0]=1; t[0]=0; x[0]=0;\n\tfor(i=1;i<=n;i++){\n\t    b[i]=0;\n\t\ta[i]=0;\n\t}\n\th=1;\n\tg=0;\n\tfor(i=0;i<=r;i++){\n\t    a[d[i]]=a[d[i]]+x[i];\n\t\tw=a[1];\n\t\tflg=1;\n\t\tfor(j=1;j<=n;j++){\n\t\t    if(w<a[j]){\n\t\t\t    w=a[j];\n\t\t\t\tflg=j;\n\t\t\t}\n\t\t}\n\t\tb[h]=b[h]+(t[i]-t[g]);\n\t\tg=i;\n\t\th=flg;\n\t}\n\tw=0;\n\tb[h]=b[h]+(l-t[g]);\n\tfor(i=1;i<=n;i++){\n\t    if(w<b[i]){\n\t\t    w=b[i];\n\t\t\tm=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct T {\n  int i, s;\n\n  bool operator<(const T& right) const {\n    return s == right.s ? i < right.s : s < right.s;\n  }\n};\n\nint MAX_N = 1 << 17;\nint n = 1;\nvector<T> dat(MAX_N * 2 - 1);\nT minT;\n\nvoid update(int k, int a) {\n  k = k + n - 1;\n  dat[k].s += a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint main() {\n  int t, r, l, z = 0, zi = 0, sc[100001] = {};\n  cin >> t >> r >> l;\n  while(t > n) n *= 2;\n  minT.i = 10000000;\n  minT.s = -9999999;\n  rep(i, 0, n * 2 - 1) dat[i] = minT;\n  rep(i, n - 1, n * 2 - 1) dat[i].i = i - (n - 1);\n\n\n\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    sc[zi] += b - z;\n    update(a - 1, c);\n    zi = dat[0].i;\n    z = b;\n  }\n\n  sc[zi] += l - z;\n  int ms = 0, ans;\n  rep(i, 0, t) if(ms < sc[i]) ans = i + 1, ms = sc[i];\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N, R, L;\n    while(cin >> N >> R >> L && N){\n        const int B = sqrt(N);\n        vector<int> bucket((N - 1) / B + 1);\n        vector<int> point(N + B, INT_MIN);\n        REP(i, N) point[i] = 0;\n        int last_time = 0;\n        int camera_id = 0;\n        vector<int> answer(N + B);\n        for(int i = 0; i < R; i++){\n            int d, t, x;\n            scanf(\"%d %d %d\", &d, &t, &x);\n            d--;\n            point[d] += x;\n            if(point[d] > bucket[d / B]){\n                bucket[d / B] = point[d];\n            }else if(point[d] - x == bucket[d / B]){\n                bucket[d / B] = *max_element(point.begin() + (d / B) * B, point.begin() + (d / B + 1) * B);\n            }\n            answer[camera_id] += t - last_time;\n            last_time = t;\n            if(camera_id == d && x < 0){\n                //REP(i, N) cout << point[i] << \" \"; cout << endl;\n                //REP(i, (N - 1) / B + 1) cout << bucket[i] << \" \"; cout << endl;\n                int k = max_element(bucket.begin(), bucket.end()) - bucket.begin();\n                camera_id = max_element(point.begin() + k * B, point.begin() + (k + 1) * B) - point.begin();\n            }else if(point[d] > point[camera_id]){\n                camera_id = d;\n            }\n            //printf(\"time:%d point[%d] += %d camera: %d\\n\", t, d + 1, x, camera_id + 1);\n        }\n        answer[camera_id] += L - last_time;\n        cout << max_element(answer.begin(), answer.end()) - answer.begin() + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\n\nusing namespace std;\nint lis[100000];\nint tim[100000];\nint main() {\n    int n,r,l,d,t,x;\n    scanf(\"%d %d %d\",&n,&r,&l);\n    int top = 0;\n    int id  = 1;\n    int nowtime = 0;\n    int timemax = 0;\n    int timemaxid = 0;\n    for(int i = 0; i < r; i++) {\n        scanf(\"%d %d %d\",&d,&t,&x);\n        tim[id] += t - nowtime;\n        if(tim[id] > timemax) {\n            timemax = tim[id];\n            timemaxid = id;\n        }\n        nowtime = t;\n        lis[d] += x;\n        if(id == d) {\n            top += x;\n        }\n        if(x < 0 && d == id) {\n            for(int j = 1; j < n+1; j++) {\n                if(top < lis[j] || (top == lis[j] && j < id)) {\n                    top = lis[j];\n                    id = j;\n                }\n            }\n            \n        }\n        if(x > 0 && d != id) {\n            if(top < lis[d] || (top == lis[d] && d < id)) {\n                top = lis[d];\n                id = d;\n            }\n        }\n\n    }\n    tim[id] += l - nowtime;\n    if(tim[id] > timemax) {\n        timemax = tim[id];\n        timemaxid = id;\n    }\n    printf(\"%d\\n\",timemaxid);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define MP make_pair\n#define F first\n#define S second\n\ntypedef pair<int, int> P;\n\nint N, R, L;\nint point[100005];\nint res[100005];\n\nint main(){\n  scanf(\"%d%d%d\", &N, &R, &L);\n  int now = 0;\n\n  priority_queue<P>q;\n  rep(i, N) q.push(P(0, -i));\n  rep(i, R){\n    //    printf(\"%d\\n\", i);\n\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x);d--;\n    //    printf(\"%d %d %d\\n\", d, t, x);\n\n    //    printf(\"%d\\n\", i);\n    P p = q.top(); q.pop();\n    while(p.F != point[-p.S]){\n      p = q.top(); q.pop();\n    }\n    q.push(p);\n\n    res[-p.S] += t - now;\n    now = t;\n\n    point[d] += x;\n    //    printf(\"%d\\n\", d);\n    //    rep(j, N) printf(\"%d \", point[j]); puts(\"\");\n    q.push(P(point[d], -d));\n  }\n\n  P p = q.top(); q.pop();\n  while(p.F != point[-p.S]){\n    //    printf(\"%d %d\\n\", p.F, point[-p.S]);\n    p = q.top(); q.pop();\n  }\n  //  printf(\"%d %d\\n\", p.F, point[-p.S]);\n  res[-p.S] += L - now;\n\n  //  rep(i, N) printf(\"%d \", res[i]); puts(\"\");\n  int team = 0;\n  rep(i, N) if(res[team] < res[i]) team = i;\n  printf(\"%d\\n\", team+1);\n  exit(0);\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct T {\n  int i, s;\n\n  bool operator<(const T& right) const {\n    return s == right.s ? i < right.s : s < right.s;\n  }\n};\n\nint MAX_N = 1 << 17;\nint n = 1;\nvector<T> dat(MAX_N * 2 - 1);\nT minT;\n\nvoid update(int k, int a) {\n  k = k + n - 1;\n  dat[k].s += a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nT query(int a, int b, int k, int l, int r) {\n  if(r <= a || b <= l) return minT;\n  if(a <= l && r <= b) return dat[k];\n\n  T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n  return max(vl, vr);\n}\n\nint main() {\n  int t, r, l, z = 0, zi = 0, sc[100001] = {};\n  cin >> t >> r >> l;\n  while(t > n) n *= 2;\n  rep(i, n - 1, n * 2 - 1) dat[i].i = i - (n - 1);\n  minT.i = 10000000;\n  minT.s = 0;\n\n\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    sc[zi] += b - z;\n    update(a - 1, c);\n    zi = dat[0].i;\n    z = b;\n  }\n\n  sc[zi] += l - z;\n  int ms = 0, ans;\n  rep(i, 0, t) if(ms < sc[i]) ans = i + 1, ms = sc[i];\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "n, r, l = map(int, input().split())\npoint, time = [], []\nrev = {0: []}\nfor i in range(n):\n    point.append(0)\n    time.append(0)\n    rev[0].append(i)\n\nnow, tv, tmax = 0, 0, 0\nfor i in range(r):\n    d, t, x = map(int, input().split())\n    time[tv] += t - now\n    now = t\n    m = point[d-1]\n    rev[point[d-1]].remove(d-1)\n    point[d-1] += x\n    if point[d-1] in rev:\n        rev[point[d-1]].append(d-1)\n    else:\n        rev[point[d-1]] = [d-1]\n    if tv != d-1: \n        if point[tv] == point[d-1]:\n            tv = min(tv, d-1)\n        elif point[tv] < point[d-1]:\n            tv = d-1\n    elif x < 0:\n        if rev[m] != []:\n            tv = min(rev[m])\n        else:\n            tv = min(rev[max(point)])\n\ntime[tv] += l - now\n\nm = max(time)\ni = 0\nwhile True:\n    if time[i] == m:\n        print(i+1)\n        break\n    i += 1"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\nint const TREE_SIZE = (1 << 20);\nlong long int seg_tree[TREE_SIZE];\n\n// 1-indexed\n\nvoid change(int a, long long int w){\n\t\n\t// a番目にwを足す O(log N)\n\t\n\ta += TREE_SIZE / 2;\n\t\n\tseg_tree[a] += w;\n\t\n\tfor(int x = a / 2; x > 0; x /= 2){\n\t\tseg_tree[x] = max(seg_tree[2 * x], seg_tree[2 * x + 1]);\n\t}\n}\n\nlong long int query(int a, int b, int index, int l, int r){\n\t\n\t// 区間 [a, b) の最小値を求める O(log N)\n\t// query(a, b, 1, 0, TREE_SIZE / 2) のように呼ぶ\n\t\n\tif(r <= a || b <= l){\n\t\treturn -INF;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn seg_tree[index];\n\t}\n\t\n\treturn max(query(a, b, index * 2, l, (l + r) / 2), query(a, b, index * 2 + 1, (l + r) / 2, r));\n}\n\nlong long int S[110000] = {};\n\nint main(){\n    long long int N, R, L;\n    cin >> N >> R >> L;\n\tfor(int i = 0; i < TREE_SIZE; i++){\n\t\tseg_tree[i] = 0;\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tchange(i, N - i + 1);\n\t}\n    long long int t_pre = 0, MUL = 1000000, id;\n    for(int i = 0; i < R; i++){\n        long long int d, t, x;\n        cin >> d >> t >> x;\n        id = N - (query(1, N + 1, 1, 0, TREE_SIZE / 2) % MUL + MUL) % MUL + 1;\n        S[id] += t - t_pre;\n        t_pre = t;\n\t\tchange(d, x * MUL);\n    }\n    id = N - (query(1, N + 1, 1, 0, TREE_SIZE / 2) % MUL + MUL) % MUL + 1;\n    S[id] += L - t_pre;\n    long long int ans, SS = 0;\n    for(int i = 1; i <= N; i++){\n        if(SS < S[i]){\n            SS = S[i];\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[131000];\nstruct node {\n    int id, point;\n} node[1<<18];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000001;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tint f = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\t\tf = 1;\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t\tf = 0;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tf = 0;\n\t\t}\n\t\tif(Time[i] > 0 && f == 1) {\n\t\t\tn =i;\n\t\t\tf = 1;\n\t\t}\n\t\tif(i == L)Team_max[temp1] += L-n;\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[500000];\nint point[100000];\nint n=1;\nint b;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\ta[c] = P(d, p(0, 0));\n\tc++;\n\tn = b;\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment[n + i - 1].second = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tkousin(0, 0);\n\t}\n\tn = b - 1;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct dat{ int id, point; };\n#define MAX_N 100000\n\nint N, R, L;\nint res[MAX_N + 1];\ndat seg[MAX_N * 2];\nint n;\n\nvoid init(){\n\tn = 1;\n\twhile(n < N) n *= 2;//nはseg木の要素数\n\tn *= 2;\n\tfor(int i = 0; i < n; i++) seg[i].point = 0;\n\tn /= 2 * 2;\n\tfor(int j = 1; j <= N; j++){\n\t\tseg[n + j].id = j;\n\t}\n}\n\nvoid add(int p, int x){\n\tp += n;\n\tseg[p].point += x;\n\twhile(p > 0){\n\t\t//printf(\"p = %d\\n\", p);\n\t\tp = (p - 1) / 2;\n\t\tif(seg[p * 2 + 1].point >= seg[p * 2 + 2].point){\n\t\t\tseg[p] = seg[p * 2 + 1];\n\t\t}\n\t\telse{\n\t\t\tseg[p] = seg[p * 2 + 2];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\tinit();\n\t\n\tint lb = 0;//左端\n\tint d, t, x;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tif(i > 0) res[seg[0].id] += t - lb;\n\t\tadd(d, x);\n\t\tlb = t;\n\t\t//for(int i = 1; i <= N; i++){\n\t\t//\tprintf(\"%d \", res[i]);\n\t\t//}\n\t\t//printf(\": seg[0].id = %d\\n\", seg[0].id);\n\t}\n\tres[seg[0].id] += L - t;\n\t\n\tint longest = 0;//最長の映り時間\n\tfor(int i = 1; i <= N; i++) longest = max(longest, res[i]);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(res[i] == longest){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\npair<int,int> rmq[1111111];\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-1;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      if(t[i] == t[i+1]){\n\tteam[smp-2] += t[i] - now1;\n      }\n      else if(now != t[i]){\n\tteam[smp-2] += t[i] - now;\n\tnow1 = now;\n      }\n      now = t[i];\n      }\n    smp = rmq[0].second;\n  }\n  team[smp-2] += L - now;\n  int a=0;\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d-1+e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;scanf(\"%lld%lld%lld\",&x,&y,&z);\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=max(segment[S*2+1],segment[S*2+2],[](P a,P b){if(a.first!=b.first)return a.first>b.first;return a.second<=b.second;});\n\t    }\n\tpoint[team]+=y-last;\n\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <regex>\n#include <vector>\n\n#define fix(n)          cout<<fixed<<setprecision(n)\n#define rep(i,n)        for (int i = 0; i < (n); ++i)\n#define all(a)          (a).begin(), (a).end()\n#define sort(a)         sort(all(a))\n#define uniq(a)         sort(a);(a).erase(unique(all(a)), (a).end())\n#define reverse(a)      reverse(all(a))\n#define ctos(c)         string(1, (c))\n#define out(d)          cout << (d)\n#define outl(d)         std::cout<<(d)<<\"\\n\"\n#define YES()           cout << \"YES\" << endl\n#define NO()            cout << \"NO\" << endl\n#define Yes()           cout << \"Yes\" << endl\n#define No()            cout << \"No\" << endl\n#define ceil(x, y)      ((x + y - 1) / (y))\n#define debug(x)        cerr << #x << \": \" << (x) << '\\n'\n#define debug2(x, y)    cerr << #x << \": \" << (x) << \", \" << #y << \": \" << (y) << '\\n'\n#define debug3(x, y, z) cerr << #x << \": \" << (x) << \", \" << #y << \": \" << (y) << \", \" << #z << \": \" << (z) << '\\n'\n#define dbg(v)          for (size_t _ = 0; _ < v.size(); ++_){ cerr << #v << \"[\" << _ << \"] : \" << v[_] << '\\n'; }\n#define pb              push_back\n#define fst             first\n#define int             long long\n#define INF             __LONG_LONG_MAX__\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll,ll>;\n\nconst ll MOD = 1000000007; // 10^9 + 7\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nvoid solve() {\n  ll N, R, L; cin >> N >> R >> L;\n  vector<ll> time(N, 0), score(N, 0);\n  priority_queue<P> pq; rep(i, N) pq.emplace(0, -i);\n\n  ll prevtime = 0, looks, lookt;\n  rep(i, R) {\n    while (1) {\n      tie(looks, lookt) = pq.top();\n      lookt *= -1;\n      if (score[lookt] == looks) break;\n      else pq.pop();\n    }\n    ll d, t, x; cin >> d >> t >> x; d--;\n\n    time[lookt] += t - prevtime;\n    prevtime = t;\n\n    score[d] += x;\n    pq.emplace(score[d], -d);\n  }\n\n  while (1) {\n    tie(looks, lookt) = pq.top();\n    lookt *= -1;\n    if (score[lookt] == looks) break;\n    else pq.pop();\n  }\n  time[lookt] += L - prevtime;\n\n  ll ans, maxt = -1;\n  rep(i, N) {\n    if (time[i] > maxt) {\n      maxt = time[i];\n      ans = i;\n    }\n  }\n\n  outl(ans+1);\n}\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  srand((unsigned)time(NULL));\n  fix(12);\n\n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000000;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N));\n\tmemset(takai_n,0,sizeof(takai_n+N));\n\tmemset(takai,0,sizeof(takai+N));\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\tcout << Team_max[temp1] << endl; \n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\tif(Time[i] > 0) n =i;\n\t\tif(i == L)Team_max[temp1] += L-n;\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstruct RMQ {\n  pair<int, int> DEF;\n  int n;\n  vector<pair<int, int> > d;\n  \n  RMQ(int n) {\n    DEF = make_pair(-1e9, 1e9);\n    this-> n = n;\n    d.resize(2 * n - 1);\n    rep (i, 2 * n - 1) d[i] = DEF;\n  }\n\n  void update(int k, int a) {\n    k += n - 1;\n    d[k] = make_pair(a, k - (n - 1));\n    while (k > 0) {\n      k = (k - 1) / 2;\n      d[k] = function(d[k * 2 + 1], d[k * 2 + 2]);\n    }\n  }\n\n  pair<int, int> query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return DEF;\n    if (a <= l && r <= b) return d[k];\n    pair<int, int> vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    pair<int, int> vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return function(vl, vr);\n  }\n\n  pair<int, int> query(int a, int b) {\n    return query(a, b, 0, 0, n);\n  }\n\n  pair<int, int> function(pair<int, int> l, pair<int, int> r) {\n    if (l.first > r.first) return l;\n    if (l.first < r.first) return r;\n    if (l.first < r.first) return l;\n    return r;\n  }\n};\n\nint main() {\n  int n, r, l;\n  cin >> n >> r >> l;\n  int score[n], res[n];\n  RMQ rmq(n);\n  rep (i, n) rmq.update(i, 0);\n  rep (i, n) rmq.update(i, 0);\n  rep (i, n) res[i] = 0;\n  rep (i, n) score[i] = 0;\n  int pre = 0;\n  rep (i, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    int k = rmq.query(0, n).second;\n    res[k] += t - pre;\n    --d;\n    score[d] += x;\n    rmq.update(d, score[d]);\n    pre = t;\n  }\n  int k = rmq.query(0, n).second;\n  res[k] += l - pre;\n  int mi = 0, mx = 0;\n  rep (i, n) if (mx < res[i]) {\n    mi = i;\n    mx = res[i];\n  }\n  cout << mi + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000000;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\tif(Time[i] > 0) n =i;\n\t\tif(i == L)Team_max[temp1] += L-n;\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 1000000\n#define MAX_TEAM 1000000\n\npriority_queue<pair<long long, long long>> Q;\nlong long d[MAX_TEAM], n, s, L, x[MAX_N], y[MAX_N], t[MAX_N], ti[MAX_TEAM], maxn, maxid;\n\nint main() {\n\tcin >> n >> s >> L;\n\tQ.push(make_pair(0, -10000000));\n\tx[0] = 1; t[0] = 0; y[0] = 0; x[s + 1] = 1; t[s + 1] = L; y[s + 1] = 0;\n\tfor (int i = 1; i <= s; i++) { cin >> x[i] >> t[i] >> y[i]; }\n\tfor (int i = 0; i <= s; i++) {\n\t\td[x[i]] += y[i];\n\t\tQ.push(make_pair(d[x[i]], -x[i]));\n\t\twhile (true) {\n\t\t\tpair<int, int>p = Q.top();\n\t\t\tif (p.first == d[-p.second]) {\n\t\t\t\tti[-p.second] += t[i + 1] - t[i]; break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (maxn < ti[i]) {\n\t\t\tmaxn = ti[i];\n\t\t\tmaxid = i;\n\t\t}\n\t}\n\tcout << maxid << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[1000010], p[1000010];\nint main()\n{\n    int n, r, l;\n    scanf(\"%d%d%d\", &n, &r, &l);\n    map<int, vector<pair<int, int>>> history;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n        history[t].push_back(make_pair(d, x));\n    }\n\n    set<pair<int, int>, greater<pair<int, int>>> s;\n    s.insert(make_pair(0, -1));\n    int pt=0;\n    for(auto& i: history) {\n        int id=-s.begin()->second;\n        int t=i.first;\n        a[id]+=t-pt;\n        for(auto& j: i.second) {\n            int d=j.first;\n            int x=j.second;\n            auto k=s.find(make_pair(p[d], -d));\n            if (k!=s.end()) s.erase(k);\n            p[d]+=x;\n            s.insert(make_pair(p[d], -d));\n        }\n        pt=t;\n    }\n    a[-s.begin()->second]+=l-(history.rbegin()->first);\n    //for(int i=1;i<=n;++i) printf(\"%d \", a[i]); puts(\"\");\n    printf(\"%d\\n\", max_element(a+1, a+n+1)-a);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint score[100000];\nint tim[100000];\n\nint main(){\n\tint i,j;\n\tint n,r,l,d,t,x;\n\tint mi;\n\tint lt=0;\n\tint identify,lidentify=0;\n\tcin >> n >> r >> l ;\n\tfor(i=0;i<100000;i++) score[i]=0;tim[i]=0;\n\tfor(i=0;i<r;i++){\n\t\tcin >> d >> t >> x;\n\t\tscore[d-1]+=x;\n\t\tidentify=lidentify;\n\t\tif(score[d-1] > score[lidentify] && x>=0) identify=d-1;\n\t\tif(score[d-1] == score[lidentify] && d-1<lidentify) identify=d-1;\n\t\t/*if(x<0) {\n\t\t\tidentify=0;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(score[j] > score[identify]) identify=j;\n\t\t\t}\n\t\t}*/\n\n\t\ttim[lidentify] += (t - lt);\n\t\t//cout << lidentify << \":\" << (t-lt) << endl;\n\t\tlt = t;lidentify=identify;\n\t}\n\ttim[lidentify] += l-lt;\n\t//cout << lidentify << \":\" << (l-lt) << endl;\n\tidentify=0;\n\tfor(i=0;i<n;i++){\n\t\tif(tim[i] > tim[identify]) identify = i;\n\t}\n\tcout << identify + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nint INF=1<<28;\nstruct SegmentTree{\n\tvector<int> dat;\n\tvector<int> mi;\n\n\tint n,size;\n\tSegmentTree(int _n){\n\t\tn=Pow2Fit(_n)<<1;\n\t\tsize=2*n-1;\n\t\tdat=vector<int>(size,-INF);\n\t\tmi=vector<int>(size,INF);\n\t}\n\tint Pow2Fit(int n){\n\t\t  n = n | (n >>  1);n = n | (n >>  2);n = n | (n >>  4);n = n | (n >>  8);n = n | (n >> 16);\n\t\t  return n ^ (n >> 1);\n\t}\n\n\tvoid update(int v,int a){\n\t\tv+=n-1;\n\t\tdat[v]=a;\n\t\tmi[v]=v-(n-1);\n\t\twhile(v>0){\n\t\t\tint parent=v=(v-1)/2;\n\t\t\tint chl=parent*2+1,chr=parent*2+2;\n\t\t\tif(dat[chl]>=dat[chr])mi[parent]=mi[chl];\t\t\t\t\n\t\t\telse mi[parent]=mi[chr];\n\t\t\tdat[parent]=max(dat[chl],dat[chr]);\n\t\t}\n\t}\n\n\tint query(int a,int b){\n\t\treturn query(0,a,b,0,n);\n\t}\n\n\tprivate:\n\tint query(int v,int a,int b,int l,int r){\n\t\tif(r<=a || b<=l)return -1;//out range\n\t\tif(a<=l && r<=b)return mi[v];\n\n\t\tint vl=query(v*2+1,a,b,l,(l+r)/2);\n\t\tint vr=query(v*2+2,a,b,(l+r)/2,r);\n\t\tif(vl==-1)return vr;\n\t\tif(vr==-1)return vl;\n\n\t\tif(dat[vl+(n-1)]>=dat[vr+(n-1)])return vl;\n\t\telse return vr;\n\t}\n};\n\nclass Task{\n\tpublic:\n\tint d,t,x;\n\tTask(int d,int t,int x):d(d),t(t),x(x){\n\t}\n\n\tbool operator < (const Task& r) const {\n\t\treturn t< r.t;\n\t}\n};\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,R,L;cin >> N >> R >> L;\n\t\tvector<Task> ts;\n\t\tREP(i,R){\n\t\t\tint d,t,x;cin >> d >> t >> x;d--;\n\t\t\tts.push_back(Task(d,t,x));\n\t\t}\n\t\tsort(ALL(ts));\n\n\t\tvector<int> vs(N);\n\t\tSegmentTree seg(N);\n\t\tREP(i,N)seg.update(i,0);\n\n\t\tint pt=0;\n\t\tREP(i,R){\n\t\t\tvs[seg.query(0,N)]+=ts[i].t-pt;\n\t\t\tpt=ts[i].t;\n\t\t\tseg.update(ts[i].d,seg.query(ts[i].d,ts[i].d+1)+ts[i].x);\n\t\t}\n\t\tvs[seg.query(0,N)]+=L-pt;\n\n\t\tint Mv=0;\n\t\tREP(i,N){\n\t\t\tMv=max(Mv,vs[i]);\n\t\t}\n\t\tREP(i,N)if(Mv==vs[i]){\n\t\t\tcout <<i+1<<endl;return;\n\t\t}\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF 2000000000\n#define fi first\n#define sec second\nconst int SIZE = 1<<17;\nint N,R,L;\nstruct segtree\n{\n\tP seg[SIZE*2];\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tseg[i+SIZE-1].fi=0;\n\t\t\tseg[i+SIZE-1].sec=-i;\n\t\t}\n\t}\n\tvoid build()\n\t{\n\t\tfor(int i=SIZE-2;i>=0;i--)seg[i]=max(seg[i*2+1],seg[i*2+2]);\n\t}\n\tvoid update(int k,int x)\n\t{\n\t\tk+=SIZE-1;\n\t\tseg[k].fi+=x;\n\t\twhile(k>0)\n\t\t{\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=max(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tP query(int a,int b,int k,int l,int r)\n\t{\n\t\tif(r<=a||b<=l)return P(-INF,INF);\n\t\telse if(a<=l&&r<=b)return seg[k];\n\t\telse return max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t}\n\tP query()\n\t{\n\t\treturn query(0,N,0,0,SIZE);\n\t}\n};\nsegtree seg;\nint total[100100];\nint d[1000100],t[1000100],x[1000100];\nint main()\n{\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tfor(int i=0;i<R;i++)\n\t{\n\t\tscanf(\"%d %d %d\",&d[i],&t[i],&x[i]);\n\t\td[i]--;\n\t}\n\tt[R]=L;\n\tseg.init();\n\tseg.build();\n\ttotal[-((seg.query()).sec)]+=t[0];\n\tfor(int i=0;i<R;i++)\n\t{\n\t\tseg.update(d[i],x[i]);\n\t\ttotal[-((seg.query()).sec)]+=t[i+1]-t[i];\n\t}\n\tint ansv=-1,ans;\n\tfor(int i=0;i<N;i++)if(ansv<total[i])\n\t{\n\t\tansv=total[i];\n\t\tans=i;\n\t}\n\tprintf(\"%d\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001];\n  int time[100001];\n\n\n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  score[0].first = -10000000;  \n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1+1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t  int flg = 0;\n\t  if(score[2*site1+1] < score[site1] &&score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[2*site1+flg];\n\t  score[2*site1+flg] = tmp;\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;*/\n\n  }\n\n\n  time[score[1].second] += L-t;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<limits.h>\nusing namespace std;\n#define max fahjkfhkahfsj\ntypedef pair<int,int> P;\nlong long int team[100001],ten[100001];\nint main(void){\n\tpriority_queue<P> qu;\n\tlong long int n,r,l,i,m,mm,d,t,x,ans,max;\n\tP ppp;\n\tcin>>n>>r>>l;\n\tfor(i=1;i<=n;i++){\n\t\tteam[i]=0;\n\t\tten[i]=0;\n\t}\n\tcin>>d>>t>>x;\n\tten[d]+=x;\n\tqu.push(P(ten[d],d*-1));\n\tm=t; mm=d; max=LONG_MIN;\n\tfor(i=1;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\tten[d]+=x;\n\t\tqu.push(P(ten[d],d*-1));\n\t\tppp=qu.top();\n\t\tif(ppp.first!=ten[mm]){\n\t\t\tteam[mm]+=t-m;\n\t\t\tif(max<team[mm]){\n\t\t\t\tmax=team[mm];\n\t\t\t\tans=mm;\n\t\t\t}\n\t\t\tm=t; mm=d;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<utility>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nconst int MAX_N = 1000000;\n\ntypedef std::pair<int, int> P;\n\nint N, R, L;\n\nint sz;\nP dat[2*MAX_N-1];\n\nvoid init( int n )\n{\n\tsz = 1;\n\twhile( sz < n )\n\t\tsz <<= 1;\n\n\trep( i, 2*sz-1 )\n\t\tdat[i] = P( 0, 0 );\n\n\treturn;\n}\n\nvoid update( int k, P p )\n{\n\tk += sz-1;\n\tdat[k].first += p.first;\n\tdat[k].second = p.second;\n\twhile( k > 0 )\n\t{\n\t\tk = (k-1)>>1;\n\t\tdat[k] = std::max( dat[2*k+1], dat[2*k+2] );\n\t}\n\n\treturn;\n}\n\nP query( int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn P( 0, 0 );\n\n\tif( a <= l && r <= b )\n\t\treturn dat[k];\n\telse\n\t\treturn std::max( query( a, b, 2*k+1, l, (l+r)>>1 ), query( a, b, 2*k+2, (l+r)>>1, r ) );\n}\n\nint cnt[1000001];\n\nint main()\n{\n\tscanf( \"%d%d%d\", &N, &R, &L );\n\n\tinit( N );\n\n\trep( i, N )\n\t\tupdate( i, P( 0, -i ) );\n\n\tint prvT, prvid;\n\tbool fst = true;\n\n\trep( i, R )\n\t{\n\t\tint d, t, x;\n\t\tscanf( \"%d%d%d\", &d, &t, &x );\n\n\t\tupdate( d-1, P( x, -(d-1) ) );\n\n\t\tif( !fst )\n\t\t\tcnt[prvid] += t-prvT;\n\t\tprvT = t;\n\t\tprvid = -query( 0, N, 0, 0, sz ).second;\n\t\tfst = false;\n\t}\n\n\tcnt[prvid] += L-prvT;\n\n\tprintf( \"%d\\n\", std::max_element( cnt, cnt+N )-cnt+1 );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> p;\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\np rmq[1111111];\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-2;\n  rmq[k].first += x;\n  rmq[k].second = no;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    //if(smp != rmq[0].second){\n      team[smp] += t[i] - now;\n      now = t[i];\n      //}\n    updata(d[i],x[i]);\n    smp = rmq[0].second;\n  }\n  team[smp] += L - now;\n  int a=0;\n  int ans=1;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n//#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\tvi v(n + 100, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\tupdate(1, 0);\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\t//if(p.se >= 0) continue;\n\t\tif(p.se == 0) p.se = -1;\n\t\telse if(p.se >0) continue;\n\t\t//cout<<p.se<<endl;\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\t// int ans = 0;\n\t// for(int i = 1; i < v.size(); i++){\n\t// \tif(v[ans] < v[i]) ans = i;\n\t// \tcout<<v[i]<<endl; \n\t// }\n\t// cout<<ans<<endl;\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct RMQ{\n  typedef long long Type;\n  int segn2;\n  Type inf;\n  vector<pair<int,Type> > data;\n\n  RMQ(int n){\n    inf = (long long)1e18;\n    segn2 = 1;\n    while(segn2 < n) segn2*=2;\n\n    data.assign(segn2*2,make_pair(0,-inf));\n  }\n\n  int query(){\n    return data[0].first;\n  }\n  \n  void set(int k,Type x){\n    int K= k + segn2-1;\n    data[K] = make_pair(k,x);\n\n    while(K>0){\n      K = (K-1)/2;\n      if(data[K*2+1].second < data[K*2+2].second)\n\tdata[K] = data[K*2+2];\n      else\n\tdata[K] = data[K*2+1];\n    }\n\n  }\n};\n  \n\nint main(){\n  int n,r,l;\n  int d,t=0,x,bt;\n  long long ans[100010] = {0};\n  int memo[100010] ={0};\n  \n  scanf(\"%d%d%d\",&n,&r,&l);\n\n  RMQ rmq(n+1);\n\n  for(int i=1;i<=n;i++){\n    rmq.set(i,0);\n  }\n\n  t = 0;\n  \n  for(int i=0;i<r;i++){\n    bt = t;\n    scanf(\"%d%d%d\",&d,&t,&x);\n\n    ans[rmq.query()] += (t-bt);\n\n    memo[d] += x;\n    rmq.set(d,memo[d]);\n  }\n\n  ans[rmq.query()] += (l-t);\n\n  int ans_max=-(int)1e18,ans_i;\n\n  for(int i=1;i<=n;i++){\n    if(ans_max < ans[i]){\n      ans_max = ans[i];\n      ans_i = i;\n    }\n  }\n\n  cout << ans_i << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <sstream>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define repp(i,k,n) for(int i=k;i<(int)n;i++)\n#define rei(n) for(int i=0;i<(int)n;i++)\n#define rel(n) for(int l=0;l<(int)n;l++)\n#define al(s) s.begin(),s.end()\n#define INT_MAX 2147483647\n\ntypedef pair<long long, int> plli;\npriority_queue<plli,vector<plli> >a;\npriority_queue<plli, vector<plli> >A;\nlong long ans[100001] = {};\nlong long sco[100001] = {};\nint main()\n{\n\tint n, r, l;\n\tcin >> n >> r >> l;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\ta.push(plli(0,(-1)*i ));\n\t}\n\tint b = 0;\n\tfor (int i = 0; i < r; i++)\n\t{\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\twhile (1)\n\t\t{\n\t\t\tif (sco[a.top().second*(-1)] != a.top().first)a.pop();\n\t\t\telse break;\n\t\t}\n\t\tans[a.top().second*-1] += t - b;\n\t\tb = t;\n\t\tsco[d] += x;\n\t\ta.push(plli(sco[d], d*(-1)));\n\t}\n\twhile (1)\n\t{\n\t\tif (sco[a.top().second*(-1)] != a.top().first)a.pop();\n\t\telse break;\n\t}\n\tans[a.top().second*(-1)] += l - b;\n\tlong long ANS = -99999999999999999;\n\tint num=0;\n\tfor (int i = 100000; i >0; i--)\n\t{\n\t\tif (ans[i] >= ANS)\n\t\t{\n\t\t\tANS = ans[i];\n\t\t\tnum = i;\n\t\t}\n\t}\n\t//for (int i = 1; i <= 3; i++)cout << ans[i] << endl;\n\tcout << num << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define int long long\n#define INF 1e+18\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint seg;\nP dat[300000];\n\nvoid add(int i,int x){\n\ti += seg - 1;\n\tdat[i].first += x;\n\twhile(i){\n\t\ti = (i - 1) / 2;\n\t\tif(dat[i * 2 + 1].first < dat[i * 2 + 2].first) dat[i] = dat[i * 2 + 2];\n\t\telse dat[i] = dat[i * 2 + 1];\n\t}\n}\n\nsigned main(){\n\tint n,r,l,cnt[100000] = {},prev = 0;\n\tscanf(\"%lld %lld %lld\",&n,&r,&l);\n\tseg = 1;\n\twhile(seg < n) seg *= 2;\n\tfor(int i = 0;i < seg;i++){\n\t\tif(i < n) dat[i + seg - 1] = P(0,i);\n\t\telse dat[i + seg - 1] = P(-INF,i);\n\t}\n\tfor(int i = seg - 2;i >= 0;i--){\n\t\tif(dat[i * 2 + 1].first < dat[i * 2 + 2].first) dat[i] = dat[i * 2 + 2];\n\t\telse dat[i] = dat[i * 2 + 1];\n\t}\n\tfor(int i = 0;i < r;i++){\n\t\tint d,t,x;\n\t\tscanf(\"%lld %lld %lld\",&d,&t,&x);\n\t\tcnt[dat[0].second] += t - prev;\n\t\tadd(d - 1,x);\n\t\tprev = t;\n\t}\n\tcnt[dat[0].second] += l - prev;\n\tint ma = -1,mii;\n\tfor(int i = 0;i < n;i++){\n\t\tif(ma < cnt[i]){\n\t\t\tmii = i;\n\t\t\tma = cnt[i];\n\t\t}\n\t}\n\tcout << mii + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[500000];\nint point[100000];\nint n=1;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\ta[c] = P(d, p(0, 0));\n\tc++;\n\twhile (n < b)n <<= 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment[n + i - 1].second = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tkousin(0, 0);\n\t}\n\tn--;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nint segt[400000];\nint depth=0;\nint best=0;\nvector<LL> mytime;\n\nint par(int i){\n  if(i==0)\n    return -1;\n  return (i-1)/2;\n}\n\nvoid update(int d,int x){\n  int i=d+(1<<depth)-1;\n  segt[i]+=x;\n  while(par(i)!=-1){\n    segt[par(i)]=max(segt[i],segt[(i+1)/2*4-1-i]);\n    i=par(i);\n  }\n  i=0;\n  while(i<(1<<depth)-1){\n    i=(segt[i]==segt[2*i+1])?2*i+1:2*i+2;\n  }\n  best=i-((1<<depth)-1);\n}\n\nint main(){\n  LL n,r,l;\n  cin >> n>>r>>l;\n\n  while((1<<depth)-1<n){\n    depth++;\n  }\n  REP(i,n)\n    mytime.push_back(0);\n\n  REP(i,1<<(depth+1)){\n    if(i<((1<<depth)-1)+n)\n      segt[i]=0;\n    else\n      segt[i]=-INT_MAX;\n  }\n\n  int d,x,t_prev,t_now=0;\n  REP(i,r){\n    t_prev=t_now;\n    cin>>d>>t_now>>x;\n    if(i==0)\n      mytime[0]+=t_now;\n    else\n      mytime[best]+=t_now-t_prev;\n    update(d-1,x);\n  }\n  mytime[best]+=l-t_now;\n  \n  cout<<1+distance(mytime.begin(),max_element(mytime.begin(),mytime.end()))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<utility>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\ntypedef std::pair<int, int> P;\n\nconst int MAX_N = 1 << 17, INF = 1 << 30;\n\nint sz;\nP dat[2*MAX_N-1];\n\nvoid init( int n )\n{\n\tsz = 1;\n\twhile( sz < n )\n\t\tsz <<= 1;\n\n\trep( i, 2*sz-1 )\n\t\tdat[i] = P( INF, INF );\n\n\treturn;\n}\n\nvoid update( int k, P p )\n{\n\tk += sz-1;\n\tdat[k] = p;\n\n\twhile( k > 0 )\n\t{\n\t\tk = (k-1)>>1;\n\t\tdat[k] = std::min( dat[2*k+1], dat[2*k+2] );\n\t}\n\n\treturn;\n}\n\nP query( int a, int b, int k, int l, int r )\n{\n\tif( b <= l || r <= a )\n\t\treturn P( INF, INF );\n\n\tif( a <= l && r <= b )\n\t\treturn dat[k];\n\telse\n\t\treturn std::min( query( a, b, 2*k+1, l, (l+r)>>1 ), query( a, b, 2*k+2, (l+r)>>1, r ) );\n}\n\nint N, R, L;\nint cnt[MAX_N];\n\nint main()\n{\n\tscanf( \"%d%d%d\", &N, &R, &L );\n\n\tinit( N );\n\trep( i, N )\n\t\tupdate( i, P( 0, i ) );\n\t\n\tint prvT = 0;\n\trep( i, R )\n\t{\n\t\tint d, t, x;\n\t\tscanf( \"%d%d%d\", &d, &t, &x );\n\n\t\tif( prvT != t )\n\t\t\tcnt[query( 0, N, 0, 0, sz ).second] += t - prvT;\n\n\t\t--d;\n\t\tP p = query( d, d+1, 0, 0, sz );\n\t\tupdate( d, P( p.first - x, p.second ) );\n\t\tprvT = t;\n\t}\n\n\tif( L != prvT )\t\n\t\tcnt[query( 0, N, 0, 0, sz ).second] += L - prvT;\n\t\n\tprintf( \"%d\\n\", std::max_element( cnt, cnt+N )-cnt+1 );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<limits.h>\nusing namespace std;\n#define max fahjkfhkahfsj\ntypedef pair<long long int,int> P;\nlong long int team[100001],ten[100001];\nint main(void){\n\tpriority_queue<P> qu;\n\tlong long int n,r,l,i,m,mm,d,t,x,ans,max;\n\tP ppp;\n\tcin>>n>>r>>l;\n\tfor(i=1;i<=n;i++){\n\t\tteam[i]=0;\n\t\tten[i]=0;\n\t}\n\tcin>>d>>t>>x;\n\tten[d]+=x;\n\tqu.push(P(ten[d],d*-1));\n\tm=t; mm=d; max=LONG_MIN;\n\tfor(i=1;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\tten[d]+=x;\n\t\tqu.push(P(ten[d],d*-1));\n\t\tppp=qu.top();\n\t\tif(ppp.first!=ten[mm]){\n\t\t\tteam[mm]+=t-m;\n\t\t\tif(max<team[mm]){\n\t\t\t\tmax=team[mm];\n\t\t\t\tans=mm;\n\t\t\t}\n\t\t\tm=t; mm=d;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n#define N_MAX 100001\ntypedef pair<int,int> P;\n\nint main(){\n  int N,R,L;\n  int d,t,x;\n  int time[N_MAX]={0};\n  int score[N_MAX]={0};\n  cin >> N >> R >> L;\n  priority_queue<P> que;\n  for(int i=1;i<=N;i++){\n    que.push(P(0,N-i));\n  }\n  int now = 0;\n  for(int j=0;j<R;j++){\n    cin >> d >> t >> x;\n    P p1 = que.top();\n    while(score[N-p1.second] != p1.first){\n      que.pop();\n      p1 = que.top();\n    }\n    time[N-p1.second] += t - now;\n    now = t;\n    score[d] += x;\n    que.push(P(score[d],N-d));\n  }\n  P p1 = que.top();\n  while(score[N-p1.second] != p1.first){\n    que.pop();\n    p1 = que.top();\n  }\n  time[N-p1.second] += L - now;\n  priority_queue<P> que2;\n  for(int i=1;i<=N;i++){\n    que2.push(P(time[i],N-i));\n  }\n  p1 = que2.top();\n  cout << N - p1.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nstruct Team{\n\tint id, cost;\n\tTeam(int a, int b):id(a), cost(b){};\n\tbool operator < (const Team &lhs)const {\n\t\tif(cost == lhs.cost)return id > lhs.id;\n\t\treturn cost < lhs.cost;\n\t}\n};\nconst int max = 1000001;\n\nint n, r, l;\nstd::priority_queue<Team> que;\nint score[max];\nint ans[max];\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tque.push(Team(0, 0));\n\tint bef = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tint a, b, c;\n\t\tstd::cin >> a >> b >> c;\n\t\tTeam t = que.top();\n\t\twhile(score[t.id] != t.cost)t = que.top(), que.pop();\n\t\tans[t.id] += (b - bef);\n\t\tbef = b;\n\t\tscore[a - 1] += c;\n\t\tque.push(Team(a - 1, score[a - 1])); \n\t}\n\tTeam t = que.top();\n\tque.pop();\n\twhile(score[t.id] != t.cost)t = que.top(), que.pop();\n\tans[t.id] += (l - bef);\n\n\tint max = 0;\n\tfor(int i = 1; i < n; i++)if(ans[i] > ans[max])max = i;\n\tstd::cout << max + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint P[100000],T[100000];\nint main() {\n    int N,R,L,PT=0,n1=0;\n    scanf(\"%d %d %d\",&N,&R,&L);\n    for(int i=0;i<R;i++) {\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x); d--;\n        P[d]+=x;\n        if(x>0) {\n            if(P[d]>P[n1]||(P[d]==P[n1]&&n1>d)) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=d;\n            }\n        }\n        if(x<0) {\n            if(d!=n1) continue;\n            int n2=n1,p2=P[d];\n            for(int j=N-1;j>=0;j--) {\n                if(p2<=P[j]) {n2=j,p2=P[j];}\n            }\n            if(n2!=n1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=n2;\n            }\n        }\n    }\n    T[n1]+=L-PT+1;\n    int ans_n=0,ans_t=0;\n    for(int i=0;i<N;i++) {\n        if(ans_t<T[i]) {\n            ans_t=T[i];\n            ans_n=i;\n        }\n    }\n    printf(\"%d\\n\",ans_n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9;\nconst ll infll = (ll)1e+17;\n\nconst int max = (int)1e+6 + 1;\n\ntypedef std::pair<ll, int> MP;\n\nint n, r, l;\nMP seg[max * 2];\nll point[max];\nint d[max], t[max], x[max];\n\nvoid init(){\n\tint x = 1;\n\twhile (x < n)x *= 2;\n\tn = x;\n\trep(i, max * 2)seg[i].first = -infll, seg[i].second = 0;\n\tREP(i, n - 1, n * 2 - 1)seg[i].second = i - (n - 1);\n}\n\nvoid update(int k, int e){\n\tk += n - 1;\n\tseg[k].first += e;\n\twhile (k > 0){\n\t\tk = (k - 1) / 2;\n\t\tint BigI = (seg[k * 2 + 1].first >= seg[k * 2 + 2].first ? k * 2 + 1 : k * 2 + 2);\n\t\tseg[k].first = seg[BigI].first;\n\t\tseg[k].second = seg[BigI].second;\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tint before = 0;\n\tinit();\n\trep(i, r)std::cin >> d[i] >> t[i] >> x[i];\n\n\trep(i, r){\n\t\tif (i == r - 1 || t[i] != t[i + 1]){\n\t\t\tpoint[seg[0].second] += (t[i] - before);\n\t\t\tbefore = t[i];\n\t\t}\n\t\tupdate(d[i] - 1, x[i]);\n\t}\n\n\tpoint[seg[0].second] += (l - before);\n\tint maxI = 0;\n\tREP(i, 1, n){\n\t\tif (point[i] > point[maxI])maxI = i;\n\t}\n\tstd::cout << maxI + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 1<<24\npriority_queue<pair<int,int>> Q;\nint d[MN],n,s,L,x[MN],y[MN],t[MN],ti[MN],mn,mid,i;\nint main(){\n\tcin>>n>>s>>L;\n\tQ.push(make_pair(0,-1));\n\tx[0]=1;t[0]=0;y[0]=0;t[s+1]=L;\n\tfor(i=1;i<=s;i++){cin>>x[i]>>t[i]>>y[i];}\n\tfor(i=0;i<=s;i++){\n\t\td[x[i]]+=y[i];\n\t\tQ.push(make_pair(d[x[i]],-x[i]));\n\t\twhile(1){\n\t\t\tpair<int,int>p=Q.top();\n\t\t\tif(p.first==d[-p.second]){\n\t\t\t\tti[-p.second]+=t[i+1]-t[i];break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(mn<ti[i]){\n\t\t\tmn=ti[i];\n\t\t\tmid=i;\n\t\t}\n\t}\n\tcout<<mid<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\nusing namespace std;\nint n,r,l;\nint d,t,x;\nint tt[1000001]={0},ten[1000001]={0};\ntypedef pair<int,int> P;\npriority_queue<P> qu;\nint main(void)\n{\n\tint i,j,flg,max,min,n1,nn,ten1;\n\tP ppp;\n\t\n\tscanf(\"%d %d %d\",&n,&r,&l);\n\t\n\tn1=1;\n\tten1=0;\n\t\n\tfor(i=0;i<r;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t\n\t\ttt[n1]+=t-ten1;\n\t\tten[d]+=x;\n\t\t\n\t\tqu.push(P(ten[d],d*-1));\n\t\tten1=t;\n\t\t\n\t\twhile(1){\n\t\t\tppp=qu.top();\n\t\t\tnn=ppp.second*-1;\n\t\t\tif(ten[nn]==ppp.first){\n\t\t\t\tn1=nn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqu.pop();\n\t\t}\t\n\t}\n\ttt[n1]+=l-ten1;\n\tmax=-1;\n\tfor(i=1;i<=n;i++){\n\t\tif(max<tt[i]){\n\t\t\tmax=tt[i];\n\t\t\tmin=i;\n\t\t}\t\n\t}\t\n\tprintf(\"%d\\n\",min);\t\n}\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nconst int MAX_N=1<<17;\nint n;\nint dat[2*MAX_N-1];\nint num[2*MAX_N-1];\n\nvoid Init(int n_){\n\tn=1;\n\twhile(n<n_) n*=2;\n\tfor(int i=0; i<2*n-1; ++i){\n\t\tif(n-1<=i){\n\t\t\tdat[i]=0;\n\t\t\tnum[i]=i;\n\t\t} else {\n\t\t\tdat[i]=INT_MIN;\n\t\t\tnum[i]=-1;\n\t\t}\n\t}\n}\n\nvoid Update(int k,int a){\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\t//dat[k]=max(dat[k*2+1],dat[k*2+2]);\n\t\tk=(k-1)/2;\n\t\tif(dat[k*2+1]>=dat[k*2+2]){\n\t\t\tdat[k]=dat[k*2+1];\n\t\t\tnum[k]=num[k*2+1];\n\t\t} else {\n\t\t\tdat[k]=dat[k*2+2];\n\t\t\tnum[k]=num[k*2+2];\n\t\t}\n\t}\n}\n\nPi Query(int a,int b,int k,int l,int r){\n\tif(r<=a||b<=l) return Pi(-1,INT_MIN);\n\tif(a<=l&&r<=b) return Pi(num[k],dat[k]);\n\telse {\n\t\tPi vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\tPi vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\tif(vl.S_>=vr.S_) return vl;\n\t\telse return vr;\n\t}\n}\n\nint main(){\n\tint N,R,L;\n\tcin >> N >> R >> L;\n\tInit(N);\n\tvector<int> t(N);\n\tPi tmp;\n\tREP(i,0,R){\n\t\tint D,T,X;\n\t\tcin >> D >> T >> X;\n\t\t--D;\n\t\tUpdate(D,dat[D+n-1]+X);\n\t\tPi p=Query(0,n,0,0,n);\n\t\tif(i!=0) t[tmp.F_]+=T-tmp.S_;\n\t\t//if(i!=0) cout << tmp.F_ << ' ' << T-tmp.S_ << endl;\n\t\ttmp.F_=p.F_-n+1;\n\t\ttmp.S_=T;\n\t\tif(i==R-1) t[tmp.F_]+=L-T;\n\t}\n\tint ans=-1,l=0;\n\tREP(i,0,N){\n\t\tif(l<t[i]){\n\t\t\tans=i+1;\n\t\t\tl=t[i];\n\t\t}\n\t}\n\t/*\n\tREP(i,0,2*n-1){\n\t\tcout << i << ' ' << num[i] << ' ' << dat[i] << endl;\n\t}\n\tcout << endl;\n\t*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{ START\nusing namespace std;\n#define int int64_t\n#define rep(i, a, n) for (int i = (a); i < (n); ++i)\n#define reps(i, a, n) for (int i = (a); i > (n); --i)\n#define arep(i, x) for (auto &&i : (x))\n#define irep(i, x) for (auto i = (x).begin(); i != (x).end(); ++i)\n#define rirep(i, x) for (auto i = (x).rbegin(); i != (x).rend(); ++i)\n//降順はgreater<T>()\n#define all(x) (x).begin(), (x).end()\n#define rv(s) reverse((s).begin(), (s).end())\n// gcd lcmはそのままok\n#define gcd(a, b) __gcd(a, b)\n#define bits(n) (1LL << (n))\n#define pcnt(x) __builtin_popcountll(x)\n//配列内等要素削除\n#define Unique(x) (x).erase(unique((x).begin(), (x).end()), (x).end())\n#define Fixed(n) fi > xed << setprecision(n)\n//総和\n#define sowa(n) (((n) * ((n) + 1)) / 2)\n#define cauto const auto &\nusing P = pair<int, int>;\nusing Graph = vector<vector<P>>;\ntemplate <class T>  //昇順\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T>  //降順\nusing max_heap = priority_queue<T>;\ntemplate <class A, class B>\nusing umap = unordered_map<A, B>;\ntemplate <class A>\nusing uset = unordered_set<A>;\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {  //多次元初期化\n  std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <class A, class B>\nbool chmax(A &a, const B &b) {  //最大値更新 返り値はbool\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class A, class B>\nbool chmin(A &a, const B &b) {  //最小値更新 返り値はbool\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\nint dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\nint dy[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr int LINF = 0x3f3f3f3f3f3f3f3fLL;\nconstexpr int mod1 = 1e9 + 7;\nconstexpr int mod2 = 998244353;\n//} END\n\ntemplate <typename Monoid>\nstruct SegmentTree {\n  using F = function<Monoid(Monoid, Monoid)>;\n\n  int sz;\n  vector<Monoid> seg;\n\n  const F f;\n  const Monoid M1;\n\n  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n    sz = 1;\n    while (sz < n) sz <<= 1;\n    seg.assign(2 * sz, M1);\n  }\n\n  void set(int k, const Monoid &x) { seg[k + sz] = x; }\n\n  void build() {\n    for (int k = sz - 1; k > 0; k--) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n\n  void update(int k, const Monoid &x) {\n    k += sz;\n    seg[k] = x;\n    while (k >>= 1) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n\n  Monoid query(int a, int b) {\n    Monoid L = M1, R = M1;\n    for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) L = f(L, seg[a++]);\n      if (b & 1) R = f(seg[--b], R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) const { return seg[k + sz]; }\n\n  template <typename C>\n  int find_subtree(int a, const C &check, Monoid &M, bool type) {\n    while (a < sz) {\n      Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n      if (check(nxt))\n        a = 2 * a + type;\n      else\n        M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n\n  template <typename C>\n  int find_first(int a, const C &check) {\n    Monoid L = M1;\n    if (a <= 0) {\n      if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    int b = sz;\n    for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) {\n        Monoid nxt = f(L, seg[a]);\n        if (check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n  template <typename C>\n  int find_last(int b, const C &check) {\n    Monoid R = M1;\n    if (b >= sz) {\n      if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    int a = sz;\n    for (b += sz; a < b; a >>= 1, b >>= 1) {\n      if (b & 1) {\n        Monoid nxt = f(seg[--b], R);\n        if (check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nsigned main(void) {\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  int n, r, l;\n  cin >> n >> r >> l;\n\n  SegmentTree<P> seg(n,\n                     [](P a, P b) {\n                       if (a.first > b.first)\n                         return a;\n                       else if (a.first < b.first)\n                         return b;\n                       else {\n                         if (a.second > b.second)\n                           return b;\n                         else\n                           return a;\n                       }\n                     },\n                     {0, 0});\n\n  int now = 0, tim = 0;\n  vector<int> ans(n);\n  rep(i, 0, n) seg.set(i, {0, i});\n  seg.build();\n  rep(i, 0, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    --d;\n    seg.update(d, {seg[d].first + x, d});\n    ans[tim] += t - now;\n    now = t;\n    tim = seg.query(0, n).second;\n  }\n  ans[tim] += l - now;\n  int mx = *max_element(all(ans));\n  rep(i, 0, n) if (ans[i] == mx) return cout << i + 1 << '\\n', 0;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nclass SegT{\nprivate:\n  int dat[2 * (1 << 17) - 1]; // = 131072\n  int NN;\n\npublic:\n  SegT(int n_){\n\tNN = 1;\n\twhile(NN < n_) NN <<= 1;\n\tfor(int i=0;i<2*NN-1;++i) dat[i] = -INF;\n  }\n\n  void update(int idx, int a){\n\tidx += NN - 1;\n\tdat[idx] += a;\n\twhile(idx > 0){\n\t  idx = (idx - 1) / 2;\n\t  dat[idx] = max(dat[idx*2+1], dat[idx*2+2]);\n\t}\n  }\n\n  int query(int k, int l, int r){\n\tif(r-l == 1) return l;\n\tint m = (l+r)/2;\n\tif(dat[k*2+1] >= dat[k*2+2])\n\t  return query(k*2+1, l, m);\n\telse\n\t  return query(k*2+2, m, r);\n  }\n  int query(){\n\treturn query(0, 0, NN);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, R, L;\n  cin >> N >> R >> L;\n  SegT seg(N);\n  REP(i,N) seg.update(i, INF);\n  VI tm(N);\n  int prv = 0;\n  REP(i,R){\n\tint d, t, x;\n\tcin >> d >> t >> x;\n\ttm[seg.query()] += t - prv;\n\n\tseg.update(d-1, x);\n\tprv = t;\n  }\n  tm[seg.query()] += L - prv;\n\n  int ans = 0;\n  REP(i,N) if(tm[ans] < tm[i]) ans = i;\n\n  cout << ans+1 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100000)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int n,score[2*MAX_N -1],time[2*MAX_N -1];\n  int r,l;\n  \n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    updata(time, k, time[k+n-1]+t, n);\n\n    updata(score, d, score[d+n-1]+x, n);\n  \n    /*\n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n;i<n*2;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    */\n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-1]+t, n);\n\n  /*printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-1;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n) return k-n+1; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for (int i=(int)(b); i<(int)(e); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T>\nclass SegTree {\n  int n;\n  vector<T> seg;\n  \n  // irrelevant value for query\n  const T NIL = make_pair(1<<30, 0);  \n  \n  // binary operator for query\n  T binop(T a, T b) {\n    return min(a, b);\n  }\n  \n  void update(int k, int l, int r, int p, T x) {\n    if (p < l || r <= p)\n      return;\n    if (r - l == 1)\n      seg[k] = x;\n    else {\n      update(2*k+1, l, (l+r)/2, p, x);\n      update(2*k+2, (l+r)/2, r, p, x);\n      seg[k] = binop(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n  T query(int k, int l, int r, int a, int b) {\n    if (b <= l || r <= a)\n      return NIL;\n    if (a <= l && r <= b)\n      return seg[k];\n    else {\n      T ret = NIL;\n      ret = binop(ret, query(2*k+1, l, (l+r)/2, a, b));\n      ret = binop(ret, query(2*k+2, (l+r)/2, r, a, b));\n      return ret;\n    }\n  }\npublic:\n  SegTree(int n): n(n), seg(4*n) {}\n  void init() {\n    for (int i = 0; i < 4*n; i++)\n      seg[i] = NIL;\n  }\n  // update p-th value to x\n  void update(int p, T x) {\n    update(0, 0, n, p, x);\n  }\n  // query for range [l, r)\n  T query(int l, int r) {\n    return query(0, 0, n, l, r);\n  }\n};\n\n\nint n, r, l;\nint sum[100000];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> r >> l;\n\n  SegTree<pair<int, int> > tree(100000);\n  int pre = 0;\n  REP (i, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    sum[tree.query(0, n).second] += t-pre;\n    int pt = -tree.query(d-1, d).first;\n    tree.update(d-1, make_pair(-(pt+x), d-1));\n    pre = t;\n  }\n  sum[tree.query(0, n).second] += l-pre;\n\n  int ans = 0;\n  REP (i, n) if (sum[i] > sum[ans]) ans = i;\n  cout << ans+1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n;\nvector<pii> seg;\n\nvoid init(int n_){\n  n=1;\n  while(n<n_) n*=2;\n  seg.resize(n*2-1,pii(-1,-1));\n}\n\nvoid update(int k, int a){\n  int id=k+n-1;\n  seg[id].first+=a;\n  seg[id].second=-k;\n  while(id>0){\n    id=(id-1)/2;\n    seg[id]=max(seg[id*2+1], seg[id*2+2]);\n  }\n}\n\nint main(){\n  int N,R,L;\n  int d,t,x;\n  cin>> N>> R>> L;\n  init(N);\n  for(int i=0;i<N;i++){\n    update(i,0);\n  }\n\n  vector<int> time(N,0);\n  int now=0,most=0;\n  while(R--){\n    cin>> d>> t>> x;\n    d--;\n    time[most]+=t-now;\n    update(d,x);\n    now=t;\n    most=-seg[0].second;\n  }\n  time[most]+=L-now;\n\n  int maxt=0, maxg;\n  for(int i=0;i<N;i++){\n    if(time[i]>maxt){\n      maxt=time[i];\n      maxg=i;\n      \n    }\n  }\n\n  cout<< maxg+1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass SegmentTree{\npublic:\n\tint n = 1;\n\tvector<P> seg[2];\t\t//0:最大\t1:最小\n\tvoid init(int N){\t\t//N要素のセグメントツリー作成\n\t\twhile(n < N)n *= 2;\n\t\trep(i,2)seg[i].resize(2*n);\n\t\tfill(all(seg[0]), P(-INF, 0));\n\t\tfill(all(seg[1]), P(INF, 0));\n\t}\n\tP cmp_min(P x, P y){\t\t//比較関数\n\t\tif(x.fi == y.fi)return x.se < y.se ? x : y;\n\t\treturn min(x, y);\n\t}\n\tP cmp_max(P x, P y){\t\t//比較関数\n\t\tif(x.fi == y.fi)return x.se < y.se ? x : y;\n\t\treturn max(x, y);\n\t}\n\tvoid update(int k, int x, bool flag=false){\t\t//kの値をxに変更\n\t\tk += n-1;\n\t\tseg[0][k] = seg[1][k] = P(x, k-(n-1));\n\t\tif(flag){seg[0][k] = P(-INF, -1);seg[1][k] = P(INF, -1);}\n\t\twhile(k > 0){\n\t\t\tk = (k-1)/2;\n\t\t\tseg[0][k] = cmp_max(seg[0][k*2+1], seg[0][k*2+2]);\n\t\t\tseg[1][k] = cmp_min(seg[1][k*2+1], seg[1][k*2+2]);\n\t\t}\n\t}\n\tP calc(int a, int b, int k, int l, int r, int f){\n\t\tif(b <= l || r <= a)return f ? P(INF, 0) : P(-INF, 0);\n\t\tif(a <= l && r <= b)return seg[f][k];\n\t\tP vl = calc(a, b, k*2+1, l, (l+r)/2, f);\n\t\tP vr = calc(a, b, k*2+2, (l+r)/2, r, f);\n\t\treturn f ? cmp_min(vl, vr) : cmp_max(vl, vr);\n\t}\n\tvoid erase(int k){update(k, -1, true);}\n\tP get_max(int a, int b){return calc(a, b, 0, 0, n, 0);}\n\tP get_min(int a, int b){return calc(a, b, 0, 0, n, 1);}\n};\n\nSegmentTree seg;\nint a[100000], ans[100000];\nsigned main(){\n\tint n, m, l, p = 0, tt = 0;\n\tscanf(\"%lld%lld%lld\", &n, &m, &l);\n\tseg.init(n);\n\trep(i,m){\n\t\tint d, t, x;\n\t\tscanf(\"%lld%lld%lld\", &d, &t, &x);d--;\n\t\tseg.update(d, a[d]+x);a[d] += x;\n\t\tP mx = seg.get_max(0, n);\n\t\tans[p] += t-tt;p = mx.se;tt= t;\n\t}\n\tans[p] += l-tt;\n\t\n\tP res = P(-INF, -1);\n\tdrep(i,n-1,0){\n\t\tif(res.fi <= ans[i])res = P(ans[i], i);\n\t}\n\tprintf(\"%lld\\n\", res.se+1);\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LIM 1+2+4+8+16+32+64+128\n#define int long long \n#define F first\n#define S second\nusing namespace std;\ntypedef struct{\n  int per;\n  int ko;\n  int kyoda;\n  int konoko;\n}TRE;\nint ace(int a,int b){\n  int ss=0;\n  for(int i=b;i<=a;i++){\n    ss+=i;\n  }\n  return(ss);\n}\ntypedef pair<int,int>P;\nvoid sai(P n[],int x){\n  if(x==1){\n    return;\n  }else{\n    if(x%2==0){\n      if(n[x].S<n[x+1].S){\n\tn[x/2].S=n[x+1].S;\n\tn[x/2].F=n[x+1].F;\n\tsai(n,x/2);\n      }else{\n\tn[x/2].S=n[x].S;\n\tn[x/2].F=n[x].F;\n\tsai(n,x/2);\n      }\n    }else{\n      if(n[x].S<=n[x-1].S){\n\tn[x/2].S=n[x-1].S;\n\tn[x/2].F=n[x-1].F;\n\tsai(n,x/2);\n      }else{      \n\tn[x/2].S=n[x].S;\n\tn[x/2].F=n[x].F;\n\tsai(n,x/2);\n      }\n    }\n  }\n  return;\n}\nsigned  main(){\n  int rui[17]={2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072};\n  int n,r,l;\n  cin>>n>>r>>l;\n  int gg=0;\n  while(1){\n    if(n<=rui[gg]){\n      break;\n    }\n    gg++;\n  }\n  int ss=rui[gg];\n  P seg[ss*2-1];\n  for(int i=0;i<ss;i++){\n    seg[ss+i].F=i+1;\n    seg[ss+i].S=0;\n  }\n  for(int i=ss-1;i>0;i--){\n    seg[i].F=seg[i*2].F;\n    seg[i].S=0;\n  }\n  int ans[n+1];\n  for(int i=0;i<=n;i++){\n    ans[i]=0;\n  }\n  int now=0;\n  for(int i=0;i<r;i++){\n    int d,t,x;\n    cin>>d>>t>>x;\n    ans[seg[1].F]+=t-now;\n    seg[ss+d-1].S+=x;\n    sai(seg,ss+d-1);\n    now=t;\n  }\n  ans[seg[1].F]+=l-now-1;\n  int mx=1;\n  for(int i=2;i<=n;i++){\n    if(ans[mx]<ans[i]){\n      mx=i;\n    }\n  }\n  cout<<mx<<endl;\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nconst int N=100010;\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+m)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst ll INF = 1001001001001001001;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int MAX_N = 100000, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = -INF;\n            seg2[i] = -1;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            //std::cout << index << \",\" << seg1[index*2+1] << \",\" << seg1[index*2+2] << std::endl;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n                //std::cout << seg2[index] << std::endl;\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n        rs[i].d--;\n    }\n\n    int ts[MAX_N];\n    std::fill(ts, ts+N, 0);\n\n    if(R > 0){\n        REP(i, N){\n            st.update(i, 0);\n        }\n\n        int prev = rs[0].t;\n        st.update(rs[0].d, rs[0].x);\n        FOR(i, 1, R){\n            if(i+1 >= R || rs[i].t < rs[i+1].t){\n                //printf(\"wa-i: %d +%d\\n\", st.root().second, rs[i].t - prev);\n                ts[st.root().second] += rs[i].t - prev;\n            }\n            st.update(rs[i].d, rs[i].x);\n            prev = rs[i].t;\n        }\n        ts[st.root().second] += L - prev;\n    }\n\n    int max_team = 0, max_t = -1;\n    REP(i, N){\n        if(ts[i] > max_t){\n            max_team = i+1;\n            max_t = ts[i];\n        }\n    }   \n\n    //std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nclass SegT{\nprivate:\n  int dat[2 * (1 << 17) - 1]; // = 131072\n  int NN;\n\npublic:\n  SegT(int n_){\n\tNN = 1;\n\twhile(NN < n_) NN <<= 1;\n\tfor(int i=0;i<2*NN-1;++i) dat[i] = -INF;\n  }\n\n  void update(int idx, int a){\n\tidx += NN - 1;\n\tdat[idx] += a;\n\twhile(idx > 0){\n\t  idx = (idx - 1) / 2;\n\t  dat[idx] = max(dat[idx*2+1], dat[idx*2+2]);\n\t}\n  }\n\n  int query(int k, int l, int r){\n\tif(r-l == 1) return l;\n\tint m = (l+r)/2;\n\tif(dat[k*2+1] >= dat[k*2+2])\n\t  return query(k*2+1, l, m);\n\telse\n\t  return query(k*2+2, m, r);\n  }\n  int query(){\n\treturn query(0, 0, NN);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, R, L;\n  cin >> N >> R >> L;\n  SegT seg(N);\n  REP(i,N) seg.update(i, INF);\n  VI tm(N);\n  int prv = 0;\n  REP(i,R){\n\tint d, t, x;\n\tcin >> d >> t >> x;\n\ttm[seg.query()] += t - prv;\n\n\tseg.update(d-1, x);\n\tprv = t;\n  }\n  tm[seg.query()] += L - prv;\n\n  int ans = 0;\n  REP(i,N) if(tm[ans] < tm[i]) ans = i;\n\n  cout << ans+1 << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[100010];\nstruct node {\n    int id;\n    long long point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst long long INF = 1001001001;\nconst long long MOD = 1000000007;\nconst double EPS = 1e-10;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,r,l;\n    cin>>n>>r>>l;\n    using T = tuple<int,int,int>;\n    T dtx[r];\n    int sec[n]={},val[n]={};\n    priority_queue<P> pq;\n    int pret=0,preidx=0;\n    for(int i=0;i<r;i++){\n        int d,t,x;\n        cin>>d>>t>>x;\n        d--;\n        val[d]+=x;\n        pq.push(P(val[d],-d));\n        while(1){\n            P p=pq.top();\n            if(p.first==val[-p.second]){\n                sec[preidx]+=t-pret;\n                preidx=-p.second;\n                pret=t;\n                break;\n            }\n            pq.pop();\n        }\n    }\n    sec[preidx]+=l-pret;\n    int ans=0,maxt=-1;\n    for(int i=0;i<n;i++){\n        if(maxt<sec[i]){\n            maxt=sec[i];\n            ans=i+1;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d+1-e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;cin>>x>>y>>z;\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\t\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[100010];\nstruct node {\n    int id, point;\n} node[1<<21];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define MP make_pair\npair<int,int> seg[1<<18];\nvoid update(int k,int x){\n  int id=k;\n  k+=(1<<17)-1;\n  seg[k].first+=x;\n  seg[k].second=id;\n  while(k>0){\n    k=(k-1)/2;\n    if(seg[k*2+1].first>=seg[k*2+2].first)seg[k]=seg[k*2+1];\n    else seg[k]=seg[k*2+2];\n  }\n}\n\nint main(){\n  int n,r,l;\n  int team[100000];\n  memset(team,0,sizeof(team));\n  cin>>n>>r>>l;\n  for(int i=0;i<n;i++)update(i,0);\n  int now=0,top=0;\n  for(int i=0;i<r;i++){\n    int a,b,c;\n    cin>>a>>b>>c;a--;\n    team[top]+=b-now;\n    update(a,c);\n    top=seg[0].second;\n    now=b;\n  }\n  team[top]+=l-now;\n  int ans=0;\n  for(int i=1;i<n;i++)if(team[ans]<team[i])ans=i;\n  cout<<ans+1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = tp[1];\n\t\tFlag = 1;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tprintf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n\tint n, r, l; cin >> n >> r >> l;\n\tvector<int> d(r), t(r + 1), x(r);\n\tfor (int i = 0; i < r; ++i) {\n\t\tcin >> d[i] >> t[i] >> x[i];\n\t\td[i]--;\n\t}\n\tt[r] = l;\n\tvector<int> po(n), ti(n);\n\tpriority_queue<pair<int, int> > pq;\n\tfor (int i = 1; i <= r; ++i) {\n\t\tpo[d[i - 1]] += x[i - 1];\n\t\tpq.push(make_pair(po[d[i - 1]], -d[i - 1]));\n\t\twhile (!pq.empty() && pq.top().first != po[-pq.top().second]) pq.pop();\n\t\tti[-pq.top().second] += t[i] - t[i - 1];\n\t}\n\tcout << max_element(ti.begin(), ti.end()) - ti.begin() + 1 << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n\n  score[0].first = 1000000000;  \n\n \n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  d = 1;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;   \n    for(int j=d;j>=1;j--) {\n      if(score[site1] < score[site1/2] ) {\n\t//cout <<\"ok\"<<endl;\n      tmp = score[site1];\n      score[site1] = score[site1/2];\n      score[site1/2] = tmp;\n      site1 = site1/2;\n      } else break;\n    }\n        \n    for(int j=site1;j<=N;j++) {\n      if(2*site1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t//\tcout <<\"ko\"<<endl;\n\tint flg = 0;\n\tif(score[2*site1+1] < score[site1] && score[2*site1] < score[2*site1+1]) flg = 1;\n\ttmp = score[site1];\n\tscore[site1] = score[site1*2+flg];\n\tscore[site1*2+flg] = tmp;\n      }else break;\n    }\n  }\n\n\n  time[score[1].second] += L-t;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint extract(Team* team){\n  int maxv;\n  maxv=team[0].id;\n  //  team[1]=team[H--];\n  //  maxHeapify(1);\n  return maxv;\n}\nvoid IncreaseKey(int i,int key){\n  team[i].point+=key;\n  while(i>1&&team[i/2].point<team[i].point){\n    swap(team[i],team[i/2]);\n    i=i/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=0;\n  for(int i=0;i<n;i++){\n    if(team[i].showed>team[top].showed) top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top+1);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=0;i<n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i]-1,x[i]);\n    Team top=team[extract(team)];\n    if(i==0){\n      top.showed+=t[0];\n    }\n    else if(i<r-1){\n    top.showed+=t[i+1]-t[i];\n    }\n    else{\n      top.showed+=l-t[r-1];\n    }\n  }\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\nconst int MAX_N = 1<<17;\nint n;\npii dat[2 * MAX_N - 1];\n\nvoid init(int n_)\n{\n\tn = 1;\n\twhile (n < n_)n *= 2;\n\tfor (int i = 0; i < 2 * n - 1; i++)dat[i] = pii(INT_MAX,0);\n}\n\nvoid update(int k, pii a)\n{\n\tk += n - 1;\n\tdat[k] = a;\n\twhile (k > 0)\n\t{\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\npii query(int a, int b, int k, int l, int r)\n{\n\tif (r <= a || b <= l)return pii(INT_MAX,0);\n\tif (a <= l&&r <= b)return dat[k];\n\telse\n\t{\n\t\tpii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\n\npii calc(int a, int b)//[a,b)\n{\n\treturn query(a, b, 0, 0, n);\n}\n\nsigned main()\n{\n\tint r, l;\n\tcin >> n >> r >> l;\n\tint ans[100001] = {};\n\tinit(n);\n\tfor (int i = 0; i < n; i++)update(i, pii(0,i));\n\tint b = 0;\n\twhile (r--)\n\t{\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x; d--;\n\t\tans[calc(0, n).second] += t-b;\n\t\tb = t;\n\t\tpii p = dat[d+ n - 1];\n\t\tp.first -= x;\n\t\tupdate(d , p);\n\t}ans[calc(0, n).second] += l - b;\n\tint p = -1, id = 0;\n\tfor (int i = n-1; i >= 0; i--)\n\t{\n\t\tif (ans[i] >= p)\n\t\t{\n\t\t\tp = ans[i];\n\t\t\tid = i + 1;\n\t\t}\n\t}\n\n\n\tcout << id << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n\n  score[0].first = 1000000000;  \n\n  for(int i=1;i<=N;i++) cout << score[i].second;\n  cout << endl;\n\n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  d = 1;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first += x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;   \n    for(int j=d;j>=1;j--) {\n      if(score[site1].first > score[site1/2].first ) {\n\t//cout <<\"ok\"<<endl;\n      tmp = score[site1];\n      score[site1] = score[site1/2];\n      score[site1/2] = tmp;\n      site1 = site1/2;\n      }else if(score[site1].first == score[site1/2].first && score[site1].second < score[site1/2].second) {\n\ttmp = score[site1];\n\tscore[site1] = score[site1/2];\n\tscore[site1/2] = tmp;\n      site1 = site1/2;\n      } else break;\n    }\n        \n    for(int j=site1;j<=N;j++) {\n      if(2*site1<= N &&( score[2*site1] > score[site1] || score[2*site1+1] < score[site1])) {\n\t//\tcout <<\"ko\"<<endl;\n\tif(site1 > N ) break;\n\tint flg = 0;\n\tif(score[2*site1+1] > score[site1] && score[2*site1] > score[2*site1+1]) flg = 1;\n\ttmp = score[site1];\n\tscore[site1] = score[site1*2+flg];\n\tscore[site1*2+flg] = tmp;\n      }else break;\n    }\n\n  }\n\n\n\n  time[score[1].second] += L-t;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -11111111\n#define MAX 11111111\ntypedef pair<int,int> P;\nint n;\nP dat[8*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[4*100012];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  dat[0] = P(MIN,1);\n  int d,t,x,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[dat[0].second].first+=t-bt;\n    update(d,x);\n    bt=t;\n  }\n  tim[dat[0].second].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-2;\n  dat[k]=P(dat[k].first+a,dat[k].second);\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n+1];\n    for(int i=0;i<2*n+1;i++){\n      points[i] = Team(i,0);\n    }\n\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,0);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams);\n\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      seg_tree.insert(id,point);\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += time - prev_time;\n\tprev_time = time;\n\tprev_champ = team.id;\n      }\n    }\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n  int INF = 1e9;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[200005];\n  int time[100005];\n  for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n  \n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1=-1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    assert(site1>=1);\n\n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    \n    if(x>0){ \n      while(site1>1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  swap(score[site1], score[site1/2]);\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  swap(score[site1],score[2*site1+flg]);\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-mae;\n  /*\n  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n   cout << endl;\n  */\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N,R,L,T[100001],S[100001],maxt=1,pret=0,P[100001];\npair<int,int>H[100001];\nvoid swap(int x,int y){\n    P[-H[y].second]=x;\n    P[-H[x].second]=y;\n    pair<int,int>i;\n    i=H[x];\n    H[x]=H[y];\n    H[y]=i;\n}\nvoid upheap(int i){\n    while(i>0&&H[i]>H[i/2]){\n        swap(i,i/2);\n        i/=2;\n    }\n}\nvoid downheap(int i){\n    int l=i*2+1,r=l+1;\n    if(r<N&&H[r]>H[l])l=r;\n    \n    if(l<N&&H[l]>H[i]){\n        swap(i,l);\n        downheap(l);\n    }\n}\nint main(void){\n  cin>>N>>R>>L;\n  for(int i=0;i<N;i++){\n      P[i+1]=i;\n      H[i].second=-i-1;\n  }\n  for(int i=0;i<R;i++){\n      int d,t,x;\n      cin>>d>>t>>x;\n      int maxp=-H[0].second;\n      T[maxp]+=t-pret;\n      pret=t;\n      if(T[maxp]==T[maxt])maxt=min(maxp,maxt);\n      \n      if(T[maxp]>T[maxt])maxt=maxp;\n      \n      H[P[d]].first+=x;\n      if(x>0)upheap(P[d]);\n      else downheap(P[d]);\n      \n      \n      \n  }\n  int maxp=-H[0].second;\n      T[maxp]+=L-pret;\n      if(T[maxp]==T[maxt])cout<<min(maxp,maxt)<<endl;\n      else if(T[maxp]>T[maxt])cout<<maxp<<endl;\n      else cout<<maxt<<endl;\n  \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 1<<24\nusing namespace std;priority_queue<pair<int,int>> Q;int d[MN],n,s,L,x[MN],y[MN],t[MN],ti[MN],mn,mid,i;int main(){cin>>n>>s>>L;Q.push(make_pair(0,-1));x[0]=1;t[0]=0;y[0]=0;t[s+1]=L;for(i=1;i<=s;i++){cin>>x[i]>>t[i]>>y[i];}for(i=0;i<=s;i++){d[x[i]]+=y[i];Q.push(make_pair(d[x[i]],-x[i]));while(1){pair<int,int>p=Q.top();if(p.first==d[-p.second]){ti[-p.second]+=t[i+1]-t[i];break;}Q.pop();}}for(i=1;i<=n;i++){if(mn<ti[i]){mn=ti[i];mid=i;}}cout<<mid<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=(j);i<(n);i++)\n#define erep(i,j,n) for(int i=(j);i<=(n);i++)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(),i.rend()\n#define INF 1e9\nconst int mod = 1e9+7;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pi;\ntypedef long long i64;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  priority_queue<pi> que;\n  int n, r, l;\n  cin >> n >> r >> l;\n  que.push(make_pair(0, -1));\n\n  vi score(n + 1, 0), time(n + 1, 0);\n  int pret = 0, pred = 1;\n\n  rep(i, 0, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    score[d] += x;\n    que.push(make_pair(score[d], -d));\n\n    while(1) {\n      pi p = que.top();\n      if(p.first == score[-p.second]) {\n        time[pred] += t - pret;\n        pred = -p.second;\n        pret = t;\n        break;\n      }\n      que.pop();\n    }\n  }\n  time[pred] += l - pret;\n\n  int ans = 1;\n  erep(i, 2, n) {\n    if(time[ans] < time[i]) ans = i;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define pque priority_queue\n#define pu push\n#define fr first\n#define sc second\n#define sa static\n\nstruct com{\n\tbool operator()(P x,P y){\n\t\tif(x.fr==y.fr)return x.sc>y.sc;\n\t\treturn x.fr<y.fr;\n\t}\n};\n\nint main(){\n\tsa int n,r,l;\n\tsa int d[100010],t[100010],x[100010];\n\t\n\tcin>>n>>r>>l;\n\trep(i,r)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\td[r]=0; t[r]=l; x[r]=0;\n\t\n\tsa int ret[100010]={0};\n\tsa int p[100010]={0};\n\tsa int T=0;\n\tsa pque<P,vector<P>,com> Q; rep(i,n)Q.pu(P(0,i+1));\n\t\n\trep(i,r+1){\n\t\tif(t[i]>T){\n\t\t\twhile(p[Q.top().sc]!=Q.top().fr)Q.pop();\n\t\t\tret[Q.top().sc]+=t[i]-T; //cout<<Q.top().sc<<\" \"<<t[i]-T<<endl;\n\t\t\tT=t[i];\n\t\t}\n\t\tp[d[i]]+=x[i]; Q.pu(P(p[d[i]],d[i]));\n\t}\n\t\n\tint Ret=0,Max=0;\n\trep(i,n){\n\t\t//cout<<i+1<<\" \"<<ret[i+1]<<endl;\n\t\tif(ret[i+1]>Max){ Ret=i+1; Max=ret[i+1]; }\n\t}\n\t\n\tcout<<Ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\tvi sum(n);\n\tvi sc(n);\n\tint ma=0,mai=0;\n\tint t=0;\n\tint a,b,c;\n\twhile(m--){\n\t\tcin>>a>>b>>c;\n\t\tsum[mai]+=b-t;\n\t\tt=b;\n\t\tsc[a-1]+=c;\n\t\tif(c<0&&a-1==mai){\n\t\t\tma=-inf;mai=inf;\n\t\t\trep(i,n)if(ma<sc[i]){\n\t\t\t\tif(ma==sc[i])mai=min(mai,i);\n\t\t\t\telse mai=i;\n\t\t\t\tma=sc[i];\n\t\t\t}\n\t\t}else if(c>=0){\n\t\t\tif(sc[a-1]>ma){\n\t\t\t\tma=sc[a-1];mai=a-1;\n\t\t\t}else if(sc[a-1]==ma)mai=min(mai,a-1);\n\t\t}\n\t}\n\tsum[mai]+=l-b;\n\tma=0;\n\trep(i,n)if(ma<sum[i]){\n\t\tif(ma==sum[i])mai=min(mai,i);\n\t\telse mai=i;\n\t\tma=sum[i];\n\t}\n\tcout<<mai+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint P[100000],T[100000];\nint main() {\n    int N,R,L,PT=0,n1=0,p1=0;\n    scanf(\"%d %d %d\",&N,&R,&L);\n    for(int i=0;i<R;i++) {\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x); d--;\n        P[d]+=x;\n        if(x>0) {\n            if(P[d]>p1) {\n                T[n1]+=t-PT;\n                PT=t;\n                n1=d;\n                p1=P[d];\n            }\n        }\n        if(x<0) {\n            if(d!=n1) continue;\n            int n2=n1,p2=P[d];\n            for(int j=N-1;j>=0;j--) {\n                if(p2<P[j]) {n2=j,p2=P[j];}\n            }\n            if(p2!=p1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=n2;\n                p1=p2;\n            }\n        }\n    }\n    T[n1]+=L-PT+1;\n    int ans_n=0,ans_t=0;\n    for(int i=0;i<N;i++) {\n        if(ans_t<T[i]) {\n            ans_t=T[i];\n            ans_n=i;\n        }\n    }\n    printf(\"%d\\n\",ans_n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[100010];\nstruct node {\n    int id;\n    long long point;\n} node[1<<21];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][100],T=0,g,p[2][100000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst ll INF = 1001001001001001001;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int MAX_N = 100000, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = -INF;\n            seg2[i] = -1;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] += v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            //std::cout << index << \",\" << seg1[index*2+1] << \",\" << seg1[index*2+2] << std::endl;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n                //std::cout << seg2[index] << std::endl;\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n        rs[i].d--;\n    }\n\n    int ts[MAX_N];\n    std::fill(ts, ts+N, 0);\n\n    if(R > 0){\n        REP(i, N){\n            st.update(i, 0);\n        }\n\n        int prev = rs[0].t;\n        st.update(rs[0].d, rs[0].x);\n        FOR(i, 1, R){\n            //if(i+1 >= R || rs[i].t < rs[i+1].t){\n                //printf(\"wa-i: %d +%d\\n\", st.root().second, rs[i].t - prev);\n                ts[st.root().second] += rs[i].t - prev;\n                //}\n            st.update(rs[i].d, rs[i].x);\n            prev = rs[i].t;\n        }\n        ts[st.root().second] += L - prev;\n    }\n\n    int max_team = 0, max_t = -1;\n    REP(i, N){\n        if(ts[i] > max_t){\n            max_team = i+1;\n            max_t = ts[i];\n        }\n    }   \n\n    //std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define PR pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0;\n#define int ll\n\n// Programming contest\n\nconst int MAX=1e5+10;\n\nsigned main(){\n  int N,R,L;\n  cin>>N>>R>>L;\n  \n  set<PR> teams;\n  int score[MAX];\n  int tele[MAX];\n  for(int i=0; i<N; i++){\n    teams.insert(mk(0,i+1));\n    score[i+1]=0;\n    tele[i+1]=0;\n  }\n  \n  int now_time=0;\n  for(int i=0; i<R; i++){\n    int team,time,s;\n    cin>>team>>time>>s;\n    PR M=*(teams.begin());\n    tele[M.second]+=time-now_time;\n    teams.erase(mk(-score[team],team));\n    teams.insert(mk(-score[team]-s,team));\n    score[team]+=s;\n    now_time=time;\n  }\n  PR M=*(teams.begin());\n  tele[M.second]+=L-now_time;\n\n  PR ans=mk(0,0);\n  for(int i=1; i<=N; i++){\n    if(ans.first<tele[i]){\n      ans.second=i;\n      ans.first=tele[i];\n    }\n  }\n  cout<<ans.second<<en\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 1<<24\nusing namespace std;priority_queue<pair<int,int>> Q;int d[MN],n,s,L,x[MN],y[MN],t[MN],ti[MN],mn,mid,i;int main(){cin>>n>>s>>L;Q.push(make_pair(0,-1));x[0]=1;t[0]=0;y[0]=0;t[s+1]=L;for(i=1;i<=s;i++){cin>>x[i]>>t[i]>>y[i];}for(i=0;i<=s;i++){d[x[i]]+=y[i];Q.push(make_pair(d[x[i]],-x[i]));while(1){pair<int,int>p=Q.top();if(p.first==d[-p.second]){ti[-p.second]+=t[i+1]-t[i];break;}Q.pop();}}for(i=1;i<=n;i++){if(mn<ti[i]){mn=ti[i];mid=i;}}cout<<mid<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int x,y,z,i,j,k=0;\n  cin >> x >> y >> z;\n  int n[x+1];//得点\n  int p[x+1];//時間\n  int o=1,ot=0,op;\n  for(i=0;i<x+1;i++)n[i]=p[i]=0;\n  int a,b,c;\n  for(i=0;i<y;i++){\n    cin >> a >> b >> c;\n    n[a]+=c;\n    for(j=1,k=1,op=n[1];j<x+1;j++){\n      if(op<n[j]){\n\top=n[j];\n\tk=j;\n      }\n    }\n    if(o!=k){\n      p[o]+=(b-ot);\n      o=k;\n      ot=b;\n    }\n  }\n  p[k]+=z-ot;\n  for(j=1,k=1,op=p[1];j<x+1;j++){\n    if(op<p[j]){\n      op=p[j];\n      k=j;\n    }\n  }\n  cout << k << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef struct{\n  int num;\n  int point;\n} Data;\n\n\nData segTree[2100000];\nint segSize;\n\nvoid reSize(int n){\n  segSize = 1;\n  while(segSize < n){\n    segSize *= 2;\n  }\n}\n\n\nvoid init(int n){\n  for(int i = 0;i < segSize;i++){\n    if(i < n){\n      segTree[i+segSize-1].point = 0;\n      segTree[i+segSize-1].num = i;\n    }\n    else segTree[i+segSize-1].point = INT_MIN;\n  }\n\n  for(int i = segSize-2;i >= 0;i--){\n    segTree[i] = segTree[i*2+1];\n  }\n\n}\n\n\nvoid update(int i,int val){\n  i = segSize-1+i;\n  segTree[i].point += val;\n  while(i > 0){\n    i = (i-1) / 2;\n    if(segTree[i*2+1].point >= segTree[i*2+2].point){\n      segTree[i] = segTree[i*2+1];\n    }else{\n      segTree[i] = segTree[i*2+2];\n    }\n  }\n\n  return;\n}\n\nint main(){\n  int n,r,l;\n  cin >> n >> r >> l;\n\n  reSize(n);\n  init(n);\n  int d,t,x;\n\n\n  int times[100000] = {};\n\n  int mae = 0;\n  for(int z = 0;z < r;z++){\n    cin >> d >> t >> x;\n\n    if(mae != 0) times[segTree[0].num] += t-mae;\n\n    update(d-1,x);\n\n    mae = t;\n  }\n\n  times[segTree[0].num] += l-mae;\n\n  Data max;\n  max.point = 0;\n  for(int i = 0;i < n;i++){\n    if(max.point < times[i]){\n      max.point = times[i];\n      max.num = i+1;\n    }\n  }\n  cout << max.num << endl;\n\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <queue>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <functional>\n#include <climits>\n \nusing namespace std;\n#define pr(...) do { _ost << #__VA_ARGS__ << \" = \"; ~(_ost,__VA_ARGS__); } while(0);\nostream & _ost = cout;\ntemplate <class T>\nostream &operator,(ostream& ost, const T& value) { return ost << value << \",\"; }\nostream &operator~(ostream& ost) { return ost << endl; }\ntemplate <class T>\nstring tos(const T& var){ ostringstream ss; ss << var; return ss.str(); }\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for(int i=(a); i<(b); i++)\n#define RALL(c) (c).rbegin(), (c).rend()\n \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned uint;\ntypedef unsigned long ul;\ntypedef unsigned long long ull;\n \nconst int mod = 1000000007;\nconst int INF = 1000000;\nconst double EPS = 1e-10;\n\nint main(){\n    int n,r,l;cin>>n>>r>>l;\n    vector<int> point(n+1);\n\n    typedef pair<int,int> range;\n    vector<range> seg;\n\n    int pt=0;\n    int pd=1;\n\n    FOR(i,0,r){\n        int d,t,x;cin>>d>>t>>x;\n        point[d]+=x;\n\n        auto m=max_element(ALL(point));\n        int md = m-point.begin();\n        md=max(1,md);\n\n        //cout<<md<<endl;\n        seg.push_back(make_pair(t-pt,pd));\n        pd=md;\n        pt=t;\n    }\n    auto m=max_element(ALL(point));\n    int mt=m-point.begin();\n    mt=max(1,mt);\n    seg.push_back(make_pair(l-pt,mt));\n\n    // FOR(i,0,seg.size()){\n    //     cout<<seg[i].first<<\" \"<<seg[i].second<<endl;\n    // }\n    //cout<<(int)(max_element(ALL(time))-time.begin())<<endl;\n\n    vector<int> t(n+1);\n    for(auto&e:seg){\n        t[e.second]+=e.first;\n    }\n    cout<<max_element(ALL(t))-t.begin()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\nconst int MAX_N = 1<<17;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nclass RMQ{\npublic:\n  ll n;\n  pii dat[2*MAX_N-1];\n\n  void init(ll n_){\n    n = 1;\n    while(n < n_){ n *= 2; }\n    for(ll i = 0 ; i < 2*n-1 ; i++){\n      dat[i] = pii(-INF,-INF);\n    }\n    for(ll i = 0 ; i < n_ ; i++){\n      update(i,0);\n    }\n  }\n\n  void update(ll k,ll a){\n    ll tk = k;\n    k += n - 1;\n    dat[k] = pii(a,-tk);\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  pii query(ll a,ll b,ll k,ll l,ll r){\n    if(r <= a || b <= l){ return pii(-INF,-INF); }\n    if(a <= l && r <= b){\n      return dat[k];\n    }else{\n      pii vl = query(a,b,k*2+1,l,(l+r)/2);\n      pii vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    }\n  }\n};\n\nint main(){\n  ll N,R,L;\n  RMQ rmq;\n  cin >> N >> R >> L;\n  rmq.init(N);\n  ll d,t,x,pt = 0;\n  vector<ll> poll(N,0);\n  for(ll i = 0 ; i < R ; i++){\n    cin >> d >> t >> x; d--;\n    poll[-rmq.query(0,N,0,0,rmq.n).second] = t-pt;\n    rmq.update(d,x+rmq.dat[d+rmq.n-1].first);\n    pt = t;\n  }\n    poll[-rmq.query(0,N,0,0,rmq.n).second] = L-pt;\n  ll res = -1, max = -INF;\n  for(ll i = 0 ; i < N ; i++){\n    if(max < poll[i]){\n      max = poll[i];\n      res = i+1;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\n//const int N=131072; // AC\n//const int N=131071; // WA\nconst int N=130650; // WA\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\tvi v(n + 100, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\tupdate(1, 0);\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\t//if(p.se >= 0) continue;\n\t\tif(p.se == 0) p.se = -1;\n\t\telse if(p.se >0) continue;\n\t\t//cout<<p.se<<endl;\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\t// int ans = 0;\n\t// for(int i = 1; i < v.size(); i++){\n\t// \tif(v[ans] < v[i]) ans = i;\n\t// \tcout<<v[i]<<endl; \n\t// }\n\t// cout<<ans<<endl;\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\n#define ISEQ(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint main() {\n  int n, r, l;\n  scanf(\"%d %d %d\", &n, &r, &l);\n  vector<int> scores(n);\n  vector<int> times(n);\n  priority_queue<P> que;\n  que.push(P(0, 0));\n  int btime = 0;\n  P top;\n  for (int i = 0; i < r; i++) {\n    int d, t, x;\n    scanf(\"%d %d %d\", &d, &t, &x);\n    d--;\n    while (true) {\n      top = que.top();\n      if (scores[-top.second] == top.first) break;\n      que.pop();\n    }\n    times[-top.second] += t - btime;\n    btime = t;\n    scores[d] += x;\n    que.push(P(scores[d], -d));\n  }\n\n  while (true) {\n    top = que.top();\n    if (scores[-top.second] == top.first) break;\n    que.pop();\n  }\n  times[-top.second] += l - btime;\n  int res = 0, max = -1;\n  for (int i = 0; i < n; i++) {\n    if (max < times[i]) {\n      max = times[i];\n      res = i;\n    }\n  }\n  cout << res + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n \n \nusing namespace std;\nint lis[100000];\nint tim[100000];\nint main() {\n    int n,r,l;\n    scanf(\"%d %d %d\",&n,&r,&l);\n \n    int top = 0;\n    int id  = 1;\n    int nowtime = 0;\n    int timemax = 0;\n    int timemaxid = 0;\n    for(int i = 0; i < r; i++) {\n        \n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x);\n        tim[id] += t - nowtime;\n        if(tim[id] > timemax) {\n            timemax = tim[id];\n            timemaxid = id;\n        }\n        nowtime = t;\n        lis[d] += x;\n        if(id == d) {\n            top += x;\n        }\n        if(x < 0 && d == id) {\n            for(int j = 1; j < n+1; j++) {\n                if(top < lis[j] || (top == lis[j] && j < id)) {\n                    top = lis[j];\n                    id = j;\n                }\n            }\n             \n        }\n        if(x > 0 && d != id) {\n            if(top < lis[d] || (top == lis[d] && d < id)) {\n                top = lis[d];\n                id = d;\n            }\n        }\n \n    }\n    tim[id] += l - nowtime;\n    if(tim[id] > timemax) {\n        timemax = tim[id];\n        timemaxid = id;\n    }\n    printf(\"%d\\n\",timemaxid);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef struct {\n  int id,sc;\n} node;\nnode dat[1<<18];\nint tim[111111];\nint n;\n\nnode max(node a,node b) {\n  if( a.sc < b.sc ) return b;\n  if( a.sc > b.sc ) return a;\n  return a.id > b.id ? b : a;\n}\n\nvoid update(int k,node x)\n{\n  k += n-1;\n  dat[k] = x;\n  while( k > 0 ) {\n    k /= 2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nint a[1111111],b[1111111],c[1111111];\n\nint main(void)\n{\n  int n_,r,l,i,j,pre,ma,res;\n  scanf(\"%d%d%d\",&n_,&r,&l);\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for( i = 0; i < n_; i++ ) dat[i+n-1].id = i;\n  for( i = 0; i < n_; i++ ) update(i,(node){i,0});\n  for( i = 0; i < r; i++ ){ scanf(\"%d%d%d\",a+i,b+i,c+i); a[i]--; }\n  b[r] = l;\n  pre = 0;\n  for( i = 0; i <= r; i++ ) {\n    tim[dat[0].id] += b[i]-pre;\n    for( j = i; j <= r && b[i] == b[j]; j++ ) {\n      update(a[j],(node){a[j],dat[a[j]+n-1].sc+c[j]});\n    }\n    i = j-1;\n    pre = b[i];\n  }\n  ma = 0;\n  res = 0;\n  for( i = 0; i < n_; i++ ) {\n    if( ma < tim[i] ) {\n      ma = tim[i];\n      res = i+1;\n    }\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define OZAWA -99999999\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = OZAWA;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t//\tprintf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for (int i=(int)(b); i<(int)(e); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T>\nclass SegTree {\n  int n;\n  vector<T> seg;\n  \n  // irrelevant value for query\n  const T NIL = make_pair(1<<30, 0);  \n  \n  // binary operator for query\n  T binop(T a, T b) {\n    return min(a, b);\n  }\n  \n  void update(int k, int l, int r, int p, T x) {\n    if (p < l || r <= p)\n      return;\n    if (r - l == 1)\n      seg[k] = x;\n    else {\n      update(2*k+1, l, (l+r)/2, p, x);\n      update(2*k+2, (l+r)/2, r, p, x);\n      seg[k] = binop(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n  T query(int k, int l, int r, int a, int b) {\n    if (b <= l || r <= a)\n      return NIL;\n    if (a <= l && r <= b)\n      return seg[k];\n    else {\n      T ret = NIL;\n      ret = binop(ret, query(2*k+1, l, (l+r)/2, a, b));\n      ret = binop(ret, query(2*k+2, (l+r)/2, r, a, b));\n      return ret;\n    }\n  }\npublic:\n  SegTree(int n): n(n), seg(4*n) {}\n  void init() {\n    for (int i = 0; i < 4*n; i++)\n      seg[i] = NIL;\n  }\n  // update p-th value to x\n  void update(int p, T x) {\n    update(0, 0, n, p, x);\n  }\n  // query for range [l, r)\n  T query(int l, int r) {\n    return query(0, 0, n, l, r);\n  }\n};\n\n\nint n, r, l;\nint sum[100000];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> r >> l;\n\n  SegTree<pair<int, int> > tree(100000);\n  int pre = 0;\n  REP (i, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    sum[tree.query(0, n).second] += t-pre;\n    int pt = -tree.query(d-1, d).first;\n    tree.update(d-1, make_pair(-(pt+x), d-1));\n    pre = t;\n  }\n  sum[tree.query(0, n).second] += l-pre;\n\n  int ans = 0;\n  REP (i, n) if (sum[i] > sum[ans]) ans = i;\n  cout << ans+1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[100001],t[100001],x[100001];\nint pnt[100000];\nint cnt[100000];\nsigned main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n    d[R]=0;t[R]=L;x[R]=0;\n\n\n    priority_queue<D>Q;\n\n    for(int i=0;i<N;i++)Q.push(D(0,i));\n\n    for(int i=0;i<R;i++){\n        pnt[d[i]]+=x[i];\n        Q.push(D(pnt[d[i]],d[i]));\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]+=t[i+1]-t[i];\n    }\n\n    cnt[0]+=x[0];\n\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = tp[1];\n\t\tFlag = 1;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t//\tprintf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131073];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint score[100000];\nint tim[100000];\n\nint main(){\n\tint i,j;\n\tint n,r,l,d,t,x;\n\tint mi;\n\tint lt=0;\n\tint identify,lidentify=0;\n\tcin >> n >> r >> l ;\n\tfor(i=0;i<100000;i++) score[i]=0;tim[i]=0;\n\tfor(i=0;i<r;i++){\n\t\tcin >> d >> t >> x;\n\t\tscore[d-1]+=x;\n\t\tidentify=lidentify;\n\t\tif(score[d-1] > score[lidentify] && x>=0) identify=d-1;\n\t\tif(score[d-1] == score[lidentify] && d-1<lidentify) identify=d-1;\n\t\tif(x<0) {\n\t\t\tidentify=0;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(score[j] > score[identify]) identify=j;\n\t\t\t}\n\t\t}\n\n\t\ttim[lidentify] += (t - lt);\n\t\t//cout << lidentify << \":\" << (t-lt) << endl;\n\t\tlt = t;lidentify=identify;\n\t}\n\ttim[lidentify] += l-lt;\n\t//cout << lidentify << \":\" << (l-lt) << endl;\n\tidentify=0;\n\tfor(i=0;i<n;i++){\n\t\tif(tim[i] > tim[identify]) identify = i;\n\t}\n\tcout << identify + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100001)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int score[4*MAX_N -1],time[4*MAX_N -1];\n  int r,l,n,n_;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  n_=n;\n  n=1;\n  while(n<n_) n*=2;\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    updata(time, k, time[k+n-1]+t, n);\n\n    updata(score, d, score[d+n-1]+x, n);\n  \n    /*\n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n;i<n*2;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n      }*/\n    \n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-1]+t, n);\n\n  /*\n  printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-1;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n) return k-n+1; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stdio.h>\nusing namespace std;\nint n,r,l;\nstruct log{\n\tint d[1000000];\n\tint x[1000000];\n};\nlog team;\nint t[1000000+1];\npriority_queue <pair<int,int> >que;\npair<int,int> p;\nint pnt[100000];\nint tm[100000];\nint mx;\nint mnum;\nint main(){\n\twhile(scanf(\"%d%d%d\",&n,&r,&l)){\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d%d%d\",&team.d[i],&t[i],&team.x[i]);\n\t}\n\tt[r]=l;\n\tfor(int i=0;i<r;i++){\n\t\tpnt[team.d[i]]+=team.x[i];\n\tfor(int j=1;j<=n;j++){\n\t\tque.push(make_pair(pnt[j],j*(-1)));\n\t}\n\t\tp=que.top();\n\t\ttm[p.second*(-1)]+=t[i+1]-t[i];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tque.pop();\n\t\t}\n\t\tcout<<p.second*(-1)<<\" \"<<tm[p.second*(-1)]<<\" \"<<pnt[p.second*(-1)]<<endl;\n\t}\n\tmx=tm[1];\n\tfor(int i=1;i<=n;i++){\n\t\tif(mx<tm[i]){\n\t\t\tmx=tm[i];\n\t\t\tmnum=i;\n\t\t}\n\t}\n\tcout<<mnum<<endl;\n\t}\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define all(a) a.begin(),a.end()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\n\nstruct Segtree {\n\tint n;\n\tvpii dat;\n\n\tvoid init(int n_) {\n\t\tn = 1;\n\n\t\twhile (n < n_) n *= 2;\n\n\t\tdat.resize(2 * n);\n\n\t\tfor (int i = 0; i < 2 * n - 1; ++i) dat[i] = pii(0, -inf);\n\t}\n\n\tvoid update(int a, int x) {\n\t\tint idx = a;\n\t\ta += n - 1;\n\n\t\tdat[a].fst += x;\n\t\tdat[a].scd = -idx;\n\n\t\twhile (a > 0) {\n\t\t\ta = (a - 1) / 2;\n\t\t\tdat[a] = max(dat[a * 2 + 1], dat[a * 2 + 2]);\n\t\t}\n\t}\n\n\tpii get_max() {\n\t\treturn dat[0];\n\t}\n};\n\ntypedef pair<int, pair<int, int> > Query;\n\nint res[100010];\n\nsigned main()\n{\n\tint N, R, L; scanf(\"%d%d%d\", &N, &R, &L);\n\n\tSegtree seg;\n\tseg.init(N);\n\n\tvector<Query> queries(R);\n\n\trep(i, R) {\n\t\tint d, t, x;\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\n\t\t-- d;\n\n\t\tqueries[i] = Query(t, pii(d, x));\n\t}\n\n\tqueries.PB(Query(L, pii(0, 0)));\n\t\n\tsort(all(queries));\n\n\trep(i, R) {\n\t\tQuery query = queries[i];\n\t\tQuery next_query = queries[i + 1];\n\n\t\tseg.update(query.scd.fst, query.scd.scd);\n\n\t\tif (query.fst != next_query.fst) {\n\t\t\tres[-seg.get_max().scd] += next_query.fst - query.fst;\n\t\t}\n\t}\n\n\tint ma = -1;\n\tint ans = -1;\n\n\trep(i, N) {\n\t\tif (ma < res[i]) {\n\t\t\tma = res[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P {\n\tint id, score;\n\tP(int id, int score) : id(id), score(score) { }\n};\n\nbool operator <(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id > p2.id;\n\treturn p1.score < p2.score;\n}\nbool operator >(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id < p2.id;\n\treturn p1.score > p2.score;\n}\n\nstruct Data {\n\tint d, t, x;\n\tData(int d, int t, int x) : d(d), t(t), x(x) { }\n};\n\nbool compare(const Data &d1, const Data &d2) {\n\treturn d1.t < d2.t;\n}\n\nint main() {\n\tvector<Data> v;\n\n\tint N, R, L; cin >> N >> R >> L;\n\tfor (int i = 0; i < R; ++i) {\n\t\tint d, t, x; cin >> d >> t >> x;\n\t\tv.push_back( Data(d-1, t, x) );\n\t}\n//\tsort( v.begin(), v.end(), compare );\n\n\tpriority_queue<P> Q;\n\tfor (int i = 0; i < N; ++i) {\n\t\tQ.push( P(i, 0) );\n\t}\n\n\tvector<int> score(N, 0);\n\tvector<int> broadTime(N, 0);\n\n\tint bt = 0;\n\tint maxNo = 0;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tint t = v[i].t;\n\t\tint pos = v[i].d; // テ」ツδ?」ツδシテ」ツδ?ァツ閉ェテ・ツ渉キ\n\t\tint x = v[i].x; // テ・ツ環?ァツつケ or テヲツクツ崚ァツつケ テ・ツ按?\n\n\t\tP top = Q.top();\n\n\t\t// テ・ツ環?ァツョツ?\n\t\tbroadTime[top.id] += t - bt;\n\n\t\tscore[pos] += x;\n\t\tif (x < 0) { // テヲツクツ崚ァツつケ\n\t\t\tif (pos == top.id) {\n\t\t\t\tQ.pop();\n\t\t\t\tQ.push( P(pos, score[pos]) );\n\t\t\t}\n\t\t}\n\t\telse if (x > 0) { // テ・ツ環?ァツつケ\n\t\t\tif (pos != top.id) {\n\t\t\t\tP newData = P(pos, score[pos]);\n\t\t\t\tif ( newData > top ) Q.push( newData );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tQ.pop();\n\t\t\t\tQ.push( P(pos, score[pos]) );\n\t\t\t}\n\t\t}\n\n\t\twhile ( 1) {\n\t\t\tP Top = Q.top();\n\t\t\tif (Top.score == score[Top.id] ) break;\n\n\t\t\tQ.pop();\n\t\t\tQ.push( P(Top.id, score[Top.id]) );\n\t\t}\n\n//\t\tcout << \":\" << top.id << endl;\n\n\t\tbt = t;\n\t}\n\tbroadTime[Q.top().id] += L - bt;\n\n\tint ansNo = 0, ansT = -1;\n\tfor (int i = 0; i < broadTime.size(); ++i) {\n\t\tif (broadTime[i] > ansT) {\n\t\t\tansT = broadTime[i];\n\t\t\tansNo = i;\n\t\t}\n//\t\tcout << \":\" << broadTime[i] << endl;\n\t}\n\tcout << (ansNo + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct node {\n\tint id, score;\n};\nbool operator<(node a, node b) {\n\tif (a.score == b.score)return a.id > b.id;\n\treturn a.score < b.score;\n}\nint s[100000], cnt[100000];\nint d[1000000], t[1000000], x[1000000];\nint main() {\n\tint n, r, l; scanf(\"%d%d%d\", &n, &r, &l);\n\tpriority_queue<node>que, ans;\n\trep(i, r)scanf(\"%d%d%d\", &d[i], &t[i], &x[i]);\n\trep(i, r) {\n\t\td[i]--;\n\t\ts[d[i]] += x[i];\n\t\tque.push({ d[i],s[d[i]] });\n\t\twhile (!que.empty() && que.top().score != s[que.top().id])que.pop();\n\t\tif (i == r - 1) {\n\t\t\tcnt[que.top().id] += l - t[i];\n\t\t\tans.push({ que.top().id,cnt[que.top().id] });\n\t\t}\n\t\telse {\n\t\t\tcnt[que.top().id] += t[i + 1] - t[i];\n\t\t\tans.push({ que.top().id,cnt[que.top().id] });\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.top().id + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\nusing VL = vector<ll>;\n#define FOR(i,a,n) for(int (i)=(a);(i)<(n);(i)++)\n#define eFOR(i,a,n) for(int (i)=(a);(i)<=(n);(i)++)\n#define rFOR(i,a,n) for(int (i)=(n)-1;(i)>=(a);(i)--)\n#define erFOR(i,a,n) for(int (i)=(n);(i)>=(a);(i)--)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\n#define all(i) (i).begin(),(i).end()\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; }return 0; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T> inline istream& operator>>(istream& input, vector<T>& v) { for (auto& elemnt : v)input >> elemnt; return input; }\n\nusing T = pair<ll, int>;\nbool comp(T a, T b) {\n    if (a.first == b.first)return a.second > b.second;\n    return a.first < b.first;\n}\n\nclass segtree {\n    int n = 1; vector<pair<ll,int>> dat;\n#define def {-LLINF/2,INF}\n    T fun(T x, T y) { return max(x, y, comp); }\npublic:\n    segtree(int _n) {\n        while (n < _n)n *= 2;\n        dat.resize(2 * n - 1, def);\n        FOR(i, 0, _n)dat[i + n - 1] = { 0,i };\n        rFOR(i, 0, n - 1)dat[i] = fun(dat[2 * i + 1], dat[2 * i + 2]);\n    }\n    segtree(VL a) {\n        int _n = a.size();\n        while (n < _n)n *= 2;\n        dat.resize(2 * n - 1, def);\n        FOR(i, 0, _n)dat[i + n - 1] = { a[i],i };\n        rFOR(i, 0, n - 1)dat[i] = fun(dat[2 * i + 1], dat[2 * i + 2]);\n    }\n    void show() {\n        FOR(i, 0, 2*n-1) {\n            cout << dat[i].first << \" \" << dat[i].second << \"\\n\";\n        }\n    }\n    void add(int i, ll a) {\n        i += n - 1;\n        dat[i].first += a;\n        while (i > 0) {\n            --i /= 2;\n            dat[i] = fun(dat[2 * i + 1], dat[2 * i + 2]);\n        }\n    }\n    T get(int a, int b, int k, int l, int r) {\n        if (b <= l || r <= a)return def;\n        if (a <= l && r <= b)return dat[k];\n        else {\n            T s = get(a, b, 2 * k + 1, l, (l + r) / 2);\n            T t = get(a, b, 2 * k + 2, (l + r) / 2, r);\n            return fun(s, t);\n        }\n    }\n    T get(int a, int b) { return get(a, b, 0, 0, n); }\n};\n\nstruct Log {\n    int id, time;\n    ll point;\n\n    bool operator<(const Log& a) {\n        return time < a.time;\n    }\n};\n\nint main() {\n    init();\n\n    int n, r, l;\n    cin >> n >> r >> l;\n\n    vector<Log> logs(r);\n    FOR(i, 0, r) {\n        int d, t; ll x;\n        cin >> d >> t >> x;\n        logs[i] = { --d,t,x };\n    }\n    logs.push_back({ 0,0,0LL });\n    logs.push_back({ 0,l,0LL });\n    SORT(logs);\n\n    segtree seg(n);\n    VI ans(n, 0);\n    int next_time = 0;\n    eFOR(i, 1, r) {\n        seg.add(logs[i].id, logs[i].point);\n        if (logs[i].time < logs[i + 1].time) {\n            next_time = logs[i + 1].time;\n            ans[seg.get(0, n).second] += next_time - logs[i].time;\n            //cout << seg.get(0, n).second << \"\\n\";\n        }\n    }\n    //seg.show();\n\n    int id = 1, time = 0;\n    FOR(i, 0, n) {\n        //cout << ans[i] << \"\\n\";\n        if (chmax(time, ans[i]))id = i + 1;\n    }\n    cout << id << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\tnowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\tnowN = (time[n-1]==time[nowN]?min(n-1,nowN):(time[n-1]>time[nowN]?n-1:nowN));\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\ntypedef pair<ll,ll> pll;\n#define MP make_pair<ll>\n\nint main(){\n  ll n,r,l;\n  cin >> n >> r >> l;\n  ll nowtime = 0;\n  ll times[n]; REP(i,n)times[i]=0;\n  ll score[n]; REP(i,n)score[i]=0;\n  set<pll> ranking; REP(i,n)ranking.insert(MP(score[i],i));\n  set<pll>::iterator iter;\n  REP(i,r){\n    ll d,t,x;\n    cin >> d >> t >> x;\n    times[ranking.rbegin()->second] += (t-nowtime);\n    nowtime = t;\n    d = n-d;\n\n    pll nw = MP(score[d],d);\n    iter = ranking.find(nw);\n    ranking.erase(iter);\n    score[d] += x;\n    nw = MP(score[d],d);\n    ranking.insert(nw);\n  }\n  times[ranking.rbegin()->second] += (l-nowtime);\n  ll id = 0;\n  ll mx = times[0];\n  REPR(i,n){\n    if(times[i]>mx){\n      mx = times[i];\n      id = i;\n    }\n  }\n  cout << (n-id) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += (t-oldt);\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n    }else old = max(pt,N);\n  }\n  //cout << t << ' ' << oldt << endl;\n  ptime[old] += (L-oldt);\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P {\n\tint id, score;\n\tP(int id, int score) : id(id), score(score) { }\n};\n\nbool operator <(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id > p2.id;\n\treturn p1.score < p2.score;\n}\nbool operator >(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id < p2.id;\n\treturn p1.score > p2.score;\n}\n\nstruct Data {\n\tint d, t, x;\n\tData(int d, int t, int x) : d(d), t(t), x(x) { }\n};\n\nbool compare(const Data &d1, const Data &d2) {\n\treturn d1.t < d2.t;\n}\n\nint main() {\n\tvector<Data> v;\n\n\tint N, R, L; cin >> N >> R >> L;\n\tfor (int i = 0; i < R; ++i) {\n\t\tint d, t, x; cin >> d >> t >> x;\n\t\tv.push_back( Data(d-1, t, x) );\n\t}\n\tsort( v.begin(), v.end(), compare );\n\n\tpriority_queue<P> Q;\n\tfor (int i = 0; i < N; ++i) {\n\t\tQ.push( P(i, 0) );\n\t}\n\n\tvector<int> score(N, 0);\n\tvector<int> broadTime(N, 0);\n\n\tint bt = 0;\n\tint maxNo = 0;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tint t = v[i].t;\n\t\tint pos = v[i].d; // テ」ツδ?」ツδシテ」ツδ?ァツ閉ェテ・ツ渉キ\n\t\tint x = v[i].x; // テ・ツ環?ァツつケ or テヲツクツ崚ァツつケ テ・ツ按?\n\n\t\tP top = Q.top();\n\n\t\t// テ・ツ環?ァツョツ?\n\t\tbroadTime[top.id] += t - bt;\n\t\tscore[pos] += x;\n\t\tif (x > 0) { // テ・ツ環?ァツつケ\n\t\t\tif (pos != top.id) {\n\t\t\t\tP newData = P(pos, score[pos]);\n\t\t\t\tQ.push( newData );\n//\t\t\t\tcout << \":\" << newData.id << \" \" << newData.score << endl;\n\t\t\t}\n\t\t}\n\n\t\twhile ( 1 ) {\n\t\t\tP Top = Q.top();\n\t\t\tif (Top.score == score[Top.id] ) break;\n\n\t\t\tQ.pop();\n\t\t\tQ.push( P(Top.id, score[Top.id]) );\n\t\t}\n/*\n\t\tqueue<P> Q2;\n\t\twhile ( !Q.empty() ) {\n\t\t\tP data = Q.top(); Q.pop(); Q2.push(data);\n\t\t\tcout << \":\" << data.id << \" \" << data.score << endl;\n\t\t}\n\t\twhile ( !Q2.empty() ) {\n\t\t\tP data = Q2.front(); Q2.pop(); Q.push(data);\n\t\t}\n\t\tcout << endl;\n*/\n//\t\tcout << Q.top().score << endl;\n\n//\t\tcout << \":\" << top.id << endl;\n\n\t\tbt = t;\n\t}\n\tbroadTime[Q.top().id] += L - bt;\n\n\tint ansNo = 0, ansT = -1;\n\tfor (int i = 0; i < broadTime.size(); ++i) {\n\t\tif (broadTime[i] > ansT) {\n\t\t\tansT = broadTime[i];\n\t\t\tansNo = i;\n\t\t}\n//\t\tcout << \":\" << broadTime[i] << endl;\n\t}\n\tcout << (ansNo + 1) << endl;\n\n\tfor (int i = 0; i < score.size(); ++i) {\n//\t\tcout << score[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point{\n  int score,player;\n\n  bool operator < (const Point& p) const {\n    if( score != p.score ) return score < p.score;\n    return player > p.player;\n  }\n};\n\n/*\n  ostream& operator << (ostream& os,const Point& p) {\n  os << \"(\" << p.score << \",\" << p.player <<\")\";\n}\n*/\nint main(){\n  \n  int N,R,L,temp=0;\n  int d,t,x;\n  priority_queue<Point> PQ;\n  priority_queue<Point> PQ2;\n  int score_sum[100001],time_sum[100001];\n  int data[3]={1,0,0};\n  \n  cin >>N>>R>>L;\n  \n  for(int i=0 ; i < 100001 ; i++){\n    score_sum[i]=0;\n    time_sum[i]=0;\n  }\n  \n  for(int i=1 ; i <= R ; i++){\n    \n    cin >>d>>t>>x;\n    \n    PQ.push((Point){score_sum[data[0]],data[0]});\n    \n    score_sum[d]+=x;\n    \n    while(1){\n      if(PQ.top().score == score_sum[PQ.top().player]){\n\ttime_sum[PQ.top().player]+=t-data[1];\n\tbreak;\n      }else{\n\tPQ.pop();\n      }\n    }  \n    PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n    \n    data[0]=d;data[1]=t;data[2]=x;  \n  }\n  PQ.push((Point){score_sum[data[0]],data[0]});\n  while(1){\n    if(PQ.top().score == score_sum[PQ.top().player]){\n      time_sum[PQ.top().player]+=L-data[1];\n      break;\n    }else{\n      PQ.pop();\n    }\n  }\n  PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n  \n  cout <<PQ2.top().player<<endl;\n  \n  //cout <<PQ2.top().score<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct node {\n\tint id, score;\n};\nbool operator<(node a, node b) {\n\tif (a.score == b.score)return a.id < b.id;\n\treturn a.score > b.score;\n}\nint s[100000], cnt[100000];\nint d[1000000], t[1000000], x[1000000];\nint main() {\n\tint n, r, l; scanf(\"%d%d%d\", &n, &r, &l);\n\tset<node>que;\n\trep(i, r)scanf(\"%d%d%d\", &d[i], &t[i], &x[i]);\n\trep(i, r) {\n\t\td[i]--;\n\t\ts[d[i]] += x[i];\n\t\tque.insert({ d[i],s[d[i]] });\n\t\twhile (!que.empty() && (*que.begin()).score != s[(*que.begin()).id])que.erase(que.begin());\n\t\tif (i == r - 1)cnt[(*que.begin()).id] += l - t[i];\n\t\telse cnt[(*que.begin()).id] += t[i + 1] - t[i];\n\t}\n\tprintf(\"%d\\n\", max_element(cnt, cnt + n) - cnt + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n//segment-tree\nint n;//nは2のべき乗\npii dat[100001*2-1];\n//i番目の値(0-indexed)をxに変更\nvoid update(int i,int x){\n\t//葉のノード番号\n\tint team =i;\n\ti +=n-1;\n\tdat[i].first +=x;\n\tdat[i].second = -team;\n\twhile(i >0){\n\t\ti =(i-1)/2;\n\t\tdat[i] =max(dat[i*2+1],dat[i*2+2]);\n\t}\n}\n\n//初期化\nvoid init(int _n){\n\tn = 1;\n\twhile(n<_n)\n\t\tn *=2;\n\tfor(int i = 0;i <_n;i++){\n\t\tupdate(i,0);\n\t}\n}\n\n/*\n//[a,b)の最小値,l,rにはノードkに対応づく区画を与える\n//外からはquery(a,b,0,0,n)のように呼ぶ\nint query(int a,int b,int k,int l,int r){\n\tif(r <=a||b <=l)//交差しない\n\t\treturn INT_MAX;\n\tif(a <=l&&r<=b)//完全に含む\n\t\treturn dat[k];\n\telse{\n\t\tint vl =query(a, b, k*2+1, l, (l+r)/2);\n\t\tint vr =query(a, b, k*2+2, (l+r)/2, r);\n\t\treturn max(vl,vr);\n\t}\n}\n*/\nint main(){\n\tint N,R,L;\n\tcin>>N>>R>>L;\n\tinit(N);\n\tint team = 0;\n\tint pret  =0;\n\tint sum[110000];\n\tfor(int i = 0;i < R;i++){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x;\n\t\td--;\n\t\tupdate(d,x);\n\t\tsum[team]+=t-pret;\n\t\tpret =t;\n\t\tteam =-dat[0].second;\n\t}\n\tsum[team] +=L-pret;\n\tint ans = 0;\n\tfor(int i = 0;i < N;i++){\n\t\tif(sum[ans]<sum[i]){\n\t\t\tans = i;\n\t\t}\n\t}\n\tcout <<ans+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct T {\n  int i, s;\n\n  bool operator<(const T& right) const {\n    return s == right.s ? i < right.s : s < right.s;\n  }\n};\n\nint MAX_N = 1 << 17;\nint n = 1;\nvector<T> dat(MAX_N * 2 - 1);\nT minT;\n\nvoid update(int k, int a) {\n  k = k + n - 1;\n  dat[k].s += a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint main() {\n  int t, r, l, z = 0, zi = 0, sc[100001] = {};\n  cin >> t >> r >> l;\n  while(t > n) n *= 2;\n  minT.i = 10000000;\n  minT.s = 0;\n  rep(i, 0, n * 2 - 1) dat[i] = minT;\n  rep(i, n - 1, n * 2 - 1) dat[i].i = i - (n - 1);\n\n\n\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    sc[zi] += b - z;\n    update(a - 1, c);\n    zi = dat[0].i;\n    z = b;\n  }\n\n  sc[zi] += l - z;\n  int ms = 0, ans;\n  rep(i, 0, t) if(ms < sc[i]) ans = i + 1, ms = sc[i];\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#define INF 1145141919\n#define SIZE1 131072\n#define SIZE2 262144\nusing namespace std;\n\nclass segtree{\n\tint score[SIZE1];\n\tint tree[SIZE2];//not use 0;\npublic:\n\tvoid reset(int n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscore[i] = 0;\n\t\t}\n\t\tfor (int i = n; i < SIZE1; i++){\n\t\t\tscore[i] = -INF;\n\t\t}\n\t\tfor (int i = SIZE2 - 1; i >= SIZE1; i--){\n\t\t\ttree[i] = i - SIZE1;\n\t\t}\n\t\tfor (int i = SIZE1 - 1; i >= 1; i--){\n\t\t\ttree[i] = tree[i * 2];\n\t\t}\n\t\treturn;\n\t}\n\tvoid setting(int team, int up){\n\t\tscore[team] += up;\n\t\tint now = team + SIZE1;\n\t\twhile (now != 1){\n\t\t\tnow /= 2;\n\t\t\ttree[now] = (score[tree[now * 2]] < score[tree[now * 2 + 1]]) ? tree[now * 2 + 1] : tree[now * 2];\n\t\t}\n\t\treturn;\n\t}\n\tint top(){\n\t\treturn tree[1];\n\t}\n};\n\nint n, r, l;\nint tim[100000];\nvector<pair<int, int> > per;\nint d[1000002], t[1000002], x[1000002];\nsegtree s;\nint main()\n{\n\tcin >> n >> r >> l;\n\ts.reset(n);\n\tfor (int i = 1; i <= r; i++){\n\t\tcin >> d[i] >> t[i] >> x[i];\n\t}\n\tt[r + 1] = l;\n\tint nowtop = 0;\n\tfor (int i = 1; i <= r + 1; i++){\n\t\ts.setting(d[i] - 1, x[i]);\n\t\ttim[nowtop] += t[i] - t[i - 1];\n\t\tnowtop = s.top();\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tper.push_back(make_pair(tim[i], i));\n\t}\n\tsort(per.begin(), per.end(), greater<pair<int, int> >());\n\tcout << per[0].second + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[100000];\n\nint N, R, L, n;\n\npair<int, int> dat[200000];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m;\n  for(int i = 0; i < N; i++)\n  {\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    update(d, make_pair(dat[d + (n - 1)].first + x, dat[d + (n - 1)].second));\n    if(i != R - 1) \n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  team[search(id,n)].point+=key;\n  maxHeapify(id);\n  while(id>1&&team[id/2].point<team[id].point){\n    swap(team[id],team[id/2]);\n    id=id/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=search(top,n);\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i],x[i],n);\n    //printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  //for(int i=1;i<=n;i++){\n  //printf(\"%d %d\\n\",team[i].id,team[i].showed);\n  //}\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\npair<int,int> rmq[1111111];\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-1;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      team[smp-2] += t[i] - now;\n      if(t[i] != t[i+1]){ \n\tnow = t[i];\n      }\n    }\n    smp = rmq[0].second;\n  }\n  team[smp-2] += L - now;\n  int a=0;\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint score[100000];\nint tim[100000];\nint rank[1000000]; //rank->id\nint rrank[1000000]; //id->rank\n\nint n,r,l,d,t,x;\n\nint rank_change(int a,int b){\n\tint i;\n\tif(b>=0){\n\t\tfor(i=rrank[a];i>0;i--){\n\t\t\tif(score[rank[i-1]] < score[rank[i]]) {\n\t\t\t\tswap(rrank[rank[i-1]],rrank[rank[i]]);\n\t\t\t\tswap(rank[i-1],rank[i]);\n\t\t\t\t//cout << \"swap1\" << endl;\n\t\t\t}\n\t\t\telse if(score[rank[i-1]] == score[rank[i]] && rank[i-1] > rank[i]) {\n\t\t\t\tswap(rrank[rank[i-1]],rrank[rank[i]]);\n\t\t\t\tswap(rank[i-1],rank[i]);\n\t\t\t\t//cout << \"swap1\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << \"break\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(i=rrank[a];i<n-1;i++){\n\t\t\tif(score[rank[i]] < score[rank[i+1]]) {\n\t\t\t\tswap(rrank[rank[i]],rrank[rank[i+1]]);\n\t\t\t\tswap(rank[i],rank[i+1]);\n\t\t\t}\n\t\t\telse if(score[rank[i]] == score[rank[i+1]] && rank[i] > rank[i+1]) {\n\t\t\t\tswap(rrank[rank[i]],rrank[rank[i+1]]);\n\t\t\t\tswap(rank[i],rank[i+1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint i,j;\n\tint mi;\n\tint lt=0;\n\tint identify,lidentify=0;\n\tcin >> n >> r >> l ;\n\tfor(i=0;i<100000;i++) score[i]=0;tim[i]=0;\n\tfor(i=0;i<n;i++) {\n\t\trank[i]=i;\n\t\trrank[i]=i;\n\t}\n\tfor(i=0;i<r;i++){\n\t\tcin >> d >> t >> x;\n\t\tscore[d-1]+=x;\n\t\trank_change(d-1,x);\n\t\ttim[lidentify] += (t - lt);\n\t\t//cout << \"-\";\n\t\t//for(j=0;j<n;j++) cout << rank[j];\n\t\t//cout << endl;\n\t\t//cout << \"[\" << lidentify << \":\" << (t-lt) << \"]\" << endl;\n\t\tlt = t;lidentify=rank[0];\n\t\t//cout  << endl;\n\t}\n\ttim[lidentify] += l-lt;\n\t//cout << lidentify << \":\" << (l-lt) << endl;\n\tidentify=0;\n\tfor(i=0;i<n;i++){\n\t\tif(tim[i] > tim[identify]) identify = i;\n\t}\n\tcout << identify + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[100010];\nstruct node {\n    int id;\n    long long point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            if (id<0) { printf(\"hgoe\\n\"); return 0; }\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\nconst int MAX_N = 1<<20;\n\nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = -INF;\n        dat[i].se = -(i-n+1);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\trep(i, n) update(i, INF);\n\tvi v(n, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se] = t-tt;\n\t\ttt = t;\n\t\tupdate(d-1, x);\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] = l-tt;\n\tint ans = 0;\n\tfor(int i = 1; i < v.size(); i++){\n\t\tif(v[ans] < v[i]) ans = i;\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\t//maxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]=+s;\n\t\tif(nowN==-1){nowN=n-1;\n\t\t//else nowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\t}else if(scr[n-1]>=scr[nowN]){\n\t\t\tif(scr[n-1]==scr[nowN])nowN=min(n-1,nowN);\n\t\t\telse nowN=n-1;\n\t\t}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN + 1);\n\treturn 0;*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131071];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P {\n\tint id, score;\n\tP(int id, int score) : id(id), score(score) { }\n};\n\nbool operator <(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id > p2.id;\n\treturn p1.score < p2.score;\n}\nbool operator >(const P &p1, const P &p2) {\n\tif (p1.score == p2.score) return p1.id < p2.id;\n\treturn p1.score > p2.score;\n}\n\nstruct Data {\n\tint d, t, x;\n\tData(int d, int t, int x) : d(d), t(t), x(x) { }\n};\n\nbool compare(const Data &d1, const Data &d2) {\n\treturn d1.t < d2.t;\n}\n\nint main() {\n\tvector<Data> v;\n\n\tint N, R, L; cin >> N >> R >> L;\n\tfor (int i = 0; i < R; ++i) {\n\t\tint d, t, x; cin >> d >> t >> x;\n\t\tv.push_back( Data(d-1, t, x) );\n\t}\n\tsort( v.begin(), v.end(), compare );\n\n\tpriority_queue<P> Q;\n\tfor (int i = 0; i < N; ++i) {\n\t\tQ.push( P(i, 0) );\n\t}\n\n\tvector<int> score(N, 0);\n\tvector<int> broadTime(N, 0);\n\n\tint bt = 0;\n\tint maxNo = 0;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tint t = v[i].t;\n\t\tint pos = v[i].d; // テ」ツδ?」ツδシテ」ツδ?ァツ閉ェテ・ツ渉キ\n\t\tint x = v[i].x; // テ・ツ環?ァツつケ or テヲツクツ崚ァツつケ テ・ツ按?\n\n\t\tP top = Q.top();\n\n\t\t// テ・ツ環?ァツョツ?\n\t\tbroadTime[top.id] += t - bt;\n\t\tscore[pos] += x;\n\t\tif (x > 0 && pos != top.id) { // テ・ツ環?ァツつケ\n\t\t\tif (pos != top.id) {\n\t\t\t\tP newData = P(pos, score[pos]);\n\t\t\t\tif ( newData > top ) Q.push( newData );\n\t\t\t}\n\t\t}\n/*\n\t\tif (x < 0) { // テヲツクツ崚ァツつケ\n\t\t\tif (pos == top.id) {\n\t\t\t\tQ.pop();\n\t\t\t\tQ.push( P(pos, score[pos]) );\n\t\t\t}\n\t\t}\n\t\telse if (x > 0) { // テ・ツ環?ァツつケ\n\t\t\tif (pos != top.id) {\n\t\t\t\tP newData = P(pos, score[pos]);\n\t\t\t\tif ( newData > top ) Q.push( newData );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tQ.pop();\n\t\t\t\tQ.push( P(pos, score[pos]) );\n\t\t\t}\n\t\t}\n*/\n\n\t\twhile ( 1) {\n\t\t\tP Top = Q.top();\n\t\t\tif (Top.score == score[Top.id] ) break;\n\n\t\t\tQ.pop();\n\t\t\tQ.push( P(Top.id, score[Top.id]) );\n\t\t}\n\n//\t\tcout << \":\" << top.id << endl;\n\n\t\tbt = t;\n\t}\n\tbroadTime[Q.top().id] += L - bt;\n\n\tint ansNo = 0, ansT = -1;\n\tfor (int i = 0; i < broadTime.size(); ++i) {\n\t\tif (broadTime[i] > ansT) {\n\t\t\tansT = broadTime[i];\n\t\t\tansNo = i;\n\t\t}\n//\t\tcout << \":\" << broadTime[i] << endl;\n\t}\n\tcout << (ansNo + 1) << endl;\n\n\tfor (int i = 0; i < score.size(); ++i) {\n//\t\tcout << score[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100001, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n    }\n\n    int prev = 0, ts[MAX_N];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R){\n        if(i+1 >= R || rs[i].t < rs[i+1].t){\n            ts[st.root().second] += rs[i].t - prev;\n        }\n        st.update(rs[i].d, rs[i].x);\n        prev = rs[i].t;\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = -1;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    // std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nmain(){\n  priority_queue<pair<int, int> > q;\n  int N, R, L, S[1000001], T[1000001], d, t, x;\n  \n  scanf(\"%d %d %d\", &N, &R, &L);\n  q.push(make_pair(0, -1));\n\n  for ( int i = 0; i <= N; i++ ) S[i] = T[i] = 0;\n  int pret = 0, pred = 1;\n\n  for(int i = 0; i < R; i++){\n    scanf(\"%d %d %d\", &d, &t, &x);\n    S[d] += x;\n    q.push(make_pair(S[d], -d));\n    while(1){\n      pair<int, int> p = q.top();\n      if(p.first == S[-p.second]){\n\tT[pred] += t - pret;\n\tpred = -p.second;\n\tpret = t;\n        break;\n      }\n      q.pop();\n    }\n  }\n  T[pred] += L - pret;\n\n  int maxv = -2000000000, ans = -1;\n  for ( int i = 1; i <= N; i++ ){\n    if ( maxv < T[i] ){\n      maxv = T[i];\n      ans = i;\n    }\n  }\n\n  printf(\"%d\\n\",  ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d-1+e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;scanf(\"%lld%lld%lld\",&x,&y,&z);\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2],[](P a,P b){if(a.first!=b.first)return a.first<b.first;return a.second<=b.second;});\n\t    }\n\tpoint[team]+=y-last;\n\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100001],tt[100001];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = 0;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t\t//printf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint a[400005][2];\nint s[100005];\nint main(){\n\tint i,j,k;\n\tint n,r,l;\n\tint d=0;\n\tint t=0;\n\tint x=0;\n\tint nn=0;\n\tint f=0;\n\tmemset(a,0,sizeof(a));\n\tmemset(s,0,sizeof(s));\n\tcin>>n>>r>>l;\n\tnn=1;\n\twhile(nn<n){\n\t\tnn*=2;\n\t}\n\tnn--;\n\tfor(i=0;i<n;i++){\n\t\ta[nn+i][1]=i;\n\t}\n\td=nn;\n\twhile(d!=0){\n\t\td--;\n\t\tif(a[d*2+1][0]<a[d*2+2][0]){\n\t\t\ta[d][0]=a[d*2+2][0];\n\t\t\ta[d][1]=a[d*2+2][1];\n\t\t}else{\n\t\t\ta[d][0]=a[d*2+1][0];\n\t\t\ta[d][1]=a[d*2+1][1];\n\t\t}\n\t}\n\tfor(i=0;i<r;i++){\n\t\tcin>>d>>t>>x;  \n\t\ts[f]+=t;\n\t\td--;\n\t\td+=nn;\n\t\ta[d][0]+=x;\n\t\twhile(d!=0){\n\t\t\td=(d-1)/2;\n\t\t\tif(a[d*2+1][0]<a[d*2+2][0]){\n\t\t\t\ta[d][0]=a[d*2+2][0];\n\t\t\t\ta[d][1]=a[d*2+2][1];\n\t\t\t}else{\n\t\t\t\ta[d][0]=a[d*2+1][0];\n\t\t\t\ta[d][1]=a[d*2+1][1];\n\t\t\t}\n\t\t}\n\t\tf=a[0][1];\n\t\ts[f]-=t;\n\t}\n\ts[f]+=l;\n\tnn=0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[nn]<s[i])nn=i;\n\t}\n\tnn++;\n\tcout<<nn<<endl;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define MAX 1111111\n#define MIN -1111111\ntypedef pair<int,int> P;\nvoid init(int n);\nvoid update(int k,int x);\nP maxx(int k1,int k2);\nP dat[2*100001];\nint tim[100001]={0};\nint N;\n\nint main(){\n  int R,L;\n  cin >> N >> R >> L;\n  int n_tmp = N;\n  init(N);\n  memset(tim,0,n_tmp+1);\n  int now = 0;\n  dat[0]=P(MIN,1);\n  for(int i=0;i<R;i++){\n    int d,t,x;\n    cin >> d >> t >> x;\n    tim[dat[0].second] += t - now;\n    update(d,x);\n    now = t;\n  }\n  tim[dat[0].second] += L - now;\n  int *ans = max_element(tim,tim+n_tmp+1);\n  cout << ans - tim << endl;\n}\n\nvoid init(int n){\n  N=1;\n  while(N<n) N*=2;\n  for(int i=0;i<2*N-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n  for(int i=N-1;i<N-1+n;i++){\n    dat[i]=P(0,i-(N-2));\n  }\n  return;\n}\n\nvoid update(int k,int x){\n  k += N - 2;\n  P p = dat[k];\n  int score = p.first;\n  int team = p.second;\n  //cout << score << \" \" << team << endl;\n  dat[k] = P(score+x,team);\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = maxx(k*2+1,k*2+2);\n    //cout << dat[k].first << \" \" << dat[k].second << endl;\n  }\n  return;\n}\n\nP maxx(int k1,int k2){\n  P p;\n  if(dat[k1].first == dat[k2].first){\n    p = P(dat[k1].first,min(dat[k1].second,dat[k2].second));\n  }\n  else {\n    p = max(dat[k1],dat[k2]);\n  }\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n// pp basics\n\n#define in ,\n#define esc_paren(...) __VA_ARGS__\n#define pp_empty(...)\n#define pp_cat_i(x, y) x ## y\n#define pp_cat(x, y) pp_cat_i(x, y)\n\n#define pp_inc0 1\n#define pp_inc1 2\n#define pp_inc2 3\n#define pp_inc3 4\n#define pp_inc4 5\n#define pp_inc5 6\n#define pp_inc6 7\n#define pp_inc7 8\n#define pp_inc8 9\n#define pp_inc(i) pp_cat(pp_inc, i)\n\n// pp args counter\n\n#define pp_arg10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) _9\n#define pp_has_comma(...) pp_arg10(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 0)\n#define pp_trigger_paren(...) ,\n#define pp_is_empty(...) \\\n  pp_is_empty1( \\\n      pp_has_comma(__VA_ARGS__), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__), \\\n      pp_has_comma(__VA_ARGS__()), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__()) \\\n      ) \n#define pp_paste5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4\n#define pp_is_empty1(_0, _1, _2, _3) pp_has_comma(pp_paste5(pp_is_empty_case_, _0, _1, _2, _3))\n#define pp_is_empty_case_0001 ,\n\n#define pp_is_one(...) pp_is_one_(__VA_ARGS__, pp_one_seq)\n#define pp_is_one_(...) pp_is_one_n(__VA_ARGS__)\n#define pp_is_one_n(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10, N, ...) N\n#define pp_one_seq 0,0,0,0,0,0,0,0,0,1,0\n\n#define pp_narg(...) \\\n         pp_narg_(__VA_ARGS__, pp_narg_seq)\n#define pp_narg_(...) \\\n         pp_narg_n(__VA_ARGS__)\n#define pp_narg_n( \\\n          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\\n         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\\n         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\\n         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\\n         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\\n         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\\n         _61,_62,_63,n,...) n\n#define pp_narg_seq \\\n         63,62,61,60, \\\n         59,58,57,56,55,54,53,52,51,50, \\\n         49,48,47,46,45,44,43,42,41,40, \\\n         39,38,37,36,35,34,33,32,31,30, \\\n         29,28,27,26,25,24,23,22,21,20, \\\n         19,18,17,16,15,14,13,12,11,10, \\\n          9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n// pp if\n#define pp_if_0(x, y) y\n#define pp_if_1(x, y) x\n#define pp_if(cond, x, y) pp_cat(pp_if_, cond)(x, y)\n\n// pp foreach\n#define pp_foreach_i9(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i8(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i7(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i6(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i5(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i4(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i3(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i2(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i1(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i0(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i(i, f, ...) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach(f, ...) pp_foreach_i(0, f, __VA_ARGS__)\n\n// alternative rep macro\n#define rep(...) rep1(rep2, (__VA_ARGS__))\n#define rep1(X, A) X A\n#define rep2(i, ...) pp_if(pp_is_one(__VA_ARGS__), rep_len1(i, __VA_ARGS__), rep3(i, __VA_ARGS__))\n#define rep_len1(i, end, ...) for (int i = 0; i < end; i++)\n#define rep3(i, iter, ...) rep4(rep5, (iter, i, esc_paren __VA_ARGS__))\n#define rep4(X, A) X A\n#define rep5(iter, ...) iter(__VA_ARGS__)\n\n// iterators\n#define up up_iter ,\n#define up_iter3(i, start, end) for (int i = start; i < end; i++)\n#define up_iter4(i, start, end, up) for (int i = start; i < end; i += up)\n#define up_iter(...) pp_cat(up_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define down down_iter ,\n#define down_iter2(i, end) for(int i = end-1; i >= 0; i--)\n#define down_iter3(i, start, end) for (int i = end-1; i >= start; i--)\n#define down_iter4(i, start, end, down) for (int i = end-1; i >= start; i -= down)\n#define down_iter(...) pp_cat(down_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define viter viter_iter ,\n#define viter_iter(i, v) auto tmpitr=v.begin(); for (auto i=*tmpitr; tmpitr != v.end(); tmpitr++)\n\n// debug macros\n#define debug_var_elem(v) << #v << \"=\" << v << \" \"\n#ifdef DEBUG\n#define debug_echo(e) cout << \"L\" << __LINE__ << \": \" << e << endl\n#define debug_var(...) cout << \"L\" << __LINE__ << \": \" pp_foreach(debug_var_elem, __VA_ARGS__) << endl\n#define debug_ary(ary) cout << \"L\" << __LINE__ << \" [ \"; for(auto ele : ary) cout << ele << \" \"; cout << \"]\" << endl;\n#else\n#define debug_echo(e)\n#define debug_var(...)\n#define debug_ary(ary)\n#endif\n\n// short names\ntypedef long long ll;\n#define down_queue(x) priority_queue<x>\n#define up_queue(x) priority_queue<x, vector<x>, greater<x>>\nll gcd(ll a,ll b){while(b){ll tmp = a % b;a = b;b = tmp;}return a;}\nll lcm(ll a,ll b){return a / gcd(a,b) * b;}\n#define all(x) x.begin(), x.end()\n#define split_str(str, sp_word) istringstream stream(str); string res; for(int cnt = 0; getline(stream,res,sp_word); cnt++)\n#define digit(x) ((int)log10((double)(x)) + 1)\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\nvector<int> digit_split(int n){vector<int> result(digit(n));for(int i = 0; n; i++){result[i] = n % 10;n /= 10;}return result;}\n#define time(content) {auto start = clock();content;auto end = clock();cout << (double)(end - start) << \"ms\" << endl;} \n#define vec_cpy(to,from) copy(all(to),back_inserter(from))\n#define ary_cpy(to,from) memcpy(to, from, sizeof(from))\n#define MOD 1000000007 \n\n// pp unionfind\n#define pp_gen_field(list) pp_gen_field1 list\n#define pp_gen_field1(name, val) decltype(val) name;\n#define pp_gen_init(list) pp_gen_init1 list\n#define pp_gen_init1(name, val) ,val\n#define pp_gen_find_set_wrap(ufnodename) ufnodename pp_gen_find_set\n#define pp_gen_find_set(list) pp_gen_find_set1 list\n#define pp_gen_find_set1(name, val) \\\n  find_set_ ## name(int x, decltype(val) v) { \\\n    if (nodes[x].parent == x) { \\\n      nodes[x].name = v; \\\n      return nodes[x]; \\\n    } else { \\\n      return nodes[x] = find_set_ ## name(nodes[x].parent, v); \\\n    } \\\n  }\n#define pp_gen_unite_set(list) pp_gen_unite_set1 list\n#define pp_gen_unite_set1(name, val) \\\n  if (nodes[x].name == val) { \\\n    find_set_ ## name(x, find(y).name); \\\n  } \\\n  if (nodes[y].name == val) { \\\n    find_set_ ## name(y, find(x).name); \\\n  }\n\n#define def_unionfind(ufname, ufnodename, ...) \\\n  struct ufnodename { \\\n    int parent; \\\n    pp_foreach(pp_gen_field, __VA_ARGS__) \\\n  }; \\\n  struct ufname { \\\n    vector<ufnodename> nodes; \\\n    vector<int> rank; \\\n    ufname(int n) : nodes(n+1), rank(n+1) { \\\n      rep (i in n) { \\\n        nodes[i] = ufnodename{i pp_foreach(pp_gen_init, __VA_ARGS__)}; \\\n        rank[i] = 0; \\\n      } \\\n    } \\\n    ufnodename find(int x) { \\\n      if (nodes[x].parent == x) { \\\n        return nodes[x]; \\\n      } else { \\\n        return nodes[x] = find(nodes[x].parent); \\\n      } \\\n    } \\\n    pp_foreach(pp_gen_find_set_wrap(ufnodename), __VA_ARGS__) \\\n    void unite(int x, int y) { \\\n      x = find(x).parent; \\\n      y = find(y).parent; \\\n      if (x == y) return; \\\n      if (rank[x] < rank[y]) { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[x].parent = y; \\\n      } else { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[y].parent = x; \\\n        if (rank[x] == rank[y]) rank[x]++; \\\n      } \\\n    } \\\n    bool same(int x, int y) { \\\n      return find(x).parent == find(y).parent; \\\n    } \\\n  }\n\n//\n// Implementation\n//\n\nint main(){\n  int n,r,l;cin >> n >> r >> l;\n  vector<int> times(n,0),score(n,0),d(r),t(r),x(r);\n\n  function<int()> top_team = [&](){\n    return distance(score.begin(),max_element(all(score)));\n  };\n\n  rep(i in up(0, r)){\n    cin >> d[i] >> t[i] >> x[i];\n    if(i != 0)\n      times[top_team()] += t[i] - t[i - 1];\n\n    score[d[i] - 1] += x[i];\n  }\n\n  times[top_team()] += l - t[r - 1];\n\n  cout << distance(times.begin(),max_element(all(times))) + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 1000000\n#define MAX_TEAM 1000000\n\npriority_queue<pair<long long, long long>> Q;\nlong long d[MAX_TEAM], n, s, L, x[MAX_N], y[MAX_N], t[MAX_N], ti[MAX_TEAM], maxn, maxid;\n\nint main() {\n\tcin >> n >> s >> L;\n\tQ.push(make_pair(0, -10000000));\n\tx[0] = 1; t[0] = 0; y[0] = 0; x[s + 1] = 1; t[s + 1] = L; y[s + 1] = 0;\n\tfor (int i = 1; i <= s; i++) { cin >> x[i] >> t[i] >> y[i]; }\n\tfor (int i = 0; i <= s; i++) {\n\t\td[x[i]] += y[i];\n\t\tQ.push(make_pair(d[x[i]], -x[i]));\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>p = Q.top();\n\t\t\tif (p.first == d[-p.second]) {\n\t\t\t\tti[-p.second] += t[i + 1] - t[i]; break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (maxn < ti[i]) {\n\t\t\tmaxn = ti[i];\n\t\t\tmaxid = i;\n\t\t}\n\t}\n\tcout << maxid << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <functional>\n#include <climits>\nusing namespace std;\n#define pb emplace_back\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define show(...) fprintf(stderr, __VA_ARGS__)\n#define outl(x) cout << (x) << '\\n'\ntemplate<class A, class B>inline bool chmax(A &a, B b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, B b){return b<a ? a=b,1 : 0;}\ninline bool inside(int y, int x, int H, int W){return(y>=0 && x>=0 && y<H && x<W);}\ninline bool inside(int x, int W){ return (0 <= x && x < W); }\nconst int dx[] = {1, 0, -1, 0,  1, 1, -1, -1};\nconst int dy[] = {0, 1, 0, -1,  -1, 1, 1, -1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nstatic constexpr int INF = 0x3f3f3f3f;\n\nstruct Team {\n    int id, s;\n    explicit Team(int i=0, int sc=0): id(i), s(sc) {}\n    bool operator < (const Team &x) const {\n        return (s == x.s) ? (id >= x.id) : (s < x.s);\n    }\n    bool operator > (const Team &x) const {\n        return (s == x.s) ? (id <= x.id) : (s > x.s);\n    }\n};\n\nconst Team& max(const Team &a, const Team &b) {\n    return a > b ? a : b;\n}\n\n\nstruct SegTree\n{\n    vector<Team> dat;\n    int size;\n\n    SegTree(int n) {\n        for (size =1; size <= n; size *= 2);\n        dat.assign(size*2+5, Team(0, INT_MIN));\n    }\n\n    void update(int i, Team x) {\n        i += size -1;\n        dat[i] = x;\n        while (i > 0) {\n            i = (i-1)  /2;\n            dat[i] = max(dat[i*2+1], dat[i*2+2]);\n        }\n    }\n\n    const Team query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return Team(0, INT_MIN);\n        if (a <= l && r <= b) return dat[k];\n        int mid = (l + r) / 2;\n        return max(query(a, b, 2*k+1, l, mid), query(a, b, 2*k+2, mid, r));\n    }\n\n    const Team query(int a, int b) { return query(a, b, 0, 0, size); }\n\n    const Team& operator [] (int i) { return dat[i+size-1]; }\n\n};\n\n#define LIM 1000010\nint N, R, L;\nint timeSum[1000010];\nint d[LIM], t[LIM], x[LIM];\n\nsigned main()\n{\n    cin.tie(0), ios::sync_with_stdio(false);\n    cin >> N >> R >> L;\n    for (int i=1; i<=R; ++i) {\n        cin >> d[i] >> t[i] >> x[i];\n        --d[i];\n    }\n\n    t[0] = 0;\n    t[R+1] = L;\n    SegTree seg(N+1);\n    for (int i = 0; i < N; i++) {\n        seg.update(i, Team(i, 0));\n    }\n\n    for (int i=1; i<=R; ++i) {\n        Team top = seg.query(0, N);\n        timeSum[top.id] += t[i] - t[i-1];\n        seg.update(d[i], Team(d[i], seg[d[i]].s + x[i]));\n    }\n    Team top = seg.query(0, N);\n    timeSum[top.id] += t[R+1] - t[R];\n\n    /*\n    for (int i=0; i<N;++i) {\n        printf(\"timesum[%d] = %d   score = %d\\n\", i+1, timeSum[i], seg[i].s);\n    }\n    */\n\n    int maxpos = 0;\n    for (int i=1; i<N;++i) {\n        if (timeSum[maxpos] < timeSum[i]) {\n            maxpos = i;\n        }\n    }\n\n    outl(maxpos + 1);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<set>\n#include<algorithm>\nusing namespace std;\nint s[100000];\nint p[1000000];\nint q[1000000];\nint r[1000000];\nint ans[100000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tset<pair<int,int> >S;\n\tfor(int i=0;i<a;i++){\n\t\tS.insert(make_pair(0,i));\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d%d\",p+i,r+i,q+i);\n\t\tp[i]--;\n\t}\n\tint now=0;\n\tfor(int i=0;i<c;i++){\n\t\twhile(now<c&&r[now]==i){\n\t\t\tS.erase(make_pair(-s[p[now]],p[now]));\n\t\t\ts[p[now]]+=q[now];\n\t\t\tS.insert(make_pair(-s[p[now]],p[now]));\n\t\t\tnow++;\n\t\t}\n\t\tpair<int,int> M=*(S.begin());\n\t\tans[M.second]++;\n\t}\n\tint val=0;\n\tint at=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(val<ans[i]){\n\t\t\tval=ans[i];\n\t\t\tat=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",at+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nint INF=1<<28;\nstruct SegmentTree{\n\tvector<int> dat;\n\tvector<int> mi;\n\n\tint n,size;\n\tSegmentTree(int _n){\n\t\tn=Pow2Fit(_n)<<1;\n\t\tsize=2*n-1;\n\t\tdat=vector<int>(size,-INF);\n\t\tmi=vector<int>(size,INF);\n\t}\n\tint Pow2Fit(int n){\n\t\t  n = n | (n >>  1);n = n | (n >>  2);n = n | (n >>  4);n = n | (n >>  8);n = n | (n >> 16);\n\t\t  return n ^ (n >> 1);\n\t}\n\n\tvoid update(int v,int a){\n\t\tv+=n-1;\n\t\tdat[v]=a;\n\t\tmi[v]=v-(n-1);\n\t\tDUMP(a);\n\t\twhile(v>0){\n\t\t\tint parent=v=(v-1)/2;\n\t\t\tint chl=parent*2+1,chr=parent*2+2;\n\t\t\tif(dat[chl]>=dat[chr])mi[parent]=mi[chl];\t\t\t\t\n\t\t\telse mi[parent]=mi[chr];\n\t\t\tdat[parent]=max(dat[chl],dat[chr]);\n\t\t}\n\t}\n\n\tint query(int a,int b){\n\t\treturn query(0,a,b,0,n);\n\t}\n\n\tprivate:\n\tint query(int v,int a,int b,int l,int r){\n\t\tif(r<=a || b<=l)return -1;//out range\n\t\tif(a<=l && r<=b)return mi[v];\n\n\t\tint vl=query(v*2+1,a,b,l,(l+r)/2);\n\t\tint vr=query(v*2+2,a,b,(l+r)/2,r);\n\t\tDUMP(v);DUMP(l);DUMP(r);DUMP(vl);DUMP(vr);DUMP(BR);\n\t\tif(vl==-1)return vr;\n\t\tif(vr==-1)return vl;\n\n\t\tif(dat[vl+(n-1)]>=dat[vr+(n-1)])return vl;\n\t\telse return vr;\n\t}\n};\n\nclass Task{\n\tpublic:\n\tint d,t,x;\n\tTask(int d,int t,int x):d(d),t(t),x(x){\n\t}\n\n\tbool operator < (const Task& r) const {\n\t\treturn t< r.t;\n\t}\n};\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,R,L;cin >> N >> R >> L;\n\t\tvector<Task> ts;\n\t\tREP(i,R){\n\t\t\tint d,t,x;cin >> d >> t >> x;d--;\n\t\t\tts.push_back(Task(d,t,x));\n\t\t}\n\t\tsort(ALL(ts));\n\n\t\tvector<int> vs(N);\n\t\tSegmentTree seg(N);\n\t\tREP(i,N)seg.update(i,0);\n\n\t\tint pt=0;\n\t\tREP(i,R){\n\t\t\tvs[seg.query(0,N)]+=ts[i].t-pt;\n\t\t\tpt=ts[i].t;\n\t\t\tseg.update(ts[i].d,seg.dat[ts[i].d+(N-1)]+ts[i].x);\n\t\t}\n\t\tvs[seg.query(0,N)]+=L-pt;\n\n\t\tint Mv=0;\n\t\tREP(i,N){\n\t\t\tMv=max(Mv,vs[i]);\n\t\t}\n\t\tREP(i,N)if(Mv==vs[i]){\n\t\t\tcout <<i+1<<endl;return;\n\t\t}\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += t-oldt;\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n      if(pt[old]==pt[d]&&old>d) old = d; \n    }else if(old==d) old = max(pt,N);\n  }\n  ptime[old] += L- oldt;\n  cout << max(ptime,N) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nconst int MAX_N=1<<17;\nint n;\nint dat[2*MAX_N-1];\nint num[2*MAX_N-1];\n\nvoid Init(int n_){\n\tn=1;\n\twhile(n<n_) n*=2;\n\tfor(int i=0; i<2*n-1; ++i){\n\t\tif(n-1<=i){\n\t\t\tdat[i]=0;\n\t\t\tnum[i]=i;\n\t\t} else {\n\t\t\tdat[i]=INT_MIN;\n\t\t\tnum[i]=-1;\n\t\t}\n\t}\n}\n\nvoid Update(int k,int a){\n\tk+=n-1;\n\tdat[k]=a;\n\twhile(k>0){\n\t\t//dat[k]=max(dat[k*2+1],dat[k*2+2]);\n\t\tk=(k-1)/2;\n\t\tif(dat[k*2+1]>=dat[k*2+2]){\n\t\t\tdat[k]=dat[k*2+1];\n\t\t\tnum[k]=num[k*2+1];\n\t\t} else {\n\t\t\tdat[k]=dat[k*2+2];\n\t\t\tnum[k]=num[k*2+2];\n\t\t}\n\t}\n}\n\nPi Query(int a,int b,int k,int l,int r){\n\tif(r<=a||b<=l) return Pi(-1,INT_MIN);\n\tif(a<=l&&r<=b) return Pi(num[k],dat[k]);\n\telse {\n\t\tPi vl=Query(a,b,k*2+1,l,(l+r)/2);\n\t\tPi vr=Query(a,b,k*2+2,(l+r)/2,r);\n\t\tif(vl.S_>=vr.S_) return vl;\n\t\telse return vr;\n\t}\n}\n\nint main(){\n\tint N,R,L;\n\tcin >> N >> R >> L;\n\tInit(N);\n\tvector<int> t(N);\n\tPi tmp;\n\tREP(i,0,R){\n\t\tint D,T,X;\n\t\tcin >> D >> T >> X;\n\t\t--D;\n\t\tUpdate(D,dat[D+n-1]+X);\n\t\tPi p=Query(0,n,0,0,n);\n\t\tif(i!=0) t[tmp.F_]+=T-tmp.S_;\n\t\t//if(i!=0) cout << tmp.F_ << ' ' << T-tmp.S_ << endl;\n\t\ttmp.F_=p.F_-n+1;\n\t\ttmp.S_=T;\n\t\tif(i==R-1) t[tmp.F_]+=L-T;\n\t}\n\tint ans=-1,l=INT_MIN;\n\tREP(i,0,N){\n\t\tif(l<t[i]){\n\t\t\tans=i+1;\n\t\t\tl=t[i];\n\t\t}\n\t}\n\t/*\n\tREP(i,0,2*n-1){\n\t\tcout << i << ' ' << num[i] << ' ' << dat[i] << endl;\n\t}\n\tcout << endl;\n\t*/\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131072];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100000, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = i>=size-1?i-(size-1):0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            //std::cout << index << \",\" << seg1[index*2+1] << \",\" << seg1[index*2+2] << std::endl;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n                //std::cout << seg2[index] << std::endl;\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n        rs[i].d--;\n    }\n\n    int ts[MAX_N];\n    std::fill(ts, ts+N, 0);\n\n    if(R > 0){\n        int prev = rs[0].t;\n        st.update(rs[0].d, rs[0].x);\n        FOR(i, 1, R){\n            if(i+1 >= R || rs[i].t < rs[i+1].t){\n                //printf(\"wa-i: %d +%d\\n\", st.root().second, rs[i].t - prev);\n                ts[st.root().second] += rs[i].t - prev;\n            }\n            st.update(rs[i].d, rs[i].x);\n            prev = rs[i].t;\n        }\n        ts[st.root().second] += L - prev;\n    }\n\n    int max_team = 0, max_t = -1;\n    REP(i, N){\n        if(ts[i] > max_t){\n            max_team = i+1;\n            max_t = ts[i];\n        }\n    }   \n\n    //std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define PR pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0;\n#define int ll\n\n// Programming contest\n\nconst int MAX=1e5+10;\n\nsigned main(){\n  int N,R,L;\n  cin>>N>>R>>L;\n  \n  set<PR> teams;\n  int score[MAX];\n  int tele[MAX];\n  for(int i=0; i<N; i++){\n    teams.insert(mk(0,i+1));\n    score[i+1]=0;\n    tele[i+1]=0;\n  }\n  \n  int now_time=0;\n  for(int i=0; i<R; i++){\n    int team,time,s;\n    cin>>team>>time>>s;\n    PR M=*(teams.begin());\n    tele[M.second]+=time-now_time;\n    teams.erase(mk(-score[team],team));\n    teams.insert(mk(-score[team]-s,team));\n    score[team]+=s;\n    now_time=time;\n  }\n  PR M=*(teams.begin());\n  tele[M.second]+=L-now_time;\n\n  PR ans=mk(0,0);\n  for(int i=1; i<=N; i++){\n    if(ans.first<tele[i]){\n      ans.second=i;\n      ans.first=tele[i];\n    }\n  }\n  cout<<ans.second<<en\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconst int SIZE = 1 << 17;\nconst int INF = 1 << 30;\nusing namespace std;\nint segment[2 * SIZE];\nint point[SIZE + 1];\nint now, times[SIZE];\nint viewTime;\nint value(int ID){\n\treturn point[ID];\n}\nvoid compare(int n){\n\tint acces;\n\tif (value(segment[n * 2 + 1]) >= value(segment[n * 2 + 2]))\n\t\tacces = segment[n * 2 + 1];\n\telse\n\t\tacces = segment[n * 2 + 2];\n\tsegment[n] = acces;\n\tif (n != 0)\n\t\tcompare((n - 1) / 2);\n\n}\nvoid add(int n, int x){\n\tint acces = SIZE - 2 + n;\n\tpoint[n] += x;\n\tcompare((acces - 1) / 2);\n}\nint main() {\n\tint N, R, L, d, t, x,last=0;\n\tcin >> N >> R >> L;\n\tfor (int i = 1; i <= N; i++){\n\t\tsegment[SIZE + i - 2] = i;\n\t\tadd(i, 0);\n\t}\n\tfor (int i = 0; i<=R; i++){\n\t\tif (i!=R)\n\t\tcin >> d >> t >> x;\n\t\telse{\n\t\t\td = 1;\n\t\t\tt = L;\n\t\t\tx = 0;\n\t\t}\n\t\tif (t != last)\n\t\t\ttimes[segment[0]] += t - last;\n\t\tlast = t;\n\t\tadd(d, x);\n\t}\n\tint maxim =1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (times[maxim]<times[i])\n\t\t\tmaxim = i;\n\t}\n\tcout << maxim << endl;\n\t// your code goes here\n\tcin >> x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct T {\n  ll i, s;\n\n  bool operator<(const T& right) const {\n    return s == right.s ? i < right.s : s < right.s;\n  }\n};\n\nll MAX_N = 1 << 17;\nll n = 1;\nvector<T> dat(MAX_N * 2 - 1);\nT minT;\n\nvoid update(ll k, ll a) {\n  k = k + n - 1;\n  dat[k].s += a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nT query(ll a, ll b, ll k, ll l, ll r) {\n  if(r <= a || b <= l) return minT;\n  if(a <= l && r <= b) return dat[k];\n\n  T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n  return max(vl, vr);\n}\n\nint main() {\n  ll t, r, l, z = 0, zi = 0, sc[100001] = {};\n  cin >> t >> r >> l;\n  while(t > n) n *= 2;\n  rep(i, n - 1, n * 2 - 1) dat[i].i = i - (n - 1);\n  minT.i = 10000000;\n  minT.s = 0;\n\n\n  rep(i, 0, r) {\n    ll a, b, c;\n    cin >> a >> b >> c;\n    sc[zi] += b - z;\n    update(a - 1, c);\n    zi = dat[0].i;\n    z = b;\n  }\n\n  sc[zi] += l - z;\n  ll ms = 0, ans;\n  rep(i, 0, t) if(ms < sc[i]) ans = i + 1, ms = sc[i];\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1e9)\ntypedef pair<int, int> pii;\nconst int MAX_N = (1<<18);\n\nstruct RMQ {\n    int n;\n    pii dat[MAX_N];\n    void init(int n_)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2*n-1; i++) {\n            dat[i] = pii(-INF, -INF);\n        }\n\n        for (int i = 0; i < n_; i++) {\n            update(i, 0);\n        }\n    }\n\n    void update(int k, int a)\n    {\n        int nk = k;\n        k += n - 1;\n        dat[k] = pii(a, -nk);\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    pii query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l) return pii(-INF, -INF);\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            pii vl = query(a, b, k*2+1, l, (l + r) / 2);\n            pii vr = query(a, b, k*2+2, (l + r) / 2, r);\n            return max(vl, vr);\n        }\n    }    \n};\n\nint main()\n{\n    int N, R, L;\n    cin >> N >> R >> L;\n    int d, t, x, pt = 0;\n    int point[MAX_N] = {};\n    RMQ r;\n    r.init(N);\n    for (int i = 0; i < R; i++) {\n        cin >> d >> t >> x; d--;\n        point[-r.query(0, N, 0, 0, r.n).second] += t - pt;\n        r.update(d, x + r.dat[d + r.n - 1].first);\n        pt = t;\n    }\n    point[-r.query(0, N, 0, 0, r.n).second] += L - pt;\n    int mx = 0, num = -1;\n    for (int i = 0; i < N; i++) {\n        if (mx < point[i]) {\n            mx = point[i];\n            num = i+1;\n        }\n    }\n    cout << num << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n// pp basics\n\n#define in ,\n#define esc_paren(...) __VA_ARGS__\n#define pp_empty(...)\n#define pp_cat_i(x, y) x ## y\n#define pp_cat(x, y) pp_cat_i(x, y)\n\n#define pp_inc0 1\n#define pp_inc1 2\n#define pp_inc2 3\n#define pp_inc3 4\n#define pp_inc4 5\n#define pp_inc5 6\n#define pp_inc6 7\n#define pp_inc7 8\n#define pp_inc8 9\n#define pp_inc(i) pp_cat(pp_inc, i)\n\n// pp args counter\n\n#define pp_arg10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) _9\n#define pp_has_comma(...) pp_arg10(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 0)\n#define pp_trigger_paren(...) ,\n#define pp_is_empty(...) \\\n  pp_is_empty1( \\\n      pp_has_comma(__VA_ARGS__), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__), \\\n      pp_has_comma(__VA_ARGS__()), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__()) \\\n      ) \n#define pp_paste5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4\n#define pp_is_empty1(_0, _1, _2, _3) pp_has_comma(pp_paste5(pp_is_empty_case_, _0, _1, _2, _3))\n#define pp_is_empty_case_0001 ,\n\n#define pp_is_one(...) pp_is_one_(__VA_ARGS__, pp_one_seq)\n#define pp_is_one_(...) pp_is_one_n(__VA_ARGS__)\n#define pp_is_one_n(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10, N, ...) N\n#define pp_one_seq 0,0,0,0,0,0,0,0,0,1,0\n\n#define pp_narg(...) \\\n         pp_narg_(__VA_ARGS__, pp_narg_seq)\n#define pp_narg_(...) \\\n         pp_narg_n(__VA_ARGS__)\n#define pp_narg_n( \\\n          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\\n         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\\n         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\\n         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\\n         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\\n         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\\n         _61,_62,_63,n,...) n\n#define pp_narg_seq \\\n         63,62,61,60, \\\n         59,58,57,56,55,54,53,52,51,50, \\\n         49,48,47,46,45,44,43,42,41,40, \\\n         39,38,37,36,35,34,33,32,31,30, \\\n         29,28,27,26,25,24,23,22,21,20, \\\n         19,18,17,16,15,14,13,12,11,10, \\\n          9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n// pp if\n#define pp_if_0(x, y) y\n#define pp_if_1(x, y) x\n#define pp_if(cond, x, y) pp_cat(pp_if_, cond)(x, y)\n\n// pp foreach\n#define pp_foreach_i9(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i8(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i7(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i6(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i5(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i4(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i3(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i2(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i1(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i0(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i(i, f, ...) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach(f, ...) pp_foreach_i(0, f, __VA_ARGS__)\n\n// alternative rep macro\n#define rep(...) rep1(rep2, (__VA_ARGS__))\n#define rep1(X, A) X A\n#define rep2(i, ...) pp_if(pp_is_one(__VA_ARGS__), rep_len1(i, __VA_ARGS__), rep3(i, __VA_ARGS__))\n#define rep_len1(i, end, ...) for (int i = 0; i < end; i++)\n#define rep3(i, iter, ...) rep4(rep5, (iter, i, esc_paren __VA_ARGS__))\n#define rep4(X, A) X A\n#define rep5(iter, ...) iter(__VA_ARGS__)\n\n// iterators\n#define up up_iter ,\n#define up_iter3(i, start, end) for (int i = start; i < end; i++)\n#define up_iter4(i, start, end, up) for (int i = start; i < end; i += up)\n#define up_iter(...) pp_cat(up_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define down down_iter ,\n#define down_iter2(i, end) for(int i = end-1; i >= 0; i--)\n#define down_iter3(i, start, end) for (int i = end-1; i >= start; i--)\n#define down_iter4(i, start, end, down) for (int i = end-1; i >= start; i -= down)\n#define down_iter(...) pp_cat(down_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define viter viter_iter ,\n#define viter_iter(i, v) auto tmpitr=v.begin(); for (auto i=*tmpitr; tmpitr != v.end(); tmpitr++)\n\n// debug macros\n#define debug_var_elem(v) << #v << \"=\" << v << \" \"\n#ifdef DEBUG\n#define debug_echo(e) cout << \"L\" << __LINE__ << \": \" << e << endl\n#define debug_var(...) cout << \"L\" << __LINE__ << \": \" pp_foreach(debug_var_elem, __VA_ARGS__) << endl\n#define debug_ary(ary) cout << \"L\" << __LINE__ << \" [ \"; for(auto ele : ary) cout << ele << \" \"; cout << \"]\" << endl;\n#else\n#define debug_echo(e)\n#define debug_var(...)\n#define debug_ary(ary)\n#endif\n\n// short names\ntypedef long long ll;\n#define down_queue(x) priority_queue<x>\n#define up_queue(x) priority_queue<x, vector<x>, greater<x>>\nll gcd(ll a,ll b){while(b){ll tmp = a % b;a = b;b = tmp;}return a;}\nll lcm(ll a,ll b){return a / gcd(a,b) * b;}\n#define all(x) x.begin(), x.end()\n#define split_str(str, sp_word) istringstream stream(str); string res; for(int cnt = 0; getline(stream,res,sp_word); cnt++)\n#define digit(x) ((int)log10((double)(x)) + 1)\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\nvector<int> digit_split(int n){vector<int> result(digit(n));for(int i = 0; n; i++){result[i] = n % 10;n /= 10;}return result;}\n#define time(content) {auto start = clock();content;auto end = clock();cout << (double)(end - start) << \"ms\" << endl;} \n#define vec_cpy(to,from) copy(all(to),back_inserter(from))\n#define ary_cpy(to,from) memcpy(to, from, sizeof(from))\n#define MOD 1000000007 \n\n// pp unionfind\n#define pp_gen_field(list) pp_gen_field1 list\n#define pp_gen_field1(name, val) decltype(val) name;\n#define pp_gen_init(list) pp_gen_init1 list\n#define pp_gen_init1(name, val) ,val\n#define pp_gen_find_set_wrap(ufnodename) ufnodename pp_gen_find_set\n#define pp_gen_find_set(list) pp_gen_find_set1 list\n#define pp_gen_find_set1(name, val) \\\n  find_set_ ## name(int x, decltype(val) v) { \\\n    if (nodes[x].parent == x) { \\\n      nodes[x].name = v; \\\n      return nodes[x]; \\\n    } else { \\\n      return nodes[x] = find_set_ ## name(nodes[x].parent, v); \\\n    } \\\n  }\n#define pp_gen_unite_set(list) pp_gen_unite_set1 list\n#define pp_gen_unite_set1(name, val) \\\n  if (nodes[x].name == val) { \\\n    find_set_ ## name(x, find(y).name); \\\n  } \\\n  if (nodes[y].name == val) { \\\n    find_set_ ## name(y, find(x).name); \\\n  }\n\n#define def_unionfind(ufname, ufnodename, ...) \\\n  struct ufnodename { \\\n    int parent; \\\n    pp_foreach(pp_gen_field, __VA_ARGS__) \\\n  }; \\\n  struct ufname { \\\n    vector<ufnodename> nodes; \\\n    vector<int> rank; \\\n    ufname(int n) : nodes(n+1), rank(n+1) { \\\n      rep (i in n) { \\\n        nodes[i] = ufnodename{i pp_foreach(pp_gen_init, __VA_ARGS__)}; \\\n        rank[i] = 0; \\\n      } \\\n    } \\\n    ufnodename find(int x) { \\\n      if (nodes[x].parent == x) { \\\n        return nodes[x]; \\\n      } else { \\\n        return nodes[x] = find(nodes[x].parent); \\\n      } \\\n    } \\\n    pp_foreach(pp_gen_find_set_wrap(ufnodename), __VA_ARGS__) \\\n    void unite(int x, int y) { \\\n      x = find(x).parent; \\\n      y = find(y).parent; \\\n      if (x == y) return; \\\n      if (rank[x] < rank[y]) { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[x].parent = y; \\\n      } else { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[y].parent = x; \\\n        if (rank[x] == rank[y]) rank[x]++; \\\n      } \\\n    } \\\n    bool same(int x, int y) { \\\n      return find(x).parent == find(y).parent; \\\n    } \\\n  }\n\n//\n// Implementation\n//\n\nint main(){\n  int n,r,l;cin >> n >> r >> l;\n  vector<int> times(n,0),score(n,0),d(r),t(r),x(r);\n\n  function<int()> top_team = [&](){\n    return distance(score.begin(),max_element(all(score)));\n  };\n\n  rep(i in up(0, r)){\n    cin >> d[i] >> t[i] >> x[i];\n    if(i != 0){\n      if(t[i] == t[i - 1]) break;\n      times[top_team()] += t[i] - t[i - 1];\n    }\n    score[d[i] - 1] += x[i];\n    debug_var(x[i]);\n  }\n\n  score[d[r - 1] - 1] += x[r - 1];\n  times[top_team()] += l - t[r - 1];\n\n  debug_ary(times);\n  debug_ary(score);\n  cout << distance(times.begin(),max_element(all(times))) + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nconst int MAX_N = 1 << 17;\n\ntypedef pair<int, int> P;\n\nint n, cnt[MAX_N];\nP dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n = 1;\n  while(n < n_) n *= 2;\n  for(int i=0;i<2*n-1;i++) dat[i] = make_pair(INT_MAX, INT_MAX);\n}\n\nvoid update(int k, P a){\n  k += n - 1;\n  dat[k] = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k*2+1], dat[k*2+2]);\n  }\n}\n\n//min [a, b)\n//call query(a, b, 0, 0, n)\nP query(int a, int b, int k, int l, int r){\n  if(r <= a || b <= l) return make_pair(INT_MAX, INT_MAX);\n  if(a <= l && r <= b) return dat[k];\n  else{\n    P vl = query(a, b, k*2+1, l, (l+r)/2);\n    P vr = query(a, b, k*2+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n}\n\nint main(){\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\tmemset(cnt, 0, sizeof(cnt));\n\tinit(N);\n\tfor(int i=0;i<N;i++) update(i, make_pair(0, i));\n\tint T = 0;\n\tfor(int i=0;i<R;i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\td--;\n\t\tif(T != t){\n\t\t\tP tmp = query(0, N, 0, 0, n);\n\t\t\tcnt[tmp.second] += t - T;\n\t\t}\n\t\tP tmp = query(d, d + 1, 0, 0, n);\n\t\tupdate(d, make_pair(tmp.first - x, tmp.second));\n\t\tT = t;\n\t}\n\tif(T != L){\n\t\tP tmp = query(0, N, 0, 0, n);\n\t\tcnt[tmp.second] += L - T;\n\t}\n\tint valM = -1, id;\n\tfor(int i=0;i<N;i++){\n\t\tif(valM < cnt[i]){\n\t\t\tvalM = cnt[i];\n\t\t\tid = i;\n\t\t}\n\t}\n\tcout << id + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n#define N_MAX 100001\ntypedef pair<int,int> P;\n\nint main(){\n  int N,R,L;\n  int d,t,x;\n  int time[N_MAX]={0};\n  int score[N_MAX]={0};\n  cin >> N >> R >> L;\n  priority_queue<P> que;\n  for(int i=1;i<=N;i++){\n    que.push(P(0,N-i));\n  }\n  int now = 0;\n  for(int j=0;j<R;j++){\n    cin >> d >> t >> x;\n    P p1 = que.top();\n    while(score[N-p1.second] != p1.first){\n      que.pop();\n      p1 = que.top();\n    }\n    time[N-p1.second] += t - now;\n    now = t;\n    score[d] += x;\n    que.push(P(score[d],N-d));\n  }\n  P p1 = que.top();\n  while(score[N-p1.second] != p1.first){\n    que.pop();\n    p1 = que.top();\n  }\n  time[N-p1.second] += L - now;\n  priority_queue<P> que2;\n  for(int i=1;i<=N;i++){\n    que2.push(P(time[i],N-i));\n  }\n  p1 = que2.top();\n  cout << N - p1.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint now=0;\n\tint gap;\n\tint max,id;\n\tint team[100001]={0};\n\tint time[100001]={0};\n\n\tcin >> N >>R >> L;\n\n\tmax=team[1];\n\tid=1;\n\twhile(R--){\n\t\tcin >>d>>t>>x;\n\t\tgap=t-now;\n\t\tnow=t;\n\t\ttime[id]+=gap;\n\t\tteam[d]+=x;\n\t\tif(x>=0){\n\t\t\tif(max<team[d]){\n\t\t\t\tmax=team[d];\n\t\t\t\tid=d;\n\t\t\t}else if(max == team[d] && id > d){\n\t\t\t\tid=d;\n\t\t\t}\n\t\t}else{\n\t\t\tmax=team[1];\n\t\t\tid=1;\n\t\t\tfor(int i=2;i<=N;i++){\n\t\t\t\tif(max<team[i]){\n\t\t\t\t\tmax=team[i];\n\t\t\t\t\tid=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tgap=L-now;\n\ttime[id]+=gap;\n\n\tmax=time[1];\n\tid=1;\n\tfor(int i=2;i<=N;i++){\n\t\tif(max<time[i]){\n\t\t\tmax=time[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\tcout<<id<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint a[200005][2];\nint s[100005];\nint main(){\n\tint i,j,k;\n\tint n,r,l;\n\tint d=0;\n\tint t=0;\n\tint x=0;\n\tint nn=0;\n\tint f=0;\n\tmemset(a,0,sizeof(a));\n\tmemset(s,0,sizeof(s));\n\tcin>>n>>r>>l;\n\tnn=1;\n\twhile(nn<n){\n\t\tnn*=2;\n\t}\n\tnn--;\n\tfor(i=0;i<n;i++){\n\t\ta[nn+i][1]=i;\n\t}\n\td=nn;\n\twhile(d!=0){\n\t\td--;\n\t\tif(a[d*2+1][0]<a[d*2+2][0]){\n\t\t\ta[d][0]=a[d*2+2][0];\n\t\t\ta[d][1]=a[d*2+2][1];\n\t\t}else{\n\t\t\ta[d][0]=a[d*2+1][0];\n\t\t\ta[d][1]=a[d*2+1][1];\n\t\t}\n\t}\n\tfor(i=0;i<r;i++){\n\t\tcin>>d>>t>>x;  \n\t\ts[f]+=t;\n\t\td--;\n\t\td+=nn;\n\t\ta[d][0]+=x;\n\t\twhile(d!=0){\n\t\t\td=(d-1)/2;\n\t\t\tif(a[d*2+1][0]<a[d*2+2][0]){\n\t\t\t\ta[d][0]=a[d*2+2][0];\n\t\t\t\ta[d][1]=a[d*2+2][1];\n\t\t\t}else{\n\t\t\t\ta[d][0]=a[d*2+1][0];\n\t\t\t\ta[d][1]=a[d*2+1][1];\n\t\t\t}\n\t\t}\n\t\tf=a[0][1];\n\t\ts[f]-=t;\n\t}\n\ts[f]+=l;\n\tnn=0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[nn]<s[i])nn=i;\n\t}\n\tnn++;\n\tcout<<nn<<endl;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define INF (1 << 30)\n#define INFL (1LL << 62)\n#define MOD7 1000000007\n#define MOD9 1000000009\n#define EPS 1e-10\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pul pair<ull, ull>\n#define all(a) (a).begin(), (a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);--i)\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nvoid YES() { cout << \"YES\" << endl; }\nvoid NO() { cout << \"NO\" << endl; }\nvoid Yes() { cout << \"Yes\" << endl; }\nvoid No() { cout << \"No\" << endl; }\nvoid yes() { cout << \"yes\" << endl; }\nvoid no() { cout << \"no\" << endl; }\nvoid Taka() { cout << \"Takahashi\" << endl; }\nvoid Aoki() { cout << \"Aoki\" << endl; }\nvoid digit(int d) { cout << fixed << setprecision(d); }\nvoid IOup() { cin.tie(0); ios::sync_with_stdio(false); }\n\nclass RMQ {\n\tvector<pii> data;\n\tint size;\n\tint suffix;\n\npublic:\n\tRMQ() {}\n\tRMQ(int n) {\n\t\tsuffix = -1;\n\t\tresize(n);\n\t}\n\n\tvoid resize(int n) {\n\t\tsize = 1;\n\t\twhile (size < n) {\n\t\t\tsize <<= 1;\n\t\t}\n\t\tdata.resize(size * 2 - 1);\n\t\tfor (int i = n - 1; i < size * 2 - 1; ++i) {\n\t\t\tdata[i] = pii(0, i - (n - 1));\n\t\t}\n\t}\n\n\tpii& operator[](int i) {\n\t\tupdate();\n\t\tsuffix = i;\n\t\treturn data[i + size - 1];\n\t}\n\n\tvoid update() {\n\t\tif (suffix < 0)\n\t\t\treturn;\n\t\tint k = suffix + size - 1;\n\t\tsuffix = -1;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdata[k] = std::min(data[k * 2 + 1], data[k * 2 + 2]);\n\t\t}\n\t}\n\n\tpii min(int a, int b) {\n\t\tupdate();\n\t\tsuffix = -1;\n\t\treturn min(a, b, 0, 0, size);\n\t}\n\n\tpii min(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)\n\t\t\treturn pii(0, INF);\n\t\tif (a <= l && r <= b)\n\t\t\treturn data[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(min(a, b, k * 2 + 1, l, m), min(a, b, k * 2 + 2, m, r));\n\t}\n};\n\nint tt[100001];\n\nint main() {\n\tint n, r, l, d, b, t, x;\n\tcin >> n >> r >> l;\n\tRMQ p(n + 1);\n\t\n\tb = 0;\n\tfor (int i = 0; i < r; ++i) {\n\t\tcin >> d >> t >> x;\n\t\tauto tmp = p.min(1, n + 2);\n\t\ttt[tmp.second] += t - b;\n\t\tp[d].first -= x;\n\t\tb = t;\n\t}\n\ttt[p.min(1, n + 2).second] += l - b;\n\t\n\tint m = 0, ans;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (m < tt[i]) {\n\t\t\tm = tt[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\nconst int MAX_N = 1<<20;\n\nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = -INF;\n        dat[i].se = -(i-n+1);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(-INF, n-1);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nvector<pii> q[1000010];\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\trep(i, n) update(i, INF);\n\tvi v(n, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tq[t].pb(pii(d-1, x));\n\t\t//p = query(0, n, 0, 0, n);\n\t\t//cout<<-p.se<<endl;\n\t\t// v[-p.se] = t-tt;\n\t\t// tt = t;\n\t\t// update(d-1, x);\n\t}\n\trep(i, l+1){\n\t\trep(j, q[i].size()){\n\t\t\tupdate(q[i][j].fi, q[i][j].se);\n\t\t}\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se]++;\n\t\t//cout<<-p.se<<endl;\n\t}\n\t//p = query(0, n, 0, 0, n);\n\t//v[-p.se] = l-tt;\n\tint ans = 0;\n\tfor(int i = 1; i < v.size(); i++){\n\t\tif(v[ans] < v[i]) ans = i;\n\t}\n\t// rep(i, v.size()){\n\t// \tcout<<v[i]<<endl;\n\t// }\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint top_id(int *x,int N){\n  int top=x[1];\n  int id=1;\n  for(int i=2;i<=N;i++){\n    if(top<x[i]){\n      top = x[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint top_time(int *x,int N){\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<x[i]){\n      top_t = x[i];\n      ans = i;\n    }\n  }\n  return ans;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t[2],x;\n  int tim[N+1];\n  int total[N+1];\n  t[0] = 0;\n  for(int i=0;i<N;i++){\n    tim[i] = 0;\n    total[i] = 0;\n  }\n  for(int i=0;i<R;i++){\n    cin >> d >> t[1] >> x;\n    total[d] += x;\n    tim[top] += (t[1] - t[0]);\n    top = top_id(total,N);\n    t[0] = t[1];\n  }\n  tim[top] += (L - t[0]);\n  cout << top_time(tim,N) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point {\n  int x,y;\n  bool operator < (const Point& p) const {\n    if( y != p.y ) return y < p.y;\n    return x > p.x;\n  }\n};\nostream& operator << (ostream& os,const Point& p) {\n  os << p.x/* <<\" \"<< p.y*/;\n}\n\nint score[100001];\nint t[1000000];\nint time_[1000000];\nint main(){\n  priority_queue<Point> Q;\n  priority_queue<Point> T;\n  int N,R,L;\n  int d,x;\n  int dmy;\n  int a=1,b=0;\n\n  cin >>N>>R>>L;\n\n\n  for(int i=0;i<R;i++){\n    cin >>d>>t[i]>>x;    \n    score[d]+=x;\n    Q.push((Point){d,score[d]});  \n \n    while(score[Q.top().x] != Q.top().y){\n      Q.pop();\n    }\n    time_[a]+=t[i]-b; \n    T.push((Point){a,time_[a]});\n    a=Q.top().x;\n    b=t[i];\n    T.push((Point){a,time_[a]});\n    \n  }\n  \n  while(score[Q.top().x] != Q.top().y){\n    Q.pop();\n  }\n  time_[a]+=L-b;\n    a=Q.top().x;\n    b=L;\n    T.push((Point){a,time_[a]});\n \n  cout <<T.top()<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[200010];\nstruct node {\n    int id, point;\n} node[1<<21];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_SIZE (1 << 17)\n\nstruct team\n{\n    int num, score, time;\n    team *self;\n    bool operator<(const team& t) const\n    {\n        if (this->score < t.score) return true;\n        if (this->score == t.score && this->num > t.num) return true;\n        return false;\n    }\n};\n\nint n, r, l;\nteam teams[MAX_SIZE * 2 - 1];\n\nvoid init()\n{\n    int n_ = 1;\n\n    while (n_ < n) n_ *= 2;\n    for (int i = n; i < n_; i++){\n        teams[i + n_ - 1].score = INT_MIN;\n    }\n    n = n_;\n    for (int i = 0; i < n; i++){\n        teams[i + n - 1].num = i + 1;\n        teams[i + n - 1].self = teams + i + n - 1;\n    }\n    for (int i = n - 2; i >= 0; i--){\n        teams[i] = max(teams[i * 2 + 1], teams[i * 2 + 2]);\n    }\n#if 0\n    int t = 2;\n    for (int i = 0; i < n * 2 - 1; i++){\n        printf(\"%d:%d \", teams[i].num, teams[i].score);\n        if (i + 2 == t){\n            puts(\"\");\n            t *= 2;\n        }\n    }\n#endif\n}\n\nvoid update(int d, int t, int x)\n{\n    static int last;\n\n    teams[0].self->time += t - last;\n    last = t;\n\n    d += n - 2;\n    teams[d].score += x;\n    while (d > 0){\n        d = (d - 1) / 2;\n        teams[d] = max(teams[d * 2 + 1], teams[d * 2 + 2]);\n    }\n#if 0\n    t = 2;\n    for (int i = 0; i < n * 2 - 1; i++){\n        printf(\"%d:%d:%d \", teams[i].num, teams[i].score, teams[i].time);\n        if (i + 2 == t){\n            puts(\"\");\n            t *= 2;\n        }\n    }\n#endif\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &r, &l);\n    init();\n\n    for (int i = 0; i < r; i++){\n        int d, t, x;\n\n        scanf(\"%d %d %d\", &d, &t, &x);\n        update(d, t, x);\n    }\n    update(1, l, 0);\n\n    int maxi = 0;\n    for (int i = 1; i < n; i++){\n        if (teams[maxi + n - 1].time < teams[i + n - 1].time) maxi = i;\n    }\n    printf(\"%d\\n\", maxi + 1);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\npair<int,int> rmq[1111111111111];\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-1;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      team[smp-2] += t[i] - now;\n      if(t[i] != t[i+1]){ \n\tnow = t[i];\n      }\n    }\n    smp = rmq[0].second;\n  }\n  team[smp-2] += L - now;\n  int a=0;\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/11/05 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\n\tint P[100001] = {0};\n\tint W = 1;\n\n\tint T[100001] = {0};\n\tint tp = 0;\n\n\tfor(int i=0; i<R; i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\n\t\tT[W] += t-tp;\n\t\ttp = t;\n\n\t\tP[d] += x;\n\n\t\tif(x>=0){\n\t\t\tif(P[W]<P[d]){\n\t\t\t\tW = d;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tW = 1;\n\t\t\tfor(int j=2; j<=N; j++){\n\t\t\t\tif(P[W]<P[j]){\n\t\t\t\t\tW = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << W << ' ' << P[W] << endl;\n\t}\n\n\tT[W] += L-tp;\n\n\tint C = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(T[C]<T[i]){\n\t\t\tC = i;\n\t\t}\n\t}\n\tcout << C << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\ntypedef pair<int, int> iiP;\n\nint n;\niiP seg[2 * 100001 - 1];\n\nvoid init(int q){\n\n  n = 1;\n  while(n < q) n *= 2;\n\n  for(int i = 0; i < n; i++) seg[i] = iiP(-INF, -i);\n\n}\n\nvoid update(int i, iiP a){\n\n  i += n - 1;\n  seg[i] = a;\n\n  while(i > 0){\n    i = (i - 1) / 2;\n    seg[i] = max(seg[i * 2 + 1], seg[i * 2 + 2]);\n  }\n\n}\n\nint main(){\n\n  int N, R, L, d, t, x, prev;\n  int sumt[100001] = {0}, score[100001] = {0};\n  cin >> N >> R >> L;\n\n  init(N);\n  cin >> d >> t >> x;\n  sumt[1] += t, score[d] += x;\n  update(d, iiP(score[d], -d));\n  prev = t;\n  //  cout << \":\" << score[d] << \" \" << d << endl;\n  for(int i = 1; i < R; i++){\n    cin >> d >> t >> x;\n    iiP p = seg[0];\n    score[d] += x, sumt[-p.second] += t - prev;\n    prev = t;\n    //\\cout << \":\" << score[d] << \" \" << d << endl;\n    update(d, iiP(score[d], -d));\n     }\n     iiP p = seg[0];\n     //  cout << p.first << \" \" << -p.second << endl;\n     sumt[-p.second] += L - prev;\n\n     cout << max_element(sumt + 1, sumt + N + 1) - sumt << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define N_MAX 100001\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef pair<int, int> iP;\n\nint ts[N_MAX], sum[N_MAX];\n\nint main(){\n  \n  int N, R, L, d, t, x;\n  \n  cin >> N >> R >> L;\n  priority_queue<iP, vector<iP> > que;\n  \n  ts[0] = sum[0] = -INF;\n  que.push(iP(0, -1));\n  int pid = 1, pt = 0;\n  for(int i = 0; i < R; i++){\n    cin >> d >> t >> x;\n    sum[d] += x;\n    que.push(iP(sum[d], -d));\n    while(1){\n      iP p = que.top();\n      if(p.fr == sum[-p.second]){\n\tts[pid] += t - pt;\n\tpt = t;\n\tpid = -p.sc;\n\tbreak;\n      }\n      que.pop();\n    }\n  }\n  ts[pid] += L - pt;\n  \n  cout << max_element(ts+1, ts+N+1) - ts << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define scanf_s scanf\n#include<stdio.h>\n#include<algorithm>\n#include <list>\nint main(void) {\n\tint n, r, l, nn[100000] = { 0 }, mm[100000] = { 0 }, max = -1000, bt = 0;\n\tscanf_s(\"%d %d %d\", &n, &r, &l);\n\tfor (int i = 0; i < r; ++i) {\n\t\tint d, t, x;\n\t\tscanf_s(\"%d %d %d\", &d, &t, &x);\n\t\tmm[d - 1] += x;\n\t\tif (i == 0 || mm[max] <= mm[d - 1]) {\n\t\t\tif (i != 0 && mm[max] < mm[d - 1]) {\n\t\t\t\tmax = d - 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (max > d - 1) {\n\t\t\t\t\tmax = d - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnn[max] += t - bt;\n\t\tbt = t;\n\t}\n\tstd::sort(nn, nn + n);\n\tprintf(\"%d\\n\", nn[n - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -11111111\n#define MAX 11111111\ntypedef pair<int,int> P;\nint n;\nP dat[8*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[4*100012];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  dat[0] = P(MIN,1);\n  int d,t,x,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[dat[0].second].first+=t-bt;\n    update(d,x);\n    bt=t;\n  }\n  tim[dat[0].second].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[n];\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,0);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    \n    priority_queue<Team> que;\n    \n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams);\n\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      seg_tree.insert(id,point);\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += time - prev_time;\n\tprev_time = time;\n\tprev_champ = team.id;\n      }\n    }\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -11111111\n#define MAX 11111111\ntypedef pair<int,int> P;\nint n;\nP dat[8*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[4*100012];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  \n  int d,t,x,top=0,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[top].first+=t-bt;\n    update(d,x);\n    top=dat[0].second;\n    bt=t;\n  }\n  tim[top].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define min_3(a,b,c) min(a,min(b,c))\n\nint SEG[400010];\nint siz;\n\nvoid init(int x){\n\tsiz=1;\n\twhile(siz<x)siz*=2;\n\t\n\trep(i,siz*2-1){\n\t\tSEG[i]=0;\n\t}\n}\n\nvoid add(int k,int x){\n\tk+=siz-1;\n\tSEG[k]+=x;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tSEG[k]=max(SEG[2*k+1],SEG[2*k+2]);\n\t}\n}\n\nint query(int l,int r,int k){\n\tif(l==r-1)return l;\n\tif(SEG[2*k+1]>=SEG[k])return query(l,(l+r)/2,2*k+1);\n\treturn query((l+r)/2,r,2*k+2);\n}\n\nint main(){\n\tint n,r,l;\n\tcin>>n>>r>>l;\n\t\n\tinit(n);\n\t\n\tstatic int ret[100010]={0};\n\t\n\tint T=0;\n\trep(i,r){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x; d--;\n\t\t\n\t\tif(t>T){\n\t\t\tret[query(0,siz,0)]+=t-T; \n\t\t\tT=t;\n\t\t}\n\t\t\n\t\tadd(d,x);\n\t}\n\tret[query(0,siz,0)]+=l-T;\n\t\n\tint RET=0,MAX=0;\n\t\n\trep(i,n){\n\t\tif(MAX<ret[i]){ RET=i; MAX=ret[i]; }\n\t}\n\t\n\tcout<<RET+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<30;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -INF);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tteam[k] = P(a, k - n + 1);\n\t\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[d + n - 2].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[team[0].second] += (l - t);\n\t\n\tint rank[100010] = {0};\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i){\n\t\tif(rank[i] == p[0]){\n\t\t\tcout << i + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\nint N, R, T;\npriority_queue<pair<int, int>> pq;\nint score[1000000], total_time[1000000];\nint beforetime = 0, nowteam = 0;\n\nint main() {\n\tcin >> N >> R >> T;\n\tfor (int i = 0; i < N; i++)pq.push(make_pair(0, -i));\n\tfor (int i = 0; i < R; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tscore[a - 1] += c;\n\t\tpq.push(make_pair(score[a - 1], -(a - 1)));\n\n\t\twhile (1) {\n\t\t\tif (pq.top().first == score[-pq.top().second]) {\n\t\t\t\t//????????¢????????´???????????§?????????\n\t\t\t\t//pq.top().second???pq???????§?????????????????????????\n\t\t\t\t//????????§????????¢??¨?????´????????????????????????????????????????????????(????????¢???????°????????????????????????????)\n\t\t\t\t//?????§???????????????????????????????¬???§??´??°??????????????¨?????????????????´??°???????????????\n\t\t\t\ttotal_time[nowteam] += (b - beforetime);\n\t\t\t\tbeforetime = b;\n\t\t\t\tnowteam = -pq.top().second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t}\n\ttotal_time[nowteam] += (T - beforetime);\n\tfor (int i = 0; i < N; i++)cout << total_time[i] << \" \";\n\tcout << endl;\n\tcout << (max_element(total_time, total_time + N) - total_time) + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<limits.h>\nusing namespace std;\n#define max fahjkfhkahfsj\ntypedef pair<long long int,long long int> P;\nlong long int team[100001],ten[100001];\npriority_queue<P> qu;\nint main(void){\n\tlong long int n,r,l,i,m,mm,d,t,x,ans,max;\n\tP ppp;\n\tcin>>n>>r>>l;\n\tfor(i=1;i<=n;i++){\n\t\tteam[i]=0;\n\t\tten[i]=0;\n\t}\n\tcin>>d>>t>>x;\n\tten[d]+=x;\n\tqu.push(P(ten[d],d*-1));\n\tm=t; mm=d; max=LONG_MIN;\n\tfor(i=1;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\tppp=qu.top();\n\t\tif(ppp.second==d){\n\t\t\twhile(ppp.second==d){\n\t\t\t\tif(ppp.second!=ten[d]){\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tppp=qu.top();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tten[d]+=x;\n\t\tqu.push(P(ten[d],d*-1));\n\t\tppp=qu.top();\n\t\tif(ppp.first!=ten[mm]){\n\t\t\tteam[mm]+=t-m;\n\t\t\tif(max<team[mm]){\n\t\t\t\tmax=team[mm];\n\t\t\t\tans=mm;\n\t\t\t}\n\t\t\tm=t; mm=d;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int size = 1 << 17;\nint segval[1 << 18], segid[1 << 18];\nvoid init(){\n\tfor (int i = 0; i < size; i++) segid[i + size - 1] = i;\n}\nvoid update(int i, int x){\n\tint k = i + size - 1;\n\tsegval[k] += x;\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\tint t = segval[k * 2 + 1] >= segval[k * 2 + 2] ? k * 2 + 1 : k * 2 + 2;\n\t\tsegval[k] = segval[t];\n\t\tsegid[k] = segid[t];\n\t}\n}\nint get(){\n\treturn segid[0];\n}\n\nint n, r, l;\nint d[1000002], t[1000002], x[1000002];\nint a[100000];\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &r, &l);\n\tinit();\n\tfor (int i = 1; i <= r; i++){\n\t\tscanf(\"%d %d %d\", d + i, t + i, x + i);\n\t}\n\tt[r + 1] = l;\n\t\n\tfor (int i = 1; i <= r + 1; i++){\n\t\ta[get()] += t[i] - t[i - 1];\n\t\tupdate(d[i] - 1, x[i]);\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (a[res] < a[i]) res = i;\n\t}\n\tprintf(\"%d\\n\", res + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\n\nconst int INF = 1<<29;\ntypedef pair<int, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -INF);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tteam[k] = P(a, k - n + 1);\n\t\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tint p[100010] = {0};\n    for(int i = 0; i < 100010; ++i)\n        p[i] = -INF;\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n    for(int i = 0; i < m; ++i){\n\t\tupdate(i, 0);\n        p[i] = 0;\n    }\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[d + n - 2].first + x);\n\t\tprev = t;\n\t}\n\tp[team[0].second] += (l - prev);\n\n\tint ans_max = -INF, ans;\n\tfor(int i = 0; i < m; ++i){\n\t\tif(ans_max < p[i]){\n            ans = i + 1;\n            ans_max = p[i];\n        }\t\n\t}\n    cout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n// Begin Headelr {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// }}} End Header\n\nconstexpr int dy[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\nconst auto inside = [](int y, int x, int H, int W) -> bool {\n    return (y >= 0 && x >= 0 && y < H && x < W);\n};\n\n// SegmentTree {{{\ntemplate <class Monoid>\nstruct SegmentTree {\n    using Func = function<Monoid(Monoid, Monoid)>;\n    const size_t sz;\n    const Func fn;\n    const Monoid unity;\n    vector<Monoid> seg;\n\n    SegmentTree(const size_t n, const Monoid &u, Func f)\n        : sz(1 << (__lg(n + 5) + 1)), fn(f), unity(u), seg(sz * 2, unity) {}\n\n    void set(size_t k, const Monoid &v) {\n        seg[k + sz] = v;\n    }\n\n    Monoid& operator[](size_t k) {\n        return seg[k + sz];\n    }\n    const Monoid& operator[](size_t k) const {\n        return seg[k + sz];\n    }\n\n    void build() {\n        for (size_t k = sz - 1; k > 0; --k) {\n            seg[k] = fn(seg[2 * k], seg[2 * k + 1]);\n        }\n    }\n\n    void update(size_t k, const Monoid &x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = fn(seg[2 * k], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(size_t a, size_t b) const {\n        Monoid L = unity, R = unity;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = fn(L, seg[a++]);\n            if (b & 1) R = fn(seg[--b], R);\n        }\n        return fn(L, R);\n    }\n};\n// }}}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n    var(intmax_t, N, R, L);\n    vector<intmax_t> res(N);\n    // {得点, インデックス}\n    SegmentTree<pair<intmax_t, intmax_t>> sg(N, {0, 0}, [](auto a, auto b) {\n        if (a.first > b.first) {\n            return a;\n        } else if (b.first > a.first) {\n            return b;\n        } else {\n            if (a.second < b.second) return a;\n            else return b;\n        }\n    });\n    rep(i, 0, N) sg.set(i, {0, i});\n    sg.build();\n    intmax_t pre = 0, cur = 0;\n    rep(i, 0, R) {\n        var(intmax_t, d, t, x);\n        d--;\n        sg.update(d, {sg[d].first + x, d});\n        res[cur] += t - pre;\n        pre = t;\n        cur = sg.query(0, N).second;\n    }\n    res[cur] += L - pre;\n    intmax_t maxv = *max_element(all(res));\n    rep(i, 0, N) {\n        if (res[i] == maxv) {\n            return output(i + 1), 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct node {\n\tint id, score;\n};\nbool operator<(node a, node b) {\n\tif (a.score == b.score)return a.id > b.id;\n\treturn a.score < b.score;\n}\nint s[100000], cnt[100000];\nint d[1000000], t[1000000], x[1000000];\nint main() {\n\tint n, r, l; scanf(\"%d%d%d\", &n, &r, &l);\n\tpriority_queue<node>que, ans;\n\trep(i, r)scanf(\"%d%d%d\", &d[i], &t[i], &x[i]);\n\trep(i, r) {\n\t\td[i]--;\n\t\ts[d[i]] += x[i];\n\t\tque.push({ d[i],s[d[i]] });\n\t\twhile (!que.empty() && que.top().score != s[que.top().id])que.pop();\n\t\tif (i == r - 1) {\n\t\t\tcnt[que.top().id] += l - t[i];\n\t\t\tans.push({ que.top().id,cnt[que.top().id] });\n\t\t}\n\t\telse {\n\t\t\tcnt[que.top().id] += t[i + 1] - t[i];\n\t\t\tans.push({ que.top().id,cnt[que.top().id] });\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.top().id + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\nstruct Point{\n  int score,player;\n\n  bool operator < (const Point& p) const {\n    if( score != p.score ) return score < p.score;\n    return player > p.player;\n  }\n};\n\n/*\n  ostream& operator << (ostream& os,const Point& p) {\n  os << \"(\" << p.score << \",\" << p.player <<\")\";\n}\n*/\nint main(){\n  \n  int N,R,L;\n  int d,t,x;\n  priority_queue<Point> PQ;\n  priority_queue<Point> PQ2;\n  int score_sum[100001],time_sum[100001];\n  int data[3]={1,0,0};\n  \n  cin >>N>>R>>L;\n  \n  for(int i=0 ; i < 100001 ; i++){\n    score_sum[i]=0;\n    time_sum[i]=0;\n  }\n  \n  for(int i=1 ; i <= R ; i++){\n    \n    cin >>d>>t>>x;\n    \n    PQ.push((Point){score_sum[data[0]],data[0]});\n    \n    score_sum[d]+=x;\n    \n    while(1){\n      if(PQ.top().score == score_sum[PQ.top().player]){\n\ttime_sum[PQ.top().player]+=t-data[1];\n\tbreak;\n      }else{\n\tPQ.pop();\n      }\n    }  \n    PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n    \n    data[0]=d;data[1]=t;data[2]=x;  \n  }\n  PQ.push((Point){score_sum[data[0]],data[0]});\n  while(1){\n    if(PQ.top().score == score_sum[PQ.top().player]){\n      time_sum[PQ.top().player]+=L-data[1];\n      break;\n    }else{\n      PQ.pop();\n    }\n  }\n  while( PQ.empty() );\n  PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n  \n  cout <<PQ2.top().player<<endl;\n  \n  //cout <<PQ2.top().score<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tvi v(n + 100, 0);\n\tinit(n);\n\tint d, t, x, tt = 0;\n\tpii p;\n\tupdate(0, 0);\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += (t-oldt);\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n    }else old = max(pt,N);\n  }\n  ptime[old] += (L-t);\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<ll, ll>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T> //Maximum\nstruct RMQ\n{\n  private:\n    int N = 1;\n    vector<T> node;\n\n  public:\n    RMQ(vector<T> vec)\n    {\n        int size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, make_pair(-llINF, 0));\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return P(-llINF, llINF);\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, R, L;\n    cin >> N >> R >> L;\n\n    vector<P> vec(N);\n\n    vector<ll> time(N, 0);\n\n    REP(i, N)\n    {\n        vec[i] = make_pair(0, -i);\n    }\n\n    RMQ<P> rmq(vec);\n\n    vector<int> d(R), t(R), x(R);\n\n    REP(i, R)\n    {\n        cin >> d[i] >> t[i] >> x[i];\n    }\n\n    t.push_back(L);\n\n    time[0] = t[0];\n\n    REP(i, R)\n    {\n        P pre = rmq.getMax(d[i] - 1, d[i]);\n        rmq.update(d[i] - 1, make_pair(pre.fi + x[i], pre.se));\n        P team = rmq.getMax(0, N);\n\n        time[-team.se] += (t[i + 1] - t[i]);        \n    }\n\n    int ans = 0;\n    ll Max = 0;\n\n    REP(i, N)\n    {\n        if(Max < time[i])\n        {\n            ans = i;\n            Max = time[i];\n        }\n    }\n\n    cout << ans + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint p[1000005];\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<int> dat,id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(2*n-1);\n\t\trep(i,2*n-1) dat[i] = -1;\n\n\t\tid.resize(2*n-1);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] = a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid show()\n\t{\n\t\trep(i,2*n-1)\n\t\t{\n\t\t\tif(dat[i] == -1) cout << \"X \";\n\t\t\telse cout << dat[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\t//time id,point\n\tmap<int,vector<pair<int,int> > > m;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tm[t].push_back(make_pair(d,x));\n\t}\n\n\tvector<int> v(n+1);\n\tmemset(p,0,sizeof(p));\n\tSeg seg(n);\n\n\tint top_id = 0,top_p = 0,pre_time = 0;\n\tmap<int,vector<pair<int,int> > >::iterator ite;\n\tfor(ite = m.begin(); ite != m.end(); ite++)\n\t{\n\t\tint d,t,x;\n\t\tt = ite->first;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\trep(i,m[t].size())\n\t\t{\n\t\t\td = m[t][i].first;\n\t\t\tx = m[t][i].second;\n\n\t\t\tp[d] += x;\n\t\t\tseg.update(d-1,p[d]);\n\t\t\ttop_id = seg.id[0];\n\t\t}\n\n\t}\n\n\tv[top_id] += l - pre_time;\n\n\tint res = 0;\n\trep(i,n)\n\t{\n\t\tres = max(res,v[i]);\n\t}\n\n\trep(i,n)\n\t{\n\t\tif(res == v[i])\n\t\t{\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tpriority_queue<pii> pq;\n\tint n, r, l, d, t, x, u = 0;\n\tscanf(\"%d%d%d\", &n, &r, &l);\n\tvector<int> s(n + 1), c(n + 1);\n\tfor(int i = 1; i <= n; ++i){\n\t\tpq.push(pii(0, ~i));\n\t}\n\tfor(int i = 0; ; ++i){\n\t\tif(i == r){\n\t\t\tt = l;\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\t}\n\t\twhile(1){\n\t\t\tif(s[~pq.top().second] == pq.top().first){\n\t\t\t\tc[~pq.top().second] += t - u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t\tif(i == r){\n\t\t\tbreak;\n\t\t}\n\t\ts[d] += x;\n\t\tpq.push(pii(s[d], ~d));\n\t\tu = t;\n\t}\n\tint ans = max_element(c.begin(), c.end()) - c.begin();\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint top_id(int *x,int N){\n  int top=x[1];\n  int id=1;\n  for(int i=2;i<=N;i++){\n    if(top<x[i]){\n      top = x[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t,x;\n  int oldt=0;\n  int tim[N+1];\n  int total[N+1];\n  t[0] = 0;\n  for(int i=0;i<=N;i++){\n    tim[i] = 0;\n    total[i] = 0;\n  }\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    tim[top] += (t - oldt);\n    oldt = t;\n    total[d] += x;\n    top = top_id(total,N)\n  }\n  tim[top] += (L - t[0]);\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<tim[i]){\n      top_t = tim[i];\n      ans = i;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][100],T=0,g,p[2][100],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;//first=point second=num||first=time second=num\nint N,r,l;\nint d,t,x;\nint n;\nP team[100005];\nP Seg[100005*2];\nP Ttime[100005];\nint top=0;\nint btop=0;\nint smin=-1;\nint btime=0;\nP Pmax(P a,P b);\nvoid init(int n_);\nvoid update(int k,int a);\nP query(int a,int b,int k,int l,int r);\nmain(){\n  cin>>N>>r>>l;\n  for(int i=0;i<100005;i++){\n    team[i].F=0;\n    team[i].S=i+1;\n    Ttime[i].F=0;\n    Ttime[i].S=-(i+1);\n  }\n  init(N);\n  for(int i=0;i<r;i++){\n    cin>>d>>t>>x;\n    Ttime[top].F+=t-btop;\n    update(d-1,x);\n    /*\n    for(int i=n-1;i<2*n-1;i++){\n      cout<<\"|\"<<Seg[i].F<<\"|\"<<Seg[i].S<<\"| \";\n    }\n    */\n    //cout<<endl;\n    P tops;\n    tops=query(0,n-1,0,0,n);\n    top=tops.S;\n    btop=t;\n    int a=1;\n  }\n  Ttime[top].F+=l-btop;\n  sort(Ttime,Ttime+N);\n  /*\n  for(int i=0;i<N;i++){\n    cout<<Ttime[i].F<<\"|\"<<Ttime[i].S<<\" \";\n  }\n  */\n  //cout<<endl;\n  cout<<-Ttime[N-1].second<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    Seg[i]=P(0,0);\n  }\n  for(int i=n-1;i<2*n-1;i++){\n    Seg[i].S=i-(n-1);\n  }\n  return;\n}\nvoid update(int k,int a){\n  k+=n-1;\n  Seg[k].F+=a;\n  if(Seg[k].F<smin){\n    smin=Seg[k].F;\n  }\n  while(k>0){\n    k=(k-1)/2;\n    Seg[k]=Pmax(Seg[k*2+1],Seg[k*2+2]);\n  }\n\n  return;\n}\nP Pmax(P a,P b){\n  if(a.F>b.F||(a.F==b.F&&a.S<b.S)){\n    return a;\n  }\n  else{\n    return b;\n  }\n}\nP query(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l){\n    return P(smin,100010);\n  }\n  if(a<=l&&r<=b){\n    return Seg[k];\n  }\n  else{\n    P vl=query(a,b,k*2+1,l,(l+r)/2);\n    P vr=query(a,b,k*2+2,(l+r)/2,r);\n    return Pmax(vl,vr);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\npair<int,int> rmq[1111111];\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-1;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      team[smp-2] += t[i] - now;\n      if(t[i] == t[i+1]){ \n\tnow = t[i];\n      }\n    }\n    smp = rmq[0].second;\n  }\n  team[smp-2] += L - now;\n  int a=0;\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nstruct MaxSegTree{\n    int n; vector<pi> dat;\n    //?????????\n    MaxSegTree(int _n){\n        n=1;\n        while(n<_n) n*=2;\n        dat=vector<pi>(2*n-1);\n    }\n    //k??????(0-indexed)???????????´??°\n    void init(int k){\n        int id=k;\n        k+=n-1;\n        dat[k]=pi(0,-id);\n        //??´??°\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=max(dat[2*k+1],dat[2*k+2]);\n        }\n    }\n    //k??????(0-indexed)?????????+a\n    void add(int k, int a){\n        k+=n-1;\n        dat[k].fi+=a;\n        //??´??°\n        while(k>0){\n            k=(k-1)/2;\n            dat[k]=max(dat[2*k+1],dat[2*k+2]);\n        }\n    }\n    //?????¨??????????????????????????¨???\n    pi _query(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l) return pi(-1200000000,0);\n\n        if(a<=l && r<=b) return dat[k];\n        else{\n            pi vl=_query(a,b,2*k+1,l,(l+r)/2);\n            pi vr=_query(a,b,2*k+2,(l+r)/2,r);\n            return max(vl,vr);\n        }\n    }\n    //[a,b)????????§???????±???????\n    pi query(int a, int b){\n        return _query(a,b,0,0,n);\n    }\n};\n\nint main()\n{\n    int n,R,L;\n    scanf(\" %d %d %d\", &n, &R, &L);\n\n    MaxSegTree st(n);\n    rep(i,n) st.init(i);\n\n    vector<int> a(n,0);\n    int T=0;\n    while(R--)\n    {\n        int d,t,x;\n        scanf(\" %d %d %d\", &d, &t, &x);\n        --d;\n\n        pi m=st.query(0,n);\n        int id=-m.se;\n        a[id]+=t-T;\n        T=t;\n\n        st.add(d,x);\n    }\n    pi m = st.query(0,n);\n    int id = -m.se;\n    a[id]+=L-T;\n\n    int ans=-1;\n    int maxT=0;\n    rep(i,n)\n    {\n        if(maxT<a[i])\n        {\n            maxT=a[i];\n            ans=i+1;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[132510];\nstruct node {\n    int id, point;\n} node[1<<18];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point {\n  int x,y;\n  bool operator < (const Point& p) const {\n    if( y != p.y ) return y < p.y;\n    return x > p.x;\n  }\n};\nostream& operator << (ostream& os,const Point& p) {\n  os << p.x <<\" \"<< p.y;\n}\n\nint score[100001];\nint t[1000000];\nint time_[1000000];\nint main(){\n  priority_queue<Point> Q;\n  priority_queue<Point> T;\n  int N,R,L;\n  int d,x;\n  int a=1,b=0;\n\n  cin >>N>>R>>L;\n\n\n  for(int i=0;i<R;i++){\n    cin >>d>>t[i]>>x;    \n    score[d]+=x;\n    Q.push((Point){d,score[d]});  \n    while(!Q.empty() && score[Q.top().x] != Q.top().y){\n      Q.pop();\n    }\n    time_[a]+=t[i]-b; \n    T.push((Point){a,time_[a]});\n    a=Q.top().x;\n    b=t[i];\n    //time_[a]+=t[i]-b;\n    \n  }\n  \n  while( !Q.empty() && score[Q.top().x] != Q.top().y){\n    Q.pop();\n  }\n  time_[a]+=L-b;\n  if( !Q.empty() ) a=Q.top().x;\n  else a = 1;\n  b=L;\n  T.push((Point){a,time_[a]});\n \n  cout <<T.top().x<<endl;\n\n  while( !T.empty() ){\n    //cout <<T.top()<<endl;\n    T.pop();\n  }\n  return 0;\n}\n\n\n\n    \n\n\t    \n\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_N+1];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n    }\n\n    int prev = 0, ts[MAX_N+1];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R){\n        if(i+1 >= N || rs[i].t < rs[i+1].t){\n            ts[st.root().second] += rs[i].t - prev;\n            prev = rs[i].t;\n        }\n        st.update(rs[i].d, rs[i].x);\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = 0;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\nstruct Point{\n  int score,player;\n\n  bool operator < (const Point& p) const {\n    if( score != p.score ) return score < p.score;\n    return player > p.player;\n  }\n};\n\n/*\n  ostream& operator << (ostream& os,const Point& p) {\n  os << \"(\" << p.score << \",\" << p.player <<\")\";\n}\n*/\nint main(){\n  \n  int N,R,L;\n  int d,t,x;\n  priority_queue<Point> PQ;\n  priority_queue<Point> PQ2;\n  int score_sum[100001],time_sum[100001];\n  int data[3]={1,0,0};\n  \n  cin >>N>>R>>L;\n  \n  for(int i=0 ; i < 100001 ; i++){\n    score_sum[i]=0;\n    time_sum[i]=0;\n  }\n\n  for(int i=1 ; i <= R ; i++){\n    \n    cin >>d>>t>>x;\n    \n    PQ.push((Point){score_sum[data[0]],data[0]});\n    \n    while(1){\n      if(!PQ.empty() && PQ.top().score == score_sum[PQ.top().player]){\n\ttime_sum[PQ.top().player]+=t-data[1];\n\tbreak;\n      }else{\n\tassert( PQ.size() );\n\tPQ.pop();\n      }\n    }  \n    PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n  \n    score_sum[d]+=x;  \n    data[0]=d;data[1]=t;data[2]=x;  \n  }\n\n  PQ.push((Point){score_sum[data[0]],data[0]});\n  while(1){\n    if(!PQ.empty() && PQ.top().score == score_sum[PQ.top().player]){\n      time_sum[PQ.top().player]+=L-data[1];\n      break;\n    }else{\n      assert( !PQ.empty() );\n      PQ.pop();\n    }\n  }\n  //cout << PQ.size() << \" \" << PQ.top().player << endl;\n  PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n  \n\n  cout <<PQ2.top().player<<endl;\n  //cout <<PQ2.top().score<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> p;\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\np rmq[1111111];\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-1;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      team[smp-2] += t[i] - now;\n      if(t[i] != t[i+1]){ \n\tnow = t[i];\n      }\n    }\n    smp = rmq[0].second;\n  }\n  team[smp-2] += L - now;\n  int a=0;\n  int ans=1;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct dat{ int id, point; };\n#define MAX_N 100000\n\nint N, R, L;\nint res[MAX_N + 1];\ndat seg[MAX_N * 2 + 10];\nint n;\n\nvoid init(){\n\tn = 1;\n\twhile(n < N) n *= 2;//nはseg木の要素数\n\tn *= 2;\n\tfor(int i = 0; i < n; i++) seg[i].point = 0;\n\tn /= 2 * 2;\n\tfor(int j = 1; j <= N; j++){\n\t\tseg[n + j].id = j;\n\t}\n}\n\nvoid add(int p, int x){\n\tp += n;\n\tseg[p].point += x;\n\twhile(p > 0){\n\t\t//printf(\"p = %d\\n\", p);\n\t\tp = (p - 1) / 2;\n\t\tif(seg[p * 2 + 1].point >= seg[p * 2 + 2].point){\n\t\t\tseg[p] = seg[p * 2 + 1];\n\t\t}\n\t\telse{\n\t\t\tseg[p] = seg[p * 2 + 2];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\tinit();\n\t\n\tint lb = 0;//左端\n\tint d, t, x;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tif(i > 0) res[seg[0].id] += t - lb;\n\t\tadd(d, x);\n\t\tlb = t;\n\t\t//for(int i = 1; i <= N; i++){\n\t\t//\tprintf(\"%d \", res[i]);\n\t\t//}\n\t\t//printf(\": seg[0].id = %d\\n\", seg[0].id);\n\t}\n\tres[seg[0].id] += L - t;\n\t\n\tint longest = 0;//最長の映り時間\n\tfor(int i = 1; i <= N; i++) longest = max(longest, res[i]);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(res[i] == longest){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[500000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d+1-e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;cin>>x>>y>>z;\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\t\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  team[search(id,n)].point+=key;\n  maxHeapify(id);\n  while(id>1&&team[id/2].point<team[id].point){\n    swap(team[id],team[id/2]);\n    id=id/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top=team[i].id;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop=team[i].id;\n      }\n    }\n  }\n  printf(\"%d\\n\",top);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i],x[i],n);\n    //    printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  //  for(int i=1;i<=n;i++){\n  //printf(\"%d %d\\n\",team[i].id,team[i].showed);\n  //}\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\nstruct Point{\n  int score,player;\n\n  bool operator < (const Point& p) const {\n    if( score != p.score ) return score < p.score;\n    return player > p.player;\n  }\n};\n\n/*\n  ostream& operator << (ostream& os,const Point& p) {\n  os << \"(\" << p.score << \",\" << p.player <<\")\";\n}\n*/\nint main(){\n  \n  int N,R,L;\n  int d,t,x;\n  priority_queue<Point> PQ;\n  priority_queue<Point> PQ2;\n  int score_sum[100001],time_sum[100001];\n  int data[3]={1,0,0};\n  \n  cin >>N>>R>>L;\n  \n  for(int i=0 ; i < 100001 ; i++){\n    score_sum[i]=0;\n    time_sum[i]=0;\n  }\n\n  for(int i=1 ; i <= R ; i++){\n    \n    cin >>d>>t>>x;\n    \n    PQ.push((Point){score_sum[data[0]],data[0]});\n    \n    while(1){\n      if(!PQ.empty() && PQ.top().score == score_sum[PQ.top().player]){\n\ttime_sum[PQ.top().player]+=t-data[1];\n\tbreak;\n      }else{\n\tassert( PQ.size() );\n\tPQ.pop();\n      }\n    }  \n    PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n  \n    score_sum[d]+=x;  \n    data[0]=d;data[1]=t;data[2]=x;  \n  }\n\n  PQ.push((Point){score_sum[data[0]],data[0]});\n  while(1){\n    if(!PQ.empty() && PQ.top().score == score_sum[PQ.top().player]){\n      time_sum[PQ.top().player]+=L-data[1];\n      break;\n    }else{\n      assert( !PQ.empty() );\n      PQ.pop();\n    }\n  }\n  cout << PQ.size() << \" \" << PQ.top().player << endl;\n  PQ2.push((Point){time_sum[PQ.top().player],PQ.top().player});\n  \n\n  cout <<PQ2.top().player<<endl;\n  //cout <<PQ2.top().score<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tpriority_queue<int, vector<pair<int, int> > > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tif(i != 0)ttime[temp.second] += t - ttemp;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\tcout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int MAX_N = 100010;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, r, l;\n\tcin >> n >> r >> l;\n\n\tint score[MAX_N];\n\tint time_[MAX_N];\n\tint id = 0;\n\tint top = 0;\n\tint now = 0;\n\tint timemax = 0;\n\tint tmid = 0;\n\tfor(int i = 0; i < r; ++i){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\t--d;\n\t\ttime_[id] += t - now;\n\t\tif(timemax < time_[id]){\n\t\t\ttimemax = time_[id];\n\t\t\ttmid = id;\n\t\t}\n\t\tnow = t;\n\t\tscore[d] += x;\n\t\tif(id == d){\n\t\t\ttop += x;\n\t\t}\n\t\tif(x < 0 && id == d){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(top < score[j] || (top == score[j] && j < id)){\n\t\t\t\t\ttop = score[j];\n\t\t\t\t\tid = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x > 0 && id != d){\n\t\t\tif(top < score[d] || (top == score[d] && d < id)){\n\t\t\t\ttop = score[d];\n\t\t\t\tid = d;\n\t\t\t}\n\t\t}\n\t}\n\ttime_[id] += l - now;\n\n\tif(timemax < time_[id]){\n\t\ttimemax = time_[id];\n\t\ttmid = id;\n\t}\n\n\tcout << tmid + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\nconst int MAX_N = 1<<17;\ntypedef pair<int,int> pii;\n\nclass RMQ{\npublic:\n  int n;\n  pii dat[2*MAX_N-1];\n\n  void init(int n_){\n    n = 1;\n    while(n < n_){ n *= 2; }\n    for(int i = 0 ; i < 2*n-1 ; i++){\n      dat[i] = pii(-INF,-INF);\n    }\n    for(int i = 0 ; i < n_ ; i++){\n      update(i,0);\n    }\n  }\n\n  void update(int k,int a){\n    int tk = k;\n    k += n - 1;\n    dat[k] = pii(a,-tk);\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  pii query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l){ return pii(-INF,-INF); }\n    if(a <= l && r <= b){\n      return dat[k];\n    }else{\n      pii vl = query(a,b,k*2+1,l,(l+r)/2);\n      pii vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    }\n  }\n};\n\nint main(){\n  int N,R,L;\n  RMQ rmq;\n  cin >> N >> R >> L;\n  rmq.init(N);\n  int d,t,x,pt = 0;\n  vector<int> point(N,0);\n  for(int i = 0 ; i < R ; i++){\n    cin >> d >> t >> x; d--;\n    point[-rmq.query(0,N,0,0,rmq.n).second] += t - pt;\n    rmq.update(d,x+rmq.dat[d+rmq.n-1].first);\n    pt = t;\n  }\n  point[-rmq.query(0,N,0,0,rmq.n).second] += L - pt;\n  int res = -1, max = -INF;\n  for(int i = 0 ; i < N ; i++){\n    if(max < point[i]){\n      max = point[i];\n      res = i+1;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int MAX_N = 100010;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, r, l;\n\tcin >> n >> r >> l;\n\n\tint score[MAX_N];\n\tint time_[MAX_N];\n\tint id = 0;\n\tint top = 0;\n\tint now = 0;\n\tint timemax = 0;\n\tint tmid = 0;\n\tfor(int i = 0; i < r; ++i){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\t--d;\n\t\ttime_[id] += t - now;\n\t\tif(timemax < time_[id] || (timemax == time_[id] && id < tmid)){\n\t\t\ttimemax = time_[id];\n\t\t\ttmid = id;\n\t\t}\n\t\tnow = t;\n\t\tscore[d] += x;\n\t\tif(id == d){\n\t\t\ttop += x;\n\t\t}\n\t\tif(x < 0 && id == d){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(top < score[j] || (top == score[j] && j < id)){\n\t\t\t\t\ttop = score[j];\n\t\t\t\t\tid = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x > 0 && id != d){\n\t\t\tif(top < score[d] || (top == score[d] && d < id)){\n\t\t\t\ttop = score[d];\n\t\t\t\tid = d;\n\t\t\t}\n\t\t}\n\t}\n\ttime_[id] += l - now;\n\n\tif(timemax < time_[id] || (timemax == time_[id] && id < tmid)){\n\t\ttimemax = time_[id];\n\t\ttmid = id;\n\t}\n\n\tcout << tmid + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[1 << 17];\n\nint N, R, L, n;\n\npair<int, int> dat[1 << 18 + 1];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m = -1000000000;\n  for(int i = 0; i < N; i++)\n  {\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    p = query(d, d + 1, 0, 0, n);\n    update(d, make_pair(p.first + x, p.second));\n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<ll> dat;\n\tvector<int> id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(n*4);\n\t\tid.resize(n*4);\n\t\trep(i,2*n-1) dat[i] = -INF;\n\t\trep(i,n) update(i,INF);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] += a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\n\tvector<int> v(n,0);\n\tSeg seg(n);\n\n\tint top_id = seg.id[0],pre_time = 0;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\tseg.update(d-1,x);\n\t\ttop_id = seg.id[0];\n\t}\n\n\tv[top_id] += l - pre_time;\n\n    int res = 0,ans = 0;\n\trep(i,n)\n\t{\n\t\tif(res < v[i])\n\t\t{\n\t\t\tres = v[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tcout << ans+1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  int t=search(id,n);\n  team[t].point+=key;\n  if(key<0){\n    maxHeapify(search(id,n));\n  }\n  else{\n    while(t>1&&team[t/2].point<team[t].point){\n      swap(team[t],team[t/2]);\n      t=t/2;\n    }\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=team[top].id;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    if(i==0){\n      team[search(1,n)].showed+=t[0];\n    }\n    IncreaseKey(d[i],x[i],n);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n    printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n  }\n  for(int i=1;i<=n;i++){\n    printf(\"%d %d   %d\\n\",team[i].id,team[i].showed,team[i].point);\n  }\n  show_top(team,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n//#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\tvi v(n + 100, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\tupdate(1, 0);\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\t//if(p.se >= 0) continue;\n\t\tif(p.se == 0) p.se = -1;\n\t\t//cout<<p.se<<endl;\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\t// int ans = 0;\n\t// for(int i = 1; i < v.size(); i++){\n\t// \tif(v[ans] < v[i]) ans = i;\n\t// \tcout<<v[i]<<endl; \n\t// }\n\t// cout<<ans<<endl;\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(long long int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  long long int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += t-oldt;\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n    }else{\n      if(old==d) old = max(pt,N);\n    }\n  }\n  //cout << t << ' ' << oldt << endl;\n  ptime[old] += L-oldt;\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std ;\n\nint num[2][262144] = {} ; // 0 point , 1 num\nint ranking[100001] = {} ;\nint n , r , l ;\nint d , t , x ;\nint minus = -1001 ;\nint btd , bt , sum1=-1 , sum2=0 ;\n\nvoid count( int p ){\n\t\n\tif( num[0][p*2] >= num[0][p*2+1] ){\n\t\tnum[0][p] = num[0][p*2] ;\n\t\tnum[1][p] = num[1][p*2] ;\n\t}else {\n\t\tnum[0][p] = num[0][p*2+1] ;\n\t\tnum[1][p] = num[1][p*2+1] ;\n\t}\n\t\n\tif( p!=1 ) count( p/2 ) ;\n}\n\nint main(){\n\t\n\tcin >> n >> r >> l ;\n\t\n\tfor( int i=1 ; i<=n ; i++ ){\n\t\tnum[1][i+131071] = i ;\n\t}\n\t\n\tfor( int i=0 ; i<r ; i++ ){\n\t\tcin >> d >> t >> x ;\n\t\tif( i==0 ) ranking[1] = t ;\n\t\tnum[0][d+131071] += x ;\n\t\t\n\t\tif( minus < t ) minus = t ;\n\t\tif( minus < 0 && t < 0 ){\n\t\t\tcount( 131072 / 2 ) ;\n\t\t}else count( ( d+131071 ) / 2 ) ;\n\t\t\n\t\tif( i != 0 ) ranking[btd] = t-bt ;\n\t\tbt = t ;\n\t\tbtd = num[1][1] ;\n\t}\n\t\n\tranking[btd] = l-bt ;\n\t\n\tfor( int i=1 ; i<=n ; i++ ){\n\t\tif( sum1 < ranking[i] ){\n\t\t\tsum1 = ranking[i] ;\n\t\t\tsum2 = i ;\n\t\t}\n\t}\n\tcout << sum2 << endl ;\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001];\n\n\n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  score[0].first = -10000000;  \n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1+1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t  //cout <<\"ko\"<<endl;\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[site1*2+flg];\n\t  score[site1*2+flg] = tmp;\n\t  site1 = site1*2+flg;\n\t}else break;\n      }\n    }\n    /*for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;*/\n\n  }\n\n\n  time[score[1].second] += L-t;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[131050];\nstruct node {\n    int id, point;\n} node[1<<18];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\n//max\nstruct SegTree\n{\n\tint n;\n\tvector<ll> dat;\n\tvector<int> id;\n\n\tSegTree(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(n*4);\n\t\tid.resize(n*4);\n\t\trep(i,n*4) dat[i] = -INF;\n\t\trep(i,n_) update(i,INF);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tint i = k+n-1;\n\t\tdat[i] += a;\n\t\tid[i] = k;\n\n\t\twhile(i > 0)\n\t\t{\n\t\t\ti = (i-1) / 2;\n\t\t\tif(dat[i*2+1] >= dat[i*2+2])\n\t\t\t{\n\t\t\t\tdat[i] = dat[i*2+1];\n\t\t\t\tid[i] = id[i*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdat[i] = dat[i*2+2];\n\t\t\t\tid[i] = id[i*2+2];\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\n\tvector<int> v(n,0);\n\tSegTree st(n);\n\n\tint top_id = st.id[0],pre_time = 0;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\tst.update(d-1,x);\n\n\t\ttop_id = st.id[0];\n\t}\n\n\tv[top_id] += l - pre_time;\n\n\tint res = 0;\n\trep(i,n) res = max(res,v[i]);\n\trep(i,n)\n\t{\n\t\tif(res == v[i])\n\t\t{\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[199999];\nint point[100000];\nint n=1;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--; g--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\tsort(a, a + c); \n\ta[c] = P(d, p(0, 0));\n\tc++;\n\twhile (n < b)n <<= 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tkousin(i, -1);\n\t}\n\tn--;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\n\nint p[1000005];\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<int> dat,id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(2*n-1);\n\t\trep(i,2*n-1) dat[i] = -INF;\n\n\t\tid.resize(2*n-1);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] = a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\t//time id,point\n\tmap<int,vector<pair<int,int> > > m;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tm[t].push_back(make_pair(d,x));\n\t}\n\n\tvector<int> v(n+1);\n\tmemset(p,0,sizeof(p));\n\tSeg seg(n);\n\n\tint top_id = 0,top_p = 0,pre_time = 0;\n\tmap<int,vector<pair<int,int> > >::iterator ite;\n\tfor(ite = m.begin(); ite != m.end(); ite++)\n\t{\n\t\tint d,t,x;\n\t\tt = ite->first;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\trep(i,m[t].size())\n\t\t{\n\t\t\td = m[t][i].first;\n\t\t\tx = m[t][i].second;\n\n\t\t\tp[d] += x;\n\t\t\tseg.update(d-1,p[d]);\n\t\t\ttop_id = seg.id[0];\n\t\t}\n\n\t}\n\n\tv[top_id] += l - pre_time;\n\n\tint res = 0;\n\trep(i,n)\n\t{\n\t\tres = max(res,v[i]);\n\t}\n\n\trep(i,n)\n\t{\n\t\tif(res == v[i])\n\t\t{\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint top_id(int *x,int N){\n  int top=x[1];\n  int id=1;\n  for(int i=2;i<=N;i++){\n    if(top<x[i]){\n      top = x[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t,x;\n  int oldt=0;\n  int tim[N+1];\n  int total[N+1];\n  oldt = 0;\n  for(int i=0;i<=N;i++){\n    tim[i] = 0;\n    total[i] = 0;\n  }\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    tim[top] += (t - oldt);\n    oldt = t;\n    total[d] += x;\n    top = top_id(total,N);\n  }\n  tim[top] += (L - oldt);\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<tim[i]){\n      top_t = tim[i];\n      ans = i;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(long long int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  long long int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += t-oldt;\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n      if(pt[old]==pt[d]&&old>d) old = d; \n    }else{\n      if(old==d) old = max(pt,N);\n    }\n  }\n  ptime[old] += L- oldt;\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<climits>\n\ntypedef std::pair<int, int> P;\n\nconst int MAX_N = 100000;\n\nint n;\n// fst: -得点, snd: チームの番号\nP dat[MAX_N * 2 - 1];\n\nint cnt[MAX_N];\n\nvoid init( int n_ )\n{\n\tn = 1;\n\twhile( n < n_ )\n\t\tn *= 2;\n\n\tfor( int i = 0; i != n * 2 - 1; ++i )\n\t\tdat[i] = std::make_pair( INT_MAX, INT_MAX );\n\n\treturn;\n}\n\nvoid update( int k, P x )\n{\n\tk += n - 1;\n\tdat[k] = x;\n\twhile( k > 0 )\n\t{\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = std::min( dat[k*2+1], dat[k*2+2] );\n\t}\n\n\treturn;\n}\n\n// [a,b)\nP query( int a, int b, int k, int l, int r )\n{\n\tif( a >= r || b <= l )\n\t\treturn std::make_pair( INT_MAX, INT_MAX );\n\t\n\tif( a <= l && r <= b )\n\t\treturn dat[k];\n\telse\n\t{\n\t\tP vl = query( a, b, k * 2 + 1, l, (l + r) / 2 );\n\t\tP vr = query( a, b, k * 2 + 2, (l + r) / 2, r );\n\t\t\n\t\treturn std::min( vl, vr );\n\t}\n}\n\nint main()\n{\n\tint N, R, L;\n\tstd::cin >> N >> R >> L;\n\n\tinit( N );\n\tfor( int i = 0; i != N; ++i )\n\t\tupdate( i, std::make_pair( 0, i ) );\n\n\tint prevT = 0;\n\tfor( int i = 0; i != R; ++i )\n\t{\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\n\t\t--d;\n\n\t\tif( t != prevT )\n\t\t{\n\t\t\tP p = query( 0, N, 0, 0, n );\n\t\t\tcnt[p.second] += t - prevT;\n\t\t}\n\n\t\tP p = query( d, d + 1, 0, 0, n );\n\t\tupdate( d, std::make_pair( p.first - x, p.second ) );\n\n\t\tprevT = t;\n\t}\n\n\tif( prevT != L )\n\t{\n\t\tP p = query( 0, N, 0, 0, n );\n\t\tcnt[p.second] += L - prevT;\n\t}\n\n\tint t = -1, id;\n\tfor( int i = 0; i != N; ++i )\n\t{\n\t\tif( t < cnt[i] )\n\t\t{\n\t\t\tt = cnt[i];\n\t\t\tid = i + 1;\n\t\t}\n\t}\n\t\n\tstd::cout << id << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\ntypedef long long ll;\n\nstruct Team{\n\tll id, cost;\n\tTeam(ll a, ll b):id(a), cost(b){};\n\tbool operator < (const Team &lhs)const {\n\t\tif(cost == lhs.cost)return id > lhs.id;\n\t\treturn cost < lhs.cost;\n\t}\n};\nconst int max = 1000001;\n\nint n, r, l;\nstd::priority_queue<Team> que;\nll score[max];\nll ans[max];\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tque.push(Team(0, 0));\n\tint bef = 0;\n\tfor(int i = 0; i < r; i++){\n\t\tint a, b, c;\n\t\tstd::cin >> a >> b >> c;\n\t\tTeam t = que.top();\n\t\twhile(score[t.id] != t.cost)t = que.top(), que.pop();\n\t\tans[t.id] += (b - bef);\n\t\tbef = b;\n\t\tscore[a - 1] += c;\n\t\tque.push(Team(a - 1, score[a - 1])); \n\t}\n\tTeam t = que.top();\n\tque.pop();\n\twhile(score[t.id] != t.cost)t = que.top(), que.pop();\n\tans[t.id] += (l - bef);\n\n\tint max = 0;\n\tfor(int i = 1; i < n; i++)if(ans[i] > ans[max])max = i;\n\tstd::cout << max + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<17;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tvi v(n + 100, 0);\n\tinit(n);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9;\nconst ll infll = (ll)1e+17;\n\nconst int max = (int)1e+6 + 1;\n\ntypedef std::pair<ll, int> MP;\n\nint n, r, l;\nMP seg[max * 2];\nll point[max];\n\nvoid init(){\n\tint x = 1;\n\twhile (x < n)x *= 2;\n\tn = x;\n\trep(i, max * 2)seg[i].first = -infll, seg[i].second = 0;\n\tREP(i, n - 1, n * 2 - 1)seg[i].second = i - (n - 1);\n}\n\nvoid update(int k, int e){\n\tk += n - 1;\n\tseg[k].first += e;\n\twhile (k > 0){\n\t\tk = (k - 1) / 2;\n\t\tint BigI;\n\t\tif (seg[k * 2 + 1].first == seg[k * 2 + 2].first)BigI = std::min(seg[k * 2 + 1].second, seg[k * 2 + 2].second);\n\t\telse BigI = (seg[k * 2 + 1].first > seg[k * 2 + 2].first ? k * 2 + 1 : k * 2 + 2);\n\t\tseg[k].first = seg[BigI].first;\n\t\tseg[k].second = seg[BigI].second;\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tint before = 0;\n\tinit();\n\trep(i, r){\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\t\t--d;\n\t\tpoint[seg[0].second] += (t - before);\n\t\tupdate(d, x);\n\t\tbefore = t;\n\t}\n\tpoint[seg[0].second] += (l - before);\n\n\tint maxI = 0;\n\tREP(i, 1, n){\n\t\tif (point[i] > point[maxI])maxI = i;\n\t}\n\tstd::cout << maxI + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <numeric>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nvoid updateRanking(int *top, int *jiten, vector<pair<int,int>> info){\n\t*top = 1;\n\t*jiten = 2;\n\tfor(int i=3; i<info.size(); i++) if(info[i].second > info[*top].second){\n\t\t*jiten = *top;\n\t\t*top = i;\n\t}\n}\nint main(){\n\tint n,r,l;\n\tcin>>n>>r>>l;\n\tvector<pair<int,int>> info(1+n,make_pair(0,0));\n\tint top=0,ti=0,jiten=0;\n\tfor(;r--;){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x;\n\t\tinfo[d].second+=x;\n\t\tif(d==top){\n\t\t\tif(x<0 && (info[top].second < info[jiten].second || (info[top].second == info[jiten].second && top > jiten))){\n\t\t\t\tinfo[top].first += t-ti;\n\t\t\t\tti=t;\n\t\t\t\tupdateRanking(&top, &jiten, info);\n\t\t\t}\n\t\t}else if(d==jiten && x<0){\n\t\t\tupdateRanking(&top, &jiten, info);\n\t\t}else if(info[d].second > info[top].second || (info[d].second == info[top].second && d < top)){\n\t\t\tinfo[top].first += t-ti;\n\t\t\tti=t;\n\t\t\tupdateRanking(&top, &jiten, info);\n\t\t}\n\t}\n\tinfo[top].first += l-ti;\n\tint mi=1;\n\tfor(int i=2; i<info.size(); i++) if(info[i].first > info[mi].first) mi = i;\n\tcout<<mi<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint a,toread,N,R,L,d,t,x,i,time=0,team,T[1001],P[1001],i2,max,dscanf[1001],tscanf[1001],xscanf[1001];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i<=R;i++){\n\t\tT[i]=0;\n\t\tP[i]=0;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tdscanf[i]=d;\n\t\ttscanf[i]=t;\n\t\txscanf[i]=x;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(i!=1){\n\t\t\tfor(a=i;a>=1;a--){\n\t\t\t\tif(tscanf[i]>=tscanf[a]){\n\t\t\t\t\ttoread=tscanf[i];\n\t\t\t\t\ttscanf[i]=tscanf[a];\n\t\t\t\t\ttscanf[a]=toread;\n\t\t\t\t\ttoread=dscanf[i];\n\t\t\t\t\tdscanf[i]=dscanf[a];\n\t\t\t\t\tdscanf[a]=toread;\n\t\t\t\t\ttoread=xscanf[i];\n\t\t\t\t\txscanf[i]=xscanf[a];\n\t\t\t\t\txscanf[a]=toread;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=R;i++){\n\t\td=dscanf[i];\n\t\tt=tscanf[i];\n\t\tx=xscanf[i];\n\t\tP[d]+=x;\n\t\tmax=0;\n\t\tif(i!=1){\n\t\t\tfor(i2=1;i2<=R;i2++){\n\t\t\t\tif(P[i2]>P[max]){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t\telse if(P[i2]==P[max]&&i2<max){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t}\n\t\tT[team]+=t-time;\n\t\t}\n\t\ttime=t;\n\t\tteam=max;\n\t\tT[0]=0;\n\t}\n\tif(time!=L){\n\t\tT[max]=L-time;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(T[i]>T[max]){\n\t\t\tmax=i;\n\t\t}\n\t\telse if(T[i]==T[max]&&i<max){\n\t\t\tmax=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100001],tt[100001];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = tp[1];\n\t\tFlag = 1;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=2;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - time );//L - t\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t//\tprintf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\nint main() {\n    int n, r, l; cin >> n >> r >> l;vector<int> d(r), t(r), x(r);\n    for(int i = 0; i < r; ++i) { cin >> d[i] >> t[i] >> x[i];d[i]--;}\n    vector<int> score(n), ans(n);priority_queue<pii> que;\n    for(int i = 0; i < n; ++i) que.emplace(0, -i);\n    int pre_t = 0;\n    for(int i = 0; i < r; ++i) {\n        while(score[-que.top().second] != que.top().first) que.pop();\n        ans[-que.top().second] += t[i] - pre_t;\n        score[d[i]] += x[i];que.emplace(score[d[i]], -d[i]);\n        pre_t = t[i];\n    }\n    while(score[-que.top().second] != que.top().first) que.pop();\n    ans[-que.top().second] += l - pre_t;\n    cout << (max_element(begin(ans), end(ans)) - begin(ans) + 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 2013/11/05 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\n\tlong long P[100001] = {0};\n\tint W = 1;\n\n\tint T[100001] = {0};\n\tint tp = 0;\n\n\tfor(int i=0; i<R; i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\n\t\tT[W] += t-tp;\n\t\ttp = t;\n\n\t\tP[d] += x;\n/*\n\t\tif(x>=0){\n\t\t\tif(P[W]<P[d]){\n\t\t\t\tW = d;\n\t\t\t}\n\t\t}\n\t\telse{\n*/\t\t\tW = 1;\n\t\t\tfor(int j=2; j<=N; j++){\n\t\t\t\tif(P[W]<P[j]){\n\t\t\t\t\tW = j;\n\t\t\t\t}\n\t\t\t}\n//\t\t}\n//\t\tcout << W << ' ' << P[W] << endl;\n\t}\n\n\tT[W] += L-tp;\n\n\tint C = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(T[C]<T[i]){\n\t\t\tC = i;\n\t\t}\n\t}\n\tcout << C << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<17;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\tvi v(n + 1, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<max_element(all(v))-v.begin()-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nconst int SIZE = 1<<17;\nint N,R,L;\nstruct segtree\n{\n\tP seg[SIZE*2];\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tseg[i+SIZE-1].fi=0;\n\t\t\tseg[i+SIZE-1].sec=-i;\n\t\t}\n\t}\n\tvoid build()\n\t{\n\t\tfor(int i=SIZE-2;i>=0;i--)seg[i]=max(seg[i*2+1],seg[i*2+2]);\n\t}\n\tvoid update(int k,int x)\n\t{\n\t\tk+=SIZE-1;\n\t\tseg[k].fi+=x;\n\t\twhile(k>0)\n\t\t{\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=max(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tP query(int a,int b,int k,int l,int r)\n\t{\n\t\tif(r<=a||b<=l)return P(-INF,INF);\n\t\telse if(a<=l&&r<=b)return seg[k];\n\t\telse return max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t}\n\tP query()\n\t{\n\t\treturn query(0,N,0,0,SIZE);\n\t}\n};\nsegtree seg;\nvoid print(){cout << -((seg.query()).sec) << endl;}\nint total[100100];\nint d[1000100],t[1000100],x[1000100];\nvector<int> vx;\nint main()\n{\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tfor(int i=0;i<R;i++)\n\t{\n\t\tscanf(\"%d %d %d\",&d[i],&t[i],&x[i]);\n\t\td[i]--;\n\t}\n\tt[R]=L;\n\tseg.init();\n\tseg.build();\n\t//print();\n\ttotal[-((seg.query()).sec)]+=t[0];\n\tfor(int i=0;i<R;i++)\n\t{\n\t\tseg.update(d[i],x[i]);\n\t\t//print();\n\t\ttotal[-((seg.query()).sec)]+=t[i+1]-t[i];\n\t}\n\tint ansv=-1,ans;\n\tfor(int i=0;i<N;i++)if(ansv<total[i])\n\t{\n\t\tansv=total[i];\n\t\tans=i;\n\t}\n\tprintf(\"%d\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n, r, l, d, t, x, u = 0;\n\tscanf(\"%d%d%d\", &n, &r, &l);\n\tint m = 1;\n\twhile(m < n){\n\t\tm <<= 1;\n\t}\n\tvector<int> s(n), c(n), p(2 * m - 1, n - 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tp[i + m - 1] = i;\n\t}\n\tfor(int i = m - 2; i >= 0; --i){\n\t\tp[i] = p[i * 2 + 1];\n\t}\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tc[p[0]] += t - u;\n\t\tu = t;\n\t\ts[d - 1] += x;\n\t\td += m - 2;\n\t\twhile(d > 0){\n\t\t\td = (d - 1) >> 1;\n\t\t\tp[d] = p[2 * d + (s[p[2 * d + 1]] >= s[p[2 * d + 2]] ? 1 : 2)];\n\t\t}\n\t}\n\tc[p[0]] += l - u;\n\n\tint ans = max_element(c.begin(), c.end()) - c.begin() + 1;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define pnt 131072\n\nint N , R , L ;\nint d , t , x ;\nint mt = 0 ;\nint num[100010] = {} ;\nint tree[262144][2] = {} ;\n\nvoid f( int p ){\n\tif( p==0 ) return ;\n\t\n\tif( tree[p*2][0] >= tree[p*2+1][0] ){\n\t\ttree[p][0] = tree[p*2][0] ;\n\t\ttree[p][1] = tree[p*2][1] ;\n\t}\n\telse {\n\t\ttree[p][0] = tree[p*2+1][0] ;\n\t\ttree[p][1] = tree[p*2+1][1] ;\n\t}\n\t\n\tf( p/2 ) ;\n}\n\nmain(){\n\tcin >> N >> R >> L ;\n\tfor( int i=1 ; i<=N ; i++ ) tree[pnt+i-1][1] = i ;\n\tf( pnt/2 ) ;\n\tfor( int i=0 ; i<=R ; i++ ){\n\t\tif( i==R ) num[ tree[1][1] ] += L - mt ;\n\t\telse {\n\t\t\tcin >> d >> t >> x ;\n\t\t\tnum[ tree[1][1] ] += t - mt ;\n\t\t\tmt = t ;\n\t\t\ttree[pnt+d-1][0] += x ;\n\t\t\tf( (pnt+d-1)/2 ) ;\n\t\t}\n\t}\n\tint mx = 0 , mxd = 0 ;\n\tfor( int i=1 ; i<=N ; i++ ){\n\t\tif( mx < num[i] ){\n\t\t\tmx = num[i] ;\n\t\t\tmxd = i ;\n\t\t}\n\t}\n\tcout << mxd << endl ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\ntypedef long long ll;\n\nstruct Team{\n\tll id, cost;\n\tTeam(ll a, ll b):id(a), cost(b){};\n\tbool operator < (const Team &lhs)const {\n\t\tif(cost == lhs.cost)return id > lhs.id;\n\t\treturn cost < lhs.cost;\n\t}\n};\nconst ll max = 1000001;\n\nll n, r, l;\nstd::priority_queue<Team> que;\nll score[max];\nll ans[max];\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tque.push(Team(0, 0));\n\tll bef = 0;\n\tfor(ll i = 0; i < r; i++){\n\t\tll a, b, c;\n\t\tstd::cin >> a >> b >> c;\n\t\tTeam t = que.top();\n\t\twhile(score[t.id] != t.cost)t = que.top(), que.pop();\n\t\tans[t.id] += (b - bef);\n\t\tbef = b;\n\t\tscore[a - 1] += c;\n\t\tque.push(Team(a - 1, score[a - 1])); \n\t}\n\tTeam t = que.top();\n\tque.pop();\n\twhile(score[t.id] != t.cost)t = que.top(), que.pop();\n\tans[t.id] += (l - bef);\n\n\tll max = 0;\n\tfor(ll i = 1; i < n; i++)if(ans[i] > ans[max])max = i;\n\tstd::cout << max + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\n#define endl '\\n'\n#define lcm( a, b ) ((a)/__gcd(a,b)*(b))\n#define MP make_pair\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<int, P> i_P;\ntypedef pair< LL, LL > L_P;\n\nconst int INF = INT_MAX;\nconst int MIN = INT_MIN;\nconst LL LINF = LLONG_MAX;\nconst int MOD = 1000000000 + 7;\nconst int SIZE = 300005;\n\nvoid update( L_P segtree[], int pos );\n\nLL b;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    LL n, r, l;\n    cin >> n >> r >> l;\n    b = 1;\n    int bi = 1;\n    while( b < n ) {\n        b *= 2;\n\n    }\n\n    b = b * 2 + 1;\n    LL res[SIZE] = {};\n    L_P segtree[SIZE];\n    for( int i = 0; i <= b; ++i ) {\n        segtree[i].F = 0;\n        segtree[i].S = 1;\n\n    }\n    for( int i = b / 2, j = 1; i <= b / 2 + n; ++i, ++j ) {\n        segtree[i].S = j;\n\n    }\n    for( int i = b / 2 + n + 1; i <= b; ++i ) {\n        segtree[i].F = MIN;\n\n    }\n\n    int team = 1;\n    int ltime = 0;\n    for( int i = 0; i < r; ++i ) {\n        LL d, t, x;\n        cin >> d >> t >> x;\n        res[team] += t - ltime;\n        ltime = t;\n\n        //cout << segtree[b / 2 + d - 1].S << endl;\n        segtree[b / 2 + d - 1].F += x;\n        update( segtree, ( d + b / 2 - 1 ) / 2 );\n        team = segtree[1].S;\n        //cout << segtree[d + b / 2 - 1].F << endl;\n\n    }\n    res[team] += l - ltime;\n    LL mx = 0, mxpos = 0;\n    for( int i = 1; i <= n; ++i ) {\n        if( mx < res[i] ) {\n            mxpos = i;\n            mx = res[i];\n\n        }\n    }\n    cout << mxpos << endl;\n\n    return 0;\n}\n\nvoid update( L_P segtree[], int pos ) {\n    if( segtree[pos * 2].F < segtree[pos * 2 + 1].F ) {\n        segtree[pos].F = segtree[pos * 2 + 1].F;\n        segtree[pos].S = segtree[pos * 2 + 1].S;\n\n    } else {\n        segtree[pos].F = segtree[pos * 2].F;\n        segtree[pos].S = segtree[pos * 2].S;\n\n    }\n    if( pos == 1 ) return;\n\n    update( segtree, pos / 2 );\n    return;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\tif(nowN==-1){\n\t\tif(scr[n-1]>0)nowN=n-1;\n\t\telse if(n==0)nowN=1;\n\t\telse nowN=0;\n\t\t//else nowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\t}else if(n-1!=nowN){\n\t\t\tif(scr[n-1]>=scr[nowN]){\n\t\t\t\tif(scr[n-1]==scr[nowN])nowN=min(n-1,nowN);\n\t\t\t\telse nowN=n-1;\n\t\t\t}\n\t\t}else if(n-1==nowN){\n\t\t\tif(s<0){\n\t\t\t\tnowN=0;\n\t\t\t\trep(i,N)if(scr[i]>scr[nowN])nowN=i;\n\t\t\t}else{\n\t\t\t\n\t\t\t}\n\t\t\t//rep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\t}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\tif(nowN==-1)nowN=n-1;\n\t\telse nowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#include<vector>\n#include<functional>\n#include<limits>\ntemplate<typename T>\nstruct segtree{\n\tfunction<T(T,T)>calcfn,updatefn;\n\tint n;\n\tT defvalue;\n\tvector<T>dat;\n\tsegtree(int n_=0,T defvalue_=numeric_limits<T>::max(),\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a<b?a:b;},\n\t\tfunction<T(T,T)>updatefn_=[](T a,T b){return b;}\n\t):defvalue(defvalue_),calcfn(calcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[i*2+1],dat[i*2+2]);\n\t}\n\tvoid update(int i,T a)\n\t{\n\t\ti+=n-1;\n\t\tdat[i]=updatefn(dat[i],a);\n\t\twhile(i>0)\n\t\t{\n\t\t\ti=(i-1)/2;\n\t\t\tdat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int i=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\tif(r<=a||b<=l)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[i];\n\t\telse\n\t\t{\n\t\t\treturn calcfn(\n\t\t\t\tquery(a,b,i*2+1,l,(l+r)/2),\n\t\t\t\tquery(a,b,i*2+2,(l+r)/2,r)\n\t\t\t);\n\t\t}\n\t}\n};\nint N,R,L;\nint cnt[1<<17];\nmain()\n{\n\tcin>>N>>R>>L;\n\tsegtree<pair<int,int> >P(N,make_pair(0,0),[](pair<int,int>a,pair<int,int>b){return a<b?a:b;},\n\t[](pair<int,int>a,pair<int,int>b){return make_pair(a.first-b.first,b.second);});\n\tfor(int i=0;i<N;i++)P.update(i,make_pair(0,i));\n\tint pre=0;\n\tfor(int i=0;i<R;i++)\n\t{\n\t\tint d,t,x;cin>>d>>t>>x;d--;\n\t\tcnt[P.query(0,N).second]+=t-pre;\n\t\tpre=t;\n\t\tP.update(d,make_pair(x,d));\n\t}\n\tcnt[P.query(0,N).second]+=L-pre;\n\tint ans=0,id;\n\tfor(int i=0;i<N;i++)if(cnt[i]>ans)ans=cnt[id=i];\n\tcout<<id+1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <set>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint N, R, L;\ntemplate<class T> struct SegmentTree\n{\n    int n = 1;\n    //score, team\n    vector<pair<int, int>> node;\n    SegmentTree(int sz)\n    {\n        while(n < sz) n *= 2;\n        for(int i = 0; i < 2 * n - 1; i++) node.push_back(make_pair(-INF, -i));\n    }\n    void update(int pos, int val)\n    {\n        pos += (n - 1);\n        node[pos].first += val;\n        while(pos > 0)\n        {\n            pos = (pos - 1) / 2;\n            node[pos] = max(node[2 * pos + 1], node[2 * pos + 2]);\n        }\n    }\n    int getRoot() { return -node[0].second - (n - 1); }\n};\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> R >> L;\n    SegmentTree<int> teams(N);\n    vector<int> d(R), t(R), x(R);\n    for(int i = 0; i < R; i++)\n    {\n        cin >> d[i] >> t[i] >> x[i];\n        d[i]--;\n    }\n    int now = 0, target = 0;\n    map<int, int> times;\n    for(int i = 0; i < R; i++)\n    {\n        times[target] += t[i] - now;\n        teams.update(d[i], x[i]);\n        target = teams.getRoot();\n        now = t[i];\n    }\n    times[target] += L - now;\n    int ans = -1, maxv = -INF;\n    for(auto x : times)\n    {\n        if(x.second > maxv)\n        {\n            maxv = x.second;\n            ans = x.first;\n        }\n    }\n    cout << ans + 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point {\n  int x,y;\n  bool operator < (const Point& p) const {\n    if( y != p.y ) return y < p.y;\n    return x > p.x;\n  }\n};\nostream& operator << (ostream& os,const Point& p) {\n  os << p.x/* <<\" \"<< p.y*/;\n}\n\nint score[100001];\nint t[1000000];\nint time_[1000000];\nint main(){\n  priority_queue<Point> Q;\n  priority_queue<Point> T;\n  int N,R,L;\n  int d,x;\n  int a=1,b=0;\n\n  cin >>N>>R>>L;\n\n\n  for(int i=0;i<R;i++){\n    cin >>d>>t[i]>>x;    \n    score[d]+=x;\n    Q.push((Point){d,score[d]});  \n \n    while(!Q.empty() && score[Q.top().x] != Q.top().y){\n      Q.pop();\n    }\n    time_[a]+=t[i]-b; \n    T.push((Point){a,time_[a]});\n    a=Q.top().x;\n    b=t[i];\n    T.push((Point){a,time_[a]});\n    \n  }\n  \n  while( !Q.empty() && score[Q.top().x] != Q.top().y){\n    Q.pop();\n  }\n  time_[a]+=L-b;\n  if( !Q.empty() ) a=Q.top().x;\n  else a = 1;\n  b=L;\n  T.push((Point){a,time_[a]});\n \n  cout <<T.top()<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][10000000],T=0,g,p[2][1000000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nconst int N=131072; // AC\n//const int N=131071; // WA\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[199999];\nint point[100000];\nint n=1;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--; g--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\tsort(a, a + c); \n\ta[c] = P(d, p(0, 0));\n\tc++;\n\twhile (n < b)n <<= 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment[n + i - 1].second = i;\n\t}\n\tn--;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000001;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tint f = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\tif(Time[i] > 0 && f== 0) {\n\t\t\tn =i;\n\t\t\tf= 1;\n\t\t}\n\t\tif(i == L)Team_max[temp1] += L-n;\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint P[100000],T[100000];\nint main() {\n    int N,R,L,PT=0,n1=0,p1=0;\n    scanf(\"%d %d %d\",&N,&R,&L);\n    for(int i=0;i<R;i++) {\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x); d--;\n        P[d]+=x;\n        if(x>0) {\n            if(P[d]>p1) {\n                T[n1]+=t-PT-1;\n                PT=t;\n                n1=d;\n                p1=P[d];\n            }\n        }\n        if(x<0) {\n            if(d!=n1) continue;\n            int n2=n1,p2=P[d];\n            for(int j=N-1;j>=0;j--) {\n                if(p2<P[j]) {n2=j,p2=P[j];}\n            }\n            if(p2!=p1) {\n                T[n1]+=t-PT-1;\n                PT=t;\n                n1=n2;\n                p1=p2;\n            }\n        }\n    }\n    T[n1]+=L-PT;\n    int ans_n=0,ans_t=0;\n    for(int i=0;i<N;i++) {\n        if(ans_t<T[i]) {\n            ans_t=T[i];\n            ans_n=i;\n        }\n    }\n    printf(\"%d\\n\",ans_n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(void){\n  int n,r,l;\n  cin>>n>>r>>l;\n  vector<int> tn(n,0);\n  vector<int> c(n,0);\n  int now = 0,ln;\n  int max = 0;\n  int d,t,x;\n\n  for(int i = 0 ; i < r ; i ++){\n     cin>>d>>t>>x;\n     d--;\n     tn[d] += t * x;\n     if(max < tn[d]){\n      c[ln] += t - (!now?t:now); \n      now = t; ln = d; \n      max = tn[d];    \n     }\n     \n  }\n  if(max < tn[d]){\n      c[ln] += l - now; \n      now = t; ln = d;     \n  }\n  max = 0;\n  for(int i = 0 ; i < n ; i ++){\n    if(c[i] > max)max = c[i];\n  }\n  for(int i = 0 ; i < n ; i ++){\n    if(c[i] == max){\n      cout<<i+1<<endl;\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint N, R, L, x[1000000], y[1000000], D[1000000], T[1000000], X[1000000], maxn, maxid;\nint main() {\n\tcin >> N >> R >> L;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> D[i] >> T[i] >> X[i];\n\t}\n\tD[R] = 0; T[R] = L; X[R] = 0;\n\tfor (int i = 0; i <= R; i++) {\n\t\tif (i >= 1) {\n\t\t\tmaxn = -1000000000;\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tif (x[j] > maxn) { maxn = x[j]; maxid = j; }\n\t\t\t}\n\t\t\ty[maxid] += T[i] - T[i - 1];\n\t\t}\n\t\tx[D[i]] += X[i];\n\t}\n\tmaxn = -1000000000;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (maxn > y[i]) { maxn = y[i]; maxid = i; }\n\t}\n\tcout << maxid << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\nint N, R, T;\npriority_queue<pair<int, int>> pq;\nint score[1000000], total_time[1000000];\nint beforetime = 0, nowteam = 0;\n\nint main() {\n\tcin >> N >> R >> T;\n\tfor (int i = 0; i < N; i++)pq.push(make_pair(0, -i));\n\tfor (int i = 0; i < R; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tscore[a - 1] += c;\n\t\tpq.push(make_pair(score[a - 1], -(a - 1)));\n\n\t\twhile (1) {\n\t\t\tif (pq.top().first == score[-pq.top().second]) {\n\t\t\t\t//????????¢????????´???????????§?????????\n\t\t\t\t//pq.top().second???pq???????§?????????????????????????\n\t\t\t\t//????????§????????¢??¨?????´????????????????????????????????????????????????(????????¢???????°????????????????????????????)\n\t\t\t\t//?????§???????????????????????????????¬???§??´??°??????????????¨?????????????????´??°???????????????\n\t\t\t\ttotal_time[nowteam] += (b - beforetime);\n\t\t\t\tbeforetime = b;\n\t\t\t\tnowteam = -pq.top().second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t}\n\ttotal_time[nowteam] += (T - beforetime);\n\tcout << (max_element(total_time, total_time + N) - total_time) + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, R, L, D, T, X, M[100000], A[100000]; vector<pair<int, int> > F[1000000]; // (team, score)\nint main() {\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\tfor (int i = 0; i < R; i++) {\n\t\tscanf(\"%d%d%d\", &D, &T, &X);\n\t\tF[D].push_back(make_pair(T - 1, X));\n\t}\n\tpriority_queue<pair<int, int> > que;\n\tfor (int i = 0; i < N; i++) {\n\t\tque.push(make_pair(0, -i));\n\t}\n\tfor (int i = 0; i < L; i++) {\n\t\tfor (int j = 0; j < F[i].size(); j++) {\n\t\t\tM[F[i][j].first] += M[F[i][j].second];\n\t\t\tque.push(make_pair(M[F[i][j].first], -F[i][j].first));\n\t\t}\n\t\tpair<int, int> p;\n\t\twhile (!que.empty()) {\n\t\t\tp = que.top();\n\t\t\tif (p.first == M[-p.second]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tA[-p.second]++;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] > A[ret]) {\n\t\t\tret = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\nint R;\nint L;\n\npair<int, int> seg[100000 * 4];\n\nvoid update(int k, int a, int b, int p, int x) {\n  if (p < a || b <= p)\n    return;\n  if (b - a == 1) {\n    int tmp = seg[k].first;\n    seg[k] = make_pair(tmp + x, -p);\n  } else {\n    update(2*k+1, a, (a+b)/2, p, x);\n    update(2*k+2, (a+b)/2, b, p, x);\n    seg[k] = max(seg[2*k+1], seg[2*k+2]);\n  }\n}\n\nconst int oo = 1<<30;\npair<int, int> query(int k, int a, int b, int l, int r) {\n  if (r <= a || b <= l)\n    return make_pair(-oo, 0);\n  if (l <= a && b <= r)\n    return seg[k];\n  pair<int, int> r1 = query(2*k+1, a, (a+b)/2, l, r);\n  pair<int, int> r2 = query(2*k+2, (a+b)/2, b, l, r);\n  return max(r1, r2);\n}\n\nint cnt[100000];\n\nint main(int argc, char *argv[])\n{\n  int pre_t = 0;\n  scanf(\" %d %d %d\", &N, &R, &L);\n  for (int i = 0; i < R; i++) {\n    int d, t, x;\n    scanf(\" %d %d %d\", &d, &t, &x);\n    auto v = query(0, 0, N, 0, N);\n    cnt[-v.second] += t - pre_t;\n    pre_t = t;\n    update(0, 0, N, d-1, x);\n  }\n  auto v = query(0, 0, N, 0, N);  \n  cnt[-v.second] += L - pre_t;\n\n  int r = 0;\n  for (int i = 1; i < N; i++) {\n    if (cnt[i] > cnt[r])\n      r = i;\n  }\n\n  printf(\"%d\\n\", r+1);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 100000000\n#define MAX_TEAM 10000000\n\npriority_queue<pair<int, int>> Q;\nint d[MAX_N], n, s, L, x[MAX_N], y[MAX_N], t[MAX_N], d[MAX_TEAM], ti[MAX_TEAM];\n\nint main() {\n\tcin >> n >> s >> L;\n\tQ.push(make_pair(0, -1000000000));\n\tx[0] = 0; t[0] = 0; y[0] = 0; x[s + 1] = 0; t[s + 1] = L; y[s + 1] = 0;\n\tfor (int i = 1; i <= s + 1; i++) {\n\t\tif (i <= s) { cin >> x[i] >> t[i] >> y[i]; }\n\t\td[x[i]] += y[i];\n\t\tQ.push(make_pair(d[x[i]], -x[i]));\n\t\twhile (true) {\n\t\t\tpair<int, int>p = Q.top();\n\t\t\tif (p.first == d[-p.second]) {\n\t\t\t\tti[p.second] += x[i] - x[i - 1]; break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[500000];\nint point[100000];\nint n=1;\nint b;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\ta[c] = P(d, p(0, 0));\n\tc++;\n\tn = b;\n\tfor (int i = 0; i < 500000; i++) {\n\t\tsegment[i] = p(1 << 29, 1 << 29);\n\t}\n\tfor (int i = 0; i < b; i++) {\n\t\tsegment[b+i-1] = p(0, i);\n\t}\n\tn = b - 1;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n  \n\n\n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n    \n    time[score[1].second] += t - mae;\n    score[d].first += x;\n    mae = t;\n    \n    int site1;\n    \n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = d;\n\tbreak;\n      }\n    \n\t \n    \n    pair <int , int > tmp;   \n    for(int j=d;j>=1;j--) {\n      if(score[site1].first > score[site1/2].first ) {\n      tmp = score[site1];\n      score[site1] = score[site1/2];\n      score[site1/2] = tmp;\n      site1 = site1/2;\n      }else if(score[site1].first == score[site1/2].first && score[site1].second < score[site1/2].second) {\n\ttmp = score[site1];\n\tscore[site1] = score[site1/2];\n\tscore[site1/2] = tmp;\n      site1 = site1/2;\n      } else break;\n    }\n        \n    for(int j=site1;j<=N;j++) {\n      if(2*site1< N &&( score[2*site1]> score[site1] || score[2*site1+1] > score[site1])) {\n\tif(site1 > N ) break;\n\tint flg = 0;\n\tif(score[2*site1+1] > score[site1] && score[2*site1] > score[2*site1+1]) flg = 1;\n\ttmp = score[site1];\n\tscore[site1] = score[site1*2+flg];\n\tscore[site1*2+flg] = tmp;\n      }else break;\n    }\n\n  }\n\n  time[score[1].second] += L-x;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n  \n  \n  cout << ans << endl;\n\n  return 0;\n\n  }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define MAX 1111111\n#define MIN -1111111\ntypedef pair<int,int> P;\nvoid init(int n);\nvoid update(int k,int x);\nP maxx(int k1,int k2);\nP dat[4*100001];\nint tim[100001]={0};\nint N;\n\nint main(){\n  int R,L;\n  cin >> N >> R >> L;\n  int n_tmp = N;\n  init(N);\n  memset(tim,0,n_tmp+1);\n  int now = 0;\n  dat[0]=P(MIN,1);\n  for(int i=0;i<R;i++){\n    int d,t,x;\n    cin >> d >> t >> x;\n    tim[dat[0].second] += t - now;\n    update(d,x);\n    now = t;\n  }\n  tim[dat[0].second] += L - now;\n  int *ans = max_element(tim,tim+n_tmp+1);\n  cout << ans - tim << endl;\n}\n\nvoid init(int n){\n  N=1;\n  while(N<n) N*=2;\n  for(int i=0;i<2*N-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n  for(int i=N-1;i<N-1+n;i++){\n    dat[i]=P(0,i-(N-2));\n  }\n  return;\n}\n\nvoid update(int k,int x){\n  k += N - 2;\n  P p = dat[k];\n  int score = p.first;\n  int team = p.second;\n  //cout << score << \" \" << team << endl;\n  dat[k] = P(score+x,team);\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = maxx(k*2+1,k*2+2);\n    //cout << dat[k].first << \" \" << dat[k].second << endl;\n  }\n  return;\n}\n\nP maxx(int k1,int k2){\n  P p;\n  if(dat[k1].first == dat[k2].first){\n    p = P(dat[k1].first,min(dat[k1].second,dat[k2].second));\n  }\n  else {\n    p = max(dat[k1],dat[k2]);\n  }\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#define f first\n#define s second\n#define MAX_T 100005\nusing namespace std;\n\ntypedef pair<int, int> P;\nP teamp[MAX_T * 2 - 1];\nP teamt[MAX_T * 2 - 1];\nvoid init(int n);\nvoid updateP(int k, int a, int n);\nvoid updateT(int k, int a, int n);\n\nint main(){\n  int N, R, L;\n  int d, t, x;\n  int befd = 0, beft = 0, nt, n = 1;\n  cin >> N >> R >> L;\n  while(n < N) n *= 2;\n  init(n);\n  for(int i = 0; i < R; i++){\n    cin >> d >> t >> x;\n    updateP(d - 1, x, n);\n    nt = t - beft;\n    beft = t;\n    updateT(befd, nt, n);\n    befd = teamp[0].s;\n  }\n  nt = L - beft;\n  updateT(befd, nt, n);\n  cout << teamt[0].s + 1 << endl;\n}\n\nvoid init(int n){\n  for(int i = 0; i < n * 2 - 1; i++){\n    teamp[i].f = 0;\n    teamt[i].f = 0;\n  }\n  for(int i = n - 1; i < n * 2 - 1; i++){\n    teamp[i].s = i - (n - 1);\n    teamt[i].s = i - (n - 1);\n  }\n  return;\n}\n\nvoid updateP(int k, int a, int n){\n  k += n - 1;\n  teamp[k].f += a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamp[k * 2 + 1].f >= teamp[k * 2 + 2].f){\n      teamp[k].f = teamp[k * 2 + 1].f;\n      teamp[k].s = teamp[k * 2 + 1].s;\n    }\n    else{\n      teamp[k].f = teamp[k * 2 + 2].f;\n      teamp[k].s = teamp[k * 2 + 2].s;\n    }\n  }\n  return;\n}\n\nvoid updateT(int k, int a, int n){\n  k += n - 1;\n  teamt[k].f += a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamt[k * 2 + 1].f >= teamt[k * 2 + 2].f){\n      teamt[k].f = teamt[k * 2 + 1].f;\n      teamt[k].s = teamt[k * 2 + 1].s;\n    }\n    else{\n      teamt[k].f = teamt[k * 2 + 2].f;\n      teamt[k].s = teamt[k * 2 + 2].s;\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass SegmentTree {\nprivate:\n    int n;\n    vector<ll> node;\n    vector<int> idx;\n    ll INF = (1ll << 31) - 1;\npublic:\n    SegmentTree(int N) {\n        n = 1;\n        while (n < N) n *= 2;\n        node.resize(2 * n - 1, -INF);\n        idx.resize(2 * n - 1, -1);\n        for (int i = 0; i < N; i++) {\n            node[i + n - 1] = 0;\n            idx[i + n - 1] = i;\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n            if (node[2 * i + 1] >= node[2 * i + 2]) {\n                idx[i] = idx[2 * i + 1];\n            } else {\n                idx[i] = idx[2 * i + 2];\n            }\n        }\n\n    }\n\n    void update(int i, ll x) {\n        i += (n - 1);\n        node[i] += x;\n        while (i > 0) {\n            i = (i - 1) / 2;\n            int l = 2 * i + 1;\n            int r = 2 * i + 2;\n            node[i] = max(node[l], node[r]);\n            if (node[l] >= node[r]) {\n                idx[i] = idx[l];\n            } else {\n                idx[i] = idx[r];\n            }\n        }\n    }\n\n    int query() {\n        return idx[0];\n    }\n\n    void disp() {\n        for (int i = 0; i < 2 * n - 1; i++) {\n            cout << idx[i] << \" \" << node[i] << \"\\n\";\n        }\n    }\n\n};\n\nint main() {\n    int N, R, L;\n    cin >> N >> R >> L;\n    int k = 0;\n    ll v[N]{};\n    SegmentTree st(N);\n    int n = 1;\n    while (n < N) n *= 2;\n    int d[R], t[R], x[R];\n    for (int i = 0; i < R; i++) {\n        cin >> d[i] >> t[i] >> x[i];\n        d[i]--; \n    }\n    \n    for (int i = 0; i < R; i++) {\n        int idx = st.query();\n        //cout << idx << \"\\n\";\n        v[idx] += t[i] - k;\n        k = t[i];\n        st.update(d[i], x[i]);\n    }\n    // cout << \"-----\\n\";\n    // cout << st.query(0, N, 0, 0, n) << \"\\n\";\n    // cout << \"-----\\n\";\n    v[st.query()] += L - k;\n    int ans = 0;\n    for (int i = N - 1; i >= 0; i--) {\n        if (v[ans] <= v[i]) {\n            ans = i;\n        }\n    }\n    cout << ans + 1 << \"\\n\";\n    //st.disp();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nint dat[1000000];\nint max_idx[2*1000000-1];\nint size;\nvoid init(int _size) {\n\tsize=1;\n\twhile(_size>size) size*=2;\n\tfor(int i=0;i<size;i++) {\n\t\tif(i<_size) dat[i]=0; else dat[i]=-(1<<30);\n\t}\n\tfor(int i=size*2-2;i>=0;i--) {\n\t\tif(i>=size-1) {\n\t\t\tmax_idx[i]=i-(size-1);\n\t\t}else {\n\t\t\tmax_idx[i]=max_idx[i*2+1];\n\t\t}\n\t}\n}\nvoid update(int k,int a) {\n\tdat[k]+=a;\n\tk+=size-1;\n\twhile(k>0) {\n\t\tk=(k-1)/2;\n\t\tif(dat[max_idx[k*2+1]]>=dat[max_idx[k*2+2]]) {\n\t\t\tmax_idx[k]=max_idx[k*2+1];\n\t\t}else {\n\t\t\tmax_idx[k]=max_idx[k*2+2];\n\t\t}\n\t}\n}\nint Time[1000000];\nint main() {\n\tint N,R,L;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tinit(N);\n\tint cur=0;\n\tfor(int i=0;i<R;i++) {\n\t\tint d,t,x;\n\t\tscanf(\"%d %d %d\",&d,&t,&x); d--;\n\t\tTime[max_idx[0]]+=t-cur;\n\t\tupdate(d,x);\n\t\tcur=t;\n\t}\n\tTime[max_idx[0]]+=L-cur;\n\tint max_time=0,max_id=0;\n\tfor(int i=0;i<N;i++) {\n\t\tif(Time[i]>max_time) {\n\t\t\tmax_time=Time[i];\n\t\t\tmax_id=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max_id+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint score[100000];\nint tim[100000];\n\nint main(){\n\tint i,j;\n\tint n,r,l,d,t,x;\n\tint mi;\n\tint lt=0;\n\tint identify,lidentify=0;\n\tcin >> n >> r >> l ;\n\tfor(i=0;i<100000;i++) score[i]=0;tim[i]=0;\n\tfor(i=0;i<r;i++){\n\t\tcin >> d >> t >> x;\n\t\tscore[d-1]+=x;\n\t\tidentify=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(score[j] > score[identify]) identify=j;\n\t\t}\n\t\ttim[lidentify] += (t - lt + 1);\n\t\t//cout << lidentify << \":\" << (t-lt+1) << endl;\n\t\tlt = t;lidentify=identify;\n\t}\n\ttim[lidentify] += l-lt+1;\n\tidentify=0;\n\tfor(i=0;i<n;i++){\n\t\tif(tim[i] > tim[identify]) identify = i;\n\t}\n\tcout << identify + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\tvector<long long int> data(N+1, 0);\n\tvector<int> timet(N+1, 0);\n\tint maxteam = 1;\n\tint maxs = 0;\n\tint time = 0;\n\tint d, t, x;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> d >> t >> x;\n\t\ttimet[maxteam] += t-time;\n\t\tdata[d] += x;\n\t\ttime = t;\n\t\tif (d == maxteam && x >= 0) {\n\t\t\tmaxs = data[d];\n\t\t} else if (d != maxteam && data[d] < maxs){\n\t\t} else if (data[d] == maxs && d < maxteam){\n\t\t\tmaxteam = d;\n\t\t} else {\n\t\t\tmaxteam = 1;\n\t\t\tmaxs = data[1];\n\t\t\tfor (int j = 2; j <= N; j++) {\n\t\t\t\tif (data[j] > maxs) {\n\t\t\t\t\tmaxs = data[j];\n\t\t\t\t\tmaxteam = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttimet[maxteam] += L-time;\n\tint k, ktoku;\n\tk = 1;\n\tktoku = timet[1];\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (timet[i] > ktoku) {\n\t\t\tktoku = timet[i];\n\t\t\tk = i;\n\t\t}\n\t}\n\tcout << k << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -11111111\n#define MAX 11111111\ntypedef pair<int,int> P;\nint n;\nP dat[8*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[4*100012];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  dat[0] = P(MIN,1);\n  int d,t,x,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[dat[0].second].first+=t-bt;\n    update(d,x);\n    bt=t;\n  }\n  tim[dat[0].second].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-2;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n\n\nusing namespace std;\nint lis[100000];\nint tim[100000];\nint main() {\n    int n,r,l;\n    scanf(\"%d %d %d\",&n,&r,&l);\n\n    int top = 0;\n    int id  = 1;\n    int nowtime = 0;\n    int timemax = 0;\n    int timemaxid = 0;\n    for(int i = 0; i < r; i++) {\n       \n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x);\n        tim[id] += t - nowtime;\n        if(tim[id] > timemax) {\n            timemax = tim[id];\n            timemaxid = id;\n        }\n        nowtime = t;\n        lis[d] += x;\n        if(id == d) {\n            top += x;\n        }\n        if(x < 0 && d == id) {\n            for(int j = 1; j < n+1; j++) {\n                if(top < lis[j] || (top == lis[j] && j < id)) {\n                    top = lis[j];\n                    id = j;\n                }\n            }\n            \n        }\n        if(x > 0 && d != id) {\n            if(top < lis[d] || (top == lis[d] && d < id)) {\n                top = lis[d];\n                id = d;\n            }\n        }\n\n    }\n    tim[id] += l - nowtime;\n    if(tim[id] > timemax) {\n        timemax = tim[id];\n        timemaxid = id;\n    }\n    printf(\"%d\\n\",timemaxid);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][100],T=0,g,p[2][100000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int l,m,n;\n  cin>>l>>m>>n;\n  int b[l+1],c[l+1],top=1,ans1=1;\n\n  for(int i=1;i<=l;i++)b[i]=c[i]=0;\n\n  int aa[m],bb[m],cc[m];\n\n  for(int i=1;i<=m;i++)cin>>aa[i]>>bb[i]>>cc[i];\n\n  for(int i=1;i<=m;i++){\n\n    for(int j=1;j<=l;j++)if(aa[i]==j)c[j]+=cc[i];\n\n    if(i==1)b[top]+=bb[i];\n\n    if(cc[i]>=0){\n      if(c[top]<c[aa[i]]) top=aa[i];\n      else if(c[top]==c[aa[i]] && aa[i]<=top)top=aa[i];\n    }\n\n    else if(cc[i]<0 && aa[i]==top){\n      top=1;\n      for(int j=2;j<=l;j++)if(c[top]<c[j])top=j;\n    }\n\n    if(i<m)b[top]+=bb[i+1]-bb[i];\n    else b[top]+=n-bb[i];\n  }\n\n  for(int i=2;i<=l;i++)if(b[ans1]<b[i])ans1=i;\n\n  cout<<ans1<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int N = 1 << 17;\n\nint seg[1 << 18], a[1 << 17];\nint n, r, l;\nint d[1000002], t[1000002], x[1000002];\nint sum[1 << 17];\n\nvoid init()\n{\n\tfor (int i = 0; i < N; i++) seg[i + N - 1] = i;\n\tfor (int i = N - 2; i >= 0; i--){\n\t\tseg[i] = seg[i * 2 + 1];\n\t}\n}\n\nvoid add(int i, int x)\n{\n\tint k = i + N - 1;\n\ta[i] += x;\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\tif (a[seg[k * 2 + 1]] >= a[seg[k * 2 + 2]]){\n\t\t\tseg[k] = seg[k * 2 + 1];\n\t\t}\n\t\telse if (a[seg[k * 2 + 1]] < a[seg[k * 2 + 2]]){\n\t\t\tseg[k] = seg[k * 2 + 2];\n\t\t}\n\t}\n}\n\nint get()\n{\n\treturn seg[0];\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &r, &l);\n\tfor (int i = 1; i <= r; i++){\n\t\tscanf(\"%d %d %d\", d + i, t + i, x + i);\n\t}\n\tt[r + 1] = l;\n\t\n\tinit();\n\tfor (int i = 1; i <= r + 1; i++){\n\t\tsum[get()] += t[i] - t[i - 1];\n\t\tadd(d[i] - 1, x[i]);\n\t}\n\t\n\tint maxi = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (sum[maxi] < sum[i]) maxi = i;\n\t}\n\tprintf(\"%d\\n\", maxi + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <queue>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <functional>\n#include <climits>\n \nusing namespace std;\n#define pr(...) do { _ost << #__VA_ARGS__ << \" = \"; ~(_ost,__VA_ARGS__); } while(0);\nostream & _ost = cout;\ntemplate <class T>\nostream &operator,(ostream& ost, const T& value) { return ost << value << \",\"; }\nostream &operator~(ostream& ost) { return ost << endl; }\ntemplate <class T>\nstring tos(const T& var){ ostringstream ss; ss << var; return ss.str(); }\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,a,b) for(int i=(a); i<(b); i++)\n#define RALL(c) (c).rbegin(), (c).rend()\n \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned uint;\ntypedef unsigned long ul;\ntypedef unsigned long long ull;\n \nconst int mod = 1000000007;\nconst int INF = 1000000;\nconst double EPS = 1e-10;\n\nint main(){\n\n    int n,r,l;cin>>n>>r>>l;\n    vector<int> point(n+1);\n\n    typedef pair<int,int> range;\n    vector<range> seg;\n\n    int pt=0;\n    int pd=1;\n\n    FOR(i,0,r){\n        int d,t,x;cin>>d>>t>>x;\n        point[d]+=x;\n\n        auto m=max_element(ALL(point));\n        int md = m-point.begin();\n        //cout<<md<<endl;\n        seg.push_back(make_pair(t-pt,pd));\n        pd=md;\n        pt=t;\n    }\n    auto m=max_element(ALL(point));\n    int mt=m-point.begin();\n    seg.push_back(make_pair(l-pt,mt));\n\n    // FOR(i,0,seg.size()){\n    //     cout<<seg[i].first<<\" \"<<seg[i].second<<endl;\n    // }\n    //cout<<(int)(max_element(ALL(time))-time.begin())<<endl;\n\n    vector<int> t(n+1);\n    for(auto&e:seg){\n        t[e.second]+=e.first;\n    }\n    cout<<max_element(ALL(t))-t.begin()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n\n  score[0].first = -1000000000;  \n\n \n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  d = 1;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1+1<= N &&( score[2*site1] > score[site1] || score[2*site1+1] > score[site1])) {\n\t  //cout <<\"ko\"<<endl;\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[site1*2+flg];\n\t  score[site1*2+flg] = tmp;\n\t  site1 = site1*2+flg;\n\t}else break;\n      }\n    }\n    /*for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;*/\n\n  }\n\n\n  time[score[1].second] += L-t;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<cstring>\n\nusing namespace std;\ntypedef long long ll;\nint N=1<<17;\nll dat[1<<18];\nint id[1<<18];\nint n,r,l;\nint d[1000001],t[1000001],x[1000001];\nint timel[100001];\n\nvoid init(){\n\tmemset(dat,0,sizeof(dat));\n\tfor(int i=N;i<N*2;i++)id[i]=i-N;\n}\n\nvoid update(int k,ll a){\n\tk+=N-1;\n\tdat[k]+=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tif(dat[k*2+1]>=dat[k*2+2]){\n\t\t\tdat[k]=dat[k*2+1];\n\t\t\tid[k]=id[k*2+1];\n\t\t}else{\n\t\t\tdat[k]=dat[k*2+2];\n\t\t\tid[k]=id[k*2+2];\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(int i=0;i<r;i++)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\tint nt=0;\n\tinit();\n\tfor(int i=0;i<r;i++){\n\t\ttimel[id[0]]+=t[i]-nt;\n\t\tnt=t[i];\n\t\tupdate(d[i],x[i]);\n\t}\n\ttimel[id[0]]+=l-nt;\n\tint sum=0,rid=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(sum<timel[i])sum=timel[i],rid=i;\n\t}\n\tprintf(\"%d\\n\",rid+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = long long int;\n\nconst i64 MAX_N = 1ll << 20;\nconst i64 INF = 1e12;\n\nstruct Node{\n    i64 id, point;\n    bool operator<(const Node &obj)const{\n        if(point == obj.point)return id > obj.id;\n        return point < obj.point;\n    }\n};\n\ni64 n, times[MAX_N]={0};\nNode dat[2*MAX_N-1];\n\nvoid init(i64 n_){\n    n = 1;\n    while(n < n_)n *= 2;\n    for(i64 i=0;i<2*n-1;i++)dat[i] = (Node){INF, -INF};\n    for(i64 i=0;i<n_;++i)dat[i+n-1] = (Node){i, 0};\n}\n\nvoid update(i64 k, i64 a){\n    k += n - 1;\n    dat[k].point += a;\n    while(k > 0){\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k*2 + 1], dat[k*2 + 2]);\n    }\n}\n\nNode query(i64 a, i64 b, i64 k, i64 l, i64 r){\n    if(r <= a || b <= l)return (Node){INF, -INF};\n\n    if(a <= l && r <= b)return dat[k];\n    else{\n        Node vl = query(a, b, k*2+1, l, (l+r)/2);\n        Node vr = query(a, b, k*2+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n}\n\nint main(){\n    i64 N, R, L;\n    cin >> N >> R >> L;\n    init(N);\n    i64 team = 0, prev_time = 0;\n    for(int i=0;i<R;++i){\n        i64 d, t, x;\n        cin >> d >> t >> x;\n        times[team] += (t - prev_time);\n        prev_time = t;\n        update(d-1, x);\n        Node top = query(0, N, 0, 0, N);\n        team = top.id;\n    }\n    times[team] += (L - prev_time);\n\n    i64 maxi = LLONG_MIN, max_team = 0;\n    for(int i=0;i<N;++i){\n        if(times[i] > maxi){\n            maxi = times[i];\n            max_team = i;\n        }\n    }\n\n    cout << max_team + 1 << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//--------------------------------------------------\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<ctime>\n\nusing namespace std;\n\n//conversion\n//--------------------------------------------------\ninline int toInt(const string &s){\n    int v;istringstream sin(s);sin>>v;\n    return v;\n}\ntemplate<class T> inline string toString(T x){\n    ostringstream sout;sout<<x;\n    return sout.str();\n}\n\n//math\n//--------------------------------------------------\ntemplate<class T> inline T sqr(T x){return x*x;}\n\n//typedef\n//--------------------------------------------------\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n\n//container util\n//--------------------------------------------------\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//--------------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------------\nconst int INF=1e9+7;\nconst int dx[]={0,-1,0,1};\nconst int dy[]={-1,0,1,0};\n\n//clear memory\n#define CLR(a) memset((a),0,sizeof(a))\n\n//debug\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\"(L\"<<__LINE__<<\")\"<<endl\n\n//---------------------------------------------------\nstruct data{\n    int p,n;\n    data(int a,int b):p(a),n(b){}\n    data(){}\n    bool operator<(const data &d)const{\n        return p!=d.p?p<d.p:n>d.n;\n    }\n};\n\nint N,R,L;\nint d[1000000];\nint t[1000000];\nint x[1000000];\n\nint solve(){\n    int Point[100000]={0};\n    int Total[100000]={0};\n    priority_queue<data>Q;\n    REP(i,N)Q.push(data(0,i));\n    int prev=0;\n    REP(i,R+1){\n        while(Q.top().p!=Point[Q.top().n])Q.pop();\n        if(i==R){\n            Total[Q.top().n]+=L-prev;\n            break;\n        }\n        Total[Q.top().n]+=t[i]-prev;\n        prev=t[i];\n        Point[d[i]]+=x[i];\n        Q.push(data(Point[d[i]],d[i]));\n    }\n\n    int mav,mac=0;\n    REP(i,N){\n        if(Total[i]>mac){\n            mac=Total[i];\n            mav=i;\n        }\n    }\n    return mav+1;\n}\n\nint main(){\n    cin>>N>>R>>L;\n    REP(i,R)cin>>d[i]>>t[i]>>x[i],d[i]--;\n    cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int length[100005] = {};\n    int point[100005] = {};\n    int N, R, L;\n\n    set < pair < int , int > > st; //point -idx\n\n    cin >> N >> R >> L;\n\n    for ( int i = 0; i < N; i++ ) {\n        st.insert(make_pair(0, -i));\n    }\n    int before = 0;\n    while ( R > 0 ) {\n        int d, t, x;\n        cin >> d >> t >> x; --d;\n\n        length[-(rbegin(st) -> second)] += (t - before);\n        st.erase(make_pair(point[d], -d));\n        point[d] += x;\n        st.insert(make_pair(point[d], -d));\n\n\n        R--, before = t;\n    }\n\n    length[-(rbegin(st) -> second)] += (L - before);\n\n    int maxp = 0;\n    for ( int i = 1; i < N; i++ ) {\n        if ( length[i] > length[maxp] ) {\n            maxp = i;\n        }\n    }\n    cout << maxp + 1 << endl;\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\nconst int MAX_N = 1<<20;\n\nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = -INF;\n        dat[i].se = -(i-n+1);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(-INF, n-1);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\trep(i, n) update(i, INF);\n\tvi v(n, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\t//cout<<-p.se<<endl;\n\t\tv[-p.se] = t-tt;\n\t\ttt = t;\n\t\tupdate(d-1, x);\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] = l-tt;\n\tint ans = 0;\n\tfor(int i = 1; i < v.size(); i++){\n\t\tif(v[ans] < v[i]) ans = i;\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[125010];\nstruct node {\n    int id, point;\n} node[1<<21];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\tnowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<30;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -INF);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tteam[k] = P(a, k - n + 1);\n\t\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[d + n - 2].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[team[0].second] += (l - t);\n\t\n\tint rank[100010] = {0};\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i){\n\t\tif(rank[i] == p[0]){\n\t\t\tcout << i + 1 << endl;\n            return 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct dat{ int id, point; };\n#define MAX_N 100000\n\nint N, R, L;\nint res[MAX_N + 1];\ndat seg[MAX_N * 2];\nint n;\n\nvoid init(){\n\tn = 1;\n\twhile(n < N) n *= 2;//nはseg木の要素数\n\tfor(int i = 0; i < 2 * n - 1; i++) seg[i].point = 0;\n\tfor(int j = 0; j <= N; j++){\n\t\tseg[n + j].id = j;\n\t}\n}\n\nvoid add(int p, int x){\n\tp += n;\n\tseg[p].point += x;\n\twhile(p > 0){\n\t\t//printf(\"p = %d\\n\", p);\n\t\tp = (p - 1) / 2;\n\t\tif(seg[p * 2 + 1].point >= seg[p * 2 + 2].point){\n\t\t\tseg[p] = seg[p * 2 + 1];\n\t\t}\n\t\telse{\n\t\t\tseg[p] = seg[p * 2 + 2];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\tinit();\n\t\n\tint lb = 0;//左端\n\tint d, t, x;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tif(i > 0) res[seg[0].id] += t - lb;\n\t\tadd(d, x);\n\t\tlb = t;\n\t\t//for(int i = 1; i <= N; i++){\n\t\t//\tprintf(\"%d \", res[i]);\n\t\t//}\n\t\t//printf(\": seg[0].id = %d\\n\", seg[0].id);\n\t}\n\tres[seg[0].id] += L - t;\n\t\n\tint longest = 0;//最長の映り時間\n\tfor(int i = 1; i <= N; i++) longest = max(longest, res[i]);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(res[i] == longest){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct team { int id, score, time; };\ntypedef pair<int, int> P;\n\nP seg[200001 * 2];\nteam prog[100001];\nint N, R, L;\n\nvoid init();\nvoid update(int key, int data, int t);\n\nint main()\n{\n\tscanf(\"%d %d %d\", &N, &R, &L);\n\tinit();\n\tint last = 0;\n\twhile (R-- > 0){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tupdate(d - 1, x, t);\n\t}\n\tupdate(0, 0, L);\n\tint maxi = 0;\n\tfor (int i = 1; i < N; i++){\n\t\tif (prog[maxi].time < prog[i].time) maxi = i;\n\t}\n\tprintf(\"%d\\n\", prog[maxi].id);\n}\n\nvoid init()\n{\n\tint n = 1;\n\t\n\twhile (n < N) n *= 2;\n\tfor (int i = 0; i < N; i++){\n\t\tprog[i].id = i + 1;\n\t}\n\tfor (int i = N; i < n; i++){\n\t\tprog[i].id = INT_MAX;\n\t}\n\tfor (int i = n - 1; i < n - 1 + N; i++){\n\t\tseg[i].second = i - n + 2;\n\t}\n\tfor (int i = (n - 1) + N; i < (n - 1) * 2; i++){\n\t\tseg[i].second = i - n + 2;\n\t\tseg[i].first = INT_MIN;\n\t}\n\tN = n;\n}\n\nvoid update(int key, int data, int t)\n{\n\tstatic int last = 0;\n\tstatic int l_id = 1;\n\t\n\tseg[key + N - 1].first += data;\n\tprog[l_id - 1].time += t - last;\n\t\n\tfor (int c = key + N - 1; c != 0; c = (c - 1) / 2){\n\t\tint other = c % 2 == 0 ? c - 1 : c + 1;\n\t\t\n\t\tif (seg[c].first > seg[other].first) seg[(c - 1) / 2] = seg[c];\n\t\telse if (seg[c].first < seg[other].first) seg[(c - 1) / 2] = seg[other];\n\t\telse if (seg[c].second < seg[other].second) seg[(c - 1) / 2] = seg[c];\n\t\telse seg[(c - 1) / 2] = seg[other];\n\t}\n\t\n\tlast = t;\n\tl_id = seg[0].second;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\n//const int N=131072; // AC\n//const int N=131071; // WA\nconst int N=130600; // WA\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long int L;\ntypedef pair<L,L> P;\n\nint main(){ L n,r,l,d,t,x,i,pt=0,w=0,wt=0,m; cin>>n>>r>>l;\n    vector<L> tp(n,0),p(n,0);\n    priority_queue<P> que;\n    for(i=0;i<n;i++){\n        que.push(P(i,0));\n    }\n    P q;\n    for(i=0;i<r;i++){\n        cin>>d>>t>>x;\n        d--;\n        p[d] += x;\n        tp[w] += t-pt;\n        que.push(P(p[d],-d));\n        while( (q = que.top()).first != p[-q.second] ) que.pop();\n        wt = q.first;\n        w = -q.second;\n        pt = t;\n    }\n    tp[w] += l-pt;\n    w = 0;m = 0;\n    for(i=0;i<n;i++){\n        if(tp[i] > m){\n            m = tp[i];\n            w = i;\n        }\n    }\n    cout << w+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * 100001];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -1000000);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n    team[k] = P(a, -(k - n + 1));\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[-team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[n + d - 2].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[-team[0].second] += (l - t);\n\t\n    for(int i = 0; i < m; ++i)\n        cout << p[i] << endl;\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100001, MAX_R = 1000002;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    rs[0] = {0, 0, 0};\n    rs[R+1] = {0, L, 0};\n    REP(i, R){\n        std::cin >> rs[i+1].d >> rs[i+1].t >> rs[i+1].x;\n    }\n\n    int prev = 0, ts[MAX_N];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R+2){\n        //printf(\"%d, %d\\n\", i, rs[i].t);\n        if(i+1 > R+1 || rs[i].t < rs[i+1].t){\n            //printf(\"%d: +%d %d %d\\n\", st.root().second, rs[i].t - prev, rs[i].t, prev);\n            ts[st.root().second] += rs[i].t - prev;\n        }\n        st.update(rs[i].d, rs[i].x);\n        prev = rs[i].t;\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = -1;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    //std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint N, R, L, x[1000000], y[1000000], D[1000000], T[1000000], X[1000000], maxn, maxid;\nint main() {\n\tcin >> N >> R >> L;\n\tfor (int i = 1; i <= R; i++) {\n\t\tcin >> D[i] >> T[i] >> X[i];\n\t}\n\tD[0] = 1; T[0] = 0; X[0] = 0;\n\tD[R + 1] = 0; T[R + 1] = L; X[R + 1] = 0;\n\tfor (int i = 0; i <= R + 1; i++) {\n\t\tif (i >= 1) {\n\t\t\tmaxn = -1000000000;\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tif (x[j] > maxn) { maxn = x[j]; maxid = j; }\n\t\t\t}\n\t\t\ty[maxid] += T[i] - T[i - 1];\n\t\t}\n\t\tx[D[i]] += X[i];\n\t}\n\tmaxn = -1000000000;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (maxn < y[i]) { maxn = y[i]; maxid = i; }\n\t}\n\tcout << maxid << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100000, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n    }\n\n    int prev = 0, ts[MAX_N+1];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R){\n        if(i+1 > N || rs[i].t < rs[i+1].t){\n            ts[st.root().second] += rs[i].t - prev;\n            prev = rs[i].t;\n        }\n        st.update(rs[i].d, rs[i].x);\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = -1;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct SegmentTree{\n  typedef pair<int, int> Pi;\n  const int INF = (1 << 30);\n  vector<Pi> data;\n  int sz;\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz *= 2;\n    data.resize(2*sz-1, Pi(-1, -1));\n  }\n  void update(int k, int x)\n  {\n    int id = -k;\n    k += sz - 1;\n    data[k].first += x;\n    data[k].second = id;\n    while(k > 0){\n      k = (k - 1) / 2;\n      data[k] = max(data[2*k+1], data[2*k+2]);\n    }\n  }\n};\n\nint main()\n{\n  int N, R, L;\n  cin >> N >> R >> L;\n  SegmentTree seg(N);\n  for(int i = 0; i < N; i++) seg.update(i, 1);\n  vector<int> tv(N, 0);\n  int cur = 0, elp = 0;\n  while(R--){\n    int d, t, x;\n    cin >> d >> t >> x;\n    --d;\n    seg.update(d, x);\n    tv[cur] += t - elp;\n    cur = -seg.data[0].second;\n    elp = t;\n  }\n  tv[cur] += L - elp;\n  cout << max_element(tv.begin(), tv.end()) - tv.begin() + 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> p;\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\np rmq[1111111];\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-2;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      team[smp-1] += t[i] - now;\n      if(t[i] != t[i+1]){ \n\tnow = t[i];\n      }\n    }\n    smp = rmq[0].second;\n  }\n  team[smp-1] += L - now;\n  int a=0;\n  int ans=1;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100001)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\nint n_;\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int score[4*MAX_N -1],time[4*MAX_N -1];\n  int r,l,n;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  n_=n;\n  n=1;\n  while(n<n_) n*=2;\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    //printf(\"k=%d\\n\",k);\n    updata(time, k, time[k+n-2]+t, n);\n\n    //printf(\"b\\n\");\n    updata(score, d, score[d+n-2]+x, n);\n  \n\n    /*printf(\"c\");\n    \n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n-1;i<n*2-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n      }*/\n    \n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-2]+t, n);\n\n  /*\n  printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-2;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n-1) return k-n+2; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  else if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000001;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tint f = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tTime[L] = takai[1]; \n\tTeam[L] = takai_n[1];\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1 ){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\t\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tcout << Team_max[i] << endl;\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct mypq: priority_queue<pii>{\n\tusing priority_queue<pii>::c;\n};\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tmypq pq;\n\tint n, r, l, d, t, x, u = 0;\n\tscanf(\"%d%d%d\", &n, &r, &l);\n\tpq.c.reserve(n + r);\n\tvector<int> s(n + 1), c(n + 1);\n\tfor(int i = 1; i <= n; ++i){\n\t\tpq.c.push_back(pii(0, ~i));\n\t}\n\tfor(int i = 0; ; ++i){\n\t\tif(i == r){\n\t\t\tt = l;\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\t}\n\t\twhile(1){\n\t\t\tconst pii &p = pq.c[0];\n\t\t\tif(s[~p.second] == p.first){\n\t\t\t\tc[~p.second] += t - u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t\tif(i == r){\n\t\t\tbreak;\n\t\t}\n\t\ts[d] += x;\n\t\tpq.push(pii(s[d], ~d));\n\t\tu = t;\n\t}\n\tint ans = max_element(c.begin(), c.end()) - c.begin();\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000000;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\tcout << Team_max[temp1] << endl; \n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\tif(Time[i] > 0) n =i;\n\t\tif(i == L)Team_max[temp1] += L-n;\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\nconst int MAX_N = 1 << 7;\nint n;\npii dat[2 * MAX_N - 1];\n\nvoid init(int n_)\n{\n\tn = 1;\n\twhile (n < n_)n *= 2;\n\tfor (int i = 0; i < 2 * n - 1; i++)dat[i] = pii(INT_MAX,0);\n}\n\nvoid update(int k, pii a)\n{\n\tk += n - 1;\n\tdat[k] = a;\n\twhile (k > 0)\n\t{\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\npii query(int a, int b, int k, int l, int r)\n{\n\tif (r <= a || b <= l)return pii(INT_MAX,0);\n\tif (a <= l&&r <= b)return dat[k];\n\telse\n\t{\n\t\tpii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\n\npii calc(int a, int b)//[a,b)\n{\n\treturn query(a, b, 0, 0, n);\n}\n\nsigned main()\n{\n\tint r, l;\n\tcin >> n >> r >> l;\n\tint ans[100001] = {};\n\tinit(n);\n\tfor (int i = 0; i < n; i++)update(i, pii(0,i));\n\tint b = 0;\n\twhile (r--)\n\t{\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x; d--;\n\t\tans[calc(0, n).second] += t-b;\n\t\tb = t;\n\t\tpii p = dat[d+ n - 1];\n\t\tp.first -= x;\n\t\tupdate(d , p);\n\t}ans[calc(0, n).second] += l - b;\n\tint p = -1, id = 0;\n\tfor (int i = n-1; i >= 0; i--)\n\t{\n\t\tif (ans[i] >= p)\n\t\t{\n\t\t\tp = ans[i];\n\t\t\tid = i + 1;\n\t\t}\n\t}\n\n\n\tcout << id << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define INF (1 << 30)\n#define INFL (1LL << 62)\n#define MOD7 1000000007\n#define MOD9 1000000009\n#define EPS 1e-10\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pul pair<ull, ull>\n#define all(a) (a).begin(), (a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);--i)\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nvoid YES() { cout << \"YES\" << endl; }\nvoid NO() { cout << \"NO\" << endl; }\nvoid Yes() { cout << \"Yes\" << endl; }\nvoid No() { cout << \"No\" << endl; }\nvoid yes() { cout << \"yes\" << endl; }\nvoid no() { cout << \"no\" << endl; }\nvoid Taka() { cout << \"Takahashi\" << endl; }\nvoid Aoki() { cout << \"Aoki\" << endl; }\nvoid digit(int d) { cout << fixed << setprecision(d); }\nvoid IOup() { cin.tie(0); ios::sync_with_stdio(false); }\n\nclass RMQ {\n\tvector<pii> data;\n\tint size;\n\tint suffix;\n\npublic:\n\tRMQ() {}\n\tRMQ(int n) {\n\t\tsuffix = -1;\n\t\tresize(n);\n\t}\n\n\tvoid resize(int n) {\n\t\tsize = 1;\n\t\twhile (size < n) {\n\t\t\tsize <<= 1;\n\t\t}\n\t\tdata.resize(size * 2 - 1);\n\t\tfor (int i = n - 1; i < size * 2 - 1; ++i) {\n\t\t\tdata[i] = pii(0, i - (n - 1));\n\t\t}\n\t}\n\n\tpii& operator[](int i) {\n\t\tupdate();\n\t\tsuffix = i;\n\t\treturn data[i + size - 1];\n\t}\n\n\tvoid update() {\n\t\tif (suffix < 0)\n\t\t\treturn;\n\t\tint k = suffix + size - 1;\n\t\tsuffix = -1;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdata[k] = std::min(data[k * 2 + 1], data[k * 2 + 2]);\n\t\t}\n\t}\n\n\tpii min(int a, int b) {\n\t\tupdate();\n\t\tsuffix = -1;\n\t\treturn min(a, b, 0, 0, size);\n\t}\n\n\tpii min(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)\n\t\t\treturn pii(0, INF);\n\t\tif (a <= l && r <= b)\n\t\t\treturn data[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(min(a, b, k * 2 + 1, l, m), min(a, b, k * 2 + 2, m, r));\n\t}\n};\n\nint tt[100001];\n\nint main() {\n\tint n, r, l, d, b, t, x;\n\tcin >> n >> r >> l;\n\tRMQ p(n + 1);\n\t\n\tb = 0;\n\tfor (int i = 0; i < r; ++i) {\n\t\tcin >> d >> t >> x;\n\t\tauto tmp = p.min(1, n + 1);\n\t\ttt[tmp.second] += t - b;\n\t\tp[d].first -= x;\n\t\tb = t;\n\t}\n\ttt[p.min(1, n + 1).second] += l - b;\n\t\n\tint m = 0, ans;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (m < tt[i]) {\n\t\t\tm = tt[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\nconst int MAX_N = 1<<18;\nint n;\npii dat[2 * MAX_N - 1];\n\nvoid init(int n_)\n{\n\tn = 1;\n\twhile (n < n_)n *= 2;\n\tfor (int i = 0; i < 2 * n - 1; i++)dat[i] = pii(INT_MAX,0);\n}\n\nvoid update(int k, pii a)\n{\n\tk += n - 1;\n\tdat[k] = a;\n\twhile (k > 0)\n\t{\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\npii query(int a, int b, int k, int l, int r)\n{\n\tif (r <= a || b <= l)return pii(INT_MAX,0);\n\tif (a <= l&&r <= b)return dat[k];\n\telse\n\t{\n\t\tpii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\n\npii calc(int a, int b)//[a,b)\n{\n\treturn query(a, b, 0, 0, n);\n}\nint ans[200000] = {};\nsigned main()\n{\n\tint r, l;\n\tcin >> n >> r >> l;\n\t\n\tinit(n);\n\tfor (int i = 0; i < n; i++)update(i, pii(0,i));\n\tint b = 0;\n\twhile (r--)\n\t{\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x; d--;\n\t\tans[calc(0, n).second] += t-b;\n\t\tb = t;\n\t\tpii p = dat[d+ n - 1];\n\t\tp.first -= x;\n\t\tupdate(d , p);\n\t}ans[calc(0, n).second] += l - b;\n\tint p = -1, id = 0;\n\tfor (int i = n-1; i >= 0; i--)\n\t{\n\t\tif (ans[i] >= p)\n\t\t{\n\t\t\tp = ans[i];\n\t\t\tid = i + 1;\n\t\t}\n\t}\n\n\n\tcout << id << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\nusing namespace std;\n\nP segment[262143];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d+1-e]=P(1<<29,1<<29);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;cin>>x>>y>>z;\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\t\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(1<<29),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define all(a) a.begin(),a.end()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\n\nstruct Segtree {\n\tint n;\n\tvpii dat;\n\n\tvoid init(int n_) {\n\t\tn = 1;\n\n\t\twhile (n < n_) n *= 2;\n\n\t\tdat.resize(2 * n);\n\n\t\tfor (int i = 0; i < 2 * n - 1; ++i) dat[i] = pii(0, -inf);\n\t}\n\n\tvoid update(int a, int x) {\n\t\tint idx = a;\n\t\ta += n - 1;\n\n\t\tdat[a].fst += x;\n\t\tdat[a].scd = -idx;\n\n\t\twhile (a > 0) {\n\t\t\ta = (a - 1) / 2;\n\t\t\tdat[a] = max(dat[a * 2 + 1], dat[a * 2 + 2]);\n\t\t}\n\t}\n\n\tpii get_max() {\n\t\treturn dat[0];\n\t}\n};\n\ntypedef pair<int, pair<int, int> > Query;\n\nint res[100010];\n\nsigned main()\n{\n\tomajinai;\n\n\tint N, R, L; cin >> N >> R >> L;\n\n\tSegtree seg;\n\tseg.init(N);\n\n\tvector<Query> queries(R);\n\n\trep(i, R) {\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\n\t\t-- d;\n\n\t\tqueries[i] = Query(t, pii(d, x));\n\t}\n\n\tqueries.PB(Query(L, pii(0, 0)));\n\t\n\tsort(all(queries));\n\n\trep(i, R) {\n\t\tQuery query = queries[i];\n\t\tQuery next_query = queries[i + 1];\n\n\t\tseg.update(query.scd.fst, query.scd.scd);\n\n\t\tif (query.fst != next_query.fst) {\n\t\t\tres[-seg.get_max().scd] += next_query.fst - query.fst;\n\t\t}\n\t}\n\n\tint ma = -1;\n\tint ans = -1;\n\n\trep(i, N) {\n\t\tif (ma < res[i]) {\n\t\t\tma = res[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tcout << ans + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tvi v(n + 100, 0);\n\tinit(n);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\n\nint p[1000005];\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<int> dat,id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(2*n-1);\n\t\trep(i,2*n-1) dat[i] = -INF;\n\n\t\tid.resize(2*n-1);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] += a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\t//time id,point\n\tmap<int,vector<pair<int,int> > > m;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tm[t].push_back(make_pair(d,x));\n\t}\n\n\tvector<int> v(n+1);\n\tmemset(p,0,sizeof(p));\n\tSeg seg(n);\n\n\tint top_id = 0,top_p = 0,pre_time = 0;\n\tmap<int,vector<pair<int,int> > >::iterator ite;\n\tfor(ite = m.begin(); ite != m.end(); ite++)\n\t{\n\t\tint d,t,x;\n\t\tt = ite->first;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\trep(i,m[t].size())\n\t\t{\n\t\t\td = m[t][i].first;\n\t\t\tx = m[t][i].second;\n\n\t\t\t// p[d] += x;\n\t\t\t// seg.update(d-1,p[d]);\n\t\t\tseg.update(d-1,x);\n\t\t\ttop_id = seg.id[0];\n\t\t}\n\n\t}\n\n\tv[top_id] += l - pre_time;\n\n\tint res = 0;\n\trep(i,n)\n\t{\n\t\tres = max(res,v[i]);\n\t}\n\n\trep(i,n)\n\t{\n\t\tif(res == v[i])\n\t\t{\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int, int>;\nusing P3 = pair<int, P>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1 << 30;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int di[] = {0, 1, 0, -1};\nconstexpr int dj[] = {1, 0, -1, 0};\n\nstruct RMQ{\n    int N;\n    vector<P> node;\n    void init(int n){\n        N = 1;\n        while(N<n) N<<=1;\n        node.assign(N*2-1,{0,0});\n    }\n    void update(int k, P x){\n        k += N-1;\n        node[k] = x;\n        while(k > 0){\n            k = (k-1)/2;\n            node[k] = max(node[k*2+1],node[k*2+2]);\n        }\n    }\n    P query(int a, int b){return query(a, b, 0, 0, N);}\n    P query(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return {-INF,-INF};\n        if(a <= l && r <= b) return node[k];\n        return max(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n    }\n};\n\nRMQ rmq;\n\nbool solve(){\n    int N, R, L;\n    cin >> N >> R >> L;\n    rmq.init(N);\n    for(int i=0;i<N;i++){\n        rmq.update(i,P(0,-i));\n    }\n    int tp = 0;\n    vector<int> cnt(N);\n    for(int i=0;i<R;i++){\n        int d, t, x;\n        cin >> d >> t >> x;\n        d--;\n        int id = abs(rmq.query(0,N).second);\n        cnt[id] += t-tp;\n        tp = t;\n        P tmp = rmq.query(d,d+1);\n        tmp.first += x;\n        rmq.update(d,tmp);\n    }\n    cnt[abs(rmq.query(0,N).second)] += L-tp;\n    int ans = 0, maxi = 0;\n    for(int i=0;i<N;i++){\n        if(cnt[i] > maxi){\n            maxi = cnt[i];\n            ans = i+1;\n        }\n    }\n    cout << ans << endl;\n    return false;\n}\n\nint main() {\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[n];\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,0);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    \n    priority_queue<Team> que;\n    \n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams+1);\n\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      seg_tree.insert(id,point);\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += time - prev_time;\n\tprev_time = time;\n\tprev_champ = team.id;\n      }\n    }\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX_N = 1 << 17;\n\ntypedef pair<int, int> P;\n\nint n, cnt[MAX_N];\nP dat[2*MAX_N-1];\n\nvoid init(int n_){\n  n = 1;\n  while(n < n_) n *= 2;\n  for(int i=0;i<2*n-1;i++) dat[i] = make_pair(INT_MAX, INT_MAX);\n}\n\nvoid update(int k, P a){\n  k += n - 1;\n  dat[k] = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = min(dat[k*2+1], dat[k*2+2]);\n  }\n}\n\n//min [a, b)\n//call query(a, b, 0, 0, n)\nP query(int a, int b, int k, int l, int r){\n  if(r <= a || b <= l) return make_pair(INT_MAX, INT_MAX);\n  if(a <= l && r <= b) return dat[k];\n  else{\n    P vl = query(a, b, k*2+1, l, (l+r)/2);\n    P vr = query(a, b, k*2+2, (l+r)/2, r);\n    return min(vl, vr);\n  }\n}\n\nint main(){\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\tmemset(cnt, 0, sizeof(cnt));\n\tinit(N);\n\tfor(int i=0;i<N;i++) update(i, make_pair(0, i));\n\tint T = 0;\n\tfor(int i=0;i<R;i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\td--;\n\t\tif(T != t){\n\t\t\tP tmp = query(0, N, 0, 0, n);\n\t\t\tcnt[tmp.second] += t - T;\n\t\t}\n\t\tP tmp = query(d, d + 1, 0, 0, n);\n\t\tupdate(d, make_pair(tmp.first - x, tmp.second));\n\t\tT = t;\n\t}\n\tif(T != L){\n\t\tP tmp = query(0, N, 0, 0, n);\n\t\tcnt[tmp.second] += L - T;\n\t}\n\tint valM = -1, id;\n\tfor(int i=0;i<N;i++){\n\t\tif(valM < cnt[i]){\n\t\t\tvalM = cnt[i];\n\t\t\tid = i;\n\t\t}\n\t}\n\tcout << id + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define MAX 1111111\n#define MIN -1111111\ntypedef pair<int,int> P;\nvoid init(int n);\nvoid update(int k,int x);\nP maxx(int k1,int k2);\nP dat[2*100000];\nint tim[100001]={0};\nint N;\n\nint main(){\n  int R,L;\n  cin >> N >> R >> L;\n  int n_tmp = N;\n  init(N);\n  memset(tim,0,n_tmp+1);\n  int now = 0;\n  dat[0]=P(MIN,1);\n  for(int i=0;i<R;i++){\n    int d,t,x;\n    cin >> d >> t >> x;\n    tim[dat[0].second] += t - now;\n    update(d,x);\n    now = t;\n  }\n  tim[dat[0].second] += L - now;\n  int *ans = max_element(tim,tim+n_tmp+1);\n  cout << ans - tim << endl;\n}\n\nvoid init(int n){\n  N=1;\n  while(N<n) N*=2;\n  for(int i=0;i<2*N-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n  for(int i=N-1;i<N-1+n;i++){\n    dat[i]=P(0,i-(N-2));\n  }\n  return;\n}\n\nvoid update(int k,int x){\n  k += N - 2;\n  P p = dat[k];\n  int score = p.first;\n  int team = p.second;\n  //cout << score << \" \" << team << endl;\n  dat[k] = P(score+x,team);\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = maxx(k*2+1,k*2+2);\n    //cout << dat[k].first << \" \" << dat[k].second << endl;\n  }\n  return;\n}\n\nP maxx(int k1,int k2){\n  P p;\n  if(dat[k1].first == dat[k2].first){\n    p = P(dat[k1].first,min(dat[k1].second,dat[k2].second));\n  }\n  else {\n    p = max(dat[k1],dat[k2]);\n  }\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][100000000],T=0,g,p[2][100000000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nint main() {\n    int n, r, l; cin >> n >> r >> l;\n    vector<int> d(r), t(r), x(r);\n    for(int i = 0; i < r; ++i) {\n        cin >> d[i] >> t[i] >> x[i];\n        d[i]--;\n    }\n    vector<int> score(n), ans(n);\n    priority_queue<pii> que;\n    for(int i = 0; i < n; ++i) que.emplace(0, -i);\n\n    int pre_t = 0;\n    for(int i = 0; i < r; ++i) {\n        while(score[-que.top().second] != que.top().first) que.pop();\n        ans[-que.top().second] += t[i] - pre_t;\n        score[d[i]] += x[i];\n        que.emplace(score[d[i]], -d[i]);\n        pre_t = t[i];\n    }\n    while(score[-que.top().second] != que.top().first) que.pop();\n    ans[-que.top().second] += l - pre_t;\n\n    cout << (max_element(begin(ans), end(ans)) - begin(ans) + 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAX 2000000\n#define INFTY (1<<30)\nstruct Team{\n  int id;\n  int point;\n  int showed;\n\n  Team(int ia,int ib,int ic);\n};\nint H,team[MAX+1];\nvoid swap(*a,*b){\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  elsif(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  elsif(team[r].point==team[largest].point){\n    if(team[r].id<team[largest]){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint extract(team){\n  int maxv;\n  if(H<1) return -INFTY;\n  maxv=team[1];\n  team[1]=team[H--];\n  maxHeapify(1);\n  return maxv;\n}\nvoid IncreaseKey(int i,int key){\n  team[i].point+=key;\n  while(i>1&&team[i/2]<team[i]){\n    swap(team[i],team[i/2]);\n    i=i/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H]=Team(id,0,0);\n}\nvoid show_top(team){\n  top=0;\n  for(int i=0;i<n;i++){\n    if(team[i].showed>team[top].showed) top=i;\n  }\n  printf(\"%d\\n\",top);\n}\n  \nint main(){\n  int n,r,l;\n  int d[1000000];\n  int t[1000000];\n  int x[1000000];\n  scanf(\"%d%d%d\",&n,&r,&l);\n  for(int i=0;i<n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n    IncreaseKey(d[i],x[i]);\n    top=extract(team);\n    if(i>0){\n    top.showed+=t[i]-t[i-1];\n    }\n  }\n  show_top(team);\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int MAX_N = 100010;\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, r, l;\n\tcin >> n >> r >> l;\n\n\tint score[MAX_N] = {};\n\tint time_[MAX_N] = {};\n\tint id = 0;\n\tint top = 0;\n\tint now = 0;\n\tint timemax = 0;\n\tint tmid = 0;\n\tfor(int i = 0; i < r; ++i){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\t--d;\n\t\ttime_[id] += t - now;\n\t\tif(timemax < time_[id] || (timemax == time_[id] && id < tmid)){\n\t\t\ttimemax = time_[id];\n\t\t\ttmid = id;\n\t\t}\n\t\tnow = t;\n\t\tscore[d] += x;\n\t\tif(id == d){\n\t\t\ttop += x;\n\t\t}\n\t\tif(x < 0 && id == d){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(top < score[j] || (top == score[j] && j < id)){\n\t\t\t\t\ttop = score[j];\n\t\t\t\t\tid = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(x > 0 && id != d){\n\t\t\tif(top < score[d] || (top == score[d] && d < id)){\n\t\t\t\ttop = score[d];\n\t\t\t\tid = d;\n\t\t\t}\n\t\t}\n\t}\n\ttime_[id] += l - now;\n\n\tif(timemax < time_[id] || (timemax == time_[id] && id < tmid)){\n\t\ttimemax = time_[id];\n\t\ttmid = id;\n\t}\n\n\tcout << tmid + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <map>\n#include <climits>\n#include <stack>\n#include <string>\n#include <random>\n#include<set>\n#include <iomanip>\n#include <climits>\n#include <memory>\nstruct Team {\n\tint id{ 0 }, score{ 0 };\n\tTeam() {};\n\tTeam(int i, int s) :id{ i }, score{ s }{};\n};\ntemplate<typename T, typename Compare>\nclass Heap;\nclass HeapElementHolder {\n\ttemplate<typename T, typename C>\n\tfriend class Heap;\n\tstd::shared_ptr<int> in_heap_position{nullptr};\n\tvoid invalidate() { in_heap_position = nullptr; }\n\tHeapElementHolder(std::shared_ptr<int> &ptr) :in_heap_position(ptr) {}\npublic:\n\tHeapElementHolder() {}\n\tHeapElementHolder(const HeapElementHolder &holder) :in_heap_position{ holder.in_heap_position } {};\n\tbool is_valid() const { return in_heap_position != nullptr; }\n};\n\ntemplate<typename T, typename Compare = std::function<bool(const T &, const T &)>>\nclass Heap {\n\tstd::vector<T> _elements;\n\tstd::vector<HeapElementHolder> _holders;\n\tCompare _is_prior;\n\tvoid sanitize_up(const int position) {\n\t\tif (position != 0) {\n\t\t\tauto up_pos = (position - 1) >> 1;\n\t\t\tauto up = upper(up_pos, (up_pos << 1) + 1, (up_pos << 1) + 2);\n\t\t\tif (up == position) {\n\t\t\t\tswap(up_pos, position);\n\t\t\t\tsanitize_up(up_pos);\n\t\t\t}\n\t\t}\n\t}\n\tvoid sanitize_down(const int position) {\n\t\tauto d = down(position, (position << 1) + 1, (position << 1) + 2);\n\t\tif (d != position) {\n\t\t\tswap(d, position);\n\t\t\tsanitize_down(d);\n\t\t}\n\t}\n\tvoid swap(const int a, const int b) {\n\t\t*_holders[a].in_heap_position = b;\n\t\t*_holders[b].in_heap_position = a;\n\t\tauto element = _elements[a];\n\t\t_elements[a] = _elements[b];\n\t\t_elements[b] = element;\n\t\tauto holder = _holders[a];\n\t\t_holders[a] = _holders[b];\n\t\t_holders[b] = holder;\n \t}\n\tint upper(const int up, const int left, const int right) {\n\t\tif (left < 0) return right;\n\t\telse if (up < 0) {\n\t\t\tif (_is_prior(_elements[left], _elements[right])) return left;\n\t\t\telse return right;\n\t\t}\n\t\telse {\n\t\t\tif (_is_prior(_elements[up], _elements[left]) && _is_prior(_elements[up], _elements[right])) return up;\n\t\t\telse if (_is_prior(_elements[left], _elements[up]) && _is_prior(_elements[left], _elements[right])) return left;\n\t\t\telse return right;\n\t\t}\n\t}\n\tint down(const int up, const int left , const int right) const {\n\t\tif (left >= _elements.size()) return up;\n\t\telse if (right >= _elements.size()) {\n\t\t\tif (_is_prior(_elements[up], _elements[left])) return up;\n\t\t\telse return left;\n\t\t}\n\t\telse {\n\t\t\tif (_is_prior(_elements[up], _elements[left]) && _is_prior(_elements[up], _elements[right])) return up;\n\t\t\telse if (_is_prior(_elements[left], _elements[up]) && _is_prior(_elements[left], _elements[right])) return left;\n\t\t\telse return right;\n\t\t}\n\t}\npublic:\n\tHeap(const Compare &comp) :_is_prior{ comp } {};\n\tHeapElementHolder add(T && element) {\n\t\tauto result = HeapElementHolder();\n\t\tresult.in_heap_position = std::make_shared<int>(_elements.size());\n \t\t_elements.push_back(std::move(element));\n\t\t_holders.push_back(result);\n\t\tsanitize_up(_elements.size() - 1);\n\t\treturn result;\n\t}\n\tHeapElementHolder add(const T &element) {\n\t\tauto result = HeapElementHolder();\n\t\tresult.in_heap_position = std::make_shared<int>(_elements.size());\n\t\t_elements.push_back(element);\n\t\t_holders.push_back(result);\n\t\tsanitize_up(_elements.size() - 1);\n\t\treturn result;\n\t}\n\tvoid update(HeapElementHolder &holder, const T &value) {\n\t\tif (_is_prior(value, _elements[*holder.in_heap_position])) {\n\t\t\t_elements[*holder.in_heap_position] = value;\n\t\t\tsanitize_up(*holder.in_heap_position);\n\t\t}\n\t\telse {\n\t\t\t_elements[*holder.in_heap_position] = value;\n\t\t\tsanitize_down(*holder.in_heap_position);\n\t\t}\n\t}\n\tvoid pop() {\n\t\tswap(0, _elements.size() - 1);\n\t\t_elements.pop_back();\n\t\t_holders.pop_back();\n\t\tsanitize_down(0);\n\t}\n\tT top() const {\n\t\treturn _elements.front();\n\t}\n};\n\ntemplate<typename T, typename Compare = std::function<bool(const T &, const T &)>>\nclass PriorityArray {\n\tstd::vector<HeapElementHolder> _holders;\n\tstd::vector<T> _elements;\n\tHeap<T, Compare> heap;\npublic:\n\tPriorityArray(const int size, const T &default_value, const Compare &comp) :_holders(size), _elements(size, default_value), heap(comp) {\n\t\tfor (auto i = 0; i < size; ++i) {\n\t\t\t_holders[i] = heap.add(_elements[i]);\n\t\t}\n\t}\n\tvoid push_back(const T &value) {\n\t\t_elements.push_back(value);\n\t\t_holders.push_back(heap.add(value));\n\t}\n\tsize_t size() const {\n\t\treturn _elements.size();\n\t}\n\tvoid update(const int index, const T& value) {\n\t\t_elements[index] = value;\n\t\theap.update(_holders[index], value);\n\t}\n\tT at(const int index) {\n\t\treturn _elements[index];\n\t}\n\tconst T &at(const int index) const {\n\t\treturn _elements[index];\n\t}\n\tT top() const { return heap.top(); }\n};\nint main() {\n\tint n, r, l; std::cin >> n >> r >> l;\n\tstd::vector<int> sum_time(n, 0);\n\tauto compare = [](const Team &a, const Team &b) {return (a.score == b.score) ? a.id < b.id: a.score > b.score; };\n\tauto scores = PriorityArray<Team>(n, Team(), compare);\n\tauto prev_time = 0;\n\tfor (auto i = 0; i < r; ++i) {\n\t\tint d, t, x; std::cin >> d >> t >> x;\n\t\tsum_time[scores.top().id] += t - prev_time;\n\t\tscores.update(d - 1, Team( d - 1, x + scores.at(d - 1).score ));\n\t\tprev_time = t;\n\t}\n\tsum_time[scores.top().id] += l - prev_time;\n\tauto max_team = 0;\n\tfor (auto i = 0; i < sum_time.size(); ++i) {\n\t\tif (sum_time[max_team] < sum_time[i]) max_team = i;\n\t}\n\tstd::cout << max_team + 1 << std::endl;\n}\n\n\n/*\n\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstring>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define INIT(a) memset(a,0,sizeof(a))\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1e9+7;\n\nint v;\nP seg[4004000];\n\nvoid init(int n){\n  v = 1;\n  while(v<n)v<<=1;\n  rep(i,2*v-1)seg[i] = P(INF,INF);\n}\n\nvoid update(int x, P a){\n  x += v-1;\n  seg[x] = a;\n  while(x){\n    x = (x-1)/2;\n    seg[x] = min(seg[2*x+1],seg[2*x+2]);\n  }\n}\n\nP query(int a, int b, int k ,int l, int r){\n  if(b<=l || r<=a)return P(INF,INF);\n  if(a<=l && r<=b)return seg[k];\n  P ql = query(a,b,2*k+1,l,(l+r)/2);\n  P qr = query(a,b,2*k+2,(l+r)/2,r);\n  return min(ql,qr);\n}\n\nint main(){\n  int n,r,l;\n  int d,t,x,prv=0;\n  int len[1001000];\n\n  INIT(len);\n  cin >> n >> r >> l;\n  init(n);\n  rep(i,n)update(i,P(0,i));\n\n  rep(i,r){\n    cin >> d >> t >> x;\n    P tmp = query(0,n,0,0,v);\n    len[tmp.sc] += t-prv;\n    prv = t;\n    update(d-1,P(seg[d-1 +v-1].fs-x,d-1));\n  }\n  len[query(0,n,0,0,v).sc] += l-prv;\n\n  int ans = 0;\n  rep(i,n){\n    if(len[ans] < len[i])ans = i;\n  }\n  cout << ans+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstruct RMQ {\n  pair<int, int> DEF;\n  int n;\n  vector<pair<int, int> > d;\n  \n  RMQ(int n) {\n    DEF = make_pair(-1e9, 1e9);\n    this-> n = n;\n    d.resize(2 * n - 1);\n    rep (i, 2 * n - 1) d[i] = DEF;\n  }\n\n  void update(int k, int a) {\n    k += n - 1;\n    d[k] = make_pair(a, k - (n - 1));\n    while (k > 0) {\n      k = (k - 1) / 2;\n      d[k] = function(d[k * 2 + 1], d[k * 2 + 2]);\n    }\n  }\n\n  pair<int, int> query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return DEF;\n    if (a <= l && r <= b) return d[k];\n    pair<int, int> vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    pair<int, int> vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return function(vl, vr);\n  }\n\n  pair<int, int> query(int a, int b) {\n    return query(a, b, 0, 0, n);\n  }\n\n  pair<int, int> function(pair<int, int> l, pair<int, int> r) {\n    if (l.first > r.first) return l;\n    if (l.first < r.first) return r;\n    if (l.second < r.second) return l;\n    return r;\n  }\n};\n\nint main() {\n  int n, r, l;\n  cin >> n >> r >> l;\n  int score[n], res[n];\n  RMQ rmq(n);\n  rep (i, n) rmq.update(i, 0);\n  rep (i, n) rmq.update(i, 0);\n  rep (i, n) res[i] = 0;\n  rep (i, n) score[i] = 0;\n  int pre = 0;\n  rep (i, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    int k = rmq.query(0, n).second;\n    res[k] += t - pre;\n    --d;\n    score[d] += x;\n    rmq.update(d, score[d]);\n    pre = t;\n  }\n  int k = rmq.query(0, n).second;\n  res[k] += l - pre;\n  int mi = 0, mx = 0;\n  rep (i, n) if (mx < res[i]) {\n    mi = i;\n    mx = res[i];\n  }\n  cout << mi + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define endl '\\n'\n#define INF (1 << 21)\ntypedef long long ll;\nconst int MOD = 1000000007;\nusing namespace std;\nclass segment_tree{\npublic:\n  int n;\n  pair<ll, int>team[1 << 18];\n  \n  segment_tree(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n\n    for(int i = 0;i < 2 * n;i++){\n      team[i] = make_pair(0, 0);\n    }\n\n    for(int i = n - 1;i < 2 * n;i++){\n      team[i] = make_pair(0, i - (n - 1));\n    }\n  }\n\n  void update(int tid, int nscore){\n    tid += n - 1;\n    team[tid].first += nscore;\n    \n    while(tid > 0){\n      tid = (tid - 1) / 2;\n      if(team[tid * 2 + 1].first == team[tid * 2 + 2].first){\n\tif(team[tid * 2 + 1].second < team[tid * 2 + 2].second){\n\t  team[tid] = team[tid * 2 + 1];\n\t}else{\n\t  team[tid] = team[tid * 2 + 2];\n\t}\n      }else{\n\tteam[tid] = max(team[tid * 2 + 1], team[tid * 2 + 2]);\n      }\n    }\n  }\n};\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int num, r, l;\n  ll ftime[100005] = {};\n  int d, t, x;\n  int now = 0;\n  \n  cin >> num >> r >> l;\n  if(r != 0){\n    segment_tree seg(num);\n  \n    for(int i = 0;i < r;i++){\n      //cout << seg.team[1 + seg.n - 1].second << endl;\n      cin >> d >> t >> x;\n      ftime[seg.team[0].second] += (t - now);\n      seg.update(d - 1, x);\n      now = t;\n    }\n    \n    ftime[seg.team[0].second] += (l - now);\n    int mini = 0;\n    for(int i = 0;i < num;i++){\n      //cout << ftime[i] << ' ';\n      if(ftime[mini] < ftime[i]){\n\tmini = i;\n      }\n    }\n    cout << mini + 1 << endl;\n  }else{\n    cout << 1 << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n#define Seg_Max_N (1<<18) \n\nusing Value = pair<long long int, long long int>;\nconst Value ini = (make_pair(1e18, 0));\nstruct segtree {\n\tint N;\n\tvector<int>nums;\n\tvector<Value>dat;\n\n\tsegtree() {}\n\tsegtree(int n) :dat(2 * Seg_Max_N), nums(2 * Seg_Max_N) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1; // leaf\n\t\tif (a == ini) {\n\t\t\tnums[k]--;\n\t\t\tif (!nums[k])dat[k] = a;\n\t\t}\n\t\telse {\n\t\t\tnums[k]++;\n\t\t\tdat[k] = a;\n\t\t}\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = min(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn min(al,ar);\n\t}\n};\nint main() {\n\tint N, R, L; cin >> N >> R >> L;\n\tint pre = 0;\n\tint ntop = 0;\n\tvector<int>times(N);\n\tsegtree seg(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tseg.update(i, make_pair(0, i));\n\t}\n\tfor (int i = 0; i < R; ++i) {\n\t\tint d, t, x; cin >> d >> t >> x; d--;\n\t\tconst int top = seg.query(0, N).second;\n\t\ttimes[top] += t - pre;\n\t\tpre = t;\n\t\tseg.update(d,make_pair( -x,d));\n\t}\n\tconst int top = seg.query(0, N).second;\n\ttimes[top] += L - pre;\n\tint amax = -1;\n\tint time = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (time < times[i]) {\n\t\t\ttime = times[i];\n\t\t\tamax = i;\n\t\t}\n\t}\n\tcout << amax+ 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nvoid update(int k,int x);\npair<int, int> seg[1 << 18];\n\n\n\nint main(){\n\n  int n,r,l;\n  int d,t,x;\n  int i;\n  int team[1000];\n  int sento=0,watch=0,maxi=0;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n  for(i=0;i<n;i++) update(i,0);\n\n  for(i=0;i<r;i++){\n    scanf(\"%d %d %d\",&d,&t,&x);\n    team[sento]+=t-watch;\n    update(d-1,x);\n    sento=seg[0].second-1;\n    watch=t;\n  }\n  team[sento]+=l-watch;\n\n  for (int i=1;i<n;i++){\n    if(team[maxi]<team[i]) maxi=i;\n  }\n  printf(\"%d\\n\",maxi+1);\n  \n  return 0;\n}\n\n\n\nvoid update(int k,int x){\n  int id;\n  \n  id=k+1;\n  k += (1 << 17) - 1;\n  \n  seg[k].first+=x;\n  seg[k].second=id;\n  \n  while(k){\n    k=(k-1)/2;\n    if(seg[k*2+1].first>seg[k*2+2]) seg[k]=seg[k*2+1];\n    else if(seg[k * 2 + 1].first < seg[k * 2 + 2].first) seg[k] = seg[k * 2 + 2];\n    else  seg[k] = seg[k * 2 + 1];\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint main()\n{\n\tint n,r,l,ans[100000]={},score[100000]={};\n\tcin>>n>>r>>l;\n\tint last=0;\n\tint m=0;//????????£????????§?????????????????£?????????????????????ID\n\tfor(int i=0;i<r;i++){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x;\n\t\tscore[--d]+=x;\n\t\tif(x>=0){\n\t\t\tif(score[d]>score[m]||((score[d]==score[m])&&d<m)){\n\t\t\t\tans[m]+=t-last;\n\t\t\t\tlast=t;\n\t\t\t\tm=d;\n\t\t\t}\n\t\t}else if(m==d){\n\t\t\tint tmp=m;\n\t\t\tfor(int j=0;j<n;j++)if(score[j]>score[m]||((score[j]==score[m])&&j<m))tmp=j;\n\t\t\tif(m!=tmp){\n\t\t\t\tans[m]+=t-last;\n\t\t\t\tlast=t;\n\t\t\t\tm=tmp;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tans[m]+=l-last;\n\tint res1=0,res2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(res1<ans[i]){\n\t\t\tres1=ans[i];\n\t\t\tres2=i;\n\t\t}\n\t}\n\tres2++;\n\tcout<<res2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N, R, L;\nint score[1000000];\nint ttime[1000000];\n\nint main(){\n  int now = 0;\n  scanf(\"%d%d%d\", &N, &R, &L);\n\n  priority_queue<pair<int, int> >q;\n  q.push(MP(0, -1));\n  rep(i, R){\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x);\n    pair<int, int>p = q.top(); q.pop();\n    while(p.F != score[-p.S]){\n      q.push(MP(score[-p.S], p.S));\n      p = q.top(); q.pop();\n    }\n    q.push(MP(score[-p.S], p.S));\n    //    printf(\"%d %d\\n\", (int)q.size(), p.S);\n    ttime[-(p.S)] += t - now;\n    //    printf(\"%d %d\\n\", ttime[-(p.S)], -(p.S));\n    //    rep(j, N) printf(\"%d \", ttime[j]); puts(\"\");\n    now = t;\n    score[d] += x;\n    q.push(MP(score[d], -d));\n  }\n  pair<int, int>p = q.top(); q.pop();\n  while(p.F != score[-p.S]){\n    q.push(MP(score[-p.S], p.S));\n    p = q.top(); q.pop();\n  }\n  q.push(MP(score[-p.S], p.S));\n\n  ttime[-(p.S)] += L - now;\n  //  REP(i, 1, N+1) printf(\"%d \", score[i]); puts(\"\");\n  //  REP(i, 1, N+1) printf(\"%d \", ttime[i]); puts(\"\");\n\n  int res = 0;\n  REP(i,1, N+1) if(ttime[res] < ttime[i]) res = i;\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n int N,R,L;\n int INF = 1e9;\n\n cin >> N >> R >> L;\n\n\n pair <int,int>  score[200005];\n int time[100005];\n for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n int id[200005] = {};\n for(int i=1;i<=N;i++) {\n   score[i]=make_pair(0,i);\n   id[i] = i;\n   time[i] = 0;\n }\n \n int  mae = 0;\n \n int d,t,x;\n for(int i=0;i<R;i++) {\n   cin >> d >> t >> x;\n\n int site1 = id[d];\n   assert(site1>=1);\n   \n   time[score[1].second] += t - mae;\n   score[site1].first -= x;\n   mae = t;\n\n   if(x>0){ \n     while(site1>1) {\n       if(score[site1] < score[site1/2] ) {\n\t swap(score[site1], score[site1/2]);\n\t swap(id[site1],id[site1/2]);\n\t site1 = site1/2;\n       } else break;\n     }\n   }\n   else {\n     while(1) {\n       if( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t int flg = 0;\n\t if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t swap(score[site1],score[2*site1+flg]);\n\t swap(id[site1],id[2*site1+flg]);\n\t site1 = 2*site1+flg;\n       }else break;\n     }\n   }\n   /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n\t cout << endl;\n\t for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n\t cout << endl;\n\t for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n\t cout << endl;\n   */\n }\n \n\n time[score[1].second] += L-mae;\n \n int maxtime = -1;\n int ans;\n for(int i=1;i<=N;i++) \n   if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n // for(int i=1;i<=N;i++) cout << time[i] <<\" \";\n //cout << endl;\n \n cout << ans << endl;\n\n return 0;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<cstring>\n#define N (1<<17)\n\nusing namespace std;\ntypedef long long ll;\nll dat[1<<18];\nint id[1<<18];\nint n,r,l;\nint d[1000001],t[1000001],x[1000001];\nint timel[100001];\n\nvoid init(){\n\tmemset(dat,0,sizeof(dat));\n\tfor(int i=N;i<N*2;i++)id[i]=i-N;\n}\n\nvoid update(int k,ll a){\n\tk+=N-1;\n\tdat[k]+=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tif(dat[k*2+1]>=dat[k*2+2]){\n\t\t\tdat[k]=dat[k*2+1];\n\t\t\tid[k]=id[k*2+1];\n\t\t}else{\n\t\t\tdat[k]=dat[k*2+2];\n\t\t\tid[k]=id[k*2+2];\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(int i=0;i<r;i++)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\tint nt=0;\n\tinit();\n\tfor(int i=0;i<r;i++){\n\t\ttimel[id[0]]+=t[i]-nt;\n\t\tnt=t[i];\n\t\tupdate(d[i],x[i]);\n\t}\n\ttimel[id[0]]+=l-nt;\n\tint sum=0,rid=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(sum<timel[i])sum=timel[i],rid=i;\n\t}\n\tprintf(\"%d\\n\",rid+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n\nusing namespace std;\n\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint now=0;\n\tint gap;\n\tint max,id;\n\tint team[100001]={0};\n\tint time[100001]={0};\n\tset<int> num;\n\tset<int>::iterator it;\n\n\tcin >> N >>R >> L;\n\n\tmax=team[1];\n\tid=1;\n\twhile(R--){\n\t\tcin >>d>>t>>x;\n\t\tgap=t-now;\n\t\tnow=t;\n\t\ttime[id]+=gap;\n\t\tteam[d]+=x;\n\t\tif(x>=0){\n\t\t\tnum.insert(d);\n\t\t\tif(max<team[d]){\n\t\t\t\tmax=team[d];\n\t\t\t\tid=d;\n\t\t\t}else if(max == team[d] && id > d){\n\t\t\t\tid=d;\n\t\t\t}\n\t\t}else{\n\t\t\tmax=team[1];\n\t\t\tid=1;\n\t\t\tit = num.begin();\n\t\t\twhile( it != num.end() ){\n\t\t\t\tif(max<team[*it]){\n\t\t\t\t\tmax=team[*it];\n\t\t\t\t\tid=*it;\n\t\t\t\t}\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\n\t}\n\tgap=L-now;\n\ttime[id]+=gap;\n\n\tmax=time[1];\n\tid=1;\n\tfor(int i=2;i<=N;i++){\n\t\tif(max<time[i]){\n\t\t\tmax=time[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\tcout<<id<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<limits.h>\nusing namespace std;\n#define max fahjkfhkahfsj\ntypedef pair<int,int> P;\nint team[100001],ten[100001];\nint main(void){\n\tpriority_queue<P> qu;\n\tint n,r,l,i,m,mm,d,t,x,ans,max;\n\tP ppp;\n\tcin>>n>>r>>l;\n\tfor(i=1;i<=n;i++){\n\t\tteam[i]=0;\n\t\tten[i]=0;\n\t}\n\tcin>>d>>t>>x;\n\tten[d]+=x;\n\tqu.push(P(ten[d],d*-1));\n\tm=t; mm=d; max=LONG_MIN;\n\tfor(i=1;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\tten[d]+=x;\n\t\tqu.push(P(ten[d],d*-1));\n\t\tppp=qu.top();\n\t\tif(ppp.first!=ten[mm]){\n\t\t\tteam[mm]+=t-m;\n\t\t\tif(max<team[mm]){\n\t\t\t\tmax=team[mm];\n\t\t\t\tans=mm;\n\t\t\t}\n\t\t\tm=t; mm=d;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 100000\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct segtree{\n  int N;\n  P dat[MAX_N * 2 - 1];\n  segtree(){}\n  segtree(int n){\n    N = 1;\n    while(n > N) N *= 2;\n\n    rep(i, 2 * N - 1) dat[i] = MP(-1000000, -1000000);\n    for(int i = N - 1; i < 2 * N - 1; i++) dat[i] = MP(0, -1 * (i - N + 1));\n  }\n\n  void update(int k, int a){\n    k += N - 1;\n    dat[k].F += a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1], dat[2*k+2]);\n    }\n  }\n\n  P query(int a, int b){ return query(a, b, 0, 0, N); }\n  P query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return P(-100000, -1000000);\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      P vl = query(a, b, 2*k+1, l, (l+r)/2);\n      P vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return max(vl, vr);\n    }\n  }\n\n  void show(){\n    puts(\"\");\n    rep(i, 2 * N - 1) printf(\"%d %d\\n\", -dat[i].S, dat[i].F);\n  }\n};\n\nint main(){\n  int N, R, L;\n  int res[MAX_N];\n  scanf(\"%d%d%d\", &N, &R, &L);\n  segtree seg(N);\n  rep(i, N) seg.update(i, 0);\n  int time = 0;\n  rep(i, R){\n    //    seg.show();\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x); d--;\n    P s = seg.query(0, N);\n    //    printf(\"%d %d\\n\", s.F, -s.S);\n    res[-s.second] += t - time;\n    seg.update(d, x);\n    time = t;\n  }\n  P s = seg.query(0, N);\n  res[-s.second] += L - time;\n\n  //  seg.show();\n\n  //  rep(i, N) printf(\"%d\\n\", res[i]);\n  int ans = 0;\n  rep(i, N) if(res[ans] < res[i]) ans = i;\n\n  printf(\"%d\\n\", ans+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int inf = (int)1e+9;\n\nconst int max = (int)1e+5 + 1;\n\nint n, r, l;\nP seg[max * 2];\nint point[max];\n\nvoid init(){\n\tint x = 1;\n\twhile (x < n)x *= 2;\n\tn = x;\n\trep(i, max * 2)seg[i].first = -inf, seg[i].second = 0;\n\tREP(i, n - 1, n * 2 - 1)seg[i].second = i - (n - 1);\n}\n\nvoid update(int k, int e){\n\tk += n - 1;\n\tseg[k].first += e;\n\twhile (k > 0){\n\t\tk = (k - 1) / 2;\n\t\tint BigI = (seg[k * 2 + 1].first > seg[k * 2 + 2].first ? k * 2 + 1 : k * 2 + 2);\n\t\tseg[k].first = seg[BigI].first;\n\t\tseg[k].second = seg[BigI].second;\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tint before = 0;\n\tinit();\n\trep(i, r){\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\t\t--d;\n\t\tpoint[seg[0].second] += (t - before);\n\t\tupdate(d, x);\n\t\tbefore = t;\n\t}\n\tpoint[seg[0].second] += (l - before);\n\n\tint maxI = 0;\n\tREP(i, 1, n){\n\t\tif (point[i] > point[maxI])maxI = i;\n\t}\n\tstd::cout << maxI + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint top_id(int *x,int N){\n  int top=x[1];\n  int id=1;\n  for(int i=2;i<=N;i++){\n    if(top<x[i]){\n      top = x[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t[2],x;\n  int tim[N+1];\n  int total[N+1];\n  t[0] = 0;\n  for(int i=0;i<=N;i++){\n    tim[i] = 0;\n    total[i] = 0;\n  }\n  for(int i=0;i<R;i++){\n    cin >> d >> t[1] >> x;\n    total[d] += x;\n    tim[top] += (t[1] - t[0]);\n    top = top_id(total,N);\n    t[0] = t[1];\n  }\n  tim[top] += (L - t[0]);\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<tim[i]){\n      top_t = tim[i];\n      ans = i;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n  int INF = 1e9+7;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[200005];\n  int time[100005];\n  for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n  \n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1=-1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    assert(site1>=1);\n\n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  swap(score[site1], score[site1/2]);\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  swap(score[site1],score[2*site1+flg]);\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n\n  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n   cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[199999];\nint point[100000];\nint n=1;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--; g--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\ta[c] = P(d, p(0, 0));\n\tc++;\n\twhile (n < b)n <<= 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment[n + i - 1].second = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tkousin(0, 0);\n\t}\n\tn--;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint top_id(int *x,int N){\n  int top=x[1];\n  int id=1;\n  for(int i=2;i<=N;i++){\n    if(top<x[i]){\n      top = x[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t[2],x;\n  int tim[N+1];\n  int total[N+1];\n  t[0] = 0;\n  for(int i=0;i<N;i++){\n    tim[i] = 0;\n    total[i] = 0;\n  }\n  for(int i=0;i<R;i++){\n    cin >> d >> t[1] >> x;\n    total[d] += x;\n    tim[top] += (t[1] - t[0]);\n    top = top_id(total,N);\n    t[0] = t[1];\n  }\n  tim[top] += (L - t[0]);\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<tim[i]){\n      top_t = tim[i];\n      ans = i;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n\nvoid update(int a,int b);\n\nusing namespace std;\n\n/*const double EPS = 1e-10;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\nconst int INF = 1001001001;*/\n\n#define clear(a) memset((a), 0, sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\npair<int, int> seg[1 << 18];\n\n\n\nint main(){\n  int n,r,l;\n  int team[100000]={0};\n  \n  scanf(\"%d %d %d\",&n,&r,&l);\n  for(int i=0; i<n; i++) update(i,0);\n  int watch=0,sento=0;\n\n  for (int i=0;i<r;i++){\n    int d,t,x;\n    scanf(\"%d %d %d\",&d,&t,&x);\n    team[sento]+=t-watch;\n    update(d-1,x);\n    sento=seg[0].second-1;\n    watch=t;\n  }\n  team[sento]+=l-watch;\n  \n  int maxi = 0;\n  for (int i=1;i<n;i++){\n    if(team[maxi]<team[i]) maxi=i;\n  }\n  printf(\"%d\\n\",maxi+1);\n  return (0);\n}\n\n\n\nvoid update(int k, int x){\n  int id = k + 1;\n  k += (1 << 17) - 1;\n  seg[k].first += x;\n  seg[k].second = id;\n  \n  while (k){\n    k = (k - 1) / 2;\n    if (seg[k * 2 + 1].first > seg[k * 2 + 2].first){\n      seg[k] = seg[k * 2 + 1];\n    }\n    else if (seg[k * 2 + 1].first < seg[k * 2 + 2].first){\n      seg[k] = seg[k * 2 + 2];\n    }\n    else {\n      seg[k] = seg[k * 2 + 1];\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint main()\n{\n  int n,r,l;\n  for(;cin>>n>>r>>l;)\n    {\n      // id,score;\n      pair<long long int,long long int> tree[n*2-1];\n      for(int i=0;i<n*2-1;i++)\n\ttree[i]=make_pair(0,-1);\n      long long int time[n+1];\n      memset(time,0,sizeof(time));\n      //初期化\n      for(int i=1;i<=n;i++)\n\t{\n\t  int num=(i-1)+(n-1);\n\t  tree[num].first=i;\n\t  tree[num].second=0;\n\t  pair<long long int ,long long int>base;\n\t  while(true)\n\t    {\n\t      num=(num-1)/2;\n\t      if(num*2+2<n*2-1 &&\n\t\t tree[num*2+1].second < tree[num*2+2].second\n\t\t )\n\t\tbase=tree[num*2+2];\n\t      else\n\t\tbase=tree[num*2+1];\n\t      tree[num]=base;\n\t      if(num==0)break;\n\t    }\n\t}\n      int oldtime=0;\n      for(int i=0;i<r;i++)\n\t{\n\t  int d,t,x;\n\t  cin>>d>>t>>x;\n\t  time[tree[0].first]+=(t-oldtime);\n\t  oldtime=t;\n\n\t  //木の更新\n\t  d--;\n\t  int num=d+(n-1);\n\t  //\t  tree[num].first=i;\n\t  tree[num].second+=x;\n\t  pair<long long int ,long long int>base;\n\t  while(true)\n\t    {\n\t      num=(num-1)/2;\n\t      if(num*2+2<n*2-1 &&\n\t\t tree[num*2+1].second < tree[num*2+2].second\n\t\t )\n\t\tbase=tree[num*2+2];\n\t      else\n\t\tbase=tree[num*2+1];\n\t      tree[num]=base;\n\t      if(num==0)break;\n\t    }\n\n\t}\n      time[tree[0].first]+=(l-oldtime);\n      long long int max_time=0;\n      long long  int max_id;\n      for(int i=n;i>0;i--)\n\t{\n\t  if(max_time<=time[i])\n\t    {\n\t      max_time=time[i];\n\t      max_id=i;\n\t    }\n\t}\n      cout<<max_id<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131100];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct dat{ int id, point; };\n#define MAX_N 1 << 17\n\nint N, R, L;\nint res[MAX_N + 1];\ndat seg[2 * MAX_N];\nint n;\n\nvoid init(){\n//\tprintf(\"c\");\n\tn = 1;\n\twhile(n < N) n *= 2;//nはseg木の要素数\n//\tprintf(\"[n = %d]\", n);\n\tfor(int i = 0; i < 2 * n - 1; i++) seg[i].point = 0;\n//\tprintf(\"a\");\n\tfor(int j = 1; j <= N; j++){\n\t\tseg[n - 1 + j].id = j;\n\t}\n//\tprintf(\"b\");\n}\n\nvoid add(int p, int x){\n\tp += n;\n\tseg[p].point += x;\n\twhile(p > 0){\n\t\t//printf(\"p = %d\\n\", p);\n\t\tp = (p - 1) / 2;\n\t\tif(seg[p * 2 + 1].point >= seg[p * 2 + 2].point){\n\t\t\tseg[p] = seg[p * 2 + 1];\n\t\t}\n\t\telse{\n\t\t\tseg[p] = seg[p * 2 + 2];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\tinit();\n\t\n\tint lb = 0;//左端\n\tint d, t, x;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tif(i > 0) res[seg[0].id] += t - lb;\n\t\tadd(d, x);\n\t\tlb = t;\n\t\t//for(int i = 1; i <= N; i++){\n\t\t//\tprintf(\"%d \", res[i]);\n\t\t//}\n\t\t//printf(\": seg[0].id = %d\\n\", seg[0].id);\n\t}\n\tres[seg[0].id] += L - t;\n\t\n\tint longest = 0;//最長の映り時間\n\tfor(int i = 1; i <= N; i++) longest = max(longest, res[i]);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(res[i] == longest){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -11111111\n#define MAX 11111111\ntypedef pair<int,int> P;\nint n;\nP dat[8*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[4*100012];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  \n  int d,t,x,top=1,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[top].first+=t-bt;\n    update(d,x);\n    top=dat[0].second;\n    bt=t;\n  }\n  tim[top].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define INF 2000000000\ntypedef pair<int, int> seg;\nseg dat[1 << 18];\nint ans[1 << 17];\n\nint n, N, R, L;\n\n\nvoid update(int i, seg x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\nvoid init()\n{\n  n = 1;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(INF, INF);\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n}\n\nseg query(int a, int b, int k, int l, int r)\n{\n  if(a >= r || b <= l)\n    return make_pair(INF, INF);\n  if(a <= l && b >= r)\n    return dat[k];\n  seg vr = query(a, b, k, (l + r) / 2, r);\n  seg vl = query(a, b, k, l, (l + r) / 2);\n  return min(vr, vl);\n}\n\n\nvoid output()\n{\n  int m = 0;\n  for(int i = 0; i < N; i++)\n  {\n//    cout << ans[i] << \" \";\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1 << endl;\n      return;\n    }\n  }\n}\n\n\nint main()\n{\n  int old_t = 0;\n\n  cin >> N >> R >> L;\n  init();\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    d--;\n    ans[query(0, N, 0, 0, n).second] += t - old_t;\n    \n    seg s = dat[d + n - 1];\n    update(d, make_pair(s.first - x, s.second));\n    old_t = t;\n  }\n  ans[query(0, N, 0, 0, n).second] += L - old_t;\n\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000001;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tint f = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tTime[L] = takai[1]; \n\tTeam[L] = takai_n[1];\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1 ){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\t\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define F first\n#define S second\n#define INF 1>>20\nusing namespace std;\ntypedef pair<int,int> P;\nvoid update(int k,int x);\nvoid init(int n_);\nP pamax(P a,P b);\nP seg[1111111];\nint n,r,l;//左からチーム数、レコード数、制限時間\nint main(){\n  int time[1111111]={0};\n  int top=0,btime=0;\n  int d,t,x;//左からチームID、獲得した時間、加減得点\n  cin >> n >> r >> l;\n  init(n);\n  for(int i=0;i<r;i++){\n    cin >> d >> t >> x;\n    time[top]+=t-btime;\n    btime=t;\n    update(d-1,x);//チームIDと加減得点\n    top=seg[0].F;//一位奴の更新\n  }\n  time[top]+=l-btime;\n  top=0;\n  time[0]=-11111;\n  for(int i=1;i<=n;i++){//映ってる時間がもっとも多いチームを調べる\n    if(time[top]<time[i])top=i;\n  }\n  cout << top << endl;\n}\n\nvoid init(int n_){\n  int n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<n;i++){\n    seg[i]=P(0,0);\n  }\n}\n\nvoid update(int k,int x){\n  int id=k+1;\n  k+=n-1;\n  seg[k].F=id;\n  seg[k].S+=x;\n  while(k>0){\n    k=(k-1)/2;\n    seg[k]=pamax(seg[k*2+1],seg[k*2+2]);\n  }\n}\n\nP pamax(P a,P b){\n  int x,y;\n  x=a.S;\n  y=b.S;\n  if(x>y)return a;\n  else return b;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<limits.h>\nusing namespace std;\n#define max fahjkfhkahfsj\ntypedef pair<long long int,long long int> P;\nlong long int team[100001],ten[100001];\nint main(void){\n\tpriority_queue<P> qu;\n\tlong long int n,r,l,i,m,mm,d,t,x,ans,max;\n\tP ppp;\n\tcin>>n>>r>>l;\n\tfor(i=1;i<=n;i++){\n\t\tteam[i]=0;\n\t\tten[i]=0;\n\t}\n\tcin>>d>>t>>x;\n\tten[d]+=x;\n\tqu.push(P(ten[d],d*-1));\n\tm=t; mm=d; max=LONG_MIN;\n\tfor(i=1;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\tten[d]+=x;\n\t\tqu.push(P(ten[d],d*-1));\n\t\tppp=qu.top();\n\t\tif(ppp.first!=ten[mm]){\n\t\t\tteam[mm]+=t-m;\n\t\t\tif(max<team[mm]){\n\t\t\t\tmax=team[mm];\n\t\t\t\tans=mm;\n\t\t\t}\n\t\t\tm=t; mm=d;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<ll> dat;\n\tvector<int> id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(2*n-1);\n\t\tid.resize(2*n-1);\n\t\trep(i,2*n-1) dat[i] = -INF;\n\t\trep(i,n) update(i,INF);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] += a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\n\tvector<int> v(n,0);\n\tSeg seg(n);\n\n\tint top_id = seg.id[0],pre_time = 0;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\tseg.update(d-1,x);\n\t\ttop_id = seg.id[0];\n\t}\n\n\tv[top_id] += l - pre_time;\n\n    int res = 0;\n\trep(i,n)\n\t{\n\t\tres = max(res,v[i]);\n\t}\n\n\trep(i,n)\n\t{\n\t\tif(res == v[i])\n\t\t{\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nimport java.util.*;\n \nclass MyComp implements Comparator<Pair> {\n \n    public int compare(Pair arg0, Pair arg1) {\n        Pair t0 = (Pair) arg0;\n        Pair t1 = (Pair) arg1;\n        if(t0.time > t1.time) {\n            return -1;\n             \n        }\n        else if(t0.time < t1.time) {\n            return 1;\n        }\n        else {\n            if(t0.id > t1.id) {\n                return 1;\n            }\n            else if(t0.id < t1.id) {\n                return -1;\n            }\n            else {\n                return 0;\n            }\n        }\n         \n    }\n     \n}\n \n \nclass Pair {\n    int id;\n    int time;\n    public Pair(int d, int t) {\n        this.id = d;\n        this.time = t;\n    }\n    public Pair(Pair a) {\n        this.id = a.id;\n        this.time = a.time;\n    }\n     \n}\n \npublic class Main {\n \n \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n         \n         \n         \n        PriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n         \n        PriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n         \n        int N = stdIn.nextInt();\n        int R = stdIn.nextInt();\n        int L = stdIn.nextInt();\n         \n        int[] time = new int[100000];\n         \n        int lastTime = 0;\n        queA.add(new Pair(1,0));\n         \n        for(int i = 0; i < R; i++) {\n             \n            int d = stdIn.nextInt();\n            int t = stdIn.nextInt();\n            int x = stdIn.nextInt();\n            time[queA.peek().id-1] += t - lastTime;\n            boolean atta = false;\n             \n            while(!queA.isEmpty()) {\n                 \n                Pair tmp = queA.poll();\n                 \n                if(tmp.id == d) {\n                    atta = true;\n                    tmp.time +=  x;\n                    queBX.offer(tmp);\n                    break;\n                }\n                else {\n                    queBX.offer(tmp);\n                }\n            }\n             \n            if(!atta) {\n                queBX.offer(new Pair(d,x));\n            }\n                 \n            while(!queBX.isEmpty()) {\n                queA.offer(queBX.poll());\n            }\n             \n \n            lastTime = t;\n                 \n        }\n         \n        time[queA.peek().id-1] += L - lastTime;\n         \n        int timeA = 0;\n        int idA = 0;\n        for(int i = 0; i < time.length; i++) {\n            if(timeA < time[i]) {\n                timeA = time[i];\n                idA = i;\n            }\n        }\n         \n        System.out.println(idA+1);\n         \n    }\n     \n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;//first=point second=num||first=time second=num\nint N,r,l;\nint d,t,x;\nint n;\nP team[100005];\nP Seg[100005*2];\nP Ttime[100005];\nint top=0;\nint btop=0;\nint smin=-1;\nint btime=0;\nP Pmax(P a,P b);\nvoid init(int n_);\nvoid update(int k,int a);\nP query(int a,int b,int k,int l,int r);\nmain(){\n  cin>>N>>r>>l;\n  for(int i=0;i<100005;i++){\n    team[i].F=0;\n    team[i].S=i+1;\n    Ttime[i].F=0;\n    Ttime[i].S=i+1;\n  }\n  init(N);\n  for(int i=0;i<r;i++){\n    cin>>d>>t>>x;\n    Ttime[top].F+=t-btop;\n    update(d-1,x);\n    /*\n    for(int i=n-1;i<2*n-1;i++){\n      cout<<\"|\"<<Seg[i].F<<\"|\"<<Seg[i].S<<\"| \";\n    }\n    */\n    //cout<<endl;\n    P tops;\n    tops=query(0,n-1,0,0,n);\n    top=tops.S;\n    btop=t;\n    int a=1;\n  }\n  Ttime[top].F+=l-btop;\n  sort(Ttime,Ttime+N);\n  /*\n  for(int i=0;i<N;i++){\n    cout<<Ttime[i].F<<\"|\"<<Ttime[i].S<<\" \";\n  }\n  */\n  //cout<<endl;\n  cout<<Ttime[N-1].second<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    Seg[i]=P(0,0);\n  }\n  for(int i=n-1;i<2*n-1;i++){\n    Seg[i].S=i-(n-1);\n  }\n  return;\n}\nvoid update(int k,int a){\n  k+=n-1;\n  Seg[k].F+=a;\n  if(Seg[k].F<smin){\n    smin=Seg[k].F;\n  }\n  while(k>0){\n    k=(k-1)/2;\n    Seg[k]=Pmax(Seg[k*2+1],Seg[k*2+2]);\n  }\n\n  return;\n}\nP Pmax(P a,P b){\n  if(a.F>b.F||(a.F==b.F&&a.S<b.S)){\n    return a;\n  }\n  else{\n    return b;\n  }\n}\nP query(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l){\n    return P(smin,100010);\n  }\n  if(a<=l&&r<=b){\n    return Seg[k];\n  }\n  else{\n    P vl=query(a,b,k*2+1,l,(l+r)/2);\n    P vr=query(a,b,k*2+2,(l+r)/2,r);\n    return Pmax(vl,vr);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 1e5;\nconst int R = 1e6;\n\ntypedef pair<int, int> P;\nconst int inf = 1e9;\n\nstruct SEG {\n  P data[N*4];\n  int n;\n  SEG(int t) {\n    n = 16;\n    while(n < t) n <<= 1;\n  }\n  void set(int i, P v) {\n    data[i += n-1] = v;\n    while(i>0)i = (i-1)/2, data[i] = min(data[i*2+1],data[i*2+2]);\n  }\n  P get(int i) {\n    return data[i+=n-1];\n  }\n  P query(int a, int b,int k=0,int l=0, int r=-1){\n    if(r<0)r=n;\n    if(b<=l||r<=a)return P(inf,inf);\n    if(a<=l&&r<=b)return data[k];\n    return min(\n        query(a, b,k*2+1,l,(l+r)>>1),\n        query(a, b,k*2+2,(l+r)>>1,r));\n  }\n};\n\nint cnt[N];\nint d[R], t[R], x[R];\nint n, r, l;\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> r >> l;\n  SEG seg(n);\n  for(int i = 0; i < n; i++) seg.set(i,P(0, i));\n  int last = 0;\n  for(int i = 0; i < r; i++) {\n    cin >> d[i] >> t[i] >> x[i];\n    --d[i];\n    ///\n    P p2 = seg.query(0, n);\n    // cout << i << \":\" << p2.second << endl;\n    cnt[p2.second] += t[i] - last;\n    last = t[i];\n    ///\n    P p = seg.get(d[i]);\n    p.first -= x[i];\n    seg.set(d[i], p);\n  }\n  P p2 = seg.query(0, n);\n  cnt[p2.second] += l - last;\n  int ans = 0;\n  for(int i = 0; i < n; i++) {\n    if(cnt[ans] < cnt[i]) ans = i;\n  }\n  cout << ans +1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem0282 : Programming Contest **/\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\nbool comp(const P &a, const P &b) {\n\tif (a.first == b.first) return a.second>b.second;\n\treturn a.first<b.first;\n}\n\nclass RMQ {\n\tconst static int MAX_N = 1 << 17;\n\tint n;\n\tP dat[2*MAX_N-1];\n\t\npublic:\n\tRMQ(int _n) {init(_n);}\n\tRMQ(){}\n\t\n\tvoid init(int _n) {\n\t\tn=1;\n\t\twhile (n<_n) n*=2;\n\t\tfor (int i=0; i<2*n-1; i++) dat[i] = P(-INF, 0);\n\t}\n\t\n\tvoid update(int k, P a) {\n\t\tk += n-1;\n\t\tdat[k] = a;\n\t\twhile (k>0) {\n\t\t\tk = (k-1)/2;\n\t\t\tdat[k] = max(dat[k*2+1], dat[k*2+2], comp);\n\t\t}\n\t}\n\t\n\tint size() {\n\t\treturn n;\n\t}\n\t\n\tP query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return P(-INF, 0);\n\t\t\n\t\tif (a <= l && r <= b) return dat[k];\n\t\telse {\n\t\t\tP vl = query(a, b, k*2+1, l, (l+r)/2);\n\t\t\tP vr = query(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn max(vl, vr, comp);\n\t\t}\n\t}\n};\n\nint main()\n{\n\tint N, R, L;\n\twhile (cin>>N>>R>>L) {\n\t\tRMQ RM(N);\n\t\tint d, t, x;\n\t\tcin>>d>>t>>x; R--;\n\t\t\n\t\tvector<int> team(N);\n\t\tvector<int> sum(N);\n\t\t\n\t\tfor (int i=0; i<L; i++) {\n\t\t\twhile (i==t) {\n\t\t\t\tsum[d-1] += x;\n\t\t\t\tRM.update(d-1, P(sum[d-1], d-1));\n\t\t\t\tif (R>0) {\n\t\t\t\t\tcin>>d>>t>>x; R--;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tteam[RM.query(0, N, 0, 0, RM.size()).second]++;\n\t\t}\n\t\t\n\t\tcout << (max_element(team.begin(), team.end())-team.begin())+1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[135010];\nstruct node {\n    int id, point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fr first\n#define sc second\nP seg[1<<18];\nint n;\nvoid update(int id,int pt){\n  int k = id + n - 1;\n  seg[k].fr += pt;\n  seg[k].sc = -id;\n  while(k != 0){\n    k = ( k - 1 ) / 2;\n    seg[k] = max(seg[2*k+1],seg[2*k+2]);\n  }\n}\nvoid init(int size) {\n  n = 1;\n  while(n < size) n *= 2;\n  for(int i = 0 ; i < size ; i++ ) seg[i+n-1] = P(-i,0);\n}\nint main(){\n  int N,R,L;\n  scanf(\"%d %d %d\",&N,&R,&L);\n  init(N);\n  int mostid = 0 , now = 0 , sum[100000] = {};\n  for(int i = 0 ; i < R ; i++ ){\n    int d,t,x;\n    scanf(\"%d %d %d\",&d,&t,&x);\n    update(d-1,x);\n    sum[mostid] += t - now;\n    now = t;\n    mostid = -seg[0].sc;\n  }\n  sum[mostid] += L - now;\n  int rec = 0;\n  for(int i = 0 ; i < N ; i++) if( sum[rec] < sum[i] ) rec = i;\n  printf(\"%d\\n\",rec+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;//first=point second=num||first=time second=num\nint N,r,l;\nint d,t,x;\nint n;\nP team[100005];\nP Seg[100005*2];\nP Ttime[100005];\nint top=0;\nint btop=0;\nint smin=-1000000;\nint btime=0;\nP Pmax(P a,P b);\nvoid init(int n_);\nvoid update(int k,int a);\nP query(int a,int b,int k,int l,int r);\nmain(){\n  cin>>N>>r>>l;\n  for(int i=0;i<100005;i++){\n    team[i].F=0;\n    team[i].S=i+1;\n    Ttime[i].F=0;\n    Ttime[i].S=-(i+1);\n  }\n  init(N);\n  for(int i=0;i<r;i++){\n    cin>>d>>t>>x;\n    Ttime[top].F+=t-btop;\n    update(d-1,x);\n    /*\n    for(int i=n-1;i<2*n-1;i++){\n      cout<<\"|\"<<Seg[i].F<<\"|\"<<Seg[i].S<<\"| \";\n    }\n    */\n    //cout<<endl;\n    P tops;\n    tops=query(0,n-1,0,0,n);\n    top=tops.S;\n    btop=t;\n    int a=1;\n  }\n  Ttime[top].F+=l-btop;\n  sort(Ttime,Ttime+N);\n  /*\n  for(int i=0;i<N;i++){\n    cout<<Ttime[i].F<<\"|\"<<Ttime[i].S<<\" \";\n  }\n  */\n  //cout<<endl;\n  cout<<-Ttime[N-1].second<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    Seg[i]=P(0,0);\n  }\n  for(int i=n-1;i<2*n-1;i++){\n    Seg[i].S=i-(n-1);\n  }\n  return;\n}\nvoid update(int k,int a){\n  k+=n-1;\n  Seg[k].F+=a;\n  if(Seg[k].F<smin){\n    smin=Seg[k].F;\n  }\n  while(k>0){\n    k=(k-1)/2;\n    Seg[k]=Pmax(Seg[k*2+1],Seg[k*2+2]);\n  }\n\n  return;\n}\nP Pmax(P a,P b){\n  if(a.F>b.F||(a.F==b.F&&a.S<b.S)){\n    return a;\n  }\n  else{\n    return b;\n  }\n}\nP query(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l){\n    return P(smin,100010);\n  }\n  if(a<=l&&r<=b){\n    return Seg[k];\n  }\n  else{\n    P vl=query(a,b,k*2+1,l,(l+r)/2);\n    P vr=query(a,b,k*2+2,(l+r)/2,r);\n    return Pmax(vl,vr);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, R, L, D, T, X, M[100000], A[100000]; vector<pair<int, int> > F[1000000]; // (team, score)\nint main() {\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\tfor (int i = 0; i < R; i++) {\n\t\tscanf(\"%d%d%d\", &D, &T, &X);\n\t\tF[T].push_back(make_pair(D - 1, X));\n\t}\n\tpriority_queue<pair<int, int> > que;\n\tfor (int i = 0; i < N; i++) {\n\t\tque.push(make_pair(0, -i));\n\t}\n\tfor (int i = 0; i < L; i++) {\n\t\tfor (int j = 0; j < F[i].size(); j++) {\n\t\t\tM[F[i][j].first] += F[i][j].second;\n\t\t\tque.push(make_pair(M[F[i][j].first], -F[i][j].first));\n\t\t}\n\t\tpair<int, int> p;\n\t\twhile (true) {\n\t\t\tp = que.top();\n\t\t\tif (p.first == M[-p.second]) break;\n\t\t\tque.pop();\n\t\t}\n\t\tA[-p.second]++;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] > A[ret]) {\n\t\t\tret = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,b,e) for (int i=(int)(b); i<(int)(e); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T>\nclass SegTree {\n  int n;\n  vector<T> seg;\n  \n  // irrelevant value for query\n  const T NIL = make_pair(1<<30, 0);\n  \n  // binary operator for query\n  T binop(T a, T b) {\n    return min(a, b);\n  }\n  \n  void update(int k, int l, int r, int p, T x) {\n    if (p < l || r <= p)\n      return;\n    if (r - l == 1)\n      seg[k] = x;\n    else {\n      update(2*k+1, l, (l+r)/2, p, x);\n      update(2*k+2, (l+r)/2, r, p, x);\n      seg[k] = binop(seg[2*k+1], seg[2*k+2]);\n    }\n  }\n  T query(int k, int l, int r, int a, int b) {\n    if (b <= l || r <= a)\n      return NIL;\n    if (a <= l && r <= b)\n      return seg[k];\n    else {\n      T ret = NIL;\n      ret = binop(ret, query(2*k+1, l, (l+r)/2, a, b));\n      ret = binop(ret, query(2*k+2, (l+r)/2, r, a, b));\n      return ret;\n    }\n  }\npublic:\n  SegTree(int n): n(n), seg(4*n) {}\n  void init() {\n    for (int i = 0; i < 4*n; i++)\n      seg[i] = NIL;\n  }\n  // update p-th value to x\n  void update(int p, T x) {\n    update(0, 0, n, p, x);\n  }\n  // query for range [l, r)\n  T query(int l, int r) {\n    return query(0, 0, n, l, r);\n  }\n};\n\n\nint n, r, l;\nint sum[100000];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin >> n >> r >> l;\n\n  SegTree<pair<int, int> > tree(100000);\n  int pre = 0;\n  REP (i, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    sum[tree.query(0, n).second] += t-pre;\n    int pt = -tree.query(d-1, d).first;\n    tree.update(d-1, make_pair(-(pt+x), d-1));\n    pre = t;\n  }\n  sum[tree.query(0, n).second] += l-pre;\n\n  int ans = 0;\n  REP (i, n) if (sum[i] > sum[ans]) ans = i;\n  cout << ans+1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[100001],t[100001],x[100001];\nint pnt[100000];\nint cnt[100000];\nsigned main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n\n    priority_queue<D>Q;\n\n    Q.push(D(0,0));\n\n    int cur=0;\n    for(int i=0;i<L;i++){\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]++;\n\n        while(cur<R&&t[cur]==i+1){\n            pnt[d[cur]]+=x[cur];\n            Q.push(D(pnt[d[cur]],d[cur]));\n            cur++;\n        }\n    }\n\n    int de=0;\n    //for(int i=0;i<N;i++)de+=cnt[i];cout<<\"de is \"<<de<<endl;\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint top_id(int *x,int N){\n  int top=-99999999;\n  int id;\n  for(int i=1;i<=N;i++){\n    if(top<x[i]){\n      top = x[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint top_time(int *x,int N){\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<x[i]){\n      top_t = x[i];\n      ans = i;\n    }\n  }\n  return ans;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t[2],x;\n  int tim[N+1];\n  int total[N+1];\n  t[0] = 0;\n  for(int i=0;i<N;i++){\n    tim[i] = 0;\n    total[i] = 0;\n  }\n  for(int i=0;i<R;i++){\n    cin >> d >> t[1] >> x;\n    total[d] += x;\n    tim[top] += (t[1] - t[0]);\n    top = top_id(total,N);\n    t[0] = t[1];\n  }\n  tim[top] += (L - t[0]);\n  cout << top_time(tim,N) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/11/05 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\n\tlong long P[100001] = {0};\n\tint W = 1;\n\n\tint T[100001] = {0};\n\tint tp = 0;\n\n\tfor(int i=0; i<R; i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\n\t\tT[W] += t-tp;\n\t\ttp = t;\n\n\t\tP[d] += x;\n\n\t\tif(x>=0){\n\t\t\tif(P[W]<P[d] || (P[W]==P[d] && W>d)){\n\t\t\t\tW = d;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tW = 1;\n\t\t\tfor(int j=2; j<=N; j++){\n\t\t\t\tif(P[W]<P[j]){\n\t\t\t\t\tW = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << W << ' ' << P[W] << endl;\n\t}\n\n\tT[W] += L-tp;\n\n\tint C = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(T[C]<T[i]){\n\t\t\tC = i;\n\t\t}\n\t}\n\tcout << C << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long int Int;\n#define REP(i, j) for(Int i = 0; i < (Int)(j); ++i)\n#define FOR(i, j, k) for(Int i = (Int)(j); i < (Int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<Int, Int> P;\nconst Int MAX_N = (1 << 17);\nnamespace std {\n  bool operator > (const P& a, const P& b) {\n    return a.first != b.first ? a.first > b.first : a.second < b.second;\n  }\n}\n\nInt n;\nP v[2 * MAX_N - 1];\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(Int nn){\n  n = 1;\n  while(n < nn) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(0, 1);\n  REP(i, nn) v[i + n - 1] = P(0, i + 1);\n}\n\n// テヲツキツサテ・ツュツ療」ツ?渓テ」ツ?ョテ」ツつづ」ツ?ョテ」ツつ誕テ」ツ?ォテヲツ崢エテヲツ鳴ー\nvoid update(Int k, Int a){\n  k += n - 1;\n  v[k].first = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);\n  }\n}\n\n// [a, b)テ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?、テ」ツつ津ヲツ個?」ツ?、テ」ツδ?」ツδシテ」ツδ?」ツδ甘」ツδウテ」ツδ静」ツδシテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n// kテ」ツ?ッテ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ヲツキツサテ・ツュツ療」ツ?〕, rテ」ツ?ッテ」ツ?敕」ツつ古」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ擬l, r)\n// テ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?凖ヲツ卍づ」ツ?ッquery(a, b, 0, 0, n)テ」ツ?ィテ」ツ?療」ツ?ヲテ・ツ堕シテ」ツ?カ\nP query(Int a, Int b, Int k, Int l, Int r){\n  if(b <= l || a >= r) return P(-1, -1);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return max(vl, vr);\n}\n\nint main() {\n  Int N, R, L, d, t, x, bef = 1; cin >>N >>R >>L;\n  P tar = P(0, 1);\n  vector<Int> cnt(N, 0);\n  init(N);\n  set<P> S;\n  REP(r, R){\n    cin >>d >>t >>x;\n    --d;\n    cnt[tar.second - 1] += t - bef;\n    update(d, x + v[d + n - 1].first);\n    tar = query(0, N, 0, 0, n);\n    bef = t;\n  }\n  cnt[tar.second - 1] += L - bef + 1;\n  Int ans = 0;\n  REP(i, N) if(cnt[i] > cnt[ans]) ans = i;\n  cout <<ans + 1 <<endl;\n  //REP(i, N) cout <<i + 1 <<\": \" <<cnt[i] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(ll i=0;i<n;++i)\n\ntypedef pair<ll,ll> pll;\n#define MP make_pair<ll>\n\nint main(){\n  ll n,r,l;\n  cin >> n >> r >> l;\n  ll nowtime = 0;\n  ll times[n]; REP(i,n)times[i]=0;\n  ll score[n]; REP(i,n)score[i]=0;\n  set<pll> ranking; REP(i,n)ranking.insert(MP(score[i],i));\n  set<pll>::iterator iter;\n  REP(i,r){\n    ll d,t,x;\n    cin >> d >> t >> x;\n    times[ranking.rbegin()->second] += (t-nowtime);\n    nowtime = t;\n    d = n-d;\n\n    pll nw = MP(score[d],d);\n    iter = ranking.find(nw);\n    ranking.erase(iter);\n    score[d] += x;\n    nw = MP(score[d],d);\n    ranking.insert(nw);\n  }\n  times[ranking.rbegin()->second] += (l-nowtime);\n  ll id = 0;\n  ll mx = times[0];\n  REP(i,n){\n    if(times[i]>mx){\n      mx = times[i];\n      id = i;\n    }\n  }\n  cout << (n-id) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[137510];\nstruct node {\n    int id, point;\n} node[1<<21];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(long long int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  long long int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += t-oldt;\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n      if(pt[old]==pt[d]&&old>d) old = d;\n    }else{\n      if(old==d) old = max(pt,N);\n    }\n  }\n  ptime[old] += L- oldt;\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,R,L;\nint p[100010];\nint T[100010];\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tset<pair<int,int> > S;\n\trep(i,R){\n\t\tS.insert(mp(0,i));\n\t}\n\tint preT = 0;\n\tint preID = 0;\n\trep(i,R){\n\t\tint d,t,x;\n\t\tscanf(\" %d %d %d\",&d,&t,&x);\n\t\td--;\n\t\tT[preID] += t - preT;\n\t\tS.erase(mp(p[d],d));\n\t\tS.insert(mp(p[d]-=x,d));\n\t\tpreID = (*(S.begin())).sec;\n\t\tpreT = t;\n\t}\n\tT[preID] += L - preT;\n\tint ans=0;\n\t//rep(i,N)printf(\"%d \",T[i]);\n\trep2(i,1,N){\n\t\tif(T[i] > T[ans])ans=i;\n\t}\n\tprintf(\"%d\\n\",ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst int N = 1<<18;\nint total[N];\nint id[N];\nint score[N];\n\nint nn;\nvoid update(int i, int x){\n\tid[i+nn-1] = i;\n\ti += nn-1;\n\tscore[i] += x;\n\twhile(i > 0){\n\t\ti = (i-1)/2;\n\t\tint chl = i*2+1, chr = i*2+2;\n\t\tif(score[chl] >= score[chr]){\n\t\t\tscore[i] = score[chl];\n\t\t\tid[i] = id[chl];\n\t\t}else{\n\t\t\tscore[i] = score[chr];\n\t\t\tid[i] = id[chr];\n\t\t}\n\t}\n}\n\nvoid init(int n){\n\tnn = 1;\n\twhile(nn < n) nn *= 2;\n\trep(i, nn*2) score[i] = -1<<30;\n\trep(i, n) update(i, 1<<30);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tint n, r, l;\n\tcin >> n >> r >> l;\n\tinit(n);\n\tint prev = 0;\n\trep(i, r){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\ttotal[id[0]] += t-prev;\n\t\tupdate(d-1, x);\n\t\tprev = t;\n\t\t//cout << \"score:\"; rep(j, n) cout << (j?\" \":\"\") << score[j+nn-1]; cout << endl;\n\t\t//cout << \"time:\";  rep(j, n) cout << (j?\" \":\"\") << total[j]; cout << endl;\n\t}\n\ttotal[id[0]] += l-prev;\n\n\tcout << max_element(total, total+n)-total+1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][100000],T=0,g,p[2][1000000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<ll, ll>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T> //Maximum\nstruct RMQ\n{\n  private:\n    int N = 1;\n    vector<T> node;\n\n  public:\n    RMQ(vector<T> vec)\n    {\n        int size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, make_pair(-llINF, 0));\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return P(-llINF, llINF);\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, R, L;\n    cin >> N >> R >> L;\n\n    vector<P> vec(N);\n\n    vector<ll> time(N, 0);\n\n    REP(i, N)\n    {\n        vec[i] = make_pair(0, -i);\n    }\n\n    RMQ<P> rmq(vec);\n\n    vector<int> d(R), t(R), x(R);\n\n    REP(i, R)\n    {\n        cin >> d[i] >> t[i] >> x[i];\n    }\n\n    t.push_back(L);\n\n    time[0] = t[0];\n\n    REP(i, R)\n    {\n        P pre = rmq.getMax(d[i] - 1, d[i]);\n        rmq.update(d[i] - 1, make_pair(pre.fi + x[i], pre.se));\n        P team = rmq.getMax(0, N);\n\n        time[-team.se] += (t[i + 1] - t[i]);        \n    }\n\n    cout << max_element(ALL(time)) - time.begin() + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, R, L, d, t, x, X[100009], A[100009]; vector<pair<int, int> > v[1000009];\nint main() {\n    scanf(\"%d%d%d\", &N, &R, &L);\n    for(int i = 0; i < R; i++) {\n        scanf(\"%d%d%d\", &d, &t, &x);\n        v[t].push_back(make_pair(d - 1, x));\n    }\n    priority_queue<pair<int, int> > que;\n    for(int i = 0; i < N; i++) que.push(make_pair(0, -i));\n    for(int i = 0; i < L; i++) {\n        for(pair<int, int> z : v[i]) {\n            X[z.first] += z.second;\n            que.push(make_pair(X[z.first], -z.first));\n        }\n        pair<int, int> w;\n        while(true) {\n            w = que.top();\n            if(w.first == X[-w.second]) {\n                A[-w.second]++;\n                break;\n            }\n            que.pop();\n        }\n    }\n    printf(\"%d\\n\", (int)(max_element(A, A + N) - A + 1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100002];\n  long long time[100002];\n\n\n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  score[0].first = -10000000;  \n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    score[N+1].first = 10000000;        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t  int flg = 0;\n\t  if(score[2*site1+1] < score[site1] &&score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[2*site1+flg];\n\t  score[2*site1+flg] = tmp;\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n\n  //  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n  // cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<ll, int> P;\n\nint sum[100000];\nint tsum[100000];\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\tint cur = 0;\n\n\tset<P> s;\n\tfor(int i = 0; i < N; i++) {\n\t\ts.insert({ 0, i });\n\t}\n\n\twhile(R--) {\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\td--;\n\n\t\tint dt = t - cur;\n\t\tint top = s.begin()->second;\n\t\ttsum[top] += dt;\n\n\t\ts.erase({ -sum[d], d });\n\t\tsum[d] += x;\n\t\ts.insert({ -sum[d], d });\n\t\tcur = t;\n\t}\n\n\tint dt = L - cur;\n\tint top = s.begin()->second;\n\ttsum[top] += dt;\n\n\tint tmax = *max_element(tsum, tsum + N);\n\tfor(int i = 0; i < N; i++) {\n\t\tif(tsum[i] == tmax) {\n\t\t\tcout << i + 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[100001],t[100001],x[100001];\nint pnt[100000];\nint cnt[100000];\nsigned main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n\n    priority_queue<D>Q;\n\n    for(int i=0;i<N;i++)Q.push(D(0,i));\n\n    int cur=0;\n    for(int i=0;i<L;i++){\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]++;\n\n        while(cur<R&&t[cur]==i+1){\n            pnt[d[cur]]+=x[cur];\n            Q.push(D(pnt[d[cur]],d[cur]));\n            cur++;\n        }\n    }\n\n    int de=0;\n    //for(int i=0;i<N;i++)de+=cnt[i];cout<<\"de is \"<<de<<endl;\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// range MAXIMUM query\nclass RMQ {\n  private:\n    static const int MAX_N = 100000;\n    int n;\n    // score, -team_id\n    pii dat[2 * MAX_N - 1];\n    pii rec(int a, int b, int k, int l, int r) {\n        if (b <= l || r <= a) {\n            return {0, 0};\n        }\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            pii rl = rec(a, b, 2 * k + 1, l, (l + r) / 2);\n            pii rr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n            return max(rl, rr);\n        }\n    }\n\n  public:\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = {0, 0};\n        }\n    }\n\n    void update(int k, int a) {\n        int reaf = k + n - 1;\n        dat[reaf] = {dat[reaf].first + a, -k};\n        while (reaf > 0) {\n            reaf = (reaf - 1) / 2;\n            dat[reaf] = max(dat[reaf * 2 + 1], dat[2 * reaf + 2]);\n        }\n    }\n\n    pii query(int a,int b){\n      return rec(a,b+1,0,0,n);\n    }\n};\n\nint main() {\n    int team_n, record_n, end_time;\n    cin >> team_n >> record_n >> end_time;\n\n    RMQ r;\n    r.init(team_n);\n\n    vi top(team_n);\n    int btime = 0;\n    REP(i, record_n) {\n        int team_id, time, point;\n        cin >> team_id >> time >> point;\n        team_id--;\n        pii t = r.query(0, team_n);\n        top[-t.second] += time - btime;\n        btime = time;\n//        LOG(\"--> %d [%d] (%d)\\n\", t.first, -t.second, time - btime);\n        r.update(team_id, point);\n    }\n    pii t = r.query(0, team_n);\n    top[-t.second] += end_time - btime;\n    cout << (max_element(ALL(top)) - top.begin() + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n#define REP(i,n) for(int i = 0; i < n; i++)\n#define REP(j,n) for(int j = 0; j < n; j++)\n\nusing namespace std;\ntypedef pair<int, int> P;\nint lis[100000];\nint tim[100000];\nint main() {\n    int n,r,l;\n    scanf(\"%d %d %d\",&n,&r,&l);\n\n    int top = 0;\n    int id  = 1;\n    int nowtime = 0;\n    int timemax = 0;\n    int timemaxid = 0;\n    for(int i = 0; i < r; i++) {\n       \n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x);\n        tim[id] += t - nowtime;\n        if(tim[id] > timemax) {\n            timemax = tim[id];\n            timemaxid = id;\n        }\n        nowtime = t;\n        lis[d] += x;\n        if(id == d) {\n            top += x;\n        }\n        if(x < 0 && d == id) {\n            for(int j = 1; j < n+1; j++) {\n                if(top < lis[j] || (top == lis[j] && j < id)) {\n                    top = lis[j];\n                    id = j;\n                }\n            }\n            \n        }\n        if(x > 0 && d != id) {\n            if(top < lis[d] || (top == lis[d] && d < id)) {\n                top = lis[d];\n                id = d;\n            }\n        }\n\n    }\n    tim[id] += l - nowtime;\n    if(tim[id] > timemax) {\n        timemax = tim[id];\n        timemaxid = id;\n    }\n    printf(\"%d\\n\",timemaxid);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000001;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\tif(Time[i] > 0) n =i;\n\t\tif(i == L)Team_max[temp1] += L-n;\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N, R, L;\n    while(cin >> N >> R >> L && N){\n        const int B = sqrt(N);\n        vector<int> bucket((N - 1) / B + 1);\n        vector<int> point(N + B, INT_MIN);\n        REP(i, N) point[i] = 0;\n        int last_time = 0;\n        int camera_id = 0;\n        vector<int> answer(N);\n        for(int i = 0; i < R; i++){\n            int d, t, x;\n            scanf(\"%d %d %d\", &d, &t, &x);\n            d--;\n            point[d] += x;\n            if(point[d] > bucket[d / B]){\n                bucket[d / B] = point[d];\n            }else if(point[d] - x == bucket[d / B]){\n                bucket[d / B] = *max_element(point.begin() + (d / B) * B, point.begin() + (d / B + 1) * B);\n            }\n            answer[camera_id] += t - last_time;\n            last_time = t;\n            if(camera_id == d && x < 0){\n                int k = max_element(bucket.begin(), bucket.end()) - bucket.begin();\n                camera_id = max_element(point.begin() + k * B, point.begin() + (k + 1) * B) - point.begin();\n            }else if(point[d] > point[camera_id]){\n                camera_id = d;\n            }\n            assert(camera_id >= 0 && camera_id < N);\n            //REP(i, N) cout << point[i] << \" \"; cout << endl;\n            //REP(i, (N - 1) / B + 1) cout << bucket[i] << \" \"; cout << endl;\n            //printf(\"time:%d point[%d] += %d camera: %d\\n\", t, d + 1, x, camera_id + 1);\n        }\n        answer[camera_id] += L - last_time;\n        cout << max_element(answer.begin(), answer.end()) - answer.begin() + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<ll> dat;\n\tvector<int> id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(n*4);\n\t\tid.resize(n*4);\n\t\trep(i,n*2) dat[i] = -INF;\n\t\trep(i,n_) update(i,INF);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tint i = k+n-1;\n\t\tdat[i] += a;\n\t\tid[i] = k;\n\n\n\t\twhile(i > 0)\n\t\t{\n\t\t\ti = (i-1) / 2;\n\t\t\tif(dat[i*2+1] == dat[i*2+2])\n\t\t\t{\n\t\t\t\tdat[i] = dat[i*2+1];\n\t\t\t\tid[i] = id[i*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[i*2+1] > dat[i*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[i] = dat[i*2+1];\n\t\t\t\t\tid[i] = id[i*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[i] = dat[i*2+2];\n\t\t\t\t\tid[i] = id[i*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\n\tvector<int> v(n,0);\n\tSeg seg(n);\n\n\tint top_id = seg.id[0],pre_time = 0;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\tseg.update(d-1,x);\n\n\t\ttop_id = seg.id[0];\n\t}\n\n\tv[top_id] += l - pre_time;\n\n    int res = 0,ans = 0;\n\trep(i,n)\n\t{\n\t\tif(res < v[i])\n\t\t{\n\t\t\tres = v[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tcout << ans+1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nvoid print(      pair<long long int,long long int> *tree,int i)\n{\n  int br=1;\n  int cnt=1;\n  for(int x=0;x<i;x++)\n    {\n      cout<<\"<\"<<(*(tree+x)).first<<\",\"<<(*(tree+x)).second<<\"> \";\n      if(cnt==br)\n\t{\n\t  cout<<endl;\n\t  br*=2;\n\t  cnt=1;\n\t}\n      else\n\tcnt++;\n\n\n    }\n}\n\nint main()\n{\n  int n,r,l;\n  for(;cin>>n>>r>>l;)\n    {\n      // id,score;\n      pair<long long int,long long int> tree[n*2-1];\n      for(int i=0;i<n*2-1;i++)\n\ttree[i]=make_pair(0,-1);\n      long long int time[n+1];\n      memset(time,0,sizeof(time));\n      //初期化\n      for(int i=1;i<=n;i++)\n\t{\n\t  int num=(i-1)+(n-1);\n\t  tree[num].first=i;\n\t  tree[num].second=0;\n\t  pair<long long int ,long long int>base;\n\t  while(true)\n\t    {\n\t      num=(num-1)/2;\n\n\t      if(num*2+2<n*2-1 &&\n\t\t (\n\t\t  tree[num*2+1].second < tree[num*2+2].second ||\n\t\t  (tree[num*2+1].second ==  tree[num*2+2].second && tree[num*2+1].first > tree[num*2+2].first)\n\t\t  )\n\t\t )\n\t\tbase=tree[num*2+2];\n\t      else\n\t\tbase=tree[num*2+1];\n\t      tree[num]=base;\n\t      if(num==0)break;\n\t    }\n\t}\n      int oldtime=0;\n      //print(tree,n*2-1);\n      for(int i=0;i<r;i++)\n\t{\n\t  int d,t,x;\n\t  cin>>d>>t>>x;\n\t  time[tree[0].first]+=(t-oldtime);\n\t  oldtime=t;\n\n\t  //木の更新\n\t  d--;\n\t  int num=d+(n-1);\n\t  //\t  tree[num].first=i;\n\t  tree[num].second+=x;\n\t  pair<long long int ,long long int>base;\n\t  while(true)\n\t    {\n\t      num=(num-1)/2;\n\t      if(num*2+2<n*2-1 &&\n\t\t (\n\t\t tree[num*2+1].second < tree[num*2+2].second ||\n\t\t (tree[num*2+1].second ==  tree[num*2+2].second && tree[num*2+1].first > tree[num*2+2].first)\n\n\t\t  )\n\t\t )\n\t\tbase=tree[num*2+2];\n\t      else\n\t\tbase=tree[num*2+1];\n\t      tree[num]=base;\n\t      if(num==0)break;\n\t    }\n\n\t}\n      time[tree[0].first]+=(l-oldtime);\n      long long int max_time=0;\n      long long int max_id;\n      for(int i=n;i>0;i--)\n\t{\n\t  if(max_time<=time[i])\n\t    {\n\t      max_time=time[i];\n\t      max_id=i;\n\t    }\n\t}\n      cout<<max_id<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// range MAXIMUM query\nclass RMQ {\n  private:\n    static const int MAX_N = 100000*2;\n    int n;\n    // score, -team_id\n    pii dat[2 * MAX_N - 1];\n    pii rec(int a, int b, int k, int l, int r) {\n        if (b <= l || r <= a) {\n            return {0, 0};\n        }\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            pii rl = rec(a, b, 2 * k + 1, l, (l + r) / 2);\n            pii rr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n            return max(rl, rr);\n        }\n    }\n\n  public:\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = {0, 0};\n        }\n    }\n\n    void update(int k, int a) {\n        int reaf = k + n - 1;\n        dat[reaf] = {dat[reaf].first + a, -k};\n        while (reaf > 0) {\n            reaf = (reaf - 1) / 2;\n            dat[reaf] = max(dat[reaf * 2 + 1], dat[2 * reaf + 2]);\n        }\n    }\n\n    pii query(int a,int b){\n      return rec(a,b+1,0,0,n);\n    }\n};\n\nint main() {\n    int team_n, record_n, end_time;\n    cin >> team_n >> record_n >> end_time;\n\n    RMQ r;\n    r.init(team_n);\n    REP(i, team_n) {\n        r.update(i, 0);\n    }\n\n    vi top(team_n);\n    int btime = 0;\n    REP(i, record_n) {\n        int team_id, time, point;\n        cin >> team_id >> time >> point;\n        team_id--;\n\n        pii t = r.query(0, team_n-1);\n        top[-t.second] += time - btime;\n        btime = time;\n//        LOG(\"--> %d [%d] (%d)\\n\", t.first, -t.second, time - btime);\n\n        r.update(team_id, point);\n    }\n    pii t = r.query(0, team_n-1);\n    top[-t.second] += end_time - btime;\n    cout << (max_element(ALL(top)) - top.begin() + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i,Team* team){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest,team);\n  }\n}\nint search(int id,int n,Team* team){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n,Team* team){\n  int t=search(id,n);\n  team[t].point+=key;\n  if(key<0){\n    maxHeapify(search(id,n,team));\n  }\n  else{\n    while(t>1&&team[t/2].point<team[t].point){\n      swap(team[t],team[t/2]);\n      t=t/2;\n    }\n  }\n}\nvoid insert(int id,Team* team){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=team[top].id;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  Team team[n];\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    if(i==0){\n      team[search(1,n)].showed+=t[0];\n    }\n    IncreaseKey(d[i],x[i],n);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\nint N, R, T;\npriority_queue<pair<int, int>> pq;\nint score[1000000], total_time[1000000];\nint beforetime = 0;\n\nint main() {\n\tcin >> N >> R >> T;\n\tfor (int i = 0; i < N; i++)pq.push(make_pair(0, -i));\n\tfor (int i = 0; i < R; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tscore[a - 1] += c;\n\t\tpq.push(make_pair(score[a - 1], -(a - 1)));\n\n\t\twhile (1) {\n\t\t\tif (pq.top().first == score[-pq.top().second]) {\n\t\t\t\t//????????¢????????´???????????§?????????\n\t\t\t\t//pq.top().second???pq???????§?????????????????????????\n\t\t\t\t//????????§????????¢??¨?????´????????????????????????????????????????????????(????????¢???????°????????????????????????????)\n\t\t\t\t//?????§???????????????????????????????¬???§??´??°??????????????¨?????????????????´??°???????????????\n\t\t\t\ttotal_time[-pq.top().second] += (b - beforetime);\n\t\t\t\tbeforetime = b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t}\n\ttotal_time[-pq.top().second] += (T - beforetime);\n\tcout << (max_element(total_time, total_time + N) - total_time) + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,n) for(int i=1;i<=(n);i++)\n#define lol long long\n#define SUM(n) ((n)+1)*(n)/2 //1〜nまでの総和を求める式\n#define mp make_pair\n#define fi first\n#define se second\n#define pu push_back\n#define SYOU(x) fixed<<setprecision(x+1) //小数点桁数を指定する\n#define abs(x,y) max(x,y)-min(x,y)\n#define all(v) v.begin(),v.end()\n#define UPDigit(a,b) (a+b-1)/b //小数点切り上げ\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst int MOD=int(1e9)+7; \nusing namespace std;\nusing pii = pair<lol, lol>;\ntypedef vector<int> vit;\n\n//最大公約数\nlol gcd(lol x, lol y){\n  if(x < y) swap(x, y);\n  lol r = x % y;\n  while(r != 0){\n    x = y;\n    y = r;\n    r = x % y;\n  }\n  return y;\n}\n//最小公倍数\nlol lcm(lol x, lol y){\n  lol a = x * y;\n  return (a / gcd(x, y));\n}\n\nsigned main(void){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  int n, r, l;\n  cin >> n >> r >> l;\n  priority_queue<pair<lol, lol> > ans;\n  lol Score[n + 5] = {}; //点数を保持\n  lol Time[n + 5] = {}; //映った時間を保持\n  //初期化\n  reps(i, n){\n    ans.emplace(Score[i], -i);\n  }\n  int d, t, x, memo = 0;\n  rep(i, r){\n    cin >> d >> t >> x;\n    while(ans.top().first != Score[-ans.top().second]){\n      ans.pop();\n    }\n    Time[-ans.top().second] += (t - memo);\n    memo = t;\n    Score[d] += x;\n    ans.emplace(Score[d], -d);\n  }\n  while(ans.top().first != Score[-ans.top().second]){\n    ans.pop();\n  }\n  Time[-ans.top().second] += (l - t);\n  //最大値を求める\n  int ansp = 0;\n  reps(i, n){\n    if(Time[ansp] < Time[i]){\n      ansp = i;\n    }\n  }\n  cout << ansp << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<numeric>\n#include<tuple>\n\nusing namespace std;\n\nconst int MAX_N=131072;\nint score[MAX_N];\nint dat[2*MAX_N-1];\nconst int INF=1<<29;\n\nvoid update(int ok,int a){\n  score[ok]=a;\n  int k=ok+MAX_N-1;\n  dat[k]=ok;\n  while(k>0){\n    k=(k-1)/2;\n    dat[k]=(score[dat[k*2+1]]>=score[dat[k*2+2]])?dat[k*2+1]:dat[k*2+2];\n  }\n}\n\nint main(){\n  int N,R,L;\n  cin>>N>>R>>L;\n  vector<tuple<int,int,int> >v;\n  for(int i=0;i<R;i++){\n    int d,t,x;\n    cin>>d>>t>>x;\n    v.emplace_back(d,t,x);\n  }\n  fill(begin(score),end(score),-INF);\n  for(int i=1;i<=N;i++){\n    update(i,0);\n  }\n  int x=0;\n  int t[MAX_N]={};\n  for(int i=0;i<L;i++){\n    while(x<R&&get<1>(v[x])==i){\n      int d=get<0>(v[x]);\n      update(d,score[d]+get<2>(v[x]));\n      x++;\n    }\n    t[dat[0]]++;\n  }\n  cout<<max_element(begin(t),end(t))-begin(t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n\tint n, r, l, md=0,pt=0;\n\tint time[100001], point[100001];\n\tcin >> n >> r >> l;\n\trep(i,n+1) time[i] = point[i] = 0;\n\tint d, t, x;\n\tcin >> d >> t >> x;\n\tmd = d;\n\tpoint[d] += x;\n\tpt = t;\n\trep(i,r-1){\n\t\tcin >> d >> t >> x;\n\t\tpoint[d] += x;\n\t\ttime[md] += t-pt;\n\t\tint m=1;\n\t\tfor(int j=2; j<=n; j++)\n\t\t\tif( point[m] < point[j] || (point[m]==point[j] && j<m) ){\n\t\t\t\tm = j;\n\t\t\t}\n\t\tmd = m;\n\t\tpt = t;\n\t}\n\ttime[md] += l-pt;\n\tint res = 1;\n//\tcout << \"1:\" << time[1] << \"[s] \" << point[1] << \"[pt]\" << endl;\n\tfor(int i=2; i<=n; i++){\n//\t\tcout << i << \":\" << time[i] << \"[s] \" << point[i] << \"[pt]\" << endl;\n\t\tif( time[res] < time[i] )\n\t\t\tres = i;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n  int INF = 1e8;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[200005];\n  int time[100005];\n  for(int i=1;i<200005;i++)score[i].first=INF;\n  \n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  swap(score[site1], score[site1/2]);\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  swap(score[site1],score[2*site1+flg]);\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n\n  //  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n  // cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int,int> p;\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\np rmq[1111111];\n \nvoid updata(int k,int x){\n  int no=k;\n  k += N-2;\n  rmq[k].first += x;\n  rmq[k].second = no;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n \n \nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    //if(smp != rmq[0].second){\n      team[smp] += t[i] - now;\n      now = t[i];\n      //}\n    updata(d[i],x[i]);\n    smp = rmq[0].second;\n  }\n  team[smp] += L - now;\n  int a=0;\n  int ans=1;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[1 << 17];\n\nint N, R, L, n;\n\npair<int, int> dat[1 << 18 + 1];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m;\n  for(int i = 0; i < N; i++)\n  {\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    p = query(d, d + 1, 0, 0, n);\n    update(d, make_pair(p.first + x, p.second));\n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\tvector<long long int> data(N+1, 0);\n\tvector<int> timet(N+1, 0);\n\tint maxteam = 1;\n\tint maxs = 0;\n\tint time = 0;\n\tint d, t, x;\n\tfor (int i = 0; i < R; i++) {\n\t\tcin >> d >> t >> x;\n\t\ttimet[maxteam] += t-time;\n\t\tdata[d] += x;\n\t\ttime = t;\n\t\tmaxteam = 1;\n\t\tmaxs = data[1];\n\t\tfor (int j = 2; j <= N; j++) {\n\t\t\tif (data[j] > maxs) {\n\t\t\t\tmaxs = data[j];\n\t\t\t\tmaxteam = j;\n\t\t\t}\n\t\t}\n\t}\n\ttimet[maxteam] += L-time;\n\tint k, ktoku;\n\tk = 1;\n\tktoku = timet[1];\n\tfor (int i = 2; i <= N; i++) {\n\t\tif (timet[i] > ktoku) {\n\t\t\tktoku = timet[i];\n\t\t\tk = i;\n\t\t}\n\t}\n\tcout << k << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100000)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(long long int data[],int n);\nvoid updata(long long int data[],int k,int a,int n);\nint query(long long int data[]);\nint such(long long int data[],int k,int n);\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  long long int score[2*MAX_N -1],time[2*MAX_N -1];\n  int r,l,n;\n  \n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    updata(time, k, time[k+n-1]+t, n);\n\n    updata(score, d, score[d+n-1]+x, n);\n  \n    /*\n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n;i<n*2;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    */\n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-1]+t, n);\n\n  /*printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(long long int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(long long int data[],int k,int a,int n){\n\n  k=k+n-1;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(long long int data[]){\n  return data[0];\n}\n\nint such(long long int data[],int k,int n){\n \n  if(k>=n) return k-n+1; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst long long INF = 100000000000000;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * 100001];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i].first = -INF;\n\t\tteam[i].second = 100002;\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tif(team[k].first == -INF){\n\t\tteam[k].first = 0;\n\t\tteam[k].second = k - n + 1;\n \t}\n\telse\n\t\tteam[k].first += a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[team[0].second] += (t - prev);\n\t\tupdate(d - 1, x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[team[0].second] += (l - t);\n\t\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint top_id(int *x,int N){\n  int top=x[1];\n  int id=1;\n  for(int i=2;i<=N;i++){\n    if(top<x[i]){\n      top = x[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t[2],x;\n  int tim[N+1];\n  int total[N+1];\n  t[0] = 0;\n  for(int i=0;i<N;i++){\n    tim[i] = 0;\n    total[i] = 0;\n  }\n  for(int i=0;i<R;i++){\n    cin >> d >> t[1] >> x;\n    total[d] += x;\n    tim[top] += (t[1] - t[0]);\n    top = top_id(total,N);\n    t[0] = t[1];\n  }\n  tim[top] += (L - t[0]);\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<x[i]){\n      top_t = x[i];\n      ans = i;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\n//const int N=131072; // AC\n//const int N=131071; // WA\nconst int N=130630; // WA\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct team{\n    long long n,p,time;\n};\n\nstruct re{\n    int d,x;\n    long long t;\n};\n\nbool operator<(const team& t1,const team& t2){\n    if(t1.p==t2.p){\n        return t1.n > t2.n;\n    }\n    return t1.p < t2.p;\n}\n\nbool operator<(const re& r1,const re& r2){\n    return r1.t < r2.t;\n}\n\npriority_queue<team> q;\nre rec[1000001];\nteam tea[100001];\n\nint main() {\n\n    long long n,r,l;\n\n    cin >> n >> r >> l;\n\n\n\n    for(int i=0;i<r;i++){\n        cin >> rec[i].d >> rec[i].t >> rec[i].x;\n    }\n\n    sort(rec,rec+r);\n\n    /*for(int i=0;i<r;i++){\n        cout << rec[i].d << \" \" << rec[i].t << \" \" << rec[i].x << endl;\n    }*/\n\n    for(int i=1;i<=n;i++){\n        tea[i].n = i;\n        tea[i].p = 0;\n        tea[i].time = 0;\n        q.push(tea[i]);\n    }\n    /*while (!q.empty()) {\n        cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n        q.pop();\n    }*/\n    /*for(int i=0;i<=n;i++){\n        cout << tea[i].n << \" \" <<  tea[i].p << \" \" << tea[i].time << endl;\n    }*/\n\n\n\n    tea[ rec[0].d ].p += rec[0].x;\n    //cout << \"point is  \" << tea[ rec[0].d].p << endl;\n    q.push(tea[rec[0].d]);\n    team tmp = q.top(); q.pop();\n    //cout << tmp.n <<\" \" << tmp.p << \" \" << tmp.time << endl;\n    tea[tmp.n].time += rec[0].t;\n    //q.push(tea[tmp.n]);\n\n//cout << endl;\n /*   while (!q.empty()) {\n        tmp = q.top();\n        cout << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n        cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n        cout << endl;\n        q.pop();\n    }*/\n\n    for(int i=1;i<r-1;i++){\n        tea[ rec[i].d ].p += rec[i].x;\n        q.push(tea[rec[i].d]);\n        tmp = q.top(); q.pop();\n        //cout << i << \" \" << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n        if(rec[i+1].t != rec[i].t) {\n            tea[tmp.n].time += rec[i + 1].t - rec[i].t;\n            //q.push(tea[tmp.n]);\n        }\n    }\n\n    tea[ rec[r-1].d ].p = rec[r-1].x;\n    q.push(tea[rec[0].d]);\n    tmp = q.top(); q.pop();\n    //cout << tmp.n << tmp.p << tmp.time << endl;\n    tea[tmp.n].time += l - rec[r-1].t;\n    //q.push(tea[tmp.n]);\n\n    /*while (!q.empty()) {\n       tmp = q.top();\n       cout << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n       cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n       cout << endl;\n       q.pop();\n   }*/\n\n\n    /*for(int i=0;i<=n;i++){\n        cout << tea[i].time << endl;\n    }*/\n\n\n    int ans=1;\n\n    for(int i=2;i<=n;i++){\n        ans = tea[i].time > tea[ans].time ? i : ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define MAX 1111111\n#define MIN -1111111\ntypedef pair<int,int> P;\nvoid init(int n);\nvoid update(int k,int x);\nP maxx(int k1,int k2);\nP dat[2*100000];\nint tim[100001]={0};\nint N;\n\nint main(){\n  int R,L;\n  cin >> N >> R >> L;\n  int n_tmp = N;\n  init(N);\n  memset(tim,0,n_tmp+1);\n  int now = 0;\n  dat[0]=P(MIN,1);\n  for(int i=0;i<R;i++){\n    int d,t,x;\n    cin >> d >> t >> x;\n    tim[dat[0].second] += t - now;\n    update(d,x);\n    now = t;\n  }\n  tim[dat[0].second] += L - now;\n  int *ans = max_element(tim,tim+n_tmp+1);\n  cout << ans - tim << endl;\n}\n\nvoid init(int n){\n  N=1;\n  while(N<n) N*=2;\n  for(int i=0;i<2*N-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n  for(int i=N-1;i<N-1+n;i++){\n    dat[i]=P(0,i-(N-2));\n  }\n  return;\n}\n\nvoid update(int k,int x){\n  k += N - 2;\n  //cout << k << \" \" << x << endl;\n  P p = dat[k];\n  int score = p.first;\n  int team = p.second;\n  cout << score << \" \" << team << endl;\n  dat[k] = P(score+x,team);\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = maxx(k*2+1,k*2+2);\n    //cout << dat[k].first << \" \" << dat[k].second << endl;\n  }\n  return;\n}\n\nP maxx(int k1,int k2){\n  P p;\n  if(dat[k1].first == dat[k2].first){\n    p = P(dat[k1].first,min(dat[k1].second,dat[k2].second));\n  }\n  else {\n    p = max(dat[k1],dat[k2]);\n  }\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#define f first\n#define s second\n#define MAX_T 100005\nusing namespace std;\n\ntypedef pair<int, int> P;\nP teamp[MAX_T * 4 - 1];\nP teamt[MAX_T * 4 - 1];\nvoid init(int n);\nvoid updateP(int k, int a, int n);\nvoid updateT(int k, int a, int n);\n\nint main(){\n  int N, R, L;\n  int d, t, x;\n  int befd = 0, beft = 0, nt, n = 1;\n  cin >> N >> R >> L;\n  while(n < N) n *= 2;\n  init(n);\n  for(int i = 0; i < R; i++){\n    cin >> d >> t >> x;\n    updateP(d - 1, x, n);\n    nt = t - beft;\n    beft = t;\n    updateT(befd, nt, n);\n    befd = teamp[0].s;\n  }\n  nt = L - beft;\n  updateT(befd, nt, n);\n  cout << teamt[0].s + 1 << endl;\n}\n\nvoid init(int n){\n  for(int i = 0; i < n * 2 - 1; i++){\n    teamp[i].f = 0;\n    teamt[i].f = 0;\n  }\n  for(int i = n - 1; i < n * 2 - 1; i++){\n    teamp[i].s = i - (n - 1);\n    teamt[i].s = i - (n - 1);\n  }\n  return;\n}\n\nvoid updateP(int k, int a, int n){\n  k += n - 1;\n  teamp[k].f += a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamp[k * 2 + 1].f >= teamp[k * 2 + 2].f){\n      teamp[k].f = teamp[k * 2 + 1].f;\n      teamp[k].s = teamp[k * 2 + 1].s;\n    }\n    else{\n      teamp[k].f = teamp[k * 2 + 2].f;\n      teamp[k].s = teamp[k * 2 + 2].s;\n    }\n  }\n  return;\n}\n\nvoid updateT(int k, int a, int n){\n  k += n - 1;\n  teamt[k].f += a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamt[k * 2 + 1].f >= teamt[k * 2 + 2].f){\n      teamt[k].f = teamt[k * 2 + 1].f;\n      teamt[k].s = teamt[k * 2 + 1].s;\n    }\n    else{\n      teamt[k].f = teamt[k * 2 + 2].f;\n      teamt[k].s = teamt[k * 2 + 2].s;\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <climits>\nusing namespace std;\n\n//===\ntemplate<typename Monoid>\nstruct SegmentTree {\n    using OP = function<Monoid(Monoid, Monoid)>;\n    \n    vector<Monoid> tree;\n    int size;\n    const OP f; // bin' operation\n    const Monoid e; // neutral element\n                                           \n    SegmentTree(int nmemb, const Monoid &e, const OP &f):\n        size(nmemb),\n        f(f),\n        e(e)\n    {\n        tree.assign(2 * size, e);\n    }\n\n    void update(int k, Monoid dat) {\n        k += size;\n        tree[k] = dat;\n        \n        while(k > 1) {\n            k /= 2;\n            tree[k] = f(tree[2 * k], tree[2 * k + 1]);\n        }\n    }\n\n    // [l, r)\n    Monoid query(int l, int r) {\n        l += size; //points leaf\n        r += size;\n\n        Monoid vl = e;\n        Monoid vr = e;\n        while (l < r) {\n            if (l & 1) {\n                vl = f(vl, tree[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                vr = f(tree[r], vr);\n            }\n\n            l /= 2;\n            r /= 2;\n        }\n\n        return f(vl, vr);\n    }\n\n    Monoid operator[] (const int k) { return query(k, k + 1); }\n};\n//===\n\n/*\n//verify AOJ DSL_2_B\nint main()\n{\n    typedef long long ll;\n    \n    ll n, q;\n    ll com, x, y;\n\n    cin >> n >> q;\n\n    SegmentTree<ll> RSQ(n,\n                        0,\n                        [](ll l, ll r){return l + r;});\n\n    for (int i = 0; i < q; i++) {\n        cin >> com >> x >> y;\n        x--;\n\n        if (com == 0) {\n            y += RSQ.query(x, x + 1);\n            RSQ.update(x, y);\n        }\n        else {\n            cout << RSQ.query(x, y) << endl;\n        }\n    }\n}\n*/\n\n/*\n  //verify AOJ DSL_2_A\nint main()\n{\n    int n, q;\n    int com, x, y;\n\n    cin >> n >> q;\n\n    SegmentTree<int> RMQ(n,\n                    (1u << 31u) - 1,\n                    [](int l, int r){\n                        return min(l, r);\n                    });\n    \n    for (int i = 0; i < q; i++) {\n        cin >> com >> x >> y;\n\n        if (com == 0) {\n            RMQ.update(x, y);\n        }\n        else {\n            cout << RMQ.query(x, y + 1) << endl;\n        }\n    }\n\n    return 0;\n}\n*/\n\n//---verify PCK2013 pre 7\nusing ll = long long;\nll n, r, l;\nll d[1'000'005];\nll t[1'000'005];\nll x[1'000'005];\nll tv[1'000'005];\n\nstruct Team{ ll id, point; };\n\nint main()\n{\n    cin >> n >> r >> l;\n    for (int i = 1; i <= r; i++) {\n        cin >> d[i] >> t[i] >> x[i];\n    }\n\n    SegmentTree<Team> seg(n + 1,\n                          (Team){0, -1 * (1ll << 60ll)},\n                          [](const Team x, const Team y){\n                              if (x.point > y.point) {\n                                  return x;\n                              }\n                              else if (x.point == y.point) {\n                                  if (x.id < y.id) {\n                                      return x;\n                                  }\n                                  else {\n                                      return y;\n                                  }\n                              }\n                              else {\n                                  return y;\n                              }\n                          });\n    //init\n    for (int i = 1; i <= n; i++) {\n        seg.update(i, (Team){i, 0});\n    }\n\n    //setinel\n    d[0] = 0, t[0] = 0, x[0] = 0;\n    d[r + 1] = 0, t[r + 1] = l, x[r + 1] = 0;\n        \n    for (int i = 1; i <= r + 1; i++) {\n        Team a = seg.query(1, n + 1);\n        tv[a.id] += t[i] - t[i - 1];\n\n        a = seg[d[i]];\n        a.point += x[i];\n        seg.update(d[i], a);\n    }\n\n    int mpos = 0;\n    for (int i = 1; i <= n; i++) {\n        if (tv[mpos] < tv[i]) mpos = i;\n    }\n\n    cout << mpos << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131060];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<ll, ll>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T> //Maximum\nstruct RMQ\n{\n  private:\n    int N = 1;\n    vector<T> node;\n\n  public:\n    RMQ(vector<T> vec)\n    {\n        int size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, make_pair(-llINF, 0));\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return P(-llINF, llINF);\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, R, L;\n    cin >> N >> R >> L;\n\n    vector<P> vec(N);\n\n    vector<ll> time(N, 0);\n\n    REP(i, N)\n    {\n        vec[i] = make_pair(0, -i);\n    }\n\n    RMQ<P> rmq(vec);\n\n    vector<int> d(R), t(R), x(R);\n\n    REP(i, R)\n    {\n        cin >> d[i] >> t[i] >> x[i];\n    }\n\n    t.push_back(L);\n\n    time[0] = t[0];\n\n    REP(i, R)\n    {\n        P pre = rmq.getMax(d[i] - 1, d[i]);\n        rmq.update(d[i] - 1, make_pair(pre.fi + x[i], pre.se));\n        P team = rmq.getMax(0, N);\n\n        time[-team.se] += (t[i + 1] - t[i]);        \n    }\n\n    cout << min_element(ALL(time)) - time.begin() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N, R, L;\n    while(cin >> N >> R >> L && N){\n        const int B = sqrt(N);\n        vector<int> bucket((N - 1) / B + 1);\n        vector<int> point(N + B, INT_MIN);\n        REP(i, N) point[i] = 0;\n        int last_time = 0;\n        int camera_id = 0;\n        vector<int> answer(N);\n        for(int i = 0; i < R; i++){\n            int d, t, x;\n            scanf(\"%d %d %d\", &d, &t, &x);\n            d--;\n            point[d] += x;\n            if(point[d] > bucket[d / B]){\n                bucket[d / B] = point[d];\n            }else if(point[d] - x == bucket[d / B]){\n                bucket[d / B] = *max_element(point.begin() + (d / B) * B, point.begin() + (d / B + 1) * B);\n            }\n            answer[camera_id] += t - last_time;\n            last_time = t;\n            if(camera_id == d && x < 0){\n                int k = max_element(bucket.begin(), bucket.end()) - bucket.begin();\n                camera_id = max_element(point.begin() + k * B, point.begin() + (k + 1) * B) - point.begin();\n            }else if(point[d] > point[camera_id]){\n                camera_id = d;\n            }\n            assert(camera_id >= 0 && camera_id < N);\n            assert(camera_id == max_element(point.begin(), point.end()) - point.begin());\n            //REP(i, N) cout << point[i] << \" \"; cout << endl;\n            //REP(i, (N - 1) / B + 1) cout << bucket[i] << \" \"; cout << endl;\n            //printf(\"time:%d point[%d] += %d camera: %d\\n\", t, d + 1, x, camera_id + 1);\n        }\n        answer[camera_id] += L - last_time;\n        cout << max_element(answer.begin(), answer.end()) - answer.begin() + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint score[100000];\nint tim[100000];\nint rank[1000000]; //rank->id\nint rrank[1000000]; //id->rank\n\nint n,r,l,d,t,x;\n\nint rank_change(int a,int b){\n\tint i;\n\tif(b>=0){\n\t\tfor(i=rrank[a];i>0;i--){\n\t\t\tif(score[rank[i-1]] < score[rank[i]]) {\n\t\t\t\tswap(rrank[rank[i-1]],rrank[rank[i]]);\n\t\t\t\tswap(rank[i-1],rank[i]);\n\t\t\t\t//cout << \"swap1\" << endl;\n\t\t\t}\n\t\t\telse if(score[rank[i-1]] == score[rank[i]] && rank[i-1] > rank[i]) {\n\t\t\t\tswap(rrank[rank[i-1]],rrank[rank[i]]);\n\t\t\t\tswap(rank[i-1],rank[i]);\n\t\t\t\t//cout << \"swap1\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << \"break\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(i=rrank[a];i<n-1;i++){\n\t\t\tif(score[rank[i]] < score[rank[i+1]]) {\n\t\t\t\tswap(rrank[rank[i]],rrank[rank[i+1]]);\n\t\t\t\tswap(rank[i],rank[i+1]);\n\t\t\t}\n\t\t\telse if(score[rank[i]] == score[rank[i+1]] && rank[i] > rank[i+1]) {\n\t\t\t\tswap(rrank[rank[i]],rrank[rank[i+1]]);\n\t\t\t\tswap(rank[i],rank[i+1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint i,j;\n\tint mi;\n\tint lt=0;\n\tint identify,lidentify=0;\n\tcin >> n >> r >> l ;\n\tfor(i=0;i<100000;i++) score[i]=0;tim[i]=0;\n\tfor(i=0;i<n;i++) {\n\t\trank[i]=i;\n\t\trrank[i]=i;\n\t}\n\tfor(i=0;i<r;i++){\n\t\tcin >> d >> t >> x;\n\t\tscore[d-1]+=x;\n\t\trank_change(d-1,x);\n\t\ttim[lidentify] += (t - lt);\n\t\t//cout << \"-\";\n\t\t//for(j=0;j<n;j++) cout << rank[j];\n\t\t//cout << endl;\n\t\t//cout << \"[\" << lidentify << \":\" << (t-lt) << \"]\" << endl;\n\t\tlt = t;lidentify=rank[0];\n\t\t//cout  << endl;\n\t}\n\ttim[lidentify] += l-lt;\n\t//cout << lidentify << \":\" << (l-lt) << endl;\n\tcout << rank[0] + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> PI;\n\n//セグメントツリー\n//初期化時にメモリーアクセス違反おこすと、変なところ書き換えられて思いがけない変数の書き換えが発生する。\nclass segtree{\n\tPI a[(1<<21)-1];\t\t//ID,score\n\tint dep;\t\t\t\t//distance from root to leaf\n\npublic:\n\tsegtree( int depth, int x ){\n\t\tint i;\n\t\tdep = depth;\n\t\tfor( i = 0; i < (1 << dep )-1; i++ )\n\t\t\ta[i] = PI( 0,x );\n\t\t\n\t\tfor( i = (1 << dep )-1; i < (1 << (dep+1))-1; i++ )\n\t\t\ta[i] = PI( i-(1 << dep )+1 ,x );\n\t\t//printf(\"dep = %d\\n\",dep);\n\t}\n\n\tvoid add( int index, int num ){\n\t\tint x = (1 << dep) + index - 1;\n\t\ta[x].second += num;\n\t\t\n\t\twhile( x > 0 ){\n\t\t\t//printf(\"dep = %d\\n\",dep);\n\t\t\tint oya = (x-1)/2;\n\t\t\tif( (a[oya*2+1].second > a[oya*2+2].second) || (a[oya*2+1].second == a[oya*2+2].second && a[oya*2+1].first < a[oya*2+2].first) )\n\t\t\t\ta[oya] = a[oya*2+1];\n\t\t\telse\n\t\t\t\ta[oya] = a[oya*2+2];\n\n\t\t\tx = oya;\n\t\t}\n\t}\n\n\t//x <= i <= yについて、a[i].secondが最大となるような、a[i]を返す。a[i].secondが同じならa[i].firstが小さいほうを優先する。\n\t//今回の場合は根しか見なくても良い！\n\tPI solve( int x=-1,int y=-1,int depth=0,int index=0 )\n\t{\n\t\tif( x==-1 && y==-1 )\n\t\t\treturn a[0];\n\n\t\tint left = (1<<depth)-1+(x>>(dep-depth));\n\t\tint right = (1<<depth)-1+(y>>(dep-depth));\n\t\t\n\t\tif( depth > dep )\n\t\t\treturn PI(100000000,-1000000001);\n\t\tif( index < left || index > right )\n\t\t\treturn PI(100000000,-1000000001);\n\t\tif( depth == dep || (index >= left && index <= right) )\n\t\t\treturn a[index];\n\n\t\tPI L = solve( x,y,depth+1,index*2+1 );\n\t\tPI R = solve( x,y,depth+1,index*2+2 );\n\t\tif( L.second > R.second || (L.second == R.second && L.first < R.first ) )\n\t\t\treturn L;\n\t\treturn R;\n\t}\n};\n\nint data[1000000];\t\t//テレビに映った時間[ID]を格納\n\nint n,r,l;\nint d,t,x;\nsegtree seg(20,0);\n\nint main()\n{\n\tint i;\n\tint id = 0,bt = 0;\n\n\tcin >> n >> r >> l;\n\tfor( i = 0; i < r;i++ )\n\t{\n\t\tcin >> d >> t >> x;\n\t\tdata[id] += t-bt;\n\t\td--;\n\n\t\t/*for( int j = 0;j < n;j++ ){\n\t\t\tprintf(\"id=%d score=%d time=%d\\n\",j+1,seg.solve(j,j).second,data[j]);\n\t\t}*/\n\n\t\tseg.add( d, x );\n\t\tid = seg.solve().first;\n\t\tbt = t;\n\t}\n\tdata[id] += l-bt;\n\n\tPI ans = PI(1,0);\t//id,写った時間\n\tfor( i = 0;i < n;i++ ){\n\t\tif( ans.second < data[i] || ( ans.first > i+1 ) ){\n\t\t\tans.first = i+1;\n\t\t\tans.second = data[i];\n\t\t}\n\t}\n\n\tcout << ans.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <vector>\n#include <limits>\n\nconstexpr int MAX_N = 100000;\nconstexpr auto INF = std::numeric_limits<int>::max();\n\nusing Pair = std::pair<int, int>;\n\nstruct segtree {\n    int N;\n    Pair dat[2*MAX_N];\n    segtree() {}\n    segtree(int n) {\n        N = 1;\n        while(N < n) N *= 2;\n        for(int i = 0; i < 2*N-1; i++)\n            dat[i] = {INF, INF};\n    }\n\n    void update(int k, int score) {\n        Pair a{-score, k};\n        k += N-1;\n        dat[k] = a;\n        while(k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    Pair query(int a, int b) { return query(a, b, 0, 0, N); }\n    Pair query(int a, int b, int k, int l, int r) {\n        if(r <= a or b <= l) return Pair{INF, INF};\n        if(a <= l and r <= b) return dat[k];\n        auto m = (l + r) / 2;\n        return min(query(a, b, k*2+1, l, m), query(a, b, k*2+2, m, r));\n    }\n};\n\nusing Pair = std::pair<int, int>;\n\nint n, r, l;\nint scores[MAX_N];\nint time_[MAX_N];\n\nint main() {\n    std::cin >> n >> r >> l;\n\n    segtree st(n);\n\n    for(int i = 0; i < n; ++i) {\n        st.update(i, 0);\n    }\n\n    std::fill(scores, scores + n, 0);\n    std::fill(time_, time_ + n, 0);\n\n    int d, t, x;\n    int prevTime = 0;\n    for(int i = 0; i < r; ++i) {\n        std::cin >> d >> t >> x;\n\n        auto m = st.query(0, n);\n\n        time_[m.second] += t - prevTime;\n\n        --d;\n\n        scores[d] += x;\n\n        st.update(d, scores[d]);\n\n        prevTime = t;\n    }\n\n    auto m = st.query(0, n);\n\n    time_[m.second] += l - prevTime;\n\n    std::cout << (std::max_element(time_, time_ + n) - time_ + 1) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100001, MAX_R = 1000001;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    rs[0] = {0, 0, 0};\n    REP(i, R+1){\n        std::cin >> rs[i+1].d >> rs[i+1].t >> rs[i+1].x;\n    }\n\n    int prev = 0, ts[MAX_N];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R+1){\n        if(i+1 > N || rs[i].t < rs[i+1].t){\n            //printf(\"%d: +%d\\n\", st.root().second, rs[i].t - prev);\n            ts[st.root().second] += rs[i].t - prev;\n            prev = rs[i].t;\n        }\n        st.update(rs[i].d, rs[i].x);\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = -1;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    //std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nint INF=1<<28;\nstruct SegmentTree{\n\tvector<int> dat;\n\tvector<int> mi;\n\n\tint n,size;\n\tSegmentTree(int _n){\n\t\tn=Pow2Fit(_n)<<1;\n\t\tsize=2*n-1;\n\t\tdat=vector<int>(size,-INF);\n\t\tmi=vector<int>(size,INF);\n\t}\n\tint Pow2Fit(int n){\n\t\t  n = n | (n >>  1);n = n | (n >>  2);n = n | (n >>  4);n = n | (n >>  8);n = n | (n >> 16);\n\t\t  return n ^ (n >> 1);\n\t}\n\n\tvoid update(int v,int a){\n\t\tv+=n-1;\n\t\tdat[v]=a;\n\t\tmi[v]=v-(n-1);\n\t\twhile(v>0){\n\t\t\tint parent=v=(v-1)/2;\n\t\t\tint chl=parent*2+1,chr=parent*2+2;\n\t\t\tif(dat[chl]>=dat[chr])mi[parent]=mi[chl];\t\t\t\t\n\t\t\telse mi[parent]=mi[chr];\n\t\t\tdat[parent]=max(dat[chl],dat[chr]);\n\t\t}\n\t}\n\n\tint query(int a,int b){\n\t\treturn query(0,a,b,0,n);\n\t}\n\n\tprivate:\n\tint query(int v,int a,int b,int l,int r){\n\t\tif(r<=a || b<=l)return -1;//out range\n\t\tif(a<=l && r<=b)return mi[v];\n\n\t\tint vl=query(v*2+1,a,b,l,(l+r)/2);\n\t\tint vr=query(v*2+2,a,b,(l+r)/2,r);\n\t\tif(vl==-1)return vr;\n\t\tif(vr==-1)return vl;\n\n\t\tif(dat[vl+(n-1)]>=dat[vr+(n-1)])return vl;\n\t\telse return vr;\n\t}\n};\n\nclass Task{\n\tpublic:\n\tint d,t,x;\n\tTask(int d,int t,int x):d(d),t(t),x(x){\n\t}\n};\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,R,L;cin >> N >> R >> L;\n\t\tvector<Task> ts;\n\t\tREP(i,R){\n\t\t\tint d,t,x;cin >> d >> t >> x;d--;\n\t\t\tts.push_back(Task(d,t,x));\n\t\t}\n\n\t\tvector<int> vs(N);\n\t\tSegmentTree seg(N);\n\t\tREP(i,N)seg.update(i,0);\n\n\t\tint pt=0;\n\t\tREP(i,R){\n\t\t\tvs[seg.query(0,N)]+=ts[i].t-pt;\n\t\t\tpt=ts[i].t;\n\t\t\tseg.update(ts[i].d,seg.dat[ts[i].d+(N-1)]+ts[i].x);\n\t\t}\n\t\tvs[seg.query(0,N)]+=L-pt;\n\n\t\tint Mv=0;\n\t\tREP(i,N)Mv=max(Mv,vs[i]);\n\t\t\n\t\tREP(i,N)if(Mv==vs[i]){\n\t\t\tcout <<i+1<<endl;return;\n\t\t}\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nstruct RMQ {\n  pair<int, int> DEF;\n  int n;\n  vector<pair<int, int> > d;\n  \n  RMQ(int n) {\n    DEF = make_pair(-1e9, 1e9);\n    this-> n = n;\n    d.resize(2 * n - 1);\n    rep (i, 2 * n - 1) d[i] = DEF;\n  }\n\n  void update(int k, int a) {\n    k += n - 1;\n    d[k] = make_pair(a, k - (n - 1));\n    while (k > 0) {\n      k = (k - 1) / 2;\n      d[k] = function(d[k * 2 + 1], d[k * 2 + 2]);\n    }\n  }\n\n  pair<int, int> query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return DEF;\n    if (a <= l && r <= b) return d[k];\n    pair<int, int> vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    pair<int, int> vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return function(vl, vr);\n  }\n\n  pair<int, int> query(int a, int b) {\n    return query(a, b, 0, 0, n);\n  }\n\n  pair<int, int> function(pair<int, int> l, pair<int, int> r) {\n    if (l.first > r.first) return l;\n    if (l.first < r.first) return r;\n    if (l.first > r.first) return l;\n    return r;\n  }\n};\n\nint main() {\n  int n, r, l;\n  cin >> n >> r >> l;\n  int score[n], res[n];\n  RMQ rmq(n);\n  rep (i, n) rmq.update(i, 0);\n  rep (i, n) rmq.update(i, 0);\n  rep (i, n) res[i] = 0;\n  rep (i, n) score[i] = 0;\n  int pre = 0;\n  rep (i, r) {\n    int d, t, x;\n    cin >> d >> t >> x;\n    int k = rmq.query(0, n).second;\n    res[k] += t - pre;\n    --d;\n    score[d] += x;\n    rmq.update(d, score[d]);\n    pre = t;\n  }\n  int k = rmq.query(0, n).second;\n  res[k] += l - pre;\n  int mi = 0, mx = 0;\n  rep (i, n) if (mx < res[i]) {\n    mi = i;\n    mx = res[i];\n  }\n  cout << mi + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[1000001];\n  int time[1000001];\n\n\n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  score[0].first = -10000000;  \n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1+1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t  int flg = 0;\n\t  if(score[2*site1+1] < score[site1] &&score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[2*site1+flg];\n\t  score[2*site1+flg] = tmp;\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n\n  }\n\n\n  time[score[1].second] += L-t;\n\n   for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n   cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n  int INF = 1e9;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[200005];\n  int time[100005];\n  for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n  \n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  swap(score[site1], score[site1/2]);\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  swap(score[site1],score[2*site1+flg]);\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n\n  //  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n  // cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100001)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\nint n_;\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int score[4*MAX_N -1],time[4*MAX_N -1];\n  int r,l,n;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  n_=n;\n  n=1;\n  while(n<n_) n*=2;\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    //printf(\"k=%d\\n\",k);\n    updata(time, k, time[k+n-2]+t, n);\n\n    //printf(\"b\\n\");\n    updata(score, d, score[d+n-2]+x, n);\n  \n\n    /*printf(\"c\");\n    \n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n-1;i<n*2-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n      }*/\n    \n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-2]+t, n);\n\n  /*\n  printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-2;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n_) return k-n+2; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define INF 2000000000\ntypedef pair<int, int> seg;\nseg dat[1 << 18 + 1];\nint ans[1 << 17];\n\nint n, N, R, L;\n\n\nvoid update(int i, seg x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\nvoid init()\n{\n  n = 1;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(INF, INF);\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n}\n\nseg query(int a, int b, int k, int l, int r)\n{\n  if(a >= r || b <= l)\n    return make_pair(INF, INF);\n  if(a <= l && b >= r)\n    return dat[k];\n  seg vr = query(a, b, k, (l + r) / 2, r);\n  seg vl = query(a, b, k, l, (l + r) / 2);\n  return min(vr, vl);\n}\n\n\nvoid output()\n{\n  int m = 0;\n  for(int i = 0; i < N; i++)\n  {\n//    cout << ans[i] << \" \";\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1 << endl;\n      return;\n    }\n  }\n}\n\n\nint main()\n{\n  int old_t = 0;\n\n  cin >> N >> R >> L;\n  init();\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    d--;\n    ans[query(0, N, 0, 0, n).second] += t - old_t;\n    \n    seg s = dat[d + n - 1];\n    update(d, make_pair(s.first - x, s.second));\n    old_t = t;\n  }\n  ans[query(0, N, 0, 0, n).second] += L - old_t;\n\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// range MAXIMUM query\nclass RMQ {\n  private:\n    static const int MAX_N = 100000;\n    int n;\n    // score, -team_id\n    pii dat[2 * MAX_N - 1];\n    pii rec(int a, int b, int k, int l, int r) {\n        if (b <= l || r <= a) {\n            return {0, 0};\n        }\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            pii rl = rec(a, b, 2 * k + 1, l, (l + r) / 2);\n            pii rr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n            return max(rl, rr);\n        }\n    }\n\n  public:\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = {0, -i/2};\n        }\n    }\n\n    void update(int k, int a) {\n        int reaf = k + n - 1;\n        dat[reaf] = {dat[reaf].first + a, -k};\n        while (reaf > 0) {\n            reaf = (reaf - 1) / 2;\n            dat[reaf] = max(dat[reaf * 2 + 1], dat[2 * reaf + 2]);\n        }\n    }\n\n    pii query(int a,int b){\n      return rec(a,b+1,0,0,n);\n    }\n};\n\nint main() {\n    int team_n, record_n, end_time;\n    cin >> team_n >> record_n >> end_time;\n\n    RMQ r;\n    r.init(team_n);\n\n    vi top(team_n);\n    int btime = 0;\n    REP(i, record_n) {\n        int team_id, time, point;\n        cin >> team_id >> time >> point;\n        team_id--;\n        pii t = r.query(0, team_n);\n        top[-t.second] += time - btime;\n        btime = time;\n//        LOG(\"--> %d [%d] (%d)\\n\", t.first, -t.second, time - btime);\n        r.update(team_id, point);\n    }\n    pii t = r.query(0, team_n);\n    top[-t.second] += end_time - btime;\n    cout << (max_element(ALL(top)) - top.begin() + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000001;\nint Time[MAX];\nint Team[MAX];\nint takai[MAX];\nint takai_n[MAX];\nint Team_max[MAX];\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint temp,temp1=0,flag = 0;\n\tint f = 0;\n\tcin >> N >> R >> L;\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tmemset(takai_n,0,sizeof(takai_n+N)+1);\n\tmemset(takai,0,sizeof(takai+N)+1);\n\tfor(int i=1;i<=N;i++){\n\t\ttakai_n[i] = i;\n\t}\n\tfor(int h=0;h<R;h++){\n\t\tcin >> d >> t >> x;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(d == takai_n[i] ) takai[i] += x;\n\t\t}\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfor(int j=i+1;j<N+1;j++){\n\t\t\t\tif(takai[i] < takai[j]){\n\t\t\t\t\tswap(takai[i],takai[j]);\n\t\t\t\t\tswap(takai_n[i],takai_n[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTime[t] = takai[1];\n\t\tTeam[t] = takai_n[1];\n\t}\n\tint n= 0;\n\tfor(int i=0;i<=L;i++){\n\t\tif(Time[i] > 0 && flag == 0) {\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t\tflag= 1;\n\t\t}\n\t\telse if(Time[i] > 0 && flag == 1){\n\t\t\tTeam_max[temp1] += i - temp;\n\t\t\ttemp = i;\n\t\t\ttemp1 = Team[i];\n\t\t}\n\t\tif(Time[i] > 0 && f == 0) {\n\t\t\tn =i;\n\t\t\tf = 1;\n\t\t}\n\t\tif(i == L)Team_max[temp1] += L-n;\n\t}\n\tint a = 0;int te = 0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(a < Team_max[i]){\n\t\t\ta = Team_max[i];\n\t\t\tte = i;\n\t\t}\n\t}\n\tcout << te << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n\nvoid update(int a,int b);\n\nusing namespace std;\n/*\n#define clear(a) memset((a), 0, sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n*/\npair<int, int> seg[1 << 18];\n\n\n\nint main(){\n  int n,r,l;\n  int team[100000]={0};\n  \n  scanf(\"%d %d %d\",&n,&r,&l);\n  for(int i=0; i<n; i++) update(i,0);\n  int watch=0,sento=0;\n\n  for (int i=0;i<r;i++){\n    int d,t,x;\n    scanf(\"%d %d %d\",&d,&t,&x);\n    team[sento]+=t-watch;\n    update(d-1,x);\n    sento=seg[0].second-1;\n    watch=t;\n  }\n  team[sento]+=l-watch;\n  \n  int maxi = 0;\n  for (int i=1;i<n;i++){\n    if(team[maxi]<team[i]) maxi=i;\n  }\n  printf(\"%d\\n\",maxi+1);\n  return (0);\n}\n\n\n\nvoid update(int k, int x){\n  int id = k + 1;\n  k += (1 << 17) - 1;\n  seg[k].first += x;\n  seg[k].second = id;\n  \n  while (k){\n    k = (k - 1) / 2;\n    if (seg[k * 2 + 1].first > seg[k * 2 + 2].first){\n      seg[k] = seg[k * 2 + 1];\n    }\n    else if (seg[k * 2 + 1].first < seg[k * 2 + 2].first){\n      seg[k] = seg[k * 2 + 2];\n    }\n    else {\n      seg[k] = seg[k * 2 + 1];\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define MP make_pair\n#define F first\n#define S second\n\ntypedef pair<int, int> P;\n\nint N, R, L;\nint point[100005];\nint res[100005];\n\nint main(){\n  scanf(\"%d%d%d\", &N, &R, &L);\n  int now = 0;\n  memset(point, 0, sizeof(point));\n  memset(res, 0, sizeof(res));\n\n  priority_queue<P>q;\n  rep(i, N) q.push(P(0, -i));\n  rep(i, R){\n    //    printf(\"%d\\n\", i);\n\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x);d--;\n    //    printf(\"%d %d %d\\n\", d, t, x);\n\n    //    printf(\"%d\\n\", i);\n    P p = q.top(); q.pop();\n    while(p.F != point[-p.S]){\n      p = q.top(); q.pop();\n    }\n    q.push(p);\n\n    res[-p.S] += t - now;\n    now = t;\n\n    point[d] += x;\n    //    printf(\"%d\\n\", d);\n    //    rep(j, N) printf(\"%d \", point[j]); puts(\"\");\n    q.push(P(point[d], -d));\n  }\n\n  P p = q.top(); q.pop();\n  while(p.F != point[-p.S]){\n    //    printf(\"%d %d\\n\", p.F, point[-p.S]);\n    p = q.top(); q.pop();\n  }\n  //  printf(\"%d %d\\n\", p.F, point[-p.S]);\n  res[-p.S] += L - now;\n\n  //  rep(i, N) printf(\"%d \", res[i]); puts(\"\");\n  int team = 0;\n  rep(i, N) if(res[team] < res[i]) team = i;\n  printf(\"%d\\n\", team+1);\n  exit(0);\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\n\nstruct state {\n  ll id,score,last;\n  bool operator < ( const state &p ) const {\n    if(score==p.score)return id > p.id;\n    else return score < p.score;\n  }\n};\n\nstruct event {\n  ll d,t,x;\n};\n\npriority_queue < state > Q;\n\nll N,R,L,id,ti,po,key;\nll score[100010];\nll last[100010];\nll sum[100010];\nevent events[100010];\n\n\nint main(){\n  cin>>N>>R>>L;\n  for(int i=1;i<=N;i++)Q.push( (state){i,0,0} );\n  for(int i=0;i<R;i++){\n    cin>>events[i].d>>events[i].t>>events[i].x;\n  }\n  events[R].t=L;\n  events[R].d=events[R].x=0;\n  state f=(state){1,0,0},g;\n  ll a=0;\n  for(int i=0;i<=R;i++){\n    event e = events[i];\n    score[e.d]+=e.x;\n    last[e.d]=e.t;\n    Q.push( (state){e.d,score[e.d],last[e.d]} );\n    if(i+1<=R&&e.t==events[i+1].t)continue;\n    g=f;\n    while(1){\n      f=Q.top();\n      if(f.last==last[f.id])break;\n      Q.pop();\n    }\n    sum[g.id]+=(e.t-a);\n    //cout<<g.id << ' '<<e.t-a<<endl;\n    a=e.t;\n  }\n  ll ans=0,ans2=0;\n  for(int i=1;i<=N;i++){\n    if(ans<sum[i]){\n      ans=sum[i];\n      ans2=i;\n    }\n  }\n  cout<<ans2<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define N_MAX 100001\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef pair<int, int> iP;\n\nint ts[N_MAX], sum[N_MAX];\n\nint main(){\n  \n  int N, R, L, d, t, x;\n  \n  cin >> N >> R >> L;\n  priority_queue<iP, vector<iP> > que;\n  \n  ts[0] = sum[0] = -INF;\n  que.push(iP(0, -1));\n  int pid = 1, pt = 0;\n  for(int i = 0; i < R; i++){\n    cin >> d >> t >> x;\n    sum[d] += x;\n    que.push(iP(sum[d], -d));\n    while(1){\n      iP p = que.top();\n      if(p.fr == sum[-p.second]){\n\tts[pid] += t - pt;\n\tpt = t;\n\tpid = d;\n\tbreak;\n      }\n      que.pop();\n    }\n    ts[pid] += L - pt;\n  }\n  \n  cout << max_element(ts+1, ts+N+1) - ts << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#define REP(i,n) for(int i = 0; i < n; i++)\n#define REP(j,n) for(int j = 0; j < n; j++)\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main() {\n    int n,r,l;\n    cin >> n;\n    cin >> r;\n    cin >> l;\n    int list[n+1];\n    int time[n+1];\n    memset(list, 0, (n+1)*4);\n    memset(time, 0, (n+1)*4);\n    int top = 0;\n    int id  = 1;\n    int nowtime = 0;\n    int timemax = 0;\n    int timemaxid = 0;\n    for(int i = 0; i < r; i++) {\n        int d,t,x;\n        cin >> d;\n        cin >> t;\n        cin >> x;\n        time[id] += t - nowtime;\n        if(time[id] > timemax) {\n            timemax = time[id];\n            timemaxid = id;\n        }\n        nowtime = t;\n        list[d] += x;\n        if(id == d) {\n            top += x;\n        }\n        if(x < 0 && d == id) {\n            for(int j = 1; j < n+1; j++) {\n                if(top < list[j] || (top == list[j] && j < id)) {\n                    top = list[j];\n                    id = j;\n                }\n            }\n            \n        }\n        if(x > 0 && d != id) {\n            if(top < list[d] || (top == list[d] && d < id)) {\n                top = list[d];\n                id = d;\n            }\n        }\n\n    }\n    time[id] += l - nowtime;\n    if(time[id] > timemax) {\n        timemax = time[id];\n        timemaxid = id;\n    }\n    cout << timemaxid << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n\nusing namespace std;\n\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint now=0;\n\tint gap;\n\tint max,id;\n\tint team[100001]={0};\n\tint time[100001]={0};\n\tset<int> num;\n\tset<int>::iterator it;\n\n\tcin >> N >>R >> L;\n\n\tmax=team[1];\n\tid=1;\n\twhile(R--){\n\t\tcin >>d>>t>>x;\n\t\tgap=t-now;\n\t\tnow=t;\n\t\ttime[id]+=gap;\n\t\tteam[d]+=x;\n\t\tif(x>=0){\n\t\t\tnum.insert(d);\n\t\t\tif(max<team[d]){\n\t\t\t\tmax=team[d];\n\t\t\t\tid=d;\n\t\t\t}else if(max == team[d] && id > d){\n\t\t\t\tid=d;\n\t\t\t}\n\t\t}else{\n\t\t\tmax=team[1];\n\t\t\tid=1;\n\t\t\tit = num.begin();\n\t\t\twhile( it != num.end() ){\n\t\t\t\tif(max<team[*it]){\n\t\t\t\t\tmax=team[*it];\n\t\t\t\t\tid=*it;\n\t\t\t\t}\n\t\t\t\t++it;\n\t\t\t}\n\t\t}\n\n\t}\n\tgap=L-now;\n\ttime[id]+=gap;\n\n\tmax=time[1];\n\tid=1;\n\tit = num.begin();\n\twhile( it != num.end() ){\n\t\tif(max<time[*it]){\n\t\t\tmax=time[*it];\n\t\t\tid=*it;\n\t\t}\n\t\t++it;\n\t}\n\tcout<<id<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point {\n  int x,y;\n  bool operator < (const Point& p) const {\n    if( y != p.y ) return y < p.y;\n    return x > p.x;\n  }\n};\nostream& operator << (ostream& os,const Point& p) {\n  os << p.x/* <<\" \"<< p.y*/;\n}\n\nint score[100001];\nint t[1000000];\nint time_[1000000];\nint main(){\n  priority_queue<Point> Q;\n  priority_queue<Point> T;\n  int N,R,L;\n  int d,x;\n  int a=1,b=0;\n\n  cin >>N>>R>>L;\n\n\n  for(int i=0;i<R;i++){\n    cin >>d>>t[i]>>x;    \n    score[d]+=x;\n    Q.push((Point){d,score[d]});  \n    while(!Q.empty() && score[Q.top().x] != Q.top().y){\n      Q.pop();\n    }\n    time_[a]+=t[i]-b; \n    T.push((Point){a,time_[a]});\n    a=Q.top().x;\n    b=t[i];\n    //time_[a]+=t[i]-b;\n    \n  }\n  \n  while( !Q.empty() && score[Q.top().x] != Q.top().y){\n    Q.pop();\n  }\n  time_[a]+=L-b;\n  if( !Q.empty() ) a=Q.top().x;\n  else a = 1;\n  b=L;\n  T.push((Point){a,time_[a]});\n \n  cout <<T.top()<<endl;\n\n  return 0;\n}\n\n\n\n    \n\n\t    \n\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<ll, ll>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T> //Maximum\nstruct RMQ\n{\n  private:\n    int N = 1;\n    vector<T> node;\n\n  public:\n    RMQ(vector<T> vec)\n    {\n        int size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, make_pair(-llINF, 0));\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return P(-llINF, llINF);\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, R, L;\n    cin >> N >> R >> L;\n\n    vector<P> vec(N);\n\n    vector<ll> time(N, 0);\n\n    REP(i, N)\n    {\n        vec[i] = make_pair(0, -i);\n    }\n\n    RMQ<P> rmq(vec);\n\n    vector<int> d(R), t(R), x(R);\n\n    REP(i, R)\n    {\n        cin >> d[i] >> t[i] >> x[i];\n    }\n\n    t.push_back(L);\n\n    time[0] = t[0];\n\n    REP(i, R)\n    {\n        P pre = rmq.getMax(d[i] - 1, d[i]);\n        rmq.update(d[i] - 1, make_pair(pre.fi + x[i], -pre.se));\n        P team = rmq.getMax(0, N);\n\n        time[team.se] += (t[i + 1] - t[i]);        \n    }\n\n    int ans = 0;\n    ll Max = 0;\n\n    REP(i, N)\n    {\n        if(Max < time[i])\n        {\n            ans = i;\n            Max = time[i];\n        }\n    }\n\n    cout << ans + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct node {\n\tint id, score;\n};\nbool operator<(node a, node b) {\n\tif (a.score == b.score)return a.id > b.id;\n\treturn a.score < b.score;\n}\nint s[100000], cnt[100000];\nint d[1000000], t[1000000], x[1000000];\nint main() {\n\tint n, r, l; scanf(\"%d%d%d\", &n, &r, &l);\n\tpriority_queue<node>que, ans;\n\trep(i, r)scanf(\"%d%d%d\", &d[i], &t[i], &x[i]);\n\trep(i, r) {\n\t\td[i]--;\n\t\ts[d[i]] += x[i];\n\t\tque.push({ d[i],s[d[i]] });\n\t\twhile (!que.empty() && que.top().score != s[que.top().id])que.pop();\n\t\tif (i == r - 1) {\n\t\t\tcnt[que.top().id] += l - t[i];\n\t\t\tans.push({ que.top().id,cnt[que.top().id] });\n\t\t}\n\t\telse {\n\t\t\tcnt[que.top().id] += t[i + 1] - t[i];\n\t\t\tans.push({ que.top().id,cnt[que.top().id] });\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.top().id + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <climits>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\n//===\ntemplate<typename Monoid>\nstruct SegmentTree {\n    using OP = function<Monoid(Monoid, Monoid)>;\n    \n    vector<Monoid> tree;\n    int size;\n    const OP f; // bin' operation\n    const Monoid e; // neutral element\n    \n    SegmentTree(int nmemb, const Monoid &e, const OP &f):\n        f(f),\n        e(e)\n    {\n        size = 1;\n        while (size < nmemb) {\n            size *= 2;\n        }\n\n        tree.assign(2 * size - 1, e);\n    }\n\n    void update(int k, Monoid dat)\n    {\n        k += size - 1;\n        tree[k] = dat;\n        \n        while(k > 0) {\n            k = (k - 1) / 2;\n            tree[k] = f(tree[2 * k + 1], tree[2 * k + 2]);\n        }\n    }\n\n    // [l, r)\n    Monoid query(int l, int r)\n    {\n        l += size - 1;\n        r += size - 1;\n\n        Monoid d = e;\n        while (l < r) {\n            if (l % 2 == 0) {\n                d = f(d, tree[l]);\n                l++;\n            }\n            if (r % 2 == 0) {\n                r--;\n                d = f(d, tree[r]);\n            }\n\n            l = (l - 1) / 2;\n            r = (r - 1) / 2;\n        }\n\n        return d;\n    }\n\n};\n//===\n\nstruct Query { ll d, t, x; };\nstruct Team  { ll id, p;   };\n\nll point[100005];\nll t[100005];\nll n, r, l;\nQuery q[1000005];\n\nint main()\n{\n    scanf(\"%lld %lld %lld\", &n, &r, &l);\n\n    q[0].d = 0, q[0].t = 0, q[0].x = 0;\n    for (int i = 1; i <= r; i++) {\n        scanf(\"%lld %lld %lld\", &q[i].d, &q[i].t, &q[i].x);\n    }\n    q[r + 1].d = 0, q[r + 1].t = l, q[r + 1].x = 0;\n\n    SegmentTree<Team> seg(n + 1, (struct Team){0, 0},\n                          [](Team x, Team y) {\n                              if (x.p > y.p) {\n                                  return x;\n                              }\n                              else if (x.p == y.p) {\n                                  if (x.id < y.id) {\n                                      return x;\n                                  }\n                              }\n                              return y;\n                          });\n\n    for (int i = 1; i <= n; i++) {\n        seg.update(i, (struct Team){i, 0});\n    }\n\n    for (int i = 1; i <= r + 1; i++) {\n        Team x = seg.query(1, n + 1);\n        t[x.id] += q[i].t - q[i - 1].t;\n\n\n        point[q[i].d] += q[i].x;\n        seg.update(q[i].d, (struct Team){q[i].d, point[q[i].d]});\n        \n        //        printf(\"%lld %lld\\n\", x.id, x.p);\n    }\n\n    t[0] = -1;\n    int mpos = 0;\n    for (int i = 1; i <= n; i++) {\n        if (t[mpos] < t[i]) {\n            mpos = i;\n        }\n        //        printf(\"%lld\\n\", t[i]);\n    }\n\n    printf(\"%d\\n\", mpos);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 10000000\n#define MAX_TEAM 10000000\n\npriority_queue<pair<int, int>> Q;\nint d[MAX_TEAM], n, s, L, x[MAX_N], y[MAX_N], t[MAX_N], ti[MAX_TEAM];\n\nint main() {\n\tcin >> n >> s >> L;\n\tQ.push(make_pair(0, -1000000000));\n\tx[0] = 0; t[0] = 0; y[0] = 0; x[s + 1] = 0; t[s + 1] = L; y[s + 1] = 0;\n\tfor (int i = 1; i <= s + 1; i++) {\n\t\tif (i <= s) { cin >> x[i] >> t[i] >> y[i]; }\n\t\td[x[i]] += y[i];\n\t\tQ.push(make_pair(d[x[i]], -x[i]));\n\t\twhile (true) {\n\t\t\tpair<int, int>p = Q.top();\n\t\t\tif (p.first == d[-p.second]) {\n\t\t\t\tti[p.second] += x[i] - x[i - 1]; break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define INF (2 << 28)\nusing namespace std;\n\ntypedef pair<int, int> iiP;\n\nint n;\niiP seg[4 * 2 * 100001 - 1];\n\nvoid init(int q){\n\n  n = 1;\n  while(n < q) n *= 2;\n\n  for(int i = 0; i < n; i++) seg[i] = iiP(-INF, -i);\n\n}\n\nvoid update(int i, iiP a){\n\n  i += n - 1;\n  seg[i] = a;\n\n  while(i > 0){\n    i = (i - 1) / 2;\n    seg[i] = max(seg[i * 2 + 1], seg[i * 2 + 2]);\n  }\n\n}\nint main(){\n\n  int N, R, L, d, t, x, prev;\n  int sumt[100001] = {0}, score[100001] = {0};\n  cin >> N >> R >> L;\n\n  init(N);\n  cin >> d >> t >> x;\n  sumt[1] += t, score[d] += x;\n  update(d, iiP(score[d], -d));\n  prev = t;\n  //  cout << \":\" << score[d] << \" \" << d << endl;\n  for(int i = 1; i < R; i++){\n    cin >> d >> t >> x;\n    iiP p = seg[0];\n    score[d] += x, sumt[-p.second] += t - prev;\n    prev = t;\n    //\\cout << \":\" << score[d] << \" \" << d << endl;\n    update(d, iiP(score[d], -d));\n  }\n  iiP p = seg[0];\n  //  cout << p.first << \" \" << -p.second << endl;\n  sumt[-p.second] += L - prev;\n\n  cout << max_element(sumt + 1, sumt + N + 1) - sumt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 10000000\n#define MAX_TEAM 10000000\n\npriority_queue<pair<int, int>> Q;\nint d[MAX_N], n, s, L, x[MAX_N], y[MAX_N], t[MAX_N], d[MAX_TEAM], ti[MAX_TEAM];\n\nint main() {\n\tcin >> n >> s >> L;\n\tQ.push(make_pair(0, -1000000000));\n\tx[0] = 0; t[0] = 0; y[0] = 0; x[s + 1] = 0; t[s + 1] = L; y[s + 1] = 0;\n\tfor (int i = 1; i <= s + 1; i++) {\n\t\tif (i <= s) { cin >> x[i] >> t[i] >> y[i]; }\n\t\td[x[i]] += y[i];\n\t\tQ.push(make_pair(d[x[i]], -x[i]));\n\t\twhile (true) {\n\t\t\tpair<int, int>p = Q.top();\n\t\t\tif (p.first == d[-p.second]) {\n\t\t\t\tti[p.second] += x[i] - x[i - 1]; break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\t//point, team, time\n\nvoid solve()\n{\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\tpriority_queue< pair<int, int> > PQue;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tPQue.push(make_pair(0, -i));\n\t}\n\tint prev = 0;\n\tvector<int> score(N);\n\tvector<int> time(N);\n\tfor (int i = 0; i < R; ++i)\n\t{\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\t\t--d;\n\t\twhile (score[-PQue.top().second] != PQue.top().first)\n\t\t{\n\t\t\tint id = -PQue.top().second;\n\t\t\tPQue.pop();\n\t\t\tPQue.push(make_pair(score[id], -id));\n\t\t}\n\t\ttime[-PQue.top().second] += t - prev;\n\t\tscore[d] += x;\n\t\tPQue.push(make_pair(score[d], -d));\n\t\tprev = t;\n\t}\n\twhile (score[-PQue.top().second] != PQue.top().first)\n\t{\n\t\tint id = -PQue.top().second;\n\t\tPQue.pop();\n\t\tPQue.push(make_pair(score[id], -id));\n\t}\n\ttime[-PQue.top().second] += L - prev;\n\tcout << 1 + (max_element(time.begin(), time.end()) - time.begin()) << endl;\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct dat{ int id, point; };\n#define SIZE 1 << 17\n\nint N, R, L;\nint res[MAX_N + 1];\ndat seg[SIZE * 2 - 1];\nint n;\n\nvoid init(){\n\tn = 1;\n\twhile(n < N) n *= 2;//nはseg木の要素数\n\tfor(int i = 0; i < 2 * n - 1; i++) seg[i].point = 0;\n\tfor(int j = 0; j <= N; j++){\n\t\tseg[n + j].id = j;\n\t}\n}\n\nvoid add(int p, int x){\n\tp += n;\n\tseg[p].point += x;\n\twhile(p > 0){\n\t\t//printf(\"p = %d\\n\", p);\n\t\tp = (p - 1) / 2;\n\t\tif(seg[p * 2 + 1].point >= seg[p * 2 + 2].point){\n\t\t\tseg[p] = seg[p * 2 + 1];\n\t\t}\n\t\telse{\n\t\t\tseg[p] = seg[p * 2 + 2];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\tinit();\n\t\n\tint lb = 0;//左端\n\tint d, t, x;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tif(i > 0) res[seg[0].id] += t - lb;\n\t\tadd(d, x);\n\t\tlb = t;\n\t\t//for(int i = 1; i <= N; i++){\n\t\t//\tprintf(\"%d \", res[i]);\n\t\t//}\n\t\t//printf(\": seg[0].id = %d\\n\", seg[0].id);\n\t}\n\tres[seg[0].id] += L - t;\n\t\n\tint longest = 0;//最長の映り時間\n\tfor(int i = 1; i <= N; i++) longest = max(longest, res[i]);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(res[i] == longest){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long d[1000001],t[1000002],x[1000001],a[100001],b[100001];\nint main(void)\n{\n    int n,r,l,w,j,flg,h,g,m,i;\n\tscanf(\"%d %d %d\",&n,&r,&l);\n\tfor(i=1;i<=r;i++){\n\t    scanf(\"%lld %lld %lld\",&d[i],&t[i],&x[i]);\n\t}\n\tt[r+1]=l; d[0]=1; t[0]=0; x[0]=0;\n\tfor(i=1;i<=n;i++){\n\t    b[i]=0;\n\t\ta[i]=0;\n\t}\n\th=1;\n\tg=0;\n\tfor(i=0;i<=r;i++){\n\t    a[d[i]]=a[d[i]]+x[i];\n\t\tw=a[1];\n\t\tflg=1;\n\t\tfor(j=1;j<=n;j++){\n\t\t    if(w<a[j]){\n\t\t\t    w=a[j];\n\t\t\t\tflg=j;\n\t\t\t}\n\t\t}\n\t\tb[h]=b[h]+(t[i]-t[g]);\n\t\tg=i;\n\t\th=flg;\n\t}\n\tw=0;\n\tb[h]=b[h]+(l-t[g]);\n\tfor(i=1;i<=n;i++){\n\t    if(w<b[i]){\n\t\t    w=b[i];\n\t\t\tm=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <vector>\n#include <limits>\n\nconstexpr int MAX_N = 1000000;\nconstexpr auto INF = std::numeric_limits<int>::max();\n\nusing Pair = std::pair<int, int>;\n\nstruct segtree {\n    int N;\n    std::vector<Pair> dat{2*MAX_N};\n    segtree() {}\n    segtree(int n) {\n        N = 1;\n        while(N < n) N *= 2;\n        for(int i = 0; i < 2*N-1; i++)\n            dat[i] = {INF, INF};\n    }\n\n    void update(int k, int score) {\n        Pair a{-score, k};\n        k += N-1;\n        dat[k] = a;\n        while(k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = min(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    Pair query(int a, int b) { return query(a, b, 0, 0, N); }\n    Pair query(int a, int b, int k, int l, int r) {\n        if(r <= a or b <= l) return Pair{INF, INF};\n        if(a <= l and r <= b) return dat[k];\n        auto m = (l + r) / 2;\n        return min(query(a, b, k*2+1, l, m), query(a, b, k*2+2, m, r));\n    }\n};\n\nint n, r, l;\nint scores[MAX_N];\nint time_[MAX_N];\n\nint main() {\n    std::cin >> n >> r >> l;\n\n    segtree st(n);\n\n    for(int i = 0; i < n; ++i) {\n        st.update(i, 0);\n    }\n\n    std::fill(scores, scores + n, 0);\n    std::fill(time_, time_ + n, 0);\n\n    int d, t, x;\n    int prevTime = 0;\n    for(int i = 0; i < r; ++i) {\n        std::cin >> d >> t >> x;\n\n        auto m = st.query(0, n);\n\n        time_[m.second] += t - prevTime;\n\n        --d;\n\n        scores[d] += x;\n\n        st.update(d, scores[d]);\n\n        prevTime = t;\n    }\n\n    auto m = st.query(0, n);\n\n    time_[m.second] += l - prevTime;\n\n    /*for(int i = 0; i < n; ++i) {\n        std::cout << scores[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    for(int i = 0; i < n; ++i) {\n        std::cout << time_[i] << \" \";\n    }\n    std::cout << std::endl;\n*/\n    std::cout << (std::max_element(time_, time_ + n) - time_ + 1) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n  \n#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -111111\n#define MAX 111111\ntypedef pair<int,int> P;\nint n;\nP dat[4*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[100001];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  \n  int d,t,x,top=0,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[top].first+=t-bt;\n    update(d,x);\n    top=dat[0].second;\n    bt=t;\n  }\n  tim[top].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tvi v(n + 100, 0);\n\tinit(n);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tif(p.se > 0) continue;\n\t\tif(p.se == 0){\n\t\t\tv[p.se] += t - tt;\n\t\t\tcontinue;\n\t\t}\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n#define Seg_Max_N (1<<18) \n\nusing Value = pair<long long int, long long int>;\nconst Value ini = (make_pair(1e18, 0));\nstruct segtree {\n\tint N;\n\tvector<int>nums;\n\tvector<Value>dat;\n\n\tsegtree() {}\n\tsegtree(int n) :dat(2 * Seg_Max_N), nums(2 * Seg_Max_N) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++) {\n\t\t\tdat[i] = ini;\n\t\t}\n\t}\n\t// update k th element\n\tvoid update(int k, Value a) {\n\t\tk += N - 1; // leaf\n\t\tif (a == ini) {\n\t\t\tnums[k]--;\n\t\t\tif (!nums[k])dat[k] = a;\n\t\t}\n\t\telse {\n\t\t\tnums[k]++;\n\t\t\tdat[k] = a;\n\t\t}\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tconst Value al(dat[k * 2 + 1]);\n\t\t\tconst Value ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = min(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tValue  query(int a, int b) { return query(a, b, 0, 0, N); }\n\tValue  query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return ini;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tconst int m = (l + r) / 2;\n\t\tconst Value al(query(a, b, k * 2 + 1, l, m));\n\t\tconst Value ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn min(al,ar);\n\t}\n};\nint main() {\n\tint N, R, L; cin >> N >> R >> L;\n\tint pre = 0;\n\tint ntop = 0;\n\tvector<int>times(N);\n\tvector<int>scores(N);\n\tsegtree seg(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tseg.update(i, make_pair(0, i));\n\t}\n\tfor (int i = 0; i < R; ++i) {\n\t\tint d, t, x; cin >> d >> t >> x; d--;\n\t\tconst int top = seg.query(0, N).second;\n\t\ttimes[top] += t - pre;\n\t\tpre = t;\n\t\tscores[d] -= x;\n\t\tseg.update(d,make_pair( scores[d],d));\n\t}\n\tconst int top = seg.query(0, N).second;\n\ttimes[top] += L - pre;\n\tint amax = -1;\n\tint time = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (time < times[i]) {\n\t\t\ttime = times[i];\n\t\t\tamax = i;\n\t\t}\n\t}\n\tcout << amax+ 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long ans[200000] = {};\nlong long pre_cost[200000] = {};\nint main() {\n\tint n, r, l;\n\tcin >> n >> r >> l;\n\tvector<tuple<int, int, int>> hogea;\n\thogea.push_back(make_tuple(0, 0, 0));\n\tREP(i, r) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\thogea.push_back(make_tuple(n-a,b, c));\n\t}\n\thogea.push_back(make_tuple(0, l, 0));\n\tpriority_queue<pair<int,int>> nexting;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnexting.push(make_pair(0, i));\n\t\tpre_cost[i] = 0;\n\t}\n\tr += 2;\n\tfor (int i = 1; i < r; ++i) {\n\t\twhile (true) {\n\t\t\tif (pre_cost[nexting.top().second] == nexting.top().first) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnexting.pop();\n\t\t}\n\t\tans[nexting.top().second] += get<1>(hogea[i]) - get<1>(hogea[i-1]);\n\t\tpre_cost[get<0>(hogea[i])] += get<2>(hogea[i]);\n\t\tnexting.push(make_pair(pre_cost[get<0>(hogea[i])], get<0>(hogea[i])));\n\t}\n\tlong long bobo = -1;\n\tlong long itr = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bobo < ans[i]) {\n\t\t\tbobo = ans[i];\n\t\t\titr = n - i;\n\t\t}\n\t}\n\tcout << itr << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\nusing namespace std;\nint score[100010],show[100010];\nint main(){\n\tset<pair<int,int> >s;\n\tint N,R,L,d,t,x,c=0,m,n,i;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=1;i<=N;i++)s.insert(make_pair(0,0));\n\tfor(;R--;){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tshow[s.begin()->second]+=t-c,c=t;\n\t\ts.erase(make_pair(-score[d],d));\n\t\tscore[d]+=x;\n\t\ts.insert(make_pair(-score[d],d));\n\t}\n\tshow[s.begin()->second]+=L-c;\n\tfor(n=i=1,m=show[i];i<=N;i++)if(m<show[i])m=show[i],n=i;\n\tprintf(\"%d\\n\",n);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tpriority_queue<int, vector<pair<int, int> > > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tif(i != 0)ttime[temp.second] += t - ttemp;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef vector<P>VP;\ntypedef priority_queue<P,VP>PQ;\nint main(void){\n\tint n,r,l;\n\tint d,t,x;\n\tP   nn;\n\tint a,b,m;\n\tint i,j;\n\tint box[100001];\n\tint time[100001];\n\tint MAX,ans;\n\tPQ que;\n\tcin>>n>>r>>l;\n\tfor(i=1;i<=n;i++)\tbox[i]=time[i]=0;\n\tcin>>d>>t>>x;\n\ta=t;\n\tbox[d]+=x;\n\tque.push(P(box[d],-d));\n\tm=d;\n\tfor(i=0;i<r-1;i++){\n\t\tcin>>d>>t>>x;\n\t\tbox[d]+=x;\n\t\tque.push(P(box[d],-d));\n\t\t//cout<<d<<\" \"<<x<<endl;\n\t\twhile(1){\n\t\t\tnn=que.top();\n\t\t\tque.pop();\n\t\t\tnn.S*=-1;\n\t\t\tif(nn.F==box[nn.S])\tbreak;\n\t\t}\n\t\t//cout<<nn.F<<\" \"<<nn.S<<\" \"<<m<<endl;\n\t\ttime[m]+=t-a;\n\t\tm=nn.S;\n\t\ta=t;\n\t\tnn.S*=-1;\n\t\tque.push(nn);\n\t}\n\ttime[m]+=l-a;\n\tMAX=-1;\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\t//cout<<time[i]<<endl;\n\t\tif(MAX<time[i]){\n\t\t\tMAX=time[i];\n\t\t\tans=i;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\t\t\n\t\t\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d-1-e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;scanf(\"%lld%lld%lld\",&x,&y,&z);\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[100001],t[100001],x[100001];\nint pnt[100000];\nint cnt[100000];\nsigned main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n    d[R]=0;t[R]=L;x[R]=0;\n\n    if(R==0){\n        cout<<1<<endl;\n        return 0;\n    }\n    priority_queue<D>Q;\n\n    for(int i=0;i<N;i++)Q.push(D(0,i));\n    \n    int cur=0;\n    while(cur<R){\n        pnt[d[cur]]+=x[cur];\n        Q.push(D(pnt[d[cur]],d[cur]));\n        while(cur<R&&t[cur]==t[cur+1]){\n            cur++;\n            pnt[d[cur]]+=x[cur];\n            Q.push(D(pnt[d[cur]],d[cur]));\n        }\n\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]+=t[cur+1]-t[cur];\n\n        cur++;\n    }\n\n    cnt[0]+=x[0];\n\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  int t=search(id,n);\n  team[t].point+=key;\n  if(key<0){\n    maxHeapify(search(id,n));\n  }\n  else{\n    while(t>1&&team[t/2].point<team[t].point){\n      swap(team[t],team[t/2]);\n      t=t/2;\n    }\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=team[top].id;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    if(i==0){\n      team[search(1,n)].showed+=t[0];\n    }\n    IncreaseKey(d[i],x[i],n);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n    printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n  }\n  for(int i=1;i<=n;i++){\n    printf(\"%d %d   %d\\n\",team[i].id,team[i].showed,team[i].point);\n  }\n  show_top(team,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long ll;\ntypedef struct {\n  int id;\n  ll sc;\n} node;\nnode dat[1<<18];\nint tim[111111];\nint n;\n\nnode max(node a,node b) {\n  if( a.sc < b.sc ) return b;\n  if( a.sc > b.sc ) return a;\n  return a.id > b.id ? b : a;\n}\n\nvoid update(int k,node x)\n{\n  k += n-1;\n  dat[k] = x;\n  while( k > 0 ) {\n    k /= 2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nint a[1111111],b[1111111];\nll c[1111111];\n\nint main(void)\n{\n  int n_,r,l,i,j,pre,ma,res;\n  scanf(\"%d%d%d\",&n_,&r,&l);\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for( i = 0; i < n; i++ ) dat[i+n-1].id = i;\n  for( i = 0; i < n; i++ ) update(i,(node){i,-999999999999ll});\n  for( i = 0; i < n_; i++ ) update(i,(node){i,0ll});\n  for( i = 0; i < r; i++ ){ scanf(\"%d%d%lld\",a+i,b+i,c+i); a[i]--; }\n  b[r] = l;\n  pre = 0;\n  for( i = 0; i <= r; i++ ) {\n    tim[dat[0].id] += b[i]-pre;\n    for( j = i; j <= r && b[i] == b[j]; j++ ) {\n      update(a[j],(node){a[j],dat[a[j]+n-1].sc+c[j]});\n    }\n    i = j-1;\n    pre = b[i];\n  }\n  ma = 0;\n  res = 0;\n  for( i = 0; i < n_; i++ ) {\n    if( ma < tim[i] ) {\n      ma = tim[i];\n      res = i+1;\n    }\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fr first\n#define sc second\nP seg[1<<18];\nint n;\nvoid update(int id,int pt){\n  int k = id + n - 1;\n  seg[k].fr += pt;\n  seg[k].sc = -id;\n  while(k != 0){\n    k = ( k - 1 ) / 2;\n    seg[k] = max(seg[2*k+1],seg[2*k+2]);\n  }\n}\nvoid init(int size) {\n  n = 1;\n  while(n < size) n *= 2;\n  for(int i = 0 ; i < size ; i++ ) update(i,0);\n}\nint main(){\n  int N,R,L;\n  scanf(\"%d %d %d\",&N,&R,&L);\n  init(N);\n  int mostid = 0 , now = 0 , sum[100000] = {};\n  for(int i = 0 ; i < R ; i++ ){\n    int d,t,x;\n    scanf(\"%d %d %d\",&d,&t,&x);\n    update(d-1,x);\n    sum[mostid] += t - now;\n    now = t;\n    mostid = -seg[0].sc;\n  }\n  sum[mostid] += L - now;\n  int rec = 0;\n  for(int i = 0 ; i < N ; i++) if( sum[rec] < sum[i] ) rec = i;\n  printf(\"%d\\n\",rec+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint a[100005][2];\npriority_queue<pair<int,int> > q1;\nint main(){\n\tint n=0;\n\tint r=0;\n\tint l=0;\n\tint f[10];\n\tint i=0;\n\tint j=0;\n\tint d=0;\n\tint t=0;\n\tint x=0;\n\tint sa=0;\n\tmemset(a,0,sizeof(a));      \n\tmemset(f,0,sizeof(f));\n\tcin>>n>>r>>l;\n\tfor(i=0;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\td--;\n\t\ta[f[1]][1]+=t;\n\t\ta[d][0]+=x;\n\t\tq1.push(make_pair(a[d][0],d));\n\t\tf[0]=q1.top().first;          \n\t\tf[1]=q1.top().second;\n\t\twhile(f[0]!=a[f[1]][0]){\n\t\t\tq1.pop();\n\t\t\tf[0]=q1.top().first;          \n\t\t\tf[1]=q1.top().second;\n\t\t}\n\t\ta[f[1]][1]-=t;\n\t}\n\ta[f[1]][1]+=l;\n\tfor(i=0;i<n;i++){\n\t\tif(sa<a[i][1]){\n\t\t\tsa=i;\n\t\t}\n\t}\n\tsa++;\n\tcout<<sa;\n}\n\t\n\t\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define OZAWA -999999\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = OZAWA;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t//\tprintf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nint INF=1<<28;\nstruct SegmentTree{\n\tvector<int> dat;\n\tvector<int> mi;\n\n\tint n,size;\n\tSegmentTree(int _n){\n\t\tn=Pow2Fit(_n)<<1;\n\t\tsize=2*n-1;\n\t\tdat=vector<int>(size,-INF);\n\t\tmi=vector<int>(size,INF);\n\t}\n\tint Pow2Fit(int n){\n\t\t  n = n | (n >>  1);n = n | (n >>  2);n = n | (n >>  4);n = n | (n >>  8);n = n | (n >> 16);\n\t\t  return n ^ (n >> 1);\n\t}\n\n\tint getDat(int v){\n\t\tv+=n-1;\n\t\treturn dat[v];\n\t}\n\n\tvoid update(int v,int a){\n\t\tv+=n-1;\n\t\tdat[v]=a;\n\t\tmi[v]=v-(n-1);\n\t\twhile(v>0){\n\t\t\tint parent=v=(v-1)/2;\n\t\t\tint chl=parent*2+1,chr=parent*2+2;\n\t\t\tif(dat[chl]>=dat[chr])mi[parent]=mi[chl];\t\t\t\t\n\t\t\telse mi[parent]=mi[chr];\n\t\t\tdat[parent]=max(dat[chl],dat[chr]);\n\t\t}\n\t}\n\n\tint query(int a,int b){\n\t\treturn query(0,a,b,0,n);\n\t}\n\n\tprivate:\n\tint query(int v,int a,int b,int l,int r){\n\t\tif(r<=a || b<=l)return -1;//out range\n\t\tif(a<=l && r<=b)return mi[v];\n\n\t\tint vl=query(v*2+1,a,b,l,(l+r)/2);\n\t\tint vr=query(v*2+2,a,b,(l+r)/2,r);\n\t\tif(vl==-1)return vr;\n\t\tif(vr==-1)return vl;\n\n\t\tif(dat[vl+(n-1)]>=dat[vr+(n-1)])return vl;\n\t\telse return vr;\n\t}\n};\n\nclass Task{\n\tpublic:\n\tint d,t,x;\n\tTask(int d,int t,int x):d(d),t(t),x(x){\n\t}\n};\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,R,L;cin >> N >> R >> L;\n\t\tvector<Task> ts;\n\t\tREP(i,R){\n\t\t\tint d,t,x;cin >> d >> t >> x;d--;\n\t\t\tts.push_back(Task(d,t,x));\n\t\t}\n\n\t\tvector<int> vs(N);\n\t\tSegmentTree seg(N);\n\t\tREP(i,N)seg.update(i,0);\n\n\t\tint pt=0;\n\t\tREP(i,R){\n\t\t\tvs[seg.query(0,N)]+=ts[i].t-pt;\n\t\t\tpt=ts[i].t;\n\t\t\tseg.update(ts[i].d,seg.getDat(ts[i].d)+ts[i].x);\n\t\t}\n\t\tvs[seg.query(0,N)]+=L-pt;\n\n\t\tint Mv=0;\n\t\tREP(i,N)Mv=max(Mv,vs[i]);\n\t\t\n\t\tREP(i,N)if(Mv==vs[i]){\n\t\t\tcout <<i+1<<endl;return;\n\t\t}\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAX 100000\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nint H;\nTeam team[MAX+1];\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nTeam extract(Team* team){\n  Team maxv;\n  maxv=team[1];\n  team[1]=team[H--];\n  maxHeapify(1);\n  return maxv;\n}\nvoid IncreaseKey(int i,int key){\n  team[i].point+=key;\n  while(i>1&&team[i/2].point<team[i].point){\n    swap(team[i],team[i/2]);\n    i=i/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=0;\n  for(int i=0;i<n;i++){\n    if(team[i].showed>team[top].showed) top=i;\n  }\n  printf(\"%d\\n\",top);\n}\n  \nint main(){\n  int n,r,l;\n  int d[1000000];\n  int t[1000000];\n  int x[1000000];\n  scanf(\"%d%d%d\",&n,&r,&l);\n  for(int i=0;i<n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n    IncreaseKey(d[i],x[i]);\n    Team top=extract(team);\n    if(i>0){\n    top.showed+=t[i]-t[i-1];\n    }\n  }\n  show_top(team,n);\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long int Int;\n#define REP(i, j) for(Int i = 0; i < (Int)(j); ++i)\n#define FOR(i, j, k) for(Int i = (Int)(j); i < (Int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<Int, Int> P;\nconst Int MAX_N = 100010;\n\nnamespace std {\n  bool operator > (const P& a, const P& b) {\n    return a.first != b.first ? a.first > b.first : a.second < b.second;\n  }\n}\n\nInt n;\nP v[2 * MAX_N - 1];\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(Int nn){\n  n = 1;\n  while(n < nn) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(0, 1);\n  REP(i, nn) v[i + n - 1] = P(0, i + 1);\n}\n\n// テヲツキツサテ・ツュツ療」ツ?渓テ」ツ?ョテ」ツつづ」ツ?ョテ」ツつ誕テ」ツ?ォテヲツ崢エテヲツ鳴ー\nvoid update(Int k, Int a){\n  k += n - 1;\n  v[k].first = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);\n  }\n}\n\n// [a, b)テ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?、テ」ツつ津ヲツ個?」ツ?、テ」ツδ?」ツδシテ」ツδ?」ツδ甘」ツδウテ」ツδ静」ツδシテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n// kテ」ツ?ッテ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ヲツキツサテ・ツュツ療」ツ?〕, rテ」ツ?ッテ」ツ?敕」ツつ古」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ擬l, r)\n// テ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?凖ヲツ卍づ」ツ?ッquery(a, b, 0, 0, n)テ」ツ?ィテ」ツ?療」ツ?ヲテ・ツ堕シテ」ツ?カ\nP query(Int a, Int b, Int k, Int l, Int r){\n  if(b <= l || a >= r) return P(-1, -1);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return max(vl, vr);\n}\n\nint main() {\n  Int N, R, L, idx = 0, now = 0; cin >>N >>R >>L;\n  P tar = P(0, 1);\n  vector<Int> cnt(N, 0), D(R), T(R), X(R);\n  REP(i, R) { cin >>D[i] >>T[i] >>X[i]; --D[i]; }\n  init(N);\n\n  FOR(i, 1, L + 1){\n    cnt[now]++;\n    while(idx < R && T[idx] == i){\n      update(D[idx], X[idx] + v[D[idx] + n - 1].first);\n      now = query(0, N, 0, 0, n).second - 1;\n      ++idx;\n    }\n  }\n  Int ans = 0;\n  REP(i, N) if(cnt[i] > cnt[ans]) ans = i;\n  cout <<ans + 1 <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += (t-oldt);\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n    }else old = max(pt,N);\n  }\n  ptime[old] += (L-t);\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\n\nconst int INF = 1<<30;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -INF);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tteam[k] = P(a, k - n + 1);\n\t\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n    for(int i = 0; i < 100010; ++i)\n        p[i] = -INF;\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n    for(int i = 0; i < m; ++i){\n\t\tupdate(i, 0);\n        p[i] = 0;\n    }\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[d + n - 2].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[team[0].second] += (l - t);\n\t\n\tint rank[100010] = {0};\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i){\n\t\tif(rank[i] == p[0]){\n\t\t\tcout << i + 1 << endl;\n            return 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct T {\n  int i, s;\n\n  bool operator<(const T& right) const {\n    return s == right.s ? i < right.s : s < right.s;\n  }\n};\n\nint MAX_N = 1 << 17;\nint n = 1;\nvector<T> dat(MAX_N * 2 - 1);\nT minT;\n\nvoid update(int k, int a) {\n  k = k + n - 1;\n  dat[k].s += a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint main() {\n  int t, r, l, z = 0, zi = 0, sc[100001] = {};\n  cin >> t >> r >> l;\n  while(t > n) n *= 2;\n  minT.i = 10000000;\n  minT.s = 0;\n  rep(i, 0, n * 2 - 1) dat[i] = minT;\n  rep(i, n - 1, n * 2 - 1) dat[i].i = i - (n - 1);\n\n\n\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    sc[zi] += b - z;\n    update(a - 1, c);\n    zi = dat[0].i;\n    z = b;\n  }\n\n  sc[zi] += l - z;\n  int ms = 0, ans;\n  rep(i, 0, t) if(ms < sc[i]) ans = i + 1, ms = sc[i];\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1<<17;\ntypedef pair<int,int> pii;\n\nclass RMQ{\npublic:\n  int n;\n  pii dat[2*MAX_N-1];\n\n  void init(int n_){\n    n = 1;\n    while(n < n_){ n *= 2; }\n    for(int i = 0 ; i < 2*n-1 ; i++){\n      dat[i] = pii(INT_MIN,INT_MIN);\n    }\n    for(int i = 0 ; i < n_ ; i++){\n      update(i,0);\n    }\n  }\n\n  void update(int k,int a){\n    int tk = k;\n    k += n - 1;\n    dat[k] = pii(a,-tk);\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  pii query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l){ return pii(INT_MIN,INT_MIN); }\n    if(a <= l && r <= b){\n      return dat[k];\n    }else{\n      pii vl = query(a,b,k*2+1,l,(l+r)/2);\n      pii vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    }\n  }\n};\n\nint main(){\n  int N,R,L;\n  RMQ rmq;\n  cin >> N >> R >> L;\n  rmq.init(N);\n  int d,t,x,pt = 0;\n  vector<int> point(N,0);\n  for(int i = 0 ; i < R ; i++){\n    cin >> d >> t >> x; d--;\n    point[-rmq.query(0,N,0,0,rmq.n).second] = t-pt;\n    rmq.update(d,x+rmq.dat[d+rmq.n-1].first);\n    pt = t;\n  }\n    point[-rmq.query(0,N,0,0,rmq.n).second] = L-pt;\n  int res = -1, max = INT_MIN;\n  for(int i = 0 ; i < N ; i++){\n    if(max < point[i]){\n      max = point[i];\n      res = i+1;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100001)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\nint n_;\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int score[4*MAX_N -1],time[4*MAX_N -1];\n  int r,l,n;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  n_=n;\n  n=1;\n  while(n<n_) n*=2;\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    //printf(\"k=%d\\n\",k);\n    updata(time, k, time[k+n-2]+t, n);\n\n    //printf(\"b\\n\");\n    updata(score, d, score[d+n-2]+x, n);\n  \n\n    /*printf(\"c\");\n    \n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n-1;i<n*2-1;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n      }*/\n    \n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-2]+t, n);\n\n  /*\n  printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*4-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-2;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n_) return k-n+2; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[199999];\nint point[100000];\nint n=1;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--; g--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\ta[c] = P(d-1, p(0, 0));\n\tc++;\n\twhile (n < b)n <<= 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment[n + i - 1].second = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tkousin(0, 0);\n\t}\n\tn--;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = a; i < b; i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nstruct SegmentTree {\n\tpii init_val;\n\tint n;\n\tvector<pii> dat;\n\t\n\tSegmentTree(int _n) {\n\t\tinit_val = pii(-INF, -INF);\n\t\tn = 1;\n\t\twhile (n < _n) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, init_val);\n\t}\n\t\n\tvoid update(int k, pii a) {\n\t\tk += n - 1;\n\t\tdat[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdat[k] = max(dat[2 * k + 1], dat[2 * k + 2]);\n\t\t}\n\t}\n\t\n\tpii query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return init_val;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\treturn max(query(a, b, k * 2 + 1, l, (l + r) / 2),\n\t\t\tquery(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t\n\tpii query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\ntypedef SegmentTree Seg;\n\nint main() {\n\tint n, r, l;\n\tcin >> n >> r >> l;\n\t\n\tvector<pii> ans(n, pii(0, 0)); // time, -ID\n\tREP(i, n) ans[i].second = -i;\n\tSeg seg(n); // score, -ID\n\tREP(i, n) seg.update(i, pii(0, -i));\n\t\n\tint beft = 0; //??\\????????????\n\t\n\twhile (r--) {\n\t\tint d, t, x;\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\td--;\n\t\t\n\t\tpii tmp = seg.query(0, n); // ?????§????????????????????????score, -ID\n\t\t\n\t\tans[-tmp.second].first += t - beft;\n\t\t\n\t\tseg.update(d, pii(seg.query(d, d + 1).first + x, -d)); \n\n\t\tbeft = t;\n\t}\n\tans[-seg.query(0, n).second].first += l- beft;\n\t\n\tsort(ans.rbegin(), ans.rend());\n\tcout << -ans[0].second + 1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing uint = unsigned int;\nusing int64 = long long;\nusing i64 = int64;\nusing uint64 = unsigned long long;\nusing vint = vector<int>;\nusing vint64 = vector<int64>;\ntemplate<typename T>\nusing p_que = priority_queue<T>;\n#define rep(i,N) for(int i=0;i<(int)(N);++i)\n#define rep1(i,N) for(int i=1;i<=(int)(N);++i)\n#define fs first\n#define sc second\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tos << \"[\";\n\tfor (auto& e : v) os << e << \", \";\n\treturn os << \"]\";\n}\n\ntemplate<class T, class U> ostream& operator<<(ostream& os, const vector<pair<T, U>> p) {\n\tos << \"P(\" << p.first << \", \" << p.second << endl;\n}\n\n/*\ntemplate<class T, class U> ostream& operator<<(ostream& os, const map<T, U>& mp) {\n\tos << \"{\";\n\tfor (auto& e : mp) os << P << \" \";\n\treturn os << \"}\";\n}\n*/\n\nvoid Main();\nsigned main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tMain();\n}\n\n/* Insert from here! */\ntemplate <typename Monoid>\nstruct SegmentTree {\n\tusing F = function<Monoid(Monoid, Monoid)>;\n\tint sz;\n\tvector<Monoid> seg;\n\n\tconst F f;\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid& x) {\n\t\tseg[k + sz] = k;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; k--) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid& x) {\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) L = f(L, seg[a++]);\n\t\t\tif (b & 1) R = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int& k) const {\n\t\treturn seg[k + sz];\n\t}\n};\n\n/* Cut from here! */\n\nusing pint = pair<int, int>;\nstruct LOG { int d, t, x; };\n\nvoid Main() {\n\tint N, R, L; cin >> N >> R >> L;\n\tpriority_queue<pint> que;\n\trep(i, N) que.emplace(0, i*-1);\n\tvector<int> score(N, 0);\n\tvector<int> time(N, 0);\n\n\tint prevtime = 0;\n\tint looks, lookt;\n\trep(i, R) {\n\t\tint t, d, x; cin >> d >> t >> x;\n\t\twhile (1) {\n\t\t\ttie(looks, lookt) = que.top();\n\t\t\tlookt *= -1;\n\t\t\tif (score[lookt] == looks) break;\n\t\t\telse que.pop();\n\t\t}\n\t\t// 時間更新\n\t\ttime[lookt] += t - prevtime;\n\t\tprevtime = t;\n\t\t//cout << \"  add team : \" << lookt << endl;\n\t\t// 得点更新\n\t\tscore[d - 1] += x;\n\t\tque.emplace(score[d - 1], (d - 1)*-1);\n\t\t//cout << \"  score : \" << score << endl;\n\t}\n\t// 最後の時間更新\n\twhile (1) {\n\t\ttie(looks, lookt) = que.top();\n\t\tlookt *= -1;\n\t\tif (score[lookt] == looks) break;\n\t\telse que.pop();\n\t}\n\ttime[lookt] += L - prevtime;\n\t\n\tint maxtime=-1, ans;\n\t//cout << time;\n\trep(i, N) {\n\t\tif (maxtime < time[i]) {\n\t\t\tmaxtime = time[i];\n\t\t\tans = i + 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nconst int MAX_N=100000,MAX_R=1000000;\n\ntypedef pair<int,int> P;\n\nint N,R,L;\nint d[MAX_R],t[MAX_R+1],x[MAX_R];\n\nint scean[MAX_N];\t//?????£?????????\nint point[MAX_N];\t//??????\n\nint main(){\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tfor (int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d[i],&t[i],&x[i]);\n\t\td[i]--;\n\t}\n\tt[R]=L;\t//??????\n\tscean[0]=t[0];\n\tpriority_queue<P> pq;\n\tfor (int i=0;i<N;i++){\n\t\tpq.push(make_pair(0,-i));\t//first=??????,second=-???????????????\n\t}\n\tfor (int i=0;i<R;i++){\n\t\tpoint[d[i]]+=x[i];\n\t\tpq.push(make_pair(point[d[i]],-d[i]));\n\t\twhile(point[-pq.top().second]!=pq.top().first){\n\t\t\tpq.pop();\n\t\t}\n\t\tscean[-pq.top().second]+=t[i+1]-t[i];\n\t}\n\tint res=0;\t//?????????????????£????????????\n\tfor (int i=1;i<N;i++){\n\t\tif (scean[res]<scean[i]) res=i;\n\t}\n\tprintf(\"%d\\n\",res+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct node {\n\tint id, score;\n};\nbool operator<(node a, node b) {\n\tif (a.score == b.score)return a.id > b.id;\n\treturn a.score < b.score;\n}\nint s[100000], cnt[100000];\nint d[1000000], t[1000000], x[1000000];\nint main() {\n\tint n, r, l; scanf(\"%d%d%d\", &n, &r, &l);\n\tpriority_queue<node>que;\n\trep(i, r)scanf(\"%d%d%d\", &d[i], &t[i], &x[i]);\n\trep(i, r) {\n\t\td[i]--;\n\t\ts[d[i]] += x[i];\n\t\tque.push({ d[i],s[d[i]] });\n\t\twhile (!que.empty() && que.top().score != s[que.top().id])que.pop();\n\t\tif (i == r - 1)cnt[que.top().id] += l - t[i];\n\t\telse cnt[que.top().id] += t[i + 1] - t[i];\n\t}\n\tprintf(\"%d\\n\", max_element(cnt, cnt + n) - cnt + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tttime[1] = 100;\n\tpriority_queue<int, vector<pair<int, int> > > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tif(i != 0)ttime[temp.second] += t - ttemp;\n\t\t//cout << i << \"  \" << temp.second << \"  \" << ttime[temp.second] << endl;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n\nint main(){\n\tll n,r,l,maxtime=0,ansid=0,nowtime=0,nexttime;\n\tll player[100000][2]={};//0 今まで表示された時間　１　今のスコア\n\tmap<ll,set<ll>,greater<ll>> score;//得点　id\n\tcin>>n>>r>>l;\n\tfor(ll i=0; i<n; i++){\n\t\tscore[0].insert(i);\n\t}\n\t//cout<<score.rend<<endl;//era-\n\tfor(ll i=0;i<r; i++){\n\t\tll d,x;\n\t\tcin>>d>>nexttime>>x;\n\t\td--;\n\t\tll topid=0;\t\t//わからん   //今一番高いやつのidを保存\n\t\tfor(auto & t : score){\n\t\t\t//for(ll o : t.second){\n\t\t\t//\tcout<<\"www\"<<o<<endl;\n\t\t\t//}\n\t\t\tfor(ll o : t.second){\n\t\t\t\t//cout<<\"score\"<<o<<endl;\n\t\t\t\ttopid=o;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//cout<<topid<<endl;\n\t\tplayer[topid][0]+= (nexttime-nowtime);//表示時間を追加\n\t\t\n\t\t\n\t\tif(player[topid][0] > maxtime){//一番長く表示された時間を更新\n\t\t\tansid=topid;\n\t\t\tmaxtime=player[topid][0];\n\t\t}else if(player[topid][0] == maxtime && topid < ansid){\n\t\t\tansid=topid;\n\t\t}\n\t\t\n\t\t\n\t\t//topが変わったかどうかを記録する\n\t\tscore[player[d][1]].erase(d);//前の記録を消す\n\t\t//if(score[player[d][1]].size() == 0)//消した記録が\n\t\t//\tscore.erase(player[d][1]);\n\t\t//\n\t\tplayer[d][1]+=x;//記録を更新\n\t\tscore[player[d][1]].insert(d);//新しくできたデータを保存\n\t\t\n\t\tnowtime=nexttime;//時間を更新\n\t\t//cout<<\"########\"<<endl;\n\t\t//for(ll u=0; u<n; u++){\n\t\t//\tcout<<u<<\" \"<<player[u][0]<<\" \"<<player[u][1]<<endl;\n\t\t//}\n\t\t//cout<<\"########\"<<endl;\n\t}\n\t\n\t\n\t\n\t\n\tll topid=2;   //わからん   //今一番高いやつのidを保存\n\t//cout<<\"WWWW\"<<endl;\n\tbool c=true;\n\tfor(auto & t : score){\n\t\t//cout<<\"scor\"<<endl;\n\t\t//for(ll o : t.second){\n\t\t//\tcout<<\"score\"<<o<<endl;\n\t\t//}\n\t\tfor(ll o : t.second){\n\t\t\tif(c){\n\t\t\t\ttopid=o;\n\t\t\t\t//cout<<\"1break\"<<endl;\n\t\t\t\tc=false;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!c){\n\t\t\tbreak;\n\t\t}\n\t\t//cout<<\"break\"<<endl;\n\t}\n\t//cout<<topid<<endl;\n\tplayer[topid][0]+=l-nowtime;//表示時間を追加\n\t\t\n\t\t\n\tif(player[topid][0] > maxtime){//一番長く表示された時間を更新\n\t\tansid=topid;\n\t\tmaxtime=player[topid][0];\n\t}else if(player[topid][0] == maxtime && topid < ansid){\n\t\tansid=topid;\n\t}\n\t//for(ll i=0; i<n; i++){\n\t//\tcout<<player[i][0]<<\" \"<<player[i][1]<<endl;\n\t//}\n\tcout<<ansid+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[1000010];\nstruct node {\n    int id, point;\n} node[1<<22];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define INF (1 << 30)\n#define INFL (1LL << 62)\n#define MOD7 1000000007\n#define MOD9 1000000009\n#define EPS 1e-10\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pul pair<ull, ull>\n#define all(a) (a).begin(), (a).end()\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);--i)\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nvoid YES() { cout << \"YES\" << endl; }\nvoid NO() { cout << \"NO\" << endl; }\nvoid Yes() { cout << \"Yes\" << endl; }\nvoid No() { cout << \"No\" << endl; }\nvoid yes() { cout << \"yes\" << endl; }\nvoid no() { cout << \"no\" << endl; }\nvoid Taka() { cout << \"Takahashi\" << endl; }\nvoid Aoki() { cout << \"Aoki\" << endl; }\nvoid digit(int d) { cout << fixed << setprecision(d); }\nvoid IOup() { cin.tie(0); ios::sync_with_stdio(false); }\n\nclass RMQ {\n\tvector<pii> data;\n\tint size;\n\tint suffix;\n\npublic:\n\tRMQ() {}\n\tRMQ(int n) {\n\t\tsuffix = -1;\n\t\tresize(n);\n\t}\n\n\tvoid resize(int n) {\n\t\tsize = 1;\n\t\twhile (size < n) {\n\t\t\tsize <<= 1;\n\t\t}\n\t\tdata.resize(size * 2 - 1);\n\t\tfor (int i = n - 1; i < size * 2 - 1; ++i) {\n\t\t\tdata[i] = pii(0, i - (n - 1));\n\t\t}\n\t}\n\n\tpii& operator[](int i) {\n\t\tupdate();\n\t\tsuffix = i;\n\t\treturn data[i + size - 1];\n\t}\n\n\tvoid update() {\n\t\tif (suffix < 0)\n\t\t\treturn;\n\t\tint k = suffix + size - 1;\n\t\tsuffix = -1;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tdata[k] = std::min(data[k * 2 + 1], data[k * 2 + 2]);\n\t\t}\n\t}\n\n\tpii min(int a, int b) {\n\t\tupdate();\n\t\tsuffix = -1;\n\t\treturn min(a, b, 0, 0, size);\n\t}\n\n\tpii min(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)\n\t\t\treturn pii(0, INF);\n\t\tif (a <= l && r <= b)\n\t\t\treturn data[k];\n\t\tint m = (l + r) / 2;\n\t\treturn std::min(min(a, b, k * 2 + 1, l, m), min(a, b, k * 2 + 2, m, r));\n\t}\n};\n\nint tt[100001];\n\nint main() {\n\tint n, r, l, d, b, t, x;\n\tcin >> n >> r >> l;\n\tRMQ p(n + 1);\n\t\n\tb = 0;\n\tfor (int i = 0; i < r; ++i) {\n\t\tcin >> d >> t >> x;\n\t\tauto tmp = p.min(1, n + 2);\n\t\ttt[tmp.second] += t - b;\n\t\tp[d].first -= x;\n\t\tb = t;\n\t}\n\ttt[p.min(1, n + 2).second] += l - b;\n\t\n\tint m = 0, ans;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (m < tt[i]) {\n\t\t\tm = tt[i];\n\t\t\tans = i;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\npair<int,int> rmq[111111111];\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-1;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      team[smp-2] += t[i] - now;\n      if(t[i] != t[i+1]){ \n\tnow = t[i];\n      }\n    }\n    smp = rmq[0].second;\n  }\n  team[smp-2] += L - now;\n  int a=0;\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nstruct SegTree {\n    int N;\n    vector<int> data;\n    SegTree(int size) {\n        N = 1;\n        while(N < size) N *= 2;\n        data.assign(2*N - 1, 0);\n    }\n    void add(int k, int a) {\n        k += N - 1; // leaf\n        data[k] += a;\n        while(k > 0) {\n            k = (k - 1) / 2; // up\n            data[k] = max(data[2*k + 1], data[2*k + 2]); // left, right\n        }\n    }\n    int search() {\n        return sub(0) - (N - 1);\n    }\n    int sub(int k) {\n        if(k >= N - 1) { // leaf\n            return k;\n        }\n        if(data[2*k + 1] == data[k]) return sub(2*k + 1);\n        else return sub(2*k + 2);\n    }\n};\n\nint main() {\n    int N, R, L; cin >> N >> R >> L;\n    vector<int> score(N, 0);\n    SegTree segt(N);\n    int curteam = 0;\n    int curtime = 0;\n    for(int i = 0; i < R; i++) {\n        int k, t, p; cin >> k >> t >> p;\n        k--;\n\n        score[curteam] += (t - curtime);\n        segt.add(k, p);\n        curteam = segt.search();\n        curtime = t;\n    }\n    score[curteam] += (L - curtime);\n    cout << distance(score.begin(), max_element(score.begin(), score.end())) + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define in ,\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nstruct T {\n  int i, s;\n\n  bool operator<(const T& right) const {\n    return s == right.s ? i > right.s : s < right.s;\n  }\n};\n\nint MAX_N = 1 << 17;\nint n = 1;\nvector<T> dat(MAX_N * 2 - 1);\nT minT;\n\nvoid update(int k, int a) {\n  k = k + n - 1;\n  dat[k].s += a;\n  while(k > 0) {\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nint main() {\n  int t, r, l, z = 0, zi = 0, sc[100001] = {};\n  cin >> t >> r >> l;\n  while(t > n) n *= 2;\n  minT.i = 10000000;\n  minT.s = 0;\n  rep(i, 0, n * 2 - 1) dat[i] = minT;\n  rep(i, n - 1, n * 2 - 1) dat[i].i = i - (n - 1);\n\n\n\n  rep(i, 0, r) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    sc[zi] += b - z;\n    update(a - 1, c);\n    zi = dat[0].i;\n    z = b;\n  }\n\n  sc[zi] += l - z;\n  int ms = 0, ans;\n  rep(i, 0, t) if(ms < sc[i]) ans = i + 1, ms = sc[i];\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nstruct SegTree {\n\tint *dat;\n\tint *max_idx;\n\tint size;\n\tSegTree(int _size) {\n\t\tsize=1;\n\t\twhile(_size>size) size*=2;\n\t\tdat=(int*)malloc(sizeof(int)*size);\n\t\tmax_idx=(int*)malloc(sizeof(int)*(size*2-1));\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tif(i<_size) dat[i]=0; else dat[i]=-(1<<30);\n\t\t}\n\t\tfor(int i=size*2-1;i>=0;i--) {\n\t\t\tif(i>=size) {\n\t\t\t\tmax_idx[i]=i-size;\n\t\t\t}else {\n\t\t\t\tmax_idx[i]=max_idx[i*2+1];\n\t\t\t}\n\t\t}\n\t}\n\tvoid update(int k,int a) {\n\t\tdat[k]+=a;\n\t\tk+=size-1;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tif(dat[max_idx[k*2+1]]>=dat[max_idx[k*2+2]]) {\n\t\t\t\tmax_idx[k]=max_idx[k*2+1];\n\t\t\t}else {\n\t\t\t\tmax_idx[k]=max_idx[k*2+2];\n\t\t\t}\n\t\t}\n\t}\n};\nint Time[100000];\nint main() {\n\tint N,R,L;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tSegTree S(N);\n\tint cur=0;\n\tfor(int i=0;i<R;i++) {\n\t\tint d,t,x;\n\t\tscanf(\"%d %d %d\",&d,&t,&x); d--;\n\t\tTime[S.max_idx[0]]+=t-cur;\n\t\tS.update(d,x);\n\t\tcur=t;\n\t}\n\tTime[S.max_idx[0]]+=L-cur;\n\tint max_time=0,max_id=0;\n\tfor(int i=0;i<N;i++) {\n\t\tif(Time[i]>max_time) {\n\t\t\tmax_time=Time[i];\n\t\t\tmax_id=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max_id+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint ten[100001],tt[100001];\npriority_queue<P> qu;\nint main(void)\n{\n\tint n,r,l;\n\n\tP ppp;\n\tint t1,n1,i,j,nn;\n\tint d,t,x,max,maxi;\n\n\tscanf(\"%d %d %d\",&n,&r,&l);\n\tfor(i=1;i<=n;i++)\t{\n\t\tten[i]=0;\n\t\ttt[i]=0;\n\t\tqu.push(P(0,100000-i));\n\t}\n\tn1=1;\n\tt1=0;\n\t\n\tfor(i=0;i<r;i++)\t{\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\ttt[n1]+=t-t1;\n\t\tten[d]+=x;\n\t\tqu.push(P(ten[d],100000-d));\n\t\tt1=t;\n\t\twhile(1)\t{\n\t\t\tppp=qu.top();\n\t\t\tnn=100000-ppp.second;\n\t\t\tif(ten[nn]==ppp.first)\t{\n\t\t\t\tn1=nn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqu.pop();\n\t\t}\n//\t\tprintf(\"n1=%d t1=%d\\n\",n1,t1);\n\t}\n\ttt[n1]+=l-t1;\n\tmax=-1;\n\tfor(i=1;i<=n;i++)\t{\n\t\tif(tt[i]>max)\t{\n\t\t\tmax=tt[i];\n\t\t\tmaxi=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maxi);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d-1-e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;sacnf(\"%lld%lld%lld\",&x,&y,&z);\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100000)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int n,score[2*MAX_N -1],time[2*MAX_N -1];\n  int r,l;\n  \n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    updata(time, k, time[k+n-1]+t, n);\n\n    updata(score, d, score[d+n-1]+x, n);\n  \n    /*\n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n;i<n*2;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    */\n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-1]+t, n);\n\n  /*printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-1;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n) return k-n+1; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define N_MAX 100001\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef pair<int, int> iP;\n\nint ts[N_MAX], sum[N_MAX];\n\nint main(){\n  \n  int N, R, L, d, t, x;\n  \n  cin >> N >> R >> L;\n  priority_queue<iP, vector<iP> > que;\n  \n  ts[0] = sum[0] = -INF;\n  que.push(iP(0, -1));\n  int pid = 1, pt = 0;\n  for(int i = 0; i < R; i++){\n    cin >> d >> t >> x;\n    sum[d] += x;\n    que.push(iP(sum[d], -d));\n    while(1){\n      iP p = que.top();\n      if(p.fr == sum[-p.second]){\n\tts[pid] += t - pt;\n\tpt = t;\n\tpid = d;\n\tbreak;\n      }\n      que.pop();\n    }\n    ts[pid] = L - pt;\n  }\n  \n  cout << max_element(ts+1, ts+N+1) - ts << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int id, score;\n    Data(int id, int score){\n        this->id = id;\n        this->score = score;\n    }\n    bool operator<(const Data& d) const{\n        return make_pair(-score, id) < make_pair(-d.score, d.id);\n    }\n};\n\nint main()\n{\n    int n, r, l;\n    cin >> n >> r >> l;\n\n    vector<int> score(n, 0);\n    vector<int> tvTime(n, 0);\n    set<Data> s;\n    for(int i=0; i<n; ++i)\n        s.insert(Data(i, 0));\n\n    vector<int> d(r), t(r), x(r);\n    for(int i=0; i<r; ++i){\n        cin >> d[i] >> t[i] >> x[i];\n        -- d[i];\n    }\n\n    int k = 0;\n    for(int i=1; i<=l; ++i){\n        ++ tvTime[s.begin()->id];\n        while(k < r && t[k] == i){\n            s.erase(Data(d[k], score[d[k]]));\n            score[d[k]] += x[k];\n            s.insert(Data(d[k], score[d[k]]));\n            ++ k;\n        }\n    }\n\n    int ret = 0;\n    for(int i=0; i<n; ++i){\n        if(tvTime[i] > tvTime[ret])\n            ret = i;\n    }\n    cout << (ret + 1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n#define FI first\n#define SE second\nconst int INF = 1001001001;\n\nint N;\nint a[1 << 18];\nint id[1 << 18];\nint sum[100000];\n\nvoid init(int n)\n{\n\tN = 1;\n\twhile (N < n){\n\t\tN <<= 1;\n\t}\n\tfill(id, id + (1 << 18), INF);\n\tfor (int i = 0; i < n; i++){\n\t\tid[i + N - 1] = i;\n\t}\n}\n\nvoid update(int i, int x)\n{\n\ti += N - 1;\n\ta[i] += x;\n\twhile (i > 0){\n\t\ti = (i - 1) / 2;\n\t\tif (a[i * 2 + 1] >= a[i * 2 + 2]){\n\t\t\ta[i] = a[i * 2 + 1];\n\t\t\tid[i] = id[i * 2 + 1];\n\t\t}\n\t\telse {\n\t\t\ta[i] = a[i * 2 + 2];\n\t\t\tid[i] = id[i * 2 + 2];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, r, l;\n\tscanf(\"%d %d %d\", &n, &r, &l);\n\tinit(n);\n\t\n\tint lastid = 0;\n\tint lasttime = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint d, t, x;\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\td--;\n\t\tupdate(d, x);\n\t\tsum[lastid] += t - lasttime;\n\t\tlastid = id[0];\n\t\tlasttime = t;\n\t}\n\tsum[lastid] += l - lasttime;\n\t\n\tint maxi = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (sum[maxi] < sum[i]){\n\t\t\tmaxi = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", maxi + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint score[100000];\nint tim[100000];\nint rank[1000000]; //rank->id\nint rrank[1000000]; //id->rank\n\nint n,r,l,d,t,x;\n\nint rank_change(int a,int b){\n\tint i;\n\tif(b>=0){\n\t\tfor(i=rrank[a];i>0;i--){\n\t\t\tif(score[rank[i-1]] < score[rank[i]]) {\n\t\t\t\tswap(rrank[rank[i-1]],rrank[rank[i]]);\n\t\t\t\tswap(rank[i-1],rank[i]);\n\t\t\t\tcout << \"swap1\" << endl;\n\t\t\t}\n\t\t\telse if(score[rank[i-1]] == score[rank[i]] && rank[i-1] > rank[i]) {\n\t\t\t\tswap(rrank[rank[i-1]],rrank[rank[i]]);\n\t\t\t\tswap(rank[i-1],rank[i]);\n\t\t\t\tcout << \"swap1\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"break\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(i=rrank[a];i<n-1;i++){\n\t\t\tif(score[rank[i]] < score[rank[i+1]]) {\n\t\t\t\tswap(rrank[rank[i]],rrank[rank[i+1]]);\n\t\t\t\tswap(rank[i],rank[i+1]);\n\t\t\t}\n\t\t\telse if(score[rank[i]] == score[rank[i+1]] && rank[i] > rank[i+1]) {\n\t\t\t\tswap(rrank[rank[i]],rrank[rank[i+1]]);\n\t\t\t\tswap(rank[i],rank[i+1]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint i,j;\n\tint mi;\n\tint lt=0;\n\tint identify,lidentify=0;\n\tcin >> n >> r >> l ;\n\tfor(i=0;i<100000;i++) score[i]=0;tim[i]=0;\n\tfor(i=0;i<n;i++) {\n\t\trank[i]=i;\n\t\trrank[i]=i;\n\t}\n\tfor(i=0;i<r;i++){\n\t\tcin >> d >> t >> x;\n\t\tscore[d-1]+=x;\n\t\trank_change(d-1,x);\n\t\ttim[lidentify] += (t - lt);\n\t\t//cout << \"-\";\n\t\tfor(j=0;j<n;j++) cout << rank[j];\n\t\t//cout << endl;\n\t\t//cout << \"[\" << lidentify << \":\" << (t-lt) << \"]\" << endl;\n\t\tlt = t;lidentify=rank[0];\n\t\t//cout  << endl;\n\t}\n\ttim[lidentify] += l-lt;\n\t//cout << lidentify << \":\" << (l-lt) << endl;\n\tidentify=0;\n\tfor(i=0;i<n;i++){\n\t\tif(tim[i] > tim[identify]) identify = i;\n\t}\n\tcout << identify + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  team[search(id,n)].point+=key;\n  maxHeapify(id);\n  while(id>1&&team[id/2].point<team[id].point){\n    swap(team[id],team[id/2]);\n    id=id/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top_id=1;\n  int top=1;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i],x[i],n);\n    //printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  //for(int i=1;i<=n;i++){\n  //printf(\"%d %d\\n\",team[i].id,team[i].showed);\n  //}\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n\n  score[0].first = 1000000000;  \n\n \n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  d = 1;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first += x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;   \n    for(int j=d;j>=1;j--) {\n      if(score[site1].first > score[site1/2].first ) {\n\t//cout <<\"ok\"<<endl;\n      tmp = score[site1];\n      score[site1] = score[site1/2];\n      score[site1/2] = tmp;\n      site1 = site1/2;\n      }else if(score[site1].first == score[site1/2].first && score[site1].second < score[site1/2].second) {\n\ttmp = score[site1];\n\tscore[site1] = score[site1/2];\n\tscore[site1/2] = tmp;\n      site1 = site1/2;\n      } else break;\n    }\n        \n    for(int j=site1;j<=N;j++) {\n      if(2*site1<= N &&( score[2*site1] > score[site1] || score[2*site1+1] < score[site1])) {\n\t//\tcout <<\"ko\"<<endl;\n\tif(site1 > N ) break;\n\tint flg = 0;\n\tif(score[2*site1+1] > score[site1] && score[2*site1] > score[2*site1+1]) flg = 1;\n\ttmp = score[site1];\n\tscore[site1] = score[site1*2+flg];\n\tscore[site1*2+flg] = tmp;\n      }else break;\n    }\n\n  }\n\n\n\n  time[score[1].second] += L-t;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n  int INF = 1e9+7;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[200005];\n  int time[100005];\n  for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n  \n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1=-1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    assert(site1>=1);\n\n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    \n    if(x>0){ \n      while(site1>1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  swap(score[site1], score[site1/2]);\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(2*site1<=N) {\n\tif( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  swap(score[site1],score[2*site1+flg]);\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n\n  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n   cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n\nint N, R, L;\nint score[100000], ans[100000];\n\nset<pair<int, int> > s;\n\nint main(){\n\t\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\trep(i, N) s.insert(mp(0, i));\n\t\n\tint prev = 0;\n\t\n\trep(i, R){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\td--;\n\t\t\n\t\tans[s.begin()->second] += t - prev;\n\t\t\n\t\ts.erase(mp(-score[d], d));\n\t\tscore[d] += x;\n\t\ts.insert(mp(-score[d], d));\n\t\t\n\t\tprev = t;\n\t}\n\tans[s.begin()->second] += L - prev;\n\t\n\tint mx = -(int)1.2e9, mxi = 0;\n\t\n\trep(i, N) if(mx < ans[i]) mx = ans[i], mxi = i;\n\t\n\tcout << mxi + 1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\t//maxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]=s;\n\t\tif(nowN==-1){nowN=n-1;\n\t\t//else nowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\t}else if(scr[n-1]>=scr[nowN]){\n\t\t\tif(scr[n-1]==scr[nowN])nowN=min(n-1,nowN);\n\t\t\telse nowN=n-1;\n\t\t}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = 0;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t\t//printf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n#define N_MAX 100000\ntypedef pair<int,int> P;\n\nint main(){\n  int N,R,L;\n  int d,t,x;\n  int time[N_MAX]={0};\n  int score[N_MAX]={0};\n  cin >> N >> R >> L;\n  priority_queue<P> que;\n  for(int i=1;i<=N;i++){\n    que.push(P(0,N-i));\n  }\n  int now = 0;\n  for(int j=0;j<R;j++){\n    cin >> d >> t >> x;\n    P p1 = que.top();\n    while(score[N-p1.second] != p1.first){\n      que.pop();\n      p1 = que.top();\n    }\n    time[N-p1.second] += t - now;\n    now = t;\n    score[d] += x;\n    que.push(P(score[d],N-d));\n  }\n  P p1 = que.top();\n  while(score[N-p1.second] != p1.first){\n    que.pop();\n    p1 = que.top();\n  }\n  time[N-p1.second] += L - now;\n  priority_queue<P> que2;\n  for(int i=1;i<=N;i++){\n    que2.push(P(time[i],N-i));\n  }\n  p1 = que2.top();\n  cout << N - p1.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/11/05 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\n\tlong long P[100001] = {0};\n\tint W = 1;\n\n\tint T[100001] = {0};\n\tint tp = 0;\n\n\tfor(int i=0; i<R; i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\n\t\tT[W] += t-tp;\n\t\ttp = t;\n\n\t\tP[d] += x;\n\n\t\tif(x>=0){\n\t\t\tif(P[W]<P[d]){\n\t\t\t\tW = d;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tW = 1;\n\t\t\tfor(int j=2; j<=N; j++){\n\t\t\t\tif(P[W]<P[j]){\n\t\t\t\t\tW = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << W << ' ' << P[W] << endl;\n\t}\n\n\tT[W] += L-tp;\n\n\tint C = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(T[C]<T[i]){\n\t\t\tC = i;\n\t\t}\n\t}\n\tcout << C << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n  int INF = 1e9;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[200005];\n  int time[100005];\n  for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n  \n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1=-1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    assert(site1>=1);\n\n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    \n    if(x>0){ \n      while(site1>1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  swap(score[site1], score[site1/2]);\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  swap(score[site1],score[2*site1+flg]);\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n  /*\n  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n   cout << endl;\n  */\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, R, L, D, T, X, M[100000], A[100000]; vector<pair<int, int> > F[1000000]; // (team, score)\nint main() {\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\tfor (int i = 0; i < R; i++) {\n\t\tscanf(\"%d%d%d\", &D, &T, &X);\n\t\tF[T].push_back(make_pair(D - 1, X));\n\t}\n\tpriority_queue<pair<int, int> > que;\n\tfor (int i = 0; i < N; i++) {\n\t\tque.push(make_pair(0, -i));\n\t}\n\tfor (int i = 0; i < L; i++) {\n\t\tfor (int j = 0; j < F[i].size(); j++) {\n\t\t\tM[F[i][j].first] += F[i][j].second;\n\t\t\tque.push(make_pair(M[F[i][j].first], -F[i][j].first));\n\t\t}\n\t\tpair<int, int> p;\n\t\twhile (!que.empty()) {\n\t\t\tp = que.top();\n\t\t\tif (p.first == M[-p.second]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\tA[-p.second]++;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] > A[ret]) {\n\t\t\tret = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long int Int;\n#define REP(i, j) for(Int i = 0; i < (Int)(j); ++i)\n#define FOR(i, j, k) for(Int i = (Int)(j); i < (Int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<Int, Int> P;\nconst Int MAX_N = (1 << 17);\nnamespace std {\n  bool operator > (const P& a, const P& b) {\n    return a.first != b.first ? a.first > b.first : a.second < b.second;\n  }\n}\n\nInt n;\nP v[2 * MAX_N - 1];\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(Int nn){\n  n = 1;\n  while(n < nn) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(0, 1);\n  REP(i, nn) v[i + n - 1] = P(0, i + 1);\n}\n\n// テヲツキツサテ・ツュツ療」ツ?渓テ」ツ?ョテ」ツつづ」ツ?ョテ」ツつ誕テ」ツ?ォテヲツ崢エテヲツ鳴ー\nvoid update(Int k, Int a){\n  k += n - 1;\n  v[k].first = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);\n  }\n}\n\n// [a, b)テ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?、テ」ツつ津ヲツ個?」ツ?、テ」ツδ?」ツδシテ」ツδ?」ツδ甘」ツδウテ」ツδ静」ツδシテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n// kテ」ツ?ッテ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ヲツキツサテ・ツュツ療」ツ?〕, rテ」ツ?ッテ」ツ?敕」ツつ古」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ擬l, r)\n// テ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?凖ヲツ卍づ」ツ?ッquery(a, b, 0, 0, n)テ」ツ?ィテ」ツ?療」ツ?ヲテ・ツ堕シテ」ツ?カ\nP query(Int a, Int b, Int k, Int l, Int r){\n  if(b <= l || a >= r) return P(-1, -1);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return max(vl, vr);\n}\n\nint main() {\n  Int N, R, L, idx = 0, now = 0; cin >>N >>R >>L;\n  P tar = P(0, 1);\n  vector<Int> cnt(N, 0), D(R), T(R), X(R);\n  REP(i, R) { cin >>D[i] >>T[i] >>X[i]; --D[i]; }\n  init(N);\n\n  FOR(i, 1, L + 1){\n    cnt[now]++;\n    //cout <<i <<\": \" <<now <<endl;\n    //REP(j, N) cout <<cnt[j] <<\", \"; cout <<endl;\n    while(idx < R && T[idx] == i){\n      update(D[idx], X[idx] + v[D[idx] + n - 1].first);\n      now = query(0, N, 0, 0, n).second - 1;\n      ++idx;\n    }\n  }\n  Int ans = 0;\n  REP(i, N) if(cnt[i] > cnt[ans]) ans = i;\n  cout <<ans + 1 <<endl;\n  //REP(j, N) cout <<cnt[j] <<\", \"; cout <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][100000],T=0,g,p[2][100000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n  int INF = 1e9;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[200005];\n  int time[100005];\n  for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n  \n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1=-1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    assert(site1>=1);\n\n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    \n    if(x>0){ \n      while(site1>1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  swap(score[site1], score[site1/2]);\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(2*site1<=N) {\n\tif( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  swap(score[site1],score[2*site1+flg]);\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n  /*\n  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n   cout << endl;\n  */\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1e9)\ntypedef pair<int, int> pii;\nconst int MAX_N = (1<<17);\n\nstruct RMQ {\n    int n;\n    pii dat[MAX_N];\n    void init(int n_)\n    {\n        n = 1;\n        while (n < n_) {\n            n *= 2;\n        }\n        for (int i = 0; i < 2*n-1; i++) {\n            dat[i] = pii(-INF, -INF);\n        }\n\n        for (int i = 0; i < n_; i++) {\n            update(i, 0);\n        }\n    }\n\n    void update(int k, int a)\n    {\n        int nk = k;\n        k += n - 1;\n        dat[k] = pii(a, -nk);\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = max(dat[k*2+1], dat[k*2+2]);\n        }\n    }\n\n    pii query(int a, int b, int k, int l, int r)\n    {\n        if (r <= a || b <= l) return pii(-INF, -INF);\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            pii vl = query(a, b, k*2+1, l, (l + r) / 2);\n            pii vr = query(a, b, k*2+2, (l + r) / 2, r);\n            return max(vl, vr);\n        }\n    }    \n};\n\nint main()\n{\n    int N, R, L;\n    cin >> N >> R >> L;\n    int d, t, x, pt = 0;\n    int point[MAX_N] = {};\n    RMQ r;\n    r.init(N);\n    for (int i = 0; i < R; i++) {\n        cin >> d >> t >> x; d--;\n        point[-r.query(0, N, 0, 0, r.n).second] += t - pt;\n        r.update(d, x + r.dat[d + r.n - 1].first);\n        pt = t;\n    }\n    point[-r.query(0, N, 0, 0, r.n).second] += L - pt;\n    int mx = 0, num = -1;\n    for (int i = 0; i < N; i++) {\n        if (mx < point[i]) {\n            mx = point[i];\n            num = i+1;\n        }\n    }\n    cout << num << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nvoid update(int k,int x);\npair<int, int> seg[1 << 18];\n\n\n\nint main(){\n\n  int n,r,l;\n  int d,t,x;\n  int i;\n  int team[1000];\n  int sento=0,watch=0,maxi=0;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n  for(i=0;i<n;i++) update(i,0);\n\n  for(i=0;i<r;i++){\n    scanf(\"%d %d %d\",&d,&t,&x);\n    team[sento]+=t-watch;\n    update(d-1,x);\n    sento=seg[0].second-1;\n    watch=t;\n  }\n  team[sento]+=l-watch;\n\n  for (int i=1;i<n;i++){\n    if(team[maxi]<team[i]) maxi=i;\n  }\n  printf(\"%d\\n\",maxi+1);\n  \n  return 0;\n}\n\n\n\nvoid update(int k,int x){\n  int id;\n  \n  id=k+1;\n  k += (1 << 17) - 1;\n  \n  seg[k].first+=x;\n  seg[k].second=id;\n  \n  while(k){\n    k=(k-1)/2;\n    if(seg[k*2+1].first>seg[k*2+2]) seg[k]=seg[k*2+1];\n    else if(seg[k * 2 + 1].first < seg[k * 2 + 2].first) seg[k] = seg[k * 2 + 2];\n    else  seg[k] = seg[k * 2 + 1];\n  }\n  return ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint n,r,l;\nstruct log{\n\tint d[1000000];\n\tint x[1000000];\n};\nlog team;\nint t[1000000+1];\npriority_queue <pair<int,int> >que;\npair<int,int> p;\nint pnt[100000];\nint tm[100000];\nint mx;\nint mnum;\nint main(){\n\twhile(scanf(\"%d%d%d\",&n,&r,&l)){\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d%d%d\",&team.d[i],&t[i],&team.x[i]);\n\t}\n\tt[r]=l;\n\tfor(int i=0;i<r;i++){\n\t\tpnt[team.d[i]]+=team.x[i];\n\tfor(int j=1;j<=n;j++){\n\t\tque.push(make_pair(pnt[j],j*(-1)));\n\t}\n\t\tp=que.top();\n\t\ttm[p.second*(-1)]+=t[i+1]-t[i];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tque.pop();\n\t\t}\n\t\tcout<<p.second*(-1)<<\" \"<<tm[p.second*(-1)]<<\" \"<<pnt[p.second*(-1)]<<endl;\n\t}\n\tmx=tm[1];\n\tfor(int i=1;i<=n;i++){\n\t\tif(mx<tm[i]){\n\t\t\tmx=tm[i];\n\t\t\tmnum=i;\n\t\t}\n\t}\n\tcout<<mnum<<endl;\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131075];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[100010];\nstruct node {\n    int id, point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    map<int, vector<pair<int, int>>> history;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n        history[t].push_back(make_pair(d-1, x));\n    }\n\n    int pt=0;\n    for(auto& i: history) {\n        int id=node[0].id;\n        int t=i.first;\n        a[id]+=t-pt;\n        for(auto& j: i.second) {\n            int d=j.first;\n            int x=j.second;\n            add(d, x);\n            print();\n        }\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-(history.rbegin()->first);\n#if DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll inf_=-174417441744;\nll ans[100005]={0};\nll val[100005]={0};\nvector<ll> dl,tl,xl;\nP mp(P p1,P p2){\n  if(p1.first==p2.first){\n    if(p1.second<p2.second) return p1;\n    else return p2;\n  }\n  else{\n    if(p1.first>p2.first) return p1;\n    else return p2;\n  }\n}\nstruct segtree{\nprivate:\n  vector<P> node;\n  ll siz;\npublic:\n  segtree(ll n){\n    siz=1;\n    while(siz<=n) siz*=2;\n    node.resize(siz*2+1,P(0,0));\n\n    for(ll i=0;i<siz;i++){\n      ll pos=i+siz-1;\n      node[pos]=P(0,i);\n    }\n    for(ll i=siz-2;i>=0;i--){\n      node[i]=mp(node[i*2+1],node[i*2+2]);\n    }\n  }\n  void upd(ll pos,ll x){\n    pos+=siz-1;\n    node[pos]=P(x,pos-(siz-1));\n    while(pos>0){\n      pos=(pos-1)/2;\n      node[pos]=mp(node[pos*2+1],node[pos*2+2]);\n    }\n  }\n  P get_max(ll a,ll b,ll pos,ll l,ll r){\n    if(a<=l&&r<=b) return node[pos];\n    if(r<=a||b<=l) return P(inf_,-inf_);\n    ll mid=(l+r)/2;\n    P lb=get_max(a,b,pos*2+1,l,mid);\n    P rb=get_max(a,b,pos*2+2,mid,r);\n    return mp(lb,rb);\n  }\n  P max_q(ll a,ll b){\n    return get_max(a,b,0,0,siz);\n  }\n};\nint main(){\n  ll n,r,l;\n  cin>>n>>r>>l;\n  dl.push_back(1);\n  tl.push_back(0);\n  xl.push_back(0);\n  for(ll i=0;i<r;i++){\n    ll d,t,x;\n    cin>>d>>t>>x;\n    dl.push_back(d);\n    tl.push_back(t);\n    xl.push_back(x);\n  }\n  tl.push_back(l);\n\n  segtree seg=segtree(n+5);\n  for(ll i=0;i<=r;i++){\n    seg.upd(dl[i],val[dl[i]]+xl[i]);\n    val[dl[i]]+=xl[i];\n    P p=seg.max_q(1,n+1);\n    ans[p.second]+=tl[i+1]-tl[i];\n  //  cout<<dl[i]<<\" \"<<now_seg+xl[i]<<\" \"<<p.first<<\" \"<<p.second<<\" \"<<tl[i+1]-tl[i]<<endl;\n  //  cout<<p.second<<endl;\n  }\n  ll as=0;\n  ll ot=0;\n  for(ll i=n;i>=1;i--){\n    if(as<=ans[i]){\n      as=ans[i];\n      ot=i;\n    }\n  }\n  //for(int i=1;i<=n;i++) cout<<val[i]<<\" \";\n  //cout<<endl;\n  cout<<ot<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstruct state {\n  int id,score,last;\n  bool operator < ( const state &p ) const {\n    if(score==p.score)return id > p.id;\n    else return score < p.score;\n  }\n};\n\nstruct event {\n  int d,t,x;\n};\n\nint N,R,L;\nint score[100010];\nint last[100010];\nint sum[100010];\nevent events[1000010];\n\n\nint main(){\n  priority_queue < state > Q;\n  for(int i=0;i<100010;i++)score[i]=last[i]=sum[i]=0;\n  cin>>N>>R>>L;\n  for(int i=1;i<=N;i++)Q.push( (state){i,0,0} );\n  for(int i=0;i<R;i++){\n    cin>>events[i].d>>events[i].t>>events[i].x;\n  }\n  events[R].t=L;\n  events[R].d=events[R].x=0;\n  state f = (state){1,0,0};\n  state g;\n  int a=0;\n  for(int i=0;i<=R;i++){\n    event e = events[i];\n    score[e.d]+=e.x;\n    last[e.d]=e.t;\n    Q.push( (state){e.d,score[e.d],last[e.d]} );\n    if(i+1<=R&&e.t==events[i+1].t)continue;\n    g=f;\n    while(1){\n      f=Q.top();\n      if(f.last==last[f.id])break;\n      Q.pop();\n    }\n    sum[g.id]+=(e.t-a);\n    //cout<<g.id << ' '<<e.t-a<<endl;\n    a=e.t;\n  }\n  int ans=-1,ans2=0;\n  for(int i=1;i<=N;i++){\n    if(ans<sum[i]){\n      ans=sum[i];\n      ans2=i;\n    }\n  }\n  cout<<ans2<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\n//const int N=131072; // AC\n//const int N=131071; // WA\nconst int N=130000; // WA\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std ;\n\nint num[2][262144] = {} ; // 0 point , 1 num\nint ranking[100001] = {} ;\nint n , r , l ;\nint d , t , x ;\nint btd , bt , sum1=-1 , sum2=0 ;\n\nvoid count( int p ){\n\t\n\tif( num[0][p*2] >= num[0][p*2+1] ){\n\t\tnum[0][p] = num[0][p*2] ;\n\t\tnum[1][p] = num[1][p*2] ;\n\t}else {\n\t\tnum[0][p] = num[0][p*2+1] ;\n\t\tnum[1][p] = num[1][p*2+1] ;\n\t}\n\t\n\tif( p!=1 ) count( p/2 ) ;\n}\n\nint main(){\n\t\n\tcin >> n >> r >> l ;\n\t\n\tfor( int i=1 ; i<=n ; i++ ){\n\t\tnum[1][i+131071] = i ;\n\t}\n\t\n\tfor( int i=0 ; i<r ; i++ ){\n\t\tcin >> d >> t >> x ;\n\t\tif( i==0 ) ranking[1] = t ;\n\t\tnum[0][d+131071] += x ;\n\t\t\n\t\tcount( ( d+131071 ) / 2 ) ;\n\t\t\n\t\tif( i != 0 ) ranking[btd] = t-bt ;\n\t\tbt = t ;\n\t\tbtd = num[1][1] ;\n\t}\n\t\n\tranking[btd] = l-bt ;\n\t\n\tfor( int i=1 ; i<=n ; i++ ){\n\t\tif( sum1 < ranking[i] ){\n\t\t\tsum1 = ranking[i] ;\n\t\t\tsum2 = i ;\n\t\t}\n\t}\n\tcout << sum2 << endl ;\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint* heap_index;\n\nstruct Info{\n\tInfo(){\n\t\tid=0;\n\t\tscore = 0;\n\t\ttime_sum = 0;\n\t}\n\tInfo(int arg_id,int arg_score){\n\t\tid = arg_id;\n\t\tscore = arg_score;\n\t\ttime_sum = 0;\n\t}\n\tint id,score,time_sum;\n};\n\nclass InfoPQ{\npublic:\n\tInfoPQ(int arg_n){\n\t\tarray = new Info[arg_n];\n\t\tn = 0;\n\t}\n\n\tvoid push(Info arg_info){\n\t\tarray[n] = arg_info;\n\t\tint tmp = n;\n\t\twhile(tmp != 0 && array[tmp].id < array[(tmp-1)/2].id){\n\t\t\tstd::swap(array[tmp], array[(tmp-1)/2]);\n\t\t\ttmp = (tmp-1)/2;\n\t\t}\n\t\tn++;\n\t}\n\n\tvoid writeHeapIndex(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\theap_index[array[i].id] = i;\n\t\t}\n\t}\n\n\tvoid addTime(int time){\n\t\tarray[0].time_sum += time;\n\t}\n\n\tvoid printResult(){\n\t\tint max_time = -1000000000,max_id;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(array[i].time_sum > max_time){\n\t\t\t\tmax_time = array[i].time_sum;\n\t\t\t\tmax_id = array[i].id;\n\t\t\t}else if(array[i].time_sum == max_time && array[i].id < max_id){\n\t\t\t\tmax_id = array[i].id;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",max_id);\n\t}\n\n\tvoid update(int update_id,int div){\n\n\t\tarray[heap_index[update_id]].score += div;\n\t\tint tmp = heap_index[update_id];\n\n\t\tif(div > 0){\n\t\t\twhile(tmp != 0 && ((array[tmp].score > array[(tmp-1)/2].score) || (array[tmp].score ==array[(tmp-1)/2].score && array[tmp].id < array[(tmp-1)/2].id))){\n\t\t\t\tstd::swap(heap_index[array[tmp].id],heap_index[array[(tmp-1)/2].id]);\n\t\t\t\tstd::swap(array[tmp], array[(tmp-1)/2]);\n\t\t\t\ttmp = (tmp-1)/2;\n\t\t\t}\n\t\t}else{\n\t\t\twhile(2*tmp+1 <= n-1){\n\t\t\t\tif(2*tmp+2 <= n-1){\n\t\t\t\t\tif(((array[2*tmp+2].score > array[tmp].score) || (array[2*tmp+2].score == array[tmp].score && array[2*tmp+2].id < array[tmp].id)) &&\n\t\t\t\t\t\t\t((array[2*tmp+2].score > array[2*tmp+1].score) || (array[2*tmp+2].score == array[2*tmp+1].score && array[2*tmp+2].id < array[2*tmp+1].id))){\n\t\t\t\t\t\tstd::swap(heap_index[array[tmp].id],heap_index[array[2*tmp+2].id]);\n\t\t\t\t\t\tstd::swap(array[2*tmp+2],array[tmp]);\n\t\t\t\t\t\ttmp = 2*tmp+2;\n\t\t\t\t\t}else if(((array[2*tmp+1].score > array[tmp].score) || (array[2*tmp+1].score == array[tmp].score && array[2*tmp+1].id < array[tmp].id)) &&\n\t\t\t\t\t\t\t((array[2*tmp+1].score > array[2*tmp+2].score) || (array[2*tmp+1].score == array[2*tmp+2].score && array[2*tmp+1].id < array[2*tmp+2].id))){\n\t\t\t\t\t\tstd::swap(heap_index[array[tmp].id],heap_index[array[2*tmp+1].id]);\n\t\t\t\t\t\tstd::swap(array[2*tmp+1],array[tmp]);\n\t\t\t\t\t\ttmp = 2*tmp+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\t//?????????????????¨???????????´???\n\t\t\t\t\tif((array[2*tmp+1].score > array[tmp].score) || (array[2*tmp+1].score == array[tmp].score && array[2*tmp+1].id < array[tmp].id)){\n\t\t\t\t\t\tstd::swap(heap_index[array[tmp].id],heap_index[array[2*tmp+1].id]);\n\t\t\t\t\t\tstd::swap(array[tmp],array[2*tmp+1]);\n\t\t\t\t\t\ttmp = 2*tmp+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nprivate:\n\tInfo* array;\n\tint n;\n};\n\n\n\nint main(){\n\tint N,R,L,pre,team_id,time,add;\n\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\n\tInfoPQ Q(N);\n\theap_index = new int[N+1];\n\n\tfor(int i = 0; i < N; i++)Q.push(Info(i+1,0));\n\n\tQ.writeHeapIndex();\n\n\tpre = 0;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&team_id,&time,&add);\n\t\tQ.addTime(time-pre);\n\t\tQ.update(team_id,add);\n\t\tpre = time;\n\t}\n\tQ.addTime(L-pre);\n\n\tQ.printResult();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tpriority_queue<pii> pq;\n\tint n, r, l, d, t, x, u = 0;\n\tscanf(\"%d%d%d\", &n, &r, &l);\n\tvector<int> s(n + 1), c(n + 1);\n\tfor(int i = 1; i <= n; ++i){\n\t\tpq.push(pii(0, ~i));\n\t}\n\tfor(int i = 0; ; ++i){\n\t\tif(i == r){\n\t\t\tt = l;\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\t}\n\t\twhile(1){\n\t\t\tif(s[~pq.top().second] == pq.top().first){\n\t\t\t\tc[~pq.top().second] += t - u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t\tif(i == r){\n\t\t\tbreak;\n\t\t}\n\t\ts[d] += x;\n\t\tpq.push(pii(s[d], ~d));\n\t\tu = t;\n\t}\n\tint ans = max_element(c.begin(), c.end()) - c.begin();\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 10000000\n#define MAX_TEAM 10000000\n\npriority_queue<pair<int, int>> Q;\nint d[MAX_TEAM], n, s, L, x[MAX_N], y[MAX_N], t[MAX_N], ti[MAX_TEAM], maxn, maxid;\n\nint main() {\n\tcin >> n >> s >> L;\n\tQ.push(make_pair(0, -1000000000));\n\tx[0] = 1; t[0] = 0; y[0] = 0; x[s + 1] = 1; t[s + 1] = L; y[s + 1] = 0;\n\tfor (int i = 1; i <= s; i++) { cin >> x[i] >> t[i] >> y[i]; }\n\tfor (int i = 0; i <= s; i++) {\n\t\td[x[i]] += y[i];\n\t\tQ.push(make_pair(d[x[i]], -x[i]));\n\t\twhile (true) {\n\t\t\tpair<int, int>p = Q.top();\n\t\t\tif (p.first == d[-p.second]) {\n\t\t\t\tti[-p.second] += t[i + 1] - t[i]; break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (maxn < ti[i]) {\n\t\t\tmaxn = ti[i];\n\t\t\tmaxid = i;\n\t\t}\n\t}\n\tcout << maxid << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\nint R;\nint L;\n\npair<int, int> seg[100000 * 4];\n\nvoid update(int k, int a, int b, int p, int x) {\n  if (p < a || b <= p)\n    return;\n  if (b - a == 1) {\n    int tmp = seg[k].first;\n    seg[k] = make_pair(tmp + x, -p);\n  } else {\n    update(2*k+1, a, (a+b)/2, p, x);\n    update(2*k+2, (a+b)/2, b, p, x);\n    seg[k] = max(seg[2*k+1], seg[2*k+2]);\n  }\n}\n\nconst int oo = 1<<30;\npair<int, int> query(int k, int a, int b, int l, int r) {\n  if (r <= a || b <= l)\n    return make_pair(-oo, 0);\n  if (l <= a && b <= r)\n    return seg[k];\n  pair<int, int> r1 = query(2*k+1, a, (a+b)/2, l, r);\n  pair<int, int> r2 = query(2*k+2, (a+b)/2, b, l, r);\n  return max(r1, r2);\n}\n\nint cnt[100000];\n\nint main(int argc, char *argv[])\n{\n  int pre_t = 0;\n  scanf(\" %d %d %d\", &N, &R, &L);\n  for (int i = 0; i < R; i++) {\n    int d, t, x;\n    scanf(\" %d %d %d\", &d, &t, &x);\n    auto v = query(0, 0, N, 0, N);\n    cnt[-v.second] += t - pre_t;\n    pre_t = t;\n    update(0, 0, N, d-1, x);\n  }\n  auto v = query(0, 0, N, 0, N);  \n  cnt[-v.second] += L - pre_t;\n\n  int r = 0;\n  for (int i = 1; i < N; i++) {\n    if (cnt[i] > cnt[r])\n      r = i;\n  }\n\n  printf(\"%d\\n\", r+1);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<numeric>\n#define INF 1e+8\n#define EPS 1e-8\n#define PB push_back\n#define fi first\n#define se second\n#define rep(i,j) for(int  i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\nclass s_data{\n    public:\n    int id;\n    int score;\n    s_data(){}\n    s_data(int _id,int _score){\n        id = _id;\n        score = _score;\n    }\n    bool operator<(const s_data &a)const{\n        if(a.score == score)return id > a.id;\n        return score<a.score;\n    }\n};\nclass Seg{\n    public:\n    int size;\n    vector < s_data > dat;\n    void init(int _k){\n        int k = 1;\n        while(k < _k)k*=2;\n        dat = vector<s_data>(2*k-1,s_data(INF,0));\n        size = k;\n    }\n    void update(s_data q){\n        int index = q.id;\n        index += size - 1;\n        dat[index].score += q.score;\n        dat[index].id = q.id;\n        while(index > 0){\n            index = (index-1)/2;\n            dat[index] = max(dat[index*2+1],dat[index*2+2]);\n        }\n    }\n};\ns_data cam[100001];\nint main(){\n    int N,R,L;\n    scanf(\"%d%d%d\",&N,&R,&L);\n    Seg seg;\n    seg.init(N);\n    rep(i,N){\n        seg.update(s_data(i,0));\n    }\n\n    int bef = 0;\n    int mid = 0;\n    rep(i,R){\n        int d,t,x;\n        scanf(\"%d%d%d\",&d,&t,&x);\n        d--;\n        seg.update(s_data(d,x));\n        cam[mid].id = mid;\n        cam[mid].score += (t-bef);\n        mid = seg.dat[0].id;\n        bef = t;\n    }\n    cam[mid].id = mid;\n    cam[mid].score += L-bef;\n    s_data ans = s_data(INF,-INF);\n    rep(i,N){\n        ans = max(ans,cam[i]);\n    }\n    printf(\"%d\\n\",ans.id+1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\n\nunordered_map<int,P>segment;\nunordered_map<int,int>point;\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d+1-e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;cin>>x>>y>>z;\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\t\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint tim[100001]={0};\nint total[100001]={0};\nint top_id(int N){\n  int top=total[1];\n  int id=1;\n  for(int i=2;i<=N;i++){\n    if(top<total[i]){\n      top = total[i];\n      id = i;\n    }\n  }\n  return id;\n}\nint top_time(int N){\n  int top_t=0;\n  int ans;\n  for(int i=1;i<=N;i++){\n    if(top_t<tim[i]){\n      top_t = tim[i];\n      ans = i;\n    }\n  }\n  return ans;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  int top=1;\n  int d,t[2],x;\n  t[0] = 0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t[1] >> x;\n    total[d] += x;\n    tim[top] += (t[1] - t[0]);\n    top = top_id(N);\n    t[0] = t[1];\n  }\n  tim[top] += (L - t[0]);\n  cout << top_time(N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<cstring>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define INIT(a) memset(a,0,sizeof(a))\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1e9+7;\n\nint v;\nP seg[4004000];\n\ninline void init(int n){\n  v = 1;\n  while(v<n)v<<=1;\n  rep(i,2*v-1)seg[i] = P(INF,INF);\n}\n\ninline void update(int x, P a){\n  x += v-1;\n  seg[x] = a;\n  while(x){\n    x = (x-1)>>1;\n    seg[x] = min(seg[2*x+1],seg[2*x+2]);\n  }\n}\n\ninline P query(int a, int b, int k ,int l, int r){\n  if(b<=l || r<=a)return P(INF,INF);\n  if(a<=l && r<=b)return seg[k];\n  P ql = query(a,b,2*k+1,l,(l+r)/2);\n  P qr = query(a,b,2*k+2,(l+r)/2,r);\n  return min(ql,qr);\n}\n\nint n,r,l;\nint d,t,x,prv=0;\nint len[1001000];\n\nint main(){\n  INIT(len);\n  scanf(\"%d%d%d\",&n,&r,&l);\n  init(n);\n  rep(i,n)update(i,P(0,i));\n\n  rep(i,r){\n    scanf(\"%d%d%d\",&d,&t,&x);\n    P tmp = query(0,n,0,0,v);\n    len[tmp.sc] += t-prv;\n    prv = t;\n    update(d-1,P(seg[d-1 +v-1].fs-x,d-1));\n  }\n  len[query(0,n,0,0,v).sc] += l-prv;\n\n  int ans = 0;\n  rep(i,n){\n    if(len[ans] < len[i])ans = i;\n  }\n  printf(\"%d\\n\",ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131070];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid printvec(vector<P>::iterator,int,int);\nvoid printtime(int *,int);\n\nint main()\n{\n\tint scor[100000],time[100000],N,R,L,d,t,x,lasttime,ans,maxtime;\n\tvector<P> rnk;\n\tvector<P>::iterator it;\n\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\n\tfor(int i = 0; i < N; i++){\n\t\trnk.push_back(P(0,i));\n\t\tscor[i] = 0;\n\t\ttime[i] = 0;\n\t}\n\tlasttime = 0;\n\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\td = N-d;\n\t\t//現在トップのチームに時間追加\n\t\tit = rnk.end();\n\t\tit--;\n\t\ttime[it->second] += t-lasttime;\n\t\tlasttime = t;\n\n\t\t//古いデータの削除\n\t\tit = lower_bound(rnk.begin(),rnk.end(),P(scor[d],d));\n\t\trnk.erase(it);\n\t\n\n\t\t//新しいデータの挿入\n\t\tscor[d] += x;\n\t\tit = lower_bound(rnk.begin(),rnk.end(),P(scor[d],d));\n\t\trnk.insert(it,P(scor[d],d));\n\n\t\t//printtime(time,N);\n\t\t//printvec(rnk.end(),rnk.size(),N);\n\t}\n\tit = rnk.end();\n\tit--;\n\ttime[it->second] += L-lasttime;\n\n\tmaxtime = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(maxtime < time[i]){\n\t\t\tmaxtime = time[i];\n\t\t\tans = N-i;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\nvoid printvec(vector<P>::iterator it,int size,int N){\n\tfor(int c = 0; c < size; c++){\n\t\tit--;\n\t\tprintf(\"scor:%d ID:%d\\n\",it->first,N-it->second);\n\t}\n}\nvoid printtime(int *time,int N){\n\tfor(int i = 0; i < N; i++){\n\t\tprintf(\"time:%d ID:%d\\n\",time[i],N-i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/11/05 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\n\tlong long P[100001] = {0};\n\tint W = 1;\n\n\tint T[100001] = {0};\n\tint tp = 0;\n\n\tfor(int i=0; i<R; i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\n\t\tT[W] += t-tp;\n\t\ttp = t;\n\n\t\tP[d] += x;\n\n\t\tif(x>=0){\n\t\t\tif(P[W]<P[d] || (P[W]==P[d] && W>d)){\n\t\t\t\tW = d;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(W==d){\n\t\t\t\tW = 1;\n\t\t\t\tfor(int j=2; j<=N; j++){\n\t\t\t\t\tif(P[W]<P[j]){\n\t\t\t\t\t\tW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << W << ' ' << P[W] << endl;\n\t}\n\n\tT[W] += L-tp;\n\n\tint C = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(T[C]<T[i]){\n\t\t\tC = i;\n\t\t}\n\t}\n\tcout << C << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\n#define MAX_N 1000000\n#define MAX_TEAM 1000000\n\npriority_queue<pair<long long, long long>> Q;\nlong long d[MAX_TEAM], n, s, L, x[MAX_N], y[MAX_N], t[MAX_N], ti[MAX_TEAM], maxn, maxid;\n\nint main() {\n\tcin >> n >> s >> L;\n\tQ.push(make_pair(0, -1));\n\tx[0] = 1; t[0] = 0; y[0] = 0; x[s + 1] = 1; t[s + 1] = L; y[s + 1] = 0;\n\tfor (int i = 1; i <= s; i++) { cin >> x[i] >> t[i] >> y[i]; }\n\tfor (int i = 0; i <= s; i++) {\n\t\td[x[i]] += y[i];\n\t\tQ.push(make_pair(d[x[i]], -x[i]));\n\t\twhile (true) {\n\t\t\tpair<int, int>p = Q.top();\n\t\t\tif (p.first == d[-p.second]) {\n\t\t\t\tti[-p.second] += t[i + 1] - t[i]; break;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (maxn < ti[i]) {\n\t\t\tmaxn = ti[i];\n\t\t\tmaxid = i;\n\t\t}\n\t}\n\tcout << maxid << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> PI;\n\n//セグメントツリー\nclass segtree{\n\tPI a[1000010];\t\t//ID,score\n\tint dep;\t\t\t//distance from root to leaf\n\npublic:\n\tsegtree( int depth, int x ){\n\t\tint i;\n\t\tdep = depth;\n\t\tfor( i = 0; i < (1 << dep )-1; i++ )\n\t\t\ta[i] = PI( 0,x );\n\t\tfor( int i = (1 << dep )-1; i < (1 << (dep+1))-1; i++ )\n\t\t\ta[i] = PI( i-(1 << dep )+1 ,x );\n\t}\n\n\tvoid add( int index, int num ){\n\t\tint x = (1 << dep) + index - 1;\n\t\ta[x].second += num;\n\t\twhile( x > 0 ){\n\t\t\tif( (a[(x-1)/2].second < a[x].second) || (a[(x-1)/2].second == a[x].second && a[(x-1)/2].first > a[x].first) )\n\t\t\t\ta[(x-1)/2] = a[x];\n\t\t\tx = (x-1)/2;\n\t\t}\n\t}\n\n\t//x <= i <= yについて、a[i].secondが最大となるような、a[i]を返す。a[i].secondが同じならa[i].firstが小さいほうを優先する。\n\t//今回の場合は根しか見なくても良い！\n\tPI solve( int x=-1,int y=-1,int depth=0,int index=0 )\n\t{\n\t\tif( x==-1 && y==-1 )\n\t\t\treturn a[0];\n\t\t\n\t\tint left = (1<<depth)-1+(x>>(dep-depth));\n\t\tint right = (1<<depth)-1+(y>>(dep-depth));\n\n\t\tif( depth > dep )\n\t\t\treturn PI(100000000,-1000000001);\n\t\tif( index < left || index > right )\n\t\t\treturn PI(100000000,-1000000001);\n\n\t\tPI L = solve( x,y,depth+1,index*2+1 );\n\t\tPI R = solve( x,y,depth+1,index*2+2 );\n\t\tif( L.second > R.second || (L.second == R.second && L.first < R.first ) )\n\t\t\treturn L;\n\t\treturn R;\n\t}\n};\n\nint data[1000000];\t\t//テレビに映った時間[ID]を格納\n\nint n,r,l;\nint d,t,x;\nsegtree seg(22,0);\n\nint main()\n{\n\tint i;\n\tint id = 0,bt = 0;\n\n\tcin >> n >> r >> l;\n\tfor( i = 0; i < r;i++ )\n\t{\n\t\tcin >> d >> t >> x;\n\t\tdata[id] += t-bt;\n\t\td--;\n\n\t\tseg.add( d, x );\n\t\tid = seg.solve().first;\n\t\tbt = t;\n\t}\n\n\tPI ans = PI(1,0);\t//id,写った時間\n\tfor( i = 0;i < r;i++ ){\n\t\tif( ans.second < data[i] || ( ans.first > i+1 ) ){\n\t\t\tans.first = i+1;\n\t\t\tans.second = data[i];\n\t\t}\n\t}\n\tcout << ans.first << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// range MAXIMUM query\nclass RMQ {\n  private:\n    static const int MAX_N = 100000;\n    int n;\n    // score, -team_id\n    pii dat[2 * MAX_N - 1];\n    pii rec(int a, int b, int k, int l, int r) {\n        if (b <= l || r <= a) {\n            return {0, 0};\n        }\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            pii rl = rec(a, b, 2 * k + 1, l, (l + r) / 2);\n            pii rr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n            return max(rl, rr);\n        }\n    }\n\n  public:\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = {0, 0};\n        }\n    }\n\n    void update(int k, int a) {\n        int reaf = k + n - 1;\n        dat[reaf] = {dat[reaf].first + a, -k};\n        while (reaf > 0) {\n            reaf = (reaf - 1) / 2;\n            dat[reaf] = max(dat[reaf * 2 + 1], dat[2 * reaf + 2]);\n        }\n    }\n\n    pii query(int a,int b){\n      return rec(a,b+1,0,0,n);\n    }\n};\n\nint main() {\n    int team_n, record_n, end_time;\n    cin >> team_n >> record_n >> end_time;\n\n    RMQ r;\n    r.init(team_n);\n    REP(i, team_n) {\n        r.update(i, 0);\n    }\n\n    vi top(team_n);\n    int btime = 0;\n    REP(i, record_n) {\n        int team_id, time, point;\n        cin >> team_id >> time >> point;\n        team_id--;\n\n        pii t = r.query(0, team_n-1);\n        top[-t.second] += time - btime;\n        btime = time;\n//        LOG(\"--> %d [%d] (%d)\\n\", t.first, -t.second, time - btime);\n\n        r.update(team_id, point);\n    }\n    pii t = r.query(0, team_n-1);\n    top[-t.second] += end_time - btime;\n    cout << (max_element(ALL(top)) - top.begin() + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n\n  score[0].first = -1000000000;  \n\n \n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  d = 1;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1+1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t  //cout <<\"ko\"<<endl;\n\t  int flg = 0;\n\t  if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[site1*2+flg];\n\t  score[site1*2+flg] = tmp;\n\t  site1 = site1*2+flg;\n\t}else break;\n      }\n    }\n    /*for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;*/\n\n  }\n\n\n  time[score[1].second] += L-t;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point {\n  int x,y;\n  bool operator < (const Point& p) const {\n    if( y != p.y ) return y < p.y;\n    return x > p.x;\n  }\n};\nostream& operator << (ostream& os,const Point& p) {\n  os << p.x <<\" \"<< p.y;\n}\n\nint score[100001];\nint t[1000000];\nint time_[1000000];\nint main(){\n  priority_queue<Point> Q;\n  priority_queue<Point> T;\n  int N,R,L;\n  int d,x;\n  int a=1,b=0;\n\n  cin >>N>>R>>L;\n\n\n  for(int i=0;i<R;i++){\n    cin >>d>>t[i]>>x;    \n    score[d]+=x;\n    Q.push((Point){d,score[d]});  \n    while(!Q.empty() && score[Q.top().x] != Q.top().y){\n      Q.pop();\n    }\n    time_[a]+=t[i]-b; \n    T.push((Point){a,time_[a]});\n    while( Q.empty() );\n    a=Q.top().x;\n    b=t[i];\n    time_[a]+=t[i]-b;\n    \n  }\n  \n  while( !Q.empty() && score[Q.top().x] != Q.top().y){\n    Q.pop();\n  }\n  time_[a]+=L-b;\n  if( !Q.empty() ) a=Q.top().x;\n  else a = 1;\n  b=L;\n  T.push((Point){a,time_[a]});\n \n  cout <<T.top().x<<endl;\n\n  while( !T.empty() ){\n    //cout <<T.top()<<endl;\n    T.pop();\n  }\n  return 0;\n}\n\n\n\n    \n\n\t    \n\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = (1 << 17);\nnamespace std {\n  bool operator > (const P& a, const P& b) {\n    return a.first != b.first ? a.first > b.first : a.second < b.second;\n  }\n}\n\nint n;\nP v[2 * MAX_N - 1];\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(int nn){\n  n = 1;\n  while(n < nn) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(0, 1);\n  REP(i, nn) v[i + n - 1] = P(0, i + 1);\n}\n\n// テヲツキツサテ・ツュツ療」ツ?渓テ」ツ?ョテ」ツつづ」ツ?ョテ」ツつ誕テ」ツ?ォテヲツ崢エテヲツ鳴ー\nvoid update(int k, int a){\n  k += n - 1;\n  v[k].first = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);\n  }\n}\n\n// [a, b)テ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?、テ」ツつ津ヲツ個?」ツ?、テ」ツδ?」ツδシテ」ツδ?」ツδ甘」ツδウテ」ツδ静」ツδシテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n// kテ」ツ?ッテ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ヲツキツサテ・ツュツ療」ツ?〕, rテ」ツ?ッテ」ツ?敕」ツつ古」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ擬l, r)\n// テ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?凖ヲツ卍づ」ツ?ッquery(a, b, 0, 0, n)テ」ツ?ィテ」ツ?療」ツ?ヲテ・ツ堕シテ」ツ?カ\nP query(int a, int b, int k, int l, int r){\n  if(b <= l || a >= r) return P(-1, -1);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return max(vl, vr);\n}\n\nint main() {\n  int N, R, L, d, t, x, bef = 0; cin >>N >>R >>L;\n  P tar = P(0, 1);\n  vector<int> cnt(N, 0);\n  init(N);\n  set<P> S;\n  REP(r, R){\n    cin >>d >>t >>x;\n    --d;\n    cnt[tar.second - 1] += t - bef;\n    update(d, x + v[d + n - 1].first);\n    tar = query(0, N, 0, 0, n);\n    bef = t;\n  }\n  cnt[tar.second - 1] += L - bef;\n  int ans = 0;\n  REP(i, N) if(cnt[i] > cnt[ans]) ans = i;\n  cout <<ans + 1 <<endl;\n  //REP(i, N) cout <<i + 1 <<\": \" <<cnt[i] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n\nvoid update(int a,int b);\n\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\nconst int INF = 1001001001;\n\n#define clear(a) memset((a), 0, sizeof(a))\n#define mclear(a) memset((a), -1, sizeof(a))\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\npair<int, int> seg[1 << 18];\n\n\n\nint main(){\n  int n,r,l;\n  int team[100000]={0};\n  \n  scanf(\"%d %d %d\",&n,&r,&l);\n  for(int i=0; i<n; i++) update(i,0);\n  int watch=0,sento=0;\n\n  for (int i=0;i<r;i++){\n    int g,y,z;\n    scanf(\"%d %d %d\",&g,&y,&z);\n    team[sento]+=y-watch;\n    update(g-1,z);\n    sento=seg[0].second-1;\n    watch=y;\n  }\n  team[sento]+=l-watch;\n  \n  int maxi = 0;\n  for (int i=1;i<n;i++){\n    if(team[maxi]<team[i]) maxi=i;\n  }\n  printf(\"%d\\n\",maxi+1);\n  return (0);\n}\n\n\n\nvoid update(int k, int x)\n{\n\tint id = k + 1;\n\tk += (1 << 17) - 1;\n\tseg[k].first += x;\n\tseg[k].second = id;\n\twhile (k){\n\t\tk = (k - 1) / 2;\n\t\tif (seg[k * 2 + 1].first > seg[k * 2 + 2].first){\n\t\t\tseg[k] = seg[k * 2 + 1];\n\t\t}\n\t\telse if (seg[k * 2 + 1].first < seg[k * 2 + 2].first){\n\t\t\tseg[k] = seg[k * 2 + 2];\n\t\t}\n\t\telse {\n\t\t\tseg[k] = seg[k * 2 + 1];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][100],T=0,g,p[2][100000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\n//const int N=131072; // AC\n//const int N=131071; // WA\nconst int N=130700; // WA\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<math.h>\n#include<algorithm>\n#include<set>\n#include<list>\n#include<map>\n\nusing namespace std;\n\n\n/*\n//1\nint main(){\n\tfor(int i=0; i<7;i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tcout << a- b << endl;\n\n\t}\n\n\treturn 0;\n}\n*/\n\n/*\n//2\nint main(){\n\tint t[4] = {6000, 4000, 3000, 2000};\n\tfor(int i=0; i<4; i++){\n\t\tint T,n;\n\t\tcin >> T >> n;\n\t\tT--;\n\t\tcout << t[T]*n << endl;\n\t}\n\n\treturn 0;\n}\n*/\n\n/*\n//3\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i=0; i<N; i++){\n\t\tint x, y, b, p;\n\t\tcin >> x >> y >> b >> p;\n\t\t\n\t\tif(b >= 5 && p >= 2){\n\t\t\tint ans = (b*x + p*y)*0.8;\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse if(b >= 5 && p < 2){\n\t\t\tint ans = (b*x + 2*y)*0.8;\n\t\t\tans = min( b*x + p*y, ans );\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse if(b < 5 && p >= 2){\n\t\t\tint ans = (5*x + p*y)*0.8;\n\t\t\tans = min( b*x + p*y, ans );\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse{\n\t\t\tint ans = (5*x + 2*y)*0.8;\n\t\t\tans = min( b*x + p*y, ans );\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n*/\n\n/*\n//4\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tint ans = 2;\n\t\tint num = N;\n\t\tbool b = false;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tif(k == 0) num--;\n\t\t\tif(k >= 2) b = true;\n\t\t}\n\t\tif(b){\n\t\t\tcout << ans + num - 1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NA\" << endl;\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n*/\n\n/*\n//5\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tstring C;\n\t\tcin >> C;\n\n\t\tint card[100];\n\t\tfor(int i=0; i<N; i++){\n\t\t\tcard[i] = 0;\n\t\t}\n\n\t\tint now = 0;\n\t\tint ba = 0;\n\t\tfor(int i=0; i<C.size(); i++){\n\t\t\tif(C[i] == 'M'){\n\t\t\t\tcard[now]++;\n\t\t\t}\n\t\t\tif(C[i] == 'L'){\n\t\t\t\tcard[now]++;\n\t\t\t\tcard[now] += ba;\n\t\t\t\tba = 0;\n\t\t\t}\n\t\t\tif(C[i] == 'S'){\n\t\t\t\tcard[now]++;\n\t\t\t\tba += card[now];\n\t\t\t\tcard[now] = 0;\n\t\t\t}\n\n\t\t\tnow++;\n\t\t\tif(now == N) now = 0;\n\t\t}\n\t\tsort(card, card+N);\n\n\t\tfor(int i= 0; i<N; i++){\n\t\t\tcout << card[i] << \" \";\n\t\t}\n\n\t\tcout << ba << endl;\n\t}\n\n\n\treturn 0;\n}\n*/\n\n/*\n//6\nint main(){\n\tint Q;\n\tcin >> Q;\n\tfor(int i=0; i<Q; i++){\n\t\tint c,a,n;\n\t\tcin >> c >> a >> n;\n\t\tint ans = 0;\n\t\twhile(c != 0 && a != 0 && n != 0){\n\t\t\tc--;\n\t\t\ta--;\n\t\t\tn--;\n\t\t\tans++;\n\t\t}\n\t\twhile(c >= 2 && a >= 1){\n\t\t\tc -= 2;\n\t\t\ta--;\n\t\t\tans++;\n\t\t}\n\t\twhile(c >= 3){\n\t\t\tc -= 3;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n*/\n\n\n//7\nint main(){\n\tint N,R,L;\n\tcin >> N >> R >> L;\n\tint s[100001];\n\tint ans[100001];\n\tset<pair<int,int> > lank;\n\tfor(int i=1; i<=N; i++){\n\t\ts[i] = 0;\n\t\tans[i] = 0;\n\t\tlank.insert(make_pair(0,i));\n\t}\n\t\n\tint last_top = N;\n\tint last_time = 0;\n\tfor(int i=0; i<R; i++){\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\t\td = N-d+1;\n\t\tans[last_top] += t - last_time;\n\t\tlank.erase(lank.find(make_pair(s[d],d))); //O(N)\n\t\ts[d] += x;\n\n\t\tauto itr = lank.lower_bound(make_pair(s[d],d)); //O(N)\n\t\tlank.insert(itr, make_pair(s[d],d));\n\t\t\n\t\tauto it = lank.end();\n\t\tit--;\n\t\tlast_top = (*it).second;\n\t\tlast_time = t;\n\t}\n\tans[last_top] += L - last_time;\n\n\tint answer = -1;\n\tint tmp = -1;\n\tfor(int i=N; i>=1; i--){\n\t\tif(ans[i] > tmp){\n\t\t\tanswer = i;\n\t\t\ttmp = ans[i];\n\t\t}\n\t}\n\n\tcout << N-answer+1 << endl;\n\n\treturn 0;\n}\n\n\n/*\n//8\nint N,Q;\nint s[1000001];\n\nint main(){\n\tcin >> N >> Q;\n\tfor(int i=1; i<=N; i++){\n\t\tcin >> s[i];\n\t}\n\t\n\tmultiset<int> leader;\n\tfor(int i=0; i<Q; i++){\n\t\tstring type;\n\t\tcin >> type;\n\t\tif(type == \"ADD\"){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tleader.insert(s[a]);\n\t\t}\n\t\tif(type == \"REMOVE\"){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tleader.erase(leader.find(s[a]));\n\t\t}\n\t\tif(type == \"CHECK\"){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif(leader.size() == 0){\n\t\t\t\tif(x >= N){\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint huka = 0;\n\t\t\tmap<int,int> R; //score,人数\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tauto itr = leader.lower_bound(s[i]);\n\t\t\t\tif(itr == leader.end()){\n\t\t\t\t\thuka++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint tmp = *itr - s[i];\n\t\t\t\tR[tmp]++;\n\t\t\t}\n\t\t\tif(huka > x){\n\t\t\t\tcout << \"NA\" << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(auto itr=R.begin(); itr!=R.end(); itr++){\n\t\t\t\tsum += itr->second;\n\t\t\t\tif(N-sum <= x){\n\t\t\t\t\tcout << itr->first << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n*/\n\n/*\n//9\nint main(){\n\n\n\treturn 0;\n}\n*/\n\n/*\n//10\nint main(){\n\n\n\treturn 0;\n}\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tpriority_queue<pii> pq;\n\tint n, r, l, d, t, x, u = 0;\n\tscanf(\"%d%d%d\", &n, &r, &l);\n\tvector<int> s(n + 1), c(n + 1);\n\tfor(int i = 1; i <= n; ++i){\n\t\tpq.push(pii(0, ~i));\n\t}\n\tfor(int i = 0; ; ++i){\n\t\tif(i == r){\n\t\t\tt = l;\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\t}\n\t\twhile(1){\n\t\t\tpii p = pq.top();\n\t\t\tif(s[~p.second] == p.first){\n\t\t\t\tc[~p.second] += t - u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t\tif(i == r){\n\t\t\tbreak;\n\t\t}\n\t\ts[d] += x;\n\t\tpq.push(pii(s[d], ~d));\n\t\tu = t;\n\t}\n\tint ans = max_element(c.begin(), c.end()) - c.begin();\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n+1];\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,0);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams+1);\n\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      seg_tree.insert(id,point);\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += time - prev_time;\n\tprev_time = time;\n\tprev_champ = team.id;\n      }\n    }\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100002];\n  long long time[100002];\n\n\n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  score[0].first = -10000000;  \n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n    score[N+1].first = -1;        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t  int flg = 0;\n\t  if(score[2*site1+1] < score[site1] &&score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[2*site1+flg];\n\t  score[2*site1+flg] = tmp;\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n\n  //  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n  // cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nP dat[300000];\nint camera[100001];\n\nvoid init(int N);\nvoid update(int d, int x);\n\nint main()\n{\n\tint N, R, L;\n\t\n\tscanf(\"%d %d %d\", &N, &R, &L);\n\tinit(N);\n\tint last = 0;\n\tint lid = 1;\n\twhile (R-- > 0){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tupdate(d, x);\n\t\tcamera[lid] += t - last;\n\t\tlid = dat[0].second;\n\t\tlast = t;\n\t}\n\tcamera[lid] += L - last;\n\tint maxi = 1;\n\tfor (int i = 2; i <= N; i++){\n\t\tif (camera[maxi] < camera[i]) maxi = i;\n\t}\n\tprintf(\"%d\\n\", maxi);\n}\n\nvoid init(int N)\n{\n\tn = 1;\n\twhile (n < N) n *= 2;\n\tfor (int i = n; i < n * 2 - 1; i++){\n\t\tdat[i] = P(0, i - n + 1);\n\t}\n}\n\nvoid update(int d, int x)\n{\n\td += n - 1;\n\tdat[d].first += x;\n\t\n\twhile (d > 0){\n\t\td = (d - 1) / 2;\n\t\tif (dat[d * 2 + 1].first > dat[d * 2 + 2].first){\n\t\t\tdat[d] = dat[d * 2 + 1];\n\t\t}\n\t\telse if (dat[d * 2 + 1].first < dat[d * 2 + 2].first){\n\t\t\tdat[d] = dat[d * 2 + 2];\n\t\t}\n\t\telse if (dat[d * 2 + 1].second == dat[d * 2 + 2].second){\n\t\t\tdat[d] = min(dat[d * 2 + 1], dat[d * 2 + 2]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\n#define fr first\n#define sc second\nP seg[1<<18];\nint n;\nvoid update(int id,int pt){\n  int k = id + n - 1;\n  seg[k].fr += pt;\n  seg[k].sc = -id;\n  while(k != 0){\n    k = ( k - 1 ) / 2;\n    seg[k] = max(seg[2*k+1],seg[2*k+2]);\n  }\n}\nvoid init(int size) {\n  n = 1;\n  while(n < size) n *= 2;\n}\nint main(){\n  int N,R,L;\n  cin >> N >> R >> L;\n  init(N);\n  for(int i = 0 ; i < N ; i++ ) update(i,0);\n  int mostid = 0 , now = 0 , sum[100000] = {};\n  for(int i = 0 ; i < R ; i++ ){\n    int d,t,x;\n    cin >> d >> t >> x;\n    update(d-1,x);\n    sum[mostid] += t - now;\n    now = t;\n    mostid = -seg[0].sc;\n  }\n  sum[mostid] += L - now;\n  int rec = 0;\n  for(int i = 0 ; i < N ; i++) if( sum[rec] < sum[i] ) rec = i;\n  cout << rec + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100000, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n    }\n\n    int prev = 0, ts[MAX_N+1];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R){\n        if(i+1 >= N || rs[i].t < rs[i+1].t){\n            ts[st.root().second] += rs[i].t - prev;\n            prev = rs[i].t;\n        }\n        st.update(rs[i].d, rs[i].x);\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = 0;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nP dat[300000];\nint camera[100001];\n\nvoid init(int N);\nvoid update(int d, int x);\n\nint main()\n{\n\tint N, R, L;\n\t\n\tscanf(\"%d %d %d\", &N, &R, &L);\n\tinit(N);\n\tint last = 0;\n\tint lid = 1;\n\twhile (R-- > 0){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tupdate(d, x);\n\t\tcamera[lid] += t - last;\n\t\tlid = dat[0].second;\n\t\tlast = t;\n\t}\n\tcamera[lid] += L - last;\n\tint maxi = 1;\n\tfor (int i = 2; i <= N; i++){\n\t\tif (camera[maxi] < camera[i]) maxi = i;\n\t}\n\tprintf(\"%d\\n\", maxi);\n}\n\nvoid init(int N)\n{\n\tn = 1;\n\twhile (n < N) n *= 2;\n\tfor (int i = n; i < n + N; i++){\n\t\tdat[i] = P(0, i - n + 1);\n\t}\n\tfor (int i = n + N; i < n * 2; i++){\n\t\tdat[i] = P(INT_MIN, INT_MIN);\n\t}\n}\n\nvoid update(int d, int x)\n{\n\td += n - 1;\n\tdat[d].first += x;\n\t\n\twhile (d > 0){\n\t\td = (d - 1) / 2;\n\t\tif (dat[d * 2 + 1].first > dat[d * 2 + 2].first){\n\t\t\tdat[d] = dat[d * 2 + 1];\n\t\t}\n\t\telse if (dat[d * 2 + 1].first < dat[d * 2 + 2].first){\n\t\t\tdat[d] = dat[d * 2 + 2];\n\t\t}\n\t\telse if (dat[d * 2 + 1].second == dat[d * 2 + 2].second){\n\t\t\tdat[d] = min(dat[d * 2 + 1], dat[d * 2 + 2]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,r,l;\nint d,t,x;\nint tt[1000001]={0},ten[1000001]={0};\ntypedef pair<int,int> P;\npriority_queue<P> qu;\nint main(void)\n{\n\tint i,j,flg,max,min,n1,nn,ten1;\n\tP ppp;\n\t\n\tcin>>n>>r>>l;\n\t\n\tn1=1;\n\tten1=0;\n\t\n\tfor(i=0;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\t\n\t\ttt[n1]+=t-ten1;\n\t\tten[d]+=x;\n\t\t\n\t\tqu.push(P(ten[d],d*-1));\n\t\tten1=t;\n\t\t\n\t\twhile(1){\n\t\t\tppp=qu.top();\n\t\t\tnn=ppp.second*-1;\n\t\t\tif(ten[nn]==ppp.first){\n\t\t\t\tn1=nn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqu.pop();\n\t\t}\t\n\t}\n\t\n\ttt[n1]+=l-ten1;\n\tmax=-1,min=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(max<tt[i]){\n\t\t\tmax=tt[i];\n\t\t\tmin=i;\n\t\t}\n\t}\t\n\t\n\tcout<<min<<endl;\t\n}\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint point[100002];\nint times[100002];\n\nint main() {\n\n    int n,r,l;\n\n    cin >> n >> r >> l;\n\n    priority_queue<pair<int,int> > que;//??????,????????????\n\n    que.push(make_pair(0,1));\n\n    int lasttime = 0;\n\n    for(int i=0;i<r;i++){\n        int d,t,x;\n        cin >> d >> t >> x;\n        pair<int,int> p = que.top();\n        while(p.first != point[p.second] && !que.empty()){\n            que.pop();\n            p = que.top();\n        }\n\n        times[p.second] += t - lasttime;\n        lasttime = t;\n\n        point[d] += x;\n\n        que.push(make_pair(point[d],d));\n\n    }\n\n    pair<int,int> p = que.top();\n    while(p.first != point[p.second] && !que.empty()){\n        que.pop();\n        p = que.top();\n    }\n    times[p.second] += l - lasttime;\n\n    int ans = -1,anstime = -1;\n\n    for(int i=1;i<=n;i++){\n        if(anstime<times[i]){\n            ans = i;\n            anstime = times[i];\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep_(v, f, l) for (int v = (f); v < (l); ++v)\n#define rep(v, n) rep_(v, 0, n)\n#define lep(v, n) rep_(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstruct SegTree {\n    static const int N=1<<17;\n    vector<int> score;\n    vector<int> id;\n    SegTree() : score(N*2, 0), id(N*2, 0) {\n        rep(i, N){\n            id[i+N-1]=i;\n        }\n    }\n    void update(int x, int v){\n        x += N - 1;\n        score[x] += v;\n        while (x){\n            x = x - 1 >> 1;\n            if (score[x + x + 1] >= score[x + x + 2]){\n                id[x] = id[x + x + 1];\n                score[x] = score[x + x + 1];\n            }\n            else {\n                id[x] = id[x + x + 2];\n                score[x] = score[x + x + 2];\n            }\n        }\n    }\n    int getMax(){ return id[0]; }\n    int getMaxValue(){ return score[0]; }\n};\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\n\nint main()\n{\n    SegTree st = SegTree();\n    int n, r, l;\n    int tv_time[100000]={};\n    n = in();\n    r = in();\n    l = in();\n    int prev_t = 0;\n    rep(i, r){\n        int d, t, x;\n        d = in() - 1;\n        t = in();\n        x = in();\n        tv_time[st.getMax()] += t - prev_t;\n        prev_t = t;\n        st.update(d, x);\n    }\n    tv_time[st.getMax()] += l - prev_t;\n    int id = 0;\n    rep(i, n){\n        if (tv_time[id] < tv_time[i]) id = i;\n    }\n    printf(\"%d\\n\", id + 1);\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nint N, R, L, D, T, X, M[100000], A[100000]; vector<pair<int, int> > F[1000000]; // (team, score)\nint main() {\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d%d%d\", &D, &T, &X);\n\t\tF[D].push_back(make_pair(T - 1, X));\n\t}\n\tpriority_queue<pair<int, int> > que;\n\tfor (int i = 0; i < N; i++) {\n\t\tque.push(make_pair(0, -i));\n\t}\n\tfor (int i = 0; i < L; i++) {\n\t\tfor (int j = 0; j < F[i].size(); j++) {\n\t\t\tM[F[i][j].first] += M[F[i][j].second];\n\t\t\tque.push(make_pair(M[F[i][j].first], -F[i][j].first));\n\t\t}\n\t\tpair<int, int> p;\n\t\twhile (!que.empty()) {\n\t\t\tp = que.top();\n\t\t\tif (p.first == M[-p.second]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tA[-p.second]++;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] > A[ret]) {\n\t\t\tret = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tttime[1] = 100;\n\tpriority_queue<int, vector<pair<int, int> > > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tif(i != 0)ttime[temp.second] += t - ttemp;\n\t\tcout << i << \"  \" << temp.second << \"  \" << ttime[temp.second] << endl;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n\nint score[100010];\nint tim[100010];\n\nint main(){\n\tint N,R,L;\n\twhile(cin >> N >> R >> L && N){\n\t\tpriority_queue< pair<int,int> > Q;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tQ.push(make_pair(0,-i));\n\t\t}\n\t\tint prev = 0;\n\t\tfor(int i = 0 ; i < R ; i++){\n\t\t\tint d,t,x;\n\t\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\t\twhile( score[-Q.top().second] != Q.top().first ){\n\t\t\t\tint id = -Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tQ.push(make_pair(score[id],-id));\n\t\t\t}\n\t\t\t//cout << -Q.top().second << \" \" << Q.top().first << endl;\n\t\t\ttim[-Q.top().second] += t - prev;\n\t\t\tscore[d-1] += x;\n\t\t\tQ.push(make_pair(score[d-1],-(d-1)));\n\t\t\tprev = t;\n\t\t\t//cout << 1 + (max_element(tim,tim+N) - tim) << ' ' << *max_element(tim,tim+N)  << endl;\n\t\t}\n\t\twhile( score[-Q.top().second] != Q.top().first ){\n\t\t\tint id = -Q.top().second;\n\t\t\tQ.pop();\n\t\t\tQ.push(make_pair(score[id],-id));\n\t\t}\n\t\ttim[-Q.top().second] += L - prev;\n\t\tcout << 1 + (max_element(tim,tim+N) - tim) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tpriority_queue<int, vector<pair<int, int> > > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tif(i != 0)ttime[temp.second] += t - ttemp;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tif (i == 0) ttime[temp.second] = t;\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<climits>\nusing namespace std;\n\nint main(){\n    int n, r, l;\n    cin >> n >> r >> l;\n\n    int D[100001] = {};\n    int T[100001] = {};\n\n    int d, t, x;\n    priority_queue<pair<int,int>> pq;\n    for(int i = 1; i <= n; i++) pq.push({0, -i});\n    int now = 0;\n\n    for(int i = 0; i < r; i++){\n        cin >> d >> t >> x;\n        int diff = t-now;\n        now = t;\n\n        while(!pq.empty()){\n            pair<int,int> p = pq.top();\n            if(D[-p.second] == p.first){\n                T[-p.second] += diff;\n                break;\n            }\n            pq.pop();\n        }\n        D[d] += x;\n        pq.push({D[d], -d});\n    }\n\n    int ans, _max = INT_MIN;\n    for(int i = 1; i <= n; i++){\n        if(D[i] > _max){\n            _max = D[i];\n            ans = i;\n        }\n    }\n    T[ans] += l-now;\n\n    ans = 0, _max = INT_MIN;\n    for(int i = 1; i <= n; i++){\n        if(T[i] > _max){\n            _max = T[i];\n            ans = i;\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f first\n#define s second\nint n,m,k,mx,i,j,h,g,y,x;\nint a[1000001],b[1000002],c[1000001];\nint ten[100001],cnt[100001],sz[100001],nb[100001];\ntypedef pair<int,int> P;\nint main(void)\n{\n\tpriority_queue<P> pri; //降順\n\tP p;\n\tcin>>n>>m>>k;\n\tfor(i=1;i<=m;i++) cin>>a[i]>>b[i]>>c[i];\n\tfor(i=1;i<=n;i++) ten[i]=0,cnt[i]=0;\n\tb[m+1]=k; i=1; \n\twhile(i<=m){\n\t\tfor(i;i<=m;i++){\n\t\t\tcnt[a[i]]+=c[i];\n\t\t\tpri.push(P(cnt[a[i]],a[i]));\n\t\t\t//cout<<\"A\"<<i<<endl;\n\t\t\tif(b[i]!=b[i+1]) break;\n\t\t}\n\t\t//cout<<\"I\"<<\" \"<<i<<endl;\n\t\tx=-10000000; y=100001; g=0;\n\t\twhile(pri.size()!=0){\n\t\t\tp=pri.top();\n\t\t\tif(p.f!=cnt[p.s]) pri.pop();\n\t\t\telse if(y>p.s&&x<=p.f) {\n\t\t\t\ty=p.s; x=p.f;\n\t\t\t\tpri.pop();\n\t\t\t\tsz[g]=p.f;\n\t\t\t\tnb[g]=p.s;\n\t\t\t\tg++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tfor(j=0;j<g;j++){\n\t\t\tpri.push(P(sz[j],nb[j]));\n\t\t}\n\t\t//printf(\"%d %d\\n\",b[i],b[i-1]);\n\t\tten[y]+=b[i+1]-b[i];\n\t\t//cout<<p.f<<\" \"<<p.s<<endl;\n\t\ti++;\n\t}\n\tmx=0;\n\th=1;\n\t//for(i=1;i<=n;i++) cout<<ten[i]<<endl;\n\tfor(i=1;i<=n;i++) if(mx<ten[i]) mx=ten[i],h=i;\n\tprintf(\"%d\\n\",h);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint extract(Team* team){\n  int maxv;\n  maxv=team[0].id;\n  //  team[1]=team[H--];\n  //  maxHeapify(1);\n  return maxv;\n}\nvoid IncreaseKey(int i,int key){\n  team[i].point+=key;\n  while(i>0&&team[i/2].point<team[i].point){\n    swap(team[i],team[i/2]);\n    i=i/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=0;\n  for(int i=0;i<n;i++){\n    if(team[i].showed>team[top].showed) top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top+1);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=0;i<n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i]-1,x[i]);\n    Team top=team[extract(team)];\n    if(i==0){\n      top.showed+=t[0];\n    }\n    else if(i<r-1){\n    top.showed+=t[i+1]-t[i];\n    }\n    else{\n      top.showed+=l-t[r-1];\n    }\n  }\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[1 << 17];\n\nint N, R, L, n;\n\npair<int, int> dat[1 << 18 + 1];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m = -1000000000;\n  for(int i = 0; i < N; i++)\n  {\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    p = query(d, d + 1, 0, 0, n);\n    update(d, make_pair(p.first + x, p.second));\n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//?????°???????????????????????????????????§?????????????????????\n//???????????????????????¨?????????????????????????¬????????????¨?????????????¢?????????????\n//?????????????????????????????§?????????push???????????¨??????????????¨???????????????\n//??????????¶???????????????????????????????????????????????????????????????§??????????????????\n\nstruct team{\n    long long n,p,time;\n};\n\nbool operator<(const team& t1,const team& t2){\n    if(t1.p==t2.p){\n        return t1.n > t2.n;\n    }\n    return t1.p < t2.p;\n}\n\npriority_queue<team> q;\nteam tea[100001];\n\nint main() {\n\n    long long n,r,l;\n\n    cin >> n >> r >> l;\n\n    /*for(int i=0;i<r;i++){\n        cout << rec[i].d << \" \" << rec[i].t << \" \" << rec[i].x << endl;\n    }*/\n\n    for(int i=1;i<=n;i++){\n        tea[i].n = i;\n        tea[i].p = 0;\n        tea[i].time = 0;\n        q.push(tea[i]);\n    }\n\n    int d,t,x,btime=0,bnum=1;\n    team tmp;\n    for(int i=0;i<r;i++){\n        scanf(\" %d %d %d\",&d,&t,&x);\n        tea[bnum].time += t - btime; //?????°???????????????????????????????????§????????????????????????????¢??????????\n        tea[d].p += x; //????????????\n        q.push(tea[d]); //???????????\\\n        while(!q.empty()){\n            tmp = q.top();\n            if(tmp.p == tea[tmp.n].p){ //?????°????????´???????????£????????????\n                bnum = tmp.n; //?????§????????????????????????????¨????\n                break;\n            }\n            q.pop(); //??????\n        }\n        btime = t; //????????????????¨????\n    }\n\n    tea[bnum].time += l - btime ; //??????????????£???????????????????????????????¶????\n\n\n    int ans=1;\n\n    for(int i=1;i<=n;i++){\n        ans = tea[i].time > tea[ans].time ? i : ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<P, int> PP;\nstruct edge{ int to, time, cost; };\nconst double esp = 1e-9;\nconst int infi = (int)1e+9;\nconst ll infll = (ll)1e+17;\n\nconst int max = (int)1e+6 + 1;\n\ntypedef std::pair<ll, int> MP;\n\nint n, r, l;\nMP seg[max * 2];\nint point[max];\n\nvoid init(){\n\tint x = 1;\n\twhile (x < n)x *= 2;\n\tn = x;\n\trep(i, max * 2)seg[i].first = -infll, seg[i].second = 0;\n\tREP(i, n - 1, n * 2 - 1)seg[i].second = i - (n - 1);\n}\n\nvoid update(int k, int e){\n\tk += n - 1;\n\tseg[k].first += e;\n\twhile (k > 0){\n\t\tk = (k - 1) / 2;\n\t\tint BigI;\n\t\tif (seg[k * 2 + 1].first == seg[k * 2 + 2].first)BigI = std::min(seg[k * 2 + 1].second, seg[k * 2 + 2].second);\n\t\telse BigI = (seg[k * 2 + 1].first > seg[k * 2 + 2].first ? k * 2 + 1 : k * 2 + 2);\n\t\tseg[k].first = seg[BigI].first;\n\t\tseg[k].second = seg[BigI].second;\n\t}\n}\n\nint main(){\n\tstd::cin >> n >> r >> l;\n\tint before = 0;\n\tinit();\n\trep(i, r){\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\t\t--d;\n\t\tpoint[seg[0].second] += (t - before);\n\t\tupdate(d, x);\n\t\tbefore = t;\n\t}\n\tpoint[seg[0].second] += (l - before);\n\n\tint maxI = 0;\n\tREP(i, 1, n){\n\t\tif (point[i] > point[maxI])maxI = i;\n\t}\n\tstd::cout << maxI + 1 << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[1000010];\nstruct node {\n    int id;\n    long long point;\n} node[1<<22];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint main()\n{\n\tint n,r,l,ans[100001]={},score[100001]={};\n\tcin>>n>>r>>l;\n\tint last=0;\n\tint m=0;//????????£????????§?????????????????£?????????????????????ID\n\tfor(int i=0;i<r;i++){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x;\n\t\tscore[--d]+=x;\n\t\tif(x>=0){\n\t\t\tif((score[d]>score[m])||((score[d]==score[m])&&d<m)){\n\t\t\t\tans[m]+=t-last;\n\t\t\t\tlast=t;\n\t\t\t\tm=d;\n\t\t\t}\n\t\t}else if(m==d){\n\t\t\tint tmp=m;\n\t\t\tfor(int j=0;j<n;j++)if(score[j]>score[tmp]||((score[j]==score[tmp])&&j<tmp))tmp=j;\n\t\t\tif(m!=tmp){\n\t\t\t\tans[m]+=t-last;\n\t\t\t\tlast=t;\n\t\t\t\tm=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tans[m]+=l-last;\n\tint res1=0,res2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(res1<ans[i]){\n\t\t\tres1=ans[i];\n\t\t\tres2=i;\n\t\t}\n\t}\n\tres2++;\n\tcout<<res2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n+1];\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,0);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams);\n\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      seg_tree.insert(id,point);\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += time - prev_time;\n\tprev_time = time;\n\tprev_champ = team.id;\n      }\n    }\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct team { int id, score, time; };\ntypedef pair<int, int> P;\n\nP seg[100001 * 2];\nteam prog[100001];\nint N, R, L;\n\nvoid init();\nvoid update(int key, int data, int t);\n\nint main()\n{\n\tscanf(\"%d %d %d\", &N, &R, &L);\n\tinit();\n\tint last = 0;\n\twhile (R-- > 0){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tupdate(d - 1, x, t);\n\t}\n\tupdate(0, 0, L);\n\tint maxi = 0;\n\tfor (int i = 1; i < N; i++){\n\t\tif (prog[maxi].time < prog[i].time) maxi = i;\n\t}\n\tprintf(\"%d\\n\", prog[maxi].id);\n}\n\nvoid init()\n{\n\tint n = 1;\n\t\n\twhile (n < N) n *= 2;\n\tfor (int i = 0; i < N; i++) prog[i].id = i + 1;\n\tfor (int i = N; i < n; i++) prog[i].id = INT_MAX;\n\tfor (int i = n - 1; i <= (n - 1) * 2; i++) seg[i].second = i - n + 2;\n\tN = n;\n}\n\nvoid update(int key, int data, int t)\n{\n\tstatic int last = 0;\n\tstatic int l_id = 1;\n\t\n\tseg[key + N - 1].first += data;\n\tprog[l_id - 1].time += t - last;\n\t\n\tfor (int c = key + N - 1; c != 0; c = (c - 1) / 2){\n\t\tint other = c % 2 == 0 ? c - 1 : c + 1;\n\t\t\n\t\tif (seg[c].first > seg[other].first) seg[(c - 1) / 2] = seg[c];\n\t\telse if (seg[c].first < seg[other].first) seg[(c - 1) / 2] = seg[other];\n\t\telse if (seg[c].second < seg[other].second) seg[(c - 1) / 2] = seg[c];\n\t\telse seg[(c - 1) / 2] = seg[other];\n\t}\n\t\n\tlast = t;\n\tl_id = seg[0].second;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<cstring>\n#define N (1<<17)\n  \nusing namespace std;\ntypedef long long ll;\nll dat[1000001];\nint id[1000001];\nint n,r,l;\nint d[1000001],t[1000001],x[1000001];\nint timel[100001];\n \nvoid init(){\n  memset(dat,0,sizeof(dat));\n  for(int i=N;i<N*2;i++)id[i]=i-N;\n}\n  \nvoid update(int k,ll a){\n  k+=N-1;\n  dat[k]+=a;\n  while(k>0){\n    k=(k-1)/2;\n    if(dat[k*2+1]>=dat[k*2+2]){//子供の左右の大小比較\n      dat[k]=dat[k*2+1];\n      id[k]=id[k*2+1];\n    }else{\n      dat[k]=dat[k*2+2];\n      id[k]=id[k*2+2];\n    }\n  }\n}\n \nint main(){\n  scanf(\"%d %d %d\",&n,&r,&l);\n  for(int i=0;i<r;i++)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  int nt=0;\n  init();\n  for(int i=0;i<r;i++){\n    timel[id[0]]+=t[i]-nt;//今レコードされた時間からその前にレコードされた時間を引いたもの\n    nt=t[i];\n    update(d[i]/*チーム番号*/,x[i]/*獲得した得点*/);\n  }\n  timel[id[0]]+=l-nt;//最後のレコードチームに残り時間すべてを加算\n  int sum=0,rid=0;\n  for(int i=0;i<n;i++){//一番合計時間の高いチームの探索\n    if(sum<timel[i]){\n      sum=timel[i];\n      rid=i;//チームID確保\n    }\n  }\n  printf(\"%d\\n\",rid+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100000, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n    }\n\n    int prev = 0, ts[MAX_N+1];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R){\n        if(i+1 > N || rs[i].t < rs[i+1].t){\n            ts[st.root().second] += rs[i].t - prev;\n            prev = rs[i].t;\n        }\n        st.update(rs[i].d, rs[i].x);\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = 0;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -1000000);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n    team[k] = P(a, -(k - n + 1));\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[-team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[n + d - 2].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[-team[0].second] += (l - t);\n\t\n    /*for(int i = 0; i < m; ++i)\n        cout << p[i] << endl;*/\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 200000\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\nstruct segtree{\n  int N;\n  P dat[2 * MAX_N - 1];\n  segtree(){}\n  segtree(int n){\n    N = 1;\n    while(n > N) N *= 2;\n\n    rep(i, 2 * N - 1) dat[i] = MP(-10000000, -10000000);\n    for(int i = N - 1; i < 2 * N - 1; i++) dat[i] = MP(0, -1 * (i - N + 1));\n  }\n\n  void update(int k, int a){\n    k += N - 1;\n    dat[k].F += a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1], dat[2*k+2]);\n    }\n  }\n\n  P query(int a, int b){ return query(a, b, 0, 0, N); }\n  P query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return P(-10000000, -10000000);\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      P vl = query(a, b, 2*k+1, l, (l+r)/2);\n      P vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return max(vl, vr);\n    }\n  }\n};\n\nint res[MAX_N];\n\nint main(){\n  int N, R, L;\n  scanf(\"%d%d%d\", &N, &R, &L);\n  segtree seg(N);\n  rep(i, N) seg.update(i, 0);\n\n  int time = 0;\n  rep(i, R){\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x); d--;\n    P s = seg.query(0, N);\n    res[-s.second] += t - time;\n    seg.update(d, x);\n    time = t;\n  }\n  P s = seg.query(0, N);\n  res[-s.second] += L - time;\n\n  int ans = 0;\n  rep(i, N) if(res[ans] < res[i]) ans = i;\n\n  printf(\"%d\\n\", ans+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\tif(i == 0)\n\t\t\ttt[1] = t;\n\t\ttp[d] = tp[d] + x;\n\t\tif(max < tp[d]){\n\t\t\tmax = tp[d];\n\t\t\tFlag = d;\n\t\t}\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t}\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t\t//printf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n//segment-tree\nint n;//nは2のべき乗\npii dat[1000000*2-1];\n//i番目の値(0-indexed)をxに変更\nvoid update(int i,int x){\n\t//葉のノード番号\n\tint team =i;\n\ti +=n-1;\n\tdat[i].first +=x;\n\tdat[i].second = -team;\n\twhile(i >0){\n\t\ti =(i-1)/2;\n\t\tdat[i] =max(dat[i*2+1],dat[i*2+2]);\n\t}\n}\n\n//初期化\nvoid init(int _n){\n\tn = 1;\n\twhile(n<_n)\n\t\tn *=2;\n\tfor(int i = 0;i <_n;i++){\n\t\tupdate(i,0);\n\t}\n}\n\n/*\n//[a,b)の最小値,l,rにはノードkに対応づく区画を与える\n//外からはquery(a,b,0,0,n)のように呼ぶ\nint query(int a,int b,int k,int l,int r){\n\tif(r <=a||b <=l)//交差しない\n\t\treturn INT_MAX;\n\tif(a <=l&&r<=b)//完全に含む\n\t\treturn dat[k];\n\telse{\n\t\tint vl =query(a, b, k*2+1, l, (l+r)/2);\n\t\tint vr =query(a, b, k*2+2, (l+r)/2, r);\n\t\treturn max(vl,vr);\n\t}\n}\n*/\nint main(){\n\tint N,R,L;\n\tcin>>N>>R>>L;\n\tinit(N);\n\tint team = 0;\n\tint pret  =0;\n\tint sum[110000];\n\tfor(int i = 0;i < R;i++){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x;\n\t\td--;\n\t\tupdate(d,x);\n\t\tsum[team]+=t-pret;\n\t\tpret =t;\n\t\tteam =-dat[0].second;\n\t}\n\tsum[team] +=L-pret;\n\tint ans = 0;\n\tfor(int i = 0;i < N;i++){\n\t\tif(sum[ans]<sum[i]){\n\t\t\tans = i;\n\t\t}\n\t}\n\tcout <<ans+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define MAX 1111111\n#define MIN 0\ntypedef pair<int,int> P;\nvoid init(int n);\nvoid update(int k,int x);\nP maxx(int k1,int k2);\nP dat[4*100001];\nint tim[100001]={0};\nint N;\n\nint main(){\n  int R,L;\n  cin >> N >> R >> L;\n  int n_tmp = N;\n  init(N);\n  memset(tim,0,n_tmp+1);\n  int now = 0;\n  dat[0]=P(MIN,1);\n  for(int i=0;i<R;i++){\n    int d,t,x;\n    cin >> d >> t >> x;\n    tim[dat[0].second] += t - now;\n    update(d,x);\n    now = t;\n  }\n  tim[dat[0].second] += L - now;\n  int *ans = max_element(tim,tim+n_tmp+1);\n  cout << ans - tim << endl;\n}\n\nvoid init(int n){\n  N=1;\n  while(N<n) N*=2;\n  for(int i=0;i<2*N-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n  for(int i=N-1;i<N-1+n;i++){\n    dat[i]=P(0,i-(N-2));\n  }\n  return;\n}\n\nvoid update(int k,int x){\n  k += N - 2;\n  P p = dat[k];\n  int score = p.first;\n  int team = p.second;\n  //cout << score << \" \" << team << endl;\n  dat[k] = P(score+x,team);\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = maxx(k*2+1,k*2+2);\n    //cout << dat[k].first << \" \" << dat[k].second << endl;\n  }\n  return;\n}\n\nP maxx(int k1,int k2){\n  P p;\n  if(dat[k1].first == dat[k2].first){\n    p = P(dat[k1].first,min(dat[k1].second,dat[k2].second));\n  }\n  else {\n    p = max(dat[k1],dat[k2]);\n  }\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\n//const int N=131072; // AC\n//const int N=131071; // WA\nconst int N=130620; // WA\nint n, a[N];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<ll, ll>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate <typename T> //Maximum\nstruct RMQ\n{\n  private:\n    int N = 1;\n    vector<T> node;\n\n  public:\n    RMQ(vector<T> vec)\n    {\n        int size = vec.size();\n\n        while (N < size)\n        {\n            N *= 2;\n        }\n\n        node.resize(2 * N - 1, make_pair(-llINF, 0));\n\n        REP(i, size)\n        {\n            node[i + N - 1] = vec[i];\n        }\n\n        for (int i = N - 2; 0 <= i; i--)\n        {\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    void update(int i, T value)\n    {\n        i += (N - 1);\n\n        node[i] = value;\n\n        while (i > 0)\n        {\n            i = (i - 1) / 2;\n\n            node[i] = max(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    T getMax(int a, int b, int i = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n        {\n            r = N;\n        }\n\n        if (r <= a || b <= l)\n        {\n            return P(-llINF, llINF);\n        }\n\n        if (a <= l && r <= b)\n        {\n            return node[i];\n        }\n\n        T vl = getMax(a, b, 2 * i + 1, l, (l + r) / 2);\n\n        T vr = getMax(a, b, 2 * i + 2, (l + r) / 2, r);\n\n        return max(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, R, L;\n    cin >> N >> R >> L;\n\n    vector<P> vec(N);\n\n    vector<ll> time(N, 0);\n\n    REP(i, N)\n    {\n        vec[i] = make_pair(0, i);\n    }\n\n    RMQ<P> rmq(vec);\n\n    vector<int> d(R), t(R), x(R);\n\n    REP(i, R)\n    {\n        cin >> d[i] >> t[i] >> x[i];\n    }\n\n    t.push_back(L);\n\n    time[0] = t[0];\n\n    REP(i, R)\n    {\n        P pre = rmq.getMax(d[i] - 1, d[i]);\n        rmq.update(d[i] - 1, make_pair(pre.fi + x[i], pre.se));\n        P team = rmq.getMax(0, N);\n\n        //cout << team.second << endl;\n\n        time[team.se] += (t[i + 1] - t[i]);\n        //cout << time[team.se] << endl;\n    }\n\n    // REP(i, N)\n    // {\n    //     cout << rmq.getMax(i, i + 1).fi << \" \" << rmq.getMax(i, i + 1).se << \" \";\n    // }\n\n    // cout << endl;\n\n    // REP(i, N)\n    // {\n    //     cout << time[i] << \" \";\n    // }\n\n    // cout << endl;\n\n    cout << max_element(ALL(time)) - time.begin() + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint maxScoreTeam(int score[], int N){\n  int team;\n  int maxscore=0;\n  for (int i=1;i<=N;i++){\n    if (score[i] > maxscore){\n      maxscore = score[i];\n      team = i;\n    }\n  }\n  return team;\n}\n\nint maxScore(int score[], int N){\n  int maxscore=0;\n  for (int i=1;i<=N;i++){\n    if (score[i] > maxscore){\n      maxscore = score[i];\n    }\n  }\n  return maxscore;\n}\n\nint main(){\n  int N,R,L,d,t,x;\n  int top,highscore, pretime;\n  cin >> N >> R >> L;\n  int time[N+1];\n  int score[N+1];\n  for (int i=0;i<=N;i++){\n    time[i] = 0;\n    score[i] = 0;\n  }\n  cin >> d >> t >> x;\n  top = d;\n  pretime = t;\n  score[d] = x;\n  highscore = x;\n  for (int i=1;i<R;i++){\n    cin >> d >> t >> x;\n    score[d] += x;\n    if (score[d] > highscore){\n      time[top] += t - pretime;\n      pretime = t;\n    }\n    int tmp = maxScoreTeam(score, N);\n    if (tmp != top){\n      top = tmp;\n      pretime = t;\n    }\n    highscore = maxScore(score, N);\n  }\n  time[top] += L - pretime;\n  cout << maxScoreTeam(time, N) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<set>\n#include<algorithm>\nusing namespace std;\nint s[100000];\nint p[1000000];\nint q[1000000];\nint r[1000000];\nint ans[100000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tset<pair<int,int> >S;\n\tfor(int i=0;i<a;i++){\n\t\tS.insert(make_pair(0,i));\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d%d\",p+i,r+i,q+i);\n\t\tp[i]--;\n\t}\n\tint now=0;\n\tfor(int i=0;i<c;i++){\n\t\twhile(now<b&&r[now]==i){\n\t\t\tS.erase(make_pair(-s[p[now]],p[now]));\n\t\t\ts[p[now]]+=q[now];\n\t\t\tS.insert(make_pair(-s[p[now]],p[now]));\n\t\t\tnow++;\n\t\t}\n\t\tpair<int,int> M=*(S.begin());\n\t\tans[M.second]++;\n\t}\n\tint val=0;\n\tint at=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(val<ans[i]){\n\t\t\tval=ans[i];\n\t\t\tat=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",at+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[1 << 17];\n\nint N, R, L, n;\n\npair<int, int> dat[1 << 18 + 1];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m = -1000000000;\n  for(int i = 0; i < N; i++)\n  {\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    p = dat[d + n - 1];\n    update(d, make_pair(p.first + x, p.second));\n    if(i != R - 1)\n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[100001],t[100001],x[100001];\nint pnt[100000];\nint cnt[100000];\nsigned main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n    d[R]=0;t[R]=L;x[R]=0;\n\n    priority_queue<D>Q;\n\n    for(int i=0;i<N;i++)Q.push(D(0,i));\n\n    int cur=0;\n    while(cur<R){\n        pnt[d[cur]]+=x[cur];\n        Q.push(D(pnt[d[cur]],d[cur]));\n        while(cur<R&&t[cur]==t[cur+1]){\n            cur++;\n            pnt[d[cur]]+=x[cur];\n            Q.push(D(pnt[d[cur]],d[cur]));\n        }\n\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]+=t[cur+1]-t[cur];\n\n        cur++;\n    }\n\n    cnt[0]+=t[0];\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\nusing namespace std;\n#define N_MAX 100000\ntypedef pair<int,int> P;\n\nint main(){\n  int N,R,L;\n  int d,t,x;\n  int time[N_MAX]={0};\n  int score[N_MAX]={0};\n  cin >> N >> R >> L;\n  priority_queue<P> que;\n  for(int i=1;i<=N;i++){\n    que.push(P(0,N-i));\n  }\n  int now = 0;\n  for(int j=0;j<R;j++){\n    cin >> d >> t >> x;\n    P p1 = que.top();\n    while(score[N-p1.second] != p1.first){\n      que.pop();\n      p1 = que.top();\n    }\n    time[N-p1.second] += t - now;\n    now = t;\n    score[d] += x;\n    que.push(P(score[d],N-d));\n  }\n  P p1 = que.top();\n  while(score[N-p1.second] != p1.first){\n    que.pop();\n    p1 = que.top();\n  }\n  time[N-p1.second] += L - now;\n  priority_queue<P> que2;\n  for(int i=1;i<=N;i++){\n    que2.push(P(time[i],N-i));\n  }\n  p1 = que2.top();\n  cout << N - p1.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// range MAXIMUM query\nclass RMQ {\n  private:\n    static const int MAX_N = 100000;\n    int n;\n    // score, -team_id\n    pii dat[2 * MAX_N - 1];\n    pii rec(int a, int b, int k, int l, int r) {\n        if (b <= l || r <= a) {\n            return {0, 0};\n        }\n\n        if (a <= l && r <= b) {\n            return dat[k];\n        } else {\n            pii rl = rec(a, b, 2 * k + 1, l, (l + r) / 2);\n            pii rr = rec(a, b, 2 * k + 2, (l + r) / 2, r);\n            return max(rl, rr);\n        }\n    }\n\n  public:\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n\n        for (int i = 0; i < 2 * n - 1; i++) {\n            dat[i] = {0, 0};\n        }\n    }\n\n    void update(int k, int a) {\n        int reaf = k + n - 1;\n        dat[reaf] = {dat[reaf].first + a, -k};\n        while (reaf > 0) {\n            reaf = (reaf - 1) / 2;\n            dat[reaf] = max(dat[reaf * 2 + 1], dat[2 * reaf + 2]);\n        }\n    }\n\n    pii query(int a,int b){\n      return rec(a,b+1,0,0,n);\n    }\n};\n\nint main() {\n    int team_n, record_n, end_time;\n    cin >> team_n >> record_n >> end_time;\n\n    RMQ r;\n    r.init(team_n);\n    REP(i, team_n) {\n        r.update(i, 0);\n    }\n\n    vi top(team_n);\n    int btime = 0;\n    REP(i, record_n) {\n        int team_id, time, point;\n        cin >> team_id >> time >> point;\n        team_id--;\n\n        pii t = r.query(0, team_n);\n        top[-t.second] += time - btime;\n        btime = time;\n//        LOG(\"--> %d [%d] (%d)\\n\", t.first, -t.second, time - btime);\n\n        r.update(team_id, point);\n    }\n    pii t = r.query(0, team_n);\n    top[-t.second] += end_time - btime;\n    cout << (max_element(ALL(top)) - top.begin() + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint a[200005][2];\nint s[100005];\nint main(){\n\tint i,j,k;\n\tint n,r,l;\n\tint d=0;\n\tint t=0;\n\tint x=0;\n\tint nn=0;\n\tint f=0;\n\tmemset(a,0,sizeof(a));\n\tmemset(s,0,sizeof(s));\n\tcin>>n>>r>>l;\n\tnn=1;\n\twhile(nn<n){\n\t\tnn*=2;\n\t}\n\tnn--;\n\tfor(i=0;i<n;i++){\n\t\ta[nn+i][1]=i;\n\t}\n\tfor(i=0;i<r;i++){\n\t\tcin>>d>>t>>x;  \n\t\ts[f]+=t;\n\t\td--;\n\t\td+=nn;\n\t\ta[d][0]+=x;\n\t\twhile(d!=0){\n\t\t\td=(d-1)/2;\n\t\t\tif(a[d*2+1][0]<a[d*2+2][0]){\n\t\t\t\ta[d][0]=a[d*2+2][0];\n\t\t\t\ta[d][1]=a[d*2+2][1];\n\t\t\t}else{\n\t\t\t\ta[d][0]=a[d*2+1][0];\n\t\t\t\ta[d][1]=a[d*2+1][1];\n\t\t\t}\n\t\t}\n\t\tf=a[0][1];\n\t\ts[f]-=t;\n\t}\n\ts[f]+=l;\n\tnn=0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[nn]<s[i])nn=i;\n\t}\n\tnn++;\n\tcout<<nn;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n  \n\n\n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n    \n    time[score[1].second] += t - mae;\n    score[d].first += x;\n    mae = t;\n    \n    int site1;\n    \n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = d;\n\tbreak;\n      }\n    \n\t \n    \n    pair <int , int > tmp;   \n    for(int j=d;j>=1;j--) {\n      if(score[site1].first > score[site1/2].first ) {\n      tmp = score[site1];\n      score[site1] = score[site1/2];\n      score[site1/2] = tmp;\n      site1 = site1/2;\n      }else if(score[site1].first == score[site1/2].first && score[site1].second < score[site1/2].second) {\n\ttmp = score[site1];\n\tscore[site1] = score[site1/2];\n\tscore[site1/2] = tmp;\n      site1 = site1/2;\n      } else break;\n    }\n        \n    for(int j=d;j<=N;j++) {\n      if(2*site1< N &&( score[2*site1]> score[site1] || score[2*site1+1] > score[site1])) {\n\tif(site1 > N ) break;\n\tint flg = 0;\n\tif(score[2*site1+1] > score[site1] && score[2*site1] > score[2*site1+1]) flg = 1;\n\ttmp = score[site1];\n\tscore[site1] = score[site1*2+flg];\n\tscore[site1*2+flg] = tmp;\n      }else break;\n    }\n\n  }\n\n  time[score[1].second] += L-x;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n  \n  \n  cout << ans << endl;\n\n  return 0;\n\n  }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<climits>\n\ntypedef std::pair<int, int> P;\n\nconst int MAX_N = 1 << 17;\n\nint n;\n// fst: -得点, snd: チームの番号\nP dat[MAX_N * 2 - 1];\n\nint cnt[MAX_N];\n\nvoid init( int n_ )\n{\n\tn = 1;\n\twhile( n < n_ )\n\t\tn *= 2;\n\n\tfor( int i = 0; i != n * 2 - 1; ++i )\n\t\tdat[i] = std::make_pair( INT_MAX, INT_MAX );\n\n\treturn;\n}\n\nvoid update( int k, P x )\n{\n\tk += n - 1;\n\tdat[k] = x;\n\twhile( k > 0 )\n\t{\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = std::min( dat[k*2+1], dat[k*2+2] );\n\t}\n\n\treturn;\n}\n\n// [a,b)\nP query( int a, int b, int k, int l, int r )\n{\n\tif( a >= r || b <= l )\n\t\treturn std::make_pair( INT_MAX, INT_MAX );\n\t\n\tif( a <= l && r <= b )\n\t\treturn dat[k];\n\telse\n\t{\n\t\tP vl = query( a, b, k * 2 + 1, l, (l + r) / 2 );\n\t\tP vr = query( a, b, k * 2 + 2, (l + r) / 2, r );\n\t\t\n\t\treturn std::min( vl, vr );\n\t}\n}\n\nint main()\n{\n\tint N, R, L;\n\tstd::cin >> N >> R >> L;\n\n\tinit( N );\n\tfor( int i = 0; i != N; ++i )\n\t\tupdate( i, std::make_pair( 0, i ) );\n\n\tint prevT = 0;\n\tfor( int i = 0; i != R; ++i )\n\t{\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\n\t\t--d;\n\n\t\tif( t != prevT )\n\t\t{\n\t\t\tP p = query( 0, N, 0, 0, n );\n\t\t\tcnt[p.second] += t - prevT;\n\t\t}\n\n\t\tP p = query( d, d + 1, 0, 0, n );\n\t\tupdate( d, std::make_pair( p.first - x, p.second ) );\n\n\t\tprevT = t;\n\t}\n\n\tif( prevT != L )\n\t{\n\t\tP p = query( 0, N, 0, 0, n );\n\t\tcnt[p.second] += L - prevT;\n\t}\n\n\tint t = -1, id;\n\tfor( int i = 0; i != N; ++i )\n\t{\n\t\tif( t < cnt[i] )\n\t\t{\n\t\t\tt = cnt[i];\n\t\t\tid = i + 1;\n\t\t}\n\t}\n\t\n\tstd::cout << id << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int length[100005] = {};\n    int point[100005] = {};\n    int N, R, L;\n\n    set < pair < int , int > > st; //point -idx\n\n    cin >> N >> R >> L;\n\n    for ( int i = 0; i < N; i++ ) {\n        st.insert(make_pair(0, -i));\n    }\n    int before = 0;\n    while ( R > 0 ) {\n        int d, t, x;\n        cin >> d >> t >> x; --d;\n\n        length[-(rbegin(st) -> second)] += (t - before);\n        st.erase(make_pair(point[d], -d));\n        point[d] += x;\n        st.insert(make_pair(point[d], -d));\n\n\n        R--, before = t;\n    }\n\n    length[-(rbegin(st) -> second)] += (L - before);\n\n    int maxp = 0;\n    for ( int i = 1; i < N; i++ ) {\n        if ( length[i] > length[maxp] ) {\n            maxp = i;\n        }\n    }\n    cout << maxp + 1 << endl;\n\n    return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\n\nconst int INF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\nconst int MAX_N = 1<<20;\n\nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = -INF;\n        dat[i].se = -(i-n+1);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(-INF, n-1);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\trep(i, n) update(i, INF);\n\tvi v(n, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\t//cout<<-p.se<<endl;\n\t\tv[-p.se] = t-tt;\n\t\ttt = t;\n\t\tupdate(d-1, x);\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] = l-tt;\n\tint ans = 0;\n\tfor(int i = 1; i < v.size(); i++){\n\t\tif(v[ans] < v[i]) ans = i;\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\ntypedef std::pair<int, int> P;\n\nint main(){\n\n\tint n, r, l;\n\tstd::cin >> n >> r >> l;\n\n\tstd::vector<int>point(n, 0);\n\tstd::vector<int>time(n, 0);\n\n\tstd::priority_queue<P>que;\n\n\tint betime = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint d, t, x;\n\t\tstd::cin >> d >> t >> x;\n\t\td--;\n\n\t\twhile (!que.empty()){\n\t\t\tP res = que.top();\n\n\t\t\tif (res.first == point[-res.second]){\n\t\t\t\ttime[-res.second] += (t - betime);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t}\n\n\t\tpoint[d] += x;\n\t\tque.push(P(point[d], -d));\n\n\t\tbetime = t;\n\t}\n\n\twhile (!que.empty()){\n\t\tP res = que.top();\n\n\t\tif (res.first == point[-res.second]){\n\t\t\ttime[-res.second] += (l - betime);\n\t\t\tbreak;\n\t\t}\n\t\tque.pop();\n\t}\n\n\tint max = 0;\n\tfor (int i = 1; i < n; i++){\n\t\tif (time[i]>time[max])max = i;\n\t}\n\n\tstd::cout << max + 1 << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i,Team* team){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest,team);\n  }\n}\nint search(int id,int n,Team* team){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n,Team* team){\n  int t=search(id,n,team);\n  team[t].point+=key;\n  if(key<0){\n    maxHeapify(search(id,n,team),team);\n  }\n  else{\n    while(t>1&&team[t/2].point<team[t].point){\n      swap(team[t],team[t/2]);\n      t=t/2;\n    }\n  }\n}\nvoid insert(int id,Team* team){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=team[top].id;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  Team team[n];\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i,team);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    if(i==0){\n      team[search(1,n,team)].showed+=t[0];\n    }\n    IncreaseKey(d[i],x[i],n,team);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[100001],t[100001],x[100001];\nint pnt[100000];\nint cnt[100000];\nint main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n    d[R]=0;t[R]=L;x[R]=0;\n\n\n    priority_queue<D>Q;\n\n    for(int i=0;i<N;i++)Q.push(D(0,i));\n\n    for(int i=0;i<R;i++){\n        pnt[d[i]]+=x[i];\n        Q.push(D(pnt[d[i]],d[i]));\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]+=t[i+1]-t[i];\n    }\n\n    cnt[0]+=x[0];\n\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define pque priority_queue\n#define pu push\n#define fr first\n#define sc second\n#define sa static\n\nstruct com{\n\tbool operator()(P x,P y){\n\t\tif(x.fr==y.fr)return x.sc>y.sc;\n\t\treturn x.fr<y.fr;\n\t}\n};\n\nint main(){\n\tsa int n,r,l;\n\tsa int d[100010],t[100010],x[100010];\n\t\n\tcin>>n>>r>>l;\n\trep(i,r)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\td[r]=0; t[r]=l; x[r]=0;\n\t\n\tsa int ret[100010]={0};\n\tsa int p[100010]={0};\n\tsa int T=0;\n\tsa pque<P,vector<P>,com> Q; rep(i,n)Q.pu(P(0,i+1));\n\t\n\trep(i,r+1){\n\t\twhile(p[Q.top().sc]!=Q.top().fr)Q.pop();\n\t\tif(t[i]>T){\n\t\t\twhile(p[Q.top().sc]!=Q.top().fr)Q.pop();\n\t\t\tret[Q.top().sc]+=t[i]-T; //cout<<Q.top().sc<<\" \"<<t[i]-T<<endl;\n\t\t\tT=t[i];\n\t\t}\n\t\tp[d[i]]+=x[i]; if(p[d[i]]>Q.top().fr)Q.pu(P(p[d[i]],d[i]));\n\t}\n\t\n\tint Ret=0,Max=0;\n\trep(i,n){\n\t\t//cout<<i+1<<\" \"<<ret[i+1]<<endl;\n\t\tif(ret[i+1]>Max){ Ret=i+1; Max=ret[i+1]; }\n\t}\n\t\n\tcout<<Ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define F first\n#define S second\ntypedef pair<int, int> P;\n\nint n;\nP dat[100010 * 4];\n\nvoid update(int id, int a){\n  int k = id;\n  k += n - 1;\n  dat[k].F += a;\n  dat[k].S = -id;\n\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n  }\n}\n\nvoid init(int n_){\n  n = 1;\n  while(n < n_) n *= 2;\n\n  for(int i = 0;i < n_; i++) update(i, 0);\n}\n/*\nP query(int a, int b, int k, int l, int r){\n  P p;\n  p.F = 0; p.S = 0;\n  if(r <= a || b <= l) return p;\n\n  if(a <= l && r <= b) return dat[k];\n  else{\n    P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return max(vl, vr);\n  }\n}\n*/\n\nint main(void)\n{\n  int N, r, l;\n  int d, t, x;\n  int max_idx = 0;\n  int prev_t = 0, time[100010] = {0};\n  P p; //p.S = -1;\n\n  scanf(\"%d %d %d\", &N, &r, &l);\n  init(N);\n\n  for(int i = 0;i < r; i++){\n    scanf(\"%d %d %d\", &d, &t, &x);\n    d--;\n    //p = query(1, N + 1, 0, 0, n);\n    p = dat[0];\n    time[-p.S] += t - prev_t;\n    update(d, x);\n    prev_t = t;\n  }\n  //p = query(1, N + 1, 0, 0, n);\n  p = dat[0];\n  time[-p.S] += l - prev_t;\n  for(int i = 0;i < N; i++){\n    //printf(\"%d\\n\", time[i]);\n    if(time[max_idx] < time[i])\n      max_idx = i;\n  }\n  printf(\"%d\\n\", max_idx + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,r,l;\nint d[100001],t[100001],x[1000001];\nint i,j,flg,max,min;\nint a[1000001]={0},b[1000001]={0};\nint main(void)\n{\n\t\n\tcin>>n>>r>>l;\n\t\t\n\tflg=0;\n\tfor(i=1;i<=r;i++){\n\t\tcin>>d[i]>>t[i]>>x[i];\n\t\tif(x[i]<0){\n\t\t\tflg=1,b[d[i]]=x[i],x[i]=0;\n\t\t}\t\n\t}\n\t\n\tif(flg==0){\n\t\tfor(j=r;j>0;j--){\n\t\t\tif(j==r) a[n]+=l-t[r],b[n]+=x[r];\n\t\t\tif(j+1<=r){\n\t\t\t\ta[d[j]]+=t[j+1]-t[j],b[d[j]]+=x[j];\n\t\t\t}\t\n\t\t}\n\t}\t\t\n\n\tif(flg==1){\n\t\tfor(j=0;j<r;j++){\n\t\t\tif(j+1<=r){\n\t\t\t\tb[d[j]]+=x[j];\n\t\t\t}\t\n\t\t}\n\t}\n\t\n\tmax=-1,min=1000010;\n\tfor(i=1;i<=n;i++){\n\t\tif(max<a[i]&&min>i) min=i;\n\t}\n\tcout<<min<<endl;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][10],T=0,g,p[2][10],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define MAX_N (100001)\n#define MAX_R (1000000)\n#define max(x,y) ((x) > (y) ? (x) : (y))\n\nvoid init(int data[],int n);\nvoid updata(int data[],int k,int a,int n);\nint query(int data[]);\nint such(int data[],int k,int n);\n\ntypedef struct{\n  int d,t,x;\n}Rec;\n\nint main(){\n  int score[2*MAX_N -1],time[2*MAX_N -1];\n  int r,l,n,n_;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n\n  n_=n;\n  n=1;\n  while(n<n_) n*=2;\n\n  init(score,n);\n  init(time,n);\n  \n  int t_a=0,t_b=0;\n  int k,t,d,x;\n  for(int i=0;i<r;i++){\n\n    scanf(\"%d %d %d\",&d ,&t_a ,&x);\n\n    k = such(score, 0, n);\n\n    if(t_b==0) t = t_a;\n    else     t = t_a - t_b;\n    t_b = t_a;\n\n    updata(time, k, time[k+n-1]+t, n);\n\n    updata(score, d, score[d+n-1]+x, n);\n  \n    /*\n    printf(\"\\n---------------\\n\");\n\n    printf(\"k = %d\\n\",k);\n    for(int i=0;i<n;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }\n    printf(\"-  -  -  -\\n\");\n    for(int i=n;i<n*2;i++){\n      printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n      }*/\n    \n  }\n\n  k = such(score, 0, n);\n  t = l-t_b;\n  updata(time, k, time[k+n-1]+t, n);\n\n  /*\n  printf(\"\\n---------------\\n\");\n  \n  printf(\"k = %d\\n\",k);\n  for(int i=0;i<n;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n  }\n  printf(\"-  -  -  -\\n\");\n  for(int i=n;i<n*2;i++){\n    printf(\"%d : score %d  time %d\\n\",i,score[i],time[i]);\n    }*/\n\n  printf(\"%d\\n\",such(time,0,n));\n\n}\n\nvoid init(int data[],int n){\n  for(int i=0;i<n*2-1;i++){\n    data[i]=0;\n  }\n  return ;\n}\n\nvoid updata(int data[],int k,int a,int n){\n\n  k=k+n-1;\n  data[k]=a;\n  \n  while(k>0){\n    k = (k-1)/2;\n\n    data[k] = max(data[k*2+1] , data[k*2+2]);\n  }\n\n  return ;\n}\n    \nint query(int data[]){\n  return data[0];\n}\n\nint such(int data[],int k,int n){\n \n  if(k>=n) return k-n+1; \n\n  if(data[k]==data[k*2+1]) return such(data,k*2+1,n);\n  if(data[k]==data[k*2+2]) return such(data,k*2+2,n);\n\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECUREj_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto iiiiiiiiii : a)cout << iiiiiiiiii << endl; }\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\nconst int MAX_N = 1<<18;\nint n;\npii dat[2 * MAX_N - 1];\n\nvoid init(int n_)\n{\n\tn = 1;\n\twhile (n < n_)n *= 2;\n\tfor (int i = 0; i < 2 * n - 1; i++)dat[i] = pii(INT_MAX,0);\n}\n\nvoid update(int k, pii a)\n{\n\tk += n - 1;\n\tdat[k] = a;\n\twhile (k > 0)\n\t{\n\t\tk = (k - 1) / 2;\n\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);\n\t}\n}\n\npii query(int a, int b, int k, int l, int r)\n{\n\tif (r <= a || b <= l)return pii(INT_MAX,0);\n\tif (a <= l&&r <= b)return dat[k];\n\telse\n\t{\n\t\tpii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr);\n\t}\n}\n\npii calc(int a, int b)//[a,b)\n{\n\treturn query(a, b, 0, 0, n);\n}\n\nsigned main()\n{\n\tint r, l;\n\tcin >> n >> r >> l;\n\tint ans[100001] = {};\n\tinit(n);\n\tfor (int i = 0; i < n; i++)update(i, pii(0,i));\n\tint b = 0;\n\twhile (r--)\n\t{\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x; d--;\n\t\tans[calc(0, n).second] += t-b;\n\t\tb = t;\n\t\tpii p = dat[d+ n - 1];\n\t\tp.first -= x;\n\t\tupdate(d , p);\n\t}ans[calc(0, n).second] += l - b;\n\tint p = -1, id = 0;\n\tfor (int i = n-1; i >= 0; i--)\n\t{\n\t\tif (ans[i] >= p)\n\t\t{\n\t\t\tp = ans[i];\n\t\t\tid = i + 1;\n\t\t}\n\t}\n\n\n\tcout << id << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define INF 1000000000\nusing namespace std;\n\nstruct state {\n  int id,score,last;\n  bool operator < ( const state &p ) const {\n    if(score==p.score)return id > p.id;\n    else return score < p.score;\n  }\n};\n\nstruct event {\n  int d,t,x;\n};\n\npriority_queue < state > Q;\n\nint N,R,L;\nint score[100010];\nint last[100010];\nint sum[100010];\nevent events[100010];\n\n\nint main(){\n  for(int i=0;i<100010;i++)score[i]=last[i]=sum[i]=0;\n  cin>>N>>R>>L;\n  for(int i=1;i<=N;i++)Q.push( (state){i,0,0} );\n  for(int i=0;i<R;i++){\n    cin>>events[i].d>>events[i].t>>events[i].x;\n  }\n  events[R].t=L;\n  events[R].d=events[R].x=0;\n  state f=(state){1,0,0},g;\n  int a=0;\n  for(int i=0;i<=R;i++){\n    event e = events[i];\n    score[e.d]+=e.x;\n    last[e.d]=e.t;\n    Q.push( (state){e.d,score[e.d],last[e.d]} );\n    if(i+1<=R&&e.t==events[i+1].t)continue;\n    g=f;\n    while(1){\n      f=Q.top();\n      if(f.last==last[f.id])break;\n      Q.pop();\n    }\n    sum[g.id]+=(e.t-a);\n    //cout<<g.id << ' '<<e.t-a<<endl;\n    a=e.t;\n  }\n  int ans=-1,ans2=0;\n  for(int i=1;i<=N;i++){\n    if(ans<sum[i]){\n      ans=sum[i];\n      ans2=i;\n    }\n  }\n  cout<<ans2<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nstruct SegTree {\n    int N;\n    pll init_v;\n    vector<pll> node;\n    \n    SegTree(int _N) {\n        init_v = pll(-INF,-INF);\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n    }\n    \n    void update(int k, pll val) {\n        k += N - 1;\n        node[k] = val;\n        while (k) {\n            k = (k - 1) / 2;\n            node[k] = max(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    pll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) return node[k];\n        else {\n            pll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            pll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return max(vl, vr);\n        }\n    }\n    pll rmq(int a, int b) { return query(a, b, 0, 0, N); }\n};\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int N,R,L; cin >> N >> R >> L;\n    vector<ll> d(R),t(R),x(R);\n    for(int i = 0; i < R;i++){\n        cin >> d[i] >> t[i] >> x[i];\n        d[i]--;\n    }\n    \n    SegTree st(N);\n    for(int i = 0; i < N;i++){\n        st.update(i,pll(0,-i));\n    }\n    vector<pll> team(N);\n    for(int i = 0; i < N;i++) team[i] = pll(0,-i);\n    \n    ll pre_t = 0;\n    for(int i = 0; i < R;i++){\n        auto ret = st.rmq(0,N);\n        team[abs(ret.second)].first += t[i] - pre_t;\n        pre_t = t[i];\n        \n        st.update((int)d[i],pll(st.node[d[i] + st.N - 1].first + x[i],-d[i]));\n    }\n    auto ret = st.rmq(0,N);\n    team[abs(ret.second)].first += L - pre_t;\n    pre_t = L;\n    \n    sort(team.begin(),team.end());\n    reverse(team.begin(), team.end());\n    cout << abs(team[0].second) + 1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[131100];\nstruct node {\n    int id, point;\n} node[1<<18];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<LL, int> P;\nconst LL INF = LONG_MAX / 2LL;\n\nconst int MAX_N = 262144;\nP dat[MAX_N * 2 - 1];\nLL times[MAX_N];\n\nint n, r, l;\n\nvoid init()\n{\n\tfor (int i = 0; i < 2 * n - 1; i++)\n\t{\n\t\tdat[i] = P(0, -(2 << 20));\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdat[n + i - 1].second = -i;\n\t}\n}\n\nvoid update(int i, LL x)\n{\n\ti += n - 1;\n\tdat[i].first += x;\n\twhile (i > 0)\n\t{\n\t\ti = (i - 1) / 2;\n\t\tdat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n}\n\nP query(int a, int b, int k, int l, int r)\n{\n\tif(r <= a || b <= l) return P(-INF, -1);\n\tif(a <= l && r <= b) return dat[k];\n\telse\n\t{\n\t\tP vl = query(a, b,k * 2 + 1, l, (l + r) / 2);\n\t\tP vr = query(a, b,k * 2 + 1, (l + r) / 2, r);\n\t\tif(vr > vl) return vr;\n\t\treturn vl;\n\t}\n}\n\nint main(void)\n{\n\twhile(cin >> n >> r >> l && n >= 2)\n\t{\n\t\tvector<int> d(r), x(r), t(r);\n\t\tfor (int i = 0; i < r; i++)\n\t\t{\n\t\t\tcin >> d[i] >> x[i] >> t[i];\n\t\t\td[i]--;\n\t\t}\n\t\tinit();\n\t\tmemset(times, 0, sizeof(times));\n\t\tP pre = P(0,0);\n\t\tint pret = 0;\n\t\tfor (int i = 0; i < r; i++)\n\t\t{\n\t\t\tif(i + 1 < r && t[i] == t[i + 1])\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tupdate(d[i], x[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tupdate(d[i], x[i]);\n\t\t\tP p = query(0, n-1, 0, 0, n);\n\t\t\ttimes[-pre.second] += (t[i] - pret);\n\t\t\tpret = t[i];\n\t\t\tpre = p;\n\t\t}\n\t\tcout << (max_element(times, times + n) - times) + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 100000\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\nstruct segtree{\n  int N;\n  P dat[MAX_N * 2 - 1];\n  segtree(){}\n  segtree(int n){\n    N = 1;\n    while(n > N) N *= 2;\n\n    rep(i, 2 * N - 1) dat[i] = MP(-1000000, -1000000);\n    for(int i = N - 1; i < 2 * N - 1; i++) dat[i] = MP(0, -1 * (i - N + 1));\n  }\n\n  void update(int k, int a){\n    k += N - 1;\n    dat[k].F += a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1], dat[2*k+2]);\n    }\n  }\n\n  P query(int a, int b){ return query(a, b, 0, 0, N); }\n  P query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return P(-100000, -1000000);\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      P vl = query(a, b, 2*k+1, l, (l+r)/2);\n      P vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return max(vl, vr);\n    }\n  }\n};\n\nint main(){\n  int N, R, L;\n  int res[MAX_N];\n  scanf(\"%d%d%d\", &N, &R, &L);\n  segtree seg(N);\n  rep(i, N) seg.update(i, 0);\n  int time = 0;\n  rep(i, R){\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x); d--;\n    P s = seg.query(0, N);\n    res[-s.second] += t - time;\n    seg.update(d, x);\n    time = t;\n  }\n\n  P s = seg.query(0, N);\n  res[-s.second] += L - time;\n\n  int ans = 0;\n  rep(i, N) if(res[ans] < res[i]) ans = i;\n\n  printf(\"%d\\n\", ans+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n+1];\n    for(int i=0;i<2*n+1;i++){\n      points[i] = Team(i,0);\n    }\n\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,-100000);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams);\n\n    map<int,vector<Team> > records;\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      records[time].push_back(Team(id,point));\n    }\n\n    for(map<int,vector<Team> >::iterator it = records.begin();\n\tit != records.end();\n\tit++){\n      for(int i=0;i<it->second.size();i++){\n\tseg_tree.insert(it->second[i].id,it->second[i].point);\n      }\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += it->first - prev_time;\n\tprev_time = it->first;\n\tprev_champ = team.id;\n      }\n    }\n\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\npair<int,int> rmq[1111111111111];\nint N,R,L;\nint d[1111111]={0};\nint t[1111111]={0};\nint x[1111111]={0};\nint team[11111111]={0};\n\nvoid updata(int k,int x){\n  int no=k;\n  k += N-1;\n  rmq[k].first += x;\n  rmq[k].second = k;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(rmq[k*2+1].first > rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+1];\n    }\n    else if(rmq[k*2+1].first < rmq[k*2+2].first){\n      rmq[k] = rmq[k*2+2];\n    }\n    else if(rmq[k*2+1].second < rmq[k*2+2].second){\n      rmq[k] = rmq[k*2+1];\n    }\n    else{\n      rmq[k] = rmq[k*2+2];\n    }\n  }\n  return;\n}\n\n\nint main(){\n  for(int i=0;i<1111111;i++){\n    rmq[i].first = 0;\n    rmq[i].second = 0;\n  }\n  int smp=0;\n  int now=0;\n  int now1=0;\n  cin >> N >> R >> L;\n  for(int i=0;i<R;i++){\n    smp = rmq[0].second;\n    cin >> d[i] >> t[i] >> x[i];\n    updata(d[i],x[i]);\n    if(smp != rmq[0].second){\n      team[smp-2] += t[i] - now;\n      if(t[i] != t[i+1]){ \n\tnow = t[i];\n      }\n    }\n    smp = rmq[0].second;\n  }\n  team[smp-2] += L - now;\n  int a=0;\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    //cout<<team[i]<<endl;\n    if(a < team[i]){\n      ans = i;\n      a = team[i];\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//?????°???????????????????????????????????§?????????????????????\n//???????????????????????¨?????????????????????????¬????????????¨?????????????¢?????????????\n//?????????????????????????????§?????????push???????????¨??????????????¨???????????????\n//??????????¶???????????????????????????????????????????????????????????????§??????????????????\n\nstruct team{\n    long long n,p,time;\n};\n\nbool operator<(const team& t1,const team& t2){\n    if(t1.p==t2.p){\n        return t1.n > t2.n;\n    }\n    return t1.p < t2.p;\n}\n\npriority_queue<team> q;\nteam tea[100001];\n\nint main() {\n\n    long long n,r,l;\n\n    cin >> n >> r >> l;\n\n    /*for(int i=0;i<r;i++){\n        cout << rec[i].d << \" \" << rec[i].t << \" \" << rec[i].x << endl;\n    }*/\n\n    for(int i=1;i<=n;i++){\n        tea[i].n = i;\n        tea[i].p = 0;\n        tea[i].time = 0;\n        q.push(tea[i]);\n    }\n\n    int d,t,x,btime=0,bnum=1;\n    team tmp;\n    for(int i=0;i<r;i++){\n        cin >> d >> t >> x;\n        tea[bnum].time += t - btime; //?????°???????????????????????????????????§????????????????????????????¢??????????\n        tea[d].p += x; //????????????\n        q.push(tea[d]); //???????????\\\n        while(!q.empty()){\n            tmp = q.top();\n            if(tmp.p == tea[tmp.n].p){ //?????°????????´???????????£????????????\n                bnum = tmp.n; //?????§????????????????????????????¨????\n                break;\n            }\n            q.pop(); //??????\n        }\n        btime = t; //????????????????¨????\n    }\n\n    tea[bnum].time += l - btime ; //??????????????£???????????????????????????????¶????\n\n\n    int ans=1;\n\n    for(int i=1;i<=n;i++){\n        ans = tea[i].time > tea[ans].time ? i : ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[100010];\nstruct node {\n    int id, point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n  \n\n\n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n    \n    time[score[1].second] += t - mae;\n    score[d].first += x;\n    mae = t;\n    \n    int site1;\n    \n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = d;\n\tbreak;\n      }\n    \n\t \n    \n    pair <int , int > tmp;   \n    for(int j=d;j>=1;j--) {\n      if(score[site1].first > score[site1/2].first ) {\n      tmp = score[site1];\n      score[site1] = score[site1/2];\n      score[site1/2] = tmp;\n      site1 = site1/2;\n      }else if(score[site1].first == score[site1/2].first && score[site1].second < score[site1/2].second) {\n\ttmp = score[site1];\n\tscore[site1] = score[site1/2];\n\tscore[site1/2] = tmp;\n      site1 = site1/2;\n      } else break;\n    }\n        \n    while(2*site1< N &&( score[2*site1]> score[site1] || score[2*site1+1] > score[site1])) {\n      if(site1 > N ) break;\n      int flg = 0;\n      if(score[2*site1+1] > score[site1] && score[2*site1] > score[2*site1+1]) flg = 1;\n      tmp = score[site1];\n      score[site1] = score[site1*2+flg];\n      score[site1*2+flg] = tmp;\n    }\n    \n\n  }\n\n  time[score[1].second] += L-x;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n  \n  \n  cout << ans << endl;\n\n  return 0;\n\n  }"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100001;\n\nint main(){\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tpriority_queue<int, vector<pair<int, int> > > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tttime[temp.second] += t - ttemp;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint N, R, L, x[1000000], y[1000000], D[1000000], T[1000000], X[1000000], maxn, maxid;\nint main() {\n\tcin >> N >> R >> L;\n\tfor (int i = 1; i <= R; i++) {\n\t\tcin >> D[i] >> T[i] >> X[i];\n\t}\n\tD[0] = 1; T[0] = 0; X[0] = 0;\n\tD[R + 1] = 0; T[R + 1] = L; X[R + 1] = 0;\n\n\tfor (int i = 0; i <= R + 1; i++) {\n\t\tif (i >= 1) {\n\t\t\tmaxn = -1000000000;\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tif (x[j] > maxn) { maxn = x[j]; maxid = j; }\n\t\t\t}\n\t\t\ty[maxid] += T[i] - T[i - 1];\n\t\t}\n\t\tx[D[i]] += X[i];\n\t}\n\n\tmaxn = -1000000000;\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (maxn < y[i]) { maxn = y[i]; maxid = i; }\n\t}\n\tcout << maxid << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100001],tt[100001];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = tp[1];\n\t\tFlag = 1;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=2;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );//L - t\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t//\tprintf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst int MAX_N = 100001, MAX_R = 1000001;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = 0;\n            seg2[i] = 0;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] = v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N+1);\n    rs[0] = {0, 0, 0};\n    REP(i, R+1){\n        std::cin >> rs[i+1].d >> rs[i+1].t >> rs[i+1].x;\n    }\n\n    int prev = 0, ts[MAX_N];\n    std::fill(ts, ts+N+1, 0);\n    REP(i, R+1){\n        if(i+1 > N || rs[i].t < rs[i+1].t){\n            printf(\"%d: +%d\\n\", st.root().second, rs[i].t - prev);\n            ts[st.root().second] += rs[i].t - prev;\n            prev = rs[i].t;\n        }\n        st.update(rs[i].d, rs[i].x);\n    }\n    ts[st.root().second] += L - prev;\n\n    int max_team = 0, max_t = -1;\n    FOR(i, 1, N+1){\n        if(ts[i] > max_t){\n            max_team = i;\n            max_t = ts[i];\n        }\n    }\n\n    //std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[100000];\n\nint N, R, L, n;\n\npair<int, int> dat[200000];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m;\n  for(int i = 0; i < N; i++)\n  {\n    cout << ans[i] << \" \" ;\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    update(d, make_pair(dat[d + (n - 1)].first + x, dat[d + (n - 1)].second));\n    if(i != R - 1) \n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\ntypedef long long int Int;\n#define REP(i, j) for(Int i = 0; i < (Int)(j); ++i)\n#define FOR(i, j, k) for(Int i = (Int)(j); i < (Int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<Int, Int> P;\nconst Int MAX_N = (1 << 17);\nnamespace std {\n  bool operator > (const P& a, const P& b) {\n    return a.first != b.first ? a.first > b.first : a.second < b.second;\n  }\n}\n\nInt n;\nP v[2 * MAX_N - 1];\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(Int nn){\n  n = 1;\n  while(n < nn) n *= 2;\n  REP(i, 2 * n - 1) v[i] = P(0, 1);\n  REP(i, nn) v[i + n - 1] = P(0, i + 1);\n}\n\n// テヲツキツサテ・ツュツ療」ツ?渓テ」ツ?ョテ」ツつづ」ツ?ョテ」ツつ誕テ」ツ?ォテヲツ崢エテヲツ鳴ー\nvoid update(Int k, Int a){\n  k += n - 1;\n  v[k].first = a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    v[k] = max(v[k * 2 + 1], v[k * 2 + 2]);\n  }\n}\n\n// [a, b)テ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?、テ」ツつ津ヲツ個?」ツ?、テ」ツδ?」ツδシテ」ツδ?」ツδ甘」ツδウテ」ツδ静」ツδシテ」ツつ津ヲツアツづ」ツつ?」ツつ?\n// kテ」ツ?ッテ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ヲツキツサテ・ツュツ療」ツ?〕, rテ」ツ?ッテ」ツ?敕」ツつ古」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ擬l, r)\n// テ・ツ堕シテ」ツ?ウテ・ツ?コテ」ツ?凖ヲツ卍づ」ツ?ッquery(a, b, 0, 0, n)テ」ツ?ィテ」ツ?療」ツ?ヲテ・ツ堕シテ」ツ?カ\nP query(Int a, Int b, Int k, Int l, Int r){\n  if(b <= l || a >= r) return P(-1, -1);\n  if(a <= l && b >= r) return v[k];\n  P vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  P vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  return max(vl, vr);\n}\n\nint main() {\n  Int N, R, L, d, t, x, bef = 0; cin >>N >>R >>L;\n  P tar = P(0, 1);\n  vector<Int> cnt(N, 0);\n  init(N);\n  set<P> S;\n  REP(r, R){\n    cin >>d >>t >>x;\n    --d;\n    cnt[tar.second - 1] += t - bef;\n    update(d, x + v[d + n - 1].first);\n    tar = query(0, N, 0, 0, n);\n    bef = t;\n  }\n  cnt[tar.second - 1] += L - bef;\n  Int ans = 0;\n  REP(i, N) if(cnt[i] > cnt[ans]) ans = i;\n  cout <<ans + 1 <<endl;\n  //REP(i, N) cout <<i + 1 <<\": \" <<cnt[i] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//vector<vector<int> > dp;\n//vector<vector<vector<int> > > vvvi;\n//dp=vector<vector<int> >(N, vector<int>(M,0));\n//vector<pair<int,int> > v;\n//v.push_back(make_pair(x,y));\n//priority_queue<int,vector<int>, greater<int> > q2;\n\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\n\n\tpriority_queue<pii> q;\n\tint N, R, L, S[1000010], T[1000010], d, t, x;\n\tcin >> N >> R >> L;\n\tq.push(pii(0, -1));\n\teREP(i, N) {\n\t\tS[i] = 0;\n\t\tT[i] = 0;\n\t}\n\tint pret = 0, pred = 1;\n\tREP(i, R) {\n\t\tcin >> d >> t >> x;\n\t\tS[d] += x;\n\t\tq.push(pii(S[d], -d));\n\t\twhile (1) {\n\t\t\tpii p = q.top();\n\t\t\tif (p.first == S[-p.second]) {\n\t\t\t\tT[pred] += t - pret;\n\t\t\t\tpred = -p.second;\n\t\t\t\tpret = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\tT[pred] += L - pret;\n\tint ans = -1, tmp;\n\teREP(i, N) {\n\t\t//cout << T[i] << \" \";\n\t\tif (ans < T[i]) {\n\t\t\ttmp = i;\n\t\t\tans = T[i];\n\t\t}\n\t}\n\tcout << tmp << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint a[200005][2];\nint s[100005];\nint main(){\n\tint i,j,k;\n\tint n,r,l;\n\tint d=0;\n\tint t=0;\n\tint x=0;\n\tint nn=0;\n\tint f=0;\n\tmemset(a,0,sizeof(a));\n\tmemset(s,0,sizeof(s));\n\tcin>>n>>r>>l;\n\tnn=1;\n\twhile(nn<n){\n\t\tnn*=2;\n\t}\n\tnn--;\n\tfor(i=0;i<n;i++){\n\t\ta[nn+i][1]=i;\n\t}\n\tfor(i=0;i<r;i++){\n\t\tcin>>d>>t>>x;  \n\t\ts[f]+=t;\n\t\td--;\n\t\td+=nn;\n\t\ta[d][0]+=x;\n\t\twhile(d!=0){\n\t\t\td=(d-1)/2;\n\t\t\tif(a[d*2+1][0]<a[d*2+2][0]){\n\t\t\t\ta[d][0]=a[d*2+2][0];\n\t\t\t\ta[d][1]=a[d*2+2][1];\n\t\t\t}else{\n\t\t\t\ta[d][0]=a[d*2+1][0];\n\t\t\t\ta[d][1]=a[d*2+1][1];\n\t\t\t}\n\t\t}\n\t\tf=a[0][1];\n\t\ts[f]-=t;\n\t}\n\ts[f]+=l;\n\tnn=0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[nn]<s[i])nn=i;\n\t}\n\tnn++;\n\tcout<<nn<<endl;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint a,toread,N,R,L,d,t,x,i,time=0,team,T[1001],P[1001],i2,max,dscanf[1001],tscanf[1001],xscanf[1001];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i<=R;i++){\n\t\tT[i]=0;\n\t\tP[i]=0;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tdscanf[i]=d;\n\t\ttscanf[i]=t;\n\t\txscanf[i]=x;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(i!=1){\n\t\t\tfor(a=i;a>=1;a--){\n\t\t\t\tif(tscanf[i]>=tscanf[a]){\n\t\t\t\t\ttoread=tscanf[i];\n\t\t\t\t\ttscanf[i]=tscanf[a];\n\t\t\t\t\ttscanf[a]=toread;\n\t\t\t\t\ttoread=dscanf[i];\n\t\t\t\t\tdscanf[i]=dscanf[a];\n\t\t\t\t\tdscanf[a]=toread;\n\t\t\t\t\ttoread=xscanf[i];\n\t\t\t\t\txscanf[i]=xscanf[a];\n\t\t\t\t\txscanf[a]=toread;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=R;i++){\n\t\td=dscanf[i];\n\t\tt=tscanf[i];\n\t\tx=xscanf[i];\n\t\tP[d]+=x;\n\t\tmax=0;\n\t\tif(i!=1){\n\t\t\tfor(i2=1;i2<=R;i2++){\n\t\t\t\tif(P[i2]>P[max]){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t\telse if(P[i2]==P[max]&&i2<max){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t}\n\t\tT[team]+=t-time;\n\t\t}\n\t\ttime=t;\n\t\tteam=max;\n\t\tT[0]=0;\n\t}\n\tif(time!=L){\n\t\tT[max]=L-time;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(T[i]>T[max]){\n\t\t\tmax=i;\n\t\t}\n\t\telse if(T[i]==T[max]&&i<max){\n\t\t\tmax=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}#include<stdio.h>\nint main(){\n\tint a,toread,N,R,L,d,t,x,i,time=0,team,T[1001],P[1001],i2,max,dscanf[1001],tscanf[1001],xscanf[1001];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i<=R;i++){\n\t\tT[i]=0;\n\t\tP[i]=0;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tdscanf[i]=d;\n\t\ttscanf[i]=t;\n\t\txscanf[i]=x;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(i!=1){\n\t\t\tfor(a=i;a>=1;a--){\n\t\t\t\tif(tscanf[i]>=tscanf[a]){\n\t\t\t\t\ttoread=tscanf[i];\n\t\t\t\t\ttscanf[i]=tscanf[a];\n\t\t\t\t\ttscanf[a]=toread;\n\t\t\t\t\ttoread=dscanf[i];\n\t\t\t\t\tdscanf[i]=dscanf[a];\n\t\t\t\t\tdscanf[a]=toread;\n\t\t\t\t\ttoread=xscanf[i];\n\t\t\t\t\txscanf[i]=xscanf[a];\n\t\t\t\t\txscanf[a]=toread;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=R;i++){\n\t\td=dscanf[i];\n\t\tt=tscanf[i];\n\t\tx=xscanf[i];\n\t\tP[d]+=x;\n\t\tmax=0;\n\t\tif(i!=1){\n\t\t\tfor(i2=1;i2<=R;i2++){\n\t\t\t\tif(P[i2]>P[max]){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t\telse if(P[i2]==P[max]&&i2<max){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t}\n\t\tT[team]+=t-time;\n\t\t}\n\t\ttime=t;\n\t\tteam=max;\n\t\tT[0]=0;\n\t}\n\tif(time!=L){\n\t\tT[max]=L-time;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(T[i]>T[max]){\n\t\t\tmax=i;\n\t\t}\n\t\telse if(T[i]==T[max]&&i<max){\n\t\t\tmax=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n int N,R,L;\n int INF = 1e9;\n\n cin >> N >> R >> L;\n\n\n pair <int,int>  score[200005];\n int time[100005];\n for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n int id[200005] = {};\n for(int i=1;i<=N;i++) {\n   score[i]=make_pair(0,i);\n   id[i] = i;\n   time[i] = 0;\n }\n \n int  mae = 0;\n \n int d,t,x;\n for(int i=0;i<R;i++) {\n   cin >> d >> t >> x;\n\n int site1 = id[d];\n   assert(site1>=1);\n   \n   time[score[1].second] += t - mae;\n   score[site1].first -= x;\n   mae = t;\n\n   if(x>0){ \n     while(site1>1) {\n       if(score[site1] < score[site1/2] ) {\n\t swap(score[site1], score[site1/2]);\n\t id[score[site1].second]= site1;\n\t id[score[site1/2].second] = site1/2;\n       site1 = site1/2;\n     } else break;\n     }\n   }\n   else {\n     while(1) {\n       if( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t int flg = 0;\n\t if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t swap(score[site1],score[2*site1+flg]);\n\t id[score[site1].second] = site1;\n\t id[score[2*site1+flg].second] = 2*site1+flg;\n\t site1 = 2*site1+flg;\n       }else break;\n     }\n   }\n   /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n\t cout << endl;\n\t for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n\t cout << endl;\n\t for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n\t cout << endl;\n   */\n }\n \n\n time[score[1].second] += L-mae;\n \n int maxtime = -1;\n int ans;\n for(int i=1;i<=N;i++) \n   if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n // for(int i=1;i<=N;i++) cout << time[i] <<\" \";\n //cout << endl;\n \n cout << ans << endl;\n\n return 0;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[100010];\nstruct node {\n    int id;\n    long long point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<limits.h>\nusing namespace std;\n#define max fahjkfhkahfsj\ntypedef pair<long long int,long long int> P;\nlong long int team[100001],ten[100001];\nint main(void){\n\tpriority_queue<P> qu;\n\tlong long int n,r,l,i,m,mm,d,t,x,ans,max;\n\tP ppp;\n\tcin>>n>>r>>l;\n\tfor(i=1;i<=n;i++){\n\t\tteam[i]=0;\n\t\tten[i]=0;\n\t}\n\tcin>>d>>t>>x;\n\tten[d]+=x;\n\tqu.push(P(ten[d],d*-1));\n\tm=t; mm=d; max=LONG_MIN;\n\tfor(i=1;i<r;i++){\n\t\tcin>>d>>t>>x;\n\t\tppp=qu.top();\n\t\tif(ppp.second==d){\n\t\t\twhile(ppp.second==d){\n\t\t\t\tif(ppp.second!=ten[d]){\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tppp=qu.top();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tten[d]+=x;\n\t\tqu.push(P(ten[d],d*-1));\n\t\tppp=qu.top();\n\t\tif(ppp.first!=ten[mm]){\n\t\t\tteam[mm]+=t-m;\n\t\t\tif(max<team[mm]){\n\t\t\t\tmax=team[mm];\n\t\t\t\tans=mm;\n\t\t\t}\n\t\t\tm=t; mm=d;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(long long int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  long long int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += t-oldt;\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n      if(pt[old]==pt[d]&&old>d) old = d;\n    }else{\n      if(old==d) old = max(pt,N);\n    }\n  }\n  ptime[old] += L- oldt;\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(void){\n  int n,r,l;\n  cin>>n>>r>>l;\n  vector<int> tn(n,0);\n  vector<int> c(n,0);\n  int now = 0,ln;\n  int max = 0;\n  int d,t,x;\n\n  for(int i = 0 ; i < r ; i ++){\n     cin>>d>>t>>x;\n     d--;\n     tn[d] += t * x;\n     if(max < tn[d]){\n     //cout<<d<<endl;\n      c[ln] += t - (!now?t:now); \n      now = t; ln = d;     \n     }\n     \n  }\n  if(max < tn[d]){\n     //cout<<d<<endl;\n      c[ln] += l - now; \n      now = t; ln = d;     \n  }\n  for(int i = 0 ; i < n ; i ++){\n    if(c[i] > max)max = c[i];\n  }\n  for(int i = 0 ; i < n ; i ++){\n    if(c[i] == max){\n      cout<<i+1<<endl;\n      break;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint now=0;\n\tint gap;\n\tint max,id;\n\tint team[100001]={0};\n\tint time[100001]={0};\n\n\tcin >> N >>R >> L;\n\n\tmax=team[1];\n\tid=1;\n\twhile(R--){\n\t\tcin >>d>>t>>x;\n\t\tgap=t-now;\n\t\tnow=t;\n\t\ttime[id]+=gap;\n\t\tteam[d]+=x;\n\t\tif(x>=0){\n\t\t\tif(max<team[d]){\n\t\t\t\tmax=team[d];\n\t\t\t\tid=d;\n\t\t\t}\n\t\t}else{\n\t\t\tmax=team[1];\n\t\t\tid=1;\n\t\t\tfor(int i=2;i<=N;i++){\n\t\t\t\tif(max<team[i]){\n\t\t\t\t\tmax=team[i];\n\t\t\t\t\tid=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tgap=L-now;\n\ttime[id]+=gap;\n\n\tmax=time[1];\n\tid=1;\n\tfor(int i=2;i<=N;i++){\n\t\tif(max<time[i]){\n\t\t\tmax=time[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\tcout<<id<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nint segt[400000];\nint depth=0;\nint best=0;\nvector<LL> mytime;\n\nint par(int i){\n  if(i==0)\n    return -1;\n  return (i-1)/2;\n}\n\nvoid update(int d,int x){\n  int i=d+(1<<depth)-1;\n  segt[i]+=x;\n  while(par(i)!=-1){\n    segt[par(i)]=max(segt[i],segt[(i+1)/2*4-1-i]);\n    i=par(i);\n  }\n  i=0;\n  while(i<(1<<depth)-1){\n    i=(segt[i]==segt[2*i+1])?2*i+1:2*i+2;\n  }\n  best=i-((1<<depth)-1);\n}\n\nint main(){\n  LL n,r,l;\n  cin >> n>>r>>l;\n\n  while((1<<depth)-1<n){\n    depth++;\n  }\n  REP(i,n)\n    mytime.push_back(0);\n\n  REP(i,1<<(depth+1)){\n    if(i<((1<<depth)-1)+n)\n      segt[i]=0;\n    else\n      segt[i]=-INT_MAX;\n  }\n\n  int d,x,t_prev,t_now=0;\n  REP(i,r){\n    t_prev=t_now;\n    cin>>d>>t_now>>x;\n    if(i==0)\n      mytime[0]+=t_now;\n    else\n      mytime[best]+=t_now-t_prev;\n    update(d-1,x);\n  }\n  mytime[best]+=l-t_now;\n  \n  cout<<1+distance(mytime.begin(),max_element(mytime.begin(),mytime.end()))<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[130625];\nstruct node {\n    int id, point;\n} node[1<<18];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst long long INF = 100000000000000;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i].first = -INF;\n\t\tteam[i].second = 100002;\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tif(team[k].first == -INF){\n\t\tteam[k].first = 0;\n\t\tteam[k].second = k - n + 1;\n \t}\n\telse\n\t\tteam[k].first += a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t    p[team[0].second] += (t - prev);\n\t\tprev = t;\n\t\tupdate(d - 1, x);\n\t}\n\tp[team[0].second] += (l - t);\n\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//AOJ0099とほぼ同じ。座標圧縮がいらない。\n//1位の見つけ方→1位が得点(順位そのまま),1位以外が得点(1位と得点したチームを比べる),1位以外が減点(順位そのまま),1位が減点(O(N)で1位を探す)\n//欠点：最悪計算量O(N^2)\n#include<iostream>\n#define rep(j,n) for(j = 0;j < n;j++)\nusing namespace std;\n\nint N,R,L;\t//チーム数 <= 10^5,レコード数 <= 10^6,競技時間\nint n[1000000],t[1000000],x[1000000];\n\nint score[100000];\nint Time[100000];\n\nint main(){\n\tint i,j;\n\tint num = 0;\t//今最高得点の奴の番号\n\tcin >> N >> R >> L;\n\trep(i,R){\n\t\tcin >> n[i] >> t[i] >> x[i];\n\t\tn[i]--;\n\t}\n\tTime[0] = t[0];\n\n\trep(i,R){\n\t\t//cout << \"num = \" << num << endl;\n\t\tscore[ n[i] ] += x[i];\n\t\t//1位がそのまま\n\t\tif( (n[i] == num && x[i] >= 0) || (n[i] != num && x[i] <= 0) ){\n\t\t\tif(i < R-1)\n\t\t\t\tTime[ num ] += t[i+1] - t[i];\n\t\t\telse\n\t\t\t\tTime[ num ] += L - t[i];\n\t\t\tcontinue;\n\t\t}\n\t\t//1位と今のチームを比べる\n\t\tif( n[i] != num && x[i] >= 0 ){\n\t\t\tif( ( score[ num ] > score[ n[i] ] ) || ( score[ num ] == score[ n[i] ] && num < n[i] ) ){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum = n[i];\n\t\t\t}\n\t\t\tif(i < R-1)\n\t\t\t\tTime[ num ] += t[i+1] - t[i];\n\t\t\telse\n\t\t\t\tTime[ num ] += L - t[i];\n\t\t\tcontinue;\n\t\t}\n\t\t//1位を調べなおす\n\t\tfor( j = 0; j < N; j++){\n\t\t\tif( ( score[ num ] > score[ j ] ) || ( score[ num ] == score[ j ] && num < j ) ){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum = j;\n\t\t\t}\n\t\t}\n\t\tif(i < R-1)\n\t\t\tTime[ num ] += t[i+1] - t[i];\n\t\telse\n\t\t\tTime[ num ] += L - t[i];\n\t}\n\tint MAX = 0,ANS = 0;\n\tfor(j = 0;j < N;j++){\n\t\tif(MAX < Time[j]){\n\t\t\tMAX = Time[j];\n\t\t\tANS = j;\n\t\t}\n\t}\n\tANS++;\n\tcout << ANS << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d-1+e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;scanf(\"%lld%lld%lld\",&x,&y,&z);\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -111111\n#define MAX 111111\ntypedef pair<int,int> P;\nint n;\nP dat[8*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[4*100012];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  \n  int d,t,x,top=0,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[top].first+=t-bt;\n    update(d,x);\n    top=dat[0].second;\n    bt=t;\n  }\n  tim[top].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[n+1];\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,0);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams+1);\n\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      seg_tree.insert(id,point);\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += time - prev_time;\n\tprev_time = time;\n\tprev_champ = team.id;\n      }\n    }\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\tif(nowN==-1){\n\t\tif(scr[n-1]>0)nowN=n-1;\n\t\telse if(n==0)nowN=1;\n\t\telse nowN=0;\n\t\t//else nowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\t}else if(n-1!=nowN){if(scr[n-1]>=scr[nowN]){\n\t\t\tif(scr[n-1]==scr[nowN])nowN=min(n-1,nowN);\n\t\t\telse nowN=n-1;}\n\t\t}else if(n-1==nowN){\n\t\t\tnowN=0;\n\t\t\trep(i,N)if(scr[i]>scr[nowN])nowN=i;\n\t\t\t//rep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\t}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>\n#define INF LLONG_MAX/3\nusing namespace std;\n\nP segment[500000];\nint point[100000];\nsigned main(){\n    int a,b,c;\n    cin>>a>>b>>c;\n    int d=1;\n    while(d<a)d*=2;\n    for(int e=0;e<d;e++){\n\tif(e<a)segment[d-1+e]=P(0,e);\n\telse segment[d-1-e]=P(INF,INF);\n\t}\n    d--;\t\n    for(int e=0;e<d;e++){\n\tsegment[e]=min(segment[e*2+1],segment[e*2+2]);\n\t}\n    int last=0,team=0;\n    for(int i=0;i<b;i++){\n\tint x,y,z;cin>>x>>y>>z;\n\tx--;\n\tint S=d+x;\n\tsegment[S].first-=z;\n\twhile(S>0){\n\t    S/=2;\n\t    segment[S]=min(segment[S*2+1],segment[S*2+2]);\n\t    }\n\tpoint[team]+=y-last;\n\t\tteam=segment[0].second;\n\tlast=y;\n\t}\n    point[team]+=c-last;\n    int n=-(INF),m=0;\t\n    for(int i=0;i<a;i++){if(point[i]>n){n=point[i];m=i+1;}}\n    cout<<m<<endl;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<cstring>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define INIT(a) memset(a,0,sizeof(a))\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1e9+7;\n\nint v;\nP seg[303000];\n\ninline void init(int n){\n  v = 1;\n  while(v<n)v<<=1;\n  rep(i,2*v-1)seg[i] = P(INF,INF);\n}\n\ninline void update(int x, P a){\n  x += v-1;\n  seg[x] = a;\n  while(x){\n    x = (x-1)>>1;\n    seg[x] = min(seg[2*x+1],seg[2*x+2]);\n  }\n}\n\ninline P query(int a, int b, int k ,int l, int r){\n  if(b<=l || r<=a)return P(INF,INF);\n  if(a<=l && r<=b)return seg[k];\n  P ql = query(a,b,2*k+1,l,(l+r)/2);\n  P qr = query(a,b,2*k+2,(l+r)/2,r);\n  return min(ql,qr);\n}\n\nint n,r,l;\nint d,t,x,prv=0;\nint len[100100];\n\nint main(){\n  INIT(len);\n  scanf(\"%d%d%d\",&n,&r,&l);\n  init(n);\n  rep(i,n)update(i,P(0,i));\n\n  rep(i,r){\n    scanf(\"%d%d%d\",&d,&t,&x);\n    P tmp = query(0,n,0,0,v);\n    len[tmp.sc] += t-prv;\n    prv = t;\n    update(d-1,P(seg[d-1 +v-1].fs-x,d-1));\n  }\n  len[query(0,n,0,0,v).sc] += l-prv;\n\n  int ans = 0;\n  rep(i,n){\n    if(len[ans] < len[i])ans = i;\n  }\n  printf(\"%d\\n\",ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"{\";\n    for (int i = 0; i < v.size(); ++i) {\n        if(i) os << \", \";\n        os << v[i];\n    }\n    return os << \"}\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"{\" << p.first << \", \" << p.second << \"}\";\n}\n\n\nint main() {\n    int n, r, l;\n    cin >> n >> r >> l;\n    vector<int> v(n);\n    set<pair<int, int>> s;\n    for (int i = 0; i < n; ++i) {\n        s.emplace(0, i);\n    }\n    int prv = 0;\n    vector<int> ans(n);\n    for (int i = 0; i < r; ++i) {\n        int d, t, x;\n        scanf(\"%d %d %d\", &d, &t, &x); d--;\n        auto M = s.begin();\n        ans[M->second] += (t-prv);\n        s.erase(s.find({v[d], d}));\n        v[d] -= x;\n        s.emplace(v[d], d);\n        prv = t;\n    }\n    auto M = s.begin();\n    ans[M->second] += (l-prv);\n    cout << max_element(ans.begin(),ans.end()) - ans.begin() + 1 << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n#include <math.h>\n#include <functional>\n\nint main(void) {\n  int i, j, k, n, t, r, be = 0, d, x, l;\n  scanf(\"%d%d%d\", &n, &r, &l);\n  int sn;\n  std::pair<int, int> seg[4 * n], to[n];\n  for(i = 0; i < n; ++i) to[i].first = 0, to[i].second = i;\n  if((int)log2(n) == log2(n)) sn = log2(n);\n  else sn = log2(n) + 1;\n  for(i = pow(2, sn); i < pow(2, sn) + n; ++i) \n    seg[i].first = 0, seg[i].second = i - pow(2, sn);\n  for(; i < pow(2, sn + 1); ++i) seg[i].first = 0, seg[i].second = 200000;\n  i = pow(2, sn - 1);\n  while(i) {\n    for(j = i; j < 2 * i; ++j) {\n      if(seg[j * 2] < seg[j * 2 + 1]) seg[j] = seg[j * 2];\n      else seg[j] = seg[j * 2 + 1];\n    }\n    i /= 2;\n  }\n  int pp = pow(2, sn);\n  for(i = 0; i < r; ++i) {\n    scanf(\"%d%d%d\", &d, &t, &x);\n    to[seg[1].second].first += t - be;\n    be = t;\n    d--;\n    seg[pp + d].first -= x;\n    int now = (pp + d) / 2;\n    while(now) {\n      if(seg[now * 2] < seg[now * 2 + 1]) seg[now] = seg[now * 2];\n      else seg[now] = seg[now * 2 + 1];\n      now /= 2;\n    }\n  }\n  to[seg[1].second].first += l - be;\n  std::sort(to, to + n, std::greater< std::pair<int, int> >());\n  printf(\"%d\\n\", to[0].second + 1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nstruct SegTree {\n\tint *dat;\n\tint *max_idx;\n\tint size;\n\tSegTree(int _size) {\n\t\tsize=1;\n\t\twhile(_size>size) size*=2;\n\t\tdat=(int*)malloc(sizeof(int)*size);\n\t\tmax_idx=(int*)malloc(sizeof(int)*(size*2-1));\n\t\tfor(int i=0;i<size;i++) {\n\t\t\tif(i<_size) dat[i]=0; else dat[i]=-(1<<30);\n\t\t}\n\t\tfor(int i=size*2-1;i>=0;i--) {\n\t\t\tif(i>=size) {\n\t\t\t\tmax_idx[i]=i-size;\n\t\t\t}else {\n\t\t\t\tmax_idx[i]=max_idx[i*2+1];\n\t\t\t}\n\t\t}\n\t}\n\tvoid update(int k,int a) {\n\t\tdat[k]+=a;\n\t\tk+=size-1;\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tif(dat[max_idx[k*2+1]]>=dat[max_idx[k*2+2]]) {\n\t\t\t\tmax_idx[k]=max_idx[k*2+1];\n\t\t\t}else {\n\t\t\t\tmax_idx[k]=max_idx[k*2+2];\n\t\t\t}\n\t\t}\n\t}\n};\nint Time[1000000];\nint main() {\n\tint N,R,L;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tSegTree S(N);\n\tint cur=0;\n\tfor(int i=0;i<R;i++) {\n\t\tint d,t,x;\n\t\tscanf(\"%d %d %d\",&d,&t,&x); d--;\n\t\tTime[S.max_idx[0]]+=t-cur;\n\t\tS.update(d,x);\n\t\tcur=t;\n\t}\n\tTime[S.max_idx[0]]+=L-cur;\n\tint max_time=0,max_id=0;\n\tfor(int i=0;i<N;i++) {\n\t\tif(Time[i]>max_time) {\n\t\t\tmax_time=Time[i];\n\t\t\tmax_id=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max_id+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define f first\n#define s second\n#define MAX_T 100005\nusing namespace std;\n\ntypedef pair<int, int> P;\nP teamp[MAX_T * 2 - 1];   //点数、チーム番号-1\nP teamt[MAX_T * 2 - 1]; //TVに映っている時間、チーム番号-1\nvoid tInit(int N);\nvoid updateP(int k, int a, int N);\nvoid updateT(int k, int a, int N);\n\nint main(){\n  int N, R, L;\n  int d, t, x;\n  int befd = 0;\n  int beft = 0;\n  cin >> N >> R >> L;\n  tInit(N);\n  for(int i = 0; i < R; i++){\n    cin >> d >> t >> x;\n    updateP(d - 1, x, N);\n    x = t - beft;\n    beft = t;\n    updateT(befd, x, N);\n    befd = teamp[0].s;\n  }\n  x = L - beft;\n  updateT(befd, x, N);\n  cout << teamt[0].s + 1 << endl;\n}\n\nvoid tInit(int N){\n  for(int i = 0; i < MAX_T * 2 - 1; i++){\n    teamp[i].f = 0;\n    teamt[i].f = 0;\n  }\n  for(int i = N - 1; i < MAX_T * 2 - 1; i++){\n    teamp[i].s = i - (N - 1);\n    teamt[i].s = i - (N - 1);\n  }\n  return;\n}\n\nvoid updateP(int k, int a, int N){\n  int w = k;\n  k += N - 1;\n  teamp[k].f += a;\n  teamp[k].s = w;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamp[k * 2 + 1].f >= teamp[k * 2 + 2].f){\n      teamp[k].f = teamp[k * 2 + 1].f;\n      teamp[k].s = teamp[k * 2 + 1].s;\n    }\n    else{\n      teamp[k].f = teamp[k * 2 + 2].f;\n      teamp[k].s = teamp[k * 2 + 2].s;\n    }\n  }\n  return;\n}\n\nvoid updateT(int k, int a, int N){\n  int w = k;\n  k += N - 1;\n  teamt[k].f += a;\n  teamt[k].s = w;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamt[k * 2 + 1].f >= teamt[k * 2 + 2].f){\n      teamt[k].f = teamt[k * 2 + 1].f;\n      teamt[k].s = teamt[k * 2 + 1].s;\n    }\n    else{\n      teamt[k].f = teamt[k * 2 + 2].f;\n      teamt[k].s = teamt[k * 2 + 2].s;\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[100001];\n\nint N, R, L, n;\n\npair<int, int> dat[400010];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m;\n  for(int i = 0; i < N; i++)\n  {\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    update(d, make_pair(dat[d + (n - 1)].first + x, dat[d + (n - 1)].second));\n    if(i != R - 1) \n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef std::pair<ll,int> P;\n\nconst ll INF = 1001001001001001001;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nconst int MAX_N = 100000, MAX_R = 1000000;\n\nclass SegmentTree{\npublic:\n    SegmentTree(){}\n    SegmentTree(int n){init(n);}\n    void init(int n){\n        size = 1;\n        while(size < n){\n            size *= 2;\n        }\n        REP(i, size*2-1){\n            seg1[i] = -INF;\n            seg2[i] = -1;\n        }\n    }\n    void update(int index, int v){\n        index += size - 1;\n        seg1[index] += v;\n        seg2[index] = index - (size-1);\n        while(index > 0){\n            index = (index-1)/2;\n            //std::cout << index << \",\" << seg1[index*2+1] << \",\" << seg1[index*2+2] << std::endl;\n            if(seg1[index*2+1] >= seg1[index*2+2]){\n                seg1[index] = seg1[index*2+1];\n                seg2[index] = seg2[index*2+1];\n            }else{\n                seg1[index] = seg1[index*2+2];\n                seg2[index] = seg2[index*2+2];\n                //std::cout << seg2[index] << std::endl;\n            }\n        }\n    }\n    P root(){\n        return mp(seg1[0], seg2[0]);\n    }\nprivate:\n    ll seg1[MAX_N*4];\n    int seg2[MAX_N*4];\n    int size;\n};\n\nstruct Record{\n    int d, t, x;\n};\n\nint N, R, L;\nRecord rs[MAX_R];\nSegmentTree st;\n\nint main(){\n    std::cin >> N >> R >> L;\n    st.init(N);\n    REP(i, R){\n        std::cin >> rs[i].d >> rs[i].t >> rs[i].x;\n        rs[i].d--;\n    }\n\n    int ts[MAX_N];\n    std::fill(ts, ts+N, 0);\n\n    if(R > 0){\n        REP(i, N){\n            st.update(i, 0);\n        }\n\n        int prev = rs[0].t;\n        st.update(rs[0].d, rs[0].x);\n        FOR(i, 1, R){\n            if(i+1 >= R || rs[i].t < rs[i+1].t){\n                //printf(\"wa-i: %d +%d\\n\", st.root().second, rs[i].t - prev);\n                ts[st.root().second] += rs[i].t - prev;\n            }\n            st.update(rs[i].d, rs[i].x);\n            prev = rs[i].t;\n        }\n        ts[st.root().second] += L - prev;\n    }\n\n    int max_team = 0, max_t = -1;\n    REP(i, N){\n        if(ts[i] > max_t){\n            max_team = i+1;\n            max_t = ts[i];\n        }\n    }   \n\n    //std::cout << max_t << std::endl;\n    std::cout << max_team << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\tif(i == 0)\n\t\t\ttt[1] = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = 0;\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t}\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t\t//printf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"MDebug.h\"\n#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#include <conio.h>\nusing namespace std;\n\nstatic const int MAX_N = 1000001;\n\nint T_Time[MAX_N], Score[MAX_N];\n\nint main()\n{\n\n\tint N, R, L, d, t, x, most, P_T = 0, P_D = 1;\n\tpriority_queue< pair< int, int > > ScoreHeap;\n\n\tmemset( Score , 0, sizeof( Score ) );\n\tmemset( T_Time, 0, sizeof( T_Time ) );\n\n\tcin >> N >> R >> L;\n\n\tfor( int i = 0; i < R; i++ ) {\n\n\t\tcin >> d >> t >> x;\n\t\tScore[d] += x;\n\n\t\tScoreHeap.push( make_pair( Score[d], -d ) );\n\n\t\twhile( true ) {\n\n\t\t\tpair< int, int > temp = ScoreHeap.top();\n\t\t\tif( temp.first == Score[-temp.second] ) {\n\n\t\t\t\tT_Time[P_D] += t - P_T;\n\t\t\t\tP_D = -temp.second;\n\t\t\t\tP_T = t;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tScoreHeap.pop();\n\n\t\t}\n\n\t}\n\n\tT_Time[P_D] += L - P_T;\n\n\tfor( int i = 1; i <= N - 1; i++ ) {\n\n\t\tif( T_Time[i] == T_Time[i + 1] ) most = i;\n\t\telse if( T_Time[i] < T_Time[i + 1] ) most = i + 1;\n\t\telse most = i;\n\n\t}\n\n\tcout << most << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n];\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,0);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams+1);\n\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      seg_tree.insert(id,point);\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += time - prev_time;\n\tprev_time = time;\n\tprev_champ = team.id;\n      }\n    }\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 0;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * 100001];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -1000000);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n    team[k] = P(a, -k);\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[2 * 100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[(-team[0].second) + n - 1] += (t - prev);\n\t\tupdate(d - 1, team[n + d - 1].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[(-team[0].second) + n - 1] += (l - t);\n\t\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint P[100000],T[100000];\nint main() {\n    int N,R,L,PT=1,n1=0,p1=0;\n    scanf(\"%d %d %d\",&N,&R,&L);\n    for(int i=0;i<R;i++) {\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x); d--;\n        P[d]+=x;\n        if(x>0) {\n            if(P[d]>p1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=d;\n                p1=P[d];\n            }\n        }\n        if(x<0) {\n            if(d!=n1) continue;\n            int n2=n1,p2=P[d];\n            for(int j=N-1;j>=0;j--) {\n                if(p2<=P[j]) {n2=j,p2=P[j];}\n            }\n            if(n2!=n1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=n2;\n                p1=p2;\n            }\n        }\n    }\n    T[n1]+=L-PT+1;\n    int ans_n=0,ans_t=0;\n    for(int i=0;i<N;i++) {\n        if(ans_t<T[i]) {\n            ans_t=T[i];\n            ans_n=i;\n        }\n    }\n    printf(\"%d\\n\",ans_n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\nconst int MAX_N = 1<<20;\n\nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = -INF;\n        dat[i].se = -(i-n+1);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(-INF, n-1);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nvector<pii> q[1000010];\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\trep(i, n) update(i, INF);\n\tvi v(n, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tq[t].pb(pii(d-1, x));\n\t\t//p = query(0, n, 0, 0, n);\n\t\t//cout<<-p.se<<endl;\n\t\t// v[-p.se] = t-tt;\n\t\t// tt = t;\n\t\t// update(d-1, x);\n\t}\n\trep(i, 1000010){\n\t\trep(j, q[i].size()){\n\t\t\tupdate(q[i][j].fi, q[i][j].se);\n\t\t}\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se]++;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] = l-tt;\n\tint ans = 0;\n\tfor(int i = 1; i < v.size(); i++){\n\t\tif(v[ans] < v[i]) ans = i;\n\t}\n\tcout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct team{\n    long long n,p,time;\n};\n\nstruct re{\n    int d,x;\n    long long t;\n};\n\nbool operator<(const team& t1,const team& t2){\n    if(t1.p==t2.p){\n        return t1.n > t2.n;\n    }\n    return t1.p < t2.p;\n}\n\nbool operator<(const re& r1,const re& r2){\n    return r1.t < r2.t;\n}\n\npriority_queue<team> q;\nre rec[1000001];\nteam tea[100001];\n\nint main() {\n\n    long long n,r,l;\n\n    cin >> n >> r >> l;\n\n\n\n    for(int i=0;i<r;i++){\n        cin >> rec[i].d >> rec[i].t >> rec[i].x;\n    }\n\n    sort(rec,rec+r);\n\n    /*for(int i=0;i<r;i++){\n        cout << rec[i].d << \" \" << rec[i].t << \" \" << rec[i].x << endl;\n    }*/\n\n    for(int i=1;i<=n;i++){\n        tea[i].n = i;\n        tea[i].p = 0;\n        tea[i].time = 0;\n        q.push(tea[i]);\n    }\n    /*while (!q.empty()) {\n        cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n        q.pop();\n    }*/\n    /*for(int i=0;i<=n;i++){\n        cout << tea[i].n << \" \" <<  tea[i].p << \" \" << tea[i].time << endl;\n    }*/\n\n\n\n    tea[ rec[0].d ].p += rec[0].x;\n    //cout << \"point is  \" << tea[ rec[0].d].p << endl;\n    q.push(tea[rec[0].d]);\n    team tmp = q.top(); //q.pop();\n    //cout << tmp.n <<\" \" << tmp.p << \" \" << tmp.time << endl;\n    tea[tmp.n].time += rec[0].t;\n    //q.push(tea[tmp.n]);\n\n//cout << endl;\n /*   while (!q.empty()) {\n        tmp = q.top();\n        cout << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n        cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n        cout << endl;\n        q.pop();\n    }*/\n\n    for(int i=1;i<r-1;i++){\n        tea[ rec[i].d ].p += rec[i].x;\n        q.push(tea[rec[i].d]);\n        tmp = q.top(); //q.pop();\n        //cout << i << \" \" << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n        if(rec[i+1].t != rec[i].t) {\n            tea[tmp.n].time += rec[i + 1].t - rec[i].t;\n            //q.push(tea[tmp.n]);\n        }\n    }\n\n    tea[ rec[r-1].d ].p = rec[r-1].x;\n    q.push(tea[rec[0].d]);\n    tmp = q.top(); //q.pop();\n    //cout << tmp.n << tmp.p << tmp.time << endl;\n    tea[tmp.n].time += l - rec[r-1].t;\n    //q.push(tea[tmp.n]);\n\n    /*while (!q.empty()) {\n       tmp = q.top();\n       cout << tmp.n << \" \" << tmp.p << \" \" << tmp.time << endl;\n       cout << q.top().n << \" \" << q.top().p << \" \" << q.top().time << endl;\n       cout << endl;\n       q.pop();\n   }*/\n\n\n    /*for(int i=0;i<=n;i++){\n        cout << tea[i].time << endl;\n    }*/\n\n\n    int ans=1;\n\n    for(int i=2;i<=n;i++){\n        ans = tea[i].time > tea[ans].time ? i : ans;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<cstring>\n#define N (1<<17)\n\nusing namespace std;\ntypedef long long ll;\nll dat[1<<18];\nint id[1<<18];\nint n,r,l;\nint d[1000001],t[1000001],x[1000001];\nint timel[100001];\n\nvoid init(){\n\tmemset(dat,0,sizeof(dat));\n\tfor(int i=N;i<N*2;i++)id[i]=i-N;\n}\n\nvoid update(int k,ll a){\n\tk+=N-1;\n\tdat[k]+=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tif(dat[k*2+1]>=dat[k*2+2]){\n\t\t\tdat[k]=dat[k*2+1];\n\t\t\tid[k]=id[k*2+1];\n\t\t}else{\n\t\t\tdat[k]=dat[k*2+2];\n\t\t\tid[k]=id[k*2+2];\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(int i=0;i<r;i++)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\tint nt=0;\n\tinit();\n\tfor(int i=0;i<r;i++){\n\t\ttimel[id[0]]+=t[i]-nt;\n\t\tnt=t[i];\n\t\tupdate(d[i],x[i]);\n\t}\n\ttimel[id[0]]+=l-nt;\n\tint sum=0,rid=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(sum<timel[i])sum=timel[i],rid=i;\n\t}\n\tprintf(\"%d\\n\",rid+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tttime[1] = 100;\n\tint pret = 0, pred = 1;\n\tpriority_queue<pair<int,int> > q;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tq.push(make_pair(tpoint[d], -d));\n\t\twhile (1){\n\t\t\tpair<int, int> p = q.top();\n\t\t\tif (p.first == tpoint[-p.second]){\n\t\t\t\tttime[pred] += t - pret;\n\t\t\t\tpred = -p.second;\n\t\t\t\tpret = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint main()\n{\n\tint n,r,l,ans[100000]={},score[100000]={};\n\tcin>>n>>r>>l;\n\tint last=0;\n\tint m=0;//????????£????????§?????????????????£?????????????????????ID\n\tfor(int i=0;i<r;i++){\n\t\tint d,t,x;\n\t\tcin>>d>>t>>x;\n\t\tscore[--d]+=x;\n\t\tif(x>=0&&m!=d){\n\t\t\tif(score[d]>score[m]||((score[d]==score[m])&&d<m)){\n\t\t\t\tans[m]+=t-last;\n\t\t\t\tlast=t;\n\t\t\t\tm=d;\n\t\t\t}\n\t\t}else if(m==d){\n\t\t\tint tmp=m;\n\t\t\tfor(int j=0;j<n;j++)if(score[j]>score[m]||((score[j]==score[m])&&j<m))tmp=j;\n\t\t\tif(m!=tmp){\n\t\t\t\tans[m]+=t-last;\n\t\t\t\tlast=t;\n\t\t\t\tm=tmp;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tans[m]+=l-last;\n\tint res1=0,res2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(res1<ans[i]){\n\t\t\tres1=ans[i];\n\t\t\tres2=i;\n\t\t}\n\t}\n\tres2++;\n\tcout<<res2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#include<iostream>\n#include<string.h>\nusing namespace std;\n#define WHITE 0\n#define GLAY 1\n#define BLACK 2\n#define INF 9999\nint kingaku(void);\nint saitan(void);\nint n,m,p,q;\nint cost[101][101],timev[101][101];\nint main()\n{\n\tint a,b,c,t,k,r;\n\twhile(1){\n\t\tmemset(cost,INF,sizeof(cost));\n\t\tmemset(timev,INF,sizeof(timev));\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0) break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> a >> b >> c >> t;\n\t\t\tcost[a][b] = cost[b][a] = c;\n\t\t\ttimev[a][b] = timev[b][a] = t;\n\t\t}\n\t\tcin >> k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin >> p >> q >> r;\n\t\t\tif(r==0){\n\t\t\t\tcout << kingaku() << endl;\n\t\t\t}\n\t\t\telse if(r==1)\n\t\t\t\tcout << saitan() << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint kingaku()\n{\n\tint minv;\n\tint dd[101],color[101];\n\n\tfor(int i=0;i<=n;i++){\n\t\tdd[i] = INF;\n\t\tcolor[i] = WHITE;\n\t}\n\tdd[p] = 0;\n\tcolor[p] = GLAY;\n\twhile(1){\n\t\tminv = INF;\n\t\tint u = -1;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tif(minv > dd[i] && color[i] != BLACK ){\n\t\t\t\tu = i;\n\t\t\t\tminv = dd[i];\n\t\t\t}\n\t\t}\n\t\tif(u == -1) break;\n\t\tcolor[u] = BLACK;\n\t\tfor(int v=1;v<=m ;v++){\n\t\t\tif(color[v] != BLACK && cost[u][v] != INF){\n\t\t\t\tif(dd[v] > dd[u] + cost[u][v]){\t\n\t\t\t\t\tdd[v] = dd[u] + cost[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<n;i++) cout << dd[i] << endl;\n\treturn dd[q];\n}\n\nint saitan()\n{\n\tint minv;\n\tint dd[101],color[101];\n\n\tfor(int i=0;i<=n;i++){\n\t\tdd[i] = INF;\n\t\tcolor[i] = WHITE;\n\t}\n\tdd[p] = 0;\n\tcolor[p] = GLAY;\n\twhile(1){\n\t\tminv = INF;\n\t\tint u = -1;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tif(minv > dd[i] && color[i] != BLACK ){\n\t\t\t\tu = i;\n\t\t\t\tminv = dd[i];\n\t\t\t}\n\t\t}\n\t\tif(u == -1) break;\n\t\tcolor[u] = BLACK;\n\t\tfor(int v=1;v<=m;v++){\n\t\t\tif(color[v] != BLACK && timev[u][v] != INF){\n\t\t\t\tif(dd[v] > dd[u] + timev[u][v]){\t//d[v]:??????\n\t\t\t\t\tdd[v] = dd[u] + timev[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//for(int i=0;i<n;i++) cout << dd[i] << endl;\n\treturn dd[q];\n}\n*/\n/*#include<iostream>\n#include<queue>\nusing namespace std;\n\npriority_queue< pair<int,int> > PQ;\nint main()\n{\n\tpair<int,int> S;\n\tS.first = 10;\n\tS.second = 20;\n\tPQ.push(S);\n\tS.first = 20;\n\tS.second= 30;\n\tPQ.push(S);\n\tcout << PQ.top().first << endl;\n}*/\n\n#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<queue>\nusing namespace std;\npriority_queue< pair<int,int> > PQ;\t//time,team\nint tp[100001],tt[100001];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0;\n\tpair<int,int> data;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\tdata.first = tt[Flag];\n\t\tdata.second = Flag;\n\t\tPQ.push(data);\n\t\ttp[d] = tp[d] + x;\n\t\tmax = tp[1];\n\t\tFlag = 1;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=2;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - time );//L - t\n\tdata.first = tt[Flag];\n\tdata.second = Flag;\n\tPQ.push(data);\n\t//for(int i=1;i<=N;i++)\n\t\t//printf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",PQ.top().second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,r,l;\nint d[100001],t[100001],x[1000001];\nint i,j,flg,Max,Min;\nint a[1000001]={0},b[1000001]={0};\nint main(void)\n{\n\t\n\tcin>>n>>r>>l;\n\t\t\n\tflg=0;\n\tfor(i=1;i<=r;i++){\n\t\tcin>>d[i]>>t[i]>>x[i];\n\t\tif(x[i]<0){\n\t\t\tflg=1,b[d[i]]=x[i],x[i]=0;\n\t\t}\t\n\t}\n\t\n\tif(flg==0){\n\t\tfor(j=r;j>0;j--){\n\t\t\tif(j==r) a[n]+=l-t[r],b[n]+=x[r];\n\t\t\tif(j+1<=r){\n\t\t\t\ta[d[j]]+=t[j+1]-t[j],b[d[j]]+=x[j];\n\t\t\t}\t\n\t\t}\n\t}\t\t\n\n\tif(flg==1){\n\t\tfor(j=0;j<r;j++){\n\t\t\tif(j+1<=r){\n\t\t\t\tb[d[j]]+=x[j];\n\t\t\t}\t\n\t\t}\n\t}\n\t\n\tMax=-1,Min=1000010;\n\tfor(i=1;i<=n;i++){\n\t\tif(Max<a[i]&&Min>i) Min=i;\n\t}\n\tcout<<Min<<endl;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <queue>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<LL, int> P;\nconst LL INF = 2 << 60;\n \nconst int MAX_N = 262144;\nP dat[MAX_N * 2 - 1];\nLL times[MAX_N];\n \nint n, r, l;\n \nvoid init()\n{\n    for (int i = 0; i < 2 * n - 1; i++)\n    {\n        dat[i] = P(0, -(2 << 20));\n    }\n    for (int i = 0; i < n; i++)\n    {\n        dat[n + i - 1].second = -i;\n    }\n}\n \nvoid update(int i, LL x)\n{\n    i += n - 1;\n    dat[i].first += x;\n    while (i > 0)\n    {\n        i = (i - 1) / 2;\n        dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n}\n \nP query(int a, int b, int k, int l, int r)\n{\n    if(r <= a || b <= l) return P(-INF, -1);\n    if(a <= l && r <= b) return dat[k];\n    else\n    {\n        P vl = query(a, b,k * 2 + 1, l, (l + r) / 2);\n        P vr = query(a, b,k * 2 + 1, (l + r) / 2, r);\n        if(vr > vl) return vr;\n        return vl;\n    }\n}\n \nint main(void)\n{\n    while(cin >> n >> r >> l && n >= 2)\n    {\n        vector<int> d(r), x(r), t(r);\n        for (int i = 0; i < r; i++)\n        {\n            cin >> d[i] >> x[i] >> t[i];\n            d[i]--;\n        }\n        init();\n        memset(times, 0, sizeof(times));\n        P pre = P(0,0);\n        int pret = 0;\n        for (int i = 0; i < r; i++)\n        {\n            if(i + 1 < r && t[i] == t[i + 1])\n            {\n                update(d[i], x[i]);\n                i++;\n                continue;\n            }\n            update(d[i], x[i]);\n            P p = query(0, n-1, 0, 0, n);\n            times[-pre.second] += (t[i] - pret);\n            pret = t[i];\n            pre = p;\n        }\n        cout << (max_element(times, times + n) - times) + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\nusing namespace std;\n#define MAX 1111111\n#define MIN -1111111\ntypedef pair<int,int> P;\nvoid init(int n);\nvoid update(int k,int x);\nP maxx(int k1,int k2);\nP dat[2*100000];\nint tim[100001]={0};\nint N;\n\nint main(){\n  int R,L;\n  cin >> N >> R >> L;\n  int n_tmp = N;\n  init(N);\n  memset(tim,0,n_tmp+1);\n  int now = 0;\n  dat[0]=P(MIN,1);\n  for(int i=0;i<R;i++){\n    int d,t,x;\n    cin >> d >> t >> x;\n    tim[dat[0].second] += t - now;\n    update(d,x);\n    now = t;\n  }\n  tim[dat[0].second] += L - now;\n  int *ans = max_element(tim,tim+n_tmp+1);\n  cout << ans - tim << endl;\n}\n\nvoid init(int n){\n  N=1;\n  while(N<n) N*=2;\n  for(int i=0;i<2*N-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n  for(int i=N-1;i<N-1+n;i++){\n    dat[i]=P(0,i-(N-2));\n  }\n  return;\n}\n\nvoid update(int k,int x){\n  k += N - 2;\n  //cout << k << \" \" << x << endl;\n  P p = dat[k];\n  int score = p.first;\n  int team = p.second;\n  cout << score << \" \" << team << endl;\n  dat[k] = P(score+x,team);\n  while(k > 0){\n    k = (k - 1) / 2;\n    dat[k] = maxx(k*2+1,k*2+2);\n    //cout << dat[k].first << \" \" << dat[k].second << endl;\n  }\n  return;\n}\n\nP maxx(int k1,int k2){\n  P p;\n  if(dat[k1].first == dat[k2].first){\n    p = P(dat[k1].first,min(dat[k1].second,dat[k2].second));\n  }\n  else {\n    p = max(dat[k1],dat[k2]);\n  }\n  return p;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n,m,l;\n\tcin>>n>>m>>l;\n\tvi sum(n);\n\tvi sc(n);\n\tint ma=0,mai=0;\n\tint t=0;\n\tint a,b,c;\n\twhile(m--){\n\t\tcin>>a>>b>>c;\n\t\tsum[mai]+=b-t;\n\t\tt=b;\n\t\tsc[a-1]+=c;\n\t\tif(c<0){\n\t\t\tma=-inf;mai=inf;\n\t\t\trep(i,n)if(ma<sc[i]){\n\t\t\t\tif(ma==sc[i])mai=min(mai,i);\n\t\t\t\telse mai=i;\n\t\t\t\tma=sc[i];\n\t\t\t}\n\t\t}else{\n\t\t\tif(sc[a-1]>ma){\n\t\t\t\tma=sc[a-1];mai=a-1;\n\t\t\t}else if(sc[a-1]==ma)mai=min(mai,a-1);\n\t\t}\n\t}\n\tsum[mai]+=l-b;\n\tma=0;\n\trep(i,n)if(ma<sum[i]){\n\t\tif(ma==sum[i])mai=min(mai,i);\n\t\telse mai=i;\n\t\tma=sum[i];\n\t}\n\tcout<<mai+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n#define int long long\n\nsigned main(){\n    int N, R, L;\n    while(cin >> N >> R >> L && N){\n        const int B = sqrt(N);\n        vector<int> bucket((N - 1) / B + 1);\n        vector<int> point(N + B, INT_MIN);\n        REP(i, N) point[i] = 0;\n        int last_time = 0;\n        int camera_id = 0;\n        vector<int> answer(N + B);\n        for(int i = 0; i < R; i++){\n            int d, t, x;\n            cin >> d >> t >> x;\n            //scanf(\"%d %d %d\", &d, &t, &x);\n            d--;\n            point[d] += x;\n            if(point[d] > bucket[d / B]){\n                bucket[d / B] = point[d];\n            }else if(point[d] - x == bucket[d / B]){\n                bucket[d / B] = *max_element(point.begin() + (d / B) * B, point.begin() + (d / B + 1) * B);\n            }\n            answer[camera_id] += t - last_time;\n            last_time = t;\n            if(camera_id == d && x < 0){\n                int k = max_element(bucket.begin(), bucket.end()) - bucket.begin();\n                camera_id = max_element(point.begin() + k * B, point.begin() + (k + 1) * B) - point.begin();\n            }else if(point[d] > point[camera_id]){\n                camera_id = d;\n            }\n            //REP(i, N) cout << point[i] << \" \"; cout << endl;\n            //REP(i, (N - 1) / B + 1) cout << bucket[i] << \" \"; cout << endl;\n            //printf(\"time:%d point[%d] += %d camera: %d\\n\", t, d + 1, x, camera_id + 1);\n        }\n        answer[camera_id] += L - last_time;\n        cout << max_element(answer.begin(), answer.end()) - answer.begin() + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#define f first\n#define s second\n#define MAX_T 100005\n#define INF 214748300\nusing namespace std;\n\ntypedef pair<int, int> P;\nP teamp[MAX_T * 2 - 1];\nP teamt[MAX_T * 2 - 1];\nvoid init(int n);\nvoid updateP(int k, int a, int n);\nvoid updateT(int k, int a, int n);\n\nint main(){\n  int N, R, L;\n  int d, t, x;\n  int befd = 0, beft = 0, nt, n = 1;\n  cin >> N >> R >> L;\n  while(n < N) n *= 2;\n  init(n);\n  for(int i = 0; i < R; i++){\n    cin >> d >> t >> x;\n    updateP(d - 1, x, n);\n    nt = t - beft;\n    beft = t;\n    updateT(befd, nt, n);\n    befd = teamp[0].s;\n  }\n  nt = L - beft;\n  updateT(befd, nt, n);\n  cout << teamt[0].s + 1 << endl;\n}\n\nvoid init(int n){\n  for(int i = 0; i < n * 2 - 1; i++){\n    teamp[i].f = 0;\n    teamt[i].f = 0;\n  }\n  for(int i = n - 1; i < n * 2 - 1; i++){\n    teamp[i].s = i - (n - 1);\n    teamt[i].s = i - (n - 1);\n  }\n  return;\n}\n\nvoid updateP(int k, int a, int n){\n  k += n - 1;\n  teamp[k].f += a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamp[k * 2 + 1].f >= teamp[k * 2 + 2].f){\n      teamp[k].f = teamp[k * 2 + 1].f;\n      teamp[k].s = teamp[k * 2 + 1].s;\n    }\n    else{\n      teamp[k].f = teamp[k * 2 + 2].f;\n      teamp[k].s = teamp[k * 2 + 2].s;\n    }\n  }\n  return;\n}\n\nvoid updateT(int k, int a, int n){\n  k += n - 1;\n  teamt[k].f += a;\n  while(k > 0){\n    k = (k - 1) / 2;\n    if(teamt[k * 2 + 1].f >= teamt[k * 2 + 2].f){\n      teamt[k].f = teamt[k * 2 + 1].f;\n      teamt[k].s = teamt[k * 2 + 1].s;\n    }\n    else{\n      teamt[k].f = teamt[k * 2 + 2].f;\n      teamt[k].s = teamt[k * 2 + 2].s;\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Point {\n  int x,y;\n  bool operator < (const Point& p) const {\n    if( y != p.y ) return y < p.y;\n    return x > p.x;\n  }\n};\nostream& operator << (ostream& os,const Point& p) {\n  os << p.x/* <<\" \"<< p.y*/;\n}\n\nint score[100001];\nint t[1000000];\nint time_[1000000];\nint main(){\n  priority_queue<Point> Q;\n  priority_queue<Point> T;\n  int N,R,L;\n  int d,x;\n  int a=1,b=0;\n\n  cin >>N>>R>>L;\n\n\n  for(int i=0;i<R;i++){\n    cin >>d>>t[i]>>x;    \n    score[d]+=x;\n    Q.push((Point){d,score[d]});  \n \n    while(!Q.empty() && score[Q.top().x] != Q.top().y){\n      Q.pop();\n    }\n    time_[a]+=t[i]-b; \n    T.push((Point){a,time_[a]});\n    a=Q.top().x;\n    b=t[i];\n    \n    \n  }\n  \n  while( !Q.empty() && score[Q.top().x] != Q.top().y){\n    Q.pop();\n  }\n  time_[a]+=L-b;\n  if( !Q.empty() ) a=Q.top().x;\n  else a = 1;\n  b=L;\n  T.push((Point){a,time_[a]});\n \n  cout <<T.top()<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\nconst int MAX_N = 1<<17;\ntypedef pair<int,int> pii;\n\nclass RMQ{\npublic:\n  int n;\n  pii dat[2*MAX_N-1];\n\n  void init(int n_){\n    n = 1;\n    while(n < n_){ n *= 2; }\n    for(int i = 0 ; i < 2*n-1 ; i++){\n      dat[i] = pii(-INF,-INF);\n    }\n    for(int i = 0 ; i < n_ ; i++){\n      update(i,0);\n    }\n  }\n\n  void update(int k,int a){\n    int tk = k;\n    k += n - 1;\n    dat[k] = pii(a,-tk);\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n\n  pii query(int a,int b,int k,int l,int r){\n    if(r <= a || b <= l){ return pii(-INF,-INF); }\n    if(a <= l && r <= b){\n      return dat[k];\n    }else{\n      pii vl = query(a,b,k*2+1,l,(l+r)/2);\n      pii vr = query(a,b,k*2+2,(l+r)/2,r);\n      return max(vl,vr);\n    }\n  }\n};\n\nint main(){\n  int N,R,L;\n  RMQ rmq;\n  cin >> N >> R >> L;\n  rmq.init(N);\n  int d,t,x,pt = 0;\n  vector<int> point(N,0);\n  for(int i = 0 ; i < R ; i++){\n    cin >> d >> t >> x; d--;\n    point[-rmq.query(0,N,0,0,rmq.n).second] = t-pt;\n    rmq.update(d,x+rmq.dat[d+rmq.n-1].first);\n    pt = t;\n  }\n    point[-rmq.query(0,N,0,0,rmq.n).second] = L-pt;\n  int res = -1, max = -INF;\n  for(int i = 0 ; i < N ; i++){\n    if(max < point[i]){\n      max = point[i];\n      res = i+1;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += (t-oldt);\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n    }else old = max(pt,N);\n  }\n  ptime[old] += (L-oldt);\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\nusing namespace std ;\n\nint num[2][262144] = {} ; // 0 point , 1 num\nint ranking[100001] = {} ;\nint n , r , l ;\nint d , t , x ;\nint btd , bt , sum1=-1 , sum2=0 ;\n\nvoid count( int p ){\n\t\n\tif( num[0][p*2] >= num[0][p*2+1] ){\n\t\tnum[0][p] = num[0][p*2] ;\n\t\tnum[1][p] = num[1][p*2] ;\n\t}else {\n\t\tnum[0][p] = num[0][p*2+1] ;\n\t\tnum[1][p] = num[1][p*2+1] ;\n\t}\n\t\n\tif( p!=1 ) count( p/2 ) ;\n}\n\nint main(){\n\t\n\tcin >> n >> r >> l ;\n\t\n\tfor( int i=1 ; i<=n ; i++ ){\n\t\tnum[1][i+131071] = i ;\n\t}\n\t\n\tfor( int i=0 ; i<r ; i++ ){\n\t\tcin >> d >> t >> x ;\n\t\tnum[0][d+131071] += x ;\n\t\t\n\t\tcount( ( d+131071 ) / 2 ) ;\n\t\t\n\t\tif( i != 0 ) ranking[btd] = t-bt ;\n\t\tbt = t ;\n\t\tbtd = num[1][1] ;\n\t}\n\t\n\tranking[btd] = l-bt ;\n\t\n\tfor( int i=1 ; i<=n ; i++ ){\n\t\tif( sum1 < ranking[i] ){\n\t\t\tsum1 = ranking[i] ;\n\t\t\tsum2 = i ;\n\t\t}\n\t}\n\tcout << sum2 << endl ;\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint P[100000],T[100000];\nint main() {\n    int N,R,L,PT=1,n1=0,p1=0;\n    scanf(\"%d %d %d\",&N,&R,&L);\n    for(int i=0;i<R;i++) {\n        int d,t,x;\n        scanf(\"%d %d %d\",&d,&t,&x); d--;\n        P[d]+=x;\n        if(x>0) {\n            if(P[d]>p1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=d;\n                p1=P[d];\n            }\n        }\n        if(x<0) {\n            if(d!=n1) continue;\n            int n2=n1,p2=P[d];\n            for(int j=N-1;j>=0;j--) {\n                if(p2<P[j]) {n2=j,p2=P[j];}\n            }\n            if(n2!=n1) {\n                T[n1]+=t-PT+1;\n                PT=t;\n                n1=n2;\n                p1=p2;\n            }\n        }\n    }\n    T[n1]+=L-PT+1;\n    int ans_n=0,ans_t=0;\n    for(int i=0;i<N;i++) {\n        if(ans_t<T[i]) {\n            ans_t=T[i];\n            ans_n=i;\n        }\n    }\n    printf(\"%d\\n\",ans_n+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nconst int INF = (1<<31)-1, MAX_N = 1<<17;\n\nint sz, dat[2*MAX_N-1];\n\nvoid init( int n_ )\n{\n\tsz = 1;\n\twhile( sz < n_ )\n\t\tsz <<= 1;\n\n\trep( i, 2*sz-1 )\n\t\tdat[i] = INF;\n\n\treturn;\n}\n\nvoid update( int k, int x )\n{\n\tk += sz-1;\n\tdat[k] = x;\n\twhile( k > 0 )\n\t{\n\t\tk = (k-1)>>1;\n\t\tdat[k] = std::min( dat[2*k+1], dat[2*k+2] );\n\t}\n\n\treturn;\n}\n\nint query( int a, int b, int k, int l, int r )\n{\n\tif( r <= a || b <= l )\n\t\treturn INF;\n\n\tif( a <= l && r <= b )\n\t\treturn dat[k];\n\telse\n\t\treturn std::min( query( a, b, 2*k+1, l, (l+r)>>1 ), query( a, b, 2*k+2, (l+r)>>1, r ) );\n}\n\n\nint main()\n{\n\tint n, q;\n\tscanf( \"%d%d\", &n, &q );\n\t\n\tinit( n );\n\t\n\trep( i, q )\n\t{\n\t\tchar com[2];\n\t\tint x, y;\n\n\t\tscanf( \"%s%d%d\", com, &x, &y );\n\n\t\tif( com[0] == '0' )\n\t\t\tupdate( x, y );\n\t\telse\n\t\t\tprintf( \"%d\\n\", query( x, y+1, 0, 0, sz ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint main(){\n\n int N,R,L;\n int INF = 1e9;\n\n cin >> N >> R >> L;\n\n\n pair <int,int>  score[200005];\n int time[100005];\n for(int i=1;i<200005;i++)score[i]=make_pair(INF,-1);\n int id[200005] = {};\n for(int i=1;i<=N;i++) {\n   score[i]=make_pair(0,i);\n   id[i] = i;\n   time[i] = 0;\n }\n \n int  mae = 0;\n \n int d,t,x;\n for(int i=0;i<R;i++) {\n   cin >> d >> t >> x;\n\n int site1 = id[d];\n   assert(site1>=1);\n   \n   time[score[1].second] += t - mae;\n   score[site1].first -= x;\n   mae = t;\n\n   if(x>0){ \n     while(site1>1) {\n       if(score[site1] < score[site1/2] ) {\n\t swap(score[site1], score[site1/2]);\n\t swap(id[site1],id[site1/2]);\n\t site1 = site1/2;\n       } else break;\n     }\n   }\n   else {\n     while(2*site1+1<= N) {\n       if( score[2*site1] < score[site1] || score[2*site1+1] < score[site1]) {\n\t int flg = 0;\n\t if(score[2*site1] > score[2*site1+1]) flg = 1;\n\t swap(score[site1],score[2*site1+flg]);\n\t swap(id[site1],id[2*site1+flg]);\n\t site1 = 2*site1+flg;\n       }else break;\n     }\n   }\n   /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n\t cout << endl;\n\t for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n\t cout << endl;\n\t for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n\t cout << endl;\n   */\n }\n \n\n time[score[1].second] += L-mae;\n \n int maxtime = -1;\n int ans;\n for(int i=1;i<=N;i++) \n   if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n // for(int i=1;i<=N;i++) cout << time[i] <<\" \";\n //cout << endl;\n \n cout << ans << endl;\n\n return 0;\n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, R, L, D, T, X, M[100000], A[100000]; vector<pair<int, int> > F[1000000]; // (team, score)\nint main() {\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\tfor (int i = 0; i < R; i++) {\n\t\tscanf(\"%d%d%d\", &D, &T, &X);\n\t\tF[T].push_back(make_pair(D - 1, X));\n\t}\n\tpriority_queue<pair<int, int> > que;\n\tfor (int i = 0; i < N; i++) {\n\t\tque.push(make_pair(0, -i));\n\t}\n\tfor (int i = 0; i < L; i++) {\n\t\tfor (int j = 0; j < F[i].size(); j++) {\n\t\t\tM[F[i][j].first] += F[i][j].second;\n\t\t\tque.push(make_pair(M[F[i][j].first], -F[i][j].first));\n\t\t}\n\t\tpair<int, int> p;\n\t\twhile (!que.empty()) {\n\t\t\tp = que.top();\n\t\t\tif (p.first == M[-p.second]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\tA[-p.second]++;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] > A[ret]) {\n\t\t\tret = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  team[search(id,n)].point+=key;\n  maxHeapify(id);\n  while(id>1&&team[id/2].point<team[id].point){\n    swap(team[id],team[id/2]);\n    id=id/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=search(top,n);\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i],x[i],n);\n    //printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n    if(i==0){\n      team[1].showed+=t[0];\n    }\n    else if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  //for(int i=1;i<=n;i++){\n  //printf(\"%d %d\\n\",team[i].id,team[i].showed);\n  //}\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rrep(i,n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1000000000;\n\nint main(){\n\t/*\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN+1);\n\treturn 0;*/\n\t\n\tint N,R,L;\n\tint n,t,s;\n\tint nowN=-1,befT=0,maxS;\n\tstatic int scr[114514],time[114514];\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\trep(i,R){\n\t\tmaxS=-INF;\n\t\tscanf(\"%d%d%d\",&n,&t,&s);\n\t\tif(nowN>-1)time[nowN]+=t-befT;\n\t\tscr[n-1]+=s;\n\t\tif(nowN==-1){\n\t\tif(scr[n-1]>0)nowN=n-1;\n\t\telse if(n==0)nowN=1;\n\t\telse nowN=0;\n\t\t//else nowN = (scr[n-1]==scr[nowN]?min(n-1,nowN):(scr[n-1]>scr[nowN]?n-1:nowN));\n\t\t}else if(n-1!=nowN){if(scr[n-1]>=scr[nowN]){\n\t\t\tif(scr[n-1]==scr[nowN])nowN=min(n-1,nowN);\n\t\t\telse nowN=n-1;}\n\t\t}else if(n-1==nowN){\n\t\t\trep(i,N)maxS=max(scr[i],maxS);\n\t\t\trep(i,N)if(scr[i]==maxS){nowN=i;break;}\n\t\t}\n\t\tbefT=t;\n\t}\n\t\tmaxS=-INF;\n\t\tt=L;\n\t\ttime[nowN]+=t-befT;\n\t\trep(i,N)maxS=max(time[i],maxS);\n\t\trep(i,N)if(time[i]==maxS){nowN=i;break;}\n\t\tprintf(\"%d\\n\",nowN + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct dat{ int id, point; };\n#define MAX_N 1 << 17\n\nint N, R, L;\nint res[MAX_N + 1];\ndat seg[2 * MAX_N];\nint n;\n\nvoid init(){\n//\tprintf(\"c\");\n\tn = 1;\n\twhile(n < N) n *= 2;//nはseg木の要素数\n//\tprintf(\"[n = %d]\", n);\n\tfor(int i = 0; i < 2 * n - 1; i++) seg[i].point = 0;\n//\tprintf(\"a\");\n\tfor(int j = 1; j <= N; j++){\n\t\tseg[n + j].id = j;\n\t}\n//\tprintf(\"b\");\n}\n\nvoid add(int p, int x){\n\tp += n;\n\tseg[p].point += x;\n\twhile(p > 0){\n\t\t//printf(\"p = %d\\n\", p);\n\t\tp = (p - 1) / 2;\n\t\tif(seg[p * 2 + 1].point >= seg[p * 2 + 2].point){\n\t\t\tseg[p] = seg[p * 2 + 1];\n\t\t}\n\t\telse{\n\t\t\tseg[p] = seg[p * 2 + 2];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\tinit();\n\t\n\tint lb = 0;//左端\n\tint d, t, x;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tif(i > 0) res[seg[0].id] += t - lb;\n\t\tadd(d, x);\n\t\tlb = t;\n//\t\tfor(int i = 1; i <= N; i++){\n//\t\t\tprintf(\"%d \", res[i]);\n//\t\t}\n//\t\tprintf(\": seg[0].id = %d\\n\", seg[0].id);\n\t}\n\tres[seg[0].id] += L - t;\n\t\n\tint longest = 0;//最長の映り時間\n\tfor(int i = 1; i <= N; i++) longest = max(longest, res[i]);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(res[i] == longest){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, R, L;\nset<pair<int, int> >  TeamInfo;\nint TotalScoreOfTeam[100001];\nint TotalTime[100001];\n\n\nvoid solve(int id, int score) {\n\tset<pair<int, int> >::iterator it;\n\n\tit = TeamInfo.find(make_pair(-TotalScoreOfTeam[id], id));\n\tif ( it != TeamInfo.end()) {\n\t\tTeamInfo.erase(it);\n\t}\n\tTotalScoreOfTeam[id] += score;\n\tTeamInfo.insert(make_pair(-TotalScoreOfTeam[id], id));\n}\n\nint main() {\n\tint d, t, x, preTime;\n\n\tmemset(TotalTime, 0, sizeof(TotalTime));\n\tmemset(TotalScoreOfTeam, 0, sizeof(TotalScoreOfTeam));\n\tTeamInfo.clear();\n\tpreTime = 0;\n\n\tcin >> N >> R >> L;\n\tfor (int i = 0; i < N; ++i) {\n\t\tTeamInfo.insert(make_pair(0, i + 1));\n\t}\n\tfor (int i = 0; i < R; ++i) {\n\t\tcin >> d >> t >> x;\n\t\t\n\t\tTotalTime[TeamInfo.begin()->second] += t - preTime;\n\t\tsolve(d, x);\n\t\tpreTime = t;\n\t}\n\tTotalTime[TeamInfo.begin()->second] += L - preTime;\n\n\tcout << max_element(TotalTime + 1, TotalTime + N + 1) - TotalTime << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[130010];\nstruct node {\n    int id, point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nstruct node {\n    int id, point;\n} node[1<<18];\nint n, a[131050];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001] ;\n  int time[100001] ;\n \n\n  \n\n\n  for(int i=1;i<=N;i++) {\n    score[i].first = 0;\n    score[i].second = i;\n    time[i] = 0;\n  }\n  \n\n\n  \n  int  mae = 0;\n  \n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n    \n    time[score[1].second] += t - mae;\n    score[d].first += x;\n    mae = t;\n    \n    int site1;\n    \n    for(int j=1;j<=N;j++) \n      if(score[j].second == d) {\n\tsite1 = d;\n\tbreak;\n      }\n    \n\t \n    \n    pair <int , int > tmp;   \n    for(int j=d;j>=1;j--) {\n      if(score[site1].first > score[site1/2].first ) {\n      tmp = score[site1];\n      score[site1] = score[site1/2];\n      score[site1/2] = tmp;\n      site1 = site1/2;\n      }else if(score[site1].first == score[site1/2].first && score[site1].second < score[site1/2].second) {\n\ttmp = score[site1];\n\tscore[site1] = score[site1/2];\n\tscore[site1/2] = tmp;\n      site1 = site1/2;\n      } else break;\n    }\n        \n    while(2*site1< N && score[2*site1]> score[site1] || score[2*site1+1] > score[site1]) {\n      if(site1 > N ) break;\n      int flg = 0;\n      if(score[2*site1+1] > score[site1] && score[2*site1] > score[2*site1+1]) flg = 1;\n      tmp = score[site1];\n      score[site1] = score[site1*2+flg];\n      score[site1*2+flg] = tmp;\n    }\n    \n\n  }\n\n  time[score[1].second] += L-x;\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n  \n  \n  cout << ans << endl;\n\n  return 0;\n\n  }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#include<functional>\n#include<string>\n#include<unordered_map>\n#define p pair<int,int>\n#define P pair<int,p>\n#define int long long\nusing namespace std;\n\nP a[1000001];//?????????????????????????????????\np segment[500000];\nint point[100000];\nint n=1;\nint b;\nvoid kousin(int b, int c) {\n\tsegment[n + b].first -= c;\n\tb = n + b;\n\twhile (b > 0) {\n\t\tb >>= 1;\n\t\tsegment[b] = min(segment[b * 2 + 1], segment[b * 2 + 2]);\n\t}\n}\nsigned main() {\n\tint b, c, d; cin >> b >> c >> d;\n\tfor (int e = 0; e < c; e++) {\n\t\tint f, g, h; scanf(\"%lld%lld%lld\", &f, &g, &h); f--;\n\t\ta[e] = P(g, p(f,h));\n\t}\n\ta[c] = P(d, p(0, 0));\n\tc++;\n\tn = b;\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment[n + i - 1].second = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tkousin(0, 0);\n\t}\n\tn = b - 1;\n\tint last = 0;\n\tint team = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tpoint[team] += a[i].first - last;\n\t\tlast = a[i].first;\n\t\tkousin(a[i].second.first, a[i].second.second);\n\t\tteam = segment[0].second;\n\t}\n\tint x = 0, y = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tif (x < point[i]) { x = point[i]; y = i + 1; }\n\t\tcout << point[i] << endl;\n\t}\n\tcout << y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[137510];\nstruct node {\n    int id, point;\n} node[1<<20];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint main(){\n\tint N,R,L;\n\tint d,t,x;\n\tint now=0;\n\tint gap;\n\tint max,id;\n\tint team[100001]={0};\n\tint time[100001]={0};\n\n\tcin >> N >>R >> L;\n\n\twhile(R--){\n\t\tcin >>d>>t>>x;\n\t\t\n\t\tgap=t-now;\n\t\tnow=t;\n\t\tmax=team[1];\n\t\tid=1;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tif(max<team[i]){\n\t\t\t\tmax=team[i];\n\t\t\t\tid=i;\n\t\t\t}\n\t\t}\n\n\t\ttime[id]+=gap;\n\t\tteam[d]+=x;\n\t\t\n\t}\n\tgap=L-now;\n\tmax=team[1];\n\tid=1;\n\tfor(int i=2;i<=N;i++){\n\t\tif(max<team[i]){\n\t\t\tmax=team[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\ttime[id]+=gap;\n\n\tmax=time[1];\n\tid=1;\n\tfor(int i=2;i<=N;i++){\n\t\tif(max<time[i]){\n\t\t\tmax=time[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\tcout<<id<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MAX_N 100000\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\nstruct segtree{\n  int N;\n  P dat[MAX_N * 2 - 1];\n  segtree(){}\n  segtree(int n){\n    N = 1;\n    while(n > N) N *= 2;\n\n    rep(i, 2 * N - 1) dat[i] = MP(-1000000, -1000000);\n    for(int i = N - 1; i < 2 * N - 1; i++) dat[i] = MP(0, -1 * (i - N + 1));\n  }\n\n  void update(int k, int a){\n    k += N - 1;\n    dat[k].F += a;\n    while(k > 0){\n      k = (k - 1) / 2;\n      dat[k] = max(dat[k*2+1], dat[2*k+2]);\n    }\n  }\n\n  P query(int a, int b){ return query(a, b, 0, 0, N); }\n  P query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return P(-100000, -1000000);\n\n    if(a <= l && r <= b) return dat[k];\n    else{\n      P vl = query(a, b, 2*k+1, l, (l+r)/2);\n      P vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return max(vl, vr);\n    }\n  }\n};\n\nint main(){\n  int N, R, L;\n  ll res[MAX_N];\n  scanf(\"%d%d%d\", &N, &R, &L);\n  segtree seg(N);\n  rep(i, N) seg.update(i, 0);\n  int time = 0;\n  rep(i, R){\n    //    seg.show();\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x); d--;\n    P s = seg.query(0, N);\n    //    printf(\"%d %d\\n\", s.F, -s.S);\n    res[-s.second] += t - time;\n    seg.update(d, x);\n    time = t;\n  }\n  P s = seg.query(0, N);\n  res[-s.second] += L - time;\n\n  //  seg.show();\n\n  //  rep(i, N) printf(\"%d\\n\", res[i]);\n  int ans = 0;\n  rep(i, N) if(res[ans] < res[i]) ans = i;\n\n  printf(\"%d\\n\", ans+1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -111111\n#define MAX 111111\ntypedef pair<int,int> P;\nint n;\nP dat[4*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[100012];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  \n  int d,t,x,top=0,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[top].first+=t-bt;\n    update(d,x);\n    top=dat[0].second;\n    bt=t;\n  }\n  tim[top].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nint INF=1<<28;\nstruct SegmentTree{\n\tvector<int> dat;\n\tvector<int> mi;\n\n\tint n,size;\n\tSegmentTree(int _n){\n\t\tn=Pow2Fit(_n)<<1;\n\t\tsize=2*n-1;\n\t\tdat=vector<int>(size,-INF);\n\t\tmi=vector<int>(size,INF);\n\t}\n\tint Pow2Fit(int n){\n\t\t  n = n | (n >>  1);n = n | (n >>  2);n = n | (n >>  4);n = n | (n >>  8);n = n | (n >> 16);\n\t\t  return n ^ (n >> 1);\n\t}\n\n\tvoid update(int v,int a){\n\t\tv+=n-1;\n\t\tdat[v]=a;\n\t\tmi[v]=v-(n-1);\n\t\twhile(v>0){\n\t\t\tint parent=v=(v-1)/2;\n\t\t\tint chl=parent*2+1,chr=parent*2+2;\n\t\t\tif(dat[chl]>=dat[chr])mi[parent]=mi[chl];\t\t\t\t\n\t\t\telse mi[parent]=mi[chr];\n\t\t\tdat[parent]=max(dat[chl],dat[chr]);\n\t\t}\n\t}\n\n\tint query(int a,int b){\n\t\treturn query(0,a,b,0,n);\n\t}\n\n\tprivate:\n\tint query(int v,int a,int b,int l,int r){\n\t\tif(r<=a || b<=l)return -1;//out range\n\t\tif(a<=l && r<=b)return mi[v];\n\n\t\tint vl=query(v*2+1,a,b,l,(l+r)/2);\n\t\tint vr=query(v*2+2,a,b,(l+r)/2,r);\n\t\tif(vl==-1)return vr;\n\t\tif(vr==-1)return vl;\n\n\t\tif(dat[vl+(n-1)]>=dat[vr+(n-1)])return vl;\n\t\telse return vr;\n\t}\n};\n\nclass Task{\n\tpublic:\n\tint d,t,x;\n\tTask(int d,int t,int x):d(d),t(t),x(x){\n\t}\n\n\tbool operator < (const Task& r) const {\n\t\treturn t< r.t;\n\t}\n};\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint N,R,L;cin >> N >> R >> L;\n\t\tvector<Task> ts;\n\t\tREP(i,R){\n\t\t\tint d,t,x;cin >> d >> t >> x;d--;\n\t\t\tts.push_back(Task(d,t,x));\n\t\t}\n\t\tsort(ALL(ts));\n\n\t\tvector<int> vs(N);\n\t\tSegmentTree seg(N);\n\t\tREP(i,N)seg.update(i,0);\n\n\t\tint pt=0;\n\t\tREP(i,R){\n\t\t\tvs[seg.query(0,N)]+=ts[i].t-pt;\n\t\t\tpt=ts[i].t;\n\t\t\tseg.update(ts[i].d,seg.dat[ts[i].d+(N-1)]+ts[i].x);\n\t\t}\n\t\tvs[seg.query(0,N)]+=L-pt;\n\n\t\tint Mv=0;\n\t\tREP(i,N){\n\t\t\tMv=max(Mv,vs[i]);\n\t\t}\n\t\tREP(i,N)if(Mv==vs[i]){\n\t\t\tcout <<i+1<<endl;return;\n\t\t}\n\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define h 131071\nint data[262144][2];//値//番号\nint ti[100002];\nint last,now,top=1;\n\nvoid update(int n){\n\tif(data[n*2][0]>=data[n*2+1][0]){\n\t\tdata[n][0]=data[n*2][0];\n\t\tdata[n][1]=data[n*2][1];\n\t}\n\telse{\n\t\tdata[n][0]=data[n*2+1][0];\n\t\tdata[n][1]=data[n*2+1][1];\n\t}\n\t\n\tif(n==1){\n\t\tti[top]+=(now-last);\n\t\ttop=data[1][1];\n\t\tlast=now;\n\t\treturn;\n\t}\n\tupdate(n/2);\n}\n\nint main(){\n\t\n\tint n,r,l;\n\tcin>>n>>r>>l;\n\tfor(int i=1;i<=n;i++){\n\t\tdata[h+i][1]=i;\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tint d,x;\n\t\tcin>>d>>now>>x;\n\t\tdata[h+d][0]+=x;\n\t\tupdate((h+d)/2);\n\t}\n\tnow=l;\n\tupdate(1);\n\tint sum=0,ans=0;\n\tfor(int i=1;i<=n;i++){\n\t\t\n\t\tif(ti[i]>sum){\n\t\t\tsum=ti[i];\n\t\t\tans=i;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nint main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\tvi v(n + 1, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<max_element(all(v))-v.begin()-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * 100001];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -1000000);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n    team[k] = P(a, -(k - n + 1));\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[-team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[n + d - 2].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[-team[0].second] += (l - t);\n\t\n    /*for(int i = 0; i < m; ++i)\n        cout << p[i] << endl;*/\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tvi v(n + 100, 0);\n\tinit(n);\n\tint d, t, x, tt = 0;\n\tpii p;\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tif(p.se > 0) continue;\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct Segtree {\n    int n;\n    vpii dat;\n\n    void init(int n_) {\n        n = 1;\n\n        while (n < n_) n *= 2;\n\n        dat.resize(2 * n);\n\n        for (int i = 0; i < 2 * n - 1; ++i) dat[i] = pii(0, -inf);\n    }\n\n    void update(int a, int x) {\n        int idx = a;\n        a += n - 1;\n\n        dat[a].fst += x;\n        dat[a].scd = -idx;\n\n        while (a > 0) {\n            a = (a - 1) / 2;\n            dat[a] = max(dat[a * 2 + 1], dat[a * 2 + 2]);\n        }\n    }\n\n    //pii get_max(int a, int b, int k = 0, int l = 0, int r = -1) {\n    pii get_max() {\n        return dat[0];\n\n        //if (r == -1) r = N;\n\n        //if (r <= a || l >= b) return pii(-inf, -inf);\n\n        //if (a <= l && r <= b) return dat[k];\n\n        //pii vl = get_max(a, b, k * 2 + 1, l, (l + r) / 2);\n        //pii vr = get_max(a, b, k * 2 + 2, (l + r) / 2, r);\n\n        //return max(vl, vr);\n    }\n};\n\ntypedef pair<int, pair<int, int> > Query;\n\nint res[100010];\n\nsigned main()\n{\n    int N, R, L; cin >> N >> R >> L;\n\n    Segtree seg;\n    seg.init(N);\n\n    vector<Query> queries(R);\n\n    rep(i, R) {\n        int d, t, x;\n        cin >> d >> t >> x;\n\n        -- d;\n\n        queries[i] = Query(t, pii(d, x));\n    }\n\n    queries.PB(Query(L, pii(0, 0)));\n    \n    sort(all(queries));\n\n    rep(i, R) {\n        Query query = queries[i];\n        Query next_query = queries[i + 1];\n\n        seg.update(query.scd.fst, query.scd.scd);\n\n        if (query.fst != next_query.fst) {\n            res[-seg.get_max().scd] += next_query.fst - query.fst;\n        }\n    }\n\n    int ma = -1;\n    int ans = -1;\n\n    rep(i, N) {\n        if (ma < res[i]) {\n            ma = res[i];\n            ans = i;\n        }\n    }\n\n    cout << ans + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstruct state {\n  int id,score,last;\n  bool operator < ( const state &p ) const {\n    if(score==p.score)return id > p.id;\n    else return score < p.score;\n  }\n};\n\nstruct event {\n  int d,t,x;\n};\n\nint N,R,L;\nint score[100010];\nint last[100010];\nint sum[100010];\nevent events[100010];\n\n\nint main(){\n  priority_queue < state > Q;\n  for(int i=0;i<100010;i++)score[i]=last[i]=sum[i]=0;\n  cin>>N>>R>>L;\n  for(int i=1;i<=N;i++)Q.push( (state){i,0,0} );\n  for(int i=0;i<R;i++){\n    cin>>events[i].d>>events[i].t>>events[i].x;\n  }\n  events[R].t=L;\n  events[R].d=events[R].x=0;\n  state f = (state){1,0,0};\n  state g;\n  int a=0;\n  for(int i=0;i<=R;i++){\n    event e = events[i];\n    score[e.d]+=e.x;\n    last[e.d]=e.t;\n    Q.push( (state){e.d,score[e.d],last[e.d]} );\n    if(i+1<=R&&e.t==events[i+1].t)continue;\n    g=f;\n    while(1){\n      f=Q.top();\n      if(f.last==last[f.id])break;\n      Q.pop();\n    }\n    sum[g.id]+=(e.t-a);\n    //cout<<g.id << ' '<<e.t-a<<endl;\n    a=e.t;\n  }\n  int ans=-1,ans2=0;\n  for(int i=1;i<=N;i++){\n    if(ans<sum[i]){\n      ans=sum[i];\n      ans2=i;\n    }\n  }\n  cout<<ans2<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[1000000],t[1000000],x[1000000];\nint pnt[100000];\nint cnt[100000];\nsigned main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n\n    priority_queue<D>Q;\n\n    for(int i=0;i<N;i++)Q.push(D(0,i));\n\n    int cur=0;\n    for(int i=0;i<L;i++){\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]++;\n\n        while(cur<R&&t[cur]==i+1){\n            pnt[d[cur]]+=x[cur];\n            Q.push(D(pnt[d[cur]],d[cur]));\n            cur++;\n        }\n    }\n\n    int de=0;\n    //for(int i=0;i<N;i++)de+=cnt[i];cout<<\"de is \"<<de<<endl;\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MIN -111111\n#define MAX 111111\ntypedef pair<int,int> P;\nint n;\nP dat[2*100000-1];\nvoid update(int k,int x);\nvoid init(int n_);\nint main(){\n  int N,R,L;\n  P tim[100001];\n  cin>>N>>R>>L;\n  \n  init(N);\n  for(int i=0;i<n;i++){\n    dat[i+(n-1)]=P(0,i+1);\n    tim[i]=P(0,-i-1);\n  }\n  \n  int d,t,x,top=0,bt=0;\n  for(int i=0;i<R;i++){\n    cin>>d>>t>>x;\n    tim[top].first+=t-bt;\n    update(d,x);\n    top=dat[0].second;\n    bt=t;\n  }\n  tim[top].first+=L-bt;\n  sort(tim,tim+n,greater<P>());\n  cout<<-tim[0].second-1<<endl;\n}\nvoid init(int n_){\n  n=1;\n  while(n<n_){\n    n*=2;\n  }\n  for(int i=0;i<2*n-1;i++){\n    dat[i]=P(MIN,MAX);\n  }\n}\nvoid update(int k,int a){\n  k+=n-1;\n  dat[k]=P(dat[k].first+a,k-(n-1));\n  while(k>0){\n    k=(k-1) /2;\n    if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second < dat[k*2+2].second){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }\n    }else{\n      if(dat[k*2+1].first > dat[k*2+2].first){\n\tdat[k]=dat[k*2+1];\n      }else{\n\tdat[k]=dat[k*2+2];\n      }   \n    }\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\n\nint p[1000005];\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<int> dat,id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(2*n-1);\n\t\tid.resize(2*n-1);\n\t\trep(i,2*n-1)\n\t\t{\n\t\t\tdat[i] = -INF;\n\t\t\tid[i] = -1;\n\t\t}\n\n\t\trep(i,n) update(i,INF);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] += a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\t//time id,point\n\tmap<int,vector<pair<int,int> > > m;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tm[t].push_back(make_pair(d,x));\n\t}\n\n\tvector<int> v(n);\n\tmemset(p,0,sizeof(p));\n\tSeg seg(n);\n\n\tint top_id = 0,pre_time = 0;\n\tmap<int,vector<pair<int,int> > >::iterator ite;\n\tfor(ite = m.begin(); ite != m.end(); ite++)\n\t{\n\t\tint d,t,x;\n\t\tt = ite->first;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\trep(i,m[t].size())\n\t\t{\n\t\t\td = m[t][i].first;\n\t\t\tx = m[t][i].second;\n\n\t\t\tseg.update(d-1,x);\n\t\t\ttop_id = seg.id[0];\n\t\t}\n\n\t}\n\n\tv[top_id] += l - pre_time;\n\n\tint res = -INF;\n\trep(i,n)\n\t{\n\t\tres = max(res,v[i]);\n\t}\n\n\trep(i,n)\n\t{\n\t\tif(res == v[i])\n\t\t{\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\ntypedef pair<int, int> P;\n\nint n;\nP team[2 * 100000];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i].first = -INF;\n\t\tteam[i].second = 100002;\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tif(team[k].first == -INF){\n\t\tteam[k].first = 0;\n\t\tteam[k].second = k - n + 1;\n \t}\n\telse\n\t\tteam[k].first += a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tint p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[team[0].second] += (t - prev);\n\t\tupdate(d - 1, x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[team[0].second] += (l - t);\n\t\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct dat{ int id, point; };\n#define MAX_N 100000\n\nint N, R, L;\nint res[MAX_N + 1];\ndat seg[MAX_N * 2];\nint n;\n\nvoid init(){\n\tn = 1;\n\twhile(n < N) n *= 2;//nはseg木の要素数\n\tfor(int i = 0; i < n; i++) seg[i].point = 0;\n\tn /= 2;\n\tfor(int j = 1; j <= N; j++){\n\t\tseg[n + j].id = j;\n\t}\n}\n\nvoid add(int p, int x){\n\tp += n;\n\tseg[p].point += x;\n\twhile(p > 0){\n\t\t//printf(\"p = %d\\n\", p);\n\t\tp = (p - 1) / 2;\n\t\tif(seg[p * 2 + 1].point >= seg[p * 2 + 2].point){\n\t\t\tseg[p] = seg[p * 2 + 1];\n\t\t}\n\t\telse{\n\t\t\tseg[p] = seg[p * 2 + 2];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\t\n\tinit();\n\t\n\tint lb = 0;//左端\n\tint d, t, x;\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\tif(i > 0) res[seg[0].id] += t - lb;\n\t\tadd(d, x);\n\t\tlb = t;\n\t\t//for(int i = 1; i <= N; i++){\n\t\t//\tprintf(\"%d \", res[i]);\n\t\t//}\n\t\t//printf(\": seg[0].id = %d\\n\", seg[0].id);\n\t}\n\tres[seg[0].id] += L - t;\n\t\n\tint longest = 0;//最長の映り時間\n\tfor(int i = 1; i <= N; i++) longest = max(longest, res[i]);\n\tfor(int i = 1; i <= N; i++){\n\t\tif(res[i] == longest){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tvi v(n + 100, 0);\n\tinit(n);\n\tint d, t, x, tt = 0;\n\tpii p;\n\tupdate(0, 0);\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\tif(p.se > 0) continue;\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\tcout<<(int)(max_element(all(v))-v.begin())-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <utility>\n#include <algorithm>\n#define REP(i,n) for(int i = 0; i < n; i++)\n#define REP(j,n) for(int j = 0; j < n; j++)\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main() {\n    int n,r,l;\n    cin >> n;\n    cin >> r;\n    cin >> l;\n    int list[n+1];\n    int time[n+1];\n    for(int i = 0; i < n+1; i++) {\n        list[i] = 0;\n        time[i] = 0;\n    }\n    int top = 0;\n    int id  = 1;\n    int nowtime = 0;\n    int timemax = 0;\n    int timemaxid = 0;\n    for(int i = 0; i < r; i++) {\n        int d,t,x;\n        cin >> d;\n        cin >> t;\n        cin >> x;\n        time[id] += t - nowtime;\n        if(time[id] > timemax) {\n            timemax = time[id];\n            timemaxid = id;\n        }\n        nowtime = t;\n        list[d] += x;\n        if(id == d) {\n            top += x;\n        }\n        if(x < 0 && d == id) {\n            for(int j = 1; j < n+1; j++) {\n                if(top < list[j] || (top == list[j] && j < id)) {\n                    top = list[j];\n                    id = j;\n                }\n            }\n            \n        }\n        if(x > 0 && d != id) {\n            if(top < list[d] || (top == list[d] && d < id)) {\n                top = list[d];\n                id = d;\n            }\n        }\n\n    }\n    time[id] += l - nowtime;\n    if(time[id] > timemax) {\n        timemax = time[id];\n        timemaxid = id;\n    }\n    cout << timemaxid << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nint ans[1 << 17];\n\nint N, R, L, n;\n\npair<int, int> dat[1 << 18 + 1];\n\nvoid init()\n{\n  n = 2;\n  while(n < N) n *= 2;\n  n *= 2;\n  for(int i = 0; i < n * 2 - 1; i++)\n    dat[i] = make_pair(0, 0);\n}\n\nvoid update(int i, pair<int, int> x)\n{\n  i += n - 1;\n  dat[i] = x;\n  while(i > 0)\n  {\n    i = (i - 1) / 2;\n    dat[i] = max(dat[i * 2 + 1], dat[i * 2 + 2]);\n  }\n}\n\npair<int, int> query(int a, int b, int k, int l, int r)\n{\n  if(r <= a || b <= l) \n    return make_pair(0, 0);\n  if(a <= l && r <= b) \n    return dat[k];\n  pair<int, int> kl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n  pair<int, int> kr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n  if(kl.first == kr.first)\n    return kl.second > kr.second ? kr : kl;\n  else\n    return max(kr, kl);\n  //return dat[kl] < dat[kr] ? kr : kl;\n}\n\nvoid output()\n{\n  int m;\n  for(int i = 0; i < N; i++)\n  {\n    m = max(m, ans[i]);\n  }\n  for(int i = 0; i < N; i++)\n  {\n    if(ans[i] == m)\n    {\n      cout << i + 1<< endl;\n      return;\n    }\n  }\n}\n\nint main()\n{\n  int old_t = 0;\n  cin >> N >> R >> L;\n\n  init();\n  for(int i = 0; i < N; i++)\n    update(i, make_pair(0, i));\n  for(int i = 0; i < R; i++)\n  {\n    int d, t, x;\n    cin >> d >> t >> x;\n    pair<int, int> p;\n    d--;\n    p = query(0, N, 0, 0, n);\n    ans[p.second] += t - old_t;\n    update(d, make_pair(dat[d + (n - 1)].first + x, dat[d + (n - 1)].second));\n    if(i != R - 1) \n      old_t = t;\n    /*for(int i = 0; i < n * 2 - 1; i++)\n      cout << dat[i] << \" \";\n    cout << endl;*/\n\n    //cout << query(0, N + 1, 0, 0, n) << endl;\n    /*\n    char c;\n    cin >> c;\n    if(c == 'e')\n      break;\n    if(c == 'u')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"update \" << a << \" \" << b << \" \" << endl;\n      update(a, b);\n    }\n    if(c == 'q')\n    {\n      int a, b;\n      cin >> a >> b;\n      cout << \"max \" << \"[\" << a << \", \" << b << \")\" << endl;\n      cout << query(a, b, 0, 0, n);\n    }*/\n  }\n\n  pair<int, int> p = query(0, N, 0, 0, n);\n  ans[p.second] += L - old_t;\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n// pp basics\n\n#define in ,\n#define esc_paren(...) __VA_ARGS__\n#define pp_empty(...)\n#define pp_cat_i(x, y) x ## y\n#define pp_cat(x, y) pp_cat_i(x, y)\n\n#define pp_inc0 1\n#define pp_inc1 2\n#define pp_inc2 3\n#define pp_inc3 4\n#define pp_inc4 5\n#define pp_inc5 6\n#define pp_inc6 7\n#define pp_inc7 8\n#define pp_inc8 9\n#define pp_inc(i) pp_cat(pp_inc, i)\n\n// pp args counter\n\n#define pp_arg10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) _9\n#define pp_has_comma(...) pp_arg10(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 0)\n#define pp_trigger_paren(...) ,\n#define pp_is_empty(...) \\\n  pp_is_empty1( \\\n      pp_has_comma(__VA_ARGS__), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__), \\\n      pp_has_comma(__VA_ARGS__()), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__()) \\\n      ) \n#define pp_paste5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4\n#define pp_is_empty1(_0, _1, _2, _3) pp_has_comma(pp_paste5(pp_is_empty_case_, _0, _1, _2, _3))\n#define pp_is_empty_case_0001 ,\n\n#define pp_is_one(...) pp_is_one_(__VA_ARGS__, pp_one_seq)\n#define pp_is_one_(...) pp_is_one_n(__VA_ARGS__)\n#define pp_is_one_n(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10, N, ...) N\n#define pp_one_seq 0,0,0,0,0,0,0,0,0,1,0\n\n#define pp_narg(...) \\\n         pp_narg_(__VA_ARGS__, pp_narg_seq)\n#define pp_narg_(...) \\\n         pp_narg_n(__VA_ARGS__)\n#define pp_narg_n( \\\n          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\\n         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\\n         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\\n         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\\n         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\\n         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\\n         _61,_62,_63,n,...) n\n#define pp_narg_seq \\\n         63,62,61,60, \\\n         59,58,57,56,55,54,53,52,51,50, \\\n         49,48,47,46,45,44,43,42,41,40, \\\n         39,38,37,36,35,34,33,32,31,30, \\\n         29,28,27,26,25,24,23,22,21,20, \\\n         19,18,17,16,15,14,13,12,11,10, \\\n          9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n// pp if\n#define pp_if_0(x, y) y\n#define pp_if_1(x, y) x\n#define pp_if(cond, x, y) pp_cat(pp_if_, cond)(x, y)\n\n// pp foreach\n#define pp_foreach_i9(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i8(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i7(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i6(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i5(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i4(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i3(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i2(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i1(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i0(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i(i, f, ...) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach(f, ...) pp_foreach_i(0, f, __VA_ARGS__)\n\n// alternative rep macro\n#define rep(...) rep1(rep2, (__VA_ARGS__))\n#define rep1(X, A) X A\n#define rep2(i, ...) pp_if(pp_is_one(__VA_ARGS__), rep_len1(i, __VA_ARGS__), rep3(i, __VA_ARGS__))\n#define rep_len1(i, end, ...) for (int i = 0; i < end; i++)\n#define rep3(i, iter, ...) rep4(rep5, (iter, i, esc_paren __VA_ARGS__))\n#define rep4(X, A) X A\n#define rep5(iter, ...) iter(__VA_ARGS__)\n\n// iterators\n#define up up_iter ,\n#define up_iter3(i, start, end) for (int i = start; i < end; i++)\n#define up_iter4(i, start, end, up) for (int i = start; i < end; i += up)\n#define up_iter(...) pp_cat(up_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define down down_iter ,\n#define down_iter2(i, end) for(int i = end-1; i >= 0; i--)\n#define down_iter3(i, start, end) for (int i = end-1; i >= start; i--)\n#define down_iter4(i, start, end, down) for (int i = end-1; i >= start; i -= down)\n#define down_iter(...) pp_cat(down_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define viter viter_iter ,\n#define viter_iter(i, v) auto tmpitr=v.begin(); for (auto i=*tmpitr; tmpitr != v.end(); tmpitr++)\n\n// debug macros\n#define debug_var_elem(v) << #v << \"=\" << v << \" \"\n#ifdef DEBUG\n#define debug_echo(e) cout << \"L\" << __LINE__ << \": \" << e << endl\n#define debug_var(...) cout << \"L\" << __LINE__ << \": \" pp_foreach(debug_var_elem, __VA_ARGS__) << endl\n#define debug_ary(ary) cout << \"L\" << __LINE__ << \" [ \"; for(auto ele : ary) cout << ele << \" \"; cout << \"]\" << endl;\n#else\n#define debug_echo(e)\n#define debug_var(...)\n#define debug_ary(ary)\n#endif\n\n// short names\ntypedef long long ll;\n#define down_queue(x) priority_queue<x>\n#define up_queue(x) priority_queue<x, vector<x>, greater<x>>\nll gcd(ll a,ll b){while(b){ll tmp = a % b;a = b;b = tmp;}return a;}\nll lcm(ll a,ll b){return a / gcd(a,b) * b;}\n#define all(x) x.begin(), x.end()\n#define split_str(str, sp_word) istringstream stream(str); string res; for(int cnt = 0; getline(stream,res,sp_word); cnt++)\n#define digit(x) ((int)log10((double)(x)) + 1)\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\nvector<int> digit_split(int n){vector<int> result(digit(n));for(int i = 0; n; i++){result[i] = n % 10;n /= 10;}return result;}\n#define time(content) {auto start = clock();content;auto end = clock();cout << (double)(end - start) << \"ms\" << endl;} \n#define vec_cpy(to,from) copy(all(to),back_inserter(from))\n#define ary_cpy(to,from) memcpy(to, from, sizeof(from))\n#define MOD 1000000007 \n\n// pp unionfind\n#define pp_gen_field(list) pp_gen_field1 list\n#define pp_gen_field1(name, val) decltype(val) name;\n#define pp_gen_init(list) pp_gen_init1 list\n#define pp_gen_init1(name, val) ,val\n#define pp_gen_find_set_wrap(ufnodename) ufnodename pp_gen_find_set\n#define pp_gen_find_set(list) pp_gen_find_set1 list\n#define pp_gen_find_set1(name, val) \\\n  find_set_ ## name(int x, decltype(val) v) { \\\n    if (nodes[x].parent == x) { \\\n      nodes[x].name = v; \\\n      return nodes[x]; \\\n    } else { \\\n      return nodes[x] = find_set_ ## name(nodes[x].parent, v); \\\n    } \\\n  }\n#define pp_gen_unite_set(list) pp_gen_unite_set1 list\n#define pp_gen_unite_set1(name, val) \\\n  if (nodes[x].name == val) { \\\n    find_set_ ## name(x, find(y).name); \\\n  } \\\n  if (nodes[y].name == val) { \\\n    find_set_ ## name(y, find(x).name); \\\n  }\n\n#define def_unionfind(ufname, ufnodename, ...) \\\n  struct ufnodename { \\\n    int parent; \\\n    pp_foreach(pp_gen_field, __VA_ARGS__) \\\n  }; \\\n  struct ufname { \\\n    vector<ufnodename> nodes; \\\n    vector<int> rank; \\\n    ufname(int n) : nodes(n+1), rank(n+1) { \\\n      rep (i in n) { \\\n        nodes[i] = ufnodename{i pp_foreach(pp_gen_init, __VA_ARGS__)}; \\\n        rank[i] = 0; \\\n      } \\\n    } \\\n    ufnodename find(int x) { \\\n      if (nodes[x].parent == x) { \\\n        return nodes[x]; \\\n      } else { \\\n        return nodes[x] = find(nodes[x].parent); \\\n      } \\\n    } \\\n    pp_foreach(pp_gen_find_set_wrap(ufnodename), __VA_ARGS__) \\\n    void unite(int x, int y) { \\\n      x = find(x).parent; \\\n      y = find(y).parent; \\\n      if (x == y) return; \\\n      if (rank[x] < rank[y]) { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[x].parent = y; \\\n      } else { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[y].parent = x; \\\n        if (rank[x] == rank[y]) rank[x]++; \\\n      } \\\n    } \\\n    bool same(int x, int y) { \\\n      return find(x).parent == find(y).parent; \\\n    } \\\n  }\n\n//\n// Implementation\n//\n\nint main(){\n  int n,r,l;cin >> n >> r >> l;\n  vector<int> times(n,0),score(n,0),d(r),t(r),x(r);\n\n  function<int()> top_team = [&](){\n    return distance(score.begin(),max_element(all(score)));\n  };\n\n  rep(i in up(0, r)){\n    cin >> d[i] >> t[i] >> x[i];\n    if(i != 0)\n      times[top_team()] += t[i] - t[i - 1];\n\n    score[d[i] - 1] += x[i];\n    debug_var(x[i]);\n  }\n\n  times[top_team()] += l - t[r - 1];\n\n  debug_ary(times);\n  debug_ary(score);\n  cout << distance(times.begin(),max_element(all(times))) + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n+1];\n    for(int i=0;i<2*n+1;i++){\n      points[i] = Team(i,0);\n    }\n\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point = p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,-100000);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams);\n\n    map<int,vector<Team> > records;\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      records[time].push_back(Team(id,point));\n    }\n\n    for(map<int,vector<Team> >::iterator it = records.begin();\n\tit != records.end();\n\tit++){\n      for(int i=0;i<it->second.size();i++){\n\tseg_tree.insert(it->second[i].id,it->second[i].point);\n      }\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += it->first - prev_time;\n\tprev_time = it->first;\n\tprev_champ = team.id;\n      }\n    }\n\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 1;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst long long INF = 100000000000000;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i].first = -INF;\n\t\tteam[i].second = 100002;\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n\tif(team[k].first == -INF){\n\t\tteam[k].first = 0;\n\t\tteam[k].second = k - n + 1;\n \t}\n\telse\n\t\tteam[k].first += a;\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tif(team[k * 2 + 1].first == team[k * 2 + 2].first){\n\t\t\tif(team[k * 2 + 1].second < team[k * 2 + 2].second)\n\t\t\t\tteam[k] = team[k * 2 + 1];\n\t\t\telse\n\t\t\t\tteam[k] = team[k * 2 + 2];\n\t\t}\n\t\telse\n\t\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t    p[team[0].second] += (t - prev);\n\t\tprev = t;\n\t\tupdate(d - 1, x);\n\t}\n\tp[team[0].second] += (l - t);\n\t\n    for(int i = 0; i < m; ++i)\n        cout << p[i] << endl;\n\tint rank[100010] = {0}, ans;\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n\tfor(int i = 0; i < m; ++i)\n\t\tif(rank[i] == p[0])\n\t\t\tans = i + 1;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N_MAX 100001\ntypedef pair<int,int> P;\n \nint main(){\n  int N,R,L;\n  int d,t,x;\n  int time[N_MAX]={0};\n  int score[N_MAX]={0};\n  cin >> N >> R >> L;\n  priority_queue<P> que;\n  for(int i=1;i<=N;i++){\n    que.push(P(0,N-i));\n  }\n  int now = 0;\n  for(int j=0;j<R;j++){\n    cin >> d >> t >> x;\n    P p1 = que.top();\n    while(score[N-p1.second] != p1.first){\n      que.pop();\n      p1 = que.top();\n    }\n    time[N-p1.second] += t - now;\n    now = t;\n    score[d] += x;\n    que.push(P(score[d],N-d));\n  }\n  P p1 = que.top();\n  while(score[N-p1.second] != p1.first){\n    que.pop();\n    p1 = que.top();\n  }\n  time[N-p1.second] += L - now;\n  priority_queue<P> que2;\n  for(int i=1;i<=N;i++){\n    que2.push(P(time[i],N-i));\n  }\n  p1 = que2.top();\n  cout << N - p1.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 2014/08/31 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint N, R, L;\n\tcin >> N >> R >> L;\n\n\tlong long P[100001] = {0};\n\tint W = 1;\n\n\tint T[100001] = {0};\n\tint tp = 0;\n\n\tfor(int i=0; i<R; i++){\n\t\tint d, t, x;\n\t\tcin >> d >> t >> x;\n\n\t\tT[W] += t-tp;\n\t\ttp = t;\n\n\t\tP[d] += x;\n\n\t\tif(x>=0){\n\t\t\tif(P[W]<P[d] || (P[W]==P[d] && W>d)){\n\t\t\t\tW = d;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(W==d){\n\t\t\t\tW = 1;\n\t\t\t\tfor(int j=2; j<=N; j++){\n\t\t\t\t\tif(P[W]<P[j]){\n\t\t\t\t\t\tW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT[W] += L-tp;\n\n\tint C = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(T[C]<T[i]){\n\t\t\tC = i;\n\t\t}\n\t}\n\tcout << C << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define DEBUG\n\nusing namespace std;\nint n, a[135010];\nstruct node {\n    int id, point;\n} node[1<<18];\n\nvoid add(int id, int x)\n{\n    id=n-1+id;\n    node[id].point+=x;\n\n    while (id>0) {\n        id=(id-1)/2;\n        int c1=2*id+1, c2=2*id+2;\n        if (node[c1].point>=node[c2].point)\n            node[id]=node[c1];\n        else\n            node[id]=node[c2];\n    }\n}\n\nvoid print()\n{\n#ifdef DEBUG\n    int k=1;\n    int x=0;\n    while (true) {\n        for(int i=0;i<k;++i) printf(\"(%d %d)\", node[x+i].id, node[x+i].point);\n        puts(\"\");\n        x+=k;\n        k<<=1;\n        if (x>=n) break;\n    }\n    puts(\"\");\n#endif\n}\n\nint main()\n{\n    int m, r, l;\n    scanf(\"%d%d%d\", &m, &r, &l);\n    n=1;\n    while (n<m) n<<=1;\n    for(int i=0;i<m;++i) node[n-1+i].id=i;\n\n    int pt=0;\n    for(int i=0;i<r;++i) {\n        int d, t, x;\n        scanf(\"%d%d%d\", &d, &t, &x);\n\n        if (pt<t) {\n            int id=node[0].id;\n            a[id]+=t-pt;\n        }\n        add(d-1, x);\n        print();\n        pt=t;\n    }\n    print();\n    a[node[0].id]+=l-pt;\n#ifdef DEBUG\n    for(int i=0;i<n;++i) printf(\"%d \", a[i]); puts(\"\");\n#endif\n    printf(\"%d\\n\", 1+(max_element(a, a+n)-a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint point[100002];\nint times[100002];\n\nint main() {\n\n    int n,r,l;\n\n    cin >> n >> r >> l;\n\n    priority_queue<pair<int,int> > que;//??????,????????????\n\n    que.push(make_pair(0,-1));\n\n    int lasttime = 0;\n\n    for(int i=0;i<r;i++){\n        int d,t,x;\n        cin >> d >> t >> x;\n        pair<int,int> p = que.top();\n        while(p.first != point[-p.second] && !que.empty()){\n            que.pop();\n            p = que.top();\n        }\n\n        times[-p.second] += t - lasttime;\n        lasttime = t;\n\n        point[d] += x;\n\n        que.push(make_pair(point[d],-d));\n\n    }\n\n    pair<int,int> p = que.top();\n    while(p.first != point[-p.second] && !que.empty()){\n        que.pop();\n        p = que.top();\n    }\n    times[-p.second] += l - lasttime;\n\n    int ans = -1,anstime = -1;\n\n    for(int i=1;i<=n;i++){\n        if(anstime<times[i]){\n            ans = i;\n            anstime = times[i];\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <limits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <complex>\n\nusing namespace std;\n\n//define\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\n#define INF (INT_MAX/3)\n#define PI (2*acos(0.0))\n#define EPS (1e-8)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint N, R, L;\nint best_team;\nint pre_time;\nint tvtime[100001];\n\ntypedef pair<int, int> team;\n\nvector<team> teams;\n\nbool compare(const team &a, const team &b){\n  return a.second > b.second;\n}\n\nvoid addScore(int id, int s){\n  for(size_t i = 0; i < teams.size(); i++){\n    if(teams[i].first == id){\n      teams[i].second += s;\n      break;\n    }\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin >> N >> R >> L;\n  for(int i = 1; i <= N; i++){\n    teams.push_back(team(i, 0));\n  }\n  for(int i = 0; i < R; i++){\n    int d, t, x;\n    cin >> d >> t >> x;\n    addScore(d, x);\n    sort(teams.begin(), teams.end(), compare);\n    if(best_team == teams[0].first) continue;\n    tvtime[best_team] += t - pre_time;\n    best_team = teams[0].first;\n    pre_time = t;\n  }\n  tvtime[teams[0].first] += L - pre_time;\n  int longest = -1;\n  int ans_id;\n  for(int i = 1; i <= N; i++){\n    if(tvtime[i] > longest){\n      longest = tvtime[i];\n      ans_id = i;\n    }\n  }\n  cout << ans_id << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct team { int id, score, time; };\ntypedef pair<int, int> P;\n\nP seg[200001 * 2];\nteam prog[100001];\nint N, R, L;\n\nvoid init();\nvoid update(int key, int data, int t);\n\nint main()\n{\n\tscanf(\"%d %d %d\", &N, &R, &L);\n\tinit();\n\tint last = 0;\n\twhile (R-- > 0){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tupdate(d - 1, x, t);\n\t}\n\tupdate(0, 0, L);\n\tint maxi = 0;\n\tfor (int i = 1; i < N; i++){\n\t\tif (prog[maxi].time < prog[i].time) maxi = i;\n\t}\n\tprintf(\"%d\\n\", prog[maxi].id);\n}\n\nvoid init()\n{\n\tint n = 1;\n\t\n\twhile (n < N) n *= 2;\n\tfor (int i = 0; i < N; i++) prog[i].id = i + 1;\n\tfor (int i = N; i < n; i++) prog[i].id = INT_MAX;\n\tfor (int i = n - 1; i <= (n - 1) * 2; i++) seg[i].second = i - n + 2;\n\tN = n;\n}\n\nvoid update(int key, int data, int t)\n{\n\tstatic int last = 0;\n\tstatic int l_id = 1;\n\t\n\tseg[key + N - 1].first += data;\n\tprog[l_id - 1].time += t - last;\n\t\n\tfor (int c = key + N - 1; c != 0; c = (c - 1) / 2){\n\t\tint other = c % 2 == 0 ? c - 1 : c + 1;\n\t\t\n\t\tif (seg[c].first > seg[other].first) seg[(c - 1) / 2] = seg[c];\n\t\telse if (seg[c].first < seg[other].first) seg[(c - 1) / 2] = seg[other];\n\t\telse if (seg[c].second < seg[other].second) seg[(c - 1) / 2] = seg[c];\n\t\telse seg[(c - 1) / 2] = seg[other];\n\t}\n\t\n\tlast = t;\n\tl_id = seg[0].second;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#define INF 2000000000\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX_N = 1 << 17;\nint n,m;\nint num[200000];\nP dat[2*MAX_N-1];\n\nvoid init(int n_){\n\tn = 1;\n\twhile(n < n_) n *= 2;\n\tfor(int i = 0; i < 2*n-1; i++){\n\t\tdat[i].fi = INF;\n\t\tdat[i].sec = -INF;\n\t}\n\tfor(int i = 0; i < n; i++) dat[i+n-1].fi = i;\n}\n\nvoid update(int k, int a){\n\tk += n-1;\n\tdat[k].sec += a;\n\twhile(k > 0){\n\t\tk = (k-1)/2;\n\t\tif(dat[k*2+1].sec < dat[k*2+2].sec){\n\t\t\tdat[k].sec = dat[k*2+2].sec;\n\t\t\tdat[k].fi = dat[k*2+2].fi;\n\t\t} else{\n\t\t\tdat[k].sec = dat[k*2+1].sec;\n\t\t\tdat[k].fi = dat[k*2+1].fi;\n\t\t}\n\t}\n}\n\nP query(int a, int b, int k, int l, int r){\n\tif(r <= a || b <= l) return P(-1,-INF);\n\tif(a <= l && r <= b) return dat[k];\n\telse{\n\t\tP vl = query(a,b,k*2+1,l,(l+r)/2);\n\t\tP vr = query(a,b,k*2+2,(l+r)/2,r);\n\t\tif(vl.sec < vr.sec) return vr;\n\t\telse return vl;\n\t}\n}\n\nint main(){\n\tint r,l;\n\tP s;\n\ts.fi = 0; s.sec = 0;\n\tscanf(\"%d%d%d\", &n, &r, &l);\n\tm = n;\n\tinit(n);\n\tfor(int i = 0; i < m; i++) update(i,INF);\n\tfor(int i = 0; i < r; i++){\n\t\tint d,t,x;\n\t\tP tmp;\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\td--;\n\t\tnum[s.fi] += t-s.sec;\n\t\tupdate(d,x);\n\t\ttmp = query(0,n,0,0,n);\n\t\ts.fi = tmp.fi; s.sec = t;\n\t\t//for(int j = 0; j < 2*n-1; j++) printf(\"%d %d\\n\", dat[j].fi, dat[j].sec);\n\t\t//for(int j = 0; j < n; j++) printf(\"%d \", num[j]);\n\t\t//printf(\"\\n\");\n\t}\n\tnum[s.fi] += l-s.sec;\n\tint ans = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tans = max(ans,num[i]);\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tif(ans == num[i]){\n\t\t\tprintf(\"%d\\n\", i+1);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += t-oldt;\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n      if(pt[old]==pt[d]&&old>d) old = d; \n    }else{\n      if(old==d) old = max(pt,N);\n    }\n  }\n  ptime[old] += L- t;\n  int ans=1;\n  for(int i=2;i<=N;i++){\n    if(ptime[ans]<ptime[i]) ans = i;\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N,R,L;\nint D[1000009];\nint T[1000009];\nint X[1000009];\nint point[100009];\nint seg[1<<18];\nint lnumber,lstart;\nint tim[100009];\nint INF=-1<<30;\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d%d%d\",&D[i],&T[i],&X[i]);D[i]--;\n\t}\n\tfor(int i=(1<<17)-1+N;i<(1<<18)-1;i++){\n\t\tseg[i]=N+1;\n\t}\n\tfor(int i=(1<<17)-1;i<(1<<17)-1+N;i++){\n\t\tseg[i]=i+1-(1<<17);\n\t}\n\tfor(int i=(1<<17)-2;i>=0;i--){\n\t\tint point1,point2;\n\t\tif(seg[2*i+1]==N+1)point1=INF;\n\t\telse point1=point[seg[2*i+1]];\n\t\tif(seg[2*i+2]==N+1)point2=INF;\n\t\telse point2=point[seg[2*i+2]];\n\t\tif(max(point1,point2)==INF){\n\t\t\tseg[i]=N+1;\n\t\t}\n\t\telse if(point1>point2){\n\t\t\tseg[i]=seg[2*i+1];\n\t\t}\n\t\telse if(point1<point2){\n\t\t\tseg[i]=seg[2*i+2];\n\t\t}\n\t\telse{\n\t\t\tseg[i]=min(seg[2*i+1],seg[2*i+2]);\n\t\t}\n\t}\n\tfor(int i=0;i<R;i++){\n\t\tpoint[D[i]]+=X[i];\n\t\tint now=(1<<17)-1+D[i];\n\t\twhile(now>0){\n\t\t\tnow-=1;now/=2;\n\t\t\tint point1,point2;\n\t\t\tif(seg[2*now+1]==N+1)point1=INF;\n\t\t\telse point1=point[seg[2*now+1]];\n\t\t\tif(seg[2*now+2]==N+1)point2=INF;\n\t\t\telse point2=point[seg[2*now+2]];\n\t\t\tif(max(point1,point2)==INF){\n\t\t\t\tseg[now]=N+1;\n\t\t\t}\n\t\t\telse if(point1>point2){\n\t\t\t\tseg[now]=seg[2*now+1];\n\t\t\t}\n\t\t\telse if(point1<point2){\n\t\t\t\tseg[now]=seg[2*now+2];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tseg[now]=min(seg[2*now+1],seg[2*now+2]);\n\t\t\t}\n\t\t}\n\t\tif(lnumber!=seg[0]){\n\t\t\ttim[lnumber]+=(T[i]-lstart);\n\t\t\tlnumber=seg[0];lstart=T[i];\n\t\t}\n\t}\n\ttim[lnumber]+=(L-lstart);\n\tint ans=0;int ma=-1;\n\tfor(int i=0;i<N;i++){\n\t\t//printf(\"%d:%d\\n\",i,tim[i]);\n\t\tif(ma<tim[i]){\n\t\t\tma=tim[i];ans=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  int t=search(id,n);\n  team[t].point+=key;\n  if(key<0){\n    maxHeapify(search(id,n));\n  }\n  else{\n    while(t>1&&team[t/2].point<team[t].point){\n      swap(team[t],team[t/2]);\n      t=t/2;\n    }\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=team[top].id;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    if(i==0){\n      team[search(1,n)].showed+=t[0];\n    }\n    IncreaseKey(d[i],x[i],n);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n   // printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n  }\n // for(int i=1;i<=n;i++){\n //   printf(\"%d %d   %d\\n\",team[i].id,team[i].showed,team[i].point);\n // }\n  show_top(team,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint tp[100000],tt[100000];\nint main()\n{\n\tint N,R,L,d,t,x,time=0,Flag,max=0,maxt=0,No1;\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tmemset(tp,0,sizeof(tp));\n\tmemset(tt,0,sizeof(tt));\n\tFlag = 1;\n\tfor(int i=0;i<R;i++){\n\t\tscanf(\"%d %d %d\",&d,&t,&x);\n\t\t//printf(\"%d %d %d \",tt[1],tt[2],tt[3]);\n\t\ttt[Flag] = tt[Flag] +  (t - time);\n\t\ttime = t;\n\t\ttp[d] = tp[d] + x;\n\t\tmax = 0;\n\t\t//printf(\"Flag=%d\\n\",Flag);\n\t\tfor(int j=1;j<=N;j++){\n\t\t\tif(max < tp[j]){\n\t\t\t\tmax = tp[j];\n\t\t\t\tFlag = j;\n\t\t\t}\n\t\t}\n\t}\n\n\ttt[Flag] = tt[Flag] + ( L - t );\n\tfor(int i=1;i<=N;i++){\n\t\tif(maxt < tt[i]){\n\t\t\tmaxt = tt[i];\n\t\t\tNo1 = i;\n\t\t}\n\t}\n\t//for(int i=1;i<=N;i++)\n\t\t//printf(\"%d p:%d t:%d\\n\",i,tp[i],tt[i]);\n\tprintf(\"%d\\n\",No1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\npair<int,int> tr[100001];\nint tm[100001];\nint id[100001];\n \nint main(){\n  int n,r,l;\n  cin>>n>>r>>l;\n  for(int i=1;i<=n;i++){\n    tr[i]=make_pair(0,i);\n    id[i]=i;\n  }\n  int rt=0;\n  for(int k=0;k<r;k++){\n    int d,t,x;\n    cin>>d>>t>>x;\n    tm[tr[1].second]+=t-rt;\n    rt=t;\n    tr[id[d]].first-=x;\n    int u=id[d];\n    pair<int,int> tem;\n    if(x>0){\n      while(u!=1&&tr[u]<tr[u/2]){\n    tem=tr[u];\n    tr[u]=tr[u/2];\n    tr[u/2]=tem;\n    id[tr[u].second]=u;\n    id[tr[u/2].second]=u/2;\n    u/=2;\n      }\n    }\n    else {\n      while(2*u+1<=n&&(tr[u]>tr[2*u]||tr[u]>tr[2*u+1])){\n    int du=(tr[2*u]<tr[2*u+1])?(2*u):(2*u+1);\n    tem=tr[u];\n    tr[u]=tr[du];\n    tr[du]=tem;\n    id[tr[u].second]=u;\n    id[tr[du].second]=du;\n    u=du;\n      }\n    }\n  }\n  tm[tr[1].second]+=l-rt;\n  int maxtm=0,tmid;\n  for(int i=1;i<=n;i++){\n    if(maxtm<tm[i]){\n      tmid=i;\n      maxtm=tm[i];\n    }\n  }\n  cout<<tmid<<endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,string> P;\n\nstatic const double EPS = 1e-8;\n\nstruct Team{\npublic:\n  int id;\n  int point;\n  Team(int _id,int _p) : id(_id),point(_p){}\n  Team() : id(0),point(0){}\n\n  bool operator<(const Team& t) const{\n    if(id == t.id){\n      return point < t.point;\n    }\n    else {\n      return (id < t.id);\n    }\n  }\n  bool operator>(const Team& t) const{\n    if(id == t.id){\n      return point > t.point;\n    }\n    else {\n      return (id > t.id);\n    }\n  }\n  bool operator==(const Team& t) const{\n    return (id == t.id && point == t.point);\n  }\n};\n\nclass SegmentTree{\nprivate:\n  struct Team* points;\n  int n;\npublic:\n  SegmentTree(int _n){\n    n = 1;\n    while(n < _n) n *= 2;\n\n    points = new Team[2*n+1];\n    for(int i=0;i<2*n+1;i++){\n      points[i] = Team(i,0);\n    }\n\n  }\n\n  void insert(int idx,int p){\n    idx += n - 1;\n\n    points[idx].id = idx - (n - 1);\n    points[idx].point += p;\n\n    while(idx > 0){\n      idx = (idx - 1) / 2;\n      int lhs =idx * 2 + 1;\n      int rhs =idx * 2 + 2;\n\n      if(points[lhs].point < points[rhs].point){\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = points[rhs].id;\n      }\n      else if(points[lhs].point > points[rhs].point){\n\tpoints[idx].point = points[lhs].point;\n\tpoints[idx].id = points[lhs].id;\n      }\n      else if(points[lhs].point == points[rhs].point){\n\tint next_id = min(points[lhs].id,points[rhs].id);\n\tpoints[idx].point = points[rhs].point;\n\tpoints[idx].id = next_id;\n      }\n    }\n  }\n\n  Team query(int a,int b,int idx,int l,int r){\n    if(r <= a || b <= l) return Team(0,-100000);\n    if(a <= l && r <= b) return points[idx];\n    else{\n      Team left = query(a,b,idx * 2 + 1,1,(l+r) / 2);\n      Team right = query(a,b,idx * 2 + 2,(l+r) / 2,r);\n      if(left < right){\n\treturn right;\n      }\n      else if(left == right){\n\treturn left;\n      }\n      else if(left > right){\n\treturn left;\n      }\n    }\n  }\n};\n\nint main(){\n  int total_teams,total_records,contest_duration;\n  while(~scanf(\"%d %d %d\",\n\t       &total_teams,\n\t       &total_records,\n\t       &contest_duration)){\n    int disp_time[100001];\n    \n    memset(disp_time,0,sizeof(disp_time));\n    int prev_champ = 1;\n    int prev_time = 0;\n    SegmentTree seg_tree(total_teams);\n\n    map<int,vector<Team> > records;\n    for(int record_idx=0;record_idx<total_records;record_idx++){\n      int id,time,point;\n      scanf(\"%d %d %d\",&id,&time,&point);\n      \n      records[time].push_back(Team(id,point));\n    }\n\n    for(map<int,vector<Team> >::iterator it = records.begin();\n\tit != records.end();\n\tit++){\n      for(int i=0;i<it->second.size();i++){\n\tseg_tree.insert(it->second[i].id,it->second[i].point);\n      }\n      Team team = seg_tree.query(0,total_teams,0,0,total_teams);\n      if(prev_champ != team.id){\n\tdisp_time[prev_champ] += it->first - prev_time;\n\tprev_time = it->first;\n\tprev_champ = team.id;\n      }\n    }\n\n    disp_time[prev_champ] += contest_duration - prev_time;\n    \n    int res = 1;\n    int max_disp = 0;\n    for(int team_idx=1;team_idx <= total_teams; team_idx++){\n      if(max_disp < disp_time[team_idx]){\n\tmax_disp = disp_time[team_idx];\n\tres = team_idx;\n      }\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntypedef long long ll;\ntypedef struct {\n  int id;\n  ll sc;\n} node;\nnode dat[1<<18];\nint tim[111111];\nint n;\n\nnode max(node a,node b) {\n  if( a.sc < b.sc ) return b;\n  if( a.sc > b.sc ) return a;\n  return a.id > b.id ? b : a;\n}\n\nvoid update(int k,node x)\n{\n  k += n-1;\n  dat[k] = x;\n  while( k > 0 ) {\n    k /= 2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nint a[1111111],b[1111111],c[1111111];\n\nint main(void)\n{\n  int n_,r,l,i,j,pre,ma,res;\n  scanf(\"%d%d%d\",&n_,&r,&l);\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for( i = 0; i < n_; i++ ) dat[i+n-1].id = i;\n  for( i = 0; i < n_; i++ ) update(i,(node){i,0});\n  for( i = 0; i < r; i++ ){ scanf(\"%d%d%d\",a+i,b+i,c+i); a[i]--; }\n  b[r] = l;\n  pre = 0;\n  for( i = 0; i <= r; i++ ) {\n    tim[dat[0].id] += b[i]-pre;\n    for( j = i; j <= r && b[i] == b[j]; j++ ) {\n      update(a[j],(node){a[j],dat[a[j]+n-1].sc+c[j]});\n    }\n    i = j-1;\n    pre = b[i];\n  }\n  ma = 0;\n  res = 0;\n  for( i = 0; i < n_; i++ ) {\n    if( ma < tim[i] ) {\n      ma = tim[i];\n      res = i+1;\n    }\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint N,R,L,d[3][10000],T=0,g,p[2][10000],i,a;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i!=2;i++){\n\t\tfor(a=0;a!=N;a++){\n\t\t\tp[i][a]=0;\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tfor(a=0;a!=3;a++){\n\t\t\tscanf(\"%d\",&d[a][i]);\n\t\t}\n\t}\n\tfor(i=0;i!=R;i++){\n\t\tg=N-1;\n\t\tfor(a=g;a>=0;a--){\n\t\t\tif(p[1][a]>=p[1][g])\n\t\t\t\tg=a;\n\t\t}\n\t\tp[1][d[0][i]-1]+=d[2][i];\n\t\tif(d[1][i]!=d[1][i+1]){\n\t\t\tp[0][g]+=d[1][i]-T;\n\t\t\tT=d[1][i];\n\t\t}\n\t}\n\tg=N-1;\n\tfor(a=g;a>=0;a--){\n\t\tif(p[1][a]>=p[1][g])\n\t\t\tg=a;\n\t}\n\tp[0][g]+=L-T;\n\tg=N-1;\n\tfor(i=g;i>=0;i--){\n//\t\tprintf(\"%d %d %d\\n\",i,p[0][i],p[1][i]);\n\t\tif(p[0][g]<=p[0][i])\n\t\t\tg=i;\n\t}\n\tprintf(\"%d\\n\",g+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tpriority_queue<int, vector<pair<int, int> > > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tttime[temp.second] += t - ttemp;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint search(int id,int n){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n){\n  team[search(id,n)].point+=key;\n  maxHeapify(id);\n  while(id>1&&team[id/2].point<team[id].point){\n    swap(team[id],team[id/2]);\n    id=id/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top=team[i].id;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop=team[i].id;\n      }\n    }\n  }\n  printf(\"%d\\n\",top);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i],x[i],n);\n    printf(\"%d %d %d\\n\",team[1].id,team[1].point,team[1].showed);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\n  for(int i=1;i<=n;i++){\n    printf(\"%d %d\\n\",team[i].id,team[i].showed);\n  }\n  show_top(team,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-7;\n\n\nconst int MAX_N = 1<<20;\n \nint n;\npii dat[2*MAX_N-1];\nvoid init(int n_){\n    n = 1;\n    while(n < n_) n *= 2;\n    for(int i = 0; i < 2 * n-1; i++){\n        dat[i].fi = 0;\n        dat[i].se = -(i-n+2);\n    }\n}\n \nvoid update(int k, int add){\n    k += n-1;\n    dat[k].fi += add;\n    while(k > 0) {\n        k = (k - 1) / 2;\n        dat[k] = max(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n}\n \npii query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l) return pii(0, 0);\n    if(a <= l && r <= b) return dat[k];\n    else{\n        pii vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        pii vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n}\n\nsigned main(){\n\tint r, l;\n\tcin>>n>>r>>l;\n\tinit(n);\n\tvi v(n + 100, 0);\n\tint d, t, x, tt = 0;\n\tpii p;\n\tupdate(1, 0);\n\trep(i, r){\n\t\tcin>>d>>t>>x;\n\t\tp = query(0, n, 0, 0, n);\n\t\t//if(p.se >= 0) continue;\n\t\t//cout<<p.se<<endl;\n\t\tv[-p.se] += t - tt;\n\t\tupdate(d-1, x);\n\t\ttt = t;\n\t}\n\tp = query(0, n, 0, 0, n);\n\tv[-p.se] += l - tt;\n\n\t// int ans = 0;\n\t// for(int i = 1; i < v.size(); i++){\n\t// \tif(v[ans] < v[i]) ans = i;\n\t// \tcout<<v[i]<<endl; \n\t// }\n\t// cout<<ans<<endl;\n\tcout<<(int)(max_element(all(v))-v.begin())<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<functional>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> PP;\ntypedef pair<int,int>P;\nint wa[1000001];\nP wa2[1000001];\nint main(void)\n{\n\tpriority_queue<PP> qu;\n\tint n,r,l,yy,x1,y2,x2,t,y,x,tt,a,i;\n\tscanf(\"%d %d %d\",&n,&r,&l);\n\tfor(i=1;i<=n;i++){\n\t\twa2[i].second=-i;\n\t\twa2[i].first=0;\n\t\twa[i]=0;\n\t}\n\tfor(i=0;i<r;i++){\n\t\tscanf(\"%d %d %d\",&a,&t,&x1);\n\t\tif(i>0){\n\t\t\twa2[yy].first+=(t-tt);\n\t\t}\n\t\ttt=t;\n\t\twa[a]+=x1;\n\t\tqu.push(PP(wa[a],-a));\n\t\twhile(1){\n\t\t\tx=qu.top().first;\n\t\t\ty=-qu.top().second;\n\t\t\tif(wa[y]==x){\n\t\t\t\tyy=y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqu.pop();\n\t\t\t}\n\t\t}\n\t}\n\twa2[yy].first+=(l-t);\n\tsort(wa2+1,wa2+n+1);\n\tprintf(\"%d\\n\",-wa2[n].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<functional>\n#include<cstring>\n\nusing namespace std;\ntypedef long long ll;\nint N=1<<17;\nll dat[1<<18];\nint id[1<<18];\nint n,r,l;\nint d[1000001],t[1000001],x[1000001];\nint timel[100001];\n\nvoid init(){\n\tmemset(dat,0,sizeof(dat));\n\tfor(int i=N;i<N*2;i++)id[i]=i-N;\n}\n\nvoid update(int k,ll a){\n\tk+=N-1;\n\tdat[k]+=a;\n\twhile(k>0){\n\t\tk=(k-1)/2;\n\t\tif(dat[k*2+1]>=dat[k*2+2]){\n\t\t\tdat[k]=dat[k*2+1];\n\t\t\tid[k]=id[k*2+1];\n\t\t}else{\n\t\t\tdat[k]=dat[k*2+2];\n\t\t\tid[k]=id[k*2+2];\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(int i=0;i<r;i++)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\tint nt=0;\n\tinit();\n\tfor(int i=0;i<r;i++){\n\t\ttimel[id[0]]+=t[i]-nt;\n\t\tnt=t[i];\n\t\tupdate(d[i],x[i]);\n\t}\n\ttimel[id[0]]+=l-nt;\n\tint sum=0,rid=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(sum<timel[i])sum=timel[i],rid=i;\n\t}\n\tprintf(\"%d\\n\",rid+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int INF = 100010;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint N, R, L;// ???????????°?????¬???????????°????????????????????????????????????\n\tint d, t, x;// ?????????????????????????????????????§?t?§???? ????????????or??????\n\tcin >> N >> R >> L;\n\tint ttime[INF]; // ??????????????¨????????????\n\tint tpoint[INF];\n\tpair<int, int> temp;\n\tmemset(ttime, 0, sizeof(ttime));// team ?????????\n\tmemset(tpoint, 0, sizeof(tpoint));\n\tint ttemp = 0; // ????????????\n\tttime[1] = 100;\n\tpriority_queue<pair<int,int> > que;\n\tfor (int i = 0; i < R; i++){\n\t\tcin >> d >> t >> x;\n\t\ttpoint[d] += x;\n\t\tif(i != 0)ttime[temp.second] += t - ttemp;\n\t\t//cout << i << \"  \" << temp.second << \"  \" << ttime[temp.second] << endl;\n\t\tfor (int team = N; team >= 1; team--){\n\t\t\tpair<int, int> p;\n\t\t\tp.first = tpoint[team]; p.second = team;\n\t\t\tque.push(p);\n\t\t}\n\t\ttemp = que.top(); while (!que.empty()) que.pop();\n\t\tttemp = t;\n\t}\n\tttime[temp.second] += L - ttemp;\n\tint MAX = -1999999; int answer = 0;\n\tfor (int i = 1; i <= N; i++){\n\t\t//cout << ttime[i] << \"   \" << tpoint[i] << endl;\n\t\tif (MAX < ttime[i]){\n\t\t\tanswer = i; MAX = ttime[i];\n\t\t}\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nTeam team[100000];\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest);\n  }\n}\nint extract(Team* team){\n  int maxv;\n  maxv=team[0].id;\n  //  team[1]=team[H--];\n  //  maxHeapify(1);\n  return maxv;\n}\nvoid IncreaseKey(int i,int key){\n  team[i].point+=key;\n  while(i>1&&team[i/2].point<team[i].point){\n    swap(team[i],team[i/2]);\n    i=i/2;\n  }\n}\nvoid insert(int id){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=0;\n  for(int i=0;i<n;i++){\n    if(team[i].showed>team[top].showed) top=i;\n  }\n  printf(\"%d\\n\",top+1);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=0;i<n;i++){\n    insert(i);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    IncreaseKey(d[i]-1,x[i]);\n    Team top=team[extract(team)];\n    if(i==0){\n      top.showed+=t[0];\n    }\n    else if(i<r-1){\n    top.showed+=t[i+1]-t[i];\n    }\n    else{\n      top.showed+=l-t[r-1];\n    }\n  }\n  show_top(team,n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <map>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\n\nint p[1000005];\n\n//max\nstruct Seg\n{\n\tint n;\n\tvector<int> dat,id;\n\n\tSeg(int n_)\n\t{\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\n\t\tdat.resize(2*n-1);\n\t\trep(i,2*n-1) dat[i] = -INF;\n\n\t\tid.resize(2*n-1);\n\t\trep(i,n) update(i,INF);\n\t}\n\n\tvoid update(int k,int a)\n\t{\n\t\tk += n-1;\n\t\tdat[k] += a;\n\t\tid[k] = k-n+1;\n\n\t\twhile(k > 0)\n\t\t{\n\t\t\tk = (k-1) / 2;\n\t\t\tif(dat[k*2+1] == dat[k*2+2])\n\t\t\t{\n\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\tid[k] = id[k*2+1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dat[k*2+1] > dat[k*2+2])\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+1];\n\t\t\t\t\tid[k] = id[k*2+1];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdat[k] = dat[k*2+2];\n\t\t\t\t\tid[k] = id[k*2+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main()\n{\n\tint n,r,l;\n\tcin >> n >> r >> l;\n\n\t//time id,point\n\tmap<int,vector<pair<int,int> > > m;\n\trep(i,r)\n\t{\n\t\tint d,t,x;\n\t\tcin >> d >> t >> x;\n\n\t\tm[t].push_back(make_pair(d,x));\n\t}\n\n\tvector<int> v(n);\n\tmemset(p,0,sizeof(p));\n\tSeg seg(n);\n\n\tint top_id = seg.id[0],pre_time = 0;\n\tmap<int,vector<pair<int,int> > >::iterator ite;\n\tfor(ite = m.begin(); ite != m.end(); ite++)\n\t{\n\t\tint d,t,x;\n\t\tt = ite->first;\n\n\t\tv[top_id] = t - pre_time;\n\t\tpre_time = t;\n\n\t\trep(i,m[t].size())\n\t\t{\n\t\t\td = m[t][i].first;\n\t\t\tx = m[t][i].second;\n\n\t\t\t// p[d] += x;\n\t\t\t// seg.update(d-1,p[d]);\n\t\t\tseg.update(d-1,x);\n\t\t\ttop_id = seg.id[0];\n\t\t}\n\n\t}\n\n\tv[top_id] += l - pre_time;\n\n\tint res = 0;\n\trep(i,n)\n\t{\n\t\tres = max(res,v[i]);\n\t}\n\n\trep(i,n)\n\t{\n\t\tif(res == v[i])\n\t\t{\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define F first\n#define S second\n#define INF 1>>20\nusing namespace std;\ntypedef pair<int,int> P;\nvoid update(int k,int x);\nvoid init(int n_);\nP pamax(P a,P b);\nP seg[1111111];\nint n,r,l;//左からチーム数、レコード数、制限時間\nint main(){\n  int time[1111111]={0};\n  int top=0,btime=0;\n  int d,t,x;//左からチームID、獲得した時間、加減得点\n  cin >> n >> r >> l;\n  init(n);\n  for(int i=0;i<r;i++){\n    cin >> d >> t >> x;\n    time[top]+=t-btime;\n    btime=t;\n    update(d-1,x);//チームIDと加減得点\n    top=seg[0].F;//一位奴の更新\n  }\n  time[top]+=l-btime;\n  top=0;\n  time[0]=-11111;\n  for(int i=1;i<=n;i++){//映ってる時間がもっとも多いチームを調べる\n    if(time[top]<time[i])top=i;\n  }\n  cout << top << endl;\n}\n\nvoid init(int n_){\n  int n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<n;i++){\n    seg[i]=P(0,0);\n  }\n}\n\nvoid update(int k,int x){\n  int id=k+1;\n  k+=n-1;\n  seg[k].F=id;\n  seg[k].S+=x;\n  while(k>0){\n    k=(k-1)/2;\n    seg[k]=pamax(seg[k*2+1],seg[k*2+2]);\n  }\n}\n\nP pamax(P a,P b){\n  int x,y;\n  x=a.S;\n  y=b.S;\n  if(x<y)return b;\n  else return a;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define fr first\n#define sc second\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int INF = (1<<25);\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n  priority_queue<pii >q;\n  int N,R,L,S[1000001],T[1000001],d,t,x;\n\n  cin>> N>> R>> L;\n  q.push(pii(0,-1));\n\n  for(int i=0;i<=N;i++) S[i]=T[i]=0;\n  int pret=0,pred=1;\n\n  for(int i=0;i<R;i++){\n    cin>> d>> t>> x;\n    S[d]+=x;\n    q.push(pii(S[d],-d));\n    while(1){\n      pii p=q.top();\n      if(p.fr==S[-p.sc]){\n\tT[pred]+=t-pret;\n\tpred=-p.sc;\n\tpret=t;\n\tbreak;\n      }\n      q.pop();\n    }\n  }\n  T[pred]+=L-pret;\n  int max=-INF;\n  int ans=0;\n  for(int i=1;i<=N;i++){\n    if(max<T[i]){\n      max=T[i]; ans=i;\n    }\n  }\n  cout<< ans<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define N 1000007\nint x[N], y[N], s[N];\n\nint main() {\n  cin.tie(0); ios_base::sync_with_stdio();\n  int n, r, l;\n  cin >> n >> r >> l;\n\n  int n0 = 1;\n  while(n0 < n) n0 <<= 1;\n  for(int i=0; i<n; ++i) {\n    int j = (y[i+n0] = i), k = i+n0;\n    while(!(k&1)) y[k >>= 1] = j;\n  }\n  int prv = 0;\n  for(int i=0; i<r; ++i) {\n    int d, t, p; cin >> d >> t >> p;\n    s[y[1]] += t - prv;\n    d += n0-1;\n    x[d] += p;\n    while(d) {\n      if(x[d] < x[d^1] || (x[d] == x[d^1] && y[d] > y[d^1])) {\n        x[d>>1] = x[d^1]; y[d>>1] = y[d^1];\n      } else {\n        x[d>>1] = x[d]; y[d>>1] = y[d];\n      }\n      d >>= 1;\n    }\n    prv = t;\n  }\n  s[y[1]] += l - prv;\n  int t = -1, a = -1;\n  for(int i=0; i<n; ++i) {\n    if(t < s[i]) {\n      t = s[i]; a = i;\n    }\n  }\n  cout << a+1 << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint N,R,L;\nint p[100010];\nint T[100010];\n\nint main(){\n\t//cin.tie(0);\n\t//ios_base::sync_with_stdio(0);\n\t\n\tscanf(\"%d %d %d\",&N,&R,&L);\n\tset<pair<int,int>> S;\n\trep(i,R){\n\t\tS.insert(mp(0,i));\n\t}\n\tint preT = 0;\n\tint preID = 0;\n\trep(i,R){\n\t\tint d,t,x;\n\t\tscanf(\" %d %d %d\",&d,&t,&x);\n\t\td--;\n\t\tT[preID] += t - preT;\n\t\tS.erase(mp(p[d],d));\n\t\tS.insert(mp(p[d]-=x,d));\n\t\tpreID = (*(S.begin())).sec;\n\t\tpreT = t;\n\t}\n\tT[preID] += L - preT;\n\tint ans=0;\n\t//rep(i,N)printf(\"%d \",T[i]);\n\trep2(i,1,N){\n\t\tif(T[i] > T[ans])ans=i;\n\t}\n\tprintf(\"%d\\n\",ans+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define pque priority_queue\n#define pu push\n#define fr first\n#define sc second\n#define sa static\n\nstruct com{\n\tbool operator()(P x,P y){\n\t\tif(x.fr==y.fr)return x.sc>y.sc;\n\t\treturn x.fr<y.fr;\n\t}\n};\n\nint main(){\n\tsa int n,r,l;\n\tsa int d[100010],t[100010],x[100010];\n\t\n\tcin>>n>>r>>l;\n\trep(i,r)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\td[r]=0; t[r]=l; x[r]=0;\n\t\n\tsa int ret[100010]={0};\n\tsa int p[100010]={0};\n\tsa int T=0;\n\tpque<P,vector<P>,com> Q; rep(i,n)Q.pu(P(0,i+1));\n\t\n\trep(i,r+1){\n\t\tif(t[i]>T){\n\t\t\twhile(p[Q.top().sc]!=Q.top().fr)Q.pop();\n\t\t\tret[Q.top().sc]+=t[i]-T; //cout<<Q.top().sc<<\" \"<<t[i]-T<<endl;\n\t\t\tT=t[i];\n\t\t}\n\t\tp[d[i]]+=x[i]; Q.pu(P(p[d[i]],d[i]));\n\t}\n\t\n\tint Ret=0,Max=0;\n\trep(i,n){\n\t\t//cout<<i+1<<\" \"<<ret[i+1]<<endl;\n\t\tif(ret[i+1]>Max){ Ret=i+1; Max=ret[i+1]; }\n\t}\n\t\n\tcout<<Ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint max(int *p,int N){\n  int top=1;\n  for(int i=2;i<=N;i++){\n    if(p[top]<p[i]) top = i;\n  }\n  return top;\n}\nint main(){\n  int N,R,L,d,t,x,old=1,oldt=0;\n  cin >> N >> R >> L;\n  int pt[N+1],ptime[N+1];\n  for(int i=0;i<=N;i++) pt[i]=ptime[i]=0;\n  for(int i=0;i<R;i++){\n    cin >> d >> t >> x;\n    ptime[old] += (t-oldt);\n    oldt = t;\n    pt[d] += x;\n    if(x>=0){\n      if(pt[old]<pt[d]) old = d;\n    }else old = max(pt,N);\n  }\n  //cout << t << ' ' << oldt << endl;\n  ptime[old] += (L-t);\n  int ans;\n  int kt = 0;\n  for(int i=1;i<=N;i++){\n    if(kt<ptime[i]){\n      ans = i;\n      kt=ptime[i];\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\n  int N,R,L;\n\n  cin >> N >> R >> L;\n\n  \n  pair <int,int>  score[100001];\n  long long time[100001];\n\n\n  for(int i=1;i<=N;i++) {\n    score[i]=make_pair(0,i);\n    time[i] = 0;\n  }\n\n  score[0].first = -10000000;  \n\n  int  mae = 0;\n  \n  int d,t,x;\n  for(int i=0;i<R;i++) {\n    cin >> d >> t >> x;\n\n    int site1;\n    for(int j=1;j<=N;j++){\n      if(score[j].second == d) {\n\tsite1 = j;\n\tbreak;\n      }\n    }\n    \n    \n    time[score[1].second] += t - mae;\n    score[site1].first -= x;\n    mae = t;\n        \t \n    \n    pair <int , int > tmp;  \n    if(x>0){ \n      while(site1!=1) {\n\tif(score[site1] < score[site1/2] ) {\n\t  tmp = score[site1];\n\t  score[site1] = score[site1/2];\n\t  score[site1/2] = tmp;\n\t  site1 = site1/2;\n\t} else break;\n      }\n    }\n    else {\n      while(1) {\n\tif(2*site1+1<= N &&( score[2*site1] < score[site1] || score[2*site1+1] < score[site1])) {\n\t  int flg = 0;\n\t  if(score[2*site1+1] < score[site1] &&score[2*site1] > score[2*site1+1]) flg = 1;\n\t  tmp = score[site1];\n\t  score[site1] = score[2*site1+flg];\n\t  score[2*site1+flg] = tmp;\n\t  site1 = 2*site1+flg;\n\t}else break;\n      }\n    }\n    /*    for(int j=1;j<=N;j++) cout<<score[j].second;\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<score[j].first <<\" \";\n    cout << endl;\n    for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n    cout << endl;\n    */\n  }\n\n\n  time[score[1].second] += L-t;\n\n  //  for(int j=1;j<=N;j++) cout <<time[j] << \" \";\n  // cout << endl;\n\n\n\n  int maxtime = -1;\n  int ans;\n  for(int i=1;i<=N;i++) \n    if(maxtime < time[i]) maxtime = time[i] ,ans = i;\n\n\n  cout << ans << endl;\n\n  return 0;\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define MP make_pair\n#define F first\n#define S second\n\ntypedef pair<int, int> P;\n\nint N, R, L;\nint point[100005];\nint res[100005];\n\nint main(){\n  scanf(\"%d%d%d\", &N, &R, &L);\n  int now = 0;\n  memset(point, 0, sizeof(point));\n  memset(res, 0, sizeof(res));\n\n  priority_queue<P>q;\n  rep(i, N) q.push(P(0, -i));\n  rep(i, R){\n    //    printf(\"%d\\n\", i);\n\n    int d, t, x;\n    scanf(\"%d%d%d\", &d, &t, &x);d--;\n    //    printf(\"%d %d %d\\n\", d, t, x);\n\n    //    printf(\"%d\\n\", i);\n    P p = q.top(); q.pop();\n    while(p.F != point[-p.S]){\n      p = q.top(); q.pop();\n    }\n    q.push(p);\n\n    res[-p.S] += t - now;\n    now = t;\n\n    point[d] += x;\n    //    printf(\"%d\\n\", d);\n    //    rep(j, N) printf(\"%d \", point[j]); puts(\"\");\n    q.push(P(point[d], -d));\n  }\n\n  P p = q.top(); q.pop();\n  while(p.F != point[-p.S]){\n    //    printf(\"%d %d\\n\", p.F, point[-p.S]);\n    p = q.top(); q.pop();\n  }\n  //  printf(\"%d %d\\n\", p.F, point[-p.S]);\n  res[-p.S] += L - now;\n\n  //  rep(i, N) printf(\"%d \", res[i]); puts(\"\");\n  int team = 0;\n  rep(i, N) if(res[team] < res[i]) team = i;\n  printf(\"%d\\n\", team+1);\n  exit(0);\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct D{\n    int pnt,id;\n    D(int a,int b):pnt(a),id(b){}\n    D(){}\n\n    bool operator<(const D &d)const{\n        return pnt!=d.pnt?pnt<d.pnt:id>d.id;\n    }\n};\n\nint N,R,L;\nint d[100001],t[100001],x[100001];\nint pnt[100000];\nint cnt[100000];\nsigned main(){\n    cin>>N>>R>>L;\n    for(int i=0;i<R;i++)cin>>d[i]>>t[i]>>x[i],d[i]--;\n    d[R]=0;t[R]=L;x[R]=0;\n\n\n    priority_queue<D>Q;\n\n    for(int i=0;i<N;i++)Q.push(D(0,i));\n\n    int cur=0;\n    while(cur<R){\n        pnt[d[cur]]+=x[cur];\n        Q.push(D(pnt[d[cur]],d[cur]));\n        while(cur<R-1&&t[cur]==t[cur+1]){\n            cur++;\n            pnt[d[cur]]+=x[cur];\n            Q.push(D(pnt[d[cur]],d[cur]));\n        }\n\n        while(Q.top().pnt!=pnt[Q.top().id])Q.pop();\n        cnt[Q.top().id]+=t[cur+1]-t[cur];\n\n        cur++;\n    }\n\n    cnt[0]+=x[0];\n\n    int ma=0;\n    for(int i=1;i<N;i++)if(cnt[ma]<cnt[i])ma=i;\n    cout<<ma+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> PA;\ntypedef pair<int,PA> PPA;\n\nint po[100010]={};\nint sa[100010]={};\npriority_queue<PA> pq;\nvector<PPA> vec;\n\nint main(){\n  \n  int n,r,l,d,t,x;\n  \n  cin >> n >> r >> l;\n  \n  for(int i=0;i<r;i++){\n    cin >> d >> t >> x;  \n    vec.push_back(PPA(t,PA(x,d)));\n  }\n  \n  vec.push_back(PPA(l,PA(0,0)));\n  sort(vec.begin(),vec.end());\n  \n  for(int i=1;i<=n;i++){\n    pq.push(PA(0,-i));\n  }  \n\n  int in;\n  PA p;\n  \n  sa[1] = vec[0].first;\n\n  for(int i=0;i<r;i++){\n    \n    int dif = abs(vec[i].first - vec[i+1].first);\n    \n    p = vec[i].second;\n    int next_x = p.first;\n    int next_d = p.second;\n    po[next_d] += next_x;\n    pq.push( PA(po[next_d],-next_d) );\n    \n    while(!pq.empty()){\n      p = pq.top();\n      if(po[-p.second] != p.first) pq.pop();\n      else break;\n    }\n    \n    p = pq.top();\n    sa[-p.second] += dif;\n    \n  }\n\n  int ans = 1;\n  for(int i=1;i<=n;i++){\n    if(sa[ans] < sa[i]) ans = i;\n  }\n\n  cout << ans << endl;\n\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int N, R, L;\n    while(cin >> N >> R >> L && N){\n        const int B = sqrt(N);\n        vector<int> bucket((N - 1) / B + 1);\n        vector<int> point(N + B, INT_MIN);\n        REP(i, N) point[i] = 0;\n        int last_time = 0;\n        int camera_id = 0;\n        vector<int> answer(N);\n        for(int i = 0; i < R; i++){\n            int d, t, x;\n            scanf(\"%d %d %d\", &d, &t, &x);\n            d--;\n            point[d] += x;\n            if(point[d] > bucket[d / B]){\n                bucket[d / B] = point[d];\n            }else if(point[d] - x == bucket[d / B]){\n                bucket[d / B] = *max_element(point.begin() + (d / B) * B, point.begin() + (d / B + 1) * B);\n            }\n            answer[camera_id] += t - last_time;\n            last_time = t;\n            if(camera_id == d && x < 0){\n                int k = max_element(bucket.begin(), bucket.end()) - bucket.begin();\n                camera_id = max_element(point.begin() + k * B, point.begin() + (k + 1) * B) - point.begin();\n            }else if(point[d] > point[camera_id]){\n                camera_id = d;\n            }else if(point[d] == point[camera_id] && d < camera_id){\n                camera_id = d;\n            }\n            assert(camera_id >= 0 && camera_id < N);\n            //REP(i, N) cout << point[i] << \" \"; cout << endl;\n            //REP(i, (N - 1) / B + 1) cout << bucket[i] << \" \"; cout << endl;\n            //printf(\"time:%d point[%d] += %d camera: %d\\n\", t, d + 1, x, camera_id + 1);\n        }\n        answer[camera_id] += L - last_time;\n        cout << max_element(answer.begin(), answer.end()) - answer.begin() + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 1145141919\n#define SIZE1 131072\n#define SIZE2 262144\nusing namespace std;\n\nclass segtree{\n\tint score[SIZE1];\n\tint tree[SIZE2];//not use 0;\npublic:\n\tvoid reset(int n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscore[i] = 0;\n\t\t}\n\t\tfor (int i = n; i < SIZE1; i++){\n\t\t\tscore[i] = -INF;\n\t\t}\n\t\tfor (int i = SIZE2 - 1; i >= SIZE1; i--){\n\t\t\ttree[i] = i - SIZE1;\n\t\t}\n\t\tfor (int i = SIZE1 - 1; i >= 1; i--){\n\t\t\ttree[i] = tree[i * 2];\n\t\t}\n\t\treturn;\n\t}\n\tvoid setting(int team, int up){\n\t\tscore[team] += up;\n\t\tint now = team + SIZE1;\n\t\twhile (now != 1){\n\t\t\tnow /= 2;\n\t\t\ttree[now] = (score[tree[now * 2]] < score[tree[now * 2 + 1]]) ? tree[now * 2 + 1] : tree[now * 2];\n\t\t}\n\t\treturn;\n\t}\n\tint top(){\n\t\treturn tree[1];\n\t}\n};\n\nint n, r, l, ans = 0;\nint tim[100000];\nint d[1000002], t[1000002], x[1000002];\nsegtree s;\nint main()\n{\n\tcin >> n >> r >> l;\n\ts.reset(n);\n\tfor (int i = 1; i <= r; i++){\n\t\tcin >> d[i] >> t[i] >> x[i];\n\t}\n\tt[r + 1] = l;\n\tint nowtop = 0;\n\tfor (int i = 1; i <= r + 1; i++){\n\t\ts.setting(d[i] - 1, x[i]);\n\t\ttim[nowtop] += t[i] - t[i - 1];\n\t\tnowtop = s.top();\n\t}\n\tfor (int i = 1; i < n; i++){\n\t\tif (tim[ans] < tim[i]) ans = i;\n\t}\n\tcout << ans + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct Team{\n  int id;\n  int point;\n  int showed;\n};\nint H=0;\nvoid swap(int *a,int *b){\n  int tmp;\n  tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\nvoid maxHeapify(int i,Team* team){\n  int l,r,largest;\n  l=2*i;\n  r=2*i+1;\n\n  if(l<=H&&team[l].point>team[i].point){\n    largest=l;\n  }\n  else if(team[l].point==team[i].point){\n    if(team[l].id<team[i].id){\n      largest=l;\n    }\n  }\n  else largest=i;\n  if (r<=H&&team[r].point>team[largest].point){\n    largest=r;\n  }\n  else if(team[r].point==team[largest].point){\n    if(team[r].id<team[largest].id){\n      largest=r;\n    }\n  }\n  if(largest!=i){\n    swap(team[i],team[largest]);\n    maxHeapify(largest,team);\n  }\n}\nint search(int id,int n,Team* team){\n  for(int i=1;i<=n;i++){\n    if(team[i].id==id){\n      return i;\n    }\n  }\n}\nvoid IncreaseKey(int id,int key,int n,Team* team){\n  int t=search(id,n,team);\n  team[t].point+=key;\n  if(key<0){\n    maxHeapify(search(id,n,team),team);\n  }\n  else{\n    while(t>1&&team[t/2].point<team[t].point){\n      swap(team[t],team[t/2]);\n      t=t/2;\n    }\n  }\n}\nvoid insert(int id,Team* team){\n  H++;\n  team[H].id=id;\n  team[H].point=0;\n  team[H].showed=0;\n}\nvoid show_top(Team* team,int n){\n  int top=1;\n  int top_id=team[top].id;\n  for(int i=1;i<=n;i++){\n    if(team[i].showed>team[top].showed) top_id=team[i].id,top=i;\n    else if(team[i].showed==team[top].showed){\n      if(team[i].id<team[top].id){\n\ttop_id=team[i].id,top=i;\n      }\n    }\n  }\n  printf(\"%d\\n\",top_id);\n}\n  \nint main(){\n  int n,r,l;\n  scanf(\"%d%d%d\",&n,&r,&l);\n  Team team[n];\n  int d[r];\n  int t[r];\n  int x[r];\n  for(int i=1;i<=n;i++){\n    insert(i,team);\n  }\n  for(int i=0;i<r;i++){\n    scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n  }\n  for(int i=0;i<r;i++){\n    if(i==0){\n      team[search(1,n,team)].showed+=t[0];\n    }\n    IncreaseKey(d[i],x[i],n,team);\n    if(i<r-1){\n      team[1].showed+=t[i+1]-t[i];\n    }\n    else{\n      team[1].showed+=l-t[r-1];\n    }\n  }\nshow_top(team, n);\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max score team\n\tprivate static int getMaxScoreTeam(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max show time team\n\tprivate static int getMaxShowTimeTeam(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\t// FIXME: ???????????????????????????????????????????????§???????????§???????????????????????????\n\t\t\tint previousMaxTeam = 1;\n\t\t\tlong previousMaxScore = 0;\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\n\t\t\t\t\t// Add show time\n\t\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\t\tteamShowTimeMap[previousMaxTeam] += showTime;\n\n\t\t\t\t\t// Update currentTime\n\t\t\t\t\ttimer = record[TIME];\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\t\t\t\t// Update max score\n\t\t\t\tif (previousMaxScore < teamScoreMap[record[TEAM_NO]]) {\n\t\t\t\t\t// If over, update max score and team\n\t\t\t\t\tpreviousMaxTeam = record[TEAM_NO];\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[record[TEAM_NO]];\n\n\t\t\t\t} else if(previousMaxTeam == record[TEAM_NO] && record[SCORE] < 0) {\n\t\t\t\t\t// If max score is decreased, search max score again\n\t\t\t\t\tpreviousMaxTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[previousMaxTeam];\n\n\t\t\t\t}\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tif (endTime != timer) {\n\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\tint showTime = endTime - timer;\n\t\t\t\tteamShowTimeMap[previousMaxTeam] += showTime;\n\t\t\t}\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxShowTimeTeam(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n\tint N,R,L,d,t,x,i,time=0,team,T[100001],P[100001],i2,max;\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tfor(i=0;i<=R;i++){\n\t\tT[i]=0;\n\t\tP[i]=0;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tP[d]+=x;\n\t\tmax=0;\n\t\tif(i!=1){\n\t\t\tfor(i2=1;i2<=R;i2++){\n\t\t\t\tif(P[i2]>P[max]){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t\telse if(P[i2]==P[max]&&i2<max){\n\t\t\t\t\tmax=i2;\n\t\t\t\t}\n\t\t\t}\n\t\tT[team]+=t-time;\n\t\t}\n\t\ttime=t;\n\t\tteam=max;\n\t\tT[0]=0;\n\t}\n\tif(time!=600){\n\t\tT[max]=600-time;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tif(T[i]>T[max]){\n\t\t\tmax=i;\n\t\t}\n\t\telse if(T[i]==T[max]&&i<max){\n\t\t\tmax=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//AOJ0099とほぼ同じ。座標圧縮がいらない。\n//1位の見つけ方→1位が得点(順位そのまま),1位以外が得点(1位と得点したチームを比べる),1位以外が減点(順位そのまま),1位が減点(O(N)で1位を探す)\n//欠点：最悪計算量O(N^2)\n#include<iostream>\n#define rep(j,n) for(j = 0;j < n;j++)\nusing namespace std;\n\nint N,R,L;\t//チーム数 <= 10^5,レコード数 <= 10^6,競技時間\nint n[1000000],t[1000000],x[1000000];\n\nint score[100000];\nint time[100000];\n\nint main(){\n\tint i,j;\n\tint num = 0;\t//今最高得点の奴の番号\n\tcin >> N >> R >> L;\n\trep(i,R){\n\t\tcin >> n[i] >> t[i] >> x[i];\n\t\tn[i]--;\n\t}\n\ttime[0] = t[0];\n\n\trep(i,R){\n\t\t//cout << \"num = \" << num << endl;\n\t\tscore[ n[i] ] += x[i];\n\t\t//1位がそのまま\n\t\tif( (n[i] == num && x[i] >= 0) || (n[i] != num && x[i] <= 0) ){\n\t\t\tif(i < R-1)\n\t\t\t\ttime[ num ] += t[i+1] - t[i];\n\t\t\telse\n\t\t\t\ttime[ num ] += L - t[i];\n\t\t\tcontinue;\n\t\t}\n\t\t//1位と今のチームを比べる\n\t\tif( n[i] != num && x[i] >= 0 ){\n\t\t\tif( ( score[ num ] > score[ n[i] ] ) || ( score[ num ] == score[ n[i] ] && num < n[i] ) ){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum = n[i];\n\t\t\t}\n\t\t\tif(i < R-1)\n\t\t\t\ttime[ num ] += t[i+1] - t[i];\n\t\t\telse\n\t\t\t\ttime[ num ] += L - t[i];\n\t\t\tcontinue;\n\t\t}\n\t\t//1位を調べなおす\n\t\tfor( j = 0; j < N; j++){\n\t\t\tif( ( score[ num ] > score[ j ] ) || ( score[ num ] == score[ j ] && num < j ) ){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum = j;\n\t\t\t}\n\t\t}\n\t\tif(i < R-1)\n\t\t\ttime[ num ] += t[i+1] - t[i];\n\t\telse\n\t\t\ttime[ num ] += L - t[i];\n\t}\n\tint MAX = 0,ANS = 0;\n\tfor(j = 0;j < N;j++){\n\t\tif(MAX < time[j]){\n\t\t\tMAX = time[j];\n\t\t\tANS = j;\n\t\t}\n\t}\n\tANS++;\n\tcout << ANS << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\npair<int,int> tr[100001];\nint tm[100001];\nint id[100001];\n\nint main(){\n  int n,r,l;\n  cin>>n>>r>>l;\n  for(int i=1;i<=n;i++){\n    tr[i]=make_pair(0,i);\n    id[i]=i;\n  }\n  int rt=0;\n  for(int k=0;k<r;k++){\n    int d,t,x;\n    cin>>d>>t>>x;\n    tm[tr[1].second]+=t-rt;\n    rt=t;\n    tr[id[d]].first-=x;\n    int u=id[d];\n    pair<int,int> tem;\n    if(x>0){\n      while(u!=1&&tr[u]<tr[u/2]){\n\ttem=tr[u];\n\ttr[u]=tr[u/2];\n\ttr[u/2]=tem;\n\tid[tr[u].second]=u;\n\tid[tr[u/2].second]=u/2;\n\tu/=2;\n      }\n    }\n    else {\n      while(2*u+1<=n&&(tr[u]>tr[2*u]||tr[u]>tr[2*u+1])){\n\tint du=(tr[2*u]<tr[2*u+1])?(2*u):(2*u+1);\n\ttem=tr[u];\n\ttr[u]=tr[du];\n\ttr[du]=tem;\n\tid[tr[u].second]=u;\n\tid[tr[du].second]=du;\n\tu=du;\n      }\n    }\n  }\n  tm[tr[1].second]+=l-rt;\n  int maxtm=0,tmid;\n  for(int i=1;i<=n;i++){ \n    if(maxtm<tm[i]){\n      tmid=i;\n      maxtm=tm[i];\n    }\n  }\n  cout<<tmid<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair< long long, long long > P;\ntypedef pair< long long, P > PP;\ntypedef pair< P, P > PPP;\n\nconst long long MOD = 1e9 + 7;\nconst long long  INF = 5e18;\nconst double DINF = 5e14;\nconst double eps = 1e-10;\nconst int di[4] = { 1,0,-1,0 }, dj[4] = { 0,1,0,-1 };\n\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define pb push_back\n#define eb emplace_back\n#define fr first\n#define sc second\n\n\n\n\nint n, r, L, d, t, x, ans, mx = -1000000010;\nint tt[100010], s[100010];\npriority_queue<P>pq;\nvector<long long>v;\n\nint main() {\n\tcin >> n >> r >> L;\n\tpq.push(P(0, -1));\n\tint now = 1, remain = 0;\n\tfor (int i = 0;i < r;i++) {\n\t\tcin >> d >> t >> x;\n\t\ts[d] += x;\n\t\tpq.push(P(s[d], -d));\n\t\twhile (true) {\n\t\t\tP p = pq.top();\n\t\t\tif (p.fr == s[-p.sc]) {\n\t\t\t\ttt[now] += t - remain;\n\t\t\t\tnow = -p.sc;\n\t\t\t\tremain = t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t}\n\ttt[now] += L - remain;\n\tfor (int i = 1;i <= n;i++) {\n\t\tif (mx < tt[i])ans = i, mx = tt[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nconst int INF = 1<<28;\ntypedef pair<long long, int> P;\n\nint n;\nP team[2 * (1<<20)];\n\nvoid init(int _n){\n\tn = 1;\n\twhile(_n > n)\n\t\tn *= 2;\n\tfor(int i = 0; i < 2 * n - 1; ++i){\n\t\tteam[i] = P(-INF, -1000000);\n\t}\n}\n\nvoid update(int k, int a){\n\tk += (n - 1);\n    team[k] = P(a, -(k - n + 1));\n\twhile(k > 0){\n\t\tk = (k - 1) / 2;\n\t\tteam[k] = max(team[k * 2 + 1], team[k * 2 + 2]);\n\t}\n}\n\nint main() {\n\tlong long p[100010] = {0};\n\tint m, r, l;\n\tcin >> m >> r >> l;\n\n\tinit(m);\n\tfor(int i = 0; i < m; ++i)\n\t\tupdate(i, 0);\n\tint d, t, x, prev = 0;\n\t\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\tp[-team[0].second] += (t - prev);\n\t\tupdate(d - 1, team[n + d - 2].first + x);\n\t\tprev = t;\n\t\t\n\t}\n\tp[-team[0].second] += (l - t);\n\t\n    /*for(int i = 0; i < m; ++i)\n        cout << p[i] << endl;*/\n\tint rank[100010] = {0};\n\tfor(int i = 0; i < m; ++i)\n\t\trank[i] = p[i];\n\tstable_sort(p, p + n, greater<int>());\n    for(int i = 0; i < m; ++i){\n        if(rank[i] == p[0]){\n\t\t\tcout << i + 1 << endl;\n            return 0;\n        }   \n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, R, L, D, T, X, M[100000], A[100000]; vector<pair<int, int> > F[1000000]; // (team, score)\nint main() {\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\tfor (int i = 0; i < R; i++) {\n\t\tscanf(\"%d%d%d\", &D, &T, &X);\n\t\tF[T].push_back(make_pair(D - 1, X));\n\t}\n\tpriority_queue<pair<int, int> > que;\n\tfor (int i = 0; i < N; i++) {\n\t\tque.push(make_pair(0, -i));\n\t}\n\tfor (int i = 0; i < L; i++) {\n\t\tfor (int j = 0; j < F[i].size(); j++) {\n\t\t\tM[F[i][j].first] += M[F[i][j].second];\n\t\t\tque.push(make_pair(M[F[i][j].first], -F[i][j].first));\n\t\t}\n\t\tpair<int, int> p;\n\t\twhile (!que.empty()) {\n\t\t\tp = que.top();\n\t\t\tif (p.first == M[-p.second]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tA[-p.second]++;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] > A[ret]) {\n\t\t\tret = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\n//RMQ\nstruct SegmentTree{\nprivate:\n\tint N;\n\tvector<long long> node, lazy;\n\tvector<bool> lazyFlg;\n\tconst long long DEFAULT = 0LL;\npublic:\n\tvoid init(int n){ //初期化 O(N)\n\t\tnode.clear();\n\t\tlazy.clear();\n\t\tlazyFlg.clear();\n\t\tN = 1;\n\t\twhile(N < n) N = (N<<1);\n\t\tfor(int i=0; i<2*N-1; i++){\n\t\t\tnode.push_back(DEFAULT);\n\t\t\tlazy.push_back(0LL);\n\t\t\tlazyFlg.push_back(false);\n\t\t}\n\t}\n\tvoid eval(int k, int l, int r){ //遅延評価 O(1)\n\t\tif(lazyFlg[k]){ //RUQ：下に更新クエリが溜まっていても加算クエリが溜まっていても上書き\n\t\t\tnode[k] = lazy[k];\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] = lazy[k];\n\t\t\t\tlazyFlg[2*k+1] = true;\n\t\t\t\tlazy[2*k+2] = lazy[k];\n\t\t\t\tlazyFlg[2*k+2] = true;\n\t\t\t}\n\t\t\tlazy[k] = 0LL;\n\t\t\tlazyFlg[k] = false;\n\t\t}\n\t\telse{ //RAQ：下に更新クエリが溜まっていても加算クエリが溜まっていても加算\n\t\t\tnode[k] += lazy[k];\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] += lazy[k];\n\t\t\t\tlazy[2*k+2] += lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0LL;\n\t\t}\n\t}\n\tvoid update(int a, long long x){ //[a,a+1)の値を変更 O(log N)\n\t\tupdate(a, a+1, x);\n\t}\n\tvoid update(int a, int b, long long x, int k=0, int l=0, int r=-1){ //[a,b)の値を変更 O(log N)\n\t\tif(r == -1) r = N;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return; //交差する場合\n\t\tif(a <= l && r <= b){ //完全に含む場合\n\t\t\tlazy[k] = x;\n\t\t\tlazyFlg[k] = true;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse{\n\t\t\tupdate(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tupdate(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tnode[k] = std::max(node[2*k+1], node[2*k+2]);\n\t\t}\n\t}\n\tvoid add(int a, long long x){ //[a,a+1)の値に加算 O(log N)\n\t\tadd(a, a+1, x);\n\t}\n\tvoid add(int a, int b, long long x, int k=0, int l=0, int r=-1){ //[a,b)の値に加算 O(log N)\n\t\tif(r == -1) r = N;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return; //交差する場合\n\t\tif(a <= l && r <= b){ //完全に含む場合\n\t\t\tlazy[k] += x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse{\n\t\t\tadd(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tadd(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tnode[k] = std::max(node[2*k+1], node[2*k+2]);\n\t\t}\n\t}\n\tlong long max(int a, int b, int k=0, int l=0, int r=-1){ //[a,b)の最大値 O(log N)\n\t\tif(r == -1) r = N;\n\t\tif(b <= l || r <= a) return DEFAULT; //交差する場合\n\t\teval(k, l, r);\n\t\tif(a <= l && r <= b) return node[k]; //完全に含む場合\n\t\treturn std::max(max(a, b, k*2+1, l, (l+r)/2), max(a, b, k*2+2, (l+r)/2, r));\n\t}\n\tlong long m;\n\tint find(int a, int b, int k=0, int l=0, int r=-1){ //[a,b)の最小値の場所 O(log N)\n\t\tif(r == -1){\n\t\t\tm = max(a, b);\n\t\t\tr = N;\n\t\t}\n\t\tif(r <= a || b <= l) return INT_MAX; //交差する場合\n\t\tif(r-l == 1){\n\t\t\tif(node[k] == m) return l;\n\t\t\telse return INT_MAX;\n\t\t}\n\t\tif(a <= l && r <= b){ //完全に含む場合\n\t\t\tint valueL = max(a, b, k*2+1, l, (l+r)/2);\n\t\t\tint valueR = max(a, b, k*2+2, (l+r)/2, r);\n\t\t\tif(valueL == m) return find(a, b, k*2+1, l, (l+r)/2);\n\t\t\tif(valueR == m) return find(a, b, k*2+2, (l+r)/2, r);\n\t\t\treturn INT_MAX;\n\t\t}\n\t\treturn std::min(find(a, b, k*2+1, l, (l+r)/2), find(a, b, k*2+2, (l+r)/2, r));\n\t}\n};\n\nLL N, R, L, d[1000000], t[1000000], x[1000000];\nSegmentTree st;\nLL ans[100000] ={};\nint main(){\n\tcin >> N >> R >> L;\n\tfor(int i=0; i<R; i++){\n\t\tscanf(\"%lld%lld%lld\", &d[i], &t[i], &x[i]);\n\t\td[i]--;\n\t}\n\tst.init(N);\n\t\n\tfor(int i=0; i<R; i++){\n\t\tans[st.find(0, N)] += t[i] - (i != 0 ? t[i-1] : 0);\n\t\tst.add(d[i], x[i]);\n\t}\n\tans[st.find(0, N)] += L - t[R-1];\n\n\tint idx = -1;\n\tLL m = -1;\n\tfor(int i=0; i<N; i++){\n\t\tif(m < ans[i]){\n\t\t\tidx = i;\n\t\t\tm = ans[i];\n\t\t}\n\t}\n\tcout << idx+1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<deque>\n#include<stack>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<tuple>\n#include<utility>\n#include<set>\n#include<queue>\n#include<iomanip>\n#include<iterator>\n//#include<chrono>\n//cout<<setprecision(12)\n//fixed\n//#include<random>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\nconst int big=1e9+100000;\nconst int mod=1e9+7;\nconst lldo eps=1e-9;\nconst long double pai=3.141592653589793238462643;\n#define mt make_tuple\n#define mp make_pair\n#define fir first\n#define sec second\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define res resize\n#define ins insert\n#define era erase\n#define dme(in) cout<<in<<endl;return 0\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint main(void){\n\tint n,r,l;scanf(\"%d %d %d\",&n,&r,&l);\n\tvector<int>pot(n);//??????\n\tvector<int>tv(n);\n\tset<pair<int,int>>a;//???\n\tint mae=0;\n\tfor(int i=0;i<n;i++){a.ins(mp(0,i));}\n\twhile(r--){\n\t\tint d,t,x;scanf(\"%d %d %d\",&d,&t,&x);\n\t\ttv[a.begin()->sec]+=t-mae;\n\t\tmae=t;\n\t\td--;a.era(mp(-pot[d],d));\n\t\tpot[d]+=x;\n\t\ta.ins(mp(-pot[d],d));\n\t}\n\ttv[a.begin()->sec]+=l-mae;\n\tint ans=0;\n\tfor(int i=0;i<n;i++){if(tv[ans]<tv[i]){ans=i;}}\n\tcout<<ans+1<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\ttypedef pair<int,int> pii;\n\tpriority_queue<pii> pq;\n\tint n, r, l, d, t, x, u = 0;\n\tscanf(\"%d%d%d\", &n, &r, &l);\n\tvector<int> s(n + 1), c(n + 1);\n\tfor(int i = 1; i <= n; ++i){\n\t\tpq.push(pii(0, ~i));\n\t}\n\tfor(int i = 0; ; ++i){\n\t\tif(i == r){\n\t\t\tt = l;\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\t}\n\t\twhile(1){\n\t\t\tpii &p = pq.top();\n\t\t\tif(s[~p.second] == p.first){\n\t\t\t\tc[~p.second] += t - u;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpq.pop();\n\t\t}\n\t\tif(i == r){\n\t\t\tbreak;\n\t\t}\n\t\ts[d] += x;\n\t\tpq.push(pii(s[d], ~d));\n\t\tu = t;\n\t}\n\tint ans = max_element(c.begin(), c.end()) - c.begin();\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define F first\n#define S second\n#define INF 1>>20\nusing namespace std;\ntypedef pair<int,int> P;\nvoid update(int k,int x);\nvoid init(int n_);\nP pamax(P a,P b);\nP seg[1111111];\nint n,r,l;//左からチーム数、レコード数、制限時間\nint main(){\n  int time[1111111]={0};\n  int top=0,btime=0;\n  int d,t,x;//左からチームID、獲得した時間、加減得点\n  cin >> n >> r >> l;\n  init(n);\n  for(int i=0;i<r;i++){\n    cin >> d >> t >> x;\n    time[top]+=t-btime;\n    btime=t;\n    update(d-1,x);//チームIDと加減得点\n    top=seg[0].F;//一位奴の更新\n  }\n  time[top]+=l-btime;\n  top=0;\n  time[0]=-11111;\n  for(int i=1;i<=n;i++){//映ってる時間がもっとも多いチームを調べる\n    if(time[top]<time[i])top=i;\n  }\n  cout << top << endl;\n}\n\nvoid init(int n_){\n  int n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<n;i++){\n    seg[i]=P(0,0);\n  }\n}\n\nvoid update(int k,int x){\n  int id=k+1;\n  k+=n-1;\n  seg[k].F=id;\n  seg[k].S+=x;\n  while(k>0){\n    k=(k-1)/2;\n    seg[k]=pamax(seg[k*2+1],seg[k*2+2]);\n  }\n}\n\nP pamax(P a,P b){\n  int x,y;\n  x=a.S;\n  y=b.S;\n  if(x<y)return b;\n  else return a;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\ntypedef long long LL;\ntypedef pair<int, int> P;\n\nint n, r, l;\nLL times[100010];\nLL scores[100010];\n\npriority_queue<P> que;\n\nP getNewest()\n{\n\tP p;\n\tdo\n\t{\n\t\tp = que.top(); que.pop();\n\t} while (scores[-p.second] != p.first);\n\tque.push(p);\n\treturn p;\n}\n\nint main(void)\n{\n\twhile(cin >> n >> r >> l && n)\n\t{\n\t\tmemset(times, 0, sizeof(times));\n\t\tmemset(scores, 0, sizeof(scores));\n\t\tque = priority_queue<P>();\n\t\tque.push(P(0, -1));\n\t\tint pret = 0;\n\t\tP ans = P(-INF, -INF);\n\n\t\tfor (int i = 0; i < r; i++)\n\t\t{\n\t\t\tint d, t, x;\n\t\t\tcin >> d >> t >> x;\n\n\t\t\tP p = getNewest();\n\t\t\ttimes[-p.second] += t - pret;\n\t\t\tans = max(ans, P(times[-p.second], p.second));\n\t\t\tpret = t;\n\n\t\t\tscores[d] += x;\n\t\t\tque.push(P(scores[d], -d));\n\t\t}\n\t\tP p = getNewest();\n\t\ttimes[-p.second] += l - pret;\n\t\tans = max(ans, P(times[-p.second], p.second));\n\t\tcout << -ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0282: Programming Contest\n// 2017.8.19 bal4u@uu\n// Priority Que\n#include <stdio.h>\n\n#define QSIZE 1000000\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\ntypedef struct { int id, key, c; } QUE;\nQUE que[QSIZE + 5]; int qsize;\n\n#define MAX 100000\ntypedef struct { int x, t, c; } T;\nT tbl[MAX + 5];\n\nvoid max_heapify(int i)\n{\n\tint l, r, largest;\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize &&\n\t\t(que[l].key > que[i].key || (que[l].key == que[i].key && que[l].id < que[i].id)))\n\t\tlargest = l;\n\telse largest = i;\n\tif (r < qsize &&\n\t\t(que[r].key > que[largest].key ||\n\t\t\t(que[r].key == que[largest].key && que[r].id < que[largest].id)))\n\t\tlargest = r;\n\tif (largest != i) {\n\t\tQUE t = que[i]; que[i] = que[largest], que[largest] = t;\n\t\tmax_heapify(largest);\n\t}\n}\n\nvoid deq(void)\n{\n\tif (qsize == 0) return;\n\tque[0] = que[--qsize];\n\tmax_heapify(0);\n}\n\nvoid enq(void)\n{\n\tint i, max;\n\ti = qsize++;\n\twhile (i > 0 && (que[max = PARENT(i)].key < que[i].key\n\t\t|| (que[max].key == que[i].key && que[max].id > que[i].id))) {\n\t\tQUE t = que[i]; que[i] = que[max], que[max] = t;\n\t\ti = max;\n\t}\n}\n\nint main()\n{\n\tint N, R, L, d, t, x;\n\tint lt, ld, i, ans;\n\n\tscanf(\"%d%d%d\", &N, &R, &L);\n\tqsize = 0; lt = 0, ld = 1;\n\tque[0].id = 1, que[0].key = 0, que[0].c = 1, enq();\n\ttbl[1].x = 0, tbl[1].c = 1;\n\twhile (R--) {\n\t\tscanf(\"%d%d%d\", &d, &t, &x);\n\t\ttbl[d].x += x, tbl[d].c++;\n\t\tque[qsize].id = d, que[qsize].key = tbl[d].x, que[qsize].c = tbl[d].c;\n\t\tenq();\n\n\t\twhile (1) {\n\t\t\td = que[0].id;\n\t\t\tif (tbl[d].c == que[0].c) {\n\t\t\t\ttbl[ld].t += t - lt;\n\t\t\t\tlt = t, ld = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdeq();\n\t\t}\n\t}\n\ttbl[ld].t += L - lt;\n\tfor (t = 0, i = 1; i <= N; i++)\n\t\tif (tbl[i].t > t) t = tbl[i].t, ans = i;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "int score[100010],show[100010],m;\nint main(){\n\tint N,R,L,d,t,x,c=0,ct=1,n,i;\n\tfor(scanf(\"%d%d%d\",&N,&R,&L);R--;){\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\tshow[ct]+=t-c,c=t;\n\t\tscore[d]+=x;\n\t\tfor(n=i=1,m=score[i];i<=N;i++)if(m<score[i])m=score[i],n=i;\n\t\tct=n;\n\t}\n\tshow[ct]+=L-c;\n\tfor(n=i=1,m=show[i];i<=N;i++)if(m<show[i])m=show[i],n=i;\n\tm=!printf(\"%d\\n\",n);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint time[1000000];\n\nint main(void)\n{\n\tint n, r, l;\n\tint i;\n\tint before_time = 0;\n\tint longest = 0;\n\t\n\tscanf(\"%d %d %d\", &n, &r, &l);\n\tfor (i = 0; i < r; i++){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\ttime[d - 1] += t - before_time;\n\t\tbefore_time = t;\n\t}\n\ttime[d - 1] += 600 - t;\n\tfor (i = 1; i < n; i++){\n\t\tif (time[longest] < time[i]){\n\t\t\tlongest = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", longest + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,r,l,id,t,p,s=0,mi=1,max=0;\n  int i,j;\n  scanf(\"%d %d %d\",&n,&r,&l);\n  int d[100000][2]={0};\n  for(i=0;i<r;i++){\n    scanf(\"%d %d %d\",&id,&t,&p);\n    d[id][0]+=p;\n    d[mi][1]+=t-s;\n    s=t;\n    if(p>0){\n      if(max<d[id][0]){\n\tmax=d[id][0];\n\tmi=id;\n      }\n      else if(max==d[id][0]&&mi>id)mi=id;\n    }\n    else{\n      if(id==mi){\n\tmax=d[1][0];\n\tmi=1;\n\tfor(j=2;j<=n;j++){\n\t  if(max<d[j][0]){\n\t    max=d[j][0];\n\t    mi=j;\n\t  }\n\t}\n      }\n    }\n    /*for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][0]);\n    printf(\"\\n\");\n    for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][1]);\n    printf(\"\\n\\n\");*/\n  }\n  d[mi][1]+=l-s;\n  max=d[1][1];\n  mi=1;//printf(\"\\t%d\",d[1][1]);\n  for(i=2;i<=n;i++){//printf(\"\\t%d\",d[i][1]);\n    if(max<d[i][1]){\n      max=d[i][1];\n      mi=i;\n    }\n  }\n  printf(\"%d\\n\",mi);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0282: Programming Contest\n// 2017.8.19 bal4u@uu\n// 2017.11.25\n\n#include <stdio.h>\n\n#define QSIZE 1000000\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\ntypedef struct { int id, key, c; } QUE;\nQUE que[QSIZE+5]; int qsize;\n\nvoid max_heapify(int i)\n{\n\tint l, r, max;\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && (que[l].key > que[i].key || (que[l].key == que[i].key && que[l].id < que[i].id)))\n\t\tmax = l;\n\telse max = i;\n\tif (r < qsize && (que[r].key > que[max].key || (que[r].key == que[max].key && que[r].id < que[max].id)))\n\t\tmax = r;\n\tif (max != i) {\n\t\tQUE t = que[i]; que[i] = que[max], que[max] = t;\n\t\tmax_heapify(max);\n\t}\n}\n\nvoid deq(void)\n{\n//\tif (qsize == 0) return;\n\tque[0] = que[--qsize];\n\tmax_heapify(0);\n}\n\nvoid enq(void)\n{\n\tint i, max;\n\ti = qsize++;\n\twhile (i > 0 && (que[max = PARENT(i)].key < que[i].key\n\t\t|| (que[max].key == que[i].key && que[max].id > que[i].id))) {\n\t\tQUE t = que[i]; que[i] = que[max], que[max] = t;\n\t\ti = max;\n\t}\n}\n\n#define MAX 100002\nint x[MAX], t[MAX], c[MAX];\nchar buf[102], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint N, R, L, d, tt;\n\tint lt, ld, i, ans;\n\n\tfgets(p=buf, 100, stdin), N = getint(), p++, R = getint(), p++, L = getint();\n\tqsize = 0; lt = 0, ld = 1;\n\tque[0].id = 1, que[0].key = 0, que[0].c = 1, enq();\n\tx[1] = 0, c[1] = 1;\n\twhile (R--) {\n\t\tfgets(p=buf, 100, stdin), d = getint(), p++, tt = getint(), p++;\n\t\tif (*p == '-') p++, x[d] -= getint(); else x[d] += getint();\n\t\tc[d]++;\n\t\tque[qsize].id = d, que[qsize].key = x[d], que[qsize].c = c[d];\n\t\tenq();\n\n\t\twhile (1) {\n\t\t\td = que[0].id;\n\t\t\tif (c[d] == que[0].c) {\n\t\t\t\tt[ld] += tt - lt;\n\t\t\t\tlt = tt, ld = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdeq();\n\t\t}\n\t}\n\tt[ld] += L - lt;\n\tfor (tt = 0, i = 1; i <= N; i++) if (t[i] > tt) tt = t[i], ans = i;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint id;\n\tint score;\n} team_t;\n\nint playerComp(team_t x,team_t y) {\n\tif(x.score>y.score)return 1;\n\tif(x.score<y.score)return -1;\n\tif(x.id<y.id)return 1;\n\tif(x.id>y.id)return -1;\n\treturn 0;\n}\n\ntypedef struct RedBlackTreeNode_tag {\n\tteam_t key;\n\tint isRed;\n\tstruct RedBlackTreeNode_tag* left;\n\tstruct RedBlackTreeNode_tag* right;\n} RedBlackTreeNode;\n\nRedBlackTreeNode* root=NULL;\n\n#define RBT_REQUEST_NONE\t\t\t0\n#define RBT_REQUEST_INIT\t\t\t1\n#define RBT_REQUEST_NEXTOFLEFT\t\t2\n#define RBT_REQUEST_NEXTOFRIGHT\t\t3\n#define RBT_REQUEST_ROTATE_LEFT\t\t0x100\n#define RBT_REQUEST_ROTATE_RIGHT\t0x200\n\n#define RBT_REQUEST_DEL_INIT\t\t1\n\nRedBlackTreeNode* RedBlackTreeNode_new(team_t key) {\n\tRedBlackTreeNode* ret=malloc(sizeof(RedBlackTreeNode));\n\tif(ret==NULL)exit(1);\n\tret->key=key;\n\tret->isRed=1;\n\tret->left=ret->right=NULL;\n\treturn ret;\n}\n\nvoid RedBlackTreeNode_delete(RedBlackTreeNode* node) {\n\tif(node->left)RedBlackTreeNode_delete(node->left);\n\tif(node->right)RedBlackTreeNode_delete(node->right);\n\tfree(node);\n}\n\nvoid RedBlackTree_rotate(RedBlackTreeNode** target,int isLeft) {\n\tif(isLeft && (*target)->right!=NULL) {\n\t\tRedBlackTreeNode* top=*target;\n\t\tRedBlackTreeNode* topRight=(*target)->right;\n\t\tRedBlackTreeNode* topRightLeft=(*target)->right->left;\n\t\t(*target)->right->left=top;\n\t\t(*target)->right=topRightLeft;\n\t\t*target=topRight;\n\t} else if((*target)->left!=NULL) {\n\t\tRedBlackTreeNode* top=*target;\n\t\tRedBlackTreeNode* topLeft=(*target)->left;\n\t\tRedBlackTreeNode* topLeftRight=(*target)->left->right;\n\t\t(*target)->left->right=top;\n\t\t(*target)->left=topLeftRight;\n\t\t*target=topLeft;\n\t}\n}\n\nint RedBlackTree_insertInternal(RedBlackTreeNode** now,team_t key) {\n\tint ret=RBT_REQUEST_NONE;\n\tint isLeft;\n\tif(*now==NULL) {\n\t\t*now=RedBlackTreeNode_new(key);\n\t\treturn RBT_REQUEST_INIT;\n\t} else if(playerComp((*now)->key,key)==0) {\n\t\treturn RBT_REQUEST_NONE;\n\t} else if(playerComp((*now)->key,key)<0) {\n\t\tret=RedBlackTree_insertInternal(&((*now)->right),key);\n\t\tisLeft=0;\n\t} else { /* key<(*now)->key */\n\t\tret=RedBlackTree_insertInternal(&((*now)->left),key);\n\t\tisLeft=1;\n\t}\n\n\tif(ret==RBT_REQUEST_INIT) {\n\t\t/* case 1 */\n\t\tif((*now)->isRed) {\n\t\t\tret=isLeft?RBT_REQUEST_NEXTOFLEFT:RBT_REQUEST_NEXTOFRIGHT;\n\t\t} else {\n\t\t\tret=RBT_REQUEST_NONE;\n\t\t}\n\t} else if(ret==RBT_REQUEST_NEXTOFLEFT) {\n\t\tif(isLeft) {\n\t\t\tif((*now)->right==NULL || !(*now)->right->isRed) {\n\t\t\t\t/* case 4 */\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\t(*now)->left->isRed=0;\n\t\t\t\tRedBlackTree_rotate(now,0);\n\t\t\t\tret=RBT_REQUEST_NONE;\n\t\t\t} else {\n\t\t\t\t/* case 2 */\n\t\t\t\t(*now)->left->isRed=0;\n\t\t\t\tif((*now)->right)(*now)->right->isRed=0;\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\tret=RBT_REQUEST_INIT;\n\t\t\t}\n\t\t} else {\n\t\t\tif((*now)->left==NULL || !(*now)->left->isRed) {\n\t\t\t\t/* case 3 */\n\t\t\t\tRedBlackTree_rotate(&((*now)->right),0);\n\t\t\t\t/* case 4 */\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\t(*now)->right->isRed=0;\n\t\t\t\tRedBlackTree_rotate(now,1);\n\t\t\t\tret=RBT_REQUEST_NONE;\n\t\t\t} else {\n\t\t\t\t/* case 2 */\n\t\t\t\t(*now)->right->isRed=0;\n\t\t\t\tif((*now)->left)(*now)->left->isRed=0;\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\tret=RBT_REQUEST_INIT;\n\t\t\t}\n\t\t}\n\t} else if(ret==RBT_REQUEST_NEXTOFRIGHT) {\n\t\tif(isLeft) {\n\t\t\tif((*now)->right==NULL || !(*now)->right->isRed) {\n\t\t\t\t/* case 3 */\n\t\t\t\tRedBlackTree_rotate(&((*now)->left),1);\n\t\t\t\t/* case 4 */\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\t(*now)->left->isRed=0;\n\t\t\t\tRedBlackTree_rotate(now,0);\n\t\t\t\tret=RBT_REQUEST_NONE;\n\t\t\t} else {\n\t\t\t\t/* case 2 */\n\t\t\t\t(*now)->left->isRed=0;\n\t\t\t\tif((*now)->right)(*now)->right->isRed=0;\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\tret=RBT_REQUEST_INIT;\n\t\t\t}\n\t\t} else {\n\t\t\tif((*now)->left==NULL || !(*now)->left->isRed) {\n\t\t\t\t/* case 4 */\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\t(*now)->right->isRed=0;\n\t\t\t\tRedBlackTree_rotate(now,1);\n\t\t\t\tret=RBT_REQUEST_NONE;\n\t\t\t} else {\n\t\t\t\t/* case 2 */\n\t\t\t\t(*now)->right->isRed=0;\n\t\t\t\tif((*now)->left)(*now)->left->isRed=0;\n\t\t\t\t(*now)->isRed=1;\n\t\t\t\tret=RBT_REQUEST_INIT;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid RedBlackTree_insert(team_t key) {\n\tRedBlackTree_insertInternal(&root,key);\n\troot->isRed=0;\n}\n\nRedBlackTreeNode* RedBlackTree_searchPtr(RedBlackTreeNode* now,team_t key) {\n\tif(now==NULL)return NULL;\n\tif(playerComp(now->key,key)==0)return now;\n\treturn RedBlackTree_searchPtr(playerComp(now->key,key)<0?now->right:now->left,key);\n}\n\nRedBlackTreeNode* RedBlackTree_searchMinNode(RedBlackTreeNode* now) {\n\tif(now->left==NULL)return now;\n\treturn RedBlackTree_searchMinNode(now->left);\n}\n\nRedBlackTreeNode* RedBlackTree_searchMaxNode(RedBlackTreeNode* now) {\n\tif(now->right==NULL)return now;\n\treturn RedBlackTree_searchMaxNode(now->right);\n}\n\nint RedBlackTree_removeInternal(RedBlackTreeNode** now,RedBlackTreeNode* target) {\n\tint ret=RBT_REQUEST_NONE;\n\tint isLeft=0;\n\tint colorTemp;\n\tif(*now==NULL)return RBT_REQUEST_NONE;\n\tif(*now==target) {\n\t\tRedBlackTreeNode* delNode=*now;\n\t\tint delNodeIsRed=delNode->isRed;\n\t\t*now=(*now)->left?(*now)->left:(*now)->right;\n\t\tdelNode->left=delNode->right=NULL;\n\t\tRedBlackTreeNode_delete(delNode);\n\t\t/* case 0 */\n\t\tif(delNodeIsRed) {\n\t\t\treturn RBT_REQUEST_NONE;\n\t\t} else if(*now && (*now)->isRed) {\n\t\t\t(*now)->isRed=0;\n\t\t\treturn RBT_REQUEST_NONE;\n\t\t}\n\t\treturn RBT_REQUEST_DEL_INIT;\n\t} else if(playerComp((*now)->key,target->key)<=0) {\n\t\tret=RedBlackTree_removeInternal(&((*now)->right),target);\n\t\tisLeft=0;\n\t} else {\n\t\tret=RedBlackTree_removeInternal(&((*now)->left),target);\n\t\tisLeft=1;\n\t}\n\tif(ret==RBT_REQUEST_DEL_INIT) {\n\t\tif(isLeft) {\n\t\t\tif((*now)->right!=NULL && (*now)->right->isRed) {\n\t\t\t\t/* case 2 */\n\t\t\t\t(*now)->isRed=!(*now)->isRed;\n\t\t\t\t(*now)->right->isRed=!(*now)->right->isRed;\n\t\t\t\tRedBlackTree_rotate(now,1);\n\t\t\t\tnow=&((*now)->left);\n\t\t\t}\n\t\t\tret=RBT_REQUEST_NONE;\n\t\t\tif((*now)->right!=NULL) {\n\t\t\t\tif(((*now)->right->left==NULL ||\n\t\t\t\t\t\t!((*now)->right->left->isRed)) &&\n\t\t\t\t\t\t((*now)->right->right==NULL ||\n\t\t\t\t\t\t!((*now)->right->right->isRed))) {\n\t\t\t\t\tif((*now)->isRed) {\n\t\t\t\t\t\t/* case 4 */\n\t\t\t\t\t\t(*now)->isRed=0;\n\t\t\t\t\t\t(*now)->right->isRed=1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* case 3 */\n\t\t\t\t\t\t(*now)->right->isRed=1;\n\t\t\t\t\t\tret=RBT_REQUEST_INIT;\n\t\t\t\t\t}\n\t\t\t\t} else if((*now)->right->right!=NULL &&\n\t\t\t\t\t\t(*now)->right->right->isRed) {\n\t\t\t\t\t/* case 6 */\n\t\t\t\t\tcolorTemp=(*now)->isRed;\n\t\t\t\t\t(*now)->isRed=(*now)->right->isRed;\n\t\t\t\t\t(*now)->right->isRed=colorTemp;\n\t\t\t\t\t(*now)->right->right->isRed=0;\n\t\t\t\t\tRedBlackTree_rotate(now,1); \n\t\t\t\t} else {\n\t\t\t\t\t/* case 5 */\n\t\t\t\t\t(*now)->right->isRed=1; \n\t\t\t\t\t(*now)->right->left->isRed=0;\n\t\t\t\t\tRedBlackTree_rotate(&((*now)->right),0);\n\t\t\t\t\t/* case 6 */\n\t\t\t\t\tcolorTemp=(*now)->isRed;\n\t\t\t\t\t(*now)->isRed=(*now)->right->isRed;\n\t\t\t\t\t(*now)->right->isRed=colorTemp;\n\t\t\t\t\t(*now)->right->right->isRed=0;\n\t\t\t\t\tRedBlackTree_rotate(now,1); \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif((*now)->left!=NULL && (*now)->left->isRed) {\n\t\t\t\t/* case 2 */\n\t\t\t\t(*now)->isRed=!(*now)->isRed;\n\t\t\t\t(*now)->left->isRed=!(*now)->left->isRed;\n\t\t\t\tRedBlackTree_rotate(now,0);\n\t\t\t\tnow=&((*now)->right);\n\t\t\t}\n\t\t\tret=RBT_REQUEST_NONE;\n\t\t\tif((*now)->left!=NULL) {\n\t\t\t\tif(((*now)->left->left==NULL ||\n\t\t\t\t\t\t!((*now)->left->left->isRed)) &&\n\t\t\t\t\t\t((*now)->left->right==NULL ||\n\t\t\t\t\t\t!((*now)->left->right->isRed))) {\n\t\t\t\t\tif((*now)->isRed) {\n\t\t\t\t\t\t/* case 4 */\n\t\t\t\t\t\t(*now)->isRed=0;\n\t\t\t\t\t\t(*now)->left->isRed=1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* case 3 */\n\t\t\t\t\t\t(*now)->left->isRed=1;\n\t\t\t\t\t\tret=RBT_REQUEST_INIT;\n\t\t\t\t\t}\n\t\t\t\t} else if((*now)->left->left!=NULL &&\n\t\t\t\t\t\t(*now)->left->left->isRed) {\n\t\t\t\t\t/* case 6 */\n\t\t\t\t\tcolorTemp=(*now)->isRed;\n\t\t\t\t\t(*now)->isRed=(*now)->left->isRed;\n\t\t\t\t\t(*now)->left->isRed=colorTemp;\n\t\t\t\t\t(*now)->left->left->isRed=0;\n\t\t\t\t\tRedBlackTree_rotate(now,0);\n\t\t\t\t} else {\n\t\t\t\t\t/* case 5 */\n\t\t\t\t\t(*now)->left->isRed=1; \n\t\t\t\t\t(*now)->left->right->isRed=0;\n\t\t\t\t\tRedBlackTree_rotate(&((*now)->left),1);\n\t\t\t\t\t/* case 6 */\n\t\t\t\t\tcolorTemp=(*now)->isRed;\n\t\t\t\t\t(*now)->isRed=(*now)->left->isRed;\n\t\t\t\t\t(*now)->left->isRed=colorTemp;\n\t\t\t\t\t(*now)->left->left->isRed=0;\n\t\t\t\t\tRedBlackTree_rotate(now,0); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint RedBlackTree_remove(team_t key) {\n\tRedBlackTreeNode* target;\n\ttarget=RedBlackTree_searchPtr(root,key);\n\tif(target==NULL)return 0;\n\tif(target->left!=NULL && target->right!=NULL) {\n\t\tRedBlackTreeNode* minNode;\n\t\tminNode=RedBlackTree_searchMinNode(target->right);\n\t\ttarget->key=minNode->key;\n\t\ttarget=minNode;\n\t}\n\tRedBlackTree_removeInternal(&root,target);\n\treturn 1;\n}\n\nteam_t RedBlackTree_getMax(void) {\n\tteam_t nothing={1,0};\n\tRedBlackTreeNode* max=RedBlackTree_searchMaxNode(root);\n\treturn max==NULL?nothing:max->key;\n}\n\nint teamScore[100001];\nint teamShownTime[100001];\n\nint main(void) {\n\tint N,R,L;\n\tint i;\n\tint prevTime=0;\n\tint resID,resTime;\n\tteam_t tempTeam={1,0};\n\tscanf(\"%d%d%d\",&N,&R,&L);\n\tRedBlackTree_insert(tempTeam);\n\tfor(i=0;i<R;i++) {\n\t\tint d,t,x;\n\t\tscanf(\"%d%d%d\",&d,&t,&x);\n\t\ttempTeam=RedBlackTree_getMax();\n\t\tteamShownTime[tempTeam.id]+=t-prevTime;\n\t\ttempTeam.id=d;\n\t\ttempTeam.score=teamScore[d];\n\t\tRedBlackTree_remove(tempTeam);\n\t\tteamScore[d]+=x;\n\t\ttempTeam.score=teamScore[d];\n\t\tRedBlackTree_insert(tempTeam);\n\t\tprevTime=t;\n\t}\n\ttempTeam=RedBlackTree_getMax();\n\tteamShownTime[tempTeam.id]+=L-prevTime;\n\tresID=0;resTime=-1;\n\tfor(i=1;i<=N;i++) {\n\t\tif(teamShownTime[i]>resTime) {\n\t\t\tresTime=teamShownTime[i];\n\t\t\tresID=i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",resID);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 282: Programming Contest\n// 2019.9.28 bal4u\n\n#include <stdio.h>\n\n#if 1\nint getchar_unlocked(void);\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in() {  // 整数の入力\n\tint n = 0, c = gc();\n\tif (c == '-') {\tc = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define MAX 100002\ntypedef struct { int x, t, qid; char f; } T; // 得点、映された長さ、キューでの位置、新規登録か\nT team[MAX];\n\n\n#define QSIZE 1000000\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\ntypedef struct { int id, key; int idx; } QUE;\nQUE que[QSIZE+5]; int qsize;\n\n//void idx_update(int idx, int pos);\n#define idx_update(idx, pos) (team[idx].qid = pos)\n\nvoid max_heapify(int i)\n{\n\tint l, r, max;\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && (que[l].key > que[i].key\n\t\t|| (que[l].key == que[i].key && que[l].id < que[i].id))) max = l;\n\telse max = i;\n\tif (r < qsize && (que[r].key > que[max].key ||\n\t\t(que[r].key == que[max].key && que[r].id < que[max].id))) max = r;\n\tif (max != i) {\n\t\tidx_update(que[i].idx, max);\n\t\tidx_update(que[max].idx, i);\n\t\tQUE t = que[i]; que[i] = que[max], que[max] = t;\n\t\tmax_heapify(max);\n\t}\n}\n\nvoid deq(void) {\n\tque[0] = que[--qsize];\n\tidx_update(que[qsize].idx, 0);\n\tmax_heapify(0);\n}\n\nvoid qup(int i) {\n\tint max;\n\twhile (i > 0 && (que[max = PARENT(i)].key < que[i].key\n\t\t|| (que[max].key == que[i].key && que[max].id > que[i].id))) {\n\t\tidx_update(que[i].idx, max);\n\t\tidx_update(que[max].idx, i);\n\t\tQUE t = que[i]; que[i] = que[max], que[max] = t;\n\t\ti = max;\n\t}\n}\n\t\nvoid enq(int id, int x, int idx) {\n\tint i = qsize++;\n\tque[i].id = id, que[i].key = x, que[i].idx = idx;\n\tidx_update(idx, i);\n\tqup(i);\n}\n\nvoid pri_update(int qid, int x) {\n\tQUE t = que[qid]; que[qid].key = x;\n\tif (x < t.key) max_heapify(qid);\n\telse           qup(qid);\n}\n\nint main()\n{\n\tint i, N, R, L, d, t, x;\n\tint pre_t, pre_d, ans;\n\n\tN = in(), R = in(), L = in();\n\tpre_t = 0, pre_d = 1;\n\t\n\tteam[1].x = 0, team[1].t = 0, team[1].qid = qsize, team[1].f = 1;  // 最初のチームが有利\n\tenq(1, 0, 1);\n\t\n\twhile (R--) {\n\t\td = in(), t = in(), x = in();\n\t\tif (x == 0) continue;\n\t\tteam[d].x += x;\n\t\t\n\t\tif (team[d].f == 0) team[d].f = 1, enq(d, team[d].x, d);\n\t\telse pri_update(team[d].qid, team[d].x);\n\n\t\tteam[pre_d].t += t - pre_t;\n\t\tpre_t = t, pre_d = que[0].id;\n\t}\n\tteam[pre_d].t += L - pre_t;\n\n\tans = t = 0; for (d = 1; d <= N; d++) if (team[d].t > t) t = team[d].t, ans = d;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0282: Programming Contest\n// 2017.8.19 bal4u@uu\n// 2017.10.29 retry\n\n#include <stdio.h>\n\n#define QSIZE 1000000\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\ntypedef struct { int id, key, c; } QUE;\nQUE que[QSIZE+5]; int qsize;\n\nvoid max_heapify(int i)\n{\n\tint l, r, max;\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && (que[l].key > que[i].key || (que[l].key == que[i].key && que[l].id < que[i].id)))\n\t\tmax = l;\n\telse max = i;\n\tif (r < qsize && (que[r].key > que[max].key || (que[r].key == que[max].key && que[r].id < que[max].id)))\n\t\tmax = r;\n\tif (max != i) {\n\t\tQUE t = que[i]; que[i] = que[max], que[max] = t;\n\t\tmax_heapify(max);\n\t}\n}\n\nvoid deq(void)\n{\n\tif (qsize == 0) return;\n\tque[0] = que[--qsize];\n\tmax_heapify(0);\n}\n\nvoid enq(void)\n{\n\tint i, max;\n\ti = qsize++;\n\twhile (i > 0 && (que[max = PARENT(i)].key < que[i].key\n\t\t|| (que[max].key == que[i].key && que[max].id > que[i].id))) {\n\t\tQUE t = que[i]; que[i] = que[max], que[max] = t;\n\t\ti = max;\n\t}\n}\n\n#define MAX 100000\ntypedef struct { int x, t, c; } T;\nT tbl[MAX+5];\nchar buf[102], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint N, R, L, d, t;\n\tint lt, ld, i, ans;\n\n\tfgets(p=buf, 100, stdin), N = getint(), p++, R = getint(), p++, L = getint();\n\tqsize = 0; lt = 0, ld = 1;\n\tque[0].id = 1, que[0].key = 0, que[0].c = 1, enq();\n\ttbl[1].x = 0, tbl[1].c = 1;\n\twhile (R--) {\n\t\tfgets(p=buf, 100, stdin), d = getint(), p++, t = getint(), p++;\n\t\tif (*p == '-') p++, tbl[d].x -= getint(); else tbl[d].x += getint();\n\t\ttbl[d].c++;\n\t\tque[qsize].id = d, que[qsize].key = tbl[d].x, que[qsize].c = tbl[d].c;\n\t\tenq();\n\n\t\twhile (1) {\n\t\t\td = que[0].id;\n\t\t\tif (tbl[d].c == que[0].c) {\n\t\t\t\ttbl[ld].t += t - lt;\n\t\t\t\tlt = t, ld = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdeq();\n\t\t}\n\t}\n\ttbl[ld].t += L - lt;\n\tfor (t = 0, i = 1; i <= N; i++)\n\t\tif (tbl[i].t > t) t = tbl[i].t, ans = i;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,r,l,id,t,p,s=0,mi=1,max=0;\n  int i,j;\n  scanf(\"%d %d %d\",&n,&r,&l);\n  int d[100000][2]={0};\n  for(i=0;i<r;i++){\n    scanf(\"%d %d %d\",&id,&t,&p);\n    d[id][0]+=p;\n    d[mi][1]+=t-s;\n    s=t;\n    if(p>0){\n      if(max<d[id][0]){\n\tmax=d[id][0];\n\tmi=id;\n      }\n      else if(max==d[id][0]&&mi>id)mi=id;\n    }\n    else{\n      max=d[1][0];\n      mi=1;\n      for(j=2;j<=n;j++){\n\tif(max<d[j][0]){\n\t  max=d[j][0];\n\t  mi=j;\n\t}\n      }\n    }\n    /*for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][0]);\n    printf(\"\\n\");\n    for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][1]);\n    printf(\"\\n\\n\");*/\n  }\n  d[mi][1]+=l-t;\n  max=d[1][1];\n  mi=1;//printf(\"\\t%d\",d[1][1]);\n  for(i=2;i<=n;i++){//printf(\"\\t%d\",d[i][1]);\n    if(max<d[i][1]){\n      max=d[i][1];\n      mi=i;\n    }\n  }\n  printf(\"%d\\n\",mi);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,r,l,id,t,p,s=0,mi=1,max=0;\n  int i,j;\n  scanf(\"%d %d %d\",&n,&r,&l);\n  int d[100002][2]={0};\n  for(i=0;i<r;i++){\n    scanf(\"%d %d %d\",&id,&t,&p);\n    d[id][0]+=p;\n    d[mi][1]+=t-s;\n    s=t;\n    if(p>0){\n      if(max<d[id][0]){\n\tmax=d[id][0];\n\tmi=id;\n      }\n      else if(max==d[id][0]&&mi>id)mi=id;\n    }\n    else{\n      if(id==mi){\n\tmax=d[1][0];\n\tmi=1;\n\tfor(j=2;j<=n;j++){\n\t  if(max<d[j][0]){\n\t    max=d[j][0];\n\t    mi=j;\n\t  }\n\t}\n      }\n    }\n    /*for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][0]);\n    printf(\"\\n\");\n    for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][1]);\n    printf(\"\\n\\n\");*/\n  }\n  d[mi][1]+=l-s;\n  max=d[1][1];\n  mi=1;//printf(\"\\t%d\",d[1][1]);\n  for(i=2;i<=n;i++){//printf(\"\\t%d\",d[i][1]);\n    if(max<d[i][1]){\n      max=d[i][1];\n      mi=i;\n    }\n  }\n  printf(\"%d\\n\",mi);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint time[1000000];\n\nint main(void)\n{\n\tint n, r, l;\n\tint i;\n\tint before_time = 0;\n\tint longest = 0;\n\t\n\tscanf(\"%d %d %d\", &n, &r, &l);\n\tfor (i = 0; i < r; i++){\n\t\tint d, t, x;\n\t\t\n\t\tscanf(\"%d %d %d\", &d, &t, &x);\n\t\ttime[d - 1] += t - before_time;\n\t\tbefore_time = t;\n\t}\n\ttime[d - 1] += 600 - before_time;\n\tfor (i = 1; i < n; i++){\n\t\tif (time[longest] < time[i]){\n\t\t\tlongest = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", longest + 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\ntypedef struct {\n  int id;\n  int sc;\n} node;\nnode dat[1<<19];\nint tim[111111];\nint n;\n\nnode max(node a,node b) {\n  if( a.sc == b.sc ) return a.id < b.id ? a : b;\n  if( a.sc < b.sc ) return b;\n  if( a.sc > b.sc ) return a;\n  return a.id > b.id ? b : a;\n}\n\nvoid update(int k,node x)\n{\n  k += n-1;\n  dat[k] = x;\n  while( k > 0 ) {\n    k /= 2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nint a[1111111],b[1111111];\nint c[1111111];\n\nint main(void)\n{\n  int n_,r,l,i,j,pre,ma,res;\n  scanf(\"%d%d%d\",&n_,&r,&l);\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for( i = 0; i < n; i++ ) dat[i+n-1] = (node){i,INT_MIN}; \n  for( i = 0; i < n_; i++ ) update(i,(node){i,0ll});\n  for( i = 0; i < r; i++ ){ scanf(\"%d%d%d\",a+i,b+i,c+i); a[i]--; }\n  b[r] = l;\n  pre = 0;\n  for( i = 0; i <= r; i++ ) {\n    tim[dat[0].id] += b[i]-pre;\n    for( j = i; j <= r && b[i] == b[j]; j++ ) {\n      update(a[j],(node){a[j],dat[a[j]+n-1].sc+c[j]});\n    }\n    i = j-1;\n    pre = b[i];\n  }\n  ma = 0;\n  res = 0;\n  for( i = 0; i < n_; i++ ) {\n    if( ma < tim[i] ) {\n      ma = tim[i];\n      res = i+1;\n    }\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,r,l,id,t,p,s=0,mi=1,max=0;\n  int i,j;\n  scanf(\"%d %d %d\",&n,&r,&l);\n  int d[100000][2]={0};\n  for(i=0;i<r;i++){\n    scanf(\"%d %d %d\",&id,&t,&p);\n    d[id][0]+=p;\n    d[mi][1]+=t-s;\n    s=t;\n    if(p>0){\n      if(max<d[id][0]){\n\tmax=d[id][0];\n\tmi=id;\n      }\n      else if(max==d[id][0]&&mi>id)mi=id;\n    }\n    else{\n      max=d[1][0];\n      mi=1;\n      for(j=2;j<=n;j++){\n\tif(max<d[j][0]){\n\t  max=d[j][0];\n\t  mi=j;\n\t}\n      }\n    }\n    /*for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][0]);\n    printf(\"\\n\");\n    for(j=0;j<n;j++)printf(\"\\t%d\",d[j+1][1]);\n    printf(\"\\n\\n\");*/\n  }\n  d[mi][1]+=l-s;\n  max=d[1][1];\n  mi=1;//printf(\"\\t%d\",d[1][1]);\n  for(i=2;i<=n;i++){//printf(\"\\t%d\",d[i][1]);\n    if(max<d[i][1]){\n      max=d[i][1];\n      mi=i;\n    }\n  }\n  printf(\"%d\\n\",mi);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct LOG\n{\n\tint d;\n\tint t;\n\tint x;\n};\n\nint main(void)\n{\n\tint n, r, l;\n\tint i;\n\tstruct LOG before, now;\n\tint team[100001][2] = {0};\n\tint maxi = 0;\n\t\n\tbefore.d = before.t = before.x = 0;\n\tscanf(\"%d %d %d\", &n, &r, &l);\n\twhile (r-- > 0){\n\t\tscanf(\"%d %d %d\", &now.d, &now.t, &now.x);\n\t\t\n\t\tif (maxi != 0) team[maxi][1] += now.t - before.t;\n\t\telse maxi = now.d;\n\t\tteam[now.d][0] += now.x;\n\t\tmaxi = 0;\n\t\tfor (i = 1; i <= n; i++){\n\t\t\tif (team[maxi][0] < team[i][0]) maxi = i;\n\t\t}\n\t\t\n\t\tbefore = now;\n\t}\n\tteam[maxi][1] += l - before.t;\n\tmaxi = 0;\n\tfor (i = 1; i <= n; i++){\n\t\tif (team[maxi][1] < team[i][1]) maxi = i;\n\t}\n\tprintf(\"%d\\n\", maxi);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\ntypedef struct {\n  int id;\n  int sc;\n} node;\nnode dat[1<<18];\nint tim[111111];\nint n;\n\nnode max(node a,node b) {\n  if( a.sc == b.sc ) return a.id < b.id ? a : b;\n  if( a.sc < b.sc ) return b;\n  if( a.sc > b.sc ) return a;\n  return a.id > b.id ? b : a;\n}\n\nvoid update(int k,node x)\n{\n  k += n-1;\n  dat[k] = x;\n  while( k > 0 ) {\n    k = (k-1)/2;\n    dat[k] = max(dat[k*2+1],dat[k*2+2]);\n  }\n}\n\nint a[1111111],b[1111111];\nint c[1111111];\n\nint main(void)\n{\n  int n_,r,l,i,j,pre,ma,res;\n  scanf(\"%d%d%d\",&n_,&r,&l);\n  n = 1;\n  while( n < n_ ) n *= 2;\n  for( i = 0; i < n; i++ ) dat[i+n-1] = (node){i,INT_MIN}; \n  for( i = 0; i < n_; i++ ) update(i,(node){i,0ll});\n  for( i = 0; i < r; i++ ){ scanf(\"%d%d%d\",a+i,b+i,c+i); a[i]--; }\n  b[r] = l;\n  pre = 0;\n  for( i = 0; i <= r; i++ ) {\n    tim[dat[0].id] += b[i]-pre;\n    for( j = i; j <= r && b[i] == b[j]; j++ ) {\n      update(a[j],(node){a[j],dat[a[j]+n-1].sc+c[j]});\n    }\n    i = j-1;\n    pre = b[i];\n  }\n  ma = 0;\n  res = 0;\n  for( i = 0; i < n_; i++ ) {\n    if( ma < tim[i] ) {\n      ma = tim[i];\n      res = i+1;\n    }\n  }\n  printf(\"%d\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct LOG\n{\n\tint d;\n\tint t;\n\tint x;\n};\n\nint main(void)\n{\n\tint n, r, l;\n\tint i;\n\tstruct LOG before, now;\n\tint team[100001][2] = {0};\n\tint maxi = 0;\n\t\n\tbefore.d = before.t = before.x = 0;\n\tscanf(\"%d %d %d\", &n, &r, &l);\n\twhile (r-- > 0){\n\t\tscanf(\"%d %d %d\", &now.d, &now.t, &now.x);\n\t\t\n\t\tif (maxi != 0) team[maxi][1] = now.t - before.t;\n\t\telse maxi = now.d;\n\t\tteam[now.d][0] += now.x;\n\t\tmaxi = 1;\n\t\tfor (i = 2; i <= n; i++){\n\t\t\tif (team[maxi][0] < team[i][0]) maxi = i;\n\t\t}\n\t\t\n\t\tbefore = now;\n\t}\n\tteam[maxi][1] += l - before.t;\n\tmaxi = 1;\n\tfor (i = 2; i <= n; i++){\n\t\tif (team[maxi][1] < team[i][1]) maxi = i;\n\t}\n\tprintf(\"%d\\n\", maxi);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint point[100001],time[100001],d[1000000],t[1000000],x[1000000];\nint main(){\n\tint n,r,l,i,i2,max;\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(i=1;i<=n;i++){\n\t\tpoint[i]=0;\n\t\ttime[i]=0;\n\t}\n\tfor(i=0;i<r;i++)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\ttime[1]+=t[0];\n\tfor(i=0;i<r;i++){\n\t\tpoint[d[i]]+=x[i];\n\t\tif(t[i]!=t[i+1]){\n\t\t\tmax=0;\n\t\t\tfor(i2=1;i2<=n;i2++)if(max<point[i2])max=point[i2];\n\t\t\tfor(i2=1;i2<=n;i2++)if(point[i2]==max)break;\n\t\t\tif(i==r-1)time[i2]+=l-t[i];\n\t\t\telse time[i2]+=t[i+1]-t[i];\n\t\t}\n\t}\n\tmax=0;\n\tfor(i=1;i<=n;i++)if(max<time[i])max=time[i];\n\tfor(i=1;i<=n;i++)if(time[i]==max)break;\n\tprintf(\"%d\\n\",i);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint point[100001],time[100001],d[1000000],t[1000000],x[1000000];\nint main(){\n\tint n,r,l,i,i2,max;\n\tscanf(\"%d%d%d\",&n,&r,&l);\n\tfor(i=1;i<=n;i++){\n\t\tpoint[i]=0;\n\t\ttime[i]=0;\n\t}\n\tfor(i=0;i<r;i++)scanf(\"%d%d%d\",&d[i],&t[i],&x[i]);\n\ttime[1]+=t[0];\n\tfor(i=0;i<r;i++){\n\t\tpoint[d[i]]+=x[i];\n\t\tif(t[i]!=t[i+1]){\n\t\t\tmax=0;\n\t\t\tfor(i2=1;i2<=n;i2++)if(max<point[i2])max=point[i2];\n\t\t\tfor(i2=1;i2<=n;i2++)if(point[i2]==max)break;\n\t\t\tif(i==r-1)time[i2]+=l-t[i];\n\t\t\telse time[i2]+=t[i+1]-t[i];\n\t\t}\n\t}\n\tmax=0;\n\tfor(i=1;i<=n;i++)if(max<time[i])max=time[i];\n\tfor(i=1;i<=n;i++)if(time[i]==max)break;\n\tprintf(\"%d\\n\",i);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\n\n#define MAX_N 100001\n\nstruct pair{int first,second;};\n\nint n;\nstruct pair dat[2*MAX_N-1];\n\nint add(int k,int a){\n  k+=n-1;\n  dat[k].first+=a;\n  while(k>0){\n    k=(k-1)/2;\n    if(dat[k*2+1].first>dat[k*2+2].first)dat[k]=dat[k*2+1];\n    else if(dat[k*2+1].first==dat[k*2+2].first){\n      if(dat[k*2+1].second<dat[k*2+2].second)dat[k]=dat[k*2+1];\n      else dat[k]=dat[k*2+2];\n    }\n    else dat[k]=dat[k*2+2];\n  }\n}\n\nvoid init(){\n  int i;\n  for(i=0;i<n;i++){\n    struct pair p;\n    p.first=0;\n    p.second=i;\n    dat[i+n-1]=p;\n  }\n  for(i=0;i<n;i++)add(i,0);\n}\n\nint cnt[100001];\n\nint main(void){\n\n  int r,l,now=0,pre=0,i;\n\n  scanf(\"%d %d %d\",&n,&r,&l);\n  init();\n\n  while(r--){\n\n    int d,t,x;\n    scanf(\"%d %d %d\",&d,&t,&x);\n    cnt[now]+=t-pre;\n    pre=t;\n    add(d-1,x);\n    now=dat[0].second;\n  }\n  cnt[now]+=l-pre;\n\n  int ans=0,p=0;\n  for(i=0;i<n;i++)if(p<cnt[i])p=cnt[i],ans=i;\n  printf(\"%d\\n\",ans+1);\n\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\t\t\t\t// Spped up\n\t\t\t\tif (teamShowTimeMap[currentTeam] > endTime / 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Select show team\n\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tint L = scanner.nextInt();\n\t\tint[] P = new int[N];\n\t\tint[] T = new int[N];\n\t\tint PT = 0;\n\t\tint n1 = 0;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tint d = scanner.nextInt() - 1;\n\t\t\tint t = scanner.nextInt();\n\t\t\tint x = scanner.nextInt();\n\t\t\tP[d] += x;\n\t\t\tif (x > 0) {\n\t\t\t\tif (P[d] > P[n1] || (P[d] == P[n1] && n1 > d)) {\n\t\t\t\t\tT[n1] += t - PT + 1;\n\t\t\t\t\tPT = t;\n\t\t\t\t\tn1 = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tif (d != n1)\n\t\t\t\t\tcontinue;\n\t\t\t\tint n2 = n1, p2 = P[d];\n\t\t\t\tfor (int j = N - 1; j >= 0; j--) {\n\t\t\t\t\tif (p2 <= P[j]) {\n\t\t\t\t\t\tn2 = j;\n\t\t\t\t\t\tp2 = P[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n2 != n1) {\n\t\t\t\t\tT[n1] += t - PT + 1;\n\t\t\t\t\tPT = t;\n\t\t\t\t\tn1 = n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tT[n1] += L - PT + 1;\n\t\tint ans_n = 0, ans_t = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (ans_t < T[i]) {\n\t\t\t\tans_t = T[i];\n\t\t\t\tans_n = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans_n + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tint[] p = new int[n+1];\n\t\tint[] s = new int[n+1];\n\n\t\tint maxid = 1;\n\t\tint pret = 0;\n\t\t\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\ts[maxid] += t - pret;\n\t\t\tpret = t;\n\t\t\tp[d] += x;\n\t\t\t\n\t\t\tif(x>0 && p[maxid]<p[d]){\n\t\t\t\tmaxid = d;\n\t\t\t}else if(x>0 && p[maxid]==p[d] && maxid>d){\n\t\t\t\tmaxid = d;\n\t\t\t}else if(x<=0 && maxid==d){\n\t\t\t\tfor(int j=1;j<=n;j++) if(p[maxid]<p[j]) maxid = j;\n\t\t\t}\n\t\t}\n\t\ts[maxid] += m-pret;\n\t\t\n\t\tmaxid = 1;\n\t\tfor(int i=1;i<=n;i++) if(s[maxid]<s[i]) maxid = i;\n\t\tSystem.out.println(maxid);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\tPriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\t\n\t\tint[] time = new int[N];\n\t\t\n\t\tint lastTime = 0;\n\t\tqueA.add(new Pair(1,0));\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tqueBX.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!queBX.isEmpty()) {\n\t\t\t\tqueA.offer(queBX.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t\t\n\t\t\tif(i % 100000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 0;\n\t\tlong max = target[0];\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 0;\n\t\tlong max = target[0];\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer -1;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Select show team\n\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tint showTime = endTime - timer -1;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tint[] po = new int[N];\n\t\tint[] c = new int[N];\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tpo[d] += x;\n\t\t\tnow = t;\n\t\t\tif (x > 0) {\n\t\t\t\tif (d == index)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (po[index] < po[d])\n\t\t\t\t\tindex = d;\n\t\t\t\telse if (po[index] == po[d] && index > d)\n\t\t\t\t\tindex = d;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tif (d != index)\n\t\t\t\t\tcontinue;\n\t\t\t\tint maxp = Integer.MIN_VALUE;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (maxp < po[j]) {\n\t\t\t\t\t\tmaxp = po[j];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max score team\n\tprivate static int getMaxScoreTeam(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max show time team\n\tprivate static int getMaxShowTimeTeam(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\t// FIXME: ???????????????????????????????????????????????§???????????§???????????????????????????\n\t\t\tint previousMaxTeam = 1;\n\t\t\tlong previousMaxScore = 0;\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\t\tcurrentTeam = previousMaxTeam;\n\n\t\t\t\t\t// Add show time\n\t\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t\t// Update currentTime\n\t\t\t\t\ttimer = record[TIME];\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\t\t\t\t// Update max score\n\t\t\t\tif (previousMaxScore < teamScoreMap[record[TEAM_NO]]) {\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[record[TEAM_NO]];\n\t\t\t\t\tpreviousMaxTeam = record[TEAM_NO];\n\t\t\t\t} else if(previousMaxTeam == record[TEAM_NO] && record[SCORE] < 0) {\n\t\t\t\t\tpreviousMaxTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[previousMaxTeam];\n\t\t\t\t}\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tif (endTime != timer) {\n\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\tcurrentTeam = previousMaxTeam;\n\t\t\t\tint showTime = endTime - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\t\t\t}\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxShowTimeTeam(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ?????°??????????????????????????????\n        String[] strs = new String[(int) RECORD_AMOUNT];\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            strs[i] = br.readLine();\n        }\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(strs[i].split(\" \"));\n\n            if (now <= record[1]) {\n                // ??´??°????????´??? ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ?????¨???????????????????????°??§????????°???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ???????????´??????????????????????????£???????????°\n        if (point > 0) {\n            if (maxScoreTeam[1] < teams[pointGetter][0]) {\n                maxScoreTeam[0] = pointGetter;\n                maxScoreTeam[1] = teams[pointGetter][0];\n                return;\n            }\n\n            if (maxScoreTeam[1] == teams[pointGetter][0]) {\n                if (maxScoreTeam[0] > pointGetter)\n                    maxScoreTeam[0] = pointGetter;\n                maxScoreTeam[1] = teams[pointGetter][0];\n                return;\n            }\n        }\n\n        if (point < 0) {\n            // ?????°????????´????????????????????§????????£?????´?????????????????????\n            if (maxScoreTeam[0] != pointGetter) {\n                return;\n            }\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                max = Math.max(max, teams[i][0]);\n                team = i;\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tint[] p = new int[n];\n\t\tint[] s = new int[n];\n\n\t\tint maxid = 0;\n\t\tint pret = 0;\n\t\t\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint d = sc.nextInt()-1;\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\ts[maxid] += t - pret;\n\t\t\tpret = t;\n\t\t\tp[d] += x;\n\t\t\t\n\t\t\tif(x>0 && (p[maxid]<p[d] || p[maxid]==p[d] && maxid>d)){\n\t\t\t\tmaxid = d;\n\t\t\t}else if(maxid==d){\n\t\t\t\tfor(int j=0;j<n;j++) if(p[maxid]<p[j]) maxid = j;\n\t\t\t}\n\t\t}\n\t\ts[maxid] += m-pret;\n\t\t\n\t\tmaxid = 0;\n\t\tfor(int i=0;i<n;i++) if(s[maxid]<s[i]) maxid = i;\n\t\tSystem.out.println(maxid+1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max score team\n\tprivate static int getMaxScoreTeam(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max show time team\n\tprivate static int getMaxShowTimeTeam(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\t// Must reduce high cost process like double loop (for test case #7, #8)\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tint previousMaxTeam = 1;\n\t\t\tlong previousMaxScore = 0;\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// If time is proceeded, update show time\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Add show time\n\t\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\t\tteamShowTimeMap[previousMaxTeam] += showTime;\n\n\t\t\t\t\t// Update currentTime\n\t\t\t\t\ttimer = record[TIME];\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\t\t\t\t// Update max score\n\t\t\t\tif (previousMaxScore < teamScoreMap[record[TEAM_NO]]) {\n\t\t\t\t\t// If over, update max score and team\n\t\t\t\t\tpreviousMaxTeam = record[TEAM_NO];\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[record[TEAM_NO]];\n\n\t\t\t\t} else if(previousMaxScore == teamScoreMap[record[TEAM_NO]] && previousMaxTeam > record[TEAM_NO]) {\n\t\t\t\t\t// If equal and teamNo is under, update team\n\t\t\t\t\tpreviousMaxTeam = record[TEAM_NO];\n\n\t\t\t\t} else if(previousMaxTeam == record[TEAM_NO] && record[SCORE] < 0) {\n\t\t\t\t\t// If max score is decreased, search max score again\n\t\t\t\t\tpreviousMaxTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[previousMaxTeam];\n\n\t\t\t\t}\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tif (endTime != timer) {\n\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\tint showTime = endTime - timer;\n\t\t\t\tteamShowTimeMap[previousMaxTeam] += showTime;\n\t\t\t}\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxShowTimeTeam(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[] Scores = new long[TEAM_AMOUNT];\n        // ????????????????????????\n        long[] onAirTimes = new long[TEAM_AMOUNT];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                onAirTimes[(int) maxScoreTeam[0]] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            Scores[(int) record[0]] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(Scores, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        onAirTimes[(int) maxScoreTeam[0]] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < onAirTimes.length; i++) {\n            if (onAirTimes[i] > maxShowTime) {\n                maxShowTime = onAirTimes[i];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[] scores, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ????????????????????????????????????????????§????????´???\n        if (maxScoreTeam[1] < scores[pointGetter]) {\n            setMaxScoreTeam(scores, pointGetter, maxScoreTeam);\n\n            return;\n        } else if (maxScoreTeam[1] == scores[pointGetter] && maxScoreTeam[0] > pointGetter) {\n            // ??????????????????????????¨?????§?????°???????????´???\n            // ????????????????????\\??????????????§?????????????????¨????????????????????????????????????\n            setMaxScoreTeam(scores, pointGetter, maxScoreTeam);\n            return;\n        } else if (maxScoreTeam[0] == pointGetter && point < 0) {\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int index = -1;\n            for (int i = 0; i < scores.length; i++) {\n                if (max < scores[i]) {\n                    max = scores[i];\n                    index = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = index;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n            return;\n        }\n\n        return;\n    }\n\n    /**\n     * ?????? ????????§????????¢????????????????¨??????????\n     * \n     * @param scores\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[] scores, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = scores[pointGetter];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max score team\n\tprivate static int getMaxScoreTeam(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max show time team\n\tprivate static int getMaxShowTimeTeam(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\t// FIXME: ???????????????????????????????????????????????§???????????§???????????????????????????\n\t\t\tint previousMaxTeam = 1;\n\t\t\tlong previousMaxScore = 0;\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\t\tcurrentTeam = previousMaxTeam;\n\n\t\t\t\t\t// Add show time\n\t\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t\t// Update currentTime\n\t\t\t\t\ttimer = record[TIME];\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\t\t\t\t// Update max score\n\t\t\t\tif (previousMaxScore < teamScoreMap[record[TEAM_NO]]) {\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[record[TEAM_NO]];\n\t\t\t\t\tpreviousMaxTeam = record[TEAM_NO];\n\t\t\t\t} else if(previousMaxTeam == record[TEAM_NO] && record[SCORE] < 0) {\n\t\t\t\t\tpreviousMaxTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\t}\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tif (endTime != timer) {\n\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\tcurrentTeam = previousMaxTeam;\n\t\t\t\tint showTime = endTime - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\t\t\t}\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxShowTimeTeam(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, l, r, d, t = 0, x = 0, kiroku = 0, max =0, maxban = 0,max2 = 0, hensu = 0;\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\tint[] ten = new int[n];\n\t\tint[] byou = new int[n];\n\t\tr = scan.nextInt();\n\t\tl = scan.nextInt();\n\t\tfor(int i = 0; i < r; i++){\n\t\t\td = scan.nextInt();\n\t\t\tt = scan.nextInt();\n\t\t\tx = scan.nextInt();\n\t\t\tif(i == 0){\n\t\t\t\tkiroku = t;\n\t\t\t\tbyou[0] = t;\n\t\t\t}\n\t\t\tten[d-1] = ten[d-1] + x;\n\t\t\t//maxbanのひとつまえを入力\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tif(max < ten[j]){\n\t\t\t\t\tmax = ten[j];\n\t\t\t\t\tmaxban = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbyou[maxban] = byou[maxban] + t - kiroku;\n\t\t\tkiroku = t;\n\t\t\thensu = d;\n\t\t}\n\t\tbyou[hensu - 1] = byou[hensu - 1] + (l - t);\n\t\tfor(int k = 1; k < n; k++){\n\t\t\tif(byou[max2] < byou[k]){\n\t\t\t\tmax2 = k;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max2 + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO sc = new IO();\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint[] time = new int[n];\n\t\tTeam[] team = new Team[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tteam[i] = new Team(i,0);\n\t\t}\n\t\tTreeSet<Team> ts = new TreeSet<Team>();\n\t\tint winner = 0;\n\t\tint tbef = 0;\n\t\tfor(int i=0;i<=r;i++) {\n\t\t\tint d,t,x;\n\t\t\tif (i < r) {\n\t\t\t\td = sc.nextInt()-1;\n\t\t\t\tt = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t}else{\n\t\t\t\td = 0;\n\t\t\t\tt = l;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tts.remove(team[d]);\n\t\t\tteam[d].score += x;\n\t\t\tts.add(team[d]);\n\t\t\ttime[winner] += t - tbef;\n\t\t\ttbef = t;\n\t\t\twinner = ts.first().id;\n\t\t}\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (time[i] > max) {\n\t\t\t\tmax = time[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans+1);\n\t}\n\n\tstatic class Team implements Comparable<Team>{\n\t\tint id, score;\n\t\tpublic Team(int id,int score) {\n\t\t\tthis.id = id;\n\t\t\tthis.score = score;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Team) {\n\t\t\t\tTeam t = (Team) o;\n\t\t\t\treturn this.id == t.id;\n\t\t\t}\n\t\t\treturn super.equals(o);\n\t\t}\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (this.score != o.score) {\n\t\t\t\treturn o.score-this.score;\n\t\t\t}\n\t\t\treturn this.id-o.id;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"[id:\" + this.id + \" ,score:\" + this.score + \"]\";\n\t\t}\n\t}\n}\n\nclass IO {\n\tBufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n\tStringBuilder out = new StringBuilder();\n\tint index = 0;\n\tString bfl = null;\n\tString[] bf = new String[0];\n\tprivate boolean read() {\n\t\ttry {\n\t\t\tbfl = bi.readLine();\n\t\t\tif (bfl == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbf = bfl.split(\"\\\\s\");\n\t\t\tindex = 0;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn true;\n\t}\n\tpublic boolean hasNext() { return index < bf.length ? true : read(); }\n\tpublic boolean hasNextLine() { return read(); }\n\tpublic String next() { return hasNext() ? bf[index++] : null; }\n\tpublic String nextLine() { if (hasNextLine()) {index = bf.length; return bfl; }else return null; }\n\tpublic int nextInt() { return Integer.parseInt(next()); }\n\tpublic long nextLong() { return Long.parseLong(next()); }\n\tpublic double nextDouble() { return Double.parseDouble(next()); };\n\tpublic char nextChar() { return next().charAt(0); }\n\tpublic void println(long x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(double x) { out.append(x); out.append(\"\\n\"); }\n\tpublic void println(String s) { out.append(s); out.append(\"\\n\"); }\n\tpublic void println() { out.append(\"\\n\"); }\n\tpublic void print(long x) { out.append(x); }\n\tpublic void print(double x) { out.append(x); }\n\tpublic void print(String s) { out.append(s); }\n\tpublic void print(char c) {out.append(c);}\n\tpublic void flush() {System.out.print(out); out = new StringBuilder(); }\n\tpublic int[] arrayInt(int n) {\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] arrayLong(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double[] arrayDouble(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i] = nextDouble();\n\t\t}\n\t\treturn a;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tint[] p = new int[n+1];\n\t\tint[] s = new int[n+1];\n\n\t\tint id = 1;\n\t\tint pret = 0;\n\t\t\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\ts[id] += t - pret;\n\t\t\tpret = t;\n\t\t\tp[d] += x;\n\t\t\t\n\t\t\tif(x>=0){\n\t\t\t\tif(p[id]<p[d]) id = d;\n\t\t\t\telse if(p[id]==p[d] && id>d) id = d;\n\t\t\t}else{\n\t\t\t\tif(id==d){\n\t\t\t\t\tid = 1;\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(p[id]<p[j]) id = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts[id] += m-pret;\n\t\t\n\t\tid = 1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[id]<s[i]) id = i;\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N???\n        Team[] teams = new Team[TEAM_AMOUNT];\n        fillArrays(teams);\n        // ?????¨????????§?????°???????´????????????°\n        long maxScore = 0;\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ?????¨?????????????????????\n        int onAirTeam = 0;\n\n        // ?????°??????????????????????????????\n        String strs = null;\n        while ((strs = br.readLine()) != null || \"\".equals(strs)) {\n            // ???????????°??¨\n            // if (\"stop\".equals(strs)) {\n            // break;\n            // }\n            long[] record = convertToLongs(strs.split(\" \"));\n\n            if (now <= record[1]) {\n                // ??´??°????????´??? ???????????????????????????????????????????????????\n                teams[onAirTeam].addShowTime(record[1] - now);\n                // ?????¨???????????????????????°??§????????°???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]].addScore(record[2]);\n            // ?????§???????????´????????´????????°????????\\????????????\n            maxScore = getMaxScore(teams);\n            // ???????????????????????????????????????\n            // ??????????????´?????????????°???????ID?????????????????????\n            onAirTeam = getOnAirTeam(teams, maxScore);\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[onAirTeam].addShowTime(CONTEST_TIME - now);\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i].getShowTime() > maxShowTime) {\n                maxShowTime = teams[i].getShowTime();\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    public static void fillArrays(Team[] teams) {\n        for (int i = 0; i < teams.length; i++) {\n            teams[i] = new Team();\n        }\n    }\n\n    private static int getOnAirTeam(Team[] teams, long max) {\n\n        for (int i = 0; i < TEAM_AMOUNT; i++) {\n            if (teams[i].getScore() == max) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    private static long getMaxScore(Team[] teams) {\n        long maxScore = 0;\n\n        for (Team team : teams) {\n            if (maxScore < team.getScore()) {\n                maxScore = team.getScore();\n            }\n        }\n\n        return maxScore;\n    }\n}\n\nclass Team {\n    public long getScore() {\n        return score;\n    }\n\n    public void addScore(long score) {\n        this.score += score;\n    }\n\n    public long getShowTime() {\n        return showTime;\n    }\n\n    public void addShowTime(long showTime) {\n        this.showTime += showTime;\n    }\n\n    private long score = 0;\n    private long showTime = 0;\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tint[] po = new int[N];\n\t\tint[] c = new int[N];\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Pair>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpq.offer(new Pair(i, 0));\n\t\t}\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tpo[d] += x;\n\t\t\tpq.offer(new Pair(d, po[d]));\n\t\t\twhile (true) {\n\t\t\t\tPair p = pq.peek();\n\t\t\t\tif (po[p.id] == p.point) {\n\t\t\t\t\tindex = p.id;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpq.poll();\n\t\t\t}\n\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint id, point;\n\n\t\tpublic Pair(int id, int point) {\n\t\t\tsuper();\n\t\t\tthis.id = id;\n\t\t\tthis.point = point;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [id=\" + id + \", point=\" + point + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + id;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (id != other.id)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.point == o.point)\n\t\t\t\treturn this.id - o.id;\n\t\t\treturn o.point - this.point;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\tPriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\t\n\t\tint[] time = new int[N];\n\t\t\n\t\tint lastTime = 0;\n\t\tqueA.add(new Pair(1,0));\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tqueBX.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!queBX.isEmpty()) {\n\t\t\t\tqueA.offer(queBX.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t\t\n\t\t\tif(i % 1000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Programming Contest\n * PCK2013\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\t\tint N, R, L;\n\t\t\tN = parseInt(st.nextToken());\n\t\t\tR = parseInt(st.nextToken());\n\t\t\tL = parseInt(st.nextToken());\n\n\t\t\tTeam[] team = new Team[N + 1];\n\n\t\t\tQueue<Team> pq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.point == y.point) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.point, x.point);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tteam[i] = new Team(i);\n\t\t\t}\n\n\t\t\tint elapsed = 0;\n\t\t\tpq.offer(team[1]);\n\n\t\t\tfor (int i = 0; i < R; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint d, t, x;\n\t\t\t\td = parseInt(st.nextToken());\n\t\t\t\tt = parseInt(st.nextToken());\n\t\t\t\tx = parseInt(st.nextToken());\n\t\t\t\tpq.peek().time += t - elapsed;\n\t\t\t\t//\n\t\t\t\tpq.remove(team[d]);\n\t\t\t\tteam[d].point += x;\n\t\t\t\tpq.offer(team[d]);\n\t\t\t\t//\n\t\t\t\tif (pq.size() > 5) {\n\t\t\t\t\tList<Team> list = new ArrayList<>();\n\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\tlist.add(pq.poll());\n\t\t\t\t\t}\n\t\t\t\t\tpq.clear();\n\t\t\t\t\tpq.addAll(list);\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\telapsed = t;\n\t\t\t}\n\n\t\t\tpq.peek().time += L - elapsed;\n\n\t\t\t//\n\t\t\tTeam ans = team[1];\n\t\t\t\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (team[i].time > ans.time) ans = team[i];\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.id);\n\t\t}\n\t}\n}\n\nclass Team {\n\n\tint id, time = 0, point = 0;\n\n\tTeam(int id) {\n\t\tthis.id = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\tPriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\t\n\t\tint[] time = new int[N];\n\t\t\n\t\tint lastTime = 0;\n\t\tqueA.add(new Pair(1,0));\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\t\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tqueBX.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!queBX.isEmpty()) {\n\t\t\t\tqueA.offer(queBX.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t\t\t\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #6\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\t\t}\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// End loop if winner is decided\n\t\t\t\tif (teamShowTimeMap[currentTeam] > endTime / 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tPair[] pairs = new Pair[N];\n\t\tPair[] c = new Pair[N];\n\t\tTreeSet<Pair> pointSet = new TreeSet<Pair>();\n\t\tTreeSet<Pair> timeSet = new TreeSet<Pair>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpairs[i] = new Pair(i, 0);\n\t\t\tc[i] = new Pair(i, 0);\n\t\t}\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\ttimeSet.remove(c[index]);\n\t\t\tc[index].point += t - now;\n\t\t\ttimeSet.add(c[index]);\n\t\t\tpointSet.remove(pairs[d]);\n\t\t\tpairs[d].point += x;\n\t\t\tpointSet.add(pairs[d]);\n\t\t\tindex = pointSet.first().id;\n\t\t\tnow = t;\n\t\t}\n\t\ttimeSet.remove(c[index]);\n\t\tc[index].point += L - now;\n\t\ttimeSet.add(c[index]);\n\t\tSystem.out.println(timeSet.first().id + 1);\n\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint id, point;\n\n\t\tpublic Pair(int id, int point) {\n\t\t\tsuper();\n\t\t\tthis.id = id;\n\t\t\tthis.point = point;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [id=\" + id + \", point=\" + point + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + id;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (id != other.id)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.point == o.point)\n\t\t\t\treturn this.id - o.id;\n\t\t\treturn o.point - this.point;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = 0;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ????????????????????????????????????????????§????????´???\n        if (point > 0) {\n            if (maxScoreTeam[1] < teams[pointGetter][0]) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n                return;\n            } else if (maxScoreTeam[1] == teams[pointGetter][0] && maxScoreTeam[0] > pointGetter) {\n                // ????????????????????\\??????????????§?????????????????¨????????????????????????????????????\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n                return;\n            }\n        } else if (maxScoreTeam[0] == pointGetter) {\n\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][0] > max) {\n                    max = teams[i][0];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n            return;\n        }\n        return;\n    }\n\n    /**\n     * ?????? ????????§????????¢????????????????¨??????????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\t\t}\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// End loop if winner is decided\n\t\t\t\tif (teamShowTimeMap[currentTeam] > endTime / 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint d, t, x, time = 0, max = 0;\n\t\tint[] tv = new int[n];\n\t\tint[] score = new int[n];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\td = sc.nextInt() - 1;\n\t\t\tt = sc.nextInt();\n\t\t\tx = sc.nextInt();\n\t\t\ttv[max] += t - time;\n\t\t\tscore[d] += x;\n\t\t\tif (x > 0) {\n\t\t\t\tif (score[max] < score[d]) {\n\t\t\t\t\tmax = d;\n\t\t\t\t} else if (score[max] == score[d]) {\n\t\t\t\t\tmax = min(max, d);\n\t\t\t\t}\n\t\t\t} else if (max == d) {\n\t\t\t\tmax = 0;\n\t\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\t\tif (score[max] < score[j]) {\n\t\t\t\t\t\tmax = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime = t;\n\t\t}\n\t\ttv[max] += l - time;\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (tv[ans] < tv[i]) {\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n}\n\nclass MyScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte()) {\n\t\t\treturn buffer[ptr++];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    /** ?????°????????????????????????????????????????????? */\n    public static int RECORD_TEAM = 0;\n\n    /** ?????°?????????????????????????????????????????? */\n    public static int RECORD_TIME = 1;\n\n    /** ?????°???????????????????????????????????? */\n    public static int RECORD_SCORE = 2;\n\n    /** ????????????????????????????????????????????? */\n    public static int TEAM_SCORE = 0;\n\n    /** ??????????????????????????????????????????????????? */\n    public static int TEAM_SHOW_TIME = 1;\n\n    /** ?????§??????????????????????????????????????? */\n    public static int ON_AIR_TEAM = 0;\n\n    /** ?????§?????????????????????????????? */\n    public static int ON_AIR_SCORE = 1;\n\n    /** ?????? */\n    public static String DELIMITER = \" \";\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(DELIMITER));\n\n        // ?????????????????????????????¨?????°???????´??????????????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´?????????????\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨?????????\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(DELIMITER));\n\n            if (now < record[RECORD_TIME]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[ON_AIR_TEAM]][TEAM_SHOW_TIME] += record[RECORD_TIME] - now;\n                // ???????????´??°??????\n                now = record[RECORD_TIME];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[RECORD_TEAM]][TEAM_SCORE] += record[RECORD_SCORE];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[RECORD_TEAM], record[RECORD_SCORE], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[ON_AIR_TEAM]][TEAM_SHOW_TIME] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = 0;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][TEAM_SHOW_TIME] > maxShowTime) {\n                maxShowTime = teams[i][TEAM_SHOW_TIME];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    /**\n     * ????????? ???????????°?????¬???????????°???????????????????????????????¨?????????????\n     * \n     * @param strs\n     *            ???????????¶????¨??????????????????????\n     */\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    /**\n     * ????????? ?????°?????????????????????????????????????????°???????????????????????????????´???????\n     * \n     * @param strs\n     *            ?????????\n     * @return 1??¬????????????????????±???????´?????????????\n     */\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[RECORD_TEAM] = Long.parseLong(strs[RECORD_TEAM]) - 1;\n        // ????????????\n        record[RECORD_TIME] = Long.parseLong(strs[RECORD_TIME]);\n        // ???????????°\n        record[RECORD_SCORE] = Long.parseLong(strs[RECORD_SCORE]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ????????????????????????????????????????????§????????´???\n        if (point > 0) {\n            if (maxScoreTeam[ON_AIR_SCORE] < teams[pointGetter][TEAM_SCORE]) {\n                set(teams, pointGetter, maxScoreTeam);\n\n                return;\n            } else if (maxScoreTeam[ON_AIR_SCORE] == teams[pointGetter][TEAM_SCORE]\n                    && maxScoreTeam[ON_AIR_TEAM] > pointGetter) {\n                // ????????????????????\\??????????????§?????????????????¨????????????????????????????????????\n                set(teams, pointGetter, maxScoreTeam);\n                return;\n            }\n        } else if (maxScoreTeam[ON_AIR_TEAM] == pointGetter) {\n\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][TEAM_SCORE] > max) {\n                    max = teams[i][TEAM_SCORE];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[ON_AIR_TEAM] = team;\n            // ????????????\n            maxScoreTeam[ON_AIR_SCORE] = max;\n\n            return;\n        }\n        return;\n    }\n\n    /**\n     * ?????? ????????§????????¢????????????????¨??????????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void set(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[ON_AIR_TEAM] = pointGetter;\n        maxScoreTeam[ON_AIR_SCORE] = teams[pointGetter][TEAM_SCORE];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tint[] p = new int[n+1];\n\t\tint[] s = new int[n+1];\n\n\t\tint id = 1;\n\t\tint pret = 0;\n\t\t\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tp[d] += x;\n\t\t\t\n\t\t\tif(x>=0){\n\t\t\t\tif(p[id]<p[d]){\n\t\t\t\t\ts[id] += t - pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tid = d;\n\t\t\t\t}\n\t\t\t\telse if(p[id]==p[d] && id>d){\n\t\t\t\t\ts[id] += t - pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tid = d;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(id==d){\n\t\t\t\t\ts[id] += t - pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(p[id]<p[j]) id = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts[id] += m-pret;\n\t\t\n\t\tid = 1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[id]<s[i]) id = i;\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tPriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\t\n\t\tint[] time = new int[100000];\n\t\t\n\t\tint lastTime = 0;\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tqueA.add(new Pair(1,0));\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\t\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\t\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tqueBX.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!queBX.isEmpty()) {\n\t\t\t\tqueA.offer(queBX.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t\t\t\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ???????????´??????????????????????????£???????????°\n        if (point > 0) {\n            // ???????????´???????????°????????????\n            if (maxScoreTeam[0] == pointGetter) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n                return;\n            }\n\n            // ????????????????????????????????????????????§????????´???\n            if (maxScoreTeam[1] < teams[pointGetter][0]) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n                return;\n            }\n            // ??????????????????????????¨?????§?????°???????????´???\n            if (maxScoreTeam[1] == teams[pointGetter][0]) {\n                if (maxScoreTeam[0] > pointGetter) {\n                    setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n                }\n\n                return;\n            }\n        }\n\n        if (point < 0) {\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                max = Math.max(max, teams[i][0]);\n                team = i;\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n        }\n    }\n\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Programming Contest\n * PCK2013\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\t\tint N, R, L;\n\t\t\tN = parseInt(st.nextToken());\n\t\t\tR = parseInt(st.nextToken());\n\t\t\tL = parseInt(st.nextToken());\n\n\t\t\tTeam[] team = new Team[N + 1];\n\n\t\t\tQueue<Team> pq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.point == y.point) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.point, x.point);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tteam[i] = new Team(i);\n\t\t\t}\n\n\t\t\tint elapsed = 0;\n\t\t\tpq.offer(team[1]);\n\n\t\t\tfor (int i = 0; i < R; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint d, t, x;\n\t\t\t\td = parseInt(st.nextToken());\n\t\t\t\tt = parseInt(st.nextToken());\n\t\t\t\tx = parseInt(st.nextToken());\n\t\t\t\tpq.peek().time += t - elapsed;\n\t\t\t\t//\n\t\t\t\tpq.remove(team[d]);\n\t\t\t\tteam[d].point += x;\n\t\t\t\tpq.offer(team[d]);\n\t\t\t\t//\n\t\t\t\tif (pq.size() > 10) {\n\t\t\t\t\tList<Team> list = new ArrayList<>();\n\t\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\t\tlist.add(pq.poll());\n\t\t\t\t\t}\n\t\t\t\t\tpq.clear();\n\t\t\t\t\tpq.addAll(list);\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\telapsed = t;\n\t\t\t}\n\n\t\t\tpq.peek().time += L - elapsed;\n\n\t\t\t//\n\t\t\tpq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.time == y.time) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.time, x.time);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tpq.offer(team[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(pq.peek().id);\n\t\t}\n\t}\n}\n\nclass Team {\n\n\tint id, time = 0, point = 0;\n\n\tTeam(int id) {\n\t\tthis.id = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 0;\n\t\tlong max = target[0];\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 0;\n\t\tlong max = target[0];\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Select show team\n\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.util.Scanner;\n\n/**\n * @author MS14A\n * @version 2017/03/21\n */\npublic class Main {\n\n    /** Input：空白 */\n    private static final String DELIMITER = \" \";\n\n    /**\n     * メインメソッド\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // ローカルテスト用。提出時は\"System.in\"に修正。\n        InputStream input = System.in;\n        // File input = new File(\"D:/Temp/AOJ/0282_ProgrammingContest.txt\");\n\n        try (Scanner scanner = new Scanner(input)) {\n            int firstLine[] = convertToIntArray(scanner.nextLine().split(\n                    DELIMITER));\n            int numberOfTeam = firstLine[0];\n            int numberOfRecord = firstLine[1];\n            int timeOfContest = firstLine[2];\n\n            // インデックスでチームIDを表し、得点・テレビに映った時間をそれぞれ配列で管理。\n            int[] scores = new int[numberOfTeam];\n            int[] times = new int[numberOfTeam];\n\n            int highScoreTeam = 0;\n            int now = 0;\n            for (int i = 0; i < numberOfRecord; i++) {\n                String line = scanner.nextLine();\n                int[] record = convertToIntArray(line.split(DELIMITER));\n\n                int teamNum = record[0] - 1;\n                int gettingScore = record[2];\n                scores[teamNum] += gettingScore;\n                times[highScoreTeam] += (record[1] - now);\n\n                if (0 < gettingScore) {\n                    if (scores[highScoreTeam] < scores[teamNum]\n                            || (scores[highScoreTeam] == scores[teamNum] && teamNum < highScoreTeam)) {\n                        highScoreTeam = teamNum;\n                    }\n                } else if (teamNum == highScoreTeam) {\n                    highScoreTeam = 0;\n                    for (int j = 0; j < numberOfTeam; j++) {\n                        if (scores[highScoreTeam] < scores[j]) {\n                            highScoreTeam = j;\n                        }\n                    }\n                }\n\n                now = record[1];\n            }\n\n            // 最終処理\n            times[highScoreTeam] += (timeOfContest - now);\n\n            System.out.println(gettingResult(times));\n\n        } catch (Exception e) {\n            // 対応しない。\n            e.printStackTrace();\n        }\n    }\n\n    private static int[] convertToIntArray(String[] target) {\n        int[] result = new int[target.length];\n\n        for (int i = 0; i < target.length; i++) {\n            result[i] = Integer.parseInt(target[i]);\n        }\n\n        return result;\n    }\n\n    private static int gettingResult(int[] times) {\n        int result = 0;\n        int max = 0;\n        for (int i = 0; i < times.length; i++) {\n            if (max < times[i]) {\n                max = times[i];\n                result = i;\n            }\n        }\n        return result + 1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint[] time = new int[n];\n\t\tTeam[] team = new Team[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tteam[i] = new Team(i,0);\n\t\t}\n\t\tTreeSet<Team> ts = new TreeSet<Team>();\n\t\tint winner = 0;\n\t\tint tbef = 0;\n\t\tfor(int i=0;i<=r;i++) {\n\t\t\tint d,t,x;\n\t\t\tif (i < r) {\n\t\t\t\td = sc.nextInt()-1;\n\t\t\t\tt = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t}else{\n\t\t\t\td = 0;\n\t\t\t\tt = l;\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t\tts.remove(team[d]);\n\t\t\tteam[d].score += x;\n\t\t\tts.add(team[d]);\n\t\t\ttime[winner] += t - tbef;\n\t\t\ttbef = t;\n\t\t\twinner = ts.first().id;\n\t\t}\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (time[i] > max) {\n\t\t\t\tmax = time[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans+1);\n\t}\n\n\tstatic class Team implements Comparable<Team>{\n\t\tint id, score;\n\t\tpublic Team(int id,int score) {\n\t\t\tthis.id = id;\n\t\t\tthis.score = score;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Team) {\n\t\t\t\tTeam t = (Team) o;\n\t\t\t\treturn this.id == t.id;\n\t\t\t}\n\t\t\treturn super.equals(o);\n\t\t}\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (this.score != o.score) {\n\t\t\t\treturn o.score-this.score;\n\t\t\t}\n\t\t\treturn this.id-o.id;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"[id:\" + this.id + \" ,score:\" + this.score + \"]\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tint[] po = new int[N];\n\t\tint[] c = new int[N];\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tpo[d] += x;\n\t\t\tif (x > 0) {\n\t\t\t\tif (po[index] < po[d])\n\t\t\t\t\tindex = d;\n\t\t\t\telse if (po[index] == po[d] && index > d)\n\t\t\t\t\tindex = d;\n\t\t\t} else {\n\t\t\t\tif (d != index)\n\t\t\t\t\tcontinue;\n\t\t\t\tint maxp = Integer.MIN_VALUE;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (maxp < po[j]) {\n\t\t\t\t\t\tmaxp = po[j];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max score team\n\tprivate static int getMaxScoreTeam(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max show time team\n\tprivate static int getMaxShowTimeTeam(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\tcurrentTeam = getMaxScoreTeam(teamScoreMap);\n\n\t\t\t\t\t// Add show time\n\t\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t\t// Update currentTime\n\t\t\t\t\ttimer = record[TIME];\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tif (endTime != timer) {\n\t\t\t\tcurrentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\tint showTime = endTime - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\t\t\t}\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxShowTimeTeam(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ???????????´???\n        if (point > 0) {\n\n            // ????????????????????????????????????????????§????????´???\n            if (maxScoreTeam[1] < teams[pointGetter][0]) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n                return;\n            }\n            // ??????????????????????????¨?????§?????°???????????´???\n            if (maxScoreTeam[1] == teams[pointGetter][0]) {\n                // ????????????????????\\??????????????§?????????????????¨????????????????????????????????????\n                if (maxScoreTeam[0] >= pointGetter) {\n                    setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n                }\n\n                return;\n            }\n        }\n        // ???????????´???\n        if (point < 0) {\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][0] > max) {\n                    max = teams[i][0];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n        }\n    }\n\n    /**\n     * ?????? ????????§????????¢????????????????¨??????????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\tlist.set(d, tmp2.point);\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 50000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = -10;\n\t\tint id = 0;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tint tmpCX;\n\t\t\ttmpCX = map.get(new Team(i,list.get(i)));\n\t\t\tif(max < tmpCX) {\n\t\t\t\tmax = tmpCX;\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\t\t}\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// End loop if winner is decided\n\t\t\t\tif (teamShowTimeMap[currentTeam] > endTime / 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\treader.close();\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\tArrayDeque <Pair> list = new ArrayDeque <Pair>();\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\n\t\tint[] time = new int[N];\n\t\t\n\t\tint lastTime = 0;\n\t\tqueA.add(new Pair(1,0));\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\t\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlist.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tlist.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!list.isEmpty()) {\n\t\t\t\tqueA.offer(list.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tint[] po = new int[N];\n\t\tint[] c = new int[N];\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tpo[d] += x;\n\t\t\tif (x > 0 && index != d) {\n\t\t\t\tif (po[index] < po[d])\n\t\t\t\t\tindex = d;\n\t\t\t\telse if (po[index] == po[d] && index < d)\n\t\t\t\t\tindex = d;\n\t\t\t} else if (x < 0) {\n\t\t\t\tint maxp = Integer.MIN_VALUE;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (maxp < po[j]) {\n\t\t\t\t\t\tmaxp = po[j];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class mondai7 {\n\tpublic static void main(String[] args){\n\t\tint n, l, r, d, t = 0, x = 0, kiroku = 0, max =0, maxban = 0,max2 = 0, hensu = 0;\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\tint[] ten = new int[n];\n\t\tint[] byou = new int[n];\n\t\tr = scan.nextInt();\n\t\tl = scan.nextInt();\n\t\tfor(int i = 0; i < r; i++){\n\t\t\td = scan.nextInt();\n\t\t\tt = scan.nextInt();\n\t\t\tx = scan.nextInt();\n\t\t\tif(i == 0){\n\t\t\t\tkiroku = t;\n\t\t\t\tbyou[0] = t;\n\t\t\t}\n\t\t\tten[d-1] = ten[d-1] + x;\n\t\t\t//maxbanのひとつまえを入力\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tif(max < ten[j]){\n\t\t\t\t\tmax = ten[j];\n\t\t\t\t\tmaxban = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbyou[maxban] = byou[maxban] + t - kiroku;\n\t\t\tkiroku = t;\n\t\t\thensu = d;\n\t\t}\n\t\tbyou[hensu - 1] = byou[hensu - 1] + (l - t);\n\t\tfor(int k = 1; k < n; k++){\n\t\t\tif(byou[max2] < byou[k]){\n\t\t\t\tmax2 = k;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max2 + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Programming Contest\n * PCK2013\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\t\tint N, R, L;\n\t\t\tN = parseInt(st.nextToken());\n\t\t\tR = parseInt(st.nextToken());\n\t\t\tL = parseInt(st.nextToken());\n\n\t\t\tTeam[] team = new Team[N + 1];\n\n\t\t\tQueue<Team> pq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.point == y.point) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.point, x.point);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tteam[i] = new Team(i);\n\t\t\t}\n\n\t\t\tint elapsed = 0;\n\t\t\tpq.offer(team[1]);\n\n\t\t\tfor (int i = 0; i < R; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint d, t, x;\n\t\t\t\td = parseInt(st.nextToken());\n\t\t\t\tt = parseInt(st.nextToken());\n\t\t\t\tx = parseInt(st.nextToken());\n\t\t\t\tpq.peek().time += t - elapsed;\n\t\t\t\t//\n\t\t\t\tpq.remove(team[d]);\n\t\t\t\tteam[d].point += x;\n\t\t\t\tpq.offer(team[d]);\n\t\t\t\t//\n\t\t\t\tif (pq.size() > 5) {\n\t\t\t\t\tList<Team> list = new ArrayList<>();\n\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\tlist.add(pq.poll());\n\t\t\t\t\t}\n\t\t\t\t\tpq.clear();\n\t\t\t\t\tpq.addAll(list);\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\telapsed = t;\n\t\t\t}\n\n\t\t\tpq.peek().time += L - elapsed;\n\n\t\t\t//\n\t\t\tpq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.time == y.time) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.time, x.time);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tpq.offer(team[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(pq.peek().id);\n\t\t}\n\t}\n}\n\nclass Team {\n\n\tint id, time = 0, point = 0;\n\n\tTeam(int id) {\n\t\tthis.id = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, l, r, d, p= 0, t = 0, x = 0, kiroku = 0, max =0, max2 = 0, hensu = 0;\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\tint[] ten = new int[n];\n\t\tint[] byou = new int[n];\n\t\tr = scan.nextInt();\n\t\tint[] ban = new int[r];\n\t\tl = scan.nextInt();\n\t\tfor(int i = 0; i < r; i++){\n\t\t\td = scan.nextInt();\n\t\t\tt = scan.nextInt();\n\t\t\tx = scan.nextInt();\n \t\t\tif(i == 0){\n\t\t\t\tkiroku = t;\n\t\t\t\tbyou[0] = t;\n\t\t\t}\n\t\t\tten[d-1] = ten[d-1] + x;\n\t\t\t//maxbanのひとつまえを入力\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tif(ten[max] < ten[j]){\n\t\t\t\t\tmax = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tban[p] = max;\n\t\t\tif(i > 0){\n\t\t\t\tbyou[ban[p-1]] = byou[ban[p-1]] + t - kiroku;\n\t\t\t}\n\t\t\tkiroku = t;\n\t\t\thensu = max;\n\t\t\tmax = 0;\n\t\t\tp = p + 1;\n\t\t}\n\t\tbyou[hensu] = byou[hensu] + (l - t);\n\t\tfor(int k = 1; k < n; k++){\n\t\t\tif(byou[max2] < byou[k]){\n\t\t\t\tmax2 = k;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max2 + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tint L = scanner.nextInt();\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Pair>();\n\t\tint[] s = new int[N];\n\t\tint[] c = new int[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tpq.offer(new Pair(0, i));\n\t\tint u = 0;\n\t\tint t = 0;\n\t\tint d = 0;\n\t\tint x = 0;\n\t\tfor (int i = 0; i <= R; i++) {\n\t\t\tif (i == R)\n\t\t\t\tt = L;\n\t\t\telse {\n\t\t\t\td = scanner.nextInt() - 1;\n\t\t\t\tt = scanner.nextInt();\n\t\t\t\tx = scanner.nextInt();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (s[pq.peek().s] == pq.peek().f) {\n\t\t\t\t\tc[pq.peek().s] += t - u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpq.poll();\n\t\t\t}\n\t\t\tif (i == R)\n\t\t\t\tbreak;\n\t\t\ts[d] += x;\n\t\t\tpq.offer(new Pair(s[d], d));\n\t\t\tu = t;\n\t\t}\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tans = i;\n\t\t\t\tmax = c[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (o.f == this.f)\n\t\t\t\treturn this.s - o.s;\n\t\t\treturn o.f - this.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tint[] p = new int[n+1];\n\t\tint[] s = new int[n+1];\n\t\t\n\t\tint pret = 0;\n\t\tint id = 1;\n\t\tint maxp = 0;\n\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tp[d] += x;\n\t\t\t\n\t\t\tif(x>=0){\n\t\t\t\tif((p[d]==maxp && id>d) || p[d]>maxp){\n\t\t\t\t\ts[id] += t-pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tmaxp = p[d];\n\t\t\t\t\tid = d;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(d==id){\n\t\t\t\t\ts[id] += t-pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tmaxp = Integer.MIN_VALUE;\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(maxp<p[j]){\n\t\t\t\t\t\t\tmaxp = p[j];\n\t\t\t\t\t\t\tid = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts[id] += m-pret;\n\t\t\n\t\tint max = 0;\n\t\tint ans = 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(max<s[i]){\n\t\t\t\tmax = s[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String args[]){\n\t\tnew Main().mainrun();\n\t}\n\n\tprivate Scanner scan;\n\tprivate int N;\n\tprivate int R;\n\tprivate int L;\n\n\tprivate int topteam = 0;\n\tprivate int lasttime = 0;\n\n\n\tprivate int team[][];//0:得点、1:時間\n\n\tprivate void mainrun() {\n\t\tscan = new Scanner(System.in);\n\n\t\tN = scan.nextInt();\n\t\tR = scan.nextInt();\n\t\tL = scan.nextInt();\n\n\t\tteam = new int[N][2];\n\n\t\tfor(int i = 0; i < N ;i++) {\n\t\t\tArrays.fill(team[i],0);\n\t\t}\n\n\n\t\tfor(int i = 0;i < R ; i++) {\n\t\t\tlooprun();\n\t\t}\n\n\t\tteam[topteam][1] += L - lasttime;\n\n\t\t//Arrays.asList(team).stream().forEach(e -> System.out.println(\"score: \" + e[0] + \",time: \" + e[1] ));\n\n\t\tSystem.out.println(timeTopteam() + 1);\n\n\t}\n\n\tprivate void looprun() {\n\t\tint d = scan.nextInt();\n\t\tint t = scan.nextInt();\n\t\tint x = scan.nextInt();\n\n\t\tteam[topteam][1] += t - lasttime;\n\t\tteam[d - 1][0] += x;\n\n\t\ttopteam = scoreTopteam(d - 1,x);\n\t\tlasttime = t;\n\t}\n\n\tprivate int timeTopteam() {\n\t\tint ansS = team[0][1];\n\t\tint ansT = 0;\n\t\tfor(int i = 0;i < N;i++) {\n\t\t\tif(ansS < team[i][1]) {\n\t\t\t\tansS = team[i][1];\n\t\t\t\tansT = i;\n\t\t\t}\n\t\t}\n\n\t\treturn ansT;\n\t}\n\n\tprivate int scoreTopteam(int addId ,int addX) {\n\n\t\tint ansT = topteam;\n\n\t\tif(addX > 0) {\n\t\t\tif(addId != topteam && (team[topteam][0] < team[addId][0] || (team[topteam][0] == team[addId][0] && addId < topteam ))) {\n\t\t\t\tansT = addId;\n\t\t\t}\n\t\t}else {\n\t\t\tif(topteam == addId) {\n\t\t\t\tint ansS = team[0][0];\n\t\t\t\tansT = 0;\n\t\t\t\tfor(int i = 0;i < N;i++) {\n\t\t\t\t\tif(ansS < team[i][0]) {\n\t\t\t\t\t\tansS = team[i][0];\n\t\t\t\t\t\tansT = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ansT;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n/**\n * @author MS14A\n * @version 2017/03/21\n */\npublic class Main {\n\n    /** Input：空白 */\n    private static final String DELIMITER = \" \";\n\n    /**\n     * メインメソッド\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // ローカルテスト用。提出時は\"System.in\"に修正。\n        InputStream input = System.in;\n        // File input = new File(\"D:/Temp/AOJ/0282_ProgrammingContest.txt\");\n\n        try (InputStreamReader inputReader = new InputStreamReader(input);\n                BufferedReader bufferedReader = new BufferedReader(inputReader)) {\n            int firstLine[] = convertToIntArray(bufferedReader.readLine()\n                    .split(DELIMITER));\n            int numberOfTeam = firstLine[0];\n            int numberOfRecord = firstLine[1];\n            int timeOfContest = firstLine[2];\n\n            // インデックスでチームIDを表し、得点・テレビに映った時間をそれぞれ配列で管理。\n            int[] scores = new int[numberOfTeam];\n            int[] times = new int[numberOfTeam];\n\n            int highScoreTeam = 0;\n            int now = 0;\n            for (int i = 0; i < numberOfRecord; i++) {\n                String line = bufferedReader.readLine();\n                int[] record = convertToIntArray(line.split(DELIMITER));\n\n                int teamNum = record[0] - 1;\n                int gettingScore = record[2];\n                scores[teamNum] += gettingScore;\n                times[highScoreTeam] += (record[1] - now);\n\n                if (0 < gettingScore) {\n                    if (scores[highScoreTeam] < scores[teamNum]\n                            || (scores[highScoreTeam] == scores[teamNum] && teamNum < highScoreTeam)) {\n                        highScoreTeam = teamNum;\n                    }\n                } else if (teamNum == highScoreTeam) {\n                    highScoreTeam = 0;\n                    for (int j = 0; j < numberOfTeam; j++) {\n                        if (scores[highScoreTeam] < scores[j]) {\n                            highScoreTeam = j;\n                        }\n                    }\n                }\n\n                now = record[1];\n            }\n\n            // 最終処理\n            times[highScoreTeam] += (timeOfContest - now);\n\n            System.out.println(gettingResult(times));\n\n        } catch (Exception e) {\n            // 対応しない。\n            e.printStackTrace();\n        }\n    }\n\n    private static int[] convertToIntArray(String[] target) {\n        int[] result = new int[target.length];\n\n        for (int i = 0; i < target.length; i++) {\n            result[i] = Integer.parseInt(target[i]);\n        }\n\n        return result;\n    }\n\n    private static int gettingResult(int[] times) {\n        int result = 0;\n        int max = 0;\n        for (int i = 0; i < times.length; i++) {\n            if (max < times[i]) {\n                max = times[i];\n                result = i;\n            }\n        }\n        return result + 1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tint n, l, r, d, p= 0, t = 0, x = 0, kiroku = 0, max =0, max2 = 0, hensu = 0;\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\tint[] ten = new int[n];\n\t\tint[] byou = new int[n];\n\t\tr = scan.nextInt();\n\t\tint[] ban = new int[r];\n\t\tl = scan.nextInt();\n\t\tfor(int i = 0; i < r; i++){\n\t\t\td = scan.nextInt();\n\t\t\tt = scan.nextInt();\n\t\t\tx = scan.nextInt();\n \t\t\tif(i == 0){\n\t\t\t\tkiroku = t;\n\t\t\t\tbyou[0] = t;\n\t\t\t}\n\t\t\tten[d-1] = ten[d-1] + x;\n\t\t\t//maxbanのひとつまえを入力\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tif(ten[max] < ten[j]){\n\t\t\t\t\tmax = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tban[p] = max;\n\t\t\tif(i > 0){\n\t\t\t\tbyou[ban[p-1]] = byou[ban[p-1]] + t - kiroku;\n\t\t\t}\n\t\t\tkiroku = t;\n\t\t\thensu = max;\n\t\t\tmax = 0;\n\t\t\tp = p + 1;\n\t\t}\n\t\tbyou[hensu] = byou[hensu] + (l - t);\n\t\tfor(int k = 1; k < n; k++){\n\t\t\tif(byou[max2] < byou[k]){\n\t\t\t\tmax2 = k;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max2 + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ???????????´??????????????????????????£???????????°\n        if (point > 0) {\n            // ???????????´???????????°????????????\n            if (maxScoreTeam[0] == pointGetter) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n                return;\n            }\n\n            // ????????????????????????????????????????????§????????´???\n            if (maxScoreTeam[1] < teams[pointGetter][0]) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n                return;\n            }\n            // ??????????????????????????¨?????§?????°???????????´???\n            if (maxScoreTeam[1] == teams[pointGetter][0]) {\n                if (maxScoreTeam[0] > pointGetter) {\n                    setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n                }\n\n                return;\n            }\n        }\n\n        if (point < 0) {\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][0] > max) {\n                    max = teams[i][0];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n        }\n    }\n\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 0;\n\t\tlong max = target[0];\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 0;\n\t\tlong max = target[0];\n\t\tfor (int i = 0; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Select show team\n\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tint showTime = endTime - timer -1;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,5000), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tint dx = 0;\n\t\tint dd = 0;\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tdx = x;\n\t\t\tdd = d;\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\t\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\tlist.set(d, tmp2.point);\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 50000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = -10;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tint tmpCX;\n\t\t\tif(map.get(new Team(i,list.get(i))) != null) {\n\t\t\t\ttmpCX = map.get(new Team(i,list.get(i)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmpCX = 0;\n\t\t\t}\n\t\t\tif(max < tmpCX) {\n\t\t\t\tmax = tmpCX;\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Programming Contest\n * PCK2013\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\t\tint N, R, L;\n\t\t\tN = parseInt(st.nextToken());\n\t\t\tR = parseInt(st.nextToken());\n\t\t\tL = parseInt(st.nextToken());\n\n\t\t\tTeam[] team = new Team[N + 1];\n\n\t\t\tQueue<Team> pq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.point == y.point) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.point, x.point);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tteam[i] = new Team(i);\n\t\t\t\tpq.offer(team[i]);\n\t\t\t}\n\n\t\t\tint elapsed = 0;\n\n\t\t\tfor (int i = 0; i < R; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint d, t, x;\n\t\t\t\td = parseInt(st.nextToken());\n\t\t\t\tt = parseInt(st.nextToken());\n\t\t\t\tx = parseInt(st.nextToken());\n\t\t\t\tpq.peek().time += t - elapsed;\n\t\t\t\tpq.remove(team[d]);\n\t\t\t\tteam[d].point += x;\n\t\t\t\tpq.offer(team[d]);\n\t\t\t\telapsed = t;\n\t\t\t}\n\n\t\t\tpq.peek().time += L - elapsed;\n\n\t\t\t//\n\t\t\tpq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.time == y.time) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.time, x.time);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tpq.offer(team[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(pq.peek().id);\n\t\t}\n\t}\n}\n\nclass Team {\n\n\tint id, time = 0, point = 0;\n\n\tTeam(int id) {\n\t\tthis.id = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Select show team\n\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tPair[] pairs = new Pair[N];\n\t\tTreeSet<Pair> set = new TreeSet<Pair>();\n\t\tint[] c = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpairs[i] = new Pair(i, 0);\n\t\t}\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tset.remove(pairs[d]);\n\t\t\tpairs[d].point += x;\n\t\t\tset.add(pairs[d]);\n\t\t\tindex = set.first().id;\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (max < c[i]) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint id, point;\n\n\t\tpublic Pair(int id, int point) {\n\t\t\tsuper();\n\t\t\tthis.id = id;\n\t\t\tthis.point = point;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [id=\" + id + \", point=\" + point + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + id;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (id != other.id)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.point == o.point)\n\t\t\t\treturn this.id - o.id;\n\t\t\treturn o.point - this.point;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n    /** ???????????????° */\n    public static int TEAM_AMOUNT;\n    /** ???¬????????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n \n    public static void main(String[] args) throws IOException {\n \n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ????????????°??????¬????????????°???????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n \n        // ??????????????????????????????¨??????°????????´???????????????????????????????N??? 0:??????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ??????¨?????????§??????°???¨?????????????????´????????????? 0:????????? 1:??????°\n        long[] maxScoreTeam = new long[2];\n \n        // ??????¨?????????????????´?????????????°\n        long now = 0;\n \n        // ????????????°???¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n \n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] += record[1] - now;\n                // ????????????´???°??????\n                now = record[1];\n            }\n \n            // ??????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ??????§????????????´?????????´?????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n \n        }\n \n        // ??????¨?????????~?????????????????????§??????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n \n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n \n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n \n        System.out.println(winner);\n    }\n \n    public static void setPremise(String[] strs) {\n \n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n \n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ????????????°\n        record[2] = Long.parseLong(strs[2]);\n \n        return record;\n    }\n \n    /**\n     * ?????? ????????????????????????????????????????????????????????????°????????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n \n        // ????????????´???\n \n        // ?????????????????????????????????????????????§?????????´???\n        if (maxScoreTeam[1] < teams[pointGetter][0]) {\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n \n            return;\n        } else if (maxScoreTeam[1] == teams[pointGetter][0] && maxScoreTeam[0] > pointGetter) {\n            // ????????????????????\\???????????????§??????????????????¨????????????????????????????????????\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n            return;\n        } else if (maxScoreTeam[0] == pointGetter && point < 0) {\n \n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][0] > max) {\n                    max = teams[i][0];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n \n            return;\n        }\n        return;\n    }\n \n    /**\n     * ?????? ?????????§?????????¢?????????????????¨??????????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "va.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tint L = scanner.nextInt();\n\t\tint[] P = new int[N];\n\t\tint[] T = new int[N];\n\t\tint PT = 0;\n\t\tint n1 = 0;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tint d = scanner.nextInt() - 1;\n\t\t\tint t = scanner.nextInt();\n\t\t\tint x = scanner.nextInt();\n\t\t\tP[d] += x;\n\t\t\tif (x > 0) {\n\t\t\t\tif (P[d] > P[n1] || (P[d] == P[n1] && n1 > d)) {\n\t\t\t\t\tT[n1] += t - PT + 1;\n\t\t\t\t\tPT = t;\n\t\t\t\t\tn1 = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tif (d != n1)\n\t\t\t\t\tcontinue;\n\t\t\t\tint n2 = n1, p2 = P[d];\n\t\t\t\tfor (int j = N - 1; j >= 0; j--) {\n\t\t\t\t\tif (p2 <= P[j]) {\n\t\t\t\t\t\tn2 = j;\n\t\t\t\t\t\tp2 = P[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (n2 != n1) {\n\t\t\t\t\tT[n1] += t - PT + 1;\n\t\t\t\t\tPT = t;\n\t\t\t\t\tn1 = n2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tT[n1] += L - PT + 1;\n\t\tint ans_n = 0, ans_t = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (ans_t < T[i]) {\n\t\t\t\tans_t = T[i];\n\t\t\t\tans_n = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans_n + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n    /** ???????????????° */\n    public static int TEAM_AMOUNT;\n    /** ???¬????????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n \n    public static void main(String[] args) throws IOException {\n \n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ????????????°??????¬????????????°???????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n \n        // ??????????????????????????????¨??????°????????´???????????????????????????????N??? 0:??????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ??????¨?????????§??????°???¨?????????????????´????????????? 0:????????? 1:??????°\n        long[] maxScoreTeam = new long[2];\n \n        // ??????¨?????????????????´?????????????°\n        long now = 0;\n \n        // ????????????°???¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n \n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] += record[1] - now;\n                // ????????????´???°??????\n                now = record[1];\n            }\n \n            // ??????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ??????§????????????´?????????´?????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n \n        }\n \n        // ??????¨?????????~?????????????????????§??????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n \n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n \n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n \n        System.out.println(winner);\n    }\n \n    public static void setPremise(String[] strs) {\n \n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n \n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ????????????°\n        record[2] = Long.parseLong(strs[2]);\n \n        return record;\n    }\n \n    /**\n     * ?????? ????????????????????????????????????????????????????????????°????????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n \n        // ????????????´???\n \n        // ?????????????????????????????????????????????§?????????´???\n        if (maxScoreTeam[1] < teams[pointGetter][0]) {\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n \n            return;\n        } else if (maxScoreTeam[1] == teams[pointGetter][0] && maxScoreTeam[0] > pointGetter) {\n            // ????????????????????\\???????????????§??????????????????¨????????????????????????????????????\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n            return;\n        } else if (maxScoreTeam[0] == pointGetter && point < 0) {\n \n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][0] > max) {\n                    max = teams[i][0];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n \n            return;\n        }\n        return;\n    }\n \n    /**\n     * ?????? ?????????§?????????¢?????????????????¨??????????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tint L = scanner.nextInt();\n\t\tint now = 0;\n\t\tint[][] num = new int[N][2];\n\t\tint index = 0;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tint d = scanner.nextInt() - 1;\n\t\t\tint t = scanner.nextInt();\n\t\t\tint x = scanner.nextInt();\n\t\t\tnum[index][1] += t - now;\n\t\t\tnum[d][0] += x;\n\t\t\tif (index == d && x > 0) {\n\t\t\t\tmax = num[index][0];\n\t\t\t} else if (x > 0) {\n\t\t\t\tif (max < num[d][0]) {\n\t\t\t\t\tmax = num[d][0];\n\t\t\t\t\tindex = d;\n\t\t\t\t} else if (max == num[d][0] && d < index) {\n\t\t\t\t\tindex = d;\n\t\t\t\t}\n\t\t\t} else if (index == d && x < 0) {\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (max < num[j][0]) {\n\t\t\t\t\t\tmax = num[j][0];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow = t;\n\t\t}\n\t\tnum[index][1] += L - now;\n\t\tint time = 0;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (time < num[i][1]) {\n\t\t\t\ttime = num[i][1];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans+1);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class SegTree{\n\t\tint size;\n\t\tint[] index;\n\t\tint[] data;\n\t\t\n\t\tpublic SegTree(int n){\n\t\t\tint n_ = 1;\n\t\t\twhile(n_ < n){\n\t\t\t\tn_ *= 2; \n\t\t\t}\n\t\t\t\n\t\t\tthis.size = n_;\n\t\t\t\n\t\t\t\n\t\t\tindex = new int[this.size * 2 - 1];\n\t\t\tfor(int i = 0; i < index.length; i++){\n\t\t\t\tindex[i] = Math.max(0, i - this.size + 1);\n\t\t\t}\n\t\t\t\n\t\t\tdata = new int[this.size * 2 - 1];\n\t\t\tfor(int i = 0; i < data.length; i++){\n\t\t\t\tdata[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void comp(int t, int k1, int k2){\n\t\t\tdata[t] = Math.max(data[k1], data[k2]);\n\t\t\tif(data[k1] >= data[k2]){\n\t\t\t\tindex[t] = index[k1];\n\t\t\t}else if(data[k1] < data[k2]){\n\t\t\t\tindex[t] = index[k2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void update(int x, int a_diff){\n\t\t\tfinal int t = x + size - 1;\n\t\t\t\n\t\t\t//System.out.println(data.length + \" \" + x + \" \" + t);\n\t\t\tdata[t] += a_diff;\n\t\t\t\n\t\t\tint k = t;\n\t\t\twhile(k != 0){\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tcomp(k, k*2 + 1, k*2 + 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int get_top_index(){\n\t\t\treturn index[0];\n\t\t}\n\t\t\n\t\tpublic int get_top_data(){\n\t\t\treturn data[0];\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int R = sc.nextInt();\n\t\tfinal int L = sc.nextInt();\n\t\t\n\t\tSegTree seg = new SegTree(N);\n\t\tSegTree time = new SegTree(N);\n\t\t\n\t\tint prev_time = 0;\n\t\tfor(int i = 0; i < R; i++){\n\t\t\tfinal int d = sc.nextInt() - 1;\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int x = sc.nextInt();\n\t\t\t\n\t\t\ttime.update(seg.get_top_index(), t - prev_time);\n\t\t\tprev_time = t;\n\t\t\t//System.out.println((time.get_top_index() + 1) + \" \" + time.get_top_data());\n\t\t\t\n\t\t\tseg.update(d, x);\n\t\t\t//System.out.println((seg.get_top_index() + 1) + \" \" + seg.get_top_data());\n\t\t}\n\t\t\n\t\ttime.update(seg.get_top_index(), L - prev_time);\n\t\t\n\t\tSystem.out.println(time.get_top_index() + 1);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N???\n        Team[] teams = new Team[TEAM_AMOUNT];\n        fillArrays(teams);\n        // ?????¨????????§?????°???????´????????????°\n        long maxScore = 0;\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ?????¨?????????????????????\n        int onAirTeam = 0;\n\n        // ?????°??????????????????????????????\n        String[] strs = new String[(int) RECORD_AMOUNT];\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            strs[i] = br.readLine();\n        }\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(strs[i].split(\" \"));\n\n            if (now <= record[1]) {\n                // ??´??°????????´??? ???????????????????????????????????????????????????\n                teams[onAirTeam].addShowTime(record[1] - now);\n                // ?????¨???????????????????????°??§????????°???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]].addScore(record[2]);\n            // ?????§???????????´????????´????????°????????\\????????????\n            maxScore = getMaxScore(teams);\n            // ???????????????????????????????????????\n            // ??????????????´?????????????°???????ID?????????????????????\n            onAirTeam = getOnAirTeam(teams, maxScore);\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[onAirTeam].addShowTime(CONTEST_TIME - now);\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i].getShowTime() > maxShowTime) {\n                maxShowTime = teams[i].getShowTime();\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    public static void fillArrays(Team[] teams) {\n        for (int i = 0; i < teams.length; i++) {\n            teams[i] = new Team();\n        }\n    }\n\n    private static int getOnAirTeam(Team[] teams, long max) {\n\n        for (int i = 0; i < TEAM_AMOUNT; i++) {\n            if (teams[i].getScore() == max) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    private static long getMaxScore(Team[] teams) {\n        long maxScore = 0;\n\n        for (Team team : teams) {\n            if (maxScore < team.getScore()) {\n                maxScore = team.getScore();\n            }\n        }\n\n        return maxScore;\n    }\n}\n\nclass Team {\n    public long getScore() {\n        return score;\n    }\n\n    public void addScore(long score) {\n        this.score += score;\n    }\n\n    public long getShowTime() {\n        return showTime;\n    }\n\n    public void addShowTime(long showTime) {\n        this.showTime += showTime;\n    }\n\n    private long score = 0;\n    private long showTime = 0;\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Programming Contest\n * PCK2013\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\t\tint N, R, L;\n\t\t\tN = parseInt(st.nextToken());\n\t\t\tR = parseInt(st.nextToken());\n\t\t\tL = parseInt(st.nextToken());\n\n\t\t\tTeam[] team = new Team[N + 1];\n\n\t\t\tQueue<Team> pq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.point == y.point) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.point, x.point);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tteam[i] = new Team(i);\n\t\t\t}\n\n\t\t\tint elapsed = 0;\n\t\t\tpq.offer(team[1]);\n\n\t\t\tfor (int i = 0; i < R; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint d, t, x;\n\t\t\t\td = parseInt(st.nextToken());\n\t\t\t\tt = parseInt(st.nextToken());\n\t\t\t\tx = parseInt(st.nextToken());\n\t\t\t\tpq.peek().time += t - elapsed;\n\t\t\t\t//\n\t\t\t\tpq.remove(team[d]);\n\t\t\t\tteam[d].point += x;\n\t\t\t\tpq.offer(team[d]);\n\t\t\t\t//\n\t\t\t\telapsed = t;\n\t\t\t}\n\n\t\t\tpq.peek().time += L - elapsed;\n\n\t\t\t//\n\t\t\tpq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.time == y.time) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.time, x.time);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tpq.offer(team[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(pq.peek().id);\n\t\t}\n\t}\n}\n\nclass Team {\n\n\tint id, time = 0, point = 0;\n\n\tTeam(int id) {\n\t\tthis.id = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Programming Contest\n * PCK2013\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\t\tint N, R, L;\n\t\t\tN = parseInt(st.nextToken());\n\t\t\tR = parseInt(st.nextToken());\n\t\t\tL = parseInt(st.nextToken());\n\n\t\t\tTeam[] team = new Team[N + 1];\n\n\t\t\tQueue<Team> pq = new PriorityQueue<>((x, y) -> {\n\t\t\t\tif (x.point == y.point) {\n\t\t\t\t\treturn Integer.compare(x.id, y.id);\n\t\t\t\t} else {\n\t\t\t\t\treturn Integer.compare(y.point, x.point);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tteam[i] = new Team(i);\n\t\t\t}\n\n\t\t\tint elapsed = 0;\n\t\t\tpq.offer(team[1]);\n\n\t\t\tfor (int i = 0; i < R; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint d, t, x;\n\t\t\t\td = parseInt(st.nextToken());\n\t\t\t\tt = parseInt(st.nextToken());\n\t\t\t\tx = parseInt(st.nextToken());\n\t\t\t\tpq.peek().time += t - elapsed;\n\t\t\t\t//\n\t\t\t\tpq.remove(team[d]);\n\t\t\t\tteam[d].point += x;\n\t\t\t\tpq.offer(team[d]);\n\t\t\t\t//\n\t\t\t\tif (pq.size() > 3) {\n\t\t\t\t\tList<Team> list = new ArrayList<>();\n\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\tlist.add(pq.poll());\n\t\t\t\t\t}\n\t\t\t\t\tpq.clear();\n\t\t\t\t\tpq.addAll(list);\n\t\t\t\t}\n\t\t\t\t//\n\t\t\t\telapsed = t;\n\t\t\t}\n\n\t\t\tpq.peek().time += L - elapsed;\n\n\t\t\t//\n\t\t\tTeam ans = team[1];\n\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (team[i].time > ans.time) ans = team[i];\n\t\t\t}\n\n\t\t\tSystem.out.println(ans.id);\n\t\t}\n\t}\n}\n\nclass Team {\n\n\tint id, time = 0, point = 0;\n\n\tTeam(int id) {\n\t\tthis.id = id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tint dx = 0;\n\t\tint dd = 0;\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tdx = x;\n\t\t\tdd = d;\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\t\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\tlist.set(d, tmp2.point);\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 1000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = 0;\n\t\tboolean tt = false;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tif(map.get(new Team(i,list.get(i))) != null) {\n\t\t\t\tint tmpCX = map.get(new Team(i,list.get(i)));\n\t\t\t\tif(max < tmpCX) {\n\t\t\t\t\tmax = tmpCX;\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.number == o2.number) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\t\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tTeam tmp = map.firstKey();\n\t\t\tint CC = map.get(tmp);\n\t\t\tmap.remove(tmp);\n\t\t\tmap.put(tmp,CC + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\tlist.set(d, tmp2.point);\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 50000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = -10;\n\t\tint id = 0;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tint tmpCX;\n\t\t\tif(map.get(new Team(i,list.get(i))) == null) {\n\t\t\t\ttmpCX = 0;\n\t\t\t}\n\t\t\telse {tmpCX = map.get(new Team(i,list.get(i)));\n\t\t\t}\n\t\t\tif(max < tmpCX) {\n\t\t\t\tmax = tmpCX;\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tint dx = 0;\n\t\tint dd = 0;\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tdx = x;\n\t\t\tdd = d;\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\t\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\tlist.set(d, tmp2.point);\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = 0;\n\t\tboolean tt = false;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tif(map.get(new Team(i,list.get(i))) != null) {\n\t\t\t\tint tmpCX = map.get(new Team(i,list.get(i)));\n\t\t\t\tif(max < tmpCX) {\n\t\t\t\t\tmax = tmpCX;\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.number == o2.number) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\tArrayDeque <Pair> list = new ArrayDeque <Pair>();\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\n\t\tint[] time = new int[N];\n\t\t\n\t\tint lastTime = 0;\n\t\tqueA.add(new Pair(1,0));\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\t\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlist.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tlist.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!list.isEmpty()) {\n\t\t\t\tqueA.offer(list.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tint dx = 0;\n\t\tint dd = 0;\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tdx = x;\n\t\t\tdd = d;\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\t\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\tlist.set(d, tmp2.point);\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 50000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = 0;\n\t\tboolean tt = false;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tif(map.get(new Team(i,list.get(i))) != null) {\n\t\t\t\tint tmpCX = map.get(new Team(i,list.get(i)));\n\t\t\t\tif(max < tmpCX) {\n\t\t\t\t\tmax = tmpCX;\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.number == o2.number) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Select show team\n\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class mondai7 {\n\tpublic static void main(String[] args){\n\t\tint n, l, r, d, p= 0, t = 0, x = 0, kiroku = 0, max =0, max2 = 0, hensu = 0;\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\tint[] ten = new int[n];\n\t\tint[] byou = new int[n];\n\t\tr = scan.nextInt();\n\t\tint[] ban = new int[r];\n\t\tl = scan.nextInt();\n\t\tfor(int i = 0; i < r; i++){\n\t\t\td = scan.nextInt();\n\t\t\tt = scan.nextInt();\n\t\t\tx = scan.nextInt();\n \t\t\tif(i == 0){\n\t\t\t\tkiroku = t;\n\t\t\t\tbyou[0] = t;\n\t\t\t}\n\t\t\tten[d-1] = ten[d-1] + x;\n\t\t\t//maxbanのひとつまえを入力\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tif(ten[max] < ten[j]){\n\t\t\t\t\tmax = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tban[p] = max;\n\t\t\tif(i > 0){\n\t\t\t\tbyou[ban[p-1]] = byou[ban[p-1]] + t - kiroku;\n\t\t\t}\n\t\t\tkiroku = t;\n\t\t\thensu = max;\n\t\t\tmax = 0;\n\t\t\tp = p + 1;\n\t\t}\n\t\tbyou[hensu] = byou[hensu] + (l - t);\n\t\tfor(int k = 1; k < n; k++){\n\t\t\tif(byou[max2] < byou[k]){\n\t\t\t\tmax2 = k;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max2 + 1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,5000), 5000);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(5000);\n\t\t}\n\t\tint dx = 0;\n\t\tint dd = 0;\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tdx = x;\n\t\t\tdd = d;\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\t\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\tlist.set(d, tmp2.point);\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 50000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = -10;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tint tmpCX;\n\t\t\ttmpCX = map.get(new Team(i,list.get(i)));\n\t\t\tif(max < tmpCX) {\n\t\t\t\tmax = tmpCX;\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max score team\n\tprivate static int getMaxScoreTeam(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max show time team\n\tprivate static int getMaxShowTimeTeam(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\t// FIXME: ???????????????????????????????????????????????§???????????§???????????????????????????\n\t\t\tint previousMaxTeam = 1;\n\t\t\tlong previousMaxScore = 0;\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\n\t\t\t\t\t// Add show time\n\t\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\t\tteamShowTimeMap[previousMaxTeam] += showTime;\n\n\t\t\t\t\t// Update currentTime\n\t\t\t\t\ttimer = record[TIME];\n\t\t\t\t}\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\t\t\t\t// Update max score\n\t\t\t\tif (previousMaxScore < teamScoreMap[record[TEAM_NO]]) {\n\t\t\t\t\t// If over, update max score and team\n\t\t\t\t\tpreviousMaxTeam = record[TEAM_NO];\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[record[TEAM_NO]];\n\n\t\t\t\t} else if(previousMaxTeam == record[TEAM_NO] && record[SCORE] < 0) {\n\t\t\t\t\t// If max score is decreased, search max score again\n\t\t\t\t\tpreviousMaxTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\t\tpreviousMaxScore = teamScoreMap[previousMaxTeam];\n\n\t\t\t\t}\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tif (endTime != timer) {\n\t\t\t\t// currentTeam = getMaxScoreTeam(teamScoreMap);\n\t\t\t\tint showTime = endTime - timer;\n\t\t\t\tteamShowTimeMap[previousMaxTeam] += showTime;\n\t\t\t}\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.println(\"previousMaxScore: \" + previousMaxScore + \", previousMaxTeam: \" + previousMaxTeam);\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxShowTimeTeam(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "00.05 sec    18484 KB    122 lines     1798 bytes    2014-10-17 22:00\n?\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\nimport java.util.*;\n \nclass MyComp implements Comparator<Pair> {\n \n    public int compare(Pair arg0, Pair arg1) {\n        Pair t0 = (Pair) arg0;\n        Pair t1 = (Pair) arg1;\n        if(t0.time > t1.time) {\n            return -1;\n             \n        }\n        else if(t0.time < t1.time) {\n            return 1;\n        }\n        else {\n            if(t0.id > t1.id) {\n                return 1;\n            }\n            else if(t0.id < t1.id) {\n                return -1;\n            }\n            else {\n                return 0;\n            }\n        }\n         \n    }\n     \n}\n \n \nclass Pair {\n    int id;\n    int time;\n    public Pair(int d, int t) {\n        this.id = d;\n        this.time = t;\n    }\n    public Pair(Pair a) {\n        this.id = a.id;\n        this.time = a.time;\n    }\n     \n}\n \npublic class Main {\n \n \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n         \n         \n         \n        PriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n         \n        PriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n         \n        int N = stdIn.nextInt();\n        int R = stdIn.nextInt();\n        int L = stdIn.nextInt();\n         \n        int[] time = new int[100000];\n         \n        int lastTime = 0;\n        queA.add(new Pair(1,0);\n         \n        for(int i = 0; i < R; i++) {\n             \n            int d = stdIn.nextInt();\n            int t = stdIn.nextInt();\n            int x = stdIn.nextInt();\n            time[queA.peek().id-1] += t - lastTime;\n            boolean atta = false;\n             \n            while(!queA.isEmpty()) {\n                 \n                Pair tmp = queA.poll();\n                 \n                if(tmp.id == d) {\n                    atta = true;\n                    tmp.time +=  x;\n                    queBX.offer(tmp);\n                    break;\n                }\n                else {\n                    queBX.offer(tmp);\n                }\n            }\n             \n            if(!atta) {\n                queBX.offer(new Pair(d,x));\n            }\n                 \n            while(!queBX.isEmpty()) {\n                queA.offer(queBX.poll());\n            }\n             \n \n            lastTime = t;\n                 \n        }\n         \n        time[queA.peek().id-1] += L - lastTime;\n         \n        int timeA = 0;\n        int idA = 0;\n        for(int i = 0; i < time.length; i++) {\n            if(timeA < time[i]) {\n                timeA = time[i];\n                idA = i;\n            }\n        }\n         \n        System.out.println(idA+1);\n         \n    }\n     \n \n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ????????????????????????????????????????????§????????´???\n        if (maxScoreTeam[1] < teams[pointGetter][0]) {\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n            return;\n        } else if (maxScoreTeam[1] == teams[pointGetter][0] && maxScoreTeam[0] > pointGetter) {\n            // ????????????????????\\??????????????§?????????????????¨????????????????????????????????????\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n            return;\n        } else if (maxScoreTeam[0] == pointGetter && point < 0) {\n\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][0] > max) {\n                    max = teams[i][0];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n            return;\n        }\n        return;\n    }\n\n    /**\n     * ?????? ????????§????????¢????????????????¨??????????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tint[] po = new int[N];\n\t\tint[] c = new int[N];\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tpo[d] += x;\n\t\t\tif (x > 0) {\n\t\t\t\tif (d == index)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (po[index] < po[d])\n\t\t\t\t\tindex = d;\n\t\t\t\telse if (po[index] == po[d] && index > d)\n\t\t\t\t\tindex = d;\n\t\t\t} else {\n\t\t\t\tif (d != index)\n\t\t\t\t\tcontinue;\n\t\t\t\tint maxp = Integer.MIN_VALUE;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (maxp < po[j]) {\n\t\t\t\t\t\tmaxp = po[j];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tTreeMap<Integer,Integer> map = new TreeMap<Integer, Integer>();  //point id\n\t\tTreeMap<Integer,Integer> map2 = new TreeMap<Integer, Integer>(); //id point\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\tint[] d = new int[R+1];\n\t\tint[] t = new int[R+1];\n\t\tint[] x = new int[R+1];\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\td[i] = stdIn.nextInt();\n\t\t\tt[i] = stdIn.nextInt();\n\t\t\tx[i] = stdIn.nextInt();\n\t\t}\n\t\td[R] = 1;\n\t\tt[R] = L;\n\t\tx[R] = 0;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tmap.put(0, 1);\n\t\t\tmap2.put(i+1,0);\n\t\t}\n\t\tint nowtime = 0;\n\t\tint[] time = new int[N+1];\n\t\tfor(int i = 0; i <= R; i++) {\n\t\t\ttime[map.get(map.lastKey())] += t[i] - nowtime;\n\t\t\tmap.put(map2.get(d[i]) + x[i],d[i] );\n\t\t\tmap2.put(d[i], map2.get(d[i]) + x[i]);\n\t\t\tnowtime = t[i];\n\t\t\t\n\t\t\tmap.remove(map2.get(d[i]) - x[i]);\n\t\t\t\n\t\t}\n\t\tint max = 0;\n\t\tint id = 0;\n\t\tfor(int i = 0; i < N+1; i++) {\n\t\t\tif(max < time[i]) {\n\t\t\t\tmax = time[i];\n\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(id);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\t\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint[] list = new int[n+1];\n\t\tint[] time = new int[n+1];\n\t\tint top = 0;\n\t\tint id  = 1;\n\t\tint nowtime = 0;\n\t\tint timemax = 0;\n\t\tint timemaxid = 0;\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\t\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\ttime[id] += t - nowtime;\n\t\t\tif(time[id] > timemax) {\n\t\t\t\ttimemax = time[id];\n\t\t\t\ttimemaxid = id;\n\t\t\t}\n\t\t\tnowtime = t;\n\t\t\tlist[d] += x;\n\t\t\tif(id == d) {\n\t\t\t\ttop += x;\n\t\t\t}\n\t\t\tif(x < 0 && d == id) {\n\t\t\t\tfor(int j = 1; j < n+1; j++) {\n\t\t\t\t\tif(top < list[j] || (top == list[j] && j < id)) {\n\t\t\t\t\t\ttop = list[j];\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(x > 0 && d != id) {\n\t\t\t\tif(top < list[d] || (top == list[d] && d < id)) {\n\t\t\t\t\ttop = list[d];\n\t\t\t\t\tid = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\ttime[id] += l - nowtime;\n\t\tif(time[id] > timemax) {\n\t\t\ttimemax = time[id];\n\t\t\ttimemaxid = id;\n\t\t}\n\t\tout.println(timemaxid);\n\t\tout.flush();\n\t}\n\n}\n\n\n\t\t\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ?????°??????????????????????????????\n        String[] strs = new String[(int) RECORD_AMOUNT];\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            strs[i] = br.readLine();\n        }\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(strs[i].split(\" \"));\n\n            if (now <= record[1]) {\n                // ??´??°????????´??? ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ?????¨???????????????????????°??§????????°???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        if (point > 0) {\n            if (maxScoreTeam[1] < teams[pointGetter][0]) {\n                maxScoreTeam[0] = pointGetter;\n                maxScoreTeam[1] = teams[pointGetter][0];\n            }\n        }\n\n        if (point < 0) {\n            // ?????°????????´????????????????????§????????£?????´?????????????????????\n            if (maxScoreTeam[0] != pointGetter) {\n                return;\n            }\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                max = Math.max(max, teams[i][0]);\n                team = i;\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tint[] po = new int[N];\n\t\tint[] c = new int[N];\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tpo[d] += x;\n\t\t\tif (x > 0 && index != d) {\n\t\t\t\tif (po[index] < po[d])\n\t\t\t\t\tindex = d;\n\t\t\t\telse if (po[index] == po[d] && index < d)\n\t\t\t\t\tindex = d;\n\t\t\t} else if (x < 0) {\n\t\t\t\tint maxp = Integer.MIN_VALUE;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (maxp < po[j]) {\n\t\t\t\t\t\tmaxp = po[j];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\tlist.set(d, tmp2.point);\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 50000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = -10;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tint tmpCX;\n\t\t\ttmpCX = map.get(new Team(i,list.get(i)));\n\t\t\tif(max < tmpCX) {\n\t\t\t\tmax = tmpCX;\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tRMQ<Team> rmq = new RMQ<Team>(n);\n\t\tint[] time = new int[n];\n\t\tint[] d = new int[r+2];\n\t\tint[] t = new int[r+2];\n\t\tint[] x = new int[r+2];\n\t\tfor(int i=1;i<=r;i++) {\n\t\t\td[i] = sc.nextInt()-1;\n\t\t\tt[i] = sc.nextInt();\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\td[0] = 0;\n\t\tt[0] = 0;\n\t\tx[0] = 0;\n\t\td[r+1] = 0;\n\t\tt[r+1] = l;\n\t\tx[r+1] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\trmq.update(i, new Team(i,0));\n\t\t}\n\t\tfor(int i=0;i<=r;i++) {\n\t\t\tTeam tmp = rmq.get(d[i]);\n\t\t\trmq.update(d[i], new Team(tmp.id,tmp.score + x[i]));\n\t\t\tTeam winner = rmq.query(0, n);\n\t\t\ttime[winner.id] += t[i+1] - t[i];\n\t\t\t//System.out.println(rmq.toString());\n\t\t}\n\t\t//System.out.println(Arrays.toString(time));\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (time[i] > max) {\n\t\t\t\tmax = time[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans+1);\n\t}\n\n\tstatic class Team implements Comparable<Team>{\n\t\tint id, score;\n\t\tpublic Team(int id,int score) {\n\t\t\tthis.id = id;\n\t\t\tthis.score = score;\n\t\t}\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (this.score != o.score) {\n\t\t\t\treturn o.score-this.score;\n\t\t\t}\n\t\t\treturn this.id-o.id;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"[id:\" + this.id + \" ,score:\" + this.score + \"]\";\n\t\t}\n\t}\n\n}\nclass RMQ<E extends Comparable<E>> {\n\tprivate int size;\n\tprivate int size_ = 1;\n\tprivate ArrayList<E> data;\n\n\tpublic RMQ(int size) {\n\t\tthis.size = size;\n\t\twhile(this.size_<this.size) {\n\t\t\tthis.size_*=2;\n\t\t}\n\t\tdata = new ArrayList<E>(Collections.nCopies(size_*2-1, (E) null));//[size_*2-1];\n\t}\n\n\tpublic E get(int k) {\n\t\treturn data.get(k+size_-1);\n\t}\n\n\tpublic void update(int k,E a) {\n\t\tk+=size_-1;\n\t\tdata.set(k, a);\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tdata.set(k, min(data.get(k*2+1),data.get(k*2+2)));\n\t\t}\n\t}\n\n\tpublic E query(int a,int b) {\n\t\treturn query(a,b,0,0,size_);\n\t}\n\n\t//[a,b)の区間について処理\n\t//kは接点の番号,[l,r)がkに対応する節点\n\tprivate E query(int a,int b,int k,int l,int r) {\n\t\tif (r<=a || b<=l) {\n\t\t\treturn null;\n\t\t}\n\t\tif (a<=l && r<=b) {\n\t\t\treturn data.get(k);\n\t\t}else{\n\t\t\treturn min(query(a,b,k*2+1,l,(l+r)/2), query(a,b,k*2+2,(l+r)/2,r));\n\t\t}\n\t}\n\n\t//nullはINFとして扱う\n\tprivate E min(E a,E b) {\n\t\tif (a!=null && b!=null) {\n\t\t\treturn a.compareTo(b)<0 ? a : b;\n\t\t}else if (a!=null) {\n\t\t\treturn a;\n\t\t}else{\n\t\t\treturn b;\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\treturn data.subList(size_-1, size+size_).toString();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tint[] p = new int[n+1];\n\t\tint[] s = new int[n+1];\n\n\t\tint maxid = 1;\n\t\tint pret = 0;\n\t\t\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\ts[maxid] += t - pret;\n\t\t\tpret = t;\n\t\t\tp[d] += x;\n\t\t\t\n\t\t\tif(x>=0 && p[maxid]<p[d]){\n\t\t\t\tmaxid = d;\n\t\t\t}else if(x>=0 && p[maxid]==p[d] && maxid>d){\n\t\t\t\tmaxid = d;\n\t\t\t}else if(maxid==d){\n\t\t\t\tfor(int j=1;j<=n;j++) if(p[maxid]<p[j]) maxid = j;\n\t\t\t}\n\t\t}\n\t\ts[maxid] += m-pret;\n\t\t\n\t\tmaxid = 1;\n\t\tfor(int i=1;i<=n;i++) if(s[maxid]<s[i]) maxid = i;\n\t\tSystem.out.println(maxid);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tRMQ<Team> rmq = new RMQ<Team>(n);\n\t\tint[] time = new int[n];\n\t\tint[] d = new int[r+2];\n\t\tint[] t = new int[r+2];\n\t\tint[] x = new int[r+2];\n\t\tfor(int i=1;i<=r;i++) {\n\t\t\td[i] = sc.nextInt()-1;\n\t\t\tt[i] = sc.nextInt();\n\t\t\tx[i] = sc.nextInt();\n\t\t}\n\t\td[0] = 0;\n\t\tt[0] = 0;\n\t\tx[0] = 0;\n\t\td[r+1] = 0;\n\t\tt[r+1] = l;\n\t\tx[r+1] = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\trmq.update(i, new Team(i,0));\n\t\t}\n\t\tfor(int i=0;i<=r;i++) {\n\t\t\tTeam tmp = rmq.get(d[i]);\n\t\t\trmq.update(d[i], new Team(tmp.id,tmp.score + x[i]));\n\t\t\tTeam winner = rmq.query(0, n);\n\t\t\ttime[winner.id] += t[i+1] - t[i];\n\t\t\t//System.out.println(rmq.toString());\n\t\t}\n\t\t//System.out.println(Arrays.toString(time));\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif (time[i] > max) {\n\t\t\t\tmax = time[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans+1);\n\t}\n\n\tstatic class Team implements Comparable<Team>{\n\t\tint id, score;\n\t\tpublic Team(int id,int score) {\n\t\t\tthis.id = id;\n\t\t\tthis.score = score;\n\t\t}\n\t\tpublic int compareTo(Team o) {\n\t\t\tif (this.score != o.score) {\n\t\t\t\treturn -Integer.compare(this.score, o.score);\n\t\t\t}\n\t\t\treturn Integer.compare(this.id, o.id);\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn \"[id:\" + this.id + \" ,score:\" + this.score + \"]\";\n\t\t}\n\t}\n\n}\nclass RMQ<E extends Comparable<E>> {\n\tprivate int size;\n\tprivate int size_ = 1;\n\tprivate ArrayList<E> data;\n\n\tpublic RMQ(int size) {\n\t\tthis.size = size;\n\t\twhile(this.size_<this.size) {\n\t\t\tthis.size_*=2;\n\t\t}\n\t\tdata = new ArrayList<E>(Collections.nCopies(size_*2-1, (E) null));//[size_*2-1];\n\t}\n\n\tpublic E get(int k) {\n\t\treturn data.get(k+size_-1);\n\t}\n\n\tpublic void update(int k,E a) {\n\t\tk+=size_-1;\n\t\tdata.set(k, a);\n\t\twhile(k>0) {\n\t\t\tk=(k-1)/2;\n\t\t\tdata.set(k, min(data.get(k*2+1),data.get(k*2+2)));\n\t\t}\n\t}\n\n\tpublic E query(int a,int b) {\n\t\treturn query(a,b,0,0,size_);\n\t}\n\n\t//[a,b)の区間について処理\n\t//kは接点の番号,[l,r)がkに対応する節点\n\tprivate E query(int a,int b,int k,int l,int r) {\n\t\tif (r<=a || b<=l) {\n\t\t\treturn null;\n\t\t}\n\t\tif (a<=l && r<=b) {\n\t\t\treturn data.get(k);\n\t\t}else{\n\t\t\treturn min(query(a,b,k*2+1,l,(l+r)/2), query(a,b,k*2+2,(l+r)/2,r));\n\t\t}\n\t}\n\n\t//nullはINFとして扱う\n\tprivate E min(E a,E b) {\n\t\tif (a!=null && b!=null) {\n\t\t\treturn a.compareTo(b)<0 ? a : b;\n\t\t}else if (a!=null) {\n\t\t\treturn a;\n\t\t}else{\n\t\t\treturn b;\n\t\t}\n\t}\n\n\tpublic String toString() {\n\t\treturn data.subList(size_-1, size+size_).toString();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\t\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\t\n\t\t\tlist.set(d, tmp2.point);\n\t\t\ttime = t;\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = 0;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tint tmpCX = map.get(new Team(i,list.get(i)));\n\t\t\tif(max < tmpCX) {\n\t\t\t\tmax = tmpCX;\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.number == o2.number) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tint L = scanner.nextInt();\n\t\tPair[] pairs = new Pair[N];\n\t\tTreeSet<Pair> set = new TreeSet<Pair>();\n\t\tint[] c = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpairs[i] = new Pair(i, 0);\n\t\t\tset.add(pairs[i]);\n\t\t}\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tint d = scanner.nextInt() - 1;\n\t\t\tint t = scanner.nextInt();\n\t\t\tint x = scanner.nextInt();\n\t\t\tc[index] += t - now;\n\t\t\tset.remove(pairs[d]);\n\t\t\tpairs[d].point += x;\n\t\t\tset.add(pairs[d]);\n\t\t\tindex = set.first().id;\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (max < c[i]) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint id, point;\n\n\t\tpublic Pair(int id, int point) {\n\t\t\tsuper();\n\t\t\tthis.id = id;\n\t\t\tthis.point = point;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [id=\" + id + \", point=\" + point + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + id;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (id != other.id)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.point == o.point)\n\t\t\t\treturn this.id - o.id;\n\t\t\treturn o.point - this.point;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tPriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\t\n\t\tint[] time = new int[100000];\n\t\t\n\t\tint lastTime = 0;\n\t\tqueA.add(new Pair(1,0));\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\t\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\t\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tqueBX.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!queBX.isEmpty()) {\n\t\t\t\tqueA.offer(queBX.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t\t\t\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\t\n\t\tint[] p = new int[n+1];\n\t\tint[] s = new int[n+1];\n\n\t\tint id = 1;\n\t\tint pret = 0;\n\t\t\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\t\n\t\t\tp[d] += x;\n\t\t\t\n\t\t\tif(x>=0){\n\t\t\t\tif(p[id]<p[d]){\n\t\t\t\t\ts[id] += t - pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tid = d;\n\t\t\t\t}\n\t\t\t\telse if(p[id]==p[d] && id>d){\n\t\t\t\t\ts[id] += t - pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tid = d;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(id==d){\n\t\t\t\t\ts[id] += t - pret;\n\t\t\t\t\tpret = t;\n\t\t\t\t\tid = 0;\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(p[id]<p[j]) id = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts[id] += m-pret;\n\t\t\n\t\tid = 1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(s[id]<s[i]) id = i;\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[] Scores = new long[TEAM_AMOUNT];\n        // ????????????????????????\n        long[] onAirTimes = new long[TEAM_AMOUNT];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                onAirTimes[(int) maxScoreTeam[0]] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            Scores[(int) record[0]] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(Scores, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        onAirTimes[(int) maxScoreTeam[0]] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < onAirTimes.length; i++) {\n            if (onAirTimes[i] > maxShowTime) {\n                maxShowTime = onAirTimes[i];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[] scores, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ???????????´???\n\n        // ????????????????????????????????????????????§????????´???\n        if (maxScoreTeam[1] < scores[pointGetter]) {\n            setMaxScoreTeam(scores, pointGetter, maxScoreTeam);\n\n            return;\n        } else if (maxScoreTeam[1] == scores[pointGetter] && maxScoreTeam[0] > pointGetter) {\n            // ??????????????????????????¨?????§?????°???????????´???\n            // ????????????????????\\??????????????§?????????????????¨????????????????????????????????????\n            setMaxScoreTeam(scores, pointGetter, maxScoreTeam);\n            return;\n        } else if (maxScoreTeam[0] == pointGetter && point < 0) {\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int index = -1;\n            for (int i = 0; i < scores.length; i++) {\n                if (max < scores[i]) {\n                    max = scores[i];\n                    index = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = index;\n            // ????????????\n            maxScoreTeam[1] = max;\n        }\n    }\n\n    /**\n     * ?????? ????????§????????¢????????????????¨??????????\n     * \n     * @param scores\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[] scores, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = scores[pointGetter];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tint L = scanner.nextInt();\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Pair>();\n\t\tint[] s = new int[N];\n\t\tList<Pair> list = new ArrayList<Main.Pair>();\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpq.offer(new Pair(0, i));\n\t\t\tlist.add(new Pair(0, i));\n\t\t}\n\t\tint u = 0;\n\t\tint t = 0;\n\t\tint d = 0;\n\t\tint x = 0;\n\t\tfor (int i = 0; i <= R; i++) {\n\t\t\tif (i == R)\n\t\t\t\tt = L;\n\t\t\telse {\n\t\t\t\td = scanner.nextInt() - 1;\n\t\t\t\tt = scanner.nextInt();\n\t\t\t\tx = scanner.nextInt();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tPair p = pq.peek();\n\t\t\t\tif (s[p.s] == p.f) {\n\t\t\t\t\tlist.get(p.s).f = list.get(p.s).f + t - u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpq.poll();\n\t\t\t}\n\t\t\tif (i == R)\n\t\t\t\tbreak;\n\t\t\ts[d] += x;\n\t\t\tpq.offer(new Pair(s[d], d));\n\t\t\tu = t;\n\t\t}\n\t\tCollections.sort(list);\n\t\tSystem.out.println(list.get(0).s + 1);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (o.f == this.f)\n\t\t\t\treturn this.s - o.s;\n\t\t\treturn o.f - this.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\t\tStringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n\t\tint N = Integer.parseInt(tokenizer.nextToken());\n\t\tint R = Integer.parseInt(tokenizer.nextToken());\n\t\tint L = Integer.parseInt(tokenizer.nextToken());\n\t\tint[] po = new int[N];\n\t\tint[] c = new int[N];\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\tint d = Integer.parseInt(tokenizer.nextToken()) - 1;\n\t\t\tint t = Integer.parseInt(tokenizer.nextToken());\n\t\t\tint x = Integer.parseInt(tokenizer.nextToken());\n\t\t\tc[index] += t - now;\n\t\t\tpo[d] += x;\n\t\t\tnow = t;\n\t\t\tif (x > 0) {\n\t\t\t\tif (d == index)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (po[index] < po[d])\n\t\t\t\t\tindex = d;\n\t\t\t\telse if (po[index] == po[d] && index > d)\n\t\t\t\t\tindex = d;\n\t\t\t} else {\n\t\t\t\tif (d != index)\n\t\t\t\t\tcontinue;\n\t\t\t\tint maxp = Integer.MIN_VALUE;\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (maxp < po[j]) {\n\t\t\t\t\t\tmaxp = po[j];\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (c[i] > max) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass MyComp implements Comparator<Pair> {\n\n\tpublic int compare(Pair arg0, Pair arg1) {\n\t\tPair t0 = (Pair) arg0;\n\t\tPair t1 = (Pair) arg1;\n\t\tif(t0.time > t1.time) {\n\t\t\treturn -1;\n\t\t\t\n\t\t}\n\t\telse if(t0.time < t1.time) {\n\t\t\treturn 1;\n\t\t}\n\t\telse {\n\t\t\tif(t0.id > t1.id) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(t0.id < t1.id) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n\n\nclass Pair {\n\tint id;\n\tint time;\n\tpublic Pair(int d, int t) {\n\t\tthis.id = d;\n\t\tthis.time = t;\n\t}\n\tpublic Pair(Pair a) {\n\t\tthis.id = a.id;\n\t\tthis.time = a.time;\n\t}\n\t\n}\n\npublic class Main {\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\tPriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tPriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n\t\t\n\t\tint N = stdIn.nextInt();\n\t\tint R = stdIn.nextInt();\n\t\tint L = stdIn.nextInt();\n\t\t\n\t\tint[] time = new int[N];\n\t\t\n\t\tint lastTime = 0;\n\t\t\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\t\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tqueA.add(new Pair(1,0));\n\t\t\ttime[queA.peek().id-1] += t - lastTime;\n\t\t\tboolean atta = false;\n\t\t\t\n\t\t\twhile(!queA.isEmpty()) {\n\t\t\t\t\n\t\t\t\tPair tmp = queA.poll();\n\t\t\t\t\n\t\t\t\tif(tmp.id == d) {\n\t\t\t\t\tatta = true;\n\t\t\t\t\ttmp.time +=  x;\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tqueBX.offer(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!atta) {\n\t\t\t\tqueBX.offer(new Pair(d,x));\n\t\t\t}\n\t\t\t\t\n\t\t\twhile(!queBX.isEmpty()) {\n\t\t\t\tqueA.offer(queBX.poll());\n\t\t\t}\n\t\t\t\n\n\t\t\tlastTime = t;\n\t\t\t\t\n\t\t}\n\t\t\n\t\ttime[queA.peek().id-1] += L - lastTime;\n\t\t\n\t\tint timeA = 0;\n\t\tint idA = 0;\n\t\tfor(int i = 0; i < time.length; i++) {\n\t\t\tif(timeA < time[i]) {\n\t\t\t\ttimeA = time[i];\n\t\t\t\tidA = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(idA+1);\n\t\t\n\t}\n\t\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint d, t, x, time = 0, max = 0;\n\t\tint[] tv = new int[n];\n\t\tint[] score = new int[n];\n\t\tfor (int i = 0; i < r; i++) {\n\t\t\td = sc.nextInt() - 1;\n\t\t\tt = sc.nextInt();\n\t\t\tx = sc.nextInt();\n\t\t\ttv[max] += t - time;\n\t\t\tscore[d] += x;\n\t\t\tif (x > 0) {\n\t\t\t\tif (score[max] < score[d]) {\n\t\t\t\t\tmax = d;\n\t\t\t\t} else if (score[max] == score[d]) {\n\t\t\t\t\tmax = min(max, d);\n\t\t\t\t}\n\t\t\t} else if (max == d) {\n\t\t\t\tmax = 0;\n\t\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\t\tif (score[max] < score[j]) {\n\t\t\t\t\t\tmax = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime = t;\n\t\t}\n\t\ttv[max] += l - time;\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (tv[ans] < tv[i]) {\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\t\tsc.close();\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ?????°??????????????????????????????\n        String[] strs = new String[(int) RECORD_AMOUNT];\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            strs[i] = br.readLine();\n        }\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(strs[i].split(\" \"));\n\n            if (now <= record[1]) {\n                // ??´??°????????´??? ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ?????¨???????????????????????°??§????????°???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ???????????´??????????????????????????£???????????°\n        if (point > 0) {\n            if (maxScoreTeam[0] == pointGetter) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n            }\n\n            if (maxScoreTeam[1] < teams[pointGetter][0]) {\n                setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n                return;\n            }\n\n            if (maxScoreTeam[1] == teams[pointGetter][0]) {\n                if (maxScoreTeam[0] > pointGetter)\n                    setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n                return;\n            }\n        }\n\n        if (point < 0) {\n            // ?????°????????´????????????????????§????????£?????´?????????????????????\n            if (maxScoreTeam[0] != pointGetter) {\n                return;\n            }\n\n            // ???????????????????????????????????´?????????????????????????±??????????????????????\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                max = Math.max(max, teams[i][0]);\n                team = i;\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n        }\n    }\n\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.util.Scanner;\n\n/**\n * @author MS14A\n * @version 2017/03/21\n */\npublic class Main {\n\n    /** Input：空白 */\n    private static final String DELIMITER = \" \";\n\n    /**\n     * メインメソッド\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        // ローカルテスト用。提出時は\"System.in\"に修正。\n        InputStream input = System.in;\n        // File input = new File(\"D:/Temp/AOJ/0282_ProgrammingContest.txt\");\n\n        try (Scanner scanner = new Scanner(input)) {\n            int firstLine[] = convertToIntArray(scanner.nextLine().split(\n                    DELIMITER));\n            int numberOfTeam = firstLine[0];\n            int numberOfRecord = firstLine[1];\n            int timeOfContest = firstLine[2];\n\n            // インデックスでチームIDを表し、得点・テレビに映った時間をそれぞれ配列で管理。\n            int[] scores = new int[numberOfTeam];\n            int[] times = new int[numberOfTeam];\n\n            int highScoreTeam = 0;\n            int now = 0;\n            for (int i = 0; i < numberOfRecord; i++) {\n                String line = scanner.nextLine();\n                int[] record = convertToIntArray(line.split(DELIMITER));\n\n                int gettingScore = record[2];\n                int teamNum = record[0] - 1;\n                scores[teamNum] += gettingScore;\n                times[highScoreTeam] += record[1] - now;\n\n                if (0 < gettingScore) {\n                    if (scores[highScoreTeam] < scores[teamNum]\n                            || (scores[highScoreTeam] == scores[teamNum] && teamNum < highScoreTeam)) {\n                        highScoreTeam = teamNum;\n                    }\n                } else if (teamNum == highScoreTeam) {\n                    for (int j = 0; j < numberOfTeam; j++) {\n                        if (scores[highScoreTeam] < scores[j]) {\n                            highScoreTeam = j;\n                        }\n                    }\n                }\n\n                now = record[1];\n            }\n\n            // 最終処理\n            times[highScoreTeam] += (timeOfContest - now);\n\n            System.out.println(gettingResult(times));\n\n        } catch (Exception e) {\n            // 対応しない。\n            e.printStackTrace();\n        }\n    }\n\n    private static int[] convertToIntArray(String[] target) {\n        int[] result = new int[target.length];\n\n        for (int i = 0; i < target.length; i++) {\n            result[i] = Integer.parseInt(target[i]);\n        }\n\n        return result;\n    }\n\n    private static int gettingResult(int[] times) {\n        int result = 0;\n        int max = 0;\n        for (int i = 0; i < times.length; i++) {\n            if (max < times[i]) {\n                max = times[i];\n                result = i;\n            }\n        }\n        return result + 1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint N = scanner.nextInt();\n\t\tint R = scanner.nextInt();\n\t\tint L = scanner.nextInt();\n\t\tPair[] pairs = new Pair[N];\n\t\tTreeSet<Pair> set = new TreeSet<Pair>();\n\t\tint[] c = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tpairs[i] = new Pair(i, 0);\n\t\t}\n\t\tint now = 0;\n\t\tint index = 0;\n\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tint d = scanner.nextInt() - 1;\n\t\t\tint t = scanner.nextInt();\n\t\t\tint x = scanner.nextInt();\n\t\t\tc[index] += t - now;\n\t\t\tset.remove(pairs[d]);\n\t\t\tpairs[d].point += x;\n\t\t\tset.add(pairs[d]);\n\t\t\tindex = set.first().id;\n\t\t\tnow = t;\n\t\t}\n\t\tc[index] += L - now;\n\t\tint ans = 0;\n\t\tint max = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (max < c[i]) {\n\t\t\t\tmax = c[i];\n\t\t\t\tans = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans + 1);\n\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint id, point;\n\n\t\tpublic Pair(int id, int point) {\n\t\t\tsuper();\n\t\t\tthis.id = id;\n\t\t\tthis.point = point;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [id=\" + id + \", point=\" + point + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + id;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (id != other.id)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.point == o.point)\n\t\t\t\treturn this.id - o.id;\n\t\t\treturn o.point - this.point;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(long[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndex(int[] target) {\n\t\tint index = 1;\n\t\tlong max = target[1];\n\t\tfor (int i = 2; i < target.length; i++) {\n\t\t\tif (max < target[i]) {\n\t\t\t\tmax = target[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tlong[] teamScoreMap = new long[teamNo + 1];\n\t\t\tint[] teamShowTimeMap = new int[teamNo + 1];\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Select show team\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\t\t}\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t\t// Update score\n\t\t\t\tteamScoreMap[record[TEAM_NO]] += record[SCORE];\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tcurrentTeam = getMaxIndex(teamScoreMap);\n\t\t\tint showTime = endTime - timer;\n\t\t\tteamShowTimeMap[currentTeam] += showTime;\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tArrays.stream(teamScoreMap).forEach(score -> System.out.print(score + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tArrays.stream(teamShowTimeMap).forEach(t -> System.out.print(t + \", \"));;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndex(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic String[][] map;\n\tstatic boolean[][] al;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tTreeMap<Team,Integer> map = new TreeMap<Team,Integer>(new MyComparator());\n\t\tint n = stdIn.nextInt();\n\t\tint r = stdIn.nextInt();\n\t\tint l = stdIn.nextInt();\n\t\t\n\t\tint time = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tmap.put(new Team(i+1,0), 0);\n\t\t}\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tint dx = 0;\n\t\tint dd = 0;\n\t\tfor(int i = 0; i< r; i++) {\n\t\t\tint d = stdIn.nextInt();\n\t\t\tint t = stdIn.nextInt();\n\t\t\tint x = stdIn.nextInt();\n\t\t\tdx = x;\n\t\t\tdd = d;\n\t\t\tTeam tmp = map.firstKey();\n\t\t\t\n\t\t\tmap.put(tmp,map.get(tmp) + t - time);\n\t\t\tTeam tmp2 = new Team(d,list.get(d));\n\t\t\tmap.remove(tmp2);\n\t\t\ttmp2.point += x;\n\t\t\t\n\t\t\tmap.put(tmp2, list.get(d));\n\t\t\tlist.set(d, tmp2.point);\n\t\t\t\n\t\t\t\n\t\t\ttime = t;\n\t\t\tif(i % 50000 == 0) {\n\t\t\t\tSystem.gc();\n\t\t\t}\n\t\t}\n\t\tTeam tmp = map.firstKey();\n\t\tmap.put(tmp,l-time);\n\t\t\n\t\tint max = 0;\n\t\tboolean tt = false;\n\t\tint id = 0;\n\t\tfor(int i = 1; i < list.size(); i++) {\n\t\t\tint tmpCX;\n\t\t\tif(map.get(new Team(i,list.get(i))) != null) {\n\t\t\t\ttmpCX = map.get(new Team(i,list.get(i)));\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmpCX = 0;\n\t\t\t}\n\t\t\tif(max < tmpCX) {\n\t\t\t\tmax = tmpCX;\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(id);\n\t}\n\t\n\t\n}\n\nclass Team {\n\tpublic int number;\n\tpublic int point;\n\tpublic Team(int number, int point) {\n\t\tthis.number = number;\n\t\tthis.point  = point;\n\t}\n}\n\nclass MyComparator implements Comparator<Team> {\n\n\tpublic int compare(Team o1, Team o2) {\n\t\tif(o1.number == o2.number) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(o1.point < o2.point) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(o1.point > o2.point) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o1.number < o2.number) {\n\t\t\treturn -1;\n\t\t}\n\t\telse if(o2.number > o2.number) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * 0282 Programming Contest\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// Read contest basic info\n\t\tContest contest = readContest();\n\n\t\t// Read record and count up time\n\t\tcontest.start();\n\n\t\t// Show result\n\t\tSystem.out.println(contest.getWinner());\n\t}\n\n\t// Read contest basic info\n\tprivate static Contest readContest() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] splitted = reader.readLine().split(\" \");\n\t\tint[] converted = convertStringToInt(splitted);\n\t\treturn new Contest(converted[0], converted[1], converted[2], reader);\n\t}\n\n\t// Convert string array to int array\n\tprivate static int[] convertStringToInt(String[] str) {\n\t\tint[] converted = new int[str.length];\n\t\tfor (int i = 0; i < str.length; i++) {\n\t\t\tconverted[i] = Integer.parseInt(str[i]);\n\t\t}\n\t\treturn converted;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndexLong(Map<Integer, Long> target) {\n\t\tif (target.size() == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint index = target.keySet().iterator().next();\n\t\tlong max = target.values().iterator().next();\n\t\tfor (Map.Entry<Integer, Long> entry : target.entrySet()) {\n\t\t\tif (max < entry.getValue()) {\n\t\t\t\tmax = entry.getValue();\n\t\t\t\tindex = entry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Get max index\n\tprivate static int getMaxIndexInt(Map<Integer, Integer> target) {\n\t\tif (target.size() == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint index = target.keySet().iterator().next();\n\t\tint max = target.values().iterator().next();\n\t\tfor (Map.Entry<Integer, Integer> entry : target.entrySet()) {\n\t\t\tif (max < entry.getValue()) {\n\t\t\t\tmax = entry.getValue();\n\t\t\t\tindex = entry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\t// Contest\n\tprivate static class Contest {\n\t\tprivate static final int TEAM_NO = 0;\n\t\tprivate static final int TIME = 1;\n\t\tprivate static final int SCORE = 2;\n\n\t\tprivate int teamNo;\n\t\tprivate int recordNo;\n\t\tprivate int endTime;\n\t\tprivate BufferedReader reader;\n\t\tprivate int winner;\n\n\t\t// Constructor\n\t\tpublic Contest(int teamNo, int recordNo, int time, BufferedReader reader) {\n\t\t\tthis.teamNo = teamNo;\n\t\t\tthis.recordNo = recordNo;\n\t\t\tthis.endTime = time;\n\t\t\tthis.reader = reader;\n\t\t}\n\n\t\t// Start contest\n\t\tpublic void start() throws IOException {\n\t\t\tint timer = 0;\n\t\t\tint currentTeam = 1;\n\t\t\tMap<Integer, Long> teamScoreMap = new TreeMap<>();\n\t\t\tMap<Integer, Integer> teamShowTimeMap = new TreeMap<>();\n\n\t\t\tfor (int i = 0; i < recordNo; i++) {\n\t\t\t\tint[] record = convertStringToInt(reader.readLine().split(\" \"));\n\n\t\t\t\t// Reduce high cost process, for test case #7\n\t\t\t\tif (record[TIME] != timer) {\n\t\t\t\t\t// Select show team\n\t\t\t\t\tcurrentTeam = getMaxIndexLong(teamScoreMap);\n\t\t\t\t}\n\t\t\t\t// Add show time\n\t\t\t\tint showTime = record[TIME] - timer;\n\t\t\t\tint currentShowTime = (teamShowTimeMap.get(currentTeam) == null) ? 0 : teamShowTimeMap.get(currentTeam);\n\t\t\t\tteamShowTimeMap.put(currentTeam, currentShowTime + showTime);\n\n\t\t\t\t// Update score\n\t\t\t\tlong currentScore = (teamScoreMap.get(record[TEAM_NO]) == null) ? 0 : teamScoreMap.get(record[TEAM_NO]);\n\t\t\t\tteamScoreMap.put(record[TEAM_NO], currentScore + record[SCORE]);\n\n\t\t\t\t// Update currentTime\n\t\t\t\ttimer = record[TIME];\n\n\t\t\t\t// Debug\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"Record: \" + i);\n\t\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\t\tteamScoreMap.forEach((team, score) -> System.out.print(score + \", \"));\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\t\tteamShowTimeMap.forEach((team, time) -> System.out.print(time + \", \"));\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println();\n\t\t\t\t*/\n\t\t\t}\n\n\t\t\t// Finally add show time to end of contest\n\t\t\tcurrentTeam = getMaxIndexLong(teamScoreMap);\n\t\t\tint showTime = endTime - timer;\n\t\t\tint currentShowTime = (teamShowTimeMap.get(currentTeam) == null) ? 0 : teamShowTimeMap.get(currentTeam);\n\t\t\tteamShowTimeMap.put(currentTeam, currentShowTime + showTime);\n\n\t\t\t// Debug\n\t\t\t/*\n\t\t\tSystem.out.println(\"Finish.\");\n\t\t\tSystem.out.print(\"teamScore: \");\n\t\t\tteamScoreMap.forEach((team, score) -> System.out.print(score + \", \"));\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.print(\"teamShowTime: \");\n\t\t\tteamShowTimeMap.forEach((team, time) -> System.out.print(time + \", \"));\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println();\n\t\t\t*/\n\n\t\t\t// Decide winner\n\t\t\twinner = getMaxIndexInt(teamShowTimeMap);\n\t\t}\n\n\t\t// Get winner\n\t\tpublic int getWinner() {\n\t\t\treturn winner;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main {\n\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\tint r = sc.nextInt();\n\t\tint l = sc.nextInt();\n\t\tint[] list = new int[n+1];\n\t\tint[] time = new int[n+1];\n\t\tint top = 0;\n\t\tint id  = 1;\n\t\tint nowtime = 0;\n\t\tfor(int i = 0; i < r; i++) {\n\t\t\t\n\t\t\tint d = sc.nextInt();\n\t\t\tint t = sc.nextInt();\n\t\t\tint x = sc.nextInt();\n\t\t\ttime[id] += t - nowtime;\n\t\t\tnowtime = t;\n\t\t\tlist[d] += x;\n\t\t\tif(id == d) {\n\t\t\t\ttop += x;\n\t\t\t}\n\t\t\tif(x < 0 && d == id) {\n\t\t\t\tfor(int j = 1; j < n+1; j++) {\n\t\t\t\t\tif(top < list[j] || (top == list[j] && j < id)) {\n\t\t\t\t\t\ttop = list[j];\n\t\t\t\t\t\tid = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tif(x > 0 && d != id) {\n\t\t\t\tif(top < list[d] || (top == list[d] && d < id)) {\n\t\t\t\t\ttop = list[d];\n\t\t\t\t\tid = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\ttime[id] += l - nowtime;\n\t\tint max = 0;\n\t\tint ix = 0;\n\t\tfor(int i = 1; i < n+1; i++) {\n\t\t\tif(max < time[i]) {\n\t\t\t\tmax = time[i];\n\t\t\t\tix = i;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.println(ix);\n\t\tout.flush();\n\t}\n\n}\n\n\n\t\t\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n    \n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static class SegTree{\n\t\tint size;\n\t\tint[] index;\n\t\tint[] data;\n\t\t\n\t\tpublic SegTree(int n){\n\t\t\tint n_ = 1;\n\t\t\twhile(n_ < n){\n\t\t\t\tn_ *= 2; \n\t\t\t}\n\t\t\t\n\t\t\tthis.size = n_;\n\t\t\t\n\t\t\t\n\t\t\tindex = new int[this.size * 2 - 1];\n\t\t\tfor(int i = 0; i < index.length; i++){\n\t\t\t\tindex[i] = Math.max(0, i - this.size + 1);\n\t\t\t}\n\t\t\t\n\t\t\tdata = new int[this.size * 2 - 1];\n\t\t\tfor(int i = 0; i < data.length; i++){\n\t\t\t\tdata[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void comp(int t, int k1, int k2){\n\t\t\tdata[t] = Math.max(data[k1], data[k2]);\n\t\t\tif(data[k1] >= data[k2]){\n\t\t\t\tindex[t] = index[k1];\n\t\t\t}else if(data[k1] < data[k2]){\n\t\t\t\tindex[t] = index[k2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void update(int x, int a_diff){\n\t\t\tfinal int t = x + size - 1;\n\t\t\t\n\t\t\t//System.out.println(data.length + \" \" + x + \" \" + t);\n\t\t\tdata[t] += a_diff;\n\t\t\t\n\t\t\tint k = t;\n\t\t\twhile(k != 0){\n\t\t\t\tk = (k - 1) / 2;\n\t\t\t\tcomp(k, k*2 + 1, k*2 + 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int get_top_index(){\n\t\t\treturn index[0];\n\t\t}\n\t\t\n\t\tpublic int get_top_data(){\n\t\t\treturn data[0];\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int R = sc.nextInt();\n\t\tfinal int L = sc.nextInt();\n\t\t\n\t\tSegTree seg = new SegTree(N);\n\t\tSegTree time = new SegTree(N);\n\t\t\n\t\tint prev_time = 0;\n\t\tfor(int i = 0; i < R; i++){\n\t\t\tfinal int d = sc.nextInt() - 1;\n\t\t\tfinal int t = sc.nextInt();\n\t\t\tfinal int x = sc.nextInt();\n\t\t\t\n\t\t\ttime.update(seg.get_top_index(), t - prev_time);\n\t\t\tprev_time = t;\n\t\t\t//System.out.println((time.get_top_index() + 1) + \" \" + time.get_top_data());\n\t\t\t\n\t\t\tseg.update(d, x);\n\t\t\t//System.out.println((seg.get_top_index() + 1) + \" \" + seg.get_top_data());\n\t\t}\n\t\t\n\t\ttime.update(seg.get_top_index(), L - prev_time);\n\t\t\n\t\tSystem.out.println(time.get_top_index() + 1);\n\t}\n\t\npublic static class Scanner {\n\t\t\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "00.05 sec    18484 KB    122 lines     1798 bytes    2014-10-17 22:00\n?\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\nimport java.util.*;\n \nclass MyComp implements Comparator<Pair> {\n \n    public int compare(Pair arg0, Pair arg1) {\n        Pair t0 = (Pair) arg0;\n        Pair t1 = (Pair) arg1;\n        if(t0.time > t1.time) {\n            return -1;\n             \n        }\n        else if(t0.time < t1.time) {\n            return 1;\n        }\n        else {\n            if(t0.id > t1.id) {\n                return 1;\n            }\n            else if(t0.id < t1.id) {\n                return -1;\n            }\n            else {\n                return 0;\n            }\n        }\n         \n    }\n     \n}\n \n \nclass Pair {\n    int id;\n    int time;\n    public Pair(int d, int t) {\n        this.id = d;\n        this.time = t;\n    }\n    public Pair(Pair a) {\n        this.id = a.id;\n        this.time = a.time;\n    }\n     \n}\n \npublic class Main {\n \n \n    public static void main(String[] args) {\n        Scanner stdIn = new Scanner(System.in);\n         \n         \n         \n        PriorityQueue <Pair> queA = new PriorityQueue <Pair>(11,new MyComp());\n         \n        PriorityQueue <Pair> queBX = new PriorityQueue <Pair>(11,new MyComp());\n         \n        int N = stdIn.nextInt();\n        int R = stdIn.nextInt();\n        int L = stdIn.nextInt();\n         \n        int[] time = new int[100000];\n         \n        int lastTime = 0;\n         \n        for(int i = 0; i < R; i++) {\n             \n            int d = stdIn.nextInt();\n            int t = stdIn.nextInt();\n            int x = stdIn.nextInt();\n            queA.add(new Pair(1,0));\n            time[queA.peek().id-1] += t - lastTime;\n            boolean atta = false;\n             \n            while(!queA.isEmpty()) {\n                 \n                Pair tmp = queA.poll();\n                 \n                if(tmp.id == d) {\n                    atta = true;\n                    tmp.time +=  x;\n                    queBX.offer(tmp);\n                    break;\n                }\n                else {\n                    queBX.offer(tmp);\n                }\n            }\n             \n            if(!atta) {\n                queBX.offer(new Pair(d,x));\n            }\n                 \n            while(!queBX.isEmpty()) {\n                queA.offer(queBX.poll());\n            }\n             \n \n            lastTime = t;\n                 \n        }\n         \n        time[queA.peek().id-1] += L - lastTime;\n         \n        int timeA = 0;\n        int idA = 0;\n        for(int i = 0; i < time.length; i++) {\n            if(timeA < time[i]) {\n                timeA = time[i];\n                idA = i;\n            }\n        }\n         \n        System.out.println(idA+1);\n         \n    }\n     \n \n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    /** ??????????????° */\n    public static int TEAM_AMOUNT;\n    /** ??¬???????????° */\n    public static long RECORD_AMOUNT;\n    /** ???????????????????????? */\n    public static long CONTEST_TIME;\n\n    public static void main(String[] args) throws IOException {\n\n        // ??\\???????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // ???????????°?????¬???????????°??????????????????????????????????´?\n        setPremise(br.readLine().split(\" \"));\n\n        // ?????????????????????????????¨?????°???????´???????????????????????????????N??? 0:?????° 1:????????????\n        long[][] teams = new long[TEAM_AMOUNT][2];\n        // ?????¨????????§?????°??¨????????????????´????????????? 0:????????? 1:?????°\n        long[] maxScoreTeam = new long[2];\n\n        // ?????¨????????????????´????????????°\n        long now = 0;\n\n        // ???????????°??¨\n        // if (\"stop\".equals(strs)) {\n        // break;\n        // }\n        for (int i = 0; i < RECORD_AMOUNT; i++) {\n            long[] record = convertToLongs(br.readLine().split(\" \"));\n\n            if (now < record[1]) {\n                // ???????????????????????????????????????????????????\n                teams[(int) maxScoreTeam[0]][1] = record[1] - now;\n                // ???????????´??°??????\n                now = record[1];\n            }\n\n            // ?????????????????????????????°????????????\n            teams[(int) record[0]][0] += record[2];\n            // ?????§???????????´????????´????????°????????\\????????????\n            setMaxScore(teams, (int) record[0], record[2], maxScoreTeam);\n\n        }\n\n        // ?????¨?????????~????????????????????§?????????????????§??????????????????????????????\n        teams[(int) maxScoreTeam[0]][1] += CONTEST_TIME - now;\n\n        // ??????????????????\n        long maxShowTime = 0;\n        // ????????????????????????-1???\n        int winner = -1;\n\n        for (int i = 0; i < teams.length; i++) {\n            if (teams[i][1] > maxShowTime) {\n                maxShowTime = teams[i][1];\n                winner = i + 1;\n            }\n        }\n\n        System.out.println(winner);\n    }\n\n    public static void setPremise(String[] strs) {\n\n        TEAM_AMOUNT = Integer.parseInt(strs[0]);\n        RECORD_AMOUNT = Long.parseLong(strs[1]);\n        CONTEST_TIME = Long.parseLong(strs[2]);\n    }\n\n    public static long[] convertToLongs(String[] strs) {\n        long[] record = new long[3];\n        // ?????????ID\n        record[0] = Long.parseLong(strs[0]) - 1;\n        // ????????????\n        record[1] = Long.parseLong(strs[1]);\n        // ???????????°\n        record[2] = Long.parseLong(strs[2]);\n\n        return record;\n    }\n\n    /**\n     * ?????? ???????????????????????????????????????????????????????????°???????´???????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param point\n     * @param maxScoreTeam\n     */\n    private static void setMaxScore(long[][] teams, int pointGetter, long point, long[] maxScoreTeam) {\n\n        // ???????????´???\n\n        // ????????????????????????????????????????????§????????´???\n        if (maxScoreTeam[1] < teams[pointGetter][0]) {\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n\n            return;\n        } else if (maxScoreTeam[1] == teams[pointGetter][0] && maxScoreTeam[0] > pointGetter) {\n            // ????????????????????\\??????????????§?????????????????¨????????????????????????????????????\n            setMaxScoreTeam(teams, pointGetter, maxScoreTeam);\n            return;\n        } else if (maxScoreTeam[0] == pointGetter && point < 0) {\n\n            long max = 0;\n            int team = 0;\n            for (int i = 0; i < teams.length; i++) {\n                if (teams[i][0] > max) {\n                    max = teams[i][0];\n                    team = i;\n                }\n            }\n            // ?????????????????????\n            maxScoreTeam[0] = team;\n            // ????????????\n            maxScoreTeam[1] = max;\n\n            return;\n        }\n        return;\n    }\n\n    /**\n     * ?????? ????????§????????¢????????????????¨??????????\n     * \n     * @param teams\n     * @param pointGetter\n     * @param maxScoreTeam\n     */\n    private static void setMaxScoreTeam(long[][] teams, int pointGetter, long[] maxScoreTeam) {\n        maxScoreTeam[0] = pointGetter;\n        maxScoreTeam[1] = teams[pointGetter][0];\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(500000, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret; // zureru\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(1100000, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret;\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(r, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tvar tmax = 0;\n\t\tvar tmaxi = 0;\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret;\n\t\t\tif (t[pred] > tmax) { tmax = t[pred]; tmaxi = pred; }\n\t\t\telse if (t[pred] == tmax && pred < tmaxi) tmaxi = pred;\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tConsole.WriteLine(tmaxi + 1);\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(120000, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tt[pred] += wt - pret; // zureru\n\t\t\tpret = wt;\n\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(120000, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret; // zureru\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int tt { get; set; }\n\tpublic int ns { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.ns > x.ns | (this.ns == x.ns && this.id < x.id)) return 1;\n\t\telse if (this.ns < x.ns | (this.ns == x.ns && this.id > x.id))   return -1;\n\t\telse   return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tgetAns(n, r, L);\n\t}\n\tstatic void getAns ( int n, int r , int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(100,1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, tt = 0, ns = ds });\n\t\tfor (int i = 0; i < r-1; i++)\n\t\t{\n\t\t\tvar a = pq.Peek();\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.ns == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t id = int.Parse(line[0]) - 1;\n\t\t\t wt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[a.id] += wt - pret;\n\t\t\tpret = wt;\n\t\t\tif (a.id != id)\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, tt = t[id], ns = s[id] });\n\t\t\t}\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.ns == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int tt { get; set; }\n\tpublic int ns { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.ns > x.ns | (this.ns == x.ns && this.id < x.id)) return 1;\n\t\telse if (this.ns < x.ns | (this.ns == x.ns && this.id > x.id))   return -1;\n\t\telse   return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns ( int n, int r , int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(100000,1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, tt = 0, ns = ds });\n\t\tfor (int i = 0; i < r-1; i++)\n\t\t{\n\t\t\tvar a = pq.Peek();\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.ns == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t id = int.Parse(line[0]) - 1;\n\t\t\t wt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[a.id] += wt - pret;\n\t\t\tpret = wt;\n\t\t\tif (a.id != id)\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, tt = t[id], ns = s[id] });\n\t\t\t}\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.ns == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int tt { get; set; }\n\tpublic int ns { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.ns > x.ns | (this.ns == x.ns && this.id < x.id)) return 1;\n\t\telse if (this.ns < ns | (this.ns == x.ns && this.id > x.id))   return -1;\n\t\telse   return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tgetAns(n, r, L);\n\t}\n\tstatic void getAns ( int n, int r , int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(100,1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, tt = 0, ns = ds });\n\t\tfor (int i = 0; i < r-1; i++)\n\t\t{\n\t\t\tvar a = pq.Peek();\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.ns == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t id = int.Parse(line[0]) - 1;\n\t\t\t wt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[a.id] += wt - pret;\n\t\t\tpret = wt;\n\t\t\tif (a.id != id)\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, tt = t[id], ns = s[id] });\n\t\t\t}\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.ns == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(200000, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tvar a = pq.Peek();\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tt[pred] += wt - pret; // zureru\n\t\t\tpret = wt;\n\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var r = int.Parse(line[1]);\n        var L = int.Parse(line[2]);\n        var po = new int[n];\n        var poL = new int[n];\n        var topteam = -1;  var topfromtime = 0;\n        for (int i = 0; i < r; i++)\n        {\n            string[] line2 = Console.ReadLine().Trim().Split(' ');\n            var d = int.Parse(line2[0])-1;\n            var t = int.Parse(line2[1]);\n            var x = int.Parse(line2[2]);\n            po[d] += x;\n            var tt= GetTopTeam(po);\n            if (tt != -1 )\n            {\n                if (topteam != -1) poL[topteam] += t - topfromtime;\n                topteam = tt;\n                topfromtime = t;\n            }\n        }\n        poL[topteam] += L - topfromtime;\n        Console.WriteLine(GetTopTeam(poL) + 1);\n    }\n    public static int GetTopTeam (int[] po)\n    {\n        var pm = po.Max();\n        if (pm <= 0) return -1;\n        for (int i = 0; i < po.Length; i++)\n            if (po[i] == pm) return i;\n        return 0;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace AOJ.Volume2\n{\n    public class ProgrammingContest\n    {\n        public static int Main()\n        {\n            var input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);    // ???????????°\n            int r = int.Parse(input[1]);    // ?????°?????°\n            int l = int.Parse(input[2]);    // ?????????????????????\n\n            var point = new int[n + 1]; // ??????(???????????????????????¢???????????§n+1?????????)\n            var time = new int[n + 1];  // ?????£?????????\n\n            // ???????????¨??????????????????0???????????§1?????????????????????\n            int bef_time = 0;\n            int current_team = 1;\n            for (int cnt = 0; cnt < r; cnt++)\n            {\n                input = Console.ReadLine().Split(' ');\n                // ???????????????\n                int t = int.Parse(input[0]);\n                int now_time = int.Parse(input[1]);\n                int p = int.Parse(input[2]);\n                point[t] += p;\n\n                // ???????????????????????????????????¢???\n                // ?????¬??????????????????????????¨???????????????????????????\n                // ???????????±????????¨????????????????????????????????????????????´????????????\n                int tmp_team = current_team;\n                if(t == current_team && p < 0)\n                {\n                    int tmp_point = int.MinValue;\n                    for (int i = 1; i <= n; i++)\n                    {\n                        if (point[i] > tmp_point)\n                        {\n                            tmp_point = point[i];\n                            tmp_team = i;\n                        }\n                    }\n                }\n                else if (point[t] > point[current_team]) { tmp_team = t; }\n                else if(point[t] == point[current_team] && t < current_team) { tmp_team = t; }\n\n                if(current_team != tmp_team)\n                {\n                    // ??????????????????????????????????????§?????????????¨?\n                    time[current_team] += now_time - bef_time;\n                    bef_time = now_time;\n                    current_team = tmp_team;\n                }\n            }\n            // ?????????????????????????????????\n            time[current_team] += l - bef_time;\n\n            int ans = 0;\n            int tmp_time = 0;\n            for(int i = 1; i <= n; i++)\n            {\n                if (time[i] > tmp_time)\n                {\n                    ans = i;\n                    tmp_time = time[i];\n                }\n            }\n            Console.WriteLine(ans);\n\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int tt { get; set; }\n\tpublic int ns { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.ns > x.ns | (this.ns == x.ns && this.id < x.id)) return 1;\n\t\telse if (this.ns < x.ns | (this.ns == x.ns && this.id > x.id))   return -1;\n\t\telse   return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tgetAns(n, r, L);\n\t}\n\tstatic void getAns ( int n, int r , int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(100000,1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, tt = 0, ns = ds });\n\t\tfor (int i = 0; i < r-1; i++)\n\t\t{\n\t\t\tvar a = pq.Peek();\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.ns == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t id = int.Parse(line[0]) - 1;\n\t\t\t wt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[a.id] += wt - pret;\n\t\t\tpret = wt;\n\t\t\tif (a.id != id)\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, tt = t[id], ns = s[id] });\n\t\t\t}\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.ns == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace AOJ.Volume2\n{\n    public class ProgrammingContest\n    {\n        public static int Main()\n        {\n            var input = Console.ReadLine().Split(' ');\n            int n = int.Parse(input[0]);    // ???????????°\n            int r = int.Parse(input[1]);    // ?????°?????°\n            int l = int.Parse(input[2]);    // ?????????????????????\n\n            var point = new int[n + 1]; // ??????(???????????????????????¢???????????§n+1?????????)\n            var time = new int[n + 1];  // ?????£?????????\n\n            // ???????????¨??????????????????0???????????§1?????????????????????\n            int bef_time = 0;\n            int current_team = 1;\n            for (int cnt = 0; cnt < r; cnt++)\n            {\n                input = Console.ReadLine().Split(' ');\n                // ???????????????\n                int t = int.Parse(input[0]);\n                int now_time = int.Parse(input[1]);\n                int p = int.Parse(input[2]);\n                point[t] += p;\n\n                // ???????????????????????????????????¢???\n                int tmp_point = int.MinValue;\n                int tmp_team = 0;\n                for (int i = 1; i <= n; i++)\n                {\n                    if (point[i] > tmp_point)\n                    {\n                        tmp_point = point[i];\n                        tmp_team = i;\n                    }\n                }\n\n                if(current_team != tmp_team)\n                {\n                    // ??????????????????????????????????????§?????????????¨?\n                    time[current_team] += now_time - bef_time;\n                    bef_time = now_time;\n                    current_team = tmp_team;\n                }\n            }\n            // ?????????????????????????????????\n            time[current_team] += l - bef_time;\n\n            int ans = 0;\n            int tmp_time = 0;\n            for(int i = 1; i <= n; i++)\n            {\n                if (time[i] > tmp_time)\n                {\n                    ans = i;\n                    tmp_time = time[i];\n                }\n            }\n            Console.WriteLine(ans);\n\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0282\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] nrl = RArInt();\n            int[] Scores = new int[nrl[0]];\n            int[] airingSeconds = new int[nrl[0]];\n\n            Tuple<int, int> top = new Tuple<int, int>(0, 0);\n            int lastlogSeconds = 0;\n\n            for (int i = 0; i < nrl[1]; i++)\n            {\n                int[] vs = RArInt();\n                airingSeconds[top.Item1] += vs[1] - lastlogSeconds;\n                lastlogSeconds = vs[1];\n\n                Scores[vs[0] - 1] += vs[2];\n                if (Scores[vs[0] - 1] > top.Item2 || Scores[vs[0] - 1] == top.Item2 && vs[0] - 1 < top.Item1)\n                {\n                    top = new Tuple<int, int>(vs[0] - 1, Scores[vs[0] - 1]);\n                }\n                else if (vs[0] - 1 == top.Item1 && vs[2] < 0)\n                {\n                    top = Scores.Select((x, idx) => new Tuple<int, int>(idx, x)).OrderByDescending(y => y.Item2).ThenBy(y => y.Item1).FirstOrDefault();\n                }\n            }\n            airingSeconds[top.Item1] += nrl[2] - lastlogSeconds;\n            Console.WriteLine(airingSeconds.Select((x, i) => new Tuple<int, int>(i, x)).OrderByDescending(y => y.Item2).ThenBy(y => y.Item1).FirstOrDefault().Item1 + 1);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(r, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret;\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(r, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tvar tmax = 0;\n\t\tvar tmaxi = -1;\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret;\n\t\t\tif (t[pred] > tmax) { tmax = t[pred]; tmaxi = pred; }\n\t\t\telse if (t[pred] == tmax && pred < tmaxi) tmaxi = pred;\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tif (t[b.id] > tmax) { tmax = t[b.id]; tmaxi = b.id; }\n\t\telse if (t[b.id] == tmax && b.id < tmaxi) tmaxi = b.id;\n\n\t\tConsole.WriteLine(tmaxi + 1);\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(500000, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret;\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t\tarray[i++] = r;\n\t\treturn array;\n\t}\n}\n\npublic class P : IComparable\n{\n\tpublic int id { get; set; }\n\tpublic int score { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (P)obj;\n\t\tif (this.score > x.score | (this.score == x.score && this.id < x.id)) return 1;\n\t\telse if (this.score < x.score | (this.score == x.score && this.id > x.id)) return -1;\n\t\telse return 0;\n\t}\n}\n\npublic class hello\n{\n\tpublic static void Main()\n\t{\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar n = int.Parse(line[0]);\n\t\tvar r = int.Parse(line[1]);\n\t\tvar L = int.Parse(line[2]);\n\t\tif (r == 0) { Console.WriteLine(1); goto exit; }\n\t\tgetAns(n, r, L);\n\texit:;\n\t}\n\tstatic void getAns(int n, int r, int L)\n\t{\n\t\tvar pq = new PriorityQueue<P>(1000000, 1);\n\t\tvar s = new int[n];\n\t\tvar t = new int[n];\n\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\tvar id = int.Parse(line[0]) - 1;\n\t\tvar wt = int.Parse(line[1]);\n\t\tvar ds = int.Parse(line[2]);\n\t\tvar pret = wt;\n\t\tvar pred = id;\n\t\ts[id] += ds;\n\t\tpq.Push(new P { id = id, score = ds });\n\t\tfor (int i = 0; i < r - 1; i++)\n\t\t{\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tid = int.Parse(line[0]) - 1;\n\t\t\twt = int.Parse(line[1]);\n\t\t\tds = int.Parse(line[2]);\n\t\t\ts[id] += ds;\n\t\t\tt[pred] += wt - pret; // zureru\n\t\t\tvar a = pq.Peek();\n\t\t\tif (a.id == id)\n\t\t\t{\n\t\t\t\tpq.Pop();\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (a.score == s[a.id]) break;\n\t\t\t\telse pq.Pop();\n\t\t\t\ta = pq.Peek();\n\t\t\t}\n\t\t\tpred = a.id;\n\t\t\tpret = wt;\n\t\t\tpq.Push(new P { id = id, score = s[id] });\n\t\t\tif (a.id == id) pq.Pop();\n\t\t}\n\t\tvar b = pq.Peek();\n\t\twhile (true)\n\t\t{\n\t\t\tif (b.score == s[b.id]) break;\n\t\t\telse pq.Pop();\n\t\t\tb = pq.Peek();\n\t\t}\n\t\tt[b.id] += L - pret;\n\t\tvar tmax = t.Max();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (t[i] == tmax) { Console.WriteLine(i + 1); break; }\n\t}\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar nrl=arr.shift().split(\" \").map(Number);\nvar n=nrl[0];\nvar L=nrl[2];\nvar t=[];\nvar max=[0,0];\nvar time=0;\nfor(var i=0;i<n;i++)t[i]=[0,0,i];\narr.push([1,L,0].join(\" \"));\narr.forEach(function(v){\n   v=v.split(\" \").map(Number);\n   var d=v[0]-1;\n   var T=v[1];\n   var x=v[2];\n   t[max[0]][1]+=T-time;\n   time=T;\n   t[d][0]+=x;\n   if(x>0){\n      if(t[d][0]>max[1])max=[d,t[d][0]];\n      else if(t[d][0]==max[1] && d<=max[0])max=[d,t[d][0]];\n   }\n   else if(x<0 && max[0]==d){\n      var MAX=0;\n      var m=0;\n      t.forEach(function(V,index){\n         if(MAX<V[0]){m=index;MAX=V[0];}\n      });\n      max=[m,t[m][0]];\n   }\n});\nt.sort(function(a,b){\n   if(a[1]==b[1])return a[2]-b[2];\n   else return b[1]-a[1];\n});\nconsole.log(t[0][2]+1);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\n\nvar arr=input.trim().split(\"\\n\");\nvar nrl=arr.shift().split(\" \").map(Number);\nvar n=nrl[0];\nvar L=nrl[2];\nvar t=[];\nvar max=[0,0];\nvar time=0;\nfor(var i=0;i<n;i++)t[i]=[0,0,i];\narr.push([1,L,0].join(\" \"));\narr.forEach(function(v){\nv=v.split(\" \").map(Number);\nvar d=v[0]-1;\nvar T=v[1];\nvar x=v[2];\n\nt[max[0]][1]+=T-time;\ntime=T;\nt[d][0]+=x;\n\nif(x>0){\nif(t[d][0]>max[1])max=[d,t[d][0]];\nelse if(t[d][0]==max[1] && d<=max[0])max=[d,t[d][0]];\n}\n\nif(x<0){\nvar MAX=0;\nvar m=0;\nt.forEach(function(V,index){\nif(MAX<V[0])m=index;\n});\n\nmax=[m,t[m][0]];\n\n\n}\n\n\n});\n\n\n\nt.sort(function(a,b){\nif(a[1]==b[1])return a[2]-b[2];\nelse return b[1]-a[1];});\n\n\nconsole.log(t[0][2]+1);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar nrl=arr.shift().split(\" \").map(Number);\nvar n=nrl[0];\nvar L=nrl[2];\nvar t=[];\nvar max=[0,0];\nvar time=0;\nfor(var i=0;i<n;i++)t[i]=[0,0,i];\narr.push([1,L,0].join(\" \"));\narr.forEach(function(v){\n   v=v.split(\" \").map(Number);\n   var d=v[0]-1;\n   var T=v[1];\n   var x=v[2];\n   t[max[0]][1]+=T-time;\n   time=T;\n   t[d][0]+=x;\n   if(x>0){\n      if(t[d][0]>max[1])max=[d,t[d][0]];\n      else if(t[d][0]==max[1] && d<=max[0])max=[d,t[d][0]];\n   }\n   else if(x<0 && max[0]==d){\n      var MAX=0;\n      var m=0;\n      t.forEach(function(V,index){\n         if(MAX<V[0])m=index;\n      });\n      max=[m,t[m][0]];\n   }\n});\nt.sort(function(a,b){\n   if(a[1]==b[1])return a[2]-b[2];\n   else return b[1]-a[1];\n});\nconsole.log(t[0][2]+1);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\n\nvar arr=input.trim().split(\"\\n\");\nvar nrl=arr.shift().split(\" \").map(Number);\nvar n=nrl[0];\nvar L=nrl[2];\nvar t=[];\nvar max=[0,0];\nvar time=0;\nfor(var i=0;i<n;i++)t[i]=[0,0,i];\narr.push([1,L,0].join(\" \"));\narr.forEach(function(v){\nv=v.split(\" \").map(Number);\nvar d=v[0]-1;\nvar T=v[1];\nvar x=v[2];\n\nt[max[0]][1]+=T-time;\ntime=T;\nt[d][0]+=x;\n\nif(x>0){\nif(t[d][0]>max[1])max=[d,t[d][0]];\nelse if(t[d][0]==max[1] && d<=max[0])max=[d,t[d][0]];\n}\n\nif(x<0 && max[0]==d){\nvar MAX=0;\nvar m=0;\nt.forEach(function(V,index){\nif(MAX<V[0])m=index;\n});\n\nmax=[m,t[m][0]];\n\n\n}\n\n\n});\n\n\n\nt.sort(function(a,b){\nif(a[1]==b[1])return a[2]-b[2];\nelse return b[1]-a[1];});\n\n\nconsole.log(t[0][2]+1);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar nrl=arr.shift().split(\" \").map(Number);\nvar n=nrl[0];\nvar L=nrl[2];\nvar t=[];\nvar max=[0,0];\nvar time=0;\nfor(var i=0;i<n;i++)t[i]=[0,0,i];\narr.push([1,L,0].join(\" \"));\nfor(var i=0;i<arr.length;i++){\n   var v=arr[i].split(\" \").map(Number);\n   var d=v[0]-1;\n   var T=v[1];\n   var x=v[2];\n   t[max[0]][1]+=T-time;\n   time=T;\n   t[d][0]+=x;\n   if(x>0){\n      if(t[d][0]>max[1])max=[d,t[d][0]];\n      else if(t[d][0]==max[1] && d<=max[0])max=[d,t[d][0]];\n   }\n   else if(x<0 && max[0]==d){\n      var MAX=0;\n      var m=0;\n      for(var j=0;j<t.length;j++){\n         if(MAX<t[j][0]){m=j;MAX=t[j][0];}\n      }\n      max=[m,t[m][0]];\n   }\n}\nt.sort(function(a,b){\n   if(a[1]==b[1])return a[2]-b[2];\n   else return b[1]-a[1];\n});\nconsole.log(t[0][2]+1);"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nvar nrl=arr.shift().split(\" \").map(Number);\nvar n=nrl[0];\nvar L=nrl[2];\nvar t=[];\nvar max=[0,0];\nvar time=0;\nfor(var i=0;i<n;i++)t[i]=[0,0,i];\narr.push([1,L,0].join(\" \"));\nfor(var i=0;i<arr.length;i++){\n   var v=arr[i].split(\" \").map(Number);\n   var d=v[0]-1;\n   var T=v[1];\n   var x=v[2];\n   t[max[0]][1]+=T-time;\n   time=T;\n   t[d][0]+=x;\n   if(x>0){\n      if(t[d][0]>max[1])max=[d,t[d][0]];\n      else if(t[d][0]==max[1] && d<=max[0])max=[d,t[d][0]];\n   }\n   else if(x<0 && max[0]==d){\n      var MAX=0;\n      var m=0;\n      for(var j=0;j<t.length;j++){\n         if(MAX<t[j][0]){m=j;MAX=t[j][0];}\n      }\n      max=[m,t[m][0]];\n   }\n}\nvar MAX=0;\nvar m=0;\nfor(var i=0;i<t.length;i++){\n   if(MAX<t[i][1]){m=i;MAX=t[i][1];}\n}\nconsole.log(m+1);"
  },
  {
    "language": "Ruby",
    "code": "require 'forwardable'\n\nclass Array\n    include Comparable\n    def <=>(other)\n        c = (self[0] <=> other[0])\n        c == 0 ? (self[1] <=> other[1]) : c\n    end\nend\n\nclass Heap\n    extend Forwardable\n\n    def initialize\n        @array = []\n        @index = {}\n    end\n\n    def add(obj, key)\n        @array << [obj, key]\n        @index[obj] = @array.size - 1\n        lift_up(@array.size - 1)\n    end\n\n    def swap(i, j)\n        u = @array[i]\n        v = @array[j]\n        @index[u[0]], @index[v[0]] = j, i\n        @array[i], @array[j] = v, u\n    end\n\n    def lift_up(i)\n        return if i == 0\n        j = (i - 1) / 2\n        if @array[i][1] < @array[j][1]\n            swap(i, j)\n            lift_up(j)\n        end\n    end\n\n    def del_min\n        raise \"heap is empty!\" if empty?\n        min = @array[0]\n        if size > 1\n            swap(0, @array.size-1)\n            @array.pop\n            lift_down(0)\n        else\n            @array.pop\n        end\n        @index.delete(min[0])\n        min\n    end\n\n    def inc_key(obj, diff)\n        i = @index[obj]\n        @array[i][1] += diff\n        lift_down(i)\n    end\n\n    def dec_key(obj, diff)\n        i = @index[obj]\n        @array[i][1] -= diff\n        lift_up(i)\n    end\n\n    def update_key(obj, new_key)\n        i = @index[obj]\n        return unless i\n        old_key = @array[i][1]\n        @array[i][1] = new_key\n        if new_key > old_key\n            @array[i][1] = new_key\n            lift_down(i)\n        else\n            @array[i][1] = new_key\n            lift_up(i)\n        end\n    end\n\n    def min_obj\n        @array[0][0]\n    end\n\n    def min_key\n        @array[0][1]\n    end\n\n    def lift_down(i)\n        j = 2 * i + 1\n        k = j + 1\n        if k >= size\n            return if j >= size\n            if @array[i][1] > @array[j][1]\n                swap(i, j)\n                lift_down(j)\n            end\n        else\n            l = (@array[j][1] < @array[k][1] ? j : k)\n            if @array[i][1] > @array[l][1]\n                swap(i, l)\n                lift_down(l)\n            end\n        end\n    end\n\n    def key(obj)\n        i = @index[obj]\n        @array[i][1]\n    end\n\n    def_delegators :@array, :empty?, :size\nend\n\nn, r, l = gets.split.map(&:to_i)\nheap = Heap.new\ntotal_time = {}\n(1..n).each do |i|\n    heap.add(i, [0, i])\n    total_time[i] = 0\nend\n\nevents = (1..r).map { gets.split.map(&:to_i) }\n\nt0 = 0\nuntil events.empty?\n    _, t, _ = events[0]\n    top = heap.min_obj\n    total_time[top] += t - t0\n\n    while !events.empty? and events[0][1] == t\n        d, t, x = events.shift\n        score, i = heap.key(d)\n        heap.update_key(d, [score - x, d])\n    end\n    t0 = t\nend\ntop = heap.min_obj\ntotal_time[top] += l - t0\np total_time.max_by {|i, t| t}[0]\n\n"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nn, rn, ln = gets.strip.split(' ').map{|s| s.to_i}\n\nscores = n.times.map{0}\nshots = n.times.map{0}\n\nprev_d = 0\nprev_t = 0\n\nrn.times do\n  d, t, x = gets.strip.split(' ').map{|s| s.to_i}\n  d -= 1\n\n  shots[prev_d] += t - prev_t\n  scores[d] += x\n\n  prev_d = (0...n).max do |a, b|\n    (cmp = scores[a] <=> scores[b]) != 0 ? cmp : (b <=> a)\n  end\n  prev_t = t\nend\n\nshots[prev_d] += ln - prev_t\n\nmax_d = (0...n).max do |a, b|\n  (cmp = shots[a] <=> shots[b]) != 0 ? cmp : (b <=> a)\nend\n\nputs (max_d + 1)"
  },
  {
    "language": "Ruby",
    "code": "gets\na=gets.split.map(&:to_i)\nraise if a!=a.sort_by{|e|e[1]}"
  },
  {
    "language": "Ruby",
    "code": "N, R, L = gets.split.map(&:to_i)\ntime = Array.new(N, 0)\nscore = Array.new(N, 0)\nlastTime = 0\ntopScore = 0\ntopTeam = 0\nR.times do\n  d, t, x = gets.split.map(&:to_i)\n  d -= 1\n  time[topTeam] += t - lastTime\n  score[d] += x\n  case d\n    when topTeam\n      if x >= 0\n        topScore = score[d]\n      else\n        topScore = score.max\n        topTeam = score.index(topScore)\n      end\n    else\n      if x >= 0\n        if score[d] == topScore\n          topTeam = [d, topTeam].min\n        elsif score[d] > topScore\n          topScore = score[d]\n          topTeam = d\n        end\n      else\n      end\n  end\n  lastTime = t\nend\ntime[topTeam] += L - lastTime\np time.index(time.max) + 1"
  },
  {
    "language": "Ruby",
    "code": "gets\na=$<.map{|e|e.split.map(&:to_i)}\nraise if a!=a.sort_by{|e|e[1]}"
  },
  {
    "language": "Ruby",
    "code": "N, R, L = gets.split.map(&:to_i)\ntime = Array.new(N, 0)\nscore = Array.new(N, 0)\nlastTime = 0\nR.times do\n  d, t, x = gets.split.map(&:to_i)\n  time[score.index(score.max)] += t - lastTime\n  lastTime = t\n  score[d-1] += x\nend\ntime[score.index(score.max)] += L - lastTime\np time.index(time.max) + 1"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nn, rn, ln = gets.strip.split(' ').map{|s| s.to_i}\n\nscores = n.times.map{0}\nshots = n.times.map{0}\n\nprev_d = 0\nprev_t = 0\n\nrn.times do\n  d, t, x = gets.strip.split(' ').map{|s| s.to_i}\n  d -= 1\n\n  shots[prev_d] += t - prev_t\n  scores[d] += x\n\n  if x > 0\n    if scores[prev_d] < scores[d]\n      prev_d = d\n    end\n  elsif x < 0 && d == prev_d\n    prev_d = (0...n).max do |a, b|\n      (cmp = scores[a] <=> scores[b]) != 0 ? cmp : (b <=> a)\n    end\n  end\n\n  prev_t = t\nend\n\nshots[prev_d] += ln - prev_t\n\nmax_d = (0...n).max do |a, b|\n  (cmp = shots[a] <=> shots[b]) != 0 ? cmp : (b <=> a)\nend\n\nputs (max_d + 1)"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nn, rn, ln = gets.strip.split(' ').map{|s| s.to_i}\n\nscores = n.times.map{0}\nshots = n.times.map{0}\n\nprev_d = 0\nprev_t = 0\n\nrn.times do\n  d, t, x = gets.strip.split(' ').map{|s| s.to_i}\n  d -= 1\n\n  shots[prev_d] += t - prev_t\n  scores[d] += x\n\n  if x > 0\n    if scores[prev_d] < scores[d]\n      prev_d = d\n    elsif scores[prev_d] == scores[d]\n      prev_d = [prev_d, d].min\n    end\n  elsif x < 0 && d == prev_d\n    prev_d = (0...n).max do |a, b|\n      (cmp = scores[a] <=> scores[b]) != 0 ? cmp : (b <=> a)\n    end\n  end\n\n  prev_t = t\nend\n\nshots[prev_d] += ln - prev_t\n\nmax_d = (0...n).max do |a, b|\n  (cmp = shots[a] <=> shots[b]) != 0 ? cmp : (b <=> a)\nend\n\nputs (max_d + 1)"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    auto rbt = redBlackTree!(\"a.score==b.score ? a.id<b.id : a.score>b.score\")(nodes[0]);\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        Node node = rbt.front;\n        rbt.removeFront;\n        node.time += t-preT;\n        rbt.insert(node);\n        rbt.removeKey(nodes[d]);\n        nodes[d].score += x;\n        rbt.insert(nodes[d]);\n        preT = t;\n    }\n    rbt.front.time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n    override string toString() const {\n        return to!string(score, id);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] >= 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    int temp = maxp;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    if(maxp == temp) break;\n\t\t    now = j;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = Node(i);\n    }\n    auto rbt = redBlackTree!(\"a.score==b.score ? a.id<b.id : a.score>b.score\")(nodes[0]);\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        int j = rbt.front.id;\n        rbt.removeFront;\n        nodes[j].time += t-preT;\n        rbt.insert(nodes[j]);\n        rbt.removeKey(nodes[d]);\n        nodes[d].score += x;\n        rbt.insert(nodes[d]);\n        preT = t;\n    }\n    nodes[rbt.front.id].time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nstruct Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    Node node = nodes[0];\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        node.time += t-preT;\n        nodes[d].score += x;\n        if (x > 0) {\n            if ((nodes[d].score > node.score) || (nodes[d].score == node.score && nodes[d].id > nodes[d].id)) {\n                node = nodes[d];\n            }\n        } else if (d == node.id) {\n            foreach(int j; 0..N) {\n                if (nodes[j].score > node.score || (nodes[j].score == node.score && nodes[j].id < node.id)) {\n                    node = nodes[j];\n                }\n            }\n        }\n        preT = t;\n    }\n    node.time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    Node node = nodes[0];\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        node.time += t-preT;\n        nodes[d].score += x;\n        if (x > 0) {\n            if ((nodes[d].score > node.score) || (nodes[d].score > node.score && nodes[d].id > nodes[d].id)) {\n                node = nodes[d];\n            }\n        } else if (d == node.id) {\n            foreach(int j; 0..N) {\n                if (nodes[j].score > node.score || (nodes[j].score == node.score && nodes[j].id < node.id)) {\n                    node = nodes[j];\n                }\n            }\n        }\n        preT = t;\n    }\n    node.time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct T {\n    int id, score;\n    int opCmp(const ref T o) const {\n        if (score == o.score) return o.id - id;\n        else return score - o.score;\n    }\n}\n\nclass SegTree {\n    int size;\n    int size2;\n    T[] v;\n    this(int size) {\n        this.size = size;\n        size2 = 1;\n        while (size2 < size) {\n            size2 *= 2;\n        }\n        v = new T[size2 * 2 + 1];\n        foreach (ref e; v) {\n            e.id = int.max;\n            e.score = 0;\n        }\n        foreach (int i; 0 .. size) {\n            int j = i + size2;\n            v[j].id = i;\n        }\n    }\n    void add(int i, int x) {\n        int j = i + size2;\n        v[j].score += x;\n        j /= 2;\n        while (j >= 1) {\n            v[j] = max(v[j * 2], v[j * 2 + 1]);\n            j /= 2;\n        }\n    }\n    T maxElement() {\n        return v[1];\n    }\n}\n\nvoid main() {\n    int N, R, L; readf(\"%d %d %d\\n\", &N, &R, &L);\n    SegTree segtree = new SegTree(N);\n    int u = 0;\n    int m = 0;\n    int[] tot = new int[N];\n    foreach (_; 0 .. R) {\n        int d, t, x; readf(\"%d %d %d\\n\", &d, &t, &x);\n        d--;\n        tot[m] += t - u;\n        segtree.add(d, x);\n        m = segtree.maxElement.id;\n        //writeln([t, m + 1]);\n        u = t;\n    }\n    tot[m] += L - u;\n    int ans = 1;\n    int ansT = 0;\n    foreach (int i, t; tot) {\n        if (t > ansT) {\n            ansT = t;\n            ans = i + 1;\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] >= 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    now = j;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] >= 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    now = j;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct T {\n    int id, score;\n    const int opCmp(const ref T o) const {\n        if (score == o.score) return o.id - id;\n        else return score - o.score;\n    }\n}\n\nclass SegTree {\n    int size;\n    int size2;\n    T[] v;\n    this(int size) {\n        this.size = size;\n        size2 = 1;\n        while (size2 < size) {\n            size2 *= 2;\n        }\n        v = new T[size2 * 2 + 1];\n        foreach (i; 1 .. size2) {\n            v[i].id = int.max;\n        }\n        foreach (int i; 0 .. size) {\n            int j = i + size2;\n            v[j].id = i;\n        }\n    }\n    final void add(int i, int x) {\n        int j = i + size2;\n        v[j].score += x;\n        j /= 2;\n        while (j >= 1) {\n            v[j] = max(v[j * 2], v[j * 2 + 1]);\n            j /= 2;\n        }\n    }\n    final T maxElement() {\n        return v[1];\n    }\n}\n\nvoid main() {\n    int N, R, L; scanf(\"%d %d %d\\n\", &N, &R, &L);\n    SegTree segtree = new SegTree(N);\n    int u = 0;\n    int m = 0;\n    int[] tot = new int[N];\n    foreach (_; 0 .. R) {\n        int d, t, x; scanf(\"%d %d %d\\n\", &d, &t, &x);\n        d--;\n        tot[m] += t - u;\n        segtree.add(d, x);\n        m = segtree.maxElement.id;\n        //writeln([t, m + 1]);\n        u = t;\n    }\n    tot[m] += L - u;\n    int ans = 1;\n    int ansT = 0;\n    foreach (int i, t; tot) {\n        if (t > ansT) {\n            ansT = t;\n            ans = i + 1;\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.conv;\nimport std.array;\nimport std.typecons;\nimport std.container;\nimport core.memory;\n\nvoid main() {\n\tGC.disable();\n\tauto inp = readln.split.map!(to!int);\n\tint N = inp[0], R = inp[1], L = inp[2];\n\talias Tuple!(int, \"point\", int, \"time\") Team;\n\tTeam[] datas = new Team[N];\n\tforeach (i; 0..N) datas[i] = tuple(0, 0);\n\tint t = 0;\n\talias Tuple!(int, \"id\", int, \"point\") MaxInfo;\n\tMaxInfo maxInfo = tuple(0,0);\n\tforeach (i; 0..R) {\n\t\tauto input = readln.split.map!(to!int).array;\n\t\tinput[0]--;\n\t\tdatas[input[0]].point += input[2];\n\t\tauto t2 = input[1];\n\t\tdatas[maxInfo.id].time += t2 - t;\n\t\tif (datas[input[0]].point > maxInfo.point || (datas[input[0]].point == maxInfo.point && input[0] < maxInfo.id)) {\n\t\t\tmaxInfo = tuple(input[0], datas[input[0]].point);\n\t\t} else if (maxInfo.id == input[0]) {\n\t\t\tint max = 0, id = 0;\n\t\t\tforeach (j; 0..N) {\n\t\t\t\tif (datas[j].point > max) {\n\t\t\t\t\tmax = datas[j].point;\n\t\t\t\t\tid = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxInfo = tuple(id, max);\n\t\t}\n\t\tt = t2;\n\t}\n\tdatas[maxInfo.id].time += L - t;\n\tint max = 0;\n\tint maxId = 0;\n\tforeach(i; 0..N) {\n\t\tif (datas[i].time > max) {\n\t\t\tmax = datas[i].time;\n\t\t\tmaxId = i;\n\t\t}\n\t}\n\twriteln(maxId+1);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] > 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else if(now == d[i]){\n\t    now = 0;\n\t    int temp = maxp;\n\t    int tempnow = now;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    if(maxp == temp) break;\n\t\t    now = j;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] >= 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    now = j;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    Node node = nodes[0];\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        node.time += t-preT;\n        nodes[d].score += x;\n        if (x > 0) {\n            if ((nodes[d].score > node.score) || (nodes[d].score == node.score && nodes[d].id < node.id)) {\n                node = nodes[d];\n            }\n        } else if (d == node.id) {\n            foreach(int j; 0..N) {\n                if (nodes[j].score > node.score || (nodes[j].score == node.score && nodes[j].id < node.id)) {\n                    node = nodes[j];\n                }\n            }\n        }\n        preT = t;\n    }\n    node.time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] > 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    int temp = maxp;\n\t    int tempnow = now;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    if(maxp == temp) break;\n\t\t    now = j;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] >= 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    maxp = 0;\n\t    for(int j=0;j<n;j++){\n\t\tmaxp = max(maxp,p[j]);\n\t    }\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp == p[j]) now = j;\n\t    }\n\t}\n\t/*\n\twriteln(\"score\");\n\twriteln(p);\n\twriteln(\"time\");\n\twriteln(pt);\n\twritef(\"now = %d\\n\",now);\n\t*/\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] >= 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    int tepm = maxp;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    if(maxp == temp) break;\n\t\t    now = j;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.conv;\nimport std.array;\nimport std.typecons;\nimport std.container;\n\n\nclass Team {\n\tint point;\n\tint time;\n\tint id;\n}\n\nvoid main() {\n\tauto inp = readln.split.map!(to!int);\n\tint N = inp[0], R = inp[1], L = inp[2];\n\tTeam[] datas = new Team[N];\n\tforeach (i; 0..N) {\n\t\tdatas[i] = new Team;\n\t\tdatas[i].id = i;\n\t}\n\tTeam[] rank = new Team[N];\n\tforeach (i; 0..N) {\n\t\trank[i] = datas[i];\n\t}\n\tint t = 0;\n\tforeach (i; 0..R) {\n\t\tauto input = readln.split.map!(to!int).array;\n\t\tinput[0]--;\n\t\tauto target = datas[input[0]];\n\t\ttarget.point += input[2];\n\t\tauto t2 = input[1];\n\t\tif (i > 0) datas[rank[0].id].time += t2 - t;\n\t\tsort!((a, b)=> a.point > b.point || (a.point == b.point && a.id < b.id))(rank);\n\t\tt = t2;\n\t}\n\tdatas[rank[0].id].time += L - t;\n\tint max = 0;\n\tint maxId = 0;\n\tforeach(i; 0..N) {\n\t\tif (datas[i].time > max) {\n\t\t\tmax = datas[i].time;\n\t\t\tmaxId = i;\n\t\t}\n\t}\n\twriteln(maxId+1);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    Node node = nodes[0];\n    auto queue = heapify!(\"a.score==b.score ? a.id<b.id : a.score>b.score\")(node.Array!Node);\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        queue.front.time += t-preT;\n        nodes[d].score += x;\n        queue.insert(nodes[d]);\n        preT = t;\n    }\n    queue.front.time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\n\nvoid main(){\n\n    int[] s = readln().split().to!(int[]);\n    int n,r,l;\n    n = s[0];\n    r = s[1];\n    l = s[2];\n    int[] d,t,x;\n    int[] p,pt;\n    int maxp,maxt,now;\n    for(int i=0;i<n;i++) {\n\tp ~= 0;\n\tpt ~= 0;\n    }\n    for(int i=0;i<r;i++){\n\ts = readln().split().to!(int[]);\n\td ~= s[0]-1;\n\tt ~= s[1];\n\tx ~= s[2];\n    }\n    d ~= 0;\n    t ~= l;\n    x ~= 0;\n    int pre = 0;\n    for(int i=0;i<=r;i++){\n\tpt[now] += t[i]-pre;\n\tmaxt = max(maxt,pt[now]);\n\tpre = t[i];\n\tp[d[i]] += x[i];\n\tif(x[i] >= 0){\n\t    if(p[d[i]] == maxp && d[i] < now){\n\t\tnow = d[i];\n\t    }else if(p[d[i]] > maxp){\n\t\tnow = d[i];\n\t\tmaxp = p[d[i]];\n\t    }\n\t}else{\n\t    now = 0;\n\t    maxp = -10000000;\n\t    for(int j=0;j<n;j++){\n\t\tif(maxp < p[j]){\n\t\t    maxp = p[j];\n\t\t    now = j;\n\t\t}\n\t    }\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tif(pt[i] == maxt){\n\t    writeln(i+1);\n\t    break;\n\t}\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct T {\n    int id, score;\n    int opCmp(const ref T o) const {\n        if (score == o.score) return o.id - id;\n        else return score - o.score;\n    }\n}\n\nclass SegTree {\n    int size;\n    int size2;\n    T[] v;\n    this(int size) {\n        this.size = size;\n        size2 = 1;\n        while (size2 < size) {\n            size2 *= 2;\n        }\n        v = new T[size2 * 2 + 1];\n        foreach (ref e; v) {\n            e.id = int.max;\n            e.score = 0;\n        }\n        foreach (int i; 0 .. size) {\n            int j = i + size2;\n            v[j].id = i;\n        }\n    }\n    void add(int i, int x) {\n        int j = i + size2;\n        v[j].score += x;\n        j /= 2;\n        while (j >= 1) {\n            v[j] = max(v[j * 2], v[j * 2 + 1]);\n            j /= 2;\n        }\n    }\n    T maxElement() {\n        return v[1];\n    }\n}\n\nvoid main() {\n    int N, R, L; readf(\"%d %d %d\\n\", &N, &R, &L);\n    SegTree segtree = new SegTree(N);\n    int u = 0;\n    int m = 1;\n    int[] tot = new int[N];\n    foreach (_; 0 .. R) {\n        int d, t, x; readf(\"%d %d %d\\n\", &d, &t, &x);\n        d--;\n        tot[m] += t - u;\n        segtree.add(d, x);\n        m = segtree.maxElement.id;\n        u = t;\n    }\n    tot[m] += L - u;\n    int ans = 1;\n    int ansT = 0;\n    foreach (int i, t; tot) {\n        if (t > ansT) {\n            ansT = t;\n            ans = i + 1;\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    int preT = 0;\n    int maxid = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        nodes[maxid].time += t-preT;\n        nodes[d].score += x;\n        multiSort!(\"a.score>b.score\", \"a.id<b.id\")(nodes);\n        maxid = nodes.front.id;\n        sort!(\"a.id<b.id\")(nodes);\n        preT = t;\n    }\n    nodes[maxid].time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.conv;\nimport std.array;\nimport std.typecons;\nimport std.container;\n\nvoid main() {\n\tauto inp = readln.split.map!(to!int);\n\tint N = inp[0], R = inp[1], L = inp[2];\n\talias Tuple!(int, \"point\", int, \"time\") Team;\n\tTeam[] datas = new Team[N];\n\tforeach (i; 0..N) datas[i] = tuple(0, 0);\n\tint t = 0;\n\talias Tuple!(int, \"id\", int, \"point\") MaxInfo;\n\tMaxInfo maxInfo = tuple(0,0);\n\tforeach (i; 0..R) {\n\t\tauto input = readln.split.map!(to!int).array;\n\t\tinput[0]--;\n\t\tdatas[input[0]].point += input[2];\n\t\tauto t2 = input[1];\n\t\tdatas[maxInfo.id].time += t2 - t;\n\t\tif (datas[input[0]].point > maxInfo.point || (datas[input[0]].point == maxInfo.point && input[0] < maxInfo.id)) {\n\t\t\tmaxInfo = tuple(input[0], datas[input[0]].point);\n\t\t} else if (maxInfo.id == input[0]) {\n\t\t\tint max = 0, id = 0;\n\t\t\tforeach (j; 0..N) {\n\t\t\t\tif (datas[j].point > max) {\n\t\t\t\t\tmax = datas[j].point;\n\t\t\t\t\tid = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxInfo = tuple(id, max);\n\t\t}\n\t\tt = t2;\n\t}\n\tdatas[maxInfo.id].time += L - t;\n\tint max = 0;\n\tint maxId = 0;\n\tforeach(i; 0..N) {\n\t\tif (datas[i].time > max) {\n\t\t\tmax = datas[i].time;\n\t\t\tmaxId = i;\n\t\t}\n\t}\n\twriteln(maxId+1);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    auto rbt = redBlackTree!(\"a.score==b.score ? a.id<b.id : a.score>b.score\")(nodes);\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        Node node = rbt.front;\n        rbt.removeFront;\n        node.time += t-preT;\n        rbt.insert(node);\n        rbt.removeKey(nodes[d]);\n        nodes[d].score += x;\n        rbt.insert(nodes[d]);\n        preT = t;\n    }\n    rbt.front.time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n    override string toString() const {\n        return to!string(score, id);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int[] input = readln.split.to!(int[]);\n    int N = input[0];\n    int R = input[1];\n    int L = input[2];\n    Node[] nodes = new Node[N];\n    foreach(int i; 0..N) {\n        nodes[i] = new Node(i);\n    }\n    auto rbt = redBlackTree!(\"a.score==b.score ? a.id<b.id : a.score>b.score\")(nodes[0]);\n    int preT = 0;\n    foreach(int i; 0..R) {\n        input = readln.split.to!(int[]);\n        int d = input[0]-1;\n        int t = input[1];\n        int x = input[2];\n\n        int j = rbt.front.id;\n        rbt.removeFront;\n        nodes[j].time += t-preT;\n        rbt.insert(nodes[j]);\n        rbt.removeKey(nodes[d]);\n        nodes[d].score += x;\n        rbt.insert(nodes[d]);\n        preT = t;\n    }\n    rbt.front.time += L-preT;\n    multiSort!(\"a.time>b.time\", \"a.id<b.id\")(nodes);\n    writeln(nodes.front.id+1);\n}\nclass Node{\n    int id, time, score;\n    this(int id) {\n        this.id = id;\n        time = 0;\n        score = 0;\n    }\n    override string toString() const {\n        return to!string(score, id);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappush, heappop\n\ndef solve():\n    file_input = sys.stdin\n    N, R, L = map(int, file_input.readline().split())\n    \n    hq = []\n    m = {}\n    for i in range(1, N + 1):\n        team = [0, i, 0]\n        heappush(hq, team)\n        m[i] = team\n    \n    time = 0\n    for line in file_input:\n        d, t, x = map(int, line.split())\n        hq[0][2] += t - time\n        time = t\n        \n        scored_team = m[d][:]\n        scored_team[0] -= x\n        heappush(hq, scored_team)\n        m[d][2] = -1\n        m[d] = scored_team\n        \n        while hq[0][2] == -1:\n            heappop(hq)\n    hq[0][2] += L - time\n    ans_team = max(hq, key = lambda x: (x[2], -x[1]))\n    print(ans_team[1])\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "N, R, L = list(map(int, input().split(\" \")))\n\ni = 1\nwhile i<N*2:\n\ti<<=1\n\ntree = [0 for j in range(i)]\n\ntime = [0 for j in range(N)]\n\ntree[0] = -1\n\ndef foo(a,x):\n\tdef bar(k,a,x,l,r):\n\t\tmid = (l+r)//2\n\t\tif r-l == 1:\n\t\t\ttree[k] += x\n\t\t\ttree[0] = l\n\t\t\treturn(tree[k])\n\t\telif a<mid:\n\t\t\ttree[k] = max(bar(k*2,a,x,l,mid), tree[k])\n\t\t\treturn(tree[k])\n\t\telse:\n\t\t\ttree[k] = max(bar(k*2+1,a,x,mid,r), tree[k])\n\t\t\treturn(tree[k])\n\n\tbar(1,a,x,0,i//2)\n\treturn(tree[1],tree[0])\n\nnowtime = 0\nnowmax = 0\nnowpoint = 0\n\nfor j in range(R):\n\td,t,x = map(int, input().split(\" \"))\n\td -= 1\n\ttime[nowmax] += t-nowtime\n\tnowtime = t\n\tnewpoint, newmax = foo(d,x)\n\tif nowpoint < newpoint:\n\t\tnowmax = newmax\n\t\tnowpoint = newpoint\n\telif nowpoint == newpoint:\n\t\tnowmax = min(nowmax, newmax)\n\ntime[nowmax] += L-nowtime\n\n\nprint(time.index(max(time))+1)"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, input().split())\np, s = [0] * n, [0] * n\ntn = 0\nmt = 0\nfor _ in range(r):\n    d, t, x = map(int, input().split())\n    s[mt] += t - tn\n    tn = t\n    p[d - 1] += x\n    if p[d - 1] >= p[mt]:\n        mt = min(d - 1, mt)\ns[mt] += l - tn\nprint(s.index(max(s)) + 1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappush, heappop, heapreplace\n\ndef solve():\n    file_input = sys.stdin\n    N, R, L = map(int, file_input.readline().split())\n    \n    pq = [[0, i, 0] for i in range(1, N + 1)]\n    m = dict(zip(range(1, N + 1), pq))\n    \n    pre_t = 0\n    for line in file_input:\n        d, t, x = map(int, line.split())\n        team = pq[0]\n        team[2] += t - pre_t\n        pre_t = t\n        \n        if team[1] == d:\n            team[0] -= x\n            if x < 0:\n                heapreplace(pq, team)\n        else:\n            scored_team = m[d][:]\n            scored_team[0] -= x\n            heappush(pq, scored_team)\n            m[d][2] = -1\n            m[d] = scored_team\n        \n        while pq[0][2] == -1:\n            heappop(pq)\n    pq[0][2] += L - pre_t\n    ans_team = max(pq, key = lambda x: (x[2], -x[1]))\n    print(ans_team[1])\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nf = sys.stdin\n\nn, r, l = map(int, f.readline().split())\n\nappearance = [0] * n\npoint = [0] * n\n\ntop = 0\npre_t = 0\nfor line in f:\n    d, t, x = map(int, line.split())\n    d -= 1 # 0-index?????????\n    \n    appearance[top] += t - pre_t\n    pre_t = t\n    \n    point[d] += x\n    if 0 < x and top != d:\n        if point[top] < point[d]:\n            top = d\n        elif point[top] == point[d] and d < top:\n            top = d\n    elif x < 0 and top == d:\n        top = point.index(max(point))\n\nappearance[top] += l - pre_t\n\nprint(1 + appearance.index(max(appearance)))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass SegmentTree:\n\n    def __init__(self, N):\n        self.N = N\n        inner = 1\n        while inner < N:\n            inner *= 2\n        self.inner = inner - 1\n        self.nodes = [(0, 0)] * (inner * 2) # (score, team)\n\n    def update(self, d, x):\n        index = self.leaf(d)\n        self.nodes[index] = (self.nodes[index][0] + x, d)\n        while index > 0:\n            p = (index - 1) // 2\n            l = p * 2 + 1\n            r = p * 2 + 2\n            if self.nodes[l][0] >= self.nodes[r][0]:\n                self.nodes[p] = self.nodes[l]\n            elif self.nodes[r][0] > self.nodes[l][0]:\n                self.nodes[p] = self.nodes[r]\n            index = p\n\n    def leaf(self, d):\n        return self.inner + d\n\n\nN, R, L = [int(s) for s in input().split()]\nst = SegmentTree(N)\nviews = [0] * N\nscores = [0] * N\nT = 0\n\nfor s in sys.stdin:\n    d, t, x = [int(s) for s in s.split()]\n    views[st.nodes[0][1]] += t - T\n    st.update(d - 1, x)\n    T = t\n\nviews[st.nodes[0][1]] += L - T\nteam, _ = max(enumerate(views), key=lambda x: x[1])\nprint(team + 1)"
  },
  {
    "language": "Python",
    "code": "def findMaxId(id_x):\n\tmax_x=0\n\tmax_id=0\n\tfor i in range(n):\n\t\tif id_x[i]>max_x:\n\t\t\tmax_x=id_x[i]\n\t\t\tmax_id=i\n\treturn i\n\t\nn,r,l=map(int,raw_input().split())\nlog=[map(int,raw_input().split()) for i in range(r)]\nlog.insert(0,[1,0,0])\nlog.append([1,l,0])\nid_t=[0]*n\nid_x=[0]*n\nmax_id=0\nfor i in range(1,r+2):\n\tcur_id=log[i][0]-1\n\tid_t[max_id]+=log[i][1]-log[i-1][1]\n\tid_x[cur_id]+=log[i][2]\n\tif cur_id==max_id and log[i][2]<0:\n\t\tmax_id=findMaxId(id_x)\n\telif id_x[max_id]<id_x[cur_id] or (id_x[max_id]==id_x[cur_id] and max_id>cur_id):\n\t\tmax_id=cur_id\nprint id_t.index(max(id_t))+1"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\ndef main():\n  n, r, l = map(int, input().split())\n  leaf_num = 1\n  while leaf_num < n:\n    leaf_num *= 2\n  INF = 10 ** 20\n  tree = [None] * (leaf_num * 2 - 1)\n  save = [0] * n\n  \n  for i in range(n):\n    tree[leaf_num - 1 + i] = i\n  \n  def set_value(index):\n    if leaf_num - 1 <= index <= leaf_num * 2 - 2:\n      return tree[index]\n    t1 = set_value(index * 2 + 1)\n    t2 = set_value(index * 2 + 2)\n    tree[index] = t1\n    return tree[index]\n  \n  def update(index):\n    index = (index - 1) // 2\n    while index >= 0:\n      left = tree[index * 2 + 1]\n      right = tree[index * 2 + 2]\n      if right == None:\n        index = (index - 1) // 2\n        continue\n      tree[index] = right if save[right] > save[left] else left\n      index = (index - 1) // 2\n\n  \n  set_value(0)\n  score = [0] * n\n  last_time = 0\n  for _ in range(r):\n    d, t, x = map(int, input().split())\n    score[tree[0]] += t - last_time\n    last_time = t\n    save[d - 1] += x\n    update(leaf_num + d - 2)\n  \n  score[tree[0]] += l - last_time\n         \n  print(score.index(max(score)) + 1)\nmain()\n"
  },
  {
    "language": "Python",
    "code": "n,r,l=map(int,raw_input().split())\nid_t=[0]*n\nid_x=[0]*n\nlog=[map(int,raw_input().split()) for i in range(r)]\nlog.insert(0,[1,0,0])\nlog.append([1,l,0])\nfor i in range(1,r+2):\n\tid_t[id_x.index(max(id_x))]+=log[i][1]-log[i-1][1]\n\tid_x[log[i][0]-1]+=log[i][2]\nprint id_t.index(max(id_t))+1"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, input().split())\np = [0 for i in range(n + 1)] #得点\np[0] = -10e10\nt = [0 for i in range(n + 1)] #時間\nnow = [1, 0]\nfor _ in range(r):\n    re = list(map(int, input().split()))\n    t[now[0]] += re[1] - now[1]\n    p[re[0]] += re[2]\n    now[1] = re[1]\n    now[0] = p.index(max(p))\nt[now[0]] += l - now[1]\nprint(t.index(max(t)))\n"
  },
  {
    "language": "Python",
    "code": "n,r,l=map(int,raw_input().split())\nlog=[map(int,raw_input().split()) for i in range(r)]\nlog.insert(0,[1,0,0])\nlog.append([1,l,0])\nid_t=[0]*n\nid_x=[0]*n\nmax_id=0\nfor i in range(1,r+2):\n\tcur_id=log[i][0]-1\n\tid_t[max_id]+=log[i][1]-log[i-1][1]\n\tid_x[cur_id]+=log[i][2]\n\tif cur_id==max_id and log[i][2]<0:\n\t\tmax_id=id_x.index(max(id_x))\n\telif id_x[max_id]<id_x[cur_id] or (id_x[max_id]==id_x[cur_id] and max_id>cur_id):\n\t\tmax_id=cur_id\nprint id_t.index(max(id_t))+1"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappush, heapify\n\ndef solve():\n    file_input = sys.stdin\n    N, R, L = map(int, file_input.readline().split())\n    \n    hq = []\n    m = {}\n    for i in range(1, N + 1):\n        team = [0, i, 0]\n        heappush(hq, team)\n        m[i] = team\n    \n    time = 0\n    for line in file_input:\n        d, t, x = map(int, line.split())\n        m[d][0] -= x\n        hq[0][2] += t - time\n        time = t\n        heapify(hq)\n    hq[0][2] += L - time\n    ans_team = max(hq, key = lambda x: (x[2], -x[1]))\n    print(ans_team[1])\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = float('inf')      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return score, team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split(' '))\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n\n    #for i in range(1, N+1):\n    #    add_team(0, i)\n    \n    add_team(0, 1)\n\n    last_time = 0\n    need_pop = True\n    top_score = 0\n\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split(' ')]\n        if need_pop:\n            need_pop = False\n            top_score, team = pop_team()\n            if d != team:\n                add_team(scores[team], team)\n\n        on_tv[team] += (t - last_time)\n\n        scores[d] += x\n        add_team(scores[d], d)\n        if x > 0 and scores[d] > top_score:\n            need_pop = True\n\n        last_time = t\n\n    t = L\n    score, team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = float('inf')      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return score, team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split(' '))\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n\n    for i in range(1, N+1):\n        add_team(0, i)\n\n    last_time = 0\n    need_pop = True\n    top_score = 0\n\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split(' ')]\n        if need_pop:\n            need_pop = False\n            top_score, team = pop_team()\n            if d != team:\n                add_team(scores[team], team)\n\n        on_tv[team] += (t - last_time)\n\n        scores[d] += x\n        add_team(scores[d], d)\n        if x > 0 and scores[d] > top_score:\n            need_pop = True\n\n        last_time = t\n\n    t = L\n    score, team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, raw_input().split())\ntime = [0]*n\nscore = [0]*n\ntop_id = 0\nd = [map(int, raw_input().split()) for _ in range(r)] + [[1,l,0]]\ncur_time = 0\nfor e in sorted(d, key = lambda x: x[1]):\n    cur_id = e[0] - 1\n    time[top_id] += e[1] - cur_time\n    cur_time = e[1]\n    score[cur_id] += e[2]\n    if cur_id == top_id and e[2] < 0:\n        top_id = score.index(max(score))\n    elif score[top_id] < score[cur_id] or (score[top_id] == score[cur_id] and top_id > cur_id):\n        top_id = cur_id\nprint time.index(max(time)) + 1"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, input().split())\nleaf_num = 1\nwhile leaf_num < n:\n  leaf_num *= 2\ntree = [None] * (leaf_num * 2 - 1)\n\nfor i in range(n):\n  tree[leaf_num - 1 + i] = (i, 0)\n\ndef set_value(index):\n  if leaf_num - 1 <= index <= leaf_num * 2 - 2:\n    return tree[index]\n  t1 = set_value(index * 2 + 1)\n  t2 = set_value(index * 2 + 2)\n  if t1 == None and t2 == None:\n    return None\n  else:\n    tree[index] = (t1[0], t1[1])\n    return tree[index]\n\ndef update(index):\n  if index <= -1:return \n  elif leaf_num - 1 <= index <= leaf_num * 2 - 2:\n    update((index - 1) // 2)\n  else:\n    left = tree[index * 2 + 1]\n    right = tree[index * 2 + 2]\n    if right == None:\n      tree[index] = left\n    else:\n      if left[1] < right[1]:\n        tree[index] = right\n      else:\n        tree[index] = left\n    update((index - 1) // 2)\n\nset_value(0)\nscore = [0] * n\nlast_time = 0\nfor _ in range(r):\n  d, t, x = map(int, input().split())\n  index, _ = tree[0]\n  score[index] += t - last_time\n  last_time = t\n  d -= 1\n  tree[leaf_num - 1 + d] = (tree[leaf_num - 1 + d][0], tree[leaf_num - 1 + d][1] + x)\n  update(leaf_num - 1 + d)\n\nscore[tree[0][0]] += l - last_time\nprint(score.index(max(score)) + 1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass Node:\n\n    def __init__(self, x, y):\n        self.score = 0\n        self.team = x\n        self.x = x\n        self.y = y\n        self.l = self.r = None\n\n        if y - x > 1:\n            mid = (x + y) / 2\n            self.l = Node(x, mid)\n            self.r = Node(mid, y)\n\n    def add(self, i, x):\n        if self.x <= i < self.y:\n            if self.l or self.r:\n                self.l.add(i, x)\n                self.r.add(i, x)\n                if self.l.score >= self.r.score:\n                    self.score = self.l.score\n                    self.team = self.l.team\n                if self.r.score > self.l.score:\n                    self.score = self.r.score\n                    self.team = self.r.team\n            else:\n                self.score += x\n\nN, R, L = [int(s) for s in raw_input().split()]\nn = Node(0, N)\nviews = [0] * N\nT = 0\n\nfor s in sys.stdin:\n    d, t, x = [int(s) for s in s.split()]\n    views[n.team] += t - T\n    n.add(d-1, x)\n    T = t\n\nviews[n.team] += L - T\nteam, _ = max(enumerate(views), key=lambda x: x[1])\nprint team + 1"
  },
  {
    "language": "Python",
    "code": "N, R, L = list(map(int, input().split(\" \")))\n\ni = 1\nwhile i<N*2:\n\ti<<=1\n\ntree = [0 for j in range(i)]\n\ntime = [0 for j in range(N)]\n\ntree[0] = -1\n\ndef foo(a,x):\n\tdef bar(k,a,x,l,r):\n\t\tmid = (l+r)//2\n\t\tif r-l == 1:\n\t\t\ttree[k] += x\n\t\t\tif tree[k]>=tree[1] and k-(i//2)<N:\n\t\t\t\ttree[0] = l\n\t\t\tprint(k-i//2,tree[k])\n\t\t\treturn(tree[k])\n\t\telse:\n\t\t\ttree[k] = max(bar(k*2,a,x,l,mid), bar(k*2+1,a,x,mid,r))\n\t\t\treturn(tree[k])\n\n\tbar(1,a,x,0,i//2)\n\t# print(\"tree[0]\",tree[0])\n\treturn(tree[1],tree[0])\n\nnowtime = 0\nnowmax = 0\nnowpoint = 0\n\nfor j in range(R):\n\td,t,x = map(int, input().split(\" \"))\n\td -= 1\n\t# print(nowmax)\n\ttime[nowmax] += t-nowtime\n\tnowtime = t\n\tnewpoint, newmax = foo(d,x)\n\tif nowpoint < newpoint:\n\t\tnowmax = newmax\n\t\tnowpoint = newpoint\n\telif nowpoint == newpoint:\n\t\tnowmax = min(nowmax, newmax)\n\ntime[nowmax] += L-nowtime\n\n# print(tree)\n# print(time)\n\nprint(time.index(max(time))+1)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nfrom collections import defaultdict\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = float('inf')      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split(' '))\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    # scores = [0] * (N + 1)       #  ????????????????????¨?????????\n    scores = defaultdict(int)\n\n    for i in range(1, N+1):\n        add_team(0, i)\n\n    last_time = 0\n    last_score = 0\n    last_team = 1\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split(' ')]\n        if last_score > 0:\n            team = pop_team()\n            if d != team:\n                add_team(scores[team], team)\n        else:\n            team = last_team\n        on_tv[team] += (t - last_time)\n\n        scores[d] += x\n        add_team(scores[d], d)\n\n        last_time = t\n        last_score = x\n        last_team = d\n\n    t = L\n    team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "n,r,l=map(int,raw_input().split())\nlog=[map(int,raw_input().split()) for i in range(r)]\nlog.insert(0,[1,0,0])\nlog.append([1,l,0])\nid_t=[0]*n\nid_x=[0]*n\nmax_id=0\nfor i in range(1,r+2):\n\tcur_id=log[i][0]-1\n\tid_t[max_id]+=log[i][1]-log[i-1][1]\n\tid_x[cur_id]+=log[i][2]\n\tif log[i][2]<0:\n\t\tmax_id=id_x.index(max(id_x))\n\telif id_x[max_id]<id_x[cur_id] or (id_x[max_id]==id_x[cur_id] and max_id>cur_id):\n\t\tmax_id=cur_id\nprint id_t.index(max(id_t))+1"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, input().split())\npoint, time = [], []\nrev = {0: []}\nfor i in range(n):\n    point.append(0)\n    time.append(0)\n    rev[0].append(i)\n\nnow, tv, tmax = 0, 0, 0\nfor i in range(r):\n    d, t, x = map(int, input().split())\n    time[tv] += t - now\n    now = t\n    m = point[d-1]\n    rev[point[d-1]].remove(d-1)\n    point[d-1] += x\n    if point[d-1] in rev:\n        rev[point[d-1]].append(d-1)\n    else:\n        rev[point[d-1]] = [d-1]\n    if tv != d-1: \n        if point[tv] == point[d-1]:\n            tv = min(tv, d-1)\n        elif point[tv] < point[d-1]:\n            tv = d-1\n    elif x < 0:\n        if rev[m] != []:\n            tv = min(rev[m])\n        else:\n            tv = min(rev[max(point)])\n\ntime[tv] += l - now\n\nm = max(time)\ni = 0\nwhile True:\n    if time[i] == m:\n        print(i+1)\n        break\n    i += 1"
  },
  {
    "language": "Python",
    "code": "import sys\n\nN, R, L = [int(s) for s in input().split()]\nviews = [0] * (N + 1)\nscores = [0] * (N + 1)\ntop = 1\nT = 0\n\nfor s in sys.stdin:\n    d, t, x = [int(s) for s in s.split()]\n    views[top] += t - T\n    scores[d] += x\n    if d == top and x < 0:\n        top = scores.index(max(scores))\n    elif scores[d] > scores[top] or (scores[d] == scores[top] and d < top):\n        top = d\n    T = t\n\nviews[top] += L - T\nteam, _ = max(enumerate(views), key=lambda x: x[1])\nprint(team)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\nTLE\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of teams to entries\nREMOVED = 10000000000 #'<removed-team>'      # placeholder for a removed team\n\ndef add_team(team, score=0):\n    'Add a new team or update the score of an existing team'\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    'Mark an existing team as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    'Remove and return the lowest score team. Raise KeyError if empty.'\n    while pq:\n        e = heappop(pq)\n        score, team = e\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team, -score\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????l\n\n    add_team(1, 0)\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        team, _ = pop_team()\n        on_tv[team] += (t - last_time)\n        if d != team:\n            add_team(team, scores[team])\n\n        scores[d] += x\n        add_team(d, scores[d])\n        last_time = t\n\n    t = L\n    team, _ = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\ninput = stdin.readline\n\n\nclass RMQ(object):\n    INT_MAX = 2**31 - 1\n\n    def __init__(self, nn, init_val=0):\n        self.n = 1\n        while self.n < nn:\n            self.n *= 2\n        self.dat = [init_val] * ((2 * self.n)-1)\n\n    def update(self, k, a):\n        # A[k]???a?????´??°?????????????????°???????????¨?????´??°\n        k += (self.n - 1)\n        self.dat[k] = a\n\n        while k > 0:\n            k = (k - 1) // 2        #  ??????index??????\n            self.dat[k] = min(self.dat[k * 2 + 1], self.dat[k * 2 + 2]) #  ???????????¨??????????????????????°?????????????????????´??°\n\n    def query(self, a, b, k, l, r):\n        # [a, b)???????°????????±??????? (0????????§b???????????????)\n        # ??????????????¨?????????query(a, b, 0, 0, n)?????¢??§??????????????????k, l, r???????????????????????´??°?????????\n        if r <= a or b <= l:        #  ?????????????????§??¨??????????????????\n            return RMQ.INT_MAX\n        if a <=l and r <= b:\n            return self.dat[k]           #  ???????????°???????????????????????§????????°????????¨??????????????????????°?????????????????????????\n        else:\n            vl = self.query(a, b, k*2+1, l, (l+r)//2) #  ????????°????????????????°????\n            vr = self.query(a, b, k*2+2, (l+r)//2, r) #  ????????°????????????????°????\n            return min(vl, vr)\n\n    def find(self, s, t):\n        return self.query(s, t+1, 0, 0, self.n)\n\n\n\ndef main(args):\n    N, R, L = map(int, input().split(' '))\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n    scores[0] = float('-inf')\n\n    rq = RMQ(N+1)\n\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split(' ')]\n        top_score = rq.find(1, N)\n        top_team = scores.index(-top_score)\n        on_tv[top_team] += (t - last_time)\n\n        scores[d] += x\n        rq.update(d, -scores[d])\n\n        last_time = t\n\n    t = L\n    top_score = rq.find(1, N)\n    top_team = scores.index(-top_score)\n    on_tv[top_team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of teams to entries\nREMOVED = 10000000000 #'<removed-team>'      # placeholder for a removed team\n\ndef add_team(team, score=0):\n    'Add a new team or update the score of an existing team'\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    'Mark an existing team as REMOVED.  Raise KeyError if not found.'\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    'Remove and return the lowest score team. Raise KeyError if empty.'\n    while pq:\n        e = heappop(pq)\n        score, team = e\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team, -score\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????l\n\n    for i in range(1, N+1):\n        add_team(i, 0)\n\n\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        team, _ = pop_team()\n        on_tv[team] += (t - last_time)\n        add_team(team, scores[team])\n\n        scores[d] += x\n        add_team(d, scores[d])\n        last_time = t\n\n    t = L\n    team, _ = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def findMaxId(id_x):\n\tmax_x=0\n\tmax_id=0\n\tfor i in range(n):\n\t\tif id_x[i]>max_x:\n\t\t\tmax_x=id_x[i]\n\t\t\tmax_id=i\n\treturn max_id\n\t\nn,r,l=map(int,raw_input().split())\nlog=[map(int,raw_input().split()) for i in range(r)]\nlog.insert(0,[1,0,0])\nlog.append([1,l,0])\nid_t=[0]*n\nid_x=[0]*n\nmax_id=0\nfor i in range(1,r+2):\n\tcur_id=log[i][0]-1\n\tid_t[max_id]+=log[i][1]-log[i-1][1]\n\tid_x[cur_id]+=log[i][2]\n\tif cur_id==max_id and log[i][2]<0:\n\t\tmax_id=findMaxId(id_x)\n\telif id_x[max_id]<id_x[cur_id] or (id_x[max_id]==id_x[cur_id] and max_id>cur_id):\n\t\tmax_id=cur_id\nprint id_t.index(max(id_t))+1"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = float('inf')      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n\n    for i in range(1, N+1):\n        add_team(0, i)\n\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        team = pop_team()\n        on_tv[team] += (t - last_time)\n        if d != team:\n            add_team(scores[team], team)\n\n        scores[d] -= x\n        add_team(scores[d], d)\n        last_time = t\n\n    t = L\n    team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappush, heappop, heapreplace\n\ndef solve():\n    file_input = sys.stdin\n    N, R, L = map(int, file_input.readline().split())\n    \n    pq = [[0, i] for i in range(1, N + 1)]\n    m = dict(zip(range(1, N + 1), pq))\n    time = [0] * (N + 1)\n    INVALID = -1\n    \n    pre_t = 0\n    for line in file_input:\n        d, t, x = map(int, line.split())\n        top_team = pq[0]\n        time[top_team[1]] += t - pre_t\n        pre_t = t\n        \n        if top_team[1] == d:\n            top_team[0] -= x\n            if x < 0:\n                heapreplace(pq, top_team)\n        else:\n            scored_team = m[d][:]\n            scored_team[0] -= x\n            heappush(pq, scored_team)\n            m[d][1] = INVALID\n            m[d] = scored_team\n        \n        while pq[0][1] == INVALID:\n            heappop(pq)\n    time[pq[0][1]] += L - pre_t\n    print(time.index(max(time)))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = float('inf')      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team\n    #raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n\n    for i in range(1, N+1):\n        add_team(0, i)\n\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        team = pop_team()\n        on_tv[team] += (t - last_time)\n        if d != team:\n            add_team(scores[team], team)\n\n        scores[d] += x\n        add_team(scores[d], d)\n        last_time = t\n\n    t = L\n    team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>'      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n\n    for i in range(1, N+1):\n        add_team(i, 0)\n\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        team = pop_team()\n        on_tv[team] += (t - last_time)\n        if d != team:\n            add_team(scores[team], team)\n\n        scores[d] -= x\n        add_team(scores[d], d)\n        last_time = t\n\n    t = L\n    team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, input().split())\npoint, time = [], []\nrev = {0: []}\nfor i in range(n):\n    point.append(0)\n    time.append(0)\n    rev[0].append(i)\n\nnow, tv = 0, 0\nfor i in range(r):\n    d, t, x = map(int, input().split())\n    time[tv] += t - now\n    now = t\n    rev[point[d-1]].remove(d-1)\n    point[d-1] += x\n    if point[d-1] in rev:\n        rev[point[d-1]].append(d-1)\n    else:\n        rev[point[d-1]] = [d-1]\n    if tv != d-1: \n        if point[tv] == point[d-1]:\n            tv = min(tv, d-1)\n        elif point[tv] < point[d-1]:\n            tv = d-1\n    elif x < 0:\n        tv = min(rev[max(point)])\n\ntime[tv] += l - now\n\nm = max(time)\ni = 0\nwhile True:\n    if time[i] == m:\n        print(i+1)\n        break\n    i += 1"
  },
  {
    "language": "Python",
    "code": "import sys\n\nclass SegmentTree:\n\n    def __init__(self, N):\n        self.N = N\n        inner = 1\n        while inner < N:\n            inner *= 2\n        self.inner = inner - 1\n        self.nodes = [(0, 0)] * (inner * 2) # (score, team)\n\n    def update(self, d, x):\n        index = self.leaf(d)\n        self.nodes[index] = (self.nodes[index][0] + x, d)\n        while index > 0:\n            p = (index - 1) / 2\n            l = p * 2 + 1\n            r = p * 2 + 2\n            if self.nodes[l][0] >= self.nodes[r][0]:\n                self.nodes[p] = self.nodes[l]\n            if self.nodes[r][0] > self.nodes[l][0]:\n                self.nodes[p] = self.nodes[r]\n            index = p\n\n    def leaf(self, d):\n        return self.inner + d\n\n\nN, R, L = [int(s) for s in raw_input().split()]\nst = SegmentTree(N)\nviews = [0] * N\nscores = [0] * N\nT = 0\n\nfor s in sys.stdin:\n    d, t, x = [int(s) for s in s.split()]\n    views[st.nodes[0][1]] += t - T\n    st.update(d - 1, x)\n    T = t\n\nviews[st.nodes[0][1]] += L - T\nteam, _ = max(enumerate(views), key=lambda x: x[1])\nprint team + 1"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom heapq import *\n\nN, R, L = map(int, input().split())\nscore = [0]*N\npq = []\n\nfor i in range(N):\n    heappush(pq, (-score[i], i))\n\nprev_t = 0\nnow = 0\ntime = [0]*N\n\nfor _ in range(R):\n    di, ti, xi = map(int, input().split())\n    time[now] += ti-prev_t\n    prev_t = ti\n    heappush(pq, (-score[now], now))\n    heappush(pq, (-score[di-1]-xi, di-1))\n    score[di-1] += xi\n    \n    while True:\n        s, idx = heappop(pq)\n        s *= -1\n        \n        if score[idx]==s:\n            break\n\n    now = idx\n\ntime[now] += L-prev_t\nmax_t = 0\nans = -1\n\nfor i in range(N):\n    if time[i]>max_t:\n        max_t = time[i]\n        ans = i+1\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\nTLE\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = '<removed-task>'      # placeholder for a removed task\n\ndef add_team(team, score):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????l\n\n    add_team(1, 0)\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        team = pop_team()\n        on_tv[team] += (t - last_time)\n        if d != team:\n            add_team(team, scores[team])\n\n        scores[d] -= x\n        add_team(d, scores[d])\n        last_time = t\n\n    t = L\n    team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "N, R, L = list(map(int, input().split(\" \")))\n\ni = 1\nwhile i<N*2:\n\ti<<=1\n\ntree = [0 for j in range(i)]\n\ntime = [0 for j in range(N)]\n\n\ndef foo(a,x):\n\tnewmax = -1\n\tdef bar(k,a,x,l,r):\n\t\tmid = (l+r)//2\n\t\tprint(l,mid,r)\n\t\tif r-l == 1:\n\t\t\ttree[k] += x\n\t\t\tnewmax = r\n\t\t\treturn(tree[k])\n\t\telif a<mid:\n\t\t\ttree[k] = max(bar(k*2,a,x,l,mid), tree[k])\n\t\telse:\n\t\t\ttree[k] = max(bar(k*2+1,a,x,mid,r), tree[k])\n\n\tbar(1,a,x,0,i//2)\n\treturn(tree[1],newmax)\n\nnowtime = 0\nnowmax = 0\nnowpoint = 0\n\nfor j in range(R):\n\td,t,x = map(int, input().split(\" \"))\n\ttime[nowmax] += d-nowtime\n\tnowtime = d\n\tnewpoint, newmax = foo(d,x)\n\tif nowpoint < newpoint:\n\t\tnowmax = newmax\n\t\tnowpoint = newpoint\n\telif nowpoint == newpoint:\n\t\tnowmax = min(nowmax, newmax)\n\ntime[nowmax] += L-nowtime\nprint(time.index(max(time)))"
  },
  {
    "language": "Python",
    "code": "N, R, L = list(map(int, input().split(\" \")))\n\ni = 1\nwhile i<N*2:\n\ti<<=1\n\nt = [0 for j in range(N)]\n\ntime = [0 for j in range()]\n\n\ndef foo(a,x):\n\tnewmax = -1\n\tdef bar(k,a,x,l,r):\n\t\tmid = a<(l+r)//2\n\t\tif r-l == 1:\n\t\t\tt[k] += x\n\t\t\tnewmax = r\n\t\t\treturn(t[k])\n\t\telif a<mid:\n\t\t\tt[k] = max(bar(k*2,a,x,l,mid), t[k])\n\t\telse:\n\t\t\tt[k] = max(bar(k*2+1,a,x,mid,r), t[k])\n\n\tbar(1,a,x,0,i//2)\n\treturn(t[1],newmax)\n\nnowtime = 0\nnowmax = 0\nnowpoint = 0\n\nfor i in range(R):\n\td,t,x = map(int, input().split(\" \"))\n\ttime[nowmax] += d-nowtime\n\tnowtime = d\n\tnewpoint, newmax = foo(d,x)\n\tif nowpoint < newpoint:\n\t\tnowmax = newmax\n\t\tnowpoint = newpoint\n\telif nowpoint == newpoint:\n\t\tnowmax = min(nowmax, newmax)\n\ntime[nowmax] += L-nowtime\nprint(time.index(max(time)))\n\n\n\nN, R, L = list(map(int, input().split(\" \")))\n\ni = 1\nwhile i<N*2:\n\ti<<=1\n\nt = [0 for j in range(N)]\n\ntime = [0 for j in range()]\n\n\ndef foo(a,x):\n\tnewmax = -1\n\tdef bar(k,a,x,l,r):\n\t\tmid = a<(l+r)//2\n\t\tif r-l == 1:\n\t\t\tt[k] += x\n\t\t\tnewmax = r\n\t\t\treturn(t[k])\n\t\telif a<mid:\n\t\t\tt[k] = max(bar(k*2,a,x,l,mid), t[k])\n\t\telse:\n\t\t\tt[k] = max(bar(k*2+1,a,x,mid,r), t[k])\n\n\tbar(1,a,x,0,i//2)\n\treturn(t[1],newmax)\n\nnowtime = 0\nnowmax = 0\nnowpoint = 0\n\nfor i in range(R):\n\td,t,x = map(int, input().split(\" \"))\n\ttime[nowmax] += d-nowtime\n\tnowtime = d\n\tnewpoint, newmax = foo(d,x)\n\tif nowpoint < newpoint:\n\t\tnowmax = newmax\n\t\tnowpoint = newpoint\n\telif nowpoint == newpoint:\n\t\tnowmax = min(nowmax, newmax)\n\ntime[nowmax] += L-nowtime\nprint(time.index(max(time)))"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, input().split())\np, s = [0] * n, [0] * n\ntn = 0\nfor _ in range(r):\n    d, t, x = map(int, input().split())\n    s[p.index(max(p))] += t - tn\n    tn = t\n    p[d - 1] += x\ns[p.index(max(p))] += l - tn\nprint(s.index(max(s)) + 1)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = 100000000      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n\n    for i in range(1, N+1):\n        add_team(0, i)\n\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        team = pop_team()\n        on_tv[team] += (t - last_time)\n        if d != team:\n            add_team(scores[team], team)\n\n        scores[d] += x\n        add_team(scores[d], d)\n        last_time = t\n\n    t = L\n    team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0282\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\ninput = stdin.readline\n\n\npq = []                         # list of entries arranged in a heap\nentry_finder = {}               # mapping of tasks to entries\nREMOVED = float('inf')      # placeholder for a removed task\n\ndef add_team(score, team):\n    if team in entry_finder:\n        remove_team(team)\n    entry = [-score, team]\n    entry_finder[team] = entry\n    heappush(pq, entry)\n\ndef remove_team(team):\n    entry = entry_finder.pop(team)\n    entry[-1] = REMOVED\n\ndef pop_team():\n    while pq:\n        score, team = heappop(pq)\n        if team is not REMOVED:\n            del entry_finder[team]\n            return team\n    raise KeyError('pop from an empty priority queue')\n\n\ndef main(args):\n    N, R, L = map(int, input().split())\n    on_tv = [0] * (N + 1)       #  ????????????????????¬???????????£??????????????????????¨?\n    scores = [0] * (N + 1)       #  ????????????????????¨?????????\n\n    for i in range(1, N+1):\n        add_team(0, i)\n\n    last_top = 1\n    last_score = 1\n    last_time = 0\n    for i in range(R):\n        d, t, x = [int(x) for x in input().split()]\n        if last_score > 0:\n            team = pop_team()\n            if d != team:\n                add_team(scores[team], team)\n        else:\n            team = last_team\n        on_tv[team] += (t - last_time)\n\n        scores[d] += x\n        add_team(scores[d], d)\n\n        last_time = t\n        last_score = x\n        last_team = d\n\n    t = L\n    team = pop_team()\n    on_tv[team] += (t - last_time)\n\n    print(on_tv.index(max(on_tv)))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappush, heappop, heapreplace\n \ndef solve():\n    file_input = sys.stdin\n    N, R, L = map(int, file_input.readline().split())\n     \n    pq = [[0, i] for i in range(1, N + 1)]\n    m = dict(zip(range(1, N + 1), pq))\n    time = [0] * (N + 1)\n    INVALID = -1\n     \n    pre_t = 0\n    for line in file_input:\n        d, t, x = map(int, line.split())\n        top_team = pq[0]\n        time[top_team[1]] += t - pre_t\n        pre_t = t\n         \n        if top_team[1] == d:\n            top_team[0] -= x\n            if x < 0:\n                heapreplace(pq, top_team)\n        else:\n            scored_team = m[d][:]\n            scored_team[0] -= x\n            heappush(pq, scored_team)\n            m[d][1] = INVALID\n            m[d] = scored_team\n         \n        while pq[0][1] == INVALID:\n            heappop(pq)\n    time[pq[0][1]] += L - pre_t\n    print(time.index(max(time)))\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "n, r, l = map(int, input().split())\npoint, time = [], []\n\nfor i in range(n):\n    point.append(0)\n    time.append(0)\n\nnow, tv = 0, 0\nfor i in range(r):\n    d, t, x = map(int, input().split())\n    time[tv] += t - now\n    now = t\n    point[d-1] += x\n    m = sorted(point, reverse=True)[0]\n    i = 0\n    while True:\n        if point[i] == m:\n            tv = i\n            break\n        i += 1\n\ntime[tv] += l - now\n\nm = sorted(time, reverse=True)[0]\ni = 0\nwhile True:\n    if time[i] == m:\n        print(i+1)\n        break\n    i += 1"
  },
  {
    "language": "Python",
    "code": "class Node:\n\n    def __init__(self, x, y):\n        self.score = 0\n        self.team = x\n        self.x = x\n        self.y = y\n        self.l = self.r = None\n\n        if y - x > 1:\n            mid = (x + y) / 2\n            self.l = Node(x, mid)\n            self.r = Node(mid, y)\n\n    def add(self, i, x):\n        if self.x <= i < self.y:\n            if self.l or self.r:\n                self.l.add(i, x)\n                self.r.add(i, x)\n                if self.l.score >= self.r.score:\n                    self.score = self.l.score\n                    self.team = self.l.team\n                if self.r.score > self.l.score:\n                    self.score = self.r.score\n                    self.team = self.r.team\n            else:\n                self.score += x\n\nN, R, L = [int(s) for s in raw_input().split()]\nn = Node(0, N)\nviews = [0] * N\nT = 0\n\nfor _ in xrange(R):\n    d, t, x = [int(s) for s in raw_input().split()]\n    views[n.team] += t - T\n    n.add(d-1, x)\n    T = t\n\nviews[n.team] += L - T\nteam, _ = max(enumerate(views), key=lambda x: x[1])\nprint team + 1"
  },
  {
    "language": "Rust",
    "code": "use std::collections::BinaryHeap;\n\nfn main(){\n  let nrl: Vec<usize> = read_vec();\n  let n = nrl[0];\n  let r = nrl[1];\n  let l = nrl[2];\n\n  let mut ptm: usize = 0;\n  let mut pid: usize = 1;\n  let mut cpt: Vec<isize> = vec![0;n+1];\n  let mut ttm: Vec<usize> = vec![0;n+1];\n\n  let mut hp: BinaryHeap<(isize, isize)> = BinaryHeap::new();\n\n  for i in 1 .. n+1 {\n    hp.push((0, -1 * (i as isize)));\n  }\n\n  for _ in 0 .. r {\n    let dtx: Vec<isize> = read_vec();\n    let d = dtx[0] as usize;\n    let t = dtx[1] as usize;\n    let x = dtx[2];\n\n    ttm[pid] += t - ptm;\n\n    cpt[d] += x;\n    hp.push((cpt[d], -1 * (d as isize)));\n\n    let mut mp = *hp.peek().unwrap();\n\n    loop {\n      if cpt[(mp.1 * -1) as usize] == mp.0 { break; }\n      hp.pop();\n      mp = *hp.peek().unwrap();\n    }\n    \n    ptm = t;\n    pid = (mp.1 * -1) as usize;\n  }\n\n  ttm[pid] += l - ptm;\n\n  let mut mid: usize = 1;\n  let mut mt: usize = ttm[1];\n\n  for i in 2 .. n+1 {\n    if mt < ttm[i] {\n      mt = ttm[i];\n      mid = i;\n    }\n  }\n\n  println!(\"{}\", mid);\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  }
]