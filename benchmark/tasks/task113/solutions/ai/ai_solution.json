[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int score;\n} Team;\n\nint main() {\n    int N, L;\n    scanf(\"%d %d\", &N, &L);\n    \n    Team *teams = (Team *)malloc(N * sizeof(Team));\n    for (int i = 0; i < N; i++) {\n        teams[i].id = i + 1;\n        teams[i].score = 0;\n    }\n    \n    int *timeShown = (int *)calloc(N + 1, sizeof(int));\n    int currentMaxId = 1;\n    int currentMaxScore = 0;\n    timeShown[currentMaxId] = 1;\n    \n    for (int i = 0; i < L; i++) {\n        int teamId, change;\n        scanf(\"%d %d\", &teamId, &change);\n        \n        teams[teamId - 1].score += change;\n        \n        if (teams[teamId - 1].score > currentMaxScore || \n            (teams[teamId - 1].score == currentMaxScore && teamId < currentMaxId)) {\n            if (teamId != currentMaxId) {\n                timeShown[currentMaxId] += i + 1 - timeShown[currentMaxId];\n                currentMaxId = teamId;\n                currentMaxScore = teams[teamId - 1].score;\n                timeShown[currentMaxId] = i + 1;\n            }\n            currentMaxScore = teams[teamId - 1].score;\n        }\n    }\n    \n    timeShown[currentMaxId] += L - timeShown[currentMaxId];\n    \n    int maxTime = -1, resultId = 0;\n    for (int i = 1; i <= N; i++) {\n        if (timeShown[i] > maxTime) {\n            maxTime = timeShown[i];\n            resultId = i;\n        } else if (timeShown[i] == maxTime && i < resultId) {\n            resultId = i;\n        }\n    }\n    \n    printf(\"%d\\n\", resultId);\n    \n    free(teams);\n    free(timeShown);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ContestTVDisplay {\n    public static int findLongestTeamOnTV(int L, int[][] logs) {\n        int[] scores = new int[logs.length + 1];\n        int[] tvTime = new int[logs.length + 1];\n        int currentLeader = 0;\n        int lastUpdateTime = 0;\n\n        for (int[] log : logs) {\n            int time = log[0];\n            int teamId = log[1];\n            int scoreChange = log[2];\n\n            // Update TV time for previous leader\n            if (currentLeader != 0) {\n                tvTime[currentLeader] += time - lastUpdateTime;\n            }\n\n            // Update team score\n            scores[teamId] += scoreChange;\n\n            // Find new leader\n            int newLeader = findLeader(scores);\n\n            // Update tracking variables\n            currentLeader = newLeader;\n            lastUpdateTime = time;\n        }\n\n        // Add final TV time if needed\n        if (currentLeader != 0) {\n            tvTime[currentLeader] += L - lastUpdateTime;\n        }\n\n        // Find team with maximum TV time\n        int maxTVTime = 0;\n        int maxTVTeam = 1;\n        for (int i = 1; i < tvTime.length; i++) {\n            if (tvTime[i] > maxTVTime) {\n                maxTVTime = tvTime[i];\n                maxTVTeam = i;\n            }\n        }\n\n        return maxTVTeam;\n    }\n\n    private static int findLeader(int[] scores) {\n        int maxScore = 0;\n        int leader = 1;\n        for (int i = 1; i < scores.length; i++) {\n            if (scores[i] > maxScore) {\n                maxScore = scores[i];\n                leader = i;\n            } else if (scores[i] == maxScore) {\n                leader = Math.min(leader, i);\n            }\n        }\n        return leader;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int L = 10;\n        int[][] logs = {{2, 1, 5}, {4, 2, 3}, {6, 1, 2}, {8, 3, 4}};\n        System.out.println(findLongestTeamOnTV(L, logs));\n    }\n}",
    "timestamp": "2025-08-05 18:40:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int N, L;\n    cin >> N >> L;\n\n    vector<int> scores(N + 1, 0); // 1-based indexing\n    map<int, set<int>> scoreToTeams;\n    for (int i = 1; i <= N; ++i) {\n        scoreToTeams[0].insert(i);\n    }\n\n    int currentMaxScore = 0;\n    int currentTeam = 1;\n    vector<int> displayTime(N + 1, 0);\n    int prevTime = 0;\n\n    for (int i = 0; i < L; ++i) {\n        int team, time;\n        cin >> team >> time;\n\n        // Update display time for the current team\n        if (currentTeam != -1) {\n            displayTime[currentTeam] += time - prevTime;\n        }\n        prevTime = time;\n\n        // Remove team from its current score group\n        int oldScore = scores[team];\n        scoreToTeams[oldScore].erase(team);\n        if (scoreToTeams[oldScore].empty()) {\n            scoreToTeams.erase(oldScore);\n        }\n\n        // Update score and add to new score group\n        scores[team]++;\n        int newScore = scores[team];\n        scoreToTeams[newScore].insert(team);\n\n        // Determine the current team to display\n        if (!scoreToTeams.empty()) {\n            auto it = scoreToTeams.rbegin();\n            int maxScore = it->first;\n            if (maxScore > currentMaxScore || (maxScore == currentMaxScore && *it->second.begin() < currentTeam)) {\n                currentMaxScore = maxScore;\n                currentTeam = *it->second.begin();\n            }\n        } else {\n            currentTeam = -1;\n        }\n    }\n\n    // Add remaining time to the current team\n    if (currentTeam != -1) {\n        displayTime[currentTeam] += L - prevTime;\n    }\n\n    // Find the team with maximum display time\n    int maxDisplayTime = 0;\n    int resultTeam = 1;\n    for (int i = 1; i <= N; ++i) {\n        if (displayTime[i] > maxDisplayTime) {\n            maxDisplayTime = displayTime[i];\n            resultTeam = i;\n        }\n    }\n\n    cout << resultTeam << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_TEAMS 100\n\nint main() {\n    int L, N;\n    scanf(\"%d %d\", &L, &N);\n    \n    int scores[MAX_TEAMS + 1] = {0};\n    int last_leader = 0;\n    int leader_start_time = 0;\n    int max_tv_time = 0;\n    int max_tv_team = 0;\n    \n    int tv_time[MAX_TEAMS + 1] = {0};\n    \n    for (int i = 0; i < N; i++) {\n        int team, points;\n        scanf(\"%d %d\", &team, &points);\n        \n        scores[team] += points;\n        \n        int current_leader = 1;\n        int current_max_score = scores[1];\n        \n        for (int j = 2; j <= L; j++) {\n            if (scores[j] > current_max_score || \n                (scores[j] == current_max_score && j < current_leader)) {\n                current_leader = j;\n                current_max_score = scores[j];\n            }\n        }\n        \n        if (current_leader != last_leader) {\n            if (last_leader != 0) {\n                tv_time[last_leader] += i - leader_start_time;\n            }\n            leader_start_time = i;\n            last_leader = current_leader;\n        }\n    }\n    \n    if (last_leader != 0) {\n        tv_time[last_leader] += N - leader_start_time;\n    }\n    \n    for (int i = 1; i <= L; i++) {\n        if (tv_time[i] > max_tv_time) {\n            max_tv_time = tv_time[i];\n            max_tv_team = i;\n        }\n    }\n    \n    printf(\"%d\\n\", max_tv_team);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, L;\n    cin >> N >> L;\n\n    vector<int> scores(N + 1, 0);\n    vector<int> tv_time(N + 1, 0);\n    int last_top_team = 1;\n    int last_change_time = 0;\n\n    for (int t = 0; t <= L; t++) {\n        int max_score = 0;\n        vector<int> top_teams;\n\n        for (int j = 1; j <= N; j++) {\n            if (scores[j] > max_score) {\n                max_score = scores[j];\n                top_teams = {j};\n            } else if (scores[j] == max_score) {\n                top_teams.push_back(j);\n            }\n        }\n\n        sort(top_teams.begin(), top_teams.end());\n        int current_top_team = top_teams[0];\n\n        if (current_top_team != last_top_team) {\n            tv_time[last_top_team] += t - last_change_time;\n            last_top_team = current_top_team;\n            last_change_time = t;\n        }\n\n        int team, points;\n        if (t < L && cin >> team >> points) {\n            scores[team] += points;\n        }\n    }\n\n    tv_time[last_top_team] += L - last_change_time;\n\n    int max_tv_time = 0;\n    int result_team = 1;\n\n    for (int j = 1; j <= N; j++) {\n        if (tv_time[j] > max_tv_time) {\n            max_tv_time = tv_time[j];\n            result_team = j;\n        }\n    }\n\n    cout << result_team << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ContestTV {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int L = scanner.nextInt();\n        int[] scores = new int[N + 1]; // 1-based indexing\n        int[] tvTime = new int[N + 1];\n        \n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> {\n            if (scores[a] != scores[b]) {\n                return Integer.compare(scores[b], scores[a]);\n            } else {\n                return Integer.compare(a, b);\n            }\n        });\n        \n        for (int i = 1; i <= N; i++) {\n            maxHeap.add(i);\n        }\n        \n        int currentTime = 0;\n        int prevTime = 0;\n        int currentTeam = maxHeap.peek();\n        \n        for (int i = 0; i < L; i++) {\n            int team = scanner.nextInt();\n            int time = scanner.nextInt();\n            currentTime += time;\n            \n            scores[team] += scanner.nextInt();\n            maxHeap.remove(team);\n            maxHeap.add(team);\n            \n            int newTeam = maxHeap.peek();\n            if (newTeam != currentTeam) {\n                tvTime[currentTeam] += currentTime - prevTime;\n                prevTime = currentTime;\n                currentTeam = newTeam;\n            }\n        }\n        \n        tvTime[currentTeam] += currentTime - prevTime;\n        \n        int maxTime = 0;\n        int result = 1;\n        for (int i = 1; i <= N; i++) {\n            if (tvTime[i] > maxTime) {\n                maxTime = tvTime[i];\n                result = i;\n            }\n        }\n        \n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 18:42:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef find_tv_team(log, L):\n    scores = defaultdict(int)\n    events = []\n    \n    for timestamp, delta, team_id in log:\n        events.append((timestamp, delta, team_id))\n\n    events.sort()\n    \n    time_on_tv = defaultdict(int)\n    \n    max_score = -1\n    current_tv_team = None\n    last_time = 0\n    \n    def update_tv_time(current_time):\n        nonlocal last_time, current_tv_team\n        if current_tv_team is not None:\n            time_on_tv[current_tv_team] += current_time - last_time\n        last_time = current_time\n    \n    for event in events:\n        current_time, delta, team_id = event\n    \n        update_tv_time(current_time)\n    \n        scores[team_id] += delta\n        \n        if scores[team_id] > max_score or (scores[team_id] == max_score and team_id < current_tv_team):\n            max_score = scores[team_id]\n            current_tv_team = team_id\n    \n    update_tv_time(L)\n    \n    return max(time_on_tv, key=time_on_tv.get)\n\n# Example call:\n# log = [(2, 10, 'A'), (5, -5, 'A'), (8, 5, 'B')]\n# L = 10\n# print(find_tv_team(log, L))",
    "timestamp": "2025-08-13 00:30:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ProgrammingContest {\n\n    static class Event {\n        int time, teamID, points;\n        Event(int time, int teamID, int points) {\n            this.time = time;\n            this.teamID = teamID;\n            this.points = points;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int T = scanner.nextInt(); // number of teams\n        int E = scanner.nextInt(); // number of events\n        int L = scanner.nextInt(); // contest duration in seconds\n        \n        Event[] events = new Event[E];\n        \n        for (int i = 0; i < E; i++) {\n            int time = scanner.nextInt();\n            int id = scanner.nextInt();\n            int points = scanner.nextInt();\n            events[i] = new Event(time, id, points);\n        }\n        \n        Arrays.sort(events, Comparator.comparingInt(e -> e.time));\n        \n        int[] scores = new int[T + 1];\n        int[] appearanceTime = new int[T + 1];\n        \n        int currentLeader = 0, lastTime = 0;\n        \n        for (Event event : events) {\n            int currentTime = event.time;\n            calculateAppearanceTime(scores, appearanceTime, currentLeader, lastTime, currentTime);\n            scores[event.teamID] += event.points;\n            currentLeader = findCurrentLeader(scores, T);\n            lastTime = currentTime;\n        }\n        \n        calculateAppearanceTime(scores, appearanceTime, currentLeader, lastTime, L);\n        \n        int maxAppearanceTime = 0, resultTeamID = 0;\n        for (int i = 1; i <= T; i++) {\n            if (appearanceTime[i] > maxAppearanceTime) {\n                maxAppearanceTime = appearanceTime[i];\n                resultTeamID = i;\n            }\n        }\n        \n        System.out.println(resultTeamID);\n        scanner.close();\n    }\n    \n    private static void calculateAppearanceTime(int[] scores, int[] appearanceTime, int currentLeader, int lastTime, int currentTime) {\n        if (currentLeader != 0) {\n            appearanceTime[currentLeader] += currentTime - lastTime;\n        }\n    }\n    \n    private static int findCurrentLeader(int[] scores, int teamsCount) {\n        int maxScore = Integer.MIN_VALUE;\n        int leader = 0;\n        for (int i = 1; i <= teamsCount; i++) {\n            if (scores[i] > maxScore || (scores[i] == maxScore && i < leader)) {\n                maxScore = scores[i];\n                leader = i;\n            }\n        }\n        return leader;\n    }\n}",
    "timestamp": "2025-08-13 00:30:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int teamID;\n    int score;\n    int timeOnTV;\n} Team;\n\nint cmp(const void *a, const void *b) {\n    Team *teamA = (Team *)a;\n    Team *teamB = (Team *)b;\n    return teamA->teamID - teamB->teamID;\n}\n\nint findHighestScoreTeam(Team teams[], int n) {\n    int highestScore = -1;\n    int teamID = -1;\n    for (int i = 0; i < n; ++i) {\n        if (teams[i].score > highestScore || (teams[i].score == highestScore && teams[i].teamID < teamID)) {\n            highestScore = teams[i].score;\n            teamID = teams[i].teamID;\n        }\n    }\n    return teamID;\n}\n\nint main() {\n    int n, L;\n    scanf(\"%d %d\", &n, &L);\n\n    Team teams[n];\n    for (int i = 0; i < n; ++i) {\n        teams[i].teamID = i + 1;\n        teams[i].score = 0;\n        teams[i].timeOnTV = 0;\n    }\n\n    int m;\n    scanf(\"%d\", &m);\n\n    int lastSwitchTime = 0;\n    int currentTeamOnTV = findHighestScoreTeam(teams, n);\n\n    for (int i = 0; i < m; ++i) {\n        int t, teamID, deltaScore;\n        scanf(\"%d %d %d\", &t, &teamID, &deltaScore);\n\n        // Update time spent on TV for the currently shown team\n        teams[currentTeamOnTV - 1].timeOnTV += t - lastSwitchTime;\n\n        // Update the score for the team\n        teams[teamID - 1].score += deltaScore;\n\n        // Determine the new team to be shown on TV if any change\n        currentTeamOnTV = findHighestScoreTeam(teams, n);\n        lastSwitchTime = t;\n    }\n\n    // Update the last period on TV till contest end\n    teams[currentTeamOnTV - 1].timeOnTV += L - lastSwitchTime;\n\n    // Find the team that was shown on TV for the longest time\n    int maxTimeOnTV = -1;\n    int teamWithMaxTimeOnTV = -1;\n    for (int i = 0; i < n; ++i) {\n        if (teams[i].timeOnTV > maxTimeOnTV) {\n            maxTimeOnTV = teams[i].timeOnTV;\n            teamWithMaxTimeOnTV = teams[i].teamID;\n        }\n    }\n\n    printf(\"%d\\n\", teamWithMaxTimeOnTV);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:30:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_longest_tv_team(L, logs):\n    scores = {}\n    tv_time = {}\n    current_tv_team = None\n    last_update_time = 0\n\n    for time, team_id, points_change in logs:\n        # Update scores\n        if team_id not in scores:\n            scores[team_id] = 0\n        scores[team_id] += points_change\n\n        # Determine team currently on TV\n        top_score = max(scores.values()) if scores else 0\n        top_teams = [t for t, s in scores.items() if s == top_score]\n        tv_team = min(top_teams) if top_teams else None\n\n        # Update TV time for previous TV team\n        if current_tv_team is not None:\n            tv_time[current_tv_team] = tv_time.get(current_tv_team, 0) + (time - last_update_time)\n\n        current_tv_team = tv_team\n        last_update_time = time\n\n    # Handle final TV time after last log entry\n    if current_tv_team is not None:\n        tv_time[current_tv_team] = tv_time.get(current_tv_team, 0) + (L - last_update_time)\n\n    # Find team with longest TV time\n    return max(tv_time, key=tv_time.get) if tv_time else None",
    "timestamp": "2025-08-13 00:30:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "L, N = map(int, input().split())\nevents = []\nfor _ in range(N):\n    t, id, delta = map(int, input().split())\n    events.append((t, id, delta))\n\n# Initialize scores and current top team\nscores = {}\ncurrent_top = None\ncurrent_top_score = 0\ntop_team_duration = {}\nlast_time = 0\n\nevents.sort()\n\nfor t, id, delta in events:\n    # Update duration for the current top team\n    if current_top is not None:\n        duration = t - last_time\n        if current_top in top_team_duration:\n            top_team_duration[current_top] += duration\n        else:\n            top_team_duration[current_top] = duration\n    \n    # Update the score\n    if id in scores:\n        scores[id] += delta\n    else:\n        scores[id] = delta\n    \n    # Determine the new top team\n    new_top = None\n    max_score = -float('inf')\n    for team in scores:\n        if scores[team] > max_score or (scores[team] == max_score and team < new_top):\n            max_score = scores[team]\n            new_top = team\n    \n    if new_top != current_top:\n        current_top = new_top\n        current_top_score = max_score\n    \n    last_time = t\n\n# Handle the remaining time after the last event\nif current_top is not None:\n    duration = L - last_time\n    if current_top in top_team_duration:\n        top_team_duration[current_top] += duration\n    else:\n        top_team_duration[current_top] = duration\n\n# Find the team with the maximum duration\nmax_duration = -1\nresult_team = None\nfor team in top_team_duration:\n    if top_team_duration[team] > max_duration or (top_team_duration[team] == max_duration and team < result_team):\n        max_duration = top_team_duration[team]\n        result_team = team\n\nprint(result_team)",
    "timestamp": "2025-08-13 00:31:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n, L, m;\n    cin >> n >> L >> m;\n    \n    vector<int> scores(n + 1, 0);\n    map<int, vector<pair<int, int>>> events; // {time, {team, change}}\n    \n    for (int i = 0; i < m; ++i) {\n        int t, id, delta;\n        cin >> t >> id >> delta;\n        events[t].push_back({id, delta});\n    }\n    \n    set<pair<int, int>> leaderboard; // {score, -id}\n    leaderboard.insert({0, -1});\n    vector<int> screen_time(n + 1, 0);\n    \n    int current_time = 0;\n    int current_team = 1;\n    \n    for (auto &event : events) {\n        int time = event.first;\n        \n        // Calculate time team was on TV\n        screen_time[current_team] += time - current_time;\n        current_time = time;\n        \n        // Update scores\n        for (auto &change : event.second) {\n            int id = change.first;\n            int delta = change.second;\n            \n            leaderboard.erase({scores[id], -id});\n            scores[id] += delta;\n            leaderboard.insert({scores[id], -id});\n        }\n        \n        // Determine team to be shown on TV\n        current_team = -leaderboard.rbegin()->second;\n    }\n    \n    // Account for the last segment of time\n    screen_time[current_team] += L - current_time;\n    \n    // Find the team with the maximum screen time\n    int max_time = 0;\n    int result_team = 1;\n    \n    for (int i = 1; i <= n; ++i) {\n        if (screen_time[i] > max_time) {\n            max_time = screen_time[i];\n            result_team = i;\n        }\n    }\n    \n    cout << result_team << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:34"
  }
]