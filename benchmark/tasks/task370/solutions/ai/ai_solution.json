[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nvoid countRealRoots(double a, double b, double c, double d, int *positive, int *negative) {\n    double roots[3];\n    int rootCount = 0;\n    \n    // Calculate discriminant\n    double delta0 = b * b - 3 * a * c;\n    double delta1 = 2 * b * b * b - 9 * a * b * c + 27 * a * a * d;\n    double discriminant = delta1 * delta1 - 4 * delta0 * delta0 * delta0;\n    \n    if (discriminant > 0) {\n        // One real root (and two complex)\n        rootCount = 1;\n    } else if (discriminant == 0) {\n        // Multiple real roots (all roots real and at least two are equal)\n        rootCount = 3;\n    } else {\n        // Three distinct real roots\n        rootCount = 3;\n    }\n    \n    *positive = 0;\n    *negative = 0;\n    \n    if (rootCount == 1) {\n        double C = cbrt((delta1 + sqrt(discriminant)) / 2);\n        if (C == 0) {\n            C = cbrt((delta1 - sqrt(discriminant)) / 2);\n        }\n        double root = -(b + C + delta0 / C) / (3 * a);\n        if (root > 0) {\n            *positive = 1;\n        } else if (root < 0) {\n            *negative = 1;\n        }\n    } else {\n        // For multiple roots, use Sturm's theorem or other methods (simplified here)\n        // This is a simplified approach and may not cover all cases\n        double p = (3 * a * c - b * b) / (3 * a * a);\n        double q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);\n        double k = q * q / 4 + p * p * p / 27;\n        \n        if (k < 0) {\n            // Three real roots\n            double angle = acos(-q / 2 / sqrt(-p * p * p / 27));\n            roots[0] = 2 * sqrt(-p / 3) * cos(angle / 3) - b / (3 * a);\n            roots[1] = 2 * sqrt(-p / 3) * cos((angle + 2 * M_PI) / 3) - b / (3 * a);\n            roots[2] = 2 * sqrt(-p / 3) * cos((angle + 4 * M_PI) / 3) - b / (3 * a);\n            \n            for (int i = 0; i < 3; i++) {\n                if (roots[i] > 0) {\n                    (*positive)++;\n                } else if (roots[i] < 0) {\n                    (*negative)++;\n                }\n            }\n        } else {\n            // One real root\n            double root = cbrt(-q / 2 + sqrt(k)) + cbrt(-q / 2 - sqrt(k)) - b / (3 * a);\n            if (root > 0) {\n                *positive = 1;\n            } else if (root < 0) {\n                *negative = 1;\n            }\n        }\n    }\n}\n\nint main() {\n    double a, b, c, d;\n    scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n    \n    int positive, negative;\n    countRealRoots(a, b, c, d, &positive, &negative);\n    \n    printf(\"%d %d\\n\", positive, negative);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint sign_changes(const vector<double>& coeffs) {\n    int changes = 0;\n    double prev = coeffs[0];\n    for (size_t i = 1; i < coeffs.size(); ++i) {\n        if (prev * coeffs[i] < 0) {\n            changes++;\n        }\n        if (coeffs[i] != 0) {\n            prev = coeffs[i];\n        }\n    }\n    return changes;\n}\n\nvector<double> transform_neg(const vector<double>& coeffs) {\n    vector<double> transformed;\n    for (size_t i = 0; i < coeffs.size(); ++i) {\n        double val = coeffs[i] * pow(-1, i);\n        transformed.push_back(val);\n    }\n    return transformed;\n}\n\nint main() {\n    vector<double> coeffs(4);\n    cin >> coeffs[0] >> coeffs[1] >> coeffs[2] >> coeffs[3];\n\n    int pos_roots = sign_changes(coeffs);\n    vector<double> neg_coeffs = transform_neg(coeffs);\n    int neg_roots = sign_changes(neg_coeffs);\n\n    cout << pos_roots << \" \" << neg_roots << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class CubicRoots {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        double a = scanner.nextDouble();\n        double b = scanner.nextDouble();\n        double c = scanner.nextDouble();\n        double d = scanner.nextDouble();\n\n        int positiveRoots = 0;\n        int negativeRoots = 0;\n\n        if (a != 0) {\n            double[] roots = findRoots(a, b, c, d);\n            for (double root : roots) {\n                if (root > 0) {\n                    positiveRoots++;\n                } else if (root < 0) {\n                    negativeRoots++;\n                }\n            }\n        }\n\n        System.out.println(positiveRoots + \" \" + negativeRoots);\n    }\n\n    private static double[] findRoots(double a, double b, double c, double d) {\n        double delta0 = b * b - 3 * a * c;\n        double delta1 = 2 * b * b * b - 9 * a * b * c + 27 * a * a * d;\n        double discriminant = delta1 * delta1 - 4 * delta0 * delta0 * delta0;\n\n        if (discriminant > 0) {\n            double C = Math.cbrt((delta1 + Math.sqrt(discriminant)) / 2);\n            double root = -1 / (3 * a) * (b + C + delta0 / C);\n            return new double[]{root};\n        } else if (discriminant == 0) {\n            double root1 = (9 * a * d - b * c) / (2 * delta0);\n            double root2 = (4 * a * b * c - 9 * a * a * d - b * b * b) / (a * delta0);\n            if (Math.abs(root1 - root2) < 1e-6) {\n                return new double[]{root1};\n            } else {\n                return new double[]{root1, root2};\n            }\n        } else {\n            double theta = Math.acos(delta1 / (2 * Math.sqrt(delta0 * delta0 * delta0)));\n            double root1 = (-b - 2 * Math.sqrt(delta0) * Math.cos(theta / 3)) / (3 * a);\n            double root2 = (-b + Math.sqrt(delta0) * (Math.cos(theta / 3) + Math.sqrt(3) * Math.sin(theta / 3))) / (3 * a);\n            double root3 = (-b + Math.sqrt(delta0) * (Math.cos(theta / 3) - Math.sqrt(3) * Math.sin(theta / 3))) / (3 * a);\n            return new double[]{root1, root2, root3};\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:15:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "public class CubicRootCounter {\n    public static int[] countRoots(double a, double b, double c, double d) {\n        // Descartes' Rule of Signs\n        int positiveRoots = countSignChanges(a, b, c, d);\n        int negativeRoots = countSignChanges(-a, -b, -c, -d);\n        \n        return new int[]{positiveRoots, negativeRoots};\n    }\n    \n    private static int countSignChanges(double... coefficients) {\n        int signChanges = 0;\n        double prevNonZero = 0;\n        \n        for (double coeff : coefficients) {\n            if (coeff == 0) continue;\n            \n            if (prevNonZero * coeff < 0) {\n                signChanges++;\n            }\n            \n            prevNonZero = coeff;\n        }\n        \n        return signChanges;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int[] roots = countRoots(1, -6, 11, -6);\n        System.out.println(\"Positive roots: \" + roots[0]);\n        System.out.println(\"Negative roots: \" + roots[1]);\n    }\n}",
    "timestamp": "2025-08-05 21:16:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint descartes_rule(double coeffs[], int n) {\n    int sign_changes = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (coeffs[i] * coeffs[j] < 0) {\n                sign_changes++;\n                break;\n            }\n        }\n    }\n    return sign_changes;\n}\n\nint count_roots(double a, double b, double c, double d) {\n    double coeffs_pos[4] = {a, b, c, d};\n    double coeffs_neg[4] = {a, -b, c, -d};\n\n    int pos_roots = descartes_rule(coeffs_pos, 4);\n    int neg_roots = descartes_rule(coeffs_neg, 4);\n\n    return pos_roots + neg_roots;\n}\n\nint main() {\n    double a, b, c, d;\n    scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n    printf(\"%d\\n\", count_roots(a, b, c, d));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nclass CubicRootCounter {\npublic:\n    static int countRoots(double a, double b, double c, double d) {\n        // Handle zero coefficients\n        if (a == 0) {\n            if (b == 0) {\n                if (c == 0) return d == 0 ? -1 : 0;\n                return countQuadraticRoots(b, c, d);\n            }\n            return countQuadraticRoots(a, b, c);\n        }\n        \n        // Descartes' rule of signs for positive roots\n        int posRoots = countSignChanges({a, b, c, d});\n        \n        // Substitute x with -x to check negative roots\n        int negRoots = countSignChanges({a, -b, c, -d});\n        \n        return posRoots + negRoots;\n    }\n    \nprivate:\n    static int countQuadraticRoots(double a, double b, double c) {\n        double discriminant = b * b - 4 * a * c;\n        if (discriminant > 0) return 2;\n        if (discriminant == 0) return 1;\n        return 0;\n    }\n    \n    static int countSignChanges(const std::vector<double>& coeffs) {\n        // Remove zero coefficients\n        std::vector<double> nonZero;\n        for (double coeff : coeffs) {\n            if (coeff != 0) nonZero.push_back(coeff);\n        }\n        \n        // Count sign changes\n        int changes = 0;\n        for (size_t i = 0; i < nonZero.size() - 1; ++i) {\n            if (nonZero[i] * nonZero[i+1] < 0) {\n                changes++;\n            }\n        }\n        \n        return changes;\n    }\n};\n\nint main() {\n    double a, b, c, d;\n    std::cin >> a >> b >> c >> d;\n    \n    int rootCount = CubicRootCounter::countRoots(a, b, c, d);\n    std::cout << rootCount << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom sympy import symbols, Eq, solve\n\ndef count_real_roots(coefficients):\n    x = symbols('x')\n    eq = Eq(coefficients[0] * x**3 + coefficients[1] * x**2 + coefficients[2] * x + coefficients[3], 0)\n    roots = solve(eq, x)\n    \n    positive_count = sum(1 for root in roots if root.is_real and root > 0)\n    negative_count = sum(1 for root in roots if root.is_real and root < 0)\n    \n    return positive_count, negative_count\n\n# Example usage:\ncoefficients = [1, -6, 11, -6]  # Corresponds to the polynomial x^3 - 6x^2 + 11x - 6\npositive_real_roots, negative_real_roots = count_real_roots(coefficients)\nprint(\"Number of positive real roots:\", positive_real_roots)\nprint(\"Number of negative real roots:\", negative_real_roots)",
    "timestamp": "2025-08-13 05:43:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class CubicEquationRoots {\n    \n    public static void main(String[] args) {\n        double a = 1.0; // Coefficients of the cubic equation\n        double b = -6.0;\n        double c = 11.0;\n        double d = -6.0;\n        \n        int[] result = countRealRoots(a, b, c, d);\n        System.out.println(\"Positive Real Roots: \" + result[0]);\n        System.out.println(\"Negative Real Roots: \" + result[1]);\n    }\n    \n    public static int[] countRealRoots(double a, double b, double c, double d) {\n        List<Double> roots = solveCubic(a, b, c, d);\n\n        int positive = 0;\n        int negative = 0;\n\n        for (double root : roots) {\n            if (root > 0) positive++;\n            else if (root < 0) negative++;\n        }\n\n        return new int[]{positive, negative};\n    }\n    \n    public static List<Double> solveCubic(double a, double b, double c, double d) {\n        List<Double> roots = new ArrayList<>();\n        \n        if (a == 0) throw new IllegalArgumentException(\"Coefficient a must not be zero.\");\n        \n        b /= a;\n        c /= a;\n        d /= a;\n        \n        double q = (3.0 * c - (b * b)) / 9.0;\n        double r = (9.0 * b * c - 27.0 * d - 2.0 * b * b * b) / 54.0;\n        double discriminant = q * q * q + r * r;\n\n        if (discriminant > 0) {\n            double sqrtDisc = Math.sqrt(discriminant);\n            double s = Math.cbrt(r + sqrtDisc);\n            double t = Math.cbrt(r - sqrtDisc);\n\n            roots.add(s + t - b / 3);\n        } else {\n            double theta = Math.acos(r / Math.sqrt(-q * q * q));\n            double sqrtNegQ = Math.sqrt(-q);\n\n            roots.add(2 * sqrtNegQ * Math.cos(theta / 3) - b / 3);\n            roots.add(2 * sqrtNegQ * Math.cos((theta + 2 * Math.PI) / 3) - b / 3);\n            roots.add(2 * sqrtNegQ * Math.cos((theta - 2 * Math.PI) / 3) - b / 3);\n        }\n\n        return roots;\n    }\n}",
    "timestamp": "2025-08-13 05:43:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n// Function to evaluate the cubic equation at a given point\ndouble evaluateCubic(double a, double b, double c, double d, double x) {\n    return a * x * x * x + b * x * x + c * x + d;\n}\n\n// Function to find the derivative of the cubic equation\ndouble evaluateDerivative(double a, double b, double c, double x) {\n    return 3 * a * x * x + 2 * b * x + c;\n}\n\n// Using Newton's method to approximate roots\ndouble findRoot(double a, double b, double c, double d, double initial_guess) {\n    double x = initial_guess;\n    double tolerance = 1e-7;\n    double max_iter = 1000;\n    for (int i = 0; i < max_iter; i++) {\n        double fx = evaluateCubic(a, b, c, d, x);\n        double dfx = evaluateDerivative(a, b, c, x);\n        if (fabs(fx) < tolerance) break;\n        if (fabs(dfx) < tolerance) break;\n        x = x - fx / dfx;\n    }\n    return x;\n}\n\nint main() {\n    double a, b, c, d;\n    printf(\"Enter coefficients a, b, c, d (where ax^3 + bx^2 + cx + d = 0): \");\n    scanf(\"%lf %lf %lf %lf\", &a, &b, &c, &d);\n\n    double positiveRoot, negativeRoot;\n    int positiveCount = 0, negativeCount = 0;\n\n    // Check initial guesses: 1, -1 for simplicity\n    positiveRoot = findRoot(a, b, c, d, 1);\n    if (evaluateCubic(a, b, c, d, positiveRoot) == 0 && positiveRoot > 0) {\n        positiveCount++;\n    }\n\n    negativeRoot = findRoot(a, b, c, d, -1);\n    if (evaluateCubic(a, b, c, d, negativeRoot) == 0 && negativeRoot < 0) {\n        negativeCount++;\n    }\n    \n    // Refine with additional steps between large ranges\n    for (double i = 1; i <= 100; i += 0.5) {\n        positiveRoot = findRoot(a, b, c, d, i);\n        if (evaluateCubic(a, b, c, d, positiveRoot) == 0 && positiveRoot > 0) {\n            positiveCount++;\n        }\n        negativeRoot = findRoot(a, b, c, d, -i);\n        if (evaluateCubic(a, b, c, d, negativeRoot) == 0 && negativeRoot < 0) {\n            negativeCount++;\n        }\n    }\n    \n    printf(\"Number of positive real roots: %d\\n\", positiveCount);\n    printf(\"Number of negative real roots: %d\\n\", negativeCount);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:43:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_roots(coefficients):\n    def descartes_rule(coeffs):\n        # Remove leading zero coefficients\n        while coeffs and abs(coeffs[0]) < 1e-10:\n            coeffs = coeffs[1:]\n        \n        # Count sign changes\n        sign_changes = 0\n        for i in range(len(coeffs) - 1):\n            if coeffs[i] * coeffs[i+1] < 0:\n                sign_changes += 1\n        \n        return sign_changes\n    \n    def substitute_negatives(coeffs):\n        # Alternate sign for odd-indexed coefficients\n        modified_coeffs = [\n            coeff * (-1)**(i) for i, coeff in enumerate(coeffs)\n        ]\n        return modified_coeffs\n    \n    # Cubic equation: ax³ + bx² + cx + d = 0\n    a, b, c, d = coefficients\n    \n    # Number of positive roots (Descartes' Rule of Signs)\n    pos_roots = descartes_rule([a, b, c, d])\n    \n    # Number of negative roots by substituting -x\n    neg_roots = descartes_rule(substitute_negatives([a, b, c, d]))\n    \n    return pos_roots, neg_roots",
    "timestamp": "2025-08-13 05:43:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\n\ndef count_real_roots(a, b, c, d):\n    # Coefficients for the cubic equation: ax^3 + bx^2 + cx + d = 0\n    coeffs = [a, b, c, d]\n    \n    # Find all roots (real and complex)\n    roots = np.roots(coeffs)\n    \n    # Count positive and negative real roots\n    positive = 0\n    negative = 0\n    \n    for root in roots:\n        if np.isreal(root):\n            real_root = np.real(root)\n            if real_root > 0:\n                positive += 1\n            elif real_root < 0:\n                negative += 1\n    \n    return positive, negative",
    "timestamp": "2025-08-13 05:43:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nconst double EPSILON = 1e-7;\n\n// Helper function to evaluate cubic polynomial\ndouble evaluateCubic(double a, double b, double c, double d, double x) {\n    return a*x*x*x + b*x*x + c*x + d;\n}\n\n// Function to find a root of a cubic equation using binary search\nbool findRoot(double a, double b, double c, double d, double low, double high, double& root) {\n    if (evaluateCubic(a, b, c, d, low) * evaluateCubic(a, b, c, d, high) > 0) {\n        return false;\n    }\n\n    while (high - low > EPSILON) {\n        double mid = (low + high) / 2;\n        double midValue = evaluateCubic(a, b, c, d, mid);\n\n        if (std::abs(midValue) < EPSILON) {\n            root = mid;\n            return true;\n        } else if (midValue * evaluateCubic(a, b, c, d, low) < 0) {\n            high = mid;\n        } else {\n            low = mid;\n        }\n    }\n    \n    root = (low + high) / 2;\n    return true;\n}\n\n// Function to count positive and negative roots of the cubic equation\nstd::pair<int, int> countRoots(double a, double b, double c, double d) {\n    std::vector<double> roots;\n\n    // Check all intervals for sign changes\n    for (double i = -1e5; i < 1e5; i += 1.0) {\n        double r;\n        if (findRoot(a, b, c, d, i, i + 1.0, r)) {\n            roots.push_back(r);\n        }\n    }\n\n    int positiveRoots = 0;\n    int negativeRoots = 0;\n\n    for (double r : roots) {\n        if (r > EPSILON) positiveRoots++;\n        else if (r < -EPSILON) negativeRoots++;\n    }\n\n    return {positiveRoots, negativeRoots};\n}\n\nint main() {\n    double a, b, c, d;\n    std::cin >> a >> b >> c >> d;\n\n    auto result = countRoots(a, b, c, d);\n    std::cout << \"Positive roots: \" << result.first << std::endl;\n    std::cout << \"Negative roots: \" << result.second << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:27:22"
  }
]